import processing.pdf.*;

void launch (String s) {open(s);}
void launch (String[] s) {open(s);}
 

String[] redo_stack = new String [0];
String[] undo_stack = new String [0];
int undo_pointer = -1; // -1:current, 0: previous, 1, 2, 3, etc.
int maximum_undo_number = 3;





int objExportPrecisionVertex = 6; 
int objExportPrecisionVtexture = 4;
int objExportPolyToPoly = 1; // 0: Exports each polymesh to different individual faces, 1: Exports polymesh to polymesh 

int objExportMaterialLibrary = 1; // 0-1
int objExportBackSides = 1; // 0-1
int objExportCombinedMaterial = 1; // 0-1
int objExportBakingResolution = 16;






String _undefined = "N/A";
float FLOAT_undefined = 1000000000; // it must be a positive big number that is not included in any data

float CubePower = 16; //8; 

double R_earth = 6373000.0;
float FLOAT_R_earth = (float) R_earth;

int Display_EARTH3D = 0;
int Display_EARTH3D_TEXTURE = 1;

int Display_TROPO3D = 0;
int Display_TROPO3D_TEXTURE = 1;

int Display_STAR3D = 0;
int Display_STAR3D_TEXTURE = 1;

int Display_MOON3D = 0;
int Display_MOON3D_TEXTURE = 1;

float planetary_magnification = 2.5; // <<<<<<<<<<


int _EN = 0;
int _FR = 1;
int _LAN = _EN;

int STATION_NUMBER = 23;

String[][] DEFINED_STATIONS = {
                                {"Tehran_11x12", "XX", "IR", "35.6789", "51.413063", "52.5", "1500", "240.0", "", "", "IRN_TEHRAN_XX_IR"},
  
                                {"Montreal_Dorval", "QC", "CA", "45.470556", "-73.740833", "-75", "36", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-INT'L-A_4547_7375_7500", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"},
                                
                                {"Hamedan_Site", "XX", "IR", "34.807", "48.455", "52.5", "1988.5", "240.0", "", "", "IRN_HAMEDAN_XX_IR"},
  
                                {"Berlin_Museum_of_the_20th_Century", "BB", "DE", "52.5080", "13.3685", "15", "36.7", "240.0", "", "", "DEU_Berlin.103840_IWEC"},
  
                                {"Villa-Matina", "XX", "GR", "36.644", "22.383", "15", "0", "240.0", "", "", "GRC_Andravida.166820_IWEC"},                              

                                {"Montreal_Dorval", "QC", "CA", "45.470556", "-73.740833", "-75", "36", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-INT'L-A_4547_7375_7500", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"},
                                {"Place_Bonaventure", "QC", "CA", "45.4995", "-73.5650", "-75", "30", "692.82", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-JEAN-BREBEUF_4550_7362_7500", "CAN_PQ_Montreal.Jean.Brebeuf.716278_CWEC"},
                                {"Ryerson_University", "ON", "CA", "43.6593", "-79.3779", "-75", "95", "461.88", "TORONTO_ISLAND_ON_CA", "ON_TORONTO_4367_7937_7500", "CAN_ON_Toronto.716240_CWEC"}, 
                                {"Financial_District", "ON", "CA", "43.6488", "-79.3817", "-75", "86", "692.82", "TORONTO_ISLAND_ON_CA", "ON_TORONTO-ISLAND-A_4363_7940_7500", "CAN_ON_Toronto.716240_CWEC"},

                                {"CALGARY", "AB", "CA", "51.113889", "-114.02", "-120", "1084.1", "240.0", "CALGARY_INTL_AB_CA", "AB_CALGARY-INT'L-A_5110_11402_10500", "CAN_AB_Calgary.718770_CWEC"}, 
                                {"EDMONTON", "AB", "CA", "53.31", "-113.579444", "-120", "723.3", "240.0", "EDMONTON_INTL_A_AB_CA", "AB_EDMONTON-INT'L-A_5332_11358_10500", "CAN_AB_Edmonton.711230_CWEC"},  
                                {"HALIFAX", "NS", "CA", "44.881111", "-63.508611", "-60", "145.4", "240.0", "HALIFAX_INTL_AIRPORT_NS_CA", "NS_HALIFAX-INT'L-A_4488_6352_6000", "CAN_NS_Shearwater.716010_CWEC"},  
                                {"OTTAWA", "ON", "CA", "45.383333", "-75.716667", "-75", "79.2", "240.0", "OTTAWA_INTL_ON_CA", "ON_OTTAWA-CDA_4538_7572_7500", "CAN_ON_Ottawa.716280_CWEC"}, 
                                {"QUEBEC", "QC", "CA", "46.803611", "-71.381667", "-75", "60", "240.0", "QUEBEC_QC_CA", "QC_QUEBEC-A_4680_7137_7500", "CAN_PQ_Quebec.717140_CWEC"}, 
                                {"SUDBURY", "ON", "CA", "46.625556", "-80.797778", "-75", "348.4", "240.0", "SUDBURY_ON_CA", "ON_SUDBURY-A_4662_8080_7500", "CAN_ON_North.Bay.717310_CWEC"}, 
                                {"TORONTO-ISLAND", "ON", "CA", "43.6275", "-79.396111", "-75", "76.8", "240.0", "TORONTO_ISLAND_ON_CA", "ON_TORONTO-ISLAND-A_4363_7940_7500", "CAN_ON_Toronto.716240_CWEC"}, 
                                {"TORONTO-PEARSON", "ON", "CA", "43.676667", "-79.630556", "-75", "173.4", "240.0", "TORONTO_PEARSON_INTL_ON_CA", "ON_TORONTO-PEARSON-INT'L_4367_7962_7500", "CAN_ON_Toronto.716240_CWEC"}, 
                                {"VANCOUVER_Harbour", "BC", "CA", "49.295353", "-123.121869", "-120", "2.5", "240.0", "VANCOUVER_INTL_BC_CA", "BC_VANCOUVER-INT'L_4925_12325_12000", "CAN_BC_Vancouver.718920_CWEC"}, 
                                {"WINNIPEG", "MB", "CA", "49.91", "-97.24", "-90", "238.7", "240.0", "WINNIPEG_INTL_MB_CA", "MB_WINNIPEG-INT'L-A_4990_9723_9000", "CAN_MB_Winnipeg.718520_CWEC"}, 
                                
                                {"BOSTON", "MA", "US", "42.35843", "-71.05978", "-75", "15.0", "240.0", "BOSTON_MA_US", "WY2-filename", "USA_MA_Boston-Logan.Intl.AP.725090_TMY3"}, 
                                {"CHICAGO", "IL", "US", "41.878113", "-87.6298", "-90", "181.0", "240.0", "CHICAGO_IL_US", "WY2-filename", "USA_IL_Chicago-Midway.AP.725340_TMY3"}, 
                                {"DENVER", "CO", "US", "39.737568", "-104.98472", "-105", "1608.0", "240.0", "DENVER_CO_US", "WY2-filename", "USA_CO_Golden-NREL.724666_TMY3"}, 
                                {"HOUSTON", "TX", "US", "29.760193", "-95.36939", "-90", "15.0", "240.0", "HOUSTON_TX_US", "WY2-filename", "USA_TX_Houston-William.P.Hobby.AP.722435_TMY3"}, 
                                {"LAS_VEGAS", "NV", "US", "36.16994", "-115.13983", "-120", "611.0", "240.0", "LAS_VEGAS_NV_US", "WY2-filename", "USA_NV_Las.Vegas-McCarran.Intl.AP.723860_TMY3"}, 
                                {"LOS_ANGELES", "CA", "US", "34.052235", "-118.24368", "-120", "87.0", "240.0", "LOS_ANGELES_CA_US", "WY2-filename", "USA_CA_Hawthorne-Jack.Northrop.Field.722956_TMY3"}, 
                                {"MIAMI", "FL", "US", "25.789097", "-80.20404", "-75", "3.0", "240.0", "MIAMI_FL_US", "WY2-filename", "USA_FL_Miami.Intl.AP.722020_TMY3"}, 
                                {"NEW_YORK_CITY", "NY", "US", "40.712784", "-74.00594", "-75", "10.0", "240.0", "NEW_YORK_CITY_NY_US", "WY2-filename", "USA_NY_New.York-Central.Park.725033_TMY3"}, 
                                {"WASHINGTON", "DC", "US", "38.907192", "-77.03687", "-75", "22.0", "240.0", "WASHINGTON_DC_US", "WY2-filename", "USA_VA_Arlington-Ronald.Reagan.Washington.Natl.AP.724050_TMY3"}, 
                                
                                {"BRASILIA", "XX", "BR", "-29.176456", "-51.22032", "-45", "774.0", "240.0", "BRASILIA_XX_BR", "WY2-filename", "BRA_Santa.Maria.839360_SWERA"}, 
                                {"RIO_DE_JANEIRO", "XX", "BR", "-22.893467", "-43.21391", "-45", "6.0", "240.0", "RIO_DE_JANEIRO_XX_BR", "WY2-filename", "BRA_Rio.de.Janeiro-Santos.Dumont.837550_SWERA"}, 
                                {"SAO_PAULO", "XX", "BR", "-23.5500", "-46.6333", "-45", "768.0", "240.0", "SAO_PAULO_XX_BR", "WY2-filename", "BRA_Bom.Jesus.da.Lapa.832880_SWERA"}, 
                                
                                {"MEXICO_CITY", "DF", "MX", "19.432608", "-99.13321", "-105", "2230.0", "240.0", "CIUDAD_DE_MEXICO_DF_MX", "WY2-filename", "MEX_Mexico.City.766790_IWEC"}, 
                                {"HAVANA", "XX", "CU", "23.05407", "-82.34519", "-75", "93.0", "240.0", "HAVANA_XX_CU", "WY2-filename", "CUB_Havana-Jose.Marti.782240_SWERA"}, 
                                {"SANTO_DOMINGO", "XX", "DO", "18.482439", "-69.96518", "-75", "62.0", "240.0", "SANTO_DOMINGO_XX_DO", "WY2-filename", "PRI_Mayaguez-Eugenio.Maria.de.Hostos.AP.785145_TMY3"}, 
                                {"SAN_SALVADOR", "XX", "SV", "13.679502", "-89.21397", "-90", "796.0", "240.0", "SAN_SALVADOR_XX_SV", "WY2-filename", "SLV_San.Salvador-Ilopango.786630_SWERA"}, 
                                {"CARACAS", "XX", "VE", "10.960712", "-63.920437", "-60", "32.0", "240.0", "CARACAS_XX_VEe", "WY2-filename", "VEN_Caracas.804150_IWEC"}, 
                                {"BOGOTA", "XX", "CO", "7.894716", "-72.504616", "-75", "302.0", "240.0", "BOGOTA_XX_CO", "WY2-filename", "COL_Bogota.802220_IWEC"}, 
                                {"GUAYAQUIL", "XX", "EC", "-2.1241937", "-79.59123", "-75", "11.0", "240.0", "GUAYAQUIL_XX_EC", "WY2-filename", "ECU_Quito.840710_IWEC"}, 
                                {"LIMA", "XX", "PE", "-12.032012", "-76.92987", "-75", "336.0", "240.0", "LIMA_XX_PE", "WY2-filename", "PER_Lima.846280_IWEC"}, 
                                {"ANTOFAGASTA", "XX", "CL", "-23.65", "-70.4", "-75", "13.0", "240.0", "ANTOFAGASTA_XX_CL", "WY2-filename", "CHL_Antofagasta.854420_IWEC"}
                              
                           
                              };

    
int Selected_STATION = STATION_NUMBER;
int LOAD_STATION = 0; 


int STUDY_i_start = 0;
int STUDY_i_end = 23;

int STUDY_j_start = 0; // constant
int STUDY_j_end = 6; //2; //16; // Variable


int Load_Default_Models = 0; //3;//0; //3; //5;


int addToLastPolymesh = 1;



int selected_posVector = 2; // 0:X, 1:Y, 2:Z, 3: All
int selected_rotVector = 2; // 0:X, 1:Y, 2:Z
int selected_scaleVector = 2; // 0:X, 1:Y, 2:Z, 3:All

float selected_posValue = 0;
float selected_rotValue = 0;  
float selected_scaleValue = 0; 

int selection_alignX = 0;
int selection_alignY = 0;
int selection_alignZ = 0;


int selectedPolymesh_displaySolarPivots = 1;
int selectedPolymesh_displayPivot = 1;
int selectedPolymesh_displayEdges = 1; //0;
int selectedPolymesh_displayBox = 1;

int selectedFace_displayEdges = 1;
int selectedFace_displayVertexCount = 1;
int selectedVertex_displayVertices = 1;
 

int selectedObject2D_displayEdges = 1;
int selectedFractal_displayEdges = 1;
int selectedSection_displayEdges = 1;

int[] selectedSection_numbers = {0};
int[] selectedFractal_numbers = {0};
int[] selectedObject2D_numbers = {0};
int[] selectedPolymesh_numbers = {0};
int[] selectedFace_numbers = {0};
int[] selectedVertex_numbers = {0};

float softSelection_Power = 1;
float softSelection_Radius = 2; // 2 = 2m

int addNewSelectionToPreviousSelection = 0;

float[][] allVertices = {{0,0,0}};
int[][] allFaces = {{0,0,0}};
int[][] allFaces_MTLV = {{0,0,0,0}}; // 0:material, 1:teselation, 2:layer, 3:visibility

int[][] allPolymesh_Faces = {{0,0}}; // start face - end face
int[][] allPolymesh_Solids = {{0,0}}; // start solid - end solid

float[][] allPolymesh_SolarPivotXYZ = {{0,0,0}}; 
int[][] allPolymesh_SolarPivotType = {{0}}; // 0: no solar rotation, 1: allow X-axis solar rotation, 2: allow X-axis solar rotation, 3: allow Z-axis solar rotation 4: free solar rotation (double axis tracking)




float[][] allObject2D_XYZS = {{0,0,0,0}};
int[] allObject2D_MAP = {0};
int allObject2D_num = 0; 



float[][] allFractal_XYZSRA = {{0,0,0,0,0,0}};
int[] allFractal_Type = {0};
int[] allFractal_DegreeMin = {0};
int[] allFractal_DegreeMax = {0};
int[] allFractal_Seed = {0};
float[] allFractal_TrunkSize = {0};
float[] allFractal_LeafSize = {0};
int allFractal_num = 0; 


float[][] allSection_UVERAB = {{0,0,0,0,0,0}};
int[] allSection_Type = {0};
int[] allSection_RES1 = {0};
int[] allSection_RES2 = {0};
int allSection_num = 0;
PImage[] allSection_SpatialImpact = {createImage(2, 2, RGB)};
PImage[][] allSection_SolarImpact = new PImage[1][(1 + STUDY_j_end - STUDY_j_start)];
{
  int i = 0;
  for (int j = STUDY_j_start; j <= STUDY_j_end; j += 1) { 
    allSection_SolarImpact[i][j] = createImage(2, 2, RGB);
  } 
}


int Display_Output_in_Explorer = 1;

int Display_Building_Model = 1;
int Display_Trees_People = 1;
int Display_FractalPlant = 1;
int Display_Leaves = 1;

int Display_Sections = 1;



int defaultMaterial = 7;
int defaultTessellation = 0;
int defaultLayer = 0;
int defaultVisibility = 1;
int defaultSolarPivotType = 0;




int Create_Default_Material = 7; //0;
int Create_Default_Tessellation = 0;
int Create_Default_Layer = 0;
int Create_Default_Visibility = 1; // 1: view 0: hide -1:freeze 

int Create_Default_SolarPivotType = 0;

float Modify_Input_WeldTreshold = 0.1; 

int Modify_Input_TessellateRows = 5;
int Modify_Input_TessellateColumns = 3;

float Modify_Input_OffsetAmount = 1.0; // 1 = 1m

float Modify_Input_OpenningDepth = 1; // 1 = 1m 
float Modify_Input_OpenningArea = 0.25; //0-1, 0.25: 25% of the face area (i.e. for parallel openings) 
float Modify_Input_OpenningDeviation = 0.5; //0-1, 0.5: middle of the face edge (could be applied in rotated openning)


float Create_Input_Length = 10;
float Create_Input_Width = 10;
float Create_Input_Height = 10;


float Create_Input_Volume = 0; //3000;

float Create_Input_Orientation = 360; //0; // 360: random




float Create_Input_powX = CubePower; 
float Create_Input_powY = CubePower; 
float Create_Input_powZ = CubePower; 

float Create_Input_powAll = 8;
int Create_Input_powRnd = 0;

int Create_Sphere_Degree = 2; //4;

int Create_Cylinder_Degree = 24; 



int Create_Poly_Degree = 6;


int Create_Mesh_Poly = 0;
int Create_Mesh_Extrude = 0;
int Create_Mesh_Tri = 0;
int Create_Mesh_Quad = 0;
int Create_Mesh_House = 0; 
int Create_Mesh_SuperOBJ = 0;
int Create_Mesh_Parametric = 0;
int Create_Mesh_Person = 0;
int Create_Mesh_Plant = 0;
int Create_Fractal_Plant = 0;


int Create_Mesh_Parametric_Type = 0;
int Create_Mesh_Person_Type = 0;
int Create_Mesh_Plant_Type = 0;
int Create_Fractal_Plant_Type = 0;
int Create_Fractal_Plant_DegreeMin = 1; //2; 
int Create_Fractal_Plant_DegreeMax = 5; //6; //8;
int Create_Fractal_Plant_Seed = -1; // -1:random, 0-99 choice
float Create_Fractal_Plant_TrunkSize = 1; //0.5;
float Create_Fractal_Plant_LeafSize = 1; //1; 

int Work_with_2D_or_3D = 3; // 1:Fractals 2:2D, 3:3D, 4:Face, 5:Vertex, 6:Soft 7:Solid 8:Section

int Create_Mesh_or_Solid = 1; // 1:Mesh 2:Solid

int View_Select_Create_Modify = 17; //-17:DistMouseXY/TargetRollXY/TargetRollZ -16:PanY/TargetRollXY/TargetRollZ -15:PanX/TargetRollXY/TargetRollZ -14:Pan/TargetRoll -13:CameraDistance/TargetRollXY/TargetRollZ -12:TargetRoll/Pan -11:TargetRollXY/TargetRollZ -10:TargetRoll/Pan -9:TargetRollXY/TargetRollZ -8:AllModelSize -7:SkydomeSize -6:Truck/Orbit -5:3DModelSize/Pan/TargetRoll -4:Pan/Height -3:Zoom/Orbit/Pan -2:RectSelect -1:PickSelect 0:Create 1:Move 2:Scale 3:Rotate 4:Seed/Material 5:Tessellation 6:Layer 7:Visibility 8:DegreeMax 9:DegreeDif 10:DegreeMin 11:TrunkSize 12:LeafSize 13:AllFractalProps 14:SolarPivot 15:FaceNormal 16:FaceFirstVertex 17:PickStudyPlane
int View_XYZ_ChangeOption = 0; // 0-1
int Modify_Object_Parameters = 0; //to modify objects with several parameters e.g. fractal trees





int Display_SWOB_points = 0; // 0-2
int Display_SWOB_nearest = 0;

int Display_NAEFS_points = 0; // 0-2
int Display_NAEFS_nearest = 0;

int Display_CWEEDS_points = 0; // 0-2
int Display_CWEEDS_nearest = 0;

int Display_EPW_points = 1; // 0-2
int Display_EPW_nearest = 1;

int FRAME_record_AUTO = 0;
int FRAME_record_JPG = 0;
int FRAME_click_JPG = 0;
int FRAME_drag_JPG = 0;

int SpatialImpact_record_PDF = 0;
int SpatialImpact_record_JPG = 0;

int SolarImpact_record_JPG = 0;  


int Ensemble_Audio_Output = 0; // inactive
int Launch_External_Simulation = 0; // inactive
int Launch_External_Hardware = 0; // inactive


//-------------------------------

float SpatialImpact_Wspd = 8; //8.0; // (8m/s = 30 km/h) 
float SpatialImpact_Wdir = 180.0;

float SpatialImpact_Power = 1.0; //2.0; //3.0; // 1/2/3 
float SpatialImpact_Grade = 0.02; //1.0; //0.1; //10.0; //contour lines 

float GlobalAlbedo = 0; // 0-100

float MAX_SHADING_DIST = 250; // the biggest object should be 250

int SavedScreenShots = 0;

float interpolation_weight = 0.5;// 0 = linear distance interpolation, 1 = square distance interpolation, 5 = nearest

float GlobeRES = 2.5; //1, 2.5, 5


int Climatic_solar_forecast = 0; //                                   Used for solar radiation only
int Climatic_weather_forecast = 0; // 0:linear 1:average 2:sky-based. Used for some parameters namely: air temperature, humidity

int automated = 0; //0: User interface, 1: Automatic

//String CLIMATE_EPW_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_EPW";
String CLIMATE_EPW_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_EPW_WORLD";

//String CLIMATE_WY2_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED_EMPTY"; 
//String CLIMATE_WY2_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED_90s"; 
String CLIMATE_WY2_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED";

//String ENSEMBLE_directory = "C:/SOLARCHVISION_2015/Input/WeatherForecast/FORECAST_NAEFS";
String ENSEMBLE_directory = "C:/SOLARCHVISION_2015/Input/WeatherForecast/FORECAST_NAEFS_Download";

String OBSERVED_directory = "C:/SOLARCHVISION_2015/Input/WeatherRealTime/OBSERVATION_SWOB_EMPTY";
//String OBSERVED_directory = "C:/SOLARCHVISION_2015/Input/WeatherRealTime/OBSERVATION_SWOB";

int MODEL_RUN = 0; //12; 

int _YEAR = year(); 
int _MONTH = month();
int _DAY = day(); 
int _HOUR = MODEL_RUN; //hour(); 
int BEGIN_DAY;
float _DATE;

void SOLARCHVISION_RecordFrame () {
  
  saveFrame(ScreenShotFolder + "/" + CreateStamp(1) + "Screen.jpg");
}

String CreateStamp (int _add) {
  
  SavedScreenShots += _add; 
  
  return nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + nf(hour(), 2) + "_IMG" + nf(SavedScreenShots , 4);
}







String MAKE_Filenames (String beginName) {

  String My_Filenames = ScreenShotFolder + "/" + beginName;  
  
  return My_Filenames;
}

/*

String MAKE_Filenames (String beginName) {
  String My_Filenames = "";
  String Main_name = MAKE_mainname();
  
  My_Filenames = DiagramsFolder + "/";
  My_Filenames += nf(_YEAR, 2) + "-" + nf(_MONTH, 2) + "-" + nf(_DAY, 2) + "/";
  My_Filenames += databaseString[impacts_source] + "/";  

  My_Filenames += beginName;
  My_Filenames += DEFINED_STATIONS[STATION_NUMBER][0] + "_";
  
  My_Filenames += LAYERS_Title[STUDY_drw_Layer][_EN] + "_" ;
  
  My_Filenames += Main_name;
  
  //My_Filenames += "S" + nf(100 + STUDY_setup, 3);
  //My_Filenames += "V" + nf(camera_variation, 0); 
  
  //My_Filenames += nf(draw_data_lines, 0);
  //My_Filenames += nf(draw_sorted, 0);
  //My_Filenames += nf(draw_normals, 0);
  //My_Filenames += nf(draw_probs, 0);
  
  My_Filenames += sky_scenario_file[sky_scenario];

  return My_Filenames;
}


*/

String MAKE_mainname () {
  
  String s = "";

  if (impacts_source == databaseNumber_ENSEMBLE) s = nf(_YEAR, 2) + nf(_MONTH, 2) + nf(_DAY, 2) + "_" + nf(STUDY_j_end, 0) + "dayFORECAST_";
  
  return s;

}

String get_SpatialImpact_Filename () {
  
  return DiagramsFolder + "/" + nf(_YEAR, 2) + "-" + nf(_MONTH, 2) + "-" + nf(_DAY, 2) + "/" + databaseString[impacts_source] + "/Impacts/SpatialImpact" + nf(SpatialImpact_sectionType, 0) + "h" + nf(int(roundTo(SpatialImpact_Elevation[SpatialImpact_sectionType], 1)), 4) + "r" + nf(int(roundTo(SpatialImpact_Rotation[SpatialImpact_sectionType], 1)), 3) + "p" + nf(SpatialImpact_Power, 2, 2).replace(".", "_") + "m" + nf(SpatialImpact_Grade, 2, 2).replace(".", "_");
}

String get_SolarImpact_Filename () {
  
  return DiagramsFolder + "/" + nf(_YEAR, 2) + "-" + nf(_MONTH, 2) + "-" + nf(_DAY, 2) + "/" + databaseString[impacts_source] + "/Impacts/SolarImpact" + nf(SolarImpact_sectionType, 0) + "h" + nf(int(roundTo(SolarImpact_Elevation, 1)), 4) + "r" + nf(int(roundTo(SolarImpact_Rotation, 1)), 3);
}




String LocationName;
String LocationProvince;
float LocationLatitude;
float LocationLongitude;
float LocationTimeZone;
float LocationElevation;
float Delta_NOON;

float HeightAboveGround = 0; //2.5; // <<<<<<<<<



float LocationLatitude_step = 0.1;
float LocationLongitude_step = 0.1;
float LocationElevation_step = 1.0;

int save_frame_number = 0;

int STUDY_record_JPG = 0;
int STUDY_record_PDF = 0;
int STUDY_record_AUTO = 0;

int WORLD_record_JPG = 0;
int WORLD_record_PDF = 0;
int WORLD_record_AUTO = 0;

int WIN3D_record_JPG = 0;
int WIN3D_record_AUTO = 0;


int STUDY_max_j_end_parameters = 16; // Constant
int STUDY_max_j_end_observations = 0; // Variable

float per_day = 61; //1; //45; //61; //30.5;
int num_add_days = 1; //30;//per_day; // it should be set up to 1 in order to plot only one day  

int CLIMATE_EPW_start = 1; 
int CLIMATE_EPW_end = 1;

int CLIMATE_WY2_start = 1953;
int CLIMATE_WY2_end = 2005;

int ENSEMBLE_start = 1; 
int ENSEMBLE_end = 43; // NAEFS:1-43 we append HRDPS or other scenarions at the end  of this list

int numberOfNearestStations_ENSEMBLE = 1;  // <<<<<<<<

int[] nearest_Station_ENSEMBLE = new int [numberOfNearestStations_ENSEMBLE];
float[] nearest_Station_ENSEMBLE_dist = new float [numberOfNearestStations_ENSEMBLE];


int numberOfNearestStations_OBSERVED = 5;  // <<<<<<<<

int OBSERVED_start = 1; 
int OBSERVED_end = numberOfNearestStations_OBSERVED;

int[] nearest_Station_OBSERVED = new int [numberOfNearestStations_OBSERVED];
float[] nearest_Station_OBSERVED_dist = new float [numberOfNearestStations_OBSERVED];




int Sample_Year_start = 1996; 
int Sample_Year_end = 2005; 

int Sample_Member_start = 1;
int Sample_Member_end = 43;

int Sample_Station_start = 1; 
int Sample_Station_end = 1;

float[][][][] CLIMATE_EPW;

float[][][][] CLIMATE_WY2;

float[][][][] ENSEMBLE;
int[][][][] ENSEMBLE_Flag;

float[][][][] OBSERVED;
int[][][][] OBSERVED_Flag;


int Load_CLIMATE_EPW = 1;
int Load_CLIMATE_WY2 = 0;
int Load_ENSEMBLE = 0;
int Load_OBSERVED = 0;
int Download_OBSERVED = 0;
int Download_ENSEMBLE = 1;

int Download_AERIAL = 0;


int GRIB2_YEAR; 
int GRIB2_MONTH; 
int GRIB2_DAY; 
int GRIB2_RUN;

int AERIAL_num = 4 * (1 + 6 + 12); // the number of nearest points on the path we want to extract the data 

float AERIAL_Center_Longitude = FLOAT_undefined;
float AERIAL_Center_Latitude = FLOAT_undefined;

float[][] AERIAL_Locations;

float[][][][] AERIAL;
int[][][][] AERIAL_Flag;

int GRIB2_Hour_Start = 0;
int GRIB2_Hour_End = 0; //48;
int GRIB2_Hour_Step = 6; //1;

int GRIB2_Layer_Start = 4; //_cloudcover;
int GRIB2_Layer_End = 8; //_drybulb;
int GRIB2_Layer_Step = 1;

int GRIB2_Hour;
int GRIB2_Layer;




String[][] GRIB2_DOMAINS = {
                               {"GEPS", "ensemble/naefs/grib2/raw", "CMC_naefs-geps-raw", "latlon1p0x1p0", "_allmbrs.grib2", "100"}
                             , {"GDPS", "model_gem_global/25km/grib2/lat_lon", "CMC_glb", "latlon.24x.24", ".grib2", "20"}
                             , {"RDPS", "model_gem_regional/10km/grib2", "CMC_reg", "ps10km", ".grib2", "10"}
                             , {"HRDPS", "model_hrdps/east/grib2", "CMC_hrdps_east", "ps2.5km", "-00.grib2", "2.5"} 
                             , {"WAVE", "model_wave/great_lakes/superior/grib2", "CMC_rdwps_lake-superior", "latlon0.05x0.0", ".grib2", "5"}                             
                             };



// http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/grib2/raw           /00/000/CMC_naefs-geps-raw_TMP_TGL_2m_latlon1p0x1p0_2015081800_P000_allmbrs.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_global/25km/grib2/lat_lon/00/000/CMC_glb           _TMP_TGL_2_latlon.24x.24 _2015081800_P000.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_regional/10km/grib2      /00/000/CMC_reg           _TMP_TGL_2_ps10km        _2015083100_P000.grib2 
// http://dd.weatheroffice.ec.gc.ca/model_hrdps/east/grib2             /00/000/CMC_hrdps_east    _TMP_TGL_2_ps2.5km       _2015081800_P000-00.grib2
  
  

// http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/grib2/raw/00/000/CMC_naefs-geps-raw_TMP_TGL_2m_latlon1p0x1p0_2015081800_P000_allmbrs.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_global/25km/grib2/lat_lon/00/000/CMC_glb_TMP_TGL_2_latlon.24x.24_2015081800_P000.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_regional/10km/grib2/00/000/CMC_reg_TMP_TGL_2_ps10km_2015083100_P000.grib2 
// http://dd.weatheroffice.ec.gc.ca/model_hrdps/east/grib2/00/000/CMC_hrdps_east_TMP_TGL_2_ps2.5km_2015081800_P000-00.grib2
  
  

//int GRIB2_DOMAIN_SELECTION = 0; int Scenarios_max = 21; // should convert U&V to wind speed and direction!   
//int GRIB2_DOMAIN_SELECTION = 1; int Scenarios_max = 1;
//int GRIB2_DOMAIN_SELECTION = 2; int Scenarios_max = 1;
int GRIB2_DOMAIN_SELECTION = 3; int Scenarios_max = 1;
//int GRIB2_DOMAIN_SELECTION = 4; int Scenarios_max = 1; // not working now!

{
  ENSEMBLE_end += Scenarios_max;
}


int AERIAL_graphOption = 0; 


PrintWriter[] File_output_node;
PrintWriter[] File_output_norm;
PrintWriter[] File_output_prob;

int H_layer_option = -1; 
int F_layer_option = -1;
int O_layer_option = -1;

int DEV_OP_0 = 8;
int DEV_OP_1 = 6;
int DEV_OP_2 = 5;
int DEV_OP_3 = 7;
int DEV_OP_4 = 4;
int DEV_OP_5 = 3;
int DEV_OP_6 = 10;
int DEV_OP_7 = 9;
int DEV_OP_8 = 11;
int DEV_OP_9 = 0;
int DEV_OP_10 = 1;
int DEV_OP_11 = 2;





int develop_option = DEV_OP_6; //between 0 - 11...
int develop_per_day = 0; //0:accumulative 1:daily(24h) 2:per12h 3:per6h <should be zero to work well with current menues> 

int update_DevelopDATA = 1;







int num_layers = 0;  

int addLayer () {
  num_layers += 1;
  return(num_layers - 1);
}

int _windspd200hPa = addLayer();
int _thicknesses_1000_500 = addLayer();
int _heightp500hPa = addLayer();

int _ceilingsky = addLayer();
int _cloudcover = addLayer();

int _winddir = addLayer();
int _windspd = addLayer();

int _pressure = addLayer();

int _drybulb = addLayer();

int _relhum = addLayer();

int _dirnorrad = addLayer();
int _difhorrad = addLayer();
int _glohorrad = addLayer();

int _direffect = addLayer();
int _difeffect = addLayer();


int A_precipitation = addLayer();

int _developed = addLayer();

/*
int _albedo = addLayer();
int _dewpoint = addLayer();
int _spchum = addLayer();

int A_rain = addLayer();
int A_snow = addLayer();
int A_icepellets = addLayer();
int A_freezingrain = addLayer();
int A_shortwave = addLayer(); 
int A_longwave = addLayer();

int NumberOfGrib2Layers = num_layers;

int H_precipitation = addLayer();
int H_rain = addLayer();
int H_snow = addLayer();
int H_icepellets = addLayer();
int H_freezingrain = addLayer();
int H_shortwave = addLayer(); 
int H_longwave = addLayer();

int distanceToTheHourlyLayers = H_precipitation - A_precipitation;

int _tracker = addLayer();



int _south15 = addLayer();
int _south30 = addLayer();
int _south45 = addLayer();
int _south60 = addLayer();
int _south75 = addLayer();
int _south90 = addLayer();

int _SE90 = addLayer();
int _east90 = addLayer();
int _NE90 = addLayer();
int _north90 = addLayer();
int _NW90 = addLayer();
int _west90 = addLayer();
int _SW90 = addLayer();

int _SE45 = addLayer();
int _east45 = addLayer();
int _NE45 = addLayer();
int _north45 = addLayer();
int _NW45 = addLayer();
int _west45 = addLayer();
int _SW45 = addLayer();

int _userSurface1 = addLayer();
int _userSurface2 = addLayer();

int _sunX = addLayer();
int _sunY = addLayer();
int _sunZ = addLayer();

*/



float Angle_inclination = 45; // 90 = horizontal surface, 0 = Vertical surface 
float Angle_orientation = 0; // 0 = South, 90 = East


int STUDY_drw_Layer = _dirnorrad; //_developed; //_drybulb; ; //_cloudcover; 

int develop_Layer = STUDY_drw_Layer;

int STUDY_print_title = 1;

float STUDY_T_scale = 0.5;
float STUDY_U_scale = 18.0 / float(STUDY_j_end - STUDY_j_start);

float[] STUDY_V_scale;
float[] STUDY_V_offset;
float[] STUDY_V_belowLine;

String[] LAYERS_Unit;
String[][] LAYERS_Title;
String[] LAYERS_ENSEMBLE; 
String[][] LAYERS_GRIB2;
float[] LAYERS_GRIB2_MUL;
float[] LAYERS_GRIB2_ADD;


int[] GRIB2_TGL_Selected = {1,0,0,0}; // for levels above ground level 
int GRIB2_TGL_number = GRIB2_TGL_Selected.length;

{
  STUDY_V_scale = new float [num_layers];
  STUDY_V_offset = new float [num_layers];
  STUDY_V_belowLine = new float [num_layers];
  LAYERS_Unit = new String [num_layers];  
  LAYERS_Title = new String [num_layers][2];
  LAYERS_ENSEMBLE = new String [num_layers];
  LAYERS_GRIB2 = new String [num_layers][GRIB2_TGL_number]; 
  LAYERS_GRIB2_MUL = new float [num_layers];
  LAYERS_GRIB2_ADD = new float [num_layers];
  
  int i = -1;

  i = _winddir;
  if (i > -1) {
    STUDY_V_scale[i] = (100.0/360.0);
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "°";
    LAYERS_Title[i][_EN] = "Surface Wind Direction";
    LAYERS_Title[i][_FR] = "Direction du vent à la surface";
    LAYERS_ENSEMBLE[i] = "WDIR-SFC";
    LAYERS_GRIB2[i][0] = "WDIR_TGL_10";
    LAYERS_GRIB2[i][1] = "WDIR_TGL_40";
    LAYERS_GRIB2[i][2] = "WDIR_TGL_80";
    LAYERS_GRIB2[i][3] = "WDIR_TGL_120";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _windspd;
  if (i > -1) {
    STUDY_V_scale[i] = (10.0/5.0);
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "km/h";
    LAYERS_Title[i][_EN] = "Surface Wind Speed";
    LAYERS_Title[i][_FR] = "Vitesse du vent à la surface";
    LAYERS_ENSEMBLE[i] = "WIND-SFC";
    LAYERS_GRIB2[i][0] = "WIND_TGL_10"; // m/sec
    LAYERS_GRIB2[i][1] = "WIND_TGL_40"; // m/sec
    LAYERS_GRIB2[i][2] = "WIND_TGL_80"; // m/sec
    LAYERS_GRIB2[i][3] = "WIND_TGL_120"; // m/sec
    LAYERS_GRIB2_MUL[i] = 3.6; // m/s > Km/h  ----> because for some domains we need to calculate wind speed and direction via U & V this value is not applied actually. Search for other line that we infact converted from m/s > Km/h
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = A_precipitation;
  if (i > -1) {
    STUDY_V_scale[i] = 4.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "mm";
    LAYERS_Title[i][_EN] = "Surface Accumulated Precipitation";
    LAYERS_Title[i][_FR] = "Précipitations accumulées à la surface";
    LAYERS_ENSEMBLE[i] = "APCP-SFC";
    LAYERS_GRIB2[i][0] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2[i][1] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2[i][2] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2[i][3] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = _relhum;
  if (i > -1) {
    STUDY_V_scale[i] = 1.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "%";
    LAYERS_Title[i][_EN] = "Surface Relative Humidity";
    LAYERS_Title[i][_FR] = "Humidité relative à la surface";
    LAYERS_ENSEMBLE[i] = "RELH-SFC";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _drybulb;
  if (i > -1) {
    STUDY_V_scale[i] = (2.5 * pow(2, 0.5));
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "°C";
    LAYERS_Title[i][_EN] = "Surface Air Temperature";
    LAYERS_Title[i][_FR] = "Température de l'air à la surface";
    LAYERS_ENSEMBLE[i] = "TMP-SFC";
    LAYERS_GRIB2[i][0] = "TMP_TGL_2"; // Kelvin
    LAYERS_GRIB2[i][1] = "TMP_TGL_40"; // Kelvin
    LAYERS_GRIB2[i][2] = "TMP_TGL_80"; // Kelvin
    LAYERS_GRIB2[i][3] = "TMP_TGL_120"; // Kelvin
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = -273.15; // °K > °C
  }
  
  i = _dirnorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][_EN] = "Direct normal radiation";
    LAYERS_Title[i][_FR] = "Rayonnement direct normal";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _difhorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][_EN] = "Diffuse horizontal radiation";
    LAYERS_Title[i][_FR] = "Diffus rayonnement horizontal";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = _glohorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][_EN] = "Global horizontal radiation";
    LAYERS_Title[i][_FR] = "Rayonnement global horizontal";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _developed;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "";
    LAYERS_Title[i][_EN] = "";
    LAYERS_Title[i][_FR] = "";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _direffect;
  if (i > -1) {
    STUDY_V_scale[_direffect] = 0.0025;
    STUDY_V_offset[_direffect] = 0;
    STUDY_V_belowLine[_direffect] = 1;
    LAYERS_Unit[i] = "W°C/m²";
    //LAYERS_Title[i][_EN] = "Direct normal effect (based on 18°C)";
    LAYERS_Title[i][_EN] = "Direct normal effect <18°C<";
    //LAYERS_Title[i][_FR] = "Effet direct normal (basé sur 18°C)";
    LAYERS_Title[i][_FR] = "Effet direct normal <18°C<";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = _difeffect;
  if (i > -1) {
    STUDY_V_scale[i] = 0.0025;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "W°C/m²";
    //LAYERS_Title[i][_EN] = "Diffuse normal effect (based on 18°C)";
    LAYERS_Title[i][_EN] = "Diffuse normal effect <18°C<";
    //LAYERS_Title[i][_FR] = "Effet diffus normal (basé sur 18°C)";
    LAYERS_Title[i][_FR] = "Effet diffus normal <18°C<";
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _cloudcover;
  if (i > -1) {
    STUDY_V_scale[i] = 10.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "tenth";
    LAYERS_Title[i][_EN] = "Total Cloud Cover";
    LAYERS_Title[i][_FR] = "Couvert nuageux total";
    LAYERS_ENSEMBLE[i] = "TCDC";
    LAYERS_GRIB2[i][0] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2[i][1] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2[i][2] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2[i][3] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2_MUL[i] = 0.1; // percent >> tenth    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _ceilingsky;
  if (i > -1) {
    STUDY_V_scale[i] = 0.01;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "m";
    LAYERS_Title[i][_EN] = "Ceiling height";
    LAYERS_Title[i][_FR] = "Hauteur sous plafond";  
    LAYERS_ENSEMBLE[i] = "";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _pressure;
  if (i > -1) {
    STUDY_V_scale[i] = 2.0;
    STUDY_V_offset[i] = -1000;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "hPa";
    LAYERS_Title[i][_EN] = "Mean Sea level Pressure";
    LAYERS_Title[i][_FR] = "Pression moyenne au niveau de la mer";
    LAYERS_ENSEMBLE[i] = "MSLP";
    LAYERS_GRIB2[i][0] = "PRMSL_MSL_0";
    LAYERS_GRIB2[i][1] = "PRMSL_MSL_0";
    LAYERS_GRIB2[i][2] = "PRMSL_MSL_0";
    LAYERS_GRIB2[i][3] = "PRMSL_MSL_0";
    LAYERS_GRIB2_MUL[i] = 0.01; // Pa >> hPa 
    LAYERS_GRIB2_ADD[i] = 0;
  }
    
  i = _heightp500hPa;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = -500;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "dam";
    LAYERS_Title[i][_EN] = "Geopotential at 500 hPa";
    LAYERS_Title[i][_FR] = "Géopotentiel à 500 hPa";
    LAYERS_ENSEMBLE[i] = "HGT-500HPA";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
  
  i = _thicknesses_1000_500;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = -500;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "dam";
    //LAYERS_Title[i][_EN] = "Thicknesses (Geopotentiel Difference) between 1000 and 500 hPa";
    LAYERS_Title[i][_EN] = "Geopotentiel Difference";
    //LAYERS_Title[i][_FR] = "Épaisseurs (différence de géopotentiel) entre 1000 et 500 hPa";
    LAYERS_Title[i][_FR] = "Différence de géopotentiel";
    LAYERS_ENSEMBLE[i] = "LAYER-1000-500HPA";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = _windspd200hPa;
  if (i > -1) {
    STUDY_V_scale[i] = 0.5;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "knots";
    LAYERS_Title[i][_EN] = "Wind Speed at 200 hPa";
    LAYERS_Title[i][_FR] = "Vitesse du vent à 200 hPa";  
    LAYERS_ENSEMBLE[i] = "WIND-200HPA";
    LAYERS_GRIB2[i][0] = "";
    LAYERS_GRIB2[i][1] = "";
    LAYERS_GRIB2[i][2] = "";
    LAYERS_GRIB2[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

}

int sky_scenario = 1; // 1: all scenarios, 2: Total Cloud Cover < 0.33, 3: middle range, 4: Total Cloud Cover > 0.66
String[] sky_scenario_text = {"", "", "[66% < Total Cloud Cover]", "[33% < Total Cloud Cover < 66%]", "[Total Cloud Cover < 33%]"};
String[] sky_scenario_file = {"", "", "Overcast sky", "Scattered sky", "Clear sky"};

int _hourly = 0;
int _daily = 1;
int filter_type = _daily;

int join_hour_numbers = 24; //48;
int join_type = -1; // -1: increasing weights, +1: equal weights



int dT = 1;

int Export_STUDY_info_node = 0;
int Export_STUDY_info_norm = 0;
int Export_STUDY_info_prob = 0;

int STUDY_Pallet_SORT_CLR = -1;
int STUDY_Pallet_SORT_DIR = -1;
float STUDY_Pallet_SORT_MLT = 2;

int STUDY_Pallet_PROB_CLR = -1;
int STUDY_Pallet_PROB_DIR = 1;
float STUDY_Pallet_PROB_MLT = 0.5;

int STUDY_Pallet_ACTIVE_CLR = 19; //15; //14; 
int STUDY_Pallet_ACTIVE_DIR = 1;
float STUDY_Pallet_ACTIVE_MLT = 1; //2;

int STUDY_Pallet_PASSIVE_CLR = 1; 
int STUDY_Pallet_PASSIVE_DIR = 1;
float STUDY_Pallet_PASSIVE_MLT = 2; 

int OBJECTS_Pallet_ACTIVE_CLR = 19; //15; //14;
int OBJECTS_Pallet_ACTIVE_DIR = 1;
float OBJECTS_Pallet_ACTIVE_MLT = 1; //2; 

int OBJECTS_Pallet_PASSIVE_CLR = 1; 
int OBJECTS_Pallet_PASSIVE_DIR = 1;  
float OBJECTS_Pallet_PASSIVE_MLT = 2; 

int SunPath3D_Pallet_ACTIVE_CLR = 15;
int SunPath3D_Pallet_ACTIVE_DIR = 1;
float SunPath3D_Pallet_ACTIVE_MLT = 1;

int SunPath3D_Pallet_PASSIVE_CLR = 18; 
int SunPath3D_Pallet_PASSIVE_DIR = -1;  
float SunPath3D_Pallet_PASSIVE_MLT = 2; //1;

int SKY3D_Pallet_ACTIVE_CLR = 18; //-1; //7; //8;
int SKY3D_Pallet_ACTIVE_DIR = 1; //-1;
float SKY3D_Pallet_ACTIVE_MLT = 0.5; //0.25; //1;

int SKY3D_Pallet_PASSIVE_CLR = 18; 
int SKY3D_Pallet_PASSIVE_DIR = -1;  
float SKY3D_Pallet_PASSIVE_MLT = 1; //2;

int ELEVATION_Pallet_CLR = 1; 
int ELEVATION_Pallet_DIR = -1; 
float ELEVATION_Pallet_MLT = 0.1; 

int SPATIAL_Pallet_CLR = 17; //1; 
int SPATIAL_Pallet_DIR = -1; 
float SPATIAL_Pallet_MLT = 0.01; //1; 

int windFlow_Pallet_CLR = 18; 
int windFlow_Pallet_DIR = -1;  
float windFlow_Pallet_MLT = 1;


int Impact_ACTIVE = 1;
int Impact_PASSIVE = 2;
int Impact_SPD_DIR = 1;
int Impact_SPD_DIR_TMP = 2;

int Impact_TYPE = 1; 




String[][] _WORDS = {
 {"", ""}, 
 {"at hour", "à l'heure"}, 
 {"day", "jour"}, 
 {"month", "mois"}, 
 {"year", "année"}, 
 {"date", "date"} 
}; 

String[][] CalendarMonth = {
  {"January", "janvier"}, 
  {"February", "février"}, 
  {"March", "mars"}, 
  {"April", "avril"}, 
  {"May", "mai"}, 
  {"June", "juin"}, 
  {"July", "juillet"}, 
  {"August", "août"}, 
  {"September", "septembre"}, 
  {"October", "octobre"}, 
  {"November", "novembre"}, 
  {"December",  "décembre"}
};

int CalendarLength[] = {31     , 28     , 31     , 30     , 31     , 30     , 31     , 31     , 30     , 31     , 30     , 31};
String CalendarDay[][];
String CalendarMM[][];
String CalendarDD[][];
int CalendarDate[][];


float X_control, Y_control;


float STUDY_X_coordinate = 0;
float STUDY_Y_coordinate = 0;

float STUDY_O_scale = 50.0;
float STUDY_W_scale = 3.0;


int COLOR_STYLE = 0;
int n_COLOR_STYLE = 20; //6;

float obj_scale = 0.005;
float obj_offset_x = 0.5;

PGraphics STUDY_Diagrams;

int databaseNumber_OBSERVED = 0;
int databaseNumber_ENSEMBLE = 1;
int databaseNumber_CLIMATE_WY2 = 2;
int databaseNumber_CLIMATE_EPW = 3;

int impacts_source = databaseNumber_CLIMATE_EPW; 

String[] databaseString = {"SWOB", "NAEFS", "CWEEDS", "TMY"};

int draw_impact_summary = 0;

int impact_layer = 1; // 4 = Median
int plot_impacts = 4; //-2/-1:wind 0/1:urban 2/3:globe 4/5:sun-path 6/7:view-from-sun 8/9:two-cycles
int update_impacts = 1; 



int draw_frame = 0;

int X_clicked = -1;
int Y_clicked = -1;

int X_click1 = -1;
int Y_click1 = -1;
int X_click2 = -1;
int Y_click2 = -1;

String[] CLIMATE_EPW_Files = getfiles(CLIMATE_EPW_directory);
String[] CLIMATE_WY2_Files = getfiles(CLIMATE_WY2_directory);
String[] ENSEMBLE_XML_Files = getfiles(ENSEMBLE_directory);
String[] OBSERVED_XML_Files = getfiles(OBSERVED_directory);


int MODEL1D_ERASE = 0;
int MODEL2D_ERASE = 0;
int MODEL3D_ERASE = 0;
int SECTION_ERASE = 0;

int LAND_TESSELLATION = 2;

int MODEL3D_TESSELLATION = 2;

int SKY3D_TESSELLATION = 3;
float SKY3D_scale = 10000; //10km:Troposphere 25km:Ozone layer 100km:Karman line.

float WindRose3D_scale = 400;


int Display_SUN3D_Path = 1;
int Display_SUN3D_Pattern = 1;

int Display_SKY3D = 0;

int Download_LAND_MESH = 0;
int Load_LAND_MESH = 1; // 1;
int Display_LAND_MESH = 0; // 1;
int Display_LAND_TEXTURE = 0;
int Display_LAND_DEPTH = 0;
int Skip_LAND_MESH_Center = 0; //5;

int Load_URBAN_MESH = 0;
int Display_URBAN_MESH = 1;

int Display_SpatialImpact_Points = 0;
int Display_SpatialImpact_Lines = 1;

int Display_MODEL3D_EDGES = 1;
int Display_MODEL3D_NORMALS = 0;

int Display_windFlow = 0;


int camera_variation = 0; // 1;

int draw_data_lines = 0;
int draw_sorted = 1;
int draw_normals = 1;
int draw_probs = 0;
int sum_interval = 2;
float level_pix = 8;

float _pix = 0; 

color color_data_lines = color(0, 0, 0);

float WIN3D_Image_Scale = 1.0;

float WORLD_Image_Scale = 1.0;

float STUDY_Image_Scale = 1.0;

int pre_Sample_Year_start; 
int pre_Sample_Year_end; 
int pre_Sample_Member_start;
int pre_Sample_Member_end;
int pre_Sample_Station_start; 
int pre_Sample_Station_end;
int pre_num_add_days;
int pre_STUDY_i_start;
int pre_STUDY_i_end;
int pre_STUDY_j_end;
int pre_Day_of_Impact_to_Display;
int pre_STUDY_setup;
int pre_impacts_source;
int pre_STATION_NUMBER;
int pre_Selected_STATION;
int pre_YEAR;
int pre_MONTH;
int pre_DAY;
int pre_HOUR;
float pre_DATE;
int pre_Climatic_solar_forecast;
int pre_Climatic_weather_forecast;

int pre_Load_CLIMATE_EPW;
int pre_Load_CLIMATE_WY2;
int pre_Load_ENSEMBLE;
int pre_Load_OBSERVED;     
float pre_LocationLatitude;
float pre_LocationLongitude;
int pre_WORLD_VIEW_Auto;
int pre_Load_LAND_MESH;
int pre_Load_URBAN_MESH;

int pre_SPATIAL_Pallet_CLR;
int pre_SPATIAL_Pallet_DIR; 
float pre_SPATIAL_Pallet_MLT; 

float pre_Create_Input_powAll;



float pre_SpatialImpact_Grade;
float pre_SpatialImpact_Power;
float[] pre_SpatialImpact_Rotation = {0,0,0,0};
float[] pre_SpatialImpact_Elevation = {0,0,0,0};
float[] pre_SpatialImpact_scale_U = {0,0,0,0};
float[] pre_SpatialImpact_scale_V = {0,0,0,0};
float[] pre_SpatialImpact_offset_U = {0,0,0,0};
float[] pre_SpatialImpact_offset_V = {0,0,0,0};

float pre_SpatialImpact_Wspd; 
float pre_SpatialImpact_Wdir;
      
int pre_PROCESS_subdivisions;

int pre_Display_SpatialImpact_Points;
int pre_Display_SpatialImpact_Lines;

int pre_Display_windFlow;

int pre_selectedFractal_numbers_lastItem;
int pre_selectedObject2D_numbers_lastItem;
int pre_selectedPolymesh_numbers_lastItem;
int pre_selectedFace_numbers_lastItem;
int pre_selectedVertex_numbers_lastItem;

int pre_selectedFractal_displayEdges;
int pre_selectedObject2D_displayEdges;

int pre_selectedSection_displayEdges;

int pre_Display_MODEL3D_EDGES;
int pre_Display_MODEL3D_NORMALS;

float pre_softSelection_Power;
float pre_softSelection_Radius;

float pre_selected_posValue;
float pre_selected_rotValue;
float pre_selected_scaleValue;

int pre_selection_alignX;
int pre_selection_alignY;
int pre_selection_alignZ;
      
int pre_selectedPolymesh_displayPivot;
int pre_selectedPolymesh_displayEdges;
int pre_selectedPolymesh_displayBox;      

int pre_selectedPolymesh_displaySolarPivots;
int pre_selectedFace_displayEdges;
int pre_selectedFace_displayVertexCount;
int pre_selectedVertex_displayVertices;
 



int pre_WIN3D_FACES_SHADE;

int pre_MODEL3D_TESSELLATION;

      
int pre_Load_Default_Models;

int pre_impact_layer;
int pre_H_layer_option;
int pre_F_layer_option;
int pre_O_layer_option;
int pre_develop_option;
int pre_STUDY_drw_Layer;
int pre_sky_scenario;
int pre_plot_impacts;





int STUDY_setup = 14; //4; //12; //13;



String BaseFolder = "C:/SOLARCHVISION_2015"; 

String Grib2ArchiveFolder;
String Wgrib2TempFolder;

String BackgroundFolder;
String WorldViewFolder;
String SWOBFolder;
String NAEFSFolder;
String CWEEDSFolder;
String EPWFolder;
String LandFolder;
String Object2DFolder_PEOPLE;
String Object2DFolder_TREES;
String ExportFolder;
String ProjectsFolder;
String DiagramsFolder;
String ScreenShotFolder;
String Model3DFolder;

String ProjectName = "Revision_" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
String HoldStamp = ""; 

void SOLARCHVISION_update_folders () {

  Grib2ArchiveFolder = BaseFolder + "/Input/WeatherForecast";
  Wgrib2TempFolder = BaseFolder + "/Temp";
  
  BackgroundFolder      = BaseFolder + "/Input/BackgroundImages/Standard/Other";
  WorldViewFolder       = BaseFolder + "/Input/BackgroundImages/Standard/World";
  SWOBFolder            = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  NAEFSFolder           = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  CWEEDSFolder          = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  EPWFolder             = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  LandFolder            = BaseFolder + "/Input/CoordinateFiles/Land";
  Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_ALL_CROP_low";
  //Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_SEL";
  //Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_ALL";
  Object2DFolder_TREES  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees_SEL";
  //Object2DFolder_TREES  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees_ALL";
  ExportFolder          = BaseFolder + "/Export";
  ProjectsFolder        = BaseFolder + "/Projects/Project_A01";  
  DiagramsFolder        = ExportFolder + "/Diagrams";  
  Model3DFolder         = ExportFolder + "/Model_3D" + "/" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);  
  
  ScreenShotFolder      = ExportFolder + "/ScreenShots" + "/" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
  //ScreenShotFolder      = ExportFolder + "/ScreenShots" + "/Next_Presentation";



  //try {

    String[] filenames = getfiles(ScreenShotFolder);
    if (filenames != null) SavedScreenShots = filenames.length;
    //println("SavedScreenShots:", SavedScreenShots);
  
  //} catch (Exception e) println("No ScreenShotFolder!");
  

}



int Materials_Number = 11; //256; // 0, 1, 2, ... , 10

int Materials_Selection = 1; //2; // yellow

float[][][] Materials_DirectArea = new float [Materials_Number][24][365]; 
int[][] Materials_DirectArea_Flag = new int [24][365];

float[][][] Materials_DiffuseArea = new float [Materials_Number][24][365]; 
int[][] Materials_DiffuseArea_Flag = new int [24][365];

int[][] Materials_Color = new int [Materials_Number][4]; // ARGB                            
{
  {
    int[] COL = {255, 255, 127, 0};    
    Materials_Color[0] = COL;
  }
  {
    int[] COL = {255, 255, 0, 0};    
    Materials_Color[1] = COL;
  }  
  {
    int[] COL = {255, 255, 255, 0};    
    Materials_Color[2] = COL;
  }
  {
    int[] COL = {255, 0, 255, 0};    
    Materials_Color[3] = COL;
  }
  {
    int[] COL = {255, 0, 255, 255};    
    Materials_Color[4] = COL;
  }
  {
    int[] COL = {255, 0, 0, 255};    
    Materials_Color[5] = COL;
  }
  {
    int[] COL = {255, 255, 0, 255};    
    Materials_Color[6] = COL;
  }
  {
    int[] COL = {255, 255, 255, 255};    
    Materials_Color[7] = COL;
  }
  {
    //int[] COL = {255, 63, 63, 63};    
    int[] COL = {63, 63, 63, 63};
    Materials_Color[8] = COL;
  }
  {
    //int[] COL = {255, 127, 127, 127};    
    int[] COL = {127, 127, 127, 127};
    Materials_Color[9] = COL;
  }
  {
    //int[] COL = {255, 191, 191, 191};    
    int[] COL = {191, 191, 191, 191};
    Materials_Color[10] = COL;
  }
  
  {
    for (int mt = 11; mt < Materials_Number; mt++) {
      int[] COL = {255, int(random(256)), int(random(256)), int(random(256))};
      Materials_Color[mt] = COL;
    }
  }  
}

void empty_Materials_DirectArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i += 1) {
      for (int j = 0; j < 365; j += 1) {
        Materials_DirectArea[mt][i][j] = FLOAT_undefined;
        Materials_DirectArea_Flag[i][j] = -1;
      }
    }  
  }

}

void empty_Materials_DiffuseArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i += 1) {
      for (int j = 0; j < 365; j += 1) {
        Materials_DiffuseArea[mt][i][j] = FLOAT_undefined;
        Materials_DiffuseArea_Flag[i][j] = -1;
      }
    }  
  }

}




                  
int h_pixel = 300; //325; //340; 
int w_pixel = int(h_pixel * 1.5); 

float MESSAGE_S_View = w_pixel / 40.0;


int a_pixel = int(1.5 * MESSAGE_S_View); // menu bar
int b_pixel = int(2.75 * MESSAGE_S_View); // 3D tool bar

int d_pixel = int(4.5 * MESSAGE_S_View); // time bar


float WIN3D_scale3D; 

int WIN3D_CX_View = 0;
int WIN3D_CY_View = a_pixel + b_pixel + 0;
int WIN3D_X_View = int(1.25 * h_pixel);
int WIN3D_Y_View = h_pixel;
float WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);

float WIN3D_X_coordinate = 0;
float WIN3D_Y_coordinate = 10;
float WIN3D_Z_coordinate = 0; 
float WIN3D_S_coordinate = 1;

float WIN3D_RX_coordinate = 90; //75; 
float WIN3D_RY_coordinate = 0;
float WIN3D_RZ_coordinate = 0; //0; //180; //135;
float WIN3D_RS_coordinate = 5.0;

float WIN3D_ZOOM_coordinate = 60; // / (h_pixel / 300.0);

int WIN3D_View_Type = 1; // 0: Ortho 1: Perspective

int WIN3D_Update = 1;
int WIN3D_include = 1;




int Shade_Surface_Wire = -1;
int Shade_Surface_Base = 0;
int Shade_Surface_White = 1;
int Shade_Surface_Materials = 2;
int Shade_Global_Solar = 3;
int Shade_Vertex_Solar = 4;
int Shade_Vertex_Spatial = 5;
int Shade_Vertex_Elevation = 6;

int number_of_shading_options = 7;

int WIN3D_FACES_SHADE = Shade_Surface_Materials; //Shade_Surface_White; // <<<<<




float[] WIN3D_VerticesSolarEnergy;
float[] WIN3D_VerticesSolarEffect;
int WIN3D_update_VerticesSolarValue = 1;






int WORLD_CX_View = int(1.25 * h_pixel);
int WORLD_CY_View = a_pixel + b_pixel + 0;
int WORLD_X_View = int(1.75 * h_pixel);
int WORLD_Y_View = h_pixel;
float WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);

int WORLD_Update = 1;
int WORLD_include = 1;

int WORLD_VIEW_Number = 0;
int WORLD_VIEW_Auto = 1;

String[][] WORLD_VIEW_Name;
float[][] WORLD_VIEW_BoundariesX;
float[][] WORLD_VIEW_BoundariesY; 
int[] WORLD_VIEW_GridDisplay;
String[] WORLD_VIEW_Filenames;
String[] Object2D_ImagePath;
int Object2D_PEOPLE_Files_Num = 0;
int Object2D_TREES_Files_Num = 0;

int number_of_WORLD_viewports;
int WORLD_viewport_ZOOM = 1; //1:A 2:B 3:C 4:D 5:E and 6:L <<<


int STUDY_CX_View = 0;
int STUDY_CY_View = a_pixel + b_pixel + h_pixel;
int STUDY_X_View = 2 * w_pixel;
int STUDY_Y_View = 1 * h_pixel;
float STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);
float STUDY_S_View;

int STUDY_Update = 1;
int STUDY_include = 1;

int ROLLOUT_CX_View = 2 * w_pixel;
int ROLLOUT_CY_View = a_pixel + b_pixel + 0;
int ROLLOUT_X_View = 1 * h_pixel;
int ROLLOUT_Y_View = 2 * h_pixel;
float ROLLOUT_R_View = float(ROLLOUT_Y_View) / float(ROLLOUT_X_View);
float ROLLOUT_S_View = h_pixel / 325.0; //1; //0.75; // ?????

int ROLLOUT_Update = 1;
int ROLLOUT_include = 1;


int MESSAGE_CX_View = 0;
int MESSAGE_CY_View = int(1 * h_pixel - 0.75 * MESSAGE_S_View + 0.5 * (a_pixel + b_pixel + d_pixel));
int MESSAGE_X_View = 2 * w_pixel + ROLLOUT_X_View;
int MESSAGE_Y_View = int(1.5 * MESSAGE_S_View);







float CAM_x;
float CAM_y;
float CAM_z;
float CAM_fov;
float CAM_dist;

float CAM_clipNear = 0.001;
float CAM_clipFar = 1000000000.0;



void setup () {

  size(1200, 696, P2D);
  //size(2 * w_pixel + ROLLOUT_X_View, a_pixel + b_pixel + 2 * h_pixel + d_pixel, P2D);
  

  SOLARCHVISION_draw_frame_icon();

  _DATE = (286 + Convert2Date(_MONTH, _DAY)) % 365; // 0 presents March 21, 286 presents Jan.01, 345 presents March.01
  //if (_HOUR >= 12) _DATE += 0.5;   

  empty_Materials_DirectArea();
  empty_Materials_DiffuseArea();

  WIN3D_VerticesSolarEnergy = new float [1];
  WIN3D_VerticesSolarEffect = new float [1];
  WIN3D_VerticesSolarEnergy[0] = FLOAT_undefined;
  WIN3D_VerticesSolarEffect[0] = FLOAT_undefined;

  
  
  WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);

  WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);  
  
  STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);


  Load_EARTH_IMAGES(); // <<<<<<<<<<<< should move it below
  Load_TROPO_IMAGES(); // <<<<<<<<<<<< should move it below

  MOON_IMAGE = loadImage(MOON_IMAGE_Filename);
  STAR_IMAGE = loadImage(STAR_IMAGE_Filename);

  LoadDefaultFontStyle();  

  frameRate(24);

  loop();
}

void SOLARCHVISION_draw_frame_icon () {
  int frame_icon_size = 64;
  
  PGraphics frame_icon = createGraphics(frame_icon_size, frame_icon_size);  
  
  frame_icon.beginDraw();
  
  //frame_icon.image(loadImage("C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Icon/s-icon.png"), 0, 0 );
  
  frame_icon.background(0);
  //frame_icon.background(63,63,255,255);
  
  //frame_icon.fill(255,127);
  frame_icon.fill(255,255,0, 127);
  
  frame_icon.textAlign(CENTER, CENTER);
  frame_icon.textSize(1.0 * frame_icon_size);
  frame_icon.text("S", 0.20 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("A", 0.50 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("V", 0.80 * frame_icon_size, 0.4 * frame_icon_size);
  
  frame_icon.endDraw();
  frame.setIconImage(frame_icon.image);  
  
  frame.setTitle("SOLARCHVISION-2015");
}



void SOLARCHVISION_update_station (int Step) {
  
  if ((Step == 0) || (Step == 1)) {
    
    rebuild_SolarProjection_array = 1;
    rebuild_SolarImpact_Image_array = 1;
    rebuild_WindRose_Image_array = 1;    
    
    WIN3D_update_VerticesSolarValue = 1;
    
    WORLD_Update = 1;
    WIN3D_Update = 1; 
    STUDY_Update = 1;    
    
    LocationName = DEFINED_STATIONS[STATION_NUMBER][0];
    LocationProvince = DEFINED_STATIONS[STATION_NUMBER][1];
    
    LocationLatitude = float(DEFINED_STATIONS[STATION_NUMBER][3]);
    LocationLongitude = float(DEFINED_STATIONS[STATION_NUMBER][4]);
    LocationTimeZone = float(DEFINED_STATIONS[STATION_NUMBER][5]);
    LocationElevation = float(DEFINED_STATIONS[STATION_NUMBER][6]);
    Delta_NOON = (LocationTimeZone - LocationLongitude) / 15.0;
    
    WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);

    BEGIN_DAY = Convert2Date(_MONTH, _DAY);
  }
  
  if ((Step == 0) || (Step == 2)) SOLARCHVISION_try_update_CLIMATE_EPW();
  
  if ((Step == 0) || (Step == 3)) SOLARCHVISION_try_update_CLIMATE_WY2();  
  
  if ((Step == 0) || (Step == 4)) SOLARCHVISION_try_update_OBSERVED();
  
  if ((Step == 0) || (Step == 5)) SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);

  if ((Step == 0) || (Step == 6)) SOLARCHVISION_LoadLAND_MESH(LocationName);
  
  //if ((Step == 0) || (Step == 7)) SOLARCHVISION_remove_FractalPlants();
  
  if ((Step == 0) || (Step == 8)) SOLARCHVISION_remove_2Dobjects();
  
  //if ((Step == 0) || (Step == 9)) SOLARCHVISION_add_2Dobjects_onLand();

}

void SOLARCHVISION_update_models (int Step) {
 
   if ((Step == 0) || (Step == 1)) SOLARCHVISION_remove_3Dobjects();
   //if ((Step == 0) || (Step == 2)) SOLARCHVISION_add_3Dobjects();
   if ((Step == 0) || (Step == 3)) SOLARCHVISION_remove_ParametricGeometries();
   if ((Step == 0) || (Step == 4)) SOLARCHVISION_add_ParametricGeometries();
   if ((Step == 0) || (Step == 5)) SOLARCHVISION_calculate_SpatialImpact_selectedSections();

}



int initializationStep = 0;
int Last_initializationStep = 1000;

void draw () {
  
  //println("frameCount:", frameCount);



  if (frameCount == 1) {

    background(223);

    SOLARCHVISION_update_folders();

    float cr;

    cr = w_pixel / 4.0;
    PImage SOLARCHVISION_logo = loadImage(BackgroundFolder + "/" + "SOLARCHVISION.jpg");
    imageMode(CENTER);
    image(SOLARCHVISION_logo, 0.5 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr + (0.075 * cr), 3.05 * cr, 3.05 * cr);
    imageMode(CORNER);

    strokeWeight(1);
    stroke(0);
    noFill();
    
    
    ellipseMode(CENTER);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 2 * cr, 2 * cr);
    strokeWeight(1);
    stroke(255);
    noFill();    
    SOLARCHVISION_draw_logo(0.2 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 0, cr, 1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 2 * cr, 2 * cr);
    
    strokeWeight(1);
    stroke(127);
    noFill();  
    //SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 0, cr, 0);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.5 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 2 * cr, 2 * cr);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 2 * cr, 2 * cr);    
    strokeWeight(1);
    stroke(255);
    noFill();  
    SOLARCHVISION_draw_logo(0.8 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 0, cr, -1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MESSAGE_S_View - cr, 2 * cr, 2 * cr);
    
    strokeWeight(0);

    stroke(255);
    fill(255);
    textAlign(CENTER, CENTER); 
    textSize(3 * MESSAGE_S_View);
    text("SOLARCHVISION model integrations 2015", 0.5 * width, 0.05 * height); 

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER); 
    textSize(1.5 * MESSAGE_S_View);
    text("Raz, Mehr, Mehraz solarch studio\n1998-2015\nAuthor: Mojtaba Samimi\nwww.solarchvision.com", 0.5 * width, 0.75 * height);

    textAlign(CENTER, CENTER); 
    textSize(MESSAGE_S_View);
  }  
  else if (frameCount == 2) {
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_LoadWorldImages", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 3) {
    SOLARCHVISION_LoadWorldImages();
    Load_WORLDViewImage(WORLD_VIEW_Number); // to load the globe image into memory

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_LoadObject2DImages", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 4) {
    SOLARCHVISION_LoadObject2DImages();
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_Calendar", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 5) {
    SOLARCHVISION_Calendar(); 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getSWOB_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 6) {
    SOLARCHVISION_getSWOB_Coordinates(); 
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getNAEFS_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 7) {
    SOLARCHVISION_getNAEFS_Coordinates(); 
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getCWEEDS_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 8) {
    SOLARCHVISION_getCWEEDS_Coordinates();  
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getEPW_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 9) {
    SOLARCHVISION_getEPW_Coordinates();  
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_update_date", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 10) {
    SOLARCHVISION_update_date(); 
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_update_station(start)", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 11) {
    SOLARCHVISION_update_station(1);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_CLIMATE_EPW", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 12) {
    SOLARCHVISION_update_station(2);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_CLIMATE_WY2", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 13) {
    SOLARCHVISION_update_station(3);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_OBSERVED", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 14) {
    SOLARCHVISION_update_station(4);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_ENSEMBLE", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 15) {
    SOLARCHVISION_update_station(5);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_LoadLAND_MESH", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 16) {
    SOLARCHVISION_update_station(6);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_remove_FractalPlants", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 17) {
    SOLARCHVISION_update_station(7);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_remove_2Dobjects", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 18) {
    SOLARCHVISION_update_station(8);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_add_2Dobjects_onLand", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 19) {
    SOLARCHVISION_update_station(9);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_remove_3Dobjects", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 20) {
    SOLARCHVISION_update_models(1);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_add_3Dobjects", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 21) {
    SOLARCHVISION_update_models(2);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_remove_ParametricGeometries", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 22) {
    SOLARCHVISION_update_models(3);    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_add_ParametricGeometries", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 23) {
    SOLARCHVISION_update_models(4);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_calculate_SpatialImpact_selectedSections", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  }
  else if (frameCount == 24) {
    SOLARCHVISION_update_models(5);
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_build_SkySphere", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
    
  }    
  else if (frameCount == 25) {
    
    SOLARCHVISION_build_SkySphere(2); //1 - 3 
    
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 
   
    stroke(255);
    fill(255);
    text("Please wait while integrating the models.", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);

    MESSAGE_X_View = 2 * w_pixel;

    X_clicked = -1;
    Y_clicked = -1;

    initializationStep = frameCount; 
    Last_initializationStep = frameCount;
  }
  else {
    
    if (ROLLOUT_include == 1) {
      if (ROLLOUT_Update == 1) {
        ROLLOUT_Update = 0;

        pre_Sample_Year_start = Sample_Year_start;
        pre_Sample_Year_end = Sample_Year_end;
        pre_Sample_Member_start = Sample_Member_start;
        pre_Sample_Member_end = Sample_Member_end;
        pre_Sample_Station_start = Sample_Station_start; 
        pre_Sample_Station_end = Sample_Station_end;
        pre_num_add_days = num_add_days;
        pre_STUDY_i_start = STUDY_i_start;
        pre_STUDY_i_end = STUDY_i_end;        
        pre_STUDY_j_end = STUDY_j_end;
        pre_Day_of_Impact_to_Display = Day_of_Impact_to_Display;
        pre_STUDY_setup = STUDY_setup;
        pre_impacts_source = impacts_source;
        pre_STATION_NUMBER = STATION_NUMBER;
        pre_Selected_STATION = Selected_STATION;
        pre_YEAR = _YEAR;
        pre_MONTH = _MONTH;
        pre_DAY = _DAY;
        pre_DATE = _DATE;
        pre_HOUR = _HOUR;
        pre_Climatic_solar_forecast = Climatic_solar_forecast;
        pre_Climatic_weather_forecast = Climatic_weather_forecast;

        pre_Load_CLIMATE_EPW = Load_CLIMATE_EPW;
        pre_Load_CLIMATE_WY2 = Load_CLIMATE_WY2;
        pre_Load_ENSEMBLE = Load_ENSEMBLE;
        pre_Load_OBSERVED = Load_OBSERVED;       

        pre_LocationLatitude = LocationLatitude;
        pre_LocationLongitude = LocationLongitude;
        
        pre_WORLD_VIEW_Auto = WORLD_VIEW_Auto;
        
        pre_Load_LAND_MESH = Load_LAND_MESH;
        pre_Load_URBAN_MESH = Load_URBAN_MESH;
        
        pre_SPATIAL_Pallet_CLR = SPATIAL_Pallet_CLR;
        pre_SPATIAL_Pallet_DIR = SPATIAL_Pallet_DIR; 
        pre_SPATIAL_Pallet_MLT = SPATIAL_Pallet_MLT;         
        
        pre_Create_Input_powAll = Create_Input_powAll;
        
        pre_SpatialImpact_scale_U = SpatialImpact_scale_U;
        pre_SpatialImpact_scale_V = SpatialImpact_scale_V;

        pre_SpatialImpact_offset_U = SpatialImpact_offset_U;
        pre_SpatialImpact_offset_V = SpatialImpact_offset_V;
        
        pre_SpatialImpact_Grade = SpatialImpact_Grade;
        pre_SpatialImpact_Power = SpatialImpact_Power;
        pre_SpatialImpact_Rotation[SpatialImpact_sectionType] = SpatialImpact_Rotation[SpatialImpact_sectionType];
        pre_SpatialImpact_Elevation[SpatialImpact_sectionType] = SpatialImpact_Elevation[SpatialImpact_sectionType];
        
        pre_SpatialImpact_Wspd = SpatialImpact_Wspd; 
        pre_SpatialImpact_Wdir = SpatialImpact_Wdir;
      
        pre_PROCESS_subdivisions = PROCESS_subdivisions;
      
        pre_Display_SpatialImpact_Points = Display_SpatialImpact_Points;
        pre_Display_SpatialImpact_Lines = Display_SpatialImpact_Lines;
        
        pre_Display_windFlow = Display_windFlow;
        
        pre_selectedFractal_numbers_lastItem = selectedFractal_numbers[selectedFractal_numbers.length - 1];
        pre_selectedObject2D_numbers_lastItem = selectedObject2D_numbers[selectedObject2D_numbers.length - 1];
        pre_selectedPolymesh_numbers_lastItem = selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1];
        pre_selectedFace_numbers_lastItem = selectedFace_numbers[selectedFace_numbers.length - 1];
        pre_selectedVertex_numbers_lastItem = selectedVertex_numbers[selectedVertex_numbers.length - 1];
        
        pre_selectedSection_displayEdges = selectedSection_displayEdges;
        
        pre_selectedFractal_displayEdges = selectedFractal_displayEdges;
        pre_selectedObject2D_displayEdges = selectedObject2D_displayEdges;
        pre_Display_MODEL3D_EDGES = Display_MODEL3D_EDGES;
        pre_Display_MODEL3D_NORMALS = Display_MODEL3D_NORMALS;
        
        pre_softSelection_Power = softSelection_Power;
        pre_softSelection_Radius = softSelection_Radius;
        
        
        pre_selected_posValue = selected_posValue;
        pre_selected_rotValue = selected_rotValue;
        pre_selected_scaleValue = selected_scaleValue;        
        
        pre_selection_alignX = selection_alignX;
        pre_selection_alignY = selection_alignY;
        pre_selection_alignZ = selection_alignZ;
        
        pre_selectedPolymesh_displayPivot = selectedPolymesh_displayPivot;
        pre_selectedPolymesh_displayEdges = selectedPolymesh_displayEdges;
        pre_selectedPolymesh_displayBox = selectedPolymesh_displayBox;        

        pre_selectedPolymesh_displaySolarPivots = selectedPolymesh_displaySolarPivots;
        pre_selectedFace_displayEdges = selectedFace_displayEdges;
        pre_selectedFace_displayVertexCount = selectedFace_displayVertexCount;
        pre_selectedVertex_displayVertices = selectedVertex_displayVertices;

        pre_WIN3D_FACES_SHADE = WIN3D_FACES_SHADE;
  
        pre_MODEL3D_TESSELLATION = MODEL3D_TESSELLATION;

      
        pre_Load_Default_Models = Load_Default_Models;

        pre_impact_layer = impact_layer;
 
        pre_H_layer_option = H_layer_option;
        pre_F_layer_option = F_layer_option;
        pre_O_layer_option = O_layer_option;
        
        pre_develop_option = develop_option;
        
        pre_STUDY_drw_Layer = STUDY_drw_Layer;
        
        pre_sky_scenario = sky_scenario;
        
        pre_plot_impacts = plot_impacts;
        
        SOLARCHVISION_draw_ROLLOUT();
        
        if (abs(pre_plot_impacts) % 2 != abs(plot_impacts) % 2) {
          rebuild_SolarProjection_array = 1;
        }
        
        if (pre_Sample_Year_start != Sample_Year_start) {
          BAR_d_Update = 1;
        }            
        if (pre_Sample_Year_end != Sample_Year_end) {
          BAR_d_Update = 1;
        }            
          
        if (pre_Sample_Member_start != Sample_Member_start) {
          BAR_d_Update = 1;
        }  
        
        if (pre_Sample_Member_end != Sample_Member_end) {
          BAR_d_Update = 1;
        }  
        
        if (pre_Sample_Station_start != Sample_Station_start) {
          BAR_d_Update = 1;
        }  
        
        if (pre_Sample_Station_end != Sample_Station_end) {
          BAR_d_Update = 1;
        }  
        
        if (pre_num_add_days != num_add_days) {
          BAR_d_Update = 1;
        }            

        if (pre_STUDY_i_start != STUDY_i_start) {
          BAR_d_Update = 1;
        }      
        
        if (pre_STUDY_i_end != STUDY_i_end) {
          BAR_d_Update = 1;
        }      
        
        if (pre_STUDY_j_end != STUDY_j_end) {
          BAR_d_Update = 1;
          
          rebuild_SolarProjection_array = 1;
          rebuild_SolarImpact_Image_array = 1;
          rebuild_WindRose_Image_array = 1;      

          SOLARCHVISION_resize_allSection_SolarImpact_array(); 
        }
        
        if (pre_Day_of_Impact_to_Display != Day_of_Impact_to_Display) {
          BAR_d_Update = 1;
        }
        
        if (pre_DATE != _DATE) {
          BAR_d_Update = 1;
          
          SOLARCHVISION_update_date();
          SOLARCHVISION_draw_ROLLOUT();
        }
        
        if ((pre_YEAR != _YEAR) || (pre_MONTH != _MONTH) || (pre_DAY != _DAY) || (pre_HOUR != _HOUR) || (pre_Climatic_solar_forecast != Climatic_solar_forecast) || (pre_Climatic_weather_forecast != Climatic_weather_forecast)) {
          BAR_d_Update = 1;
          
          BEGIN_DAY = Convert2Date(_MONTH, _DAY);
          _HOUR = int(24 * (_DATE - int(_DATE)));
          _DATE = (_HOUR / 24.0) + (286 + Convert2Date(_MONTH, _DAY)) % 365;
          println("DATE:", _DATE, "\tHOUR:", _HOUR);
          SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
          
          SOLARCHVISION_draw_ROLLOUT();
        }
      
        if (pre_STATION_NUMBER != STATION_NUMBER) SOLARCHVISION_update_station(0);
        
        if (pre_Selected_STATION != Selected_STATION) ROLLOUT_Update = 1;

        if (LOAD_STATION == 1) {         
          STATION_NUMBER = Selected_STATION;
          SOLARCHVISION_update_station(0);
          LOAD_STATION = 0;
        }
        
        if (pre_Load_CLIMATE_EPW != Load_CLIMATE_EPW) SOLARCHVISION_try_update_CLIMATE_EPW();
        if (pre_Load_CLIMATE_WY2 != Load_CLIMATE_WY2) SOLARCHVISION_try_update_CLIMATE_WY2();
        if (pre_Load_OBSERVED != Load_OBSERVED) SOLARCHVISION_try_update_OBSERVED();
        if (pre_Load_ENSEMBLE != Load_ENSEMBLE) SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);

        if (pre_WORLD_VIEW_Auto != WORLD_VIEW_Auto) {
          WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);
        }
        


        if ((pre_LocationLatitude != LocationLatitude) || (pre_LocationLongitude != LocationLongitude)) {

          WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);
          WORLD_Update = 1; 
        }
        
       
        if (Download_LAND_MESH != 0) {
          SOLARCHVISION_DownloadLAND_MESH();
          WIN3D_Update = 1;
          ROLLOUT_Update = 1;
        }
       
        if (pre_Load_LAND_MESH != Load_LAND_MESH) {
          SOLARCHVISION_LoadLAND_MESH(LocationName);
          WIN3D_Update = 1;
        }
        
        
        if (pre_Load_URBAN_MESH != Load_URBAN_MESH) {
          SOLARCHVISION_add_urban();
          
          WIN3D_Update = 1;
        }
        
        if (pre_selectedSection_displayEdges != selectedSection_displayEdges) {
          WIN3D_Update = 1;
        }     
        

        if (pre_selectedFractal_displayEdges != selectedFractal_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedObject2D_displayEdges != selectedObject2D_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFractal_numbers_lastItem != selectedFractal_numbers[selectedFractal_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_Pivot 19");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }
        
        if (pre_selectedObject2D_numbers_lastItem != selectedObject2D_numbers[selectedObject2D_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_Pivot 20");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }
        
        if (pre_selectedPolymesh_numbers_lastItem != selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_Pivot 21");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }

        if (pre_selectedFace_numbers_lastItem != selectedFace_numbers[selectedFace_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_Pivot 22");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }
        
        if (pre_selectedVertex_numbers_lastItem != selectedVertex_numbers[selectedVertex_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_Pivot 23");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }        
        
        

        if (pre_softSelection_Power != softSelection_Power) {    
          SOLARCHVISION_convertVertex2softSelection();
          WIN3D_Update = 1;
        }  

        if (pre_softSelection_Radius != softSelection_Radius) {
          SOLARCHVISION_convertVertex2softSelection();
          WIN3D_Update = 1;
        }  

        
        if (pre_selection_alignX != selection_alignX) {    
          println("SOLARCHVISION_calculate_selection_Pivot 24");    
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }        
        
        if (pre_selection_alignY != selection_alignY) {   
          println("SOLARCHVISION_calculate_selection_Pivot 25");     
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }      
        
        if (pre_selection_alignZ != selection_alignZ) {        
          println("SOLARCHVISION_calculate_selection_Pivot 26");
          SOLARCHVISION_calculate_selection_Pivot();
          WIN3D_Update = 1;
        }      
        
        if (pre_selected_posValue != selected_posValue) {

          float d = selected_posValue - pre_selected_posValue;
          
          float dx = d;
          float dy = d;
          float dz = d;
          
          int the_Vector = selected_posVector;
          
          if (the_Vector == 0) {dy = 0; dz = 0;}  
          if (the_Vector == 1) {dz = 0; dx = 0;}  
          if (the_Vector == 2) {dx = 0; dy = 0;}            
          
          SOLARCHVISION_move_Selection(dx, dy, dz);
          WIN3D_Update = 1;
        }
        if (pre_selected_rotValue != selected_rotValue) {
          
          float x0 = selected_Pivot_XYZ[0];
          float y0 = selected_Pivot_XYZ[1];
          float z0 = selected_Pivot_XYZ[2];
  
          float r = selected_rotValue - pre_selected_rotValue;
          
          int the_Vector = selected_rotVector;
          
          SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);
          WIN3D_Update = 1;
        }
        if (pre_selected_scaleValue != selected_scaleValue) {

          float x0 = selected_Pivot_XYZ[0];
          float y0 = selected_Pivot_XYZ[1];
          float z0 = selected_Pivot_XYZ[2];          
          
          float s = pow(2.0, selected_scaleValue - pre_selected_scaleValue);
          
          float sx = s;
          float sy = s;
          float sz = s;
          
          int the_Vector = selected_scaleVector;
        
          if (the_Vector == 0) {sy = 1; sz = 1;}  
          if (the_Vector == 1) {sz = 1; sx = 1;}  
          if (the_Vector == 2) {sx = 1; sy = 1;}           
          
          SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);
          WIN3D_Update = 1;
        }        


        if (pre_selectedPolymesh_displayPivot != selectedPolymesh_displayPivot) {
          WIN3D_Update = 1;          
        }
        
        if (pre_selectedPolymesh_displayEdges != selectedPolymesh_displayEdges) {
          WIN3D_Update = 1;          
        }

        if (pre_selectedPolymesh_displayBox != selectedPolymesh_displayBox) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedPolymesh_displaySolarPivots != selectedPolymesh_displaySolarPivots) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFace_displayEdges != selectedFace_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFace_displayVertexCount != selectedFace_displayVertexCount) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedVertex_displayVertices != selectedVertex_displayVertices) {
          WIN3D_Update = 1;
        }     


        
        

        if (pre_WIN3D_FACES_SHADE != WIN3D_FACES_SHADE) {
          WIN3D_Update = 1;
        }             
        
        if (pre_MODEL3D_TESSELLATION != MODEL3D_TESSELLATION) {
          WIN3D_update_VerticesSolarValue = 1;
        }


        if (MODEL1D_ERASE == 1) {
          SOLARCHVISION_remove_FractalPlants();
          
          WIN3D_Update = 1;
      
          ROLLOUT_Update = 1;
      
          MODEL1D_ERASE = 0;    
        }      

        if (MODEL2D_ERASE == 1) {
          SOLARCHVISION_remove_2Dobjects();
          
          WIN3D_Update = 1;
      
          ROLLOUT_Update = 1;
      
          MODEL2D_ERASE = 0;    
        }        
        
        if (MODEL3D_ERASE == 1) {
          
          SOLARCHVISION_remove_3Dobjects();
          
          SOLARCHVISION_remove_ParametricGeometries();
          
          SOLARCHVISION_add_3Dbase(-2, 0, 0, 1, 0);
          
          SOLARCHVISION_calculate_SpatialImpact_selectedSections();

          WIN3D_Update = 1;
      
          ROLLOUT_Update = 1;
      
          MODEL3D_ERASE = 0;    
        }
        
        if (SECTION_ERASE == 1) {
          SOLARCHVISION_remove_Sections();
          
          WIN3D_Update = 1;
      
          ROLLOUT_Update = 1;
      
          SECTION_ERASE = 0;    
        }            
        
        if (pre_Load_Default_Models != Load_Default_Models) {
          
          SOLARCHVISION_remove_FractalPlants();
          
          SOLARCHVISION_remove_2Dobjects();
          
          SOLARCHVISION_remove_3Dobjects();
          
          SOLARCHVISION_remove_ParametricGeometries();
          
          SOLARCHVISION_add_3Dbase(-2, 0, 0, 1, 0);

          SOLARCHVISION_add_DefaultModel(Load_Default_Models);
          
          SOLARCHVISION_calculate_SpatialImpact_selectedSections();
          
          WIN3D_Update = 1;
      
          ROLLOUT_Update = 1;
        }
        
        
        if (pre_Create_Input_powAll != Create_Input_powAll) {
          Create_Input_powX = Create_Input_powAll;
          Create_Input_powY = Create_Input_powAll;
          Create_Input_powZ = Create_Input_powAll;
          
          ROLLOUT_Update = 1;
        }


        if (pre_SPATIAL_Pallet_CLR != SPATIAL_Pallet_CLR) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SPATIAL_Pallet_DIR != SPATIAL_Pallet_DIR) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SPATIAL_Pallet_MLT != SPATIAL_Pallet_MLT) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}

        if (pre_SpatialImpact_Grade != SpatialImpact_Grade) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_Power != SpatialImpact_Power) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_Rotation[SpatialImpact_sectionType] != SpatialImpact_Rotation[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_Elevation[SpatialImpact_sectionType] != SpatialImpact_Elevation[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}

        if (pre_SpatialImpact_scale_U[SpatialImpact_sectionType] != SpatialImpact_scale_U[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_scale_V[SpatialImpact_sectionType] != SpatialImpact_scale_V[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}

        if (pre_SpatialImpact_offset_U[SpatialImpact_sectionType] != SpatialImpact_offset_U[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_offset_V[SpatialImpact_sectionType] != SpatialImpact_offset_V[SpatialImpact_sectionType]) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}

        
        
        if (pre_SpatialImpact_Wspd != SpatialImpact_Wspd) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}
        if (pre_SpatialImpact_Wdir != SpatialImpact_Wdir) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}


        if (pre_PROCESS_subdivisions != PROCESS_subdivisions) {SOLARCHVISION_calculate_SpatialImpact_selectedSections(); WIN3D_Update = 1;}

        if (pre_Display_SpatialImpact_Points != Display_SpatialImpact_Points) WIN3D_Update = 1;
        if (pre_Display_SpatialImpact_Lines != Display_SpatialImpact_Lines) WIN3D_Update = 1;
        
        if (pre_Display_MODEL3D_EDGES != Display_MODEL3D_EDGES) WIN3D_Update = 1;
        if (pre_Display_MODEL3D_NORMALS != Display_MODEL3D_NORMALS) WIN3D_Update = 1;
        
        if (pre_Display_windFlow != Display_windFlow) WIN3D_Update = 1;

        if (Download_AERIAL != 0) {
          SOLARCHVISION_try_update_AERIAL(_YEAR, _MONTH, _DAY, _HOUR);
          
          Download_AERIAL = 0;
          ROLLOUT_Update = 1;
        }

            
        if (STUDY_setup != pre_STUDY_setup) {
          update_impacts = 1;
          BAR_d_Update = 0;
        }
        
        if (impacts_source != pre_impacts_source) {
          update_impacts = 1;
          BAR_d_Update = 0;
        } 

      }
    }
    


    if (FRAME_record_AUTO == 1) {
      if (STUDY_Update == 1) FRAME_record_JPG = 1;
      if (WIN3D_Update == 1) FRAME_record_JPG = 1;
      if (WORLD_Update == 1) FRAME_record_JPG = 1;
      //if (BAR_a_Update == 1) FRAME_record_JPG = 1;
      //if (BAR_b_Update == 1) FRAME_record_JPG = 1;
      //if (BAR_d_Update == 1) FRAME_record_JPG = 1;
    }




    int Illustrations_Animate = 0;

    //if ((STUDY_Update == 0) && (WIN3D_Update == 0)) {
    if (STUDY_Update == 0) {
      //Illustrations_Animate = 1;
    }

    if (STUDY_include == 1) {
      if (STUDY_Update == 1) {
        
        SOLARCHVISION_draw_STUDY();
        
      }
    }
    STUDY_Update = 0;
    
    if (STUDY_record_PDF == 0) {
/*      
      if (Illustrations_Animate != 0) {
        GRIB2_Layer = GRIB2_Layer_Start;
  
        GRIB2_Hour = GRIB2_Hour_Start;
        
        int d = (GRIB2_Hour_End - GRIB2_Hour_Start) / GRIB2_Hour_Step;      
        
        if (d > 1) {
          
          GRIB2_Hour += GRIB2_Hour_Step * (frameCount % d);
        
          if (GRIB2_Hour > GRIB2_Hour_End) GRIB2_Hour = GRIB2_Hour_Start;
        
          WORLD_Update = 1;
          WIN3D_Update = 1; // <<<<<<<<<<<
        }
      }
*/

      if (WORLD_include == 1) {
        if (WORLD_Update == 1) {
          
          SOLARCHVISION_draw_WORLD();
          
        }
      }
      
      if (WORLD_record_PDF == 0) {      
        if (WIN3D_include == 1) {
          if (WIN3D_Update == 1) {
            
            SOLARCHVISION_draw_WIN3D();
            
          }
        }
  
        if (BAR_a_Update == 1) {
          SOLARCHVISION_draw_window_BAR_a();
        }
    
        if (BAR_b_Update == 1) {
          SOLARCHVISION_draw_window_BAR_b();
        }
        
        if (BAR_d_Update == 1) {
          SOLARCHVISION_draw_window_BAR_d();
        }    


        
        if (FRAME_record_JPG == 1) {
          SOLARCHVISION_RecordFrame();
          FRAME_record_JPG = 0;  
        }
        
        
      }
      else {
        WORLD_record_PDF = 0; 
      }
    
    }
    else {
      STUDY_record_PDF = 0; 
    }


    //WIN3D_Update = 0;
    //WORLD_Update = 0;
    //STUDY_Update = 0;

    //noLoop(); // <<<<<<<<<<<<
  }

} 

float refScale = 250;

PGraphics WIN3D_Diagrams;

void SOLARCHVISION_draw_WIN3D () {
  
  if (WIN3D_Update == 1) {
    
    if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
      if (rebuild_SolarProjection_array != 0) {
        SOLARCHVISION_SolarProjection();
      }
    }     

    if (WIN3D_record_JPG == 1) WIN3D_Image_Scale = 2; //3;
    else WIN3D_Image_Scale = 1;
  
    //////////////////////////////////
    WIN3D_X_View *= WIN3D_Image_Scale;
    WIN3D_Y_View *= WIN3D_Image_Scale;
    //////////////////////////////////
    
    if (WIN3D_Image_Scale != 1) {
      println("IMG:high-res");
      WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);    
    }  
  
    WIN3D_Diagrams.beginDraw();  
  
    WIN3D_scale3D = WIN3D_Y_View / refScale; // fits field of view to window's height
  
    WIN3D_Diagrams.background(233);
  
    WIN3D_Diagrams.fill(127);
    WIN3D_Diagrams.strokeWeight(0);

    WIN3D_Diagrams.pushMatrix();
  
    WIN3D_Diagrams.hint(ENABLE_DEPTH_TEST);
    
    SOLARCHVISION_transform_Camera();
    
    SOLARCHVISION_put_Camera();
    
    SOLARCHVISION_draw_SKY3D();
  
    SOLARCHVISION_draw_SunPattern3D(0, 0, 0, 0.9 * SKY3D_scale);
  
    SOLARCHVISION_draw_SunPath3D(0, 0, 0, 0.9 * SKY3D_scale, LocationLatitude);
    
    SOLARCHVISION_draw_SolarRotation(0, 0, 0, (150000.0 * 1000000) * OBJECTS_scale, LocationLatitude);
    
    SOLARCHVISION_draw_STAR3D();
    
    SOLARCHVISION_draw_MOON3D();
    
    SOLARCHVISION_draw_EARTH3D();
    
    SOLARCHVISION_draw_TROPO3D();
    
    SOLARCHVISION_draw_land();

    SOLARCHVISION_draw_3Dobjects();

    SOLARCHVISION_draw_FractalPlants();
    
    SOLARCHVISION_draw_WindRose_Image();
    
    SOLARCHVISION_draw_Sections();
  
    SOLARCHVISION_draw_SpatialImpact_lines();
    
    SOLARCHVISION_draw_SpatialImpact_points();
    
    SOLARCHVISION_draw_2Dobjects();  
    
    SOLARCHVISION_draw_windFlow();
  
  
    WIN3D_Diagrams.sphereDetail(6, 4);
  
    for (int n = 0; n < AERIAL_num; n += 1) {
        
      if ((AERIAL_Center_Longitude == LocationLongitude) && (AERIAL_Center_Latitude == LocationLatitude)) {
    
        float _tgl = AERIAL_Locations[n][2];
        float _lat = AERIAL_Locations[n][1];
        float _lon = AERIAL_Locations[n][0]; 
        if (_lon > 180) _lon -= 360; // << important!
        
        double du = ((_lon - AERIAL_Center_Longitude) / 180.0) * (PI * R_earth);
        double dv = ((_lat - AERIAL_Center_Latitude) / 180.0) * (PI * R_earth);
        
        float x = 0.1 * (float) du * cos_ang((float) AERIAL_Center_Latitude); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float y = 0.1 * (float) dv;                                           // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float z = _tgl - HeightAboveGround;
        
        if (AERIAL_graphOption == 0) {
          //-----------------------------
          int PAL_TYPE = 6; //12; 
          int PAL_DIR = -1;
          float PAL_Multiplier = 1.0 / 30.0;
          //-----------------------------
    
          for (int o = 0; o < Scenarios_max; o += 1){
            
            float _val = AERIAL[GRIB2_Hour][_drybulb][n][o];
            
            if (_val < 0.9 * FLOAT_undefined) {
      
              float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;
              
              float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);             
      
              WIN3D_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
              WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);           
              //WIN3D_Diagrams.noFill();
      
              WIN3D_Diagrams.strokeWeight(0); // 2; <<<<<<<<<
  
              float R = 5;
              /*         
              WIN3D_Diagrams.beginShape();
              for (float teta = 0; teta < 360; teta += 360.0 / 6.0) {
                WIN3D_Diagrams.vertex((x + R * cos_ang(teta)) * OBJECTS_scale * WIN3D_scale3D, (y + R * sin_ang(teta)) * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              }
              WIN3D_Diagrams.endShape(CLOSE);
              */
              WIN3D_Diagrams.pushMatrix();
              WIN3D_Diagrams.translate(x * OBJECTS_scale * WIN3D_scale3D, y * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              WIN3D_Diagrams.sphere(R);
              WIN3D_Diagrams.popMatrix();
            }        
          }        
        }
        
        if (AERIAL_graphOption == 1) {
          
          //-----------------------------
          int PAL_TYPE = 1;//12; 
          int PAL_DIR = 1;//-1;
          float PAL_Multiplier = 0.1;//1.0 / 30.0;
          //-----------------------------
    
          for (int o = 0; o < Scenarios_max; o += 1){
            
            //float _val = AERIAL[GRIB2_Hour][_drybulb][n][o];
            float _val = AERIAL[GRIB2_Hour][_windspd][n][o];
            
            if (_val < 0.9 * FLOAT_undefined) {
              
              float teta = AERIAL[GRIB2_Hour][_winddir][n][o];
              float D_teta = 15; 
              float R = 5.0 * AERIAL[GRIB2_Hour][_windspd][n][o];
              
              float R_in = 0.0 * R; 
              float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta)));
              float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta)));
              float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta)));
              float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta)));                      
               
              float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta)));
              float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta)));
              float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta)));
              float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta)));          
              
              //float ox = -0.5 * (R * cos_ang(90 - teta));
              //float oy = -0.5 * (R * -sin_ang(90 - teta));
              //float ox = -1 * (R * cos_ang(90 - teta));
              //float oy = -1 * (R * -sin_ang(90 - teta));
              float ox = -2 * (R * cos_ang(90 - teta)) / 3.0;
              float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0;            
      
              float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;
              
              float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);             
      
              WIN3D_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
              //WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);           
              WIN3D_Diagrams.noFill();
      
              WIN3D_Diagrams.strokeWeight(2); // 0; <<<<<<<<<
             
              WIN3D_Diagrams.beginShape();
              WIN3D_Diagrams.vertex((x + x1 + ox) * OBJECTS_scale * WIN3D_scale3D, (y + y1 + oy) * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              WIN3D_Diagrams.vertex((x + x2 + ox) * OBJECTS_scale * WIN3D_scale3D, (y + y2 + oy) * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              WIN3D_Diagrams.vertex((x + x3 + ox) * OBJECTS_scale * WIN3D_scale3D, (y + y3 + oy) * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              WIN3D_Diagrams.vertex((x + x4 + ox) * OBJECTS_scale * WIN3D_scale3D, (y + y4 + oy) * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
              WIN3D_Diagrams.endShape(CLOSE);
            }        
          }
        }
      }
    }   


    
    WIN3D_Diagrams.popMatrix();
    
    WIN3D_Diagrams.hint(DISABLE_DEPTH_TEST);
    
    SOLARCHVISION_draw_pallet_on_WIN3D();  
    
    WIN3D_Diagrams.endDraw();
  
    if ((WIN3D_record_JPG == 1) || (WIN3D_record_AUTO == 1)) {
      String myFile = MAKE_Filenames(CreateStamp(1) + "WIN3D_") + ".jpg";
      WIN3D_Diagrams.save(myFile);
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);       
    }
    
    imageMode(CORNER);
    image(WIN3D_Diagrams, WIN3D_CX_View, WIN3D_CY_View, WIN3D_X_View / WIN3D_Image_Scale, WIN3D_Y_View / WIN3D_Image_Scale);
    
    
     
    if ((WIN3D_record_JPG == 1) || (WIN3D_record_AUTO == 0)) WIN3D_record_JPG = 0;  
  
    //////////////////////////////////
    WIN3D_X_View /= WIN3D_Image_Scale;
    WIN3D_Y_View /= WIN3D_Image_Scale;  
    //////////////////////////////////
  
    if (WIN3D_Image_Scale != 1) {
      WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);
      WIN3D_Update = 0; //1;    
    }   
    else {
      WIN3D_Update = 0;
      
      SOLARCHVISION_draw_Perspective_Internally();
    }
  }

}

void SOLARCHVISION_draw_pallet_on_WIN3D () {

  int draw_pal = 0;

  int PAL_TYPE = 0; 
  int PAL_DIR = 1;
  float PAL_Multiplier = 1; 

  if ((WIN3D_FACES_SHADE == Shade_Vertex_Solar) || (WIN3D_FACES_SHADE == Shade_Global_Solar)) {
    
    if (Impact_TYPE == Impact_ACTIVE) {
      PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR; 
      PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;  
    }   
    
    draw_pal = 1;
  }

  if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {

    PAL_TYPE = ELEVATION_Pallet_CLR; 
    PAL_DIR = ELEVATION_Pallet_DIR; 
    PAL_Multiplier = ELEVATION_Pallet_MLT; 
          
    draw_pal = 1;      
  }

  if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {

    PAL_TYPE = SPATIAL_Pallet_CLR; 
    PAL_DIR = SPATIAL_Pallet_DIR;
    PAL_Multiplier = SPATIAL_Pallet_MLT;
          
    draw_pal = 1;      
  }          


     
  
  if (draw_pal != 0) {
    
    float the_scale = 1;
  
    if (WIN3D_View_Type == 1) {
      
      //the_scale *= (0.5 * WIN3D_scale3D / tan(0.5 * CAM_fov)) * refScale;
      the_scale *= (0.5 / tan(0.5 * CAM_fov));
    }
    else {
      float ZOOM = Orthographic_Zoom();
  
      //the_scale *= (1.0 / ZOOM) * (0.5 * WIN3D_scale3D);
      the_scale *= (0.5 / ZOOM);
    }  
    
    WIN3D_Diagrams.pushMatrix();
  
    CAM_fov = WIN3D_ZOOM_coordinate * PI / 180;
  
    CAM_dist = (0.5 * refScale) / tan(0.5 * CAM_fov);
  
    if (WIN3D_View_Type == 1) {
  
      float aspect = 1.0 / WIN3D_R_View;
      
      float zFar = CAM_dist * 1000;
      float zNear = CAM_dist * 0.001;
  
      WIN3D_Diagrams.translate(0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View, 0); // << IMPORTANT!
    }
    else {
  
      float ZOOM = Orthographic_Zoom();
      
      WIN3D_Diagrams.translate(0, 1.0 * WIN3D_Y_View, 0); // << IMPORTANT!
    }
  


    


  
  
  
    float pal_length = 1 * h_pixel * WIN3D_Image_Scale / the_scale;
    
    for (int q = 0; q < 11; q += 1) {
      
      float _u = 0.1 * q;
      
      if ((WIN3D_FACES_SHADE == Shade_Vertex_Solar) || (WIN3D_FACES_SHADE == Shade_Global_Solar)) {
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) {
          _u = 0.2 * q - 0.5;
          _u = (_u - 0.5) * 0.75 + 0.5;
        }        
      }
        
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
      
      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u); 
      
      WIN3D_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
      WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
      
      WIN3D_Diagrams.strokeWeight(0);
      
      float x1 = -0.5 * pal_length + q * (pal_length / 11.0); 
      float x2 = x1 + (pal_length / 11.0);
      float y1 = -0.2 * (x2 - x1) + (0.4 * WIN3D_Y_View / the_scale);
      float y2 = y1 + 0.4 * (x2 - x1);
      
      WIN3D_Diagrams.beginShape();
      WIN3D_Diagrams.vertex(x1, y1, 0);
      WIN3D_Diagrams.vertex(x1, y2, 0);
      WIN3D_Diagrams.vertex(x2, y2, 0);
      WIN3D_Diagrams.vertex(x2, y1, 0);
      WIN3D_Diagrams.endShape(CLOSE);    
  
      if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
        WIN3D_Diagrams.stroke(127);
        WIN3D_Diagrams.fill(127);
        WIN3D_Diagrams.strokeWeight(0);
      }
      else {
        WIN3D_Diagrams.stroke(255);
        WIN3D_Diagrams.fill(255);
        WIN3D_Diagrams.strokeWeight(2);
      }  
      
      float txtSize = y2 - y1;
                  
      WIN3D_Diagrams.textSize(txtSize);
      WIN3D_Diagrams.textAlign(CENTER, CENTER);
      
      if ((WIN3D_FACES_SHADE == Shade_Vertex_Solar) || (WIN3D_FACES_SHADE == Shade_Global_Solar)) {
        if (Impact_TYPE == Impact_ACTIVE) WIN3D_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        if (Impact_TYPE == Impact_PASSIVE) WIN3D_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }

      if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
        WIN3D_Diagrams.text(nf(int(roundTo(1.0 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }
      
      if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
        WIN3D_Diagrams.text(nf(int(roundTo(1.0 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }
    }
    
      
    WIN3D_Diagrams.popMatrix();  
  }


}






PGraphics WORLD_Diagrams;

void SOLARCHVISION_draw_WORLD () {
  
  if (WORLD_Update == 1) {
  
    if (WORLD_record_PDF == 1) WORLD_Image_Scale = 1;
    else if (WORLD_record_JPG == 1) WORLD_Image_Scale = 2;
    else WORLD_Image_Scale = 1;
    
    //////////////////////////////////
    WORLD_X_View *= WORLD_Image_Scale;
    WORLD_Y_View *= WORLD_Image_Scale;  
    //////////////////////////////////  
    
    if (WORLD_record_PDF == 1) {
      println("PDF:begin");
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, PDF, MAKE_Filenames(CreateStamp(1) + "WORLD_") + ".pdf");
      beginRecord(WORLD_Diagrams);
    }
    else if (WORLD_Image_Scale != 1) {
      println("IMG:high-res");
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
      WORLD_Diagrams.beginDraw();
    }  
    else {
      WORLD_Diagrams.beginDraw();
    }
    
    WORLD_Diagrams.background(0, 0, 0);
 
    WORLD_Diagrams.image(WORLDViewImage, 0, 0, WORLD_X_View, WORLD_Y_View);
    
    float WORLD_VIEW_OffsetX = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0] + 180;
    float WORLD_VIEW_OffsetY = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - 90;
      
    float WORLD_VIEW_ScaleX = (WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) / 360.0;
    float WORLD_VIEW_ScaleY = (WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) / 180.0;    

    float _lon1 = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0];
    float _lon2 = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1];
    float _lat1 = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0];
    float _lat2 = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1];
  
    int x_point1 = int(WORLD_X_View * (( 1 * (_lon1 - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX);
    int y_point1 = int(WORLD_Y_View * ((-1 * (_lat1 - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY);
    int x_point2 = int(WORLD_X_View * (( 1 * (_lon2 - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX);
    int y_point2 = int(WORLD_Y_View * ((-1 * (_lat2 - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY); 
  
    float R_station = 2 * WORLD_Image_Scale;
    if (WORLD_VIEW_GridDisplay[WORLD_VIEW_Number] == 1) R_station = 5; 
  
    WORLD_Diagrams.ellipseMode(CENTER);
  
    for (int n = 0; n < AERIAL_num; n += 1) {
      
      //try {
        
        if ((AERIAL_Center_Longitude == LocationLongitude) && (AERIAL_Center_Latitude == LocationLatitude)) {
      
          float _lat = AERIAL_Locations[n][1];
          float _lon = AERIAL_Locations[n][0]; 
          if (_lon > 180) _lon -= 360; // << important!
    
          float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
          float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY; 
  
          WORLD_Diagrams.pushMatrix();
          WORLD_Diagrams.translate(x_point, y_point);
          
          if (AERIAL_graphOption == 0) {
            //-----------------------------
            int PAL_TYPE = 6; //12; 
            int PAL_DIR = -1;
            float PAL_Multiplier = 1.0 / 30.0;
            //-----------------------------
    
            for (int _turn = 1; _turn <= 2; _turn += 1){
              for (int o = 0; o < Scenarios_max; o += 1){
              
                float _val = AERIAL[GRIB2_Hour][_drybulb][n][o];
                
                if (_val < 0.9 * FLOAT_undefined) {
                
                  float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
                  
                  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);             
        
                  if (_turn == 1) {
                    WORLD_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
                    WORLD_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);           
        
                    WORLD_Diagrams.strokeWeight(0);
                    WORLD_Diagrams.ellipse(0, 0, R_station, R_station);
                  }
                  
                  if (_turn == 2) {
                    WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
                    WORLD_Diagrams.textAlign(CENTER, CENTER);
      
                    _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                    
                    if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
                      WORLD_Diagrams.stroke(127);
                      WORLD_Diagrams.fill(127);
                      WORLD_Diagrams.strokeWeight(0);
                    }
                    else {
                      WORLD_Diagrams.stroke(255);
                      WORLD_Diagrams.fill(255);
                      WORLD_Diagrams.strokeWeight(2 * WORLD_Image_Scale);
                    }              
                    if (_val < 0.9 * FLOAT_undefined) WORLD_Diagrams.text(nf(int(roundTo(_val, 1)), 0), 0,0);
                  }
                }
              }
            }            
          }  
          
          if (AERIAL_graphOption == 1) {
  
            //-----------------------------
            int PAL_TYPE = 1;//12; 
            int PAL_DIR = 1;//-1;
            float PAL_Multiplier = 0.1;//1.0 / 30.0;
            //-----------------------------
    
            for (int _turn = 1; _turn <= 2; _turn += 1){
              for (int o = 0; o < Scenarios_max; o += 1){
              
                //float _val = AERIAL[GRIB2_Hour][_drybulb][n][o];
                float _val = AERIAL[GRIB2_Hour][_windspd][n][o];
                
                if (_val < 0.9 * FLOAT_undefined) {              
                  
                  float teta = AERIAL[GRIB2_Hour][_winddir][n][o];
                  float D_teta = 15; 
                  float R = 0.25 * R_station * AERIAL[GRIB2_Hour][_windspd][n][o];
                  
                  float R_in = 0.0 * R; 
                  float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta))) * WORLD_Image_Scale;
                  float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta))) * WORLD_Image_Scale;
                  float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta))) * WORLD_Image_Scale;
                  float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta))) * WORLD_Image_Scale;                      
                   
                  float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta))) * WORLD_Image_Scale;
                  float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta))) * WORLD_Image_Scale;
                  float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta))) * WORLD_Image_Scale;
                  float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta))) * WORLD_Image_Scale;          
                  
                  //float ox = -0.5 * (R * cos_ang(90 - teta)) * WORLD_Image_Scale;
                  //float oy = -0.5 * (R * -sin_ang(90 - teta)) * WORLD_Image_Scale;
                  //float ox = -1 * (R * cos_ang(90 - teta)) * WORLD_Image_Scale;
                  //float oy = -1 * (R * -sin_ang(90 - teta)) * WORLD_Image_Scale;
                  float ox = -2 * (R * cos_ang(90 - teta)) / 3.0 * WORLD_Image_Scale;
                  float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0 * WORLD_Image_Scale;            
      
                  float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
                  
                  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);             
        
                  if (_turn == 1) {
                    WORLD_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
                    WORLD_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);           
        
                    WORLD_Diagrams.strokeWeight(0);
                    //WORLD_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    WORLD_Diagrams.quad(x1 + ox, y1 + oy, x2 + ox, y2 + oy, x3 + ox, y3 + oy, x4 + ox, y4 + oy);
                  }
                  
                  if (_turn == 2) {
                    WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
                    WORLD_Diagrams.textAlign(CENTER, CENTER);
      
                    _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                    
                    if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
                      WORLD_Diagrams.stroke(127);
                      WORLD_Diagrams.fill(127);
                      WORLD_Diagrams.strokeWeight(0);
                    }
                    else {
                      WORLD_Diagrams.stroke(255);
                      WORLD_Diagrams.fill(255);
                      WORLD_Diagrams.strokeWeight(2 * WORLD_Image_Scale);
                    }              
                    if (_val < 0.9 * FLOAT_undefined) WORLD_Diagrams.text(nf(int(roundTo(_val, 1)), 0), 0,0);
                  }
                }
              }
            }
          }
          
          WORLD_Diagrams.popMatrix();
        }
      //}
      //catch (Exception e) {
      //}
  
    }   
    
        
  

    {
      float _lat = LocationLatitude;
      float _lon = LocationLongitude; 
      if (_lon > 180) _lon -= 360; // << important!
    
      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY; 
  
      WORLD_Diagrams.strokeWeight(3 * WORLD_Image_Scale);
      WORLD_Diagrams.stroke(0, 0, 127, 255);
      WORLD_Diagrams.noFill();
  
      WORLD_Diagrams.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
    }   
  
    int nearest_Station_OBSERVED = -1;
    float nearest_Station_OBSERVED_dist = FLOAT_undefined;
    
    for (int f = 0; f < STATION_SWOB_INFO.length; f += 1) {
      float draw_info = 0;
    
      if (Display_SWOB_points != 0) draw_info = 1;
    
      float _lat = float(STATION_SWOB_INFO[f][3]);
      float _lon = float(STATION_SWOB_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!
 
      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 
    
      if (draw_info == 1) {
  
        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
  
        WORLD_Diagrams.strokeWeight(0);
        WORLD_Diagrams.stroke(191, 0, 0, 191);
        WORLD_Diagrams.fill(191, 0, 0, 191);      
        WORLD_Diagrams.ellipse(x_point, y_point, R_station, R_station);
  
        if (Display_SWOB_points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
          WORLD_Diagrams.text(STATION_SWOB_INFO[f][6], x_point, y_point);
        }
      
      }
      
      float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
      
      if (nearest_Station_OBSERVED_dist > d) {
        nearest_Station_OBSERVED_dist = d;
        nearest_Station_OBSERVED = f;
      }     
    }    
    
    if (Display_SWOB_nearest == 1) {   
      int f = nearest_Station_OBSERVED;
      
      float _lat = float(STATION_SWOB_INFO[f][3]);
      float _lon = float(STATION_SWOB_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!
      
      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
      
      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER);
      WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
      WORLD_Diagrams.text(STATION_SWOB_INFO[f][6], x_point, y_point);
      //println(STATION_SWOB_INFO[f][6]);
    }  
  
  
  
    int nearest_STATION_NAEFS = -1;
    float nearest_STATION_NAEFS_dist = FLOAT_undefined;
              
    for (int f = 0; f < STATION_NAEFS_INFO.length; f += 1) {
      float draw_info = 0;
    
      if (Display_NAEFS_points != 0) draw_info = 1;
    
      float _lat = float(STATION_NAEFS_INFO[f][3]);
      float _lon = float(STATION_NAEFS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!
    
      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 
    
      if (draw_info == 1) {
  
        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
  
        WORLD_Diagrams.strokeWeight(0);
        WORLD_Diagrams.stroke(0, 63, 0, 127);
        WORLD_Diagrams.fill(0, 63, 0, 127);
        
        WORLD_Diagrams.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
  
        if (Display_NAEFS_points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
          WORLD_Diagrams.text(STATION_NAEFS_INFO[f][0], x_point, y_point);
        }
  
      }
      
      float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
      
      if (nearest_STATION_NAEFS_dist > d) {
        nearest_STATION_NAEFS_dist = d;
        nearest_STATION_NAEFS = f;
      } 
      
    }
    
    if (Display_NAEFS_nearest == 1) {   
      int f = nearest_STATION_NAEFS;
    
      float _lat = float(STATION_NAEFS_INFO[f][3]);
      float _lon = float(STATION_NAEFS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!      
      
      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
      
      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
      WORLD_Diagrams.text(STATION_NAEFS_INFO[f][0], x_point, y_point);
      //println(STATION_NAEFS_INFO[f][0]);
    }
    
  
    int nearest_STATION_CWEEDS = -1;
    float nearest_STATION_CWEEDS_dist = FLOAT_undefined;
              
    for (int f = 0; f < STATION_CWEEDS_INFO.length; f += 1) {
      float draw_info = 0;
    
      if (Display_CWEEDS_points != 0) draw_info = 1;
      
      float _lat = float(STATION_CWEEDS_INFO[f][3]);
      float _lon = float(STATION_CWEEDS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!
    
      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 
    
      if (draw_info == 1) {
  
        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
  
        WORLD_Diagrams.strokeWeight(2 * WORLD_Image_Scale);
        WORLD_Diagrams.stroke(0, 0, 0, 191);
        WORLD_Diagrams.noFill();
        WORLD_Diagrams.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
        if (Display_CWEEDS_points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
          WORLD_Diagrams.text(STATION_CWEEDS_INFO[f][0], x_point, y_point);
        } 
      }
      
      float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
      
      if (nearest_STATION_CWEEDS_dist > d) {
        nearest_STATION_CWEEDS_dist = d;
        nearest_STATION_CWEEDS = f;
      }     
    } 
  
    if (Display_CWEEDS_nearest == 1) {   
      int f = nearest_STATION_CWEEDS;
    
      float _lat = float(STATION_CWEEDS_INFO[f][3]);
      float _lon = float(STATION_CWEEDS_INFO[f][4]);  
      if (_lon > 180) _lon -= 360; // << important!      
      
      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
      
      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
      WORLD_Diagrams.text(STATION_CWEEDS_INFO[f][0], x_point, y_point);
      //println(STATION_CWEEDS_INFO[f][0]);
    }
    
   
    int nearest_STATION_EPW = -1;
    float nearest_STATION_EPW_dist = FLOAT_undefined;
              
    for (int f = 0; f < STATION_EPW_INFO.length; f += 1) {
      float draw_info = 0;
      
      if (Display_EPW_points != 0) draw_info = 1;
      
      float _lat = float(STATION_EPW_INFO[f][3]);
      float _lon = float(STATION_EPW_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!
    
      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 
    
      if (draw_info == 1) {
  
        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
  
        WORLD_Diagrams.strokeWeight(2 * WORLD_Image_Scale);
        WORLD_Diagrams.stroke(255, 0, 0, 127);
        WORLD_Diagrams.noFill();
        WORLD_Diagrams.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
        if (Display_EPW_points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
          WORLD_Diagrams.text(STATION_EPW_INFO[f][0], x_point, y_point);
        } 
      }
      
      float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
      
      if (nearest_STATION_EPW_dist > d) {
        nearest_STATION_EPW_dist = d;
        nearest_STATION_EPW = f;
      }     
    } 
  
    if (Display_EPW_nearest == 1) {   
      int f = nearest_STATION_EPW;
    
      float _lat = float(STATION_EPW_INFO[f][3]);
      float _lon = float(STATION_EPW_INFO[f][4]);  
      if (_lon > 180) _lon -= 360; // << important!      
      
      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
      
      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MESSAGE_S_View * WORLD_Image_Scale);
      WORLD_Diagrams.text(STATION_EPW_INFO[f][0], x_point, y_point);
      //println(STATION_EPW_INFO[f][0]);
    }
  
   
    WORLD_Diagrams.strokeWeight(0);
    
    
    if (WORLD_record_PDF == 1) {
      endRecord();
      
      String myFile = MAKE_Filenames(CreateStamp(0) + "WORLD_") + ".pdf";
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);      
    }
    else {
      WORLD_Diagrams.endDraw();
      
      if ((WORLD_record_JPG == 1) || (WORLD_record_AUTO == 1)) {
        String myFile = MAKE_Filenames(CreateStamp(1) + "WORLD_") + ".jpg";
        WORLD_Diagrams.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }
      
      imageMode(CORNER);
      image(WORLD_Diagrams, WORLD_CX_View, WORLD_CY_View, WORLD_X_View / WORLD_Image_Scale, WORLD_Y_View / WORLD_Image_Scale);
   
    }
  
  
    //////////////////////////////////
    WORLD_X_View /= WORLD_Image_Scale;
    WORLD_Y_View /= WORLD_Image_Scale;  
    //////////////////////////////////
  
    if ((WORLD_Image_Scale != 1) || (WORLD_record_PDF == 1)) {
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
      WORLD_Update = 0; //1;    
    }   
    else {
      WORLD_Update = 0;
    }
    
    
    if ((WORLD_record_JPG == 1) || (WORLD_record_AUTO == 0)) WORLD_record_JPG = 0;  
  }
}





void SOLARCHVISION_draw_STUDY () {

  cursor(WAIT);
  
  
  if (STUDY_Update == 1) {
  
    if (STUDY_record_PDF == 1) STUDY_Image_Scale = 1;
    else if (STUDY_record_JPG == 1) STUDY_Image_Scale = 2;
    else STUDY_Image_Scale = 1;
    
    //////////////////////////////////
    STUDY_X_View *= STUDY_Image_Scale;
    STUDY_Y_View *= STUDY_Image_Scale;  
    STUDY_T_scale *= STUDY_Image_Scale;
    //////////////////////////////////  
    
    if (STUDY_record_PDF == 1) {
      println("PDF:begin");
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, PDF, MAKE_Filenames(CreateStamp(1) + "STUDY_") + ".pdf");
      beginRecord(STUDY_Diagrams);
    }
    else if (STUDY_Image_Scale != 1) {
      println("IMG:high-res");
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
      STUDY_Diagrams.beginDraw();
    }  
    else {
      STUDY_Diagrams.beginDraw();
    }  
  
    draw_frame += 1;
    println("frame:", draw_frame);    
    
    //if (update_DevelopDATA == 1) {
      if (STUDY_drw_Layer == _developed) {
        SOLARCHVISION_DevelopDATA(impacts_source);
        
        println("DevelopDATA updated!");
        
        update_DevelopDATA = 0;
      }
    //}     
    
     
    STUDY_S_View = (STUDY_X_View / 2100.0);
    STUDY_U_scale = 18.0 / float(STUDY_j_end - STUDY_j_start);
   
    
    STUDY_X_coordinate = -0.333 * STUDY_X_View;      
    
    STUDY_Y_coordinate = 1.0 * STUDY_Y_View;
    

    STUDY_Diagrams.background(255);
    
    STUDY_Diagrams.blendMode(BLEND);
  
    STUDY_Diagrams.strokeJoin(ROUND); 
    
    STUDY_Diagrams.textFont(SOLARCHVISION_font);
    
    STUDY_Diagrams.strokeWeight(0);
    
    //STUDY_Diagrams.translate(STUDY_X_coordinate * -0.25, STUDY_Y_coordinate * 0.5); 
    STUDY_Diagrams.translate(STUDY_X_coordinate * -0.425, STUDY_Y_coordinate * 0.5);

    Plot_Setup();
    
    //STUDY_Diagrams.translate(STUDY_X_coordinate * 0.25, STUDY_Y_coordinate * 0.5);
    STUDY_Diagrams.translate(STUDY_X_coordinate * 0.425, STUDY_Y_coordinate * 0.5);

    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      
    STUDY_Diagrams.stroke(63);
    STUDY_Diagrams.fill(63);
    STUDY_Diagrams.textAlign(CENTER, CENTER);

    String _text = "SOLARCHVISION post-processing";

    if (impacts_source == databaseNumber_CLIMATE_EPW) _text += " based on typical-year data for Building Energy Simulation";  //"(EPW - U.S. Department of Energy)";
    if (impacts_source == databaseNumber_CLIMATE_WY2) _text += " based on long-term Canadian Weather Energy and Engineering Datasets (CWEEDS - Environment Canada)";
    if (impacts_source == databaseNumber_ENSEMBLE) _text += " based on the North American Ensemble Forecast System (NAEFS - Environment Canada)";
    if (impacts_source == databaseNumber_OBSERVED) _text += " based on real-time Surface Weather Observation (SWOB - Environment Canada)";
    
    //_text += ", www.solarchvision.com";

    STUDY_Diagrams.textSize(STUDY_X_View * 0.01);
    ///STUDY_Diagrams.text(_text, STUDY_X_View * 0.55, STUDY_Y_View * -0.1666 / STUDY_R_View, 0);

    if (STUDY_record_PDF == 1) {
      endRecord();
      
      String myFile = MAKE_Filenames(CreateStamp(0) + "STUDY_") + ".pdf";
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);             
    }
    else {
      STUDY_Diagrams.endDraw();
      
      if ((STUDY_record_JPG == 1) || (STUDY_record_AUTO == 1)) {
        String myFile = MAKE_Filenames(CreateStamp(1) + "STUDY_") + ".jpg";
        STUDY_Diagrams.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);        
      }
      
      imageMode(CORNER);
      image(STUDY_Diagrams, STUDY_CX_View, STUDY_CY_View, STUDY_X_View / STUDY_Image_Scale, STUDY_Y_View / STUDY_Image_Scale);
   
    }

    //////////////////////////////////
    STUDY_X_View /= STUDY_Image_Scale;
    STUDY_Y_View /= STUDY_Image_Scale;
    STUDY_T_scale /= STUDY_Image_Scale;
    //////////////////////////////////
  
    if ((STUDY_Image_Scale != 1) || (STUDY_record_PDF == 1)) {
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
      STUDY_Update = 0; //1;    
    }   
    else {
      STUDY_Update = 0;
    }
    
    
    if ((STUDY_record_JPG == 1) || (STUDY_record_AUTO == 0)) STUDY_record_JPG = 0;  
  
  }

  Export_STUDY_info_node = 0;
  Export_STUDY_info_norm = 0;
  Export_STUDY_info_prob = 0;

  cursor(ARROW);
  
} 



int now_drawing = -1; // -1 = Nothing, 0 = Climate WY2, 1 = Forecast-NAEFS, 2 = Observation, 3 = Climate EPW 

void SOLARCHVISION_PlotHOURLY (float x, float y, float z, float sx, float sy, float sz) {
  
  int draw_climate_WY2 = 0;
  int draw_forecast = 0;
  int draw_observed = 0;
  int draw_climate_EPW = 0; 
  
  if (impacts_source == databaseNumber_CLIMATE_WY2) draw_climate_WY2 = 1;
  if (impacts_source == databaseNumber_ENSEMBLE) draw_forecast = 1;
  if (impacts_source == databaseNumber_OBSERVED) draw_observed = 1;
  if (impacts_source == databaseNumber_CLIMATE_EPW) draw_climate_EPW = 1;
  
  //////////////////
  draw_observed = 1;
  //////////////////  

  if (draw_climate_EPW == 1) {
    now_drawing = databaseNumber_CLIMATE_EPW;
    SOLARCHVISION_PlotCLIMATE_EPW(x, y, z, sx, sy, sz);
  }  
  if (draw_climate_WY2 == 1) {
    now_drawing = databaseNumber_CLIMATE_WY2;
    SOLARCHVISION_PlotCLIMATE_WY2(x, y, z, sx, sy, sz);
  }
  if (draw_forecast == 1) {
    now_drawing = databaseNumber_ENSEMBLE;
    SOLARCHVISION_PlotENSEMBLE(x, y, z, sx, sy, sz);
  }
  if (draw_observed == 1) {

    int keep_draw_data_lines = draw_data_lines;
    int keep_draw_sorted = draw_sorted;
    int keep_draw_normals = draw_normals;
    int keep_draw_probs = draw_probs;
    
    draw_data_lines = 1;
    draw_sorted = 0;
    draw_normals = 1;
    draw_probs = 0; 
    
    now_drawing = databaseNumber_OBSERVED;
    SOLARCHVISION_PlotOBSERVED(x, y, z, sx, sy, sz);
    
    draw_data_lines = keep_draw_data_lines;
    draw_sorted = keep_draw_sorted;
    draw_normals = keep_draw_normals;
    draw_probs = keep_draw_probs; 
  }
  
  now_drawing = -1;

}





void Plot_Setup () {

  if (STUDY_setup == 14) {

    if (frame_variation == 2) {

      for (int p = 0; p < 3; p += 1) { 
        impact_layer = 3 * int(pre_impact_layer / 3) + p;

        SOLARCHVISION_PlotIMPACT(0, (175 - p * 350) * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
      }
      impact_layer = pre_impact_layer;
    
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    }
    
    else {

      if ((plot_impacts == 8) || (plot_impacts == 9)) {
        
        int keep_BEGIN_DAY = BEGIN_DAY;
        float keep_per_day = per_day;
        int keep_STUDY_j_end = STUDY_j_end;
        float keep_STUDY_U_scale = STUDY_U_scale;
        
        BEGIN_DAY = 183; //0; // 183: to put the summer diagram on the left similar to the YC book
        per_day = 183;
        STUDY_j_end = 2;
        STUDY_U_scale = 18.0 / float(STUDY_j_end - STUDY_j_start);
        
        SOLARCHVISION_PlotIMPACT(0, 0 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
        
        BEGIN_DAY = keep_BEGIN_DAY;
        per_day = keep_per_day;
        STUDY_j_end = keep_STUDY_j_end;
        STUDY_U_scale = keep_STUDY_U_scale;
      }
      else{
        SOLARCHVISION_PlotIMPACT(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
        
        SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
      }
      
    }

  }  
  
  // -----------------------------------------------
  
  if (STUDY_setup == -2) {
    if (impacts_source == databaseNumber_ENSEMBLE) {
      pre_DATE = _DATE;
      int keep_BEGIN_DAY = BEGIN_DAY;
      int delta = 4;
      
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      _DATE -= delta;
      SOLARCHVISION_update_date();
      BEGIN_DAY = Convert2Date(_MONTH, _DAY);
      SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
      BEGIN_DAY = (BEGIN_DAY + delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      _DATE -= delta;
      SOLARCHVISION_update_date();
      BEGIN_DAY = Convert2Date(_MONTH, _DAY);
      SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
      BEGIN_DAY = (BEGIN_DAY + 2 * delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      _DATE -= delta;
      SOLARCHVISION_update_date();
      BEGIN_DAY = Convert2Date(_MONTH, _DAY);
      SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
      BEGIN_DAY = (BEGIN_DAY + 3 * delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
      
      _DATE = pre_DATE;
      SOLARCHVISION_update_date();
      BEGIN_DAY = Convert2Date(_MONTH, _DAY);
      SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
      BEGIN_DAY = keep_BEGIN_DAY;
    }
  }
  
  
  if (STUDY_setup == -1) {
    pre_impacts_source = impacts_source;
    
    impacts_source = databaseNumber_ENSEMBLE; 

    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
    
    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    impacts_source = databaseNumber_CLIMATE_WY2;
    
    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
    
    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0; 
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    impacts_source = pre_impacts_source;
  }
  
  
  if (STUDY_setup == 0) {
    if (impacts_source == databaseNumber_CLIMATE_WY2) {
      
      
      H_layer_option = 3;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      H_layer_option = 4;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      H_layer_option = 5;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      H_layer_option = 0;
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
      
      H_layer_option = pre_H_layer_option;
    }       
    if (impacts_source == databaseNumber_ENSEMBLE) {
      
      
      F_layer_option = 4;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      F_layer_option = 3;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      F_layer_option = 1;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 
  
      F_layer_option = 0;
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
      
      F_layer_option = pre_F_layer_option;
    } 
  }


  if (STUDY_setup == 1) {
    
    develop_Layer = STUDY_drw_Layer;
    STUDY_drw_Layer = _developed; 
    
    develop_option = DEV_OP_1;
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    develop_option = DEV_OP_2;
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    develop_option = DEV_OP_3;
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    develop_option = DEV_OP_4;
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    develop_option = pre_develop_option;
    STUDY_drw_Layer = pre_STUDY_drw_Layer; 
  }  
  
  
  if (STUDY_setup == 2) {
    if (STUDY_drw_Layer != _developed) {
      
      
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      develop_Layer = STUDY_drw_Layer;
      STUDY_drw_Layer = _developed;
  
      develop_option = DEV_OP_6; 
      SOLARCHVISION_DevelopDATA(impacts_source);
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      develop_option = DEV_OP_7; 
      SOLARCHVISION_DevelopDATA(impacts_source);
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
  
      develop_option = DEV_OP_8; 
      SOLARCHVISION_DevelopDATA(impacts_source);
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
      
      STUDY_drw_Layer = pre_STUDY_drw_Layer; 
    }
  }  
  
  
  if (STUDY_setup == 3) {
    
    STUDY_drw_Layer = _windspd200hPa;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _pressure;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _heightp500hPa;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _thicknesses_1000_500;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = pre_STUDY_drw_Layer;
  }
  
  
  if (STUDY_setup == 4) {
        
    STUDY_drw_Layer = _windspd;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = A_precipitation;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _relhum;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _drybulb;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = pre_STUDY_drw_Layer;
  }  
  
  
  if (STUDY_setup == 5) {
    
    STUDY_drw_Layer = _dirnorrad;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _difhorrad;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _developed;
    develop_option = DEV_OP_1; 
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _developed;
    develop_option = DEV_OP_3; 
    SOLARCHVISION_DevelopDATA(impacts_source);
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = pre_STUDY_drw_Layer;
    develop_option = pre_develop_option;
  }
  
  
  if (STUDY_setup == 6) {
    
    sky_scenario = 4;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    sky_scenario = 3;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    sky_scenario = 2;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    sky_scenario = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    sky_scenario = pre_sky_scenario;
  }  
  
  
  if (STUDY_setup == 7) {
    
    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1; 
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = -2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = -1;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
   
    plot_impacts = pre_plot_impacts; 
  }
  

  if (STUDY_setup == 8) {    
    
    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = 3;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = pre_plot_impacts; 
    impact_layer = pre_impact_layer;
  }


  if (STUDY_setup == 9) {
    
    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = 2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = pre_plot_impacts;
    impact_layer = pre_impact_layer;
  }

  if (STUDY_setup == 10) {

    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = 4;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = pre_plot_impacts; 
    impact_layer = pre_impact_layer;
  }
  
  if (STUDY_setup == 11) {

    draw_sorted = 0;
    draw_normals = 0;
    draw_data_lines = 1;
    draw_probs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    draw_sorted = 1;
    draw_normals = 1;
    draw_data_lines = 0;
    draw_probs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);
    
    plot_impacts = 5;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = pre_plot_impacts; 
    impact_layer = pre_impact_layer;
  }  

  if (STUDY_setup == 12) {

    if (automated != 0) {
      draw_sorted = 0;
      draw_normals = 1;
      draw_data_lines = 0;
      draw_probs = 1;
    }

    STUDY_drw_Layer = _windspd; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    //STUDY_drw_Layer = A_precipitation ; 
    //develop_Layer = STUDY_drw_Layer;
    //STUDY_drw_Layer = _developed; 
    //develop_option = DEV_OP_9;
    //SOLARCHVISION_DevelopDATA(impacts_source); 
    //SOLARCHVISION_PlotHOURLY(0, 325 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _drybulb; 
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = 1;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = -2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);


  }

  if (STUDY_setup == 13) {

    if (automated != 0) {
      draw_sorted = 1;
      draw_normals = 1;
      draw_data_lines = 0;
      draw_probs = 0;
    }

    STUDY_drw_Layer = STUDY_drw_Layer = _dirnorrad; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    //STUDY_drw_Layer = _glohorrad; //_difhorrad; // <<<<<<<<<<<<<< 
    //SOLARCHVISION_PlotHOURLY(0, 325 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_drw_Layer = _cloudcover;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = 0;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);

    plot_impacts = 2; //4;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_drw_Layer] * STUDY_S_View), 1.0 * STUDY_S_View);


    plot_impacts = pre_plot_impacts; 
    impact_layer = pre_impact_layer;

  }  
    
}






String[] getfiles (String _Folder) {
  File dir = new File(_Folder);
  
  String[] filenames = dir.list();
  
  if (filenames != null) {
    for (int i = 0; i < filenames.length; i++) {
      //println(filenames[i]);
    }
  }
  return filenames;
}

void my_line (float ax, float ay, float az, float bx, float by, float bz) {
  //line(ax, ay, az, bx, by, bz);
  STUDY_Diagrams.line(ax, ay, bx, by);
}



int _Opacity (float STUDY_O_scale) {
 int k = int(STUDY_O_scale * 0.01 * 256);
 if (k > 255) k = 255;
 if (k < 0) k = 0;
 
 return k; 
}


float sin_ang (float a) {
 return sin(a * PI / 180); 
}

float cos_ang (float a) {
 return cos(a * PI / 180); 
}

float tan_ang (float a) {
 return tan(a * PI / 180); 
}


float asin_ang (float a) {
 return ((asin(a)) * 180/PI); 
}

float acos_ang (float a) {
 return ((acos(a)) * 180/PI); 
}

float atan_ang (float a) {
 return ((atan(a)) * 180/PI); 
}

float atan2_ang (float a, float b) {
 return ((atan2(a, b)) * 180/PI); 
}

float roundTo (float a, float b) {
  float a_floor = (floor (a / (1.0 * b))) * b;
  float a_ceil =  (ceil (a / (1.0 * b))) * b;
  float c;
  if ((a - a_floor) > (a_ceil - a)) {
    c = a_ceil;
  }
  else {
    c = a_floor;
  }
  return c;
}

float dist_lon_lat (double lon1, double lat1, double lon2, double lat2) {

  float dLon = (float) (lon2 - lon1); 
  float dLat = (float) (lat2 - lat1);

  float a = sin_ang(dLon / 2.0);
  float b = sin_ang(dLat / 2.0) * sin_ang(dLat / 2.0) + cos_ang((float) lat1) * cos_ang((float) lat2) * a * a;
  float d = 2 * atan2(sqrt(b), sqrt(1 - b)) * (float) R_earth; 

  return(d);
}

float fn_dist (float[] a, float[] b) {

  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(b[i] - a[i], 2);
  }
  d = pow(d, 0.5);
  
  return d;
}

float[] fn_G (float[][] a) {

  float[] b = a[0]; // initializing to the first node
  
  // adding other nodes
  for (int i = 1; i < a.length; i++) {
    for (int j = 0; j < b.length; j++) {
      b[j] += a[i][j];
    }
  }

  // dividing to the number of nodes
  for (int j = 0; j < b.length; j++) {
    b[j] /= float(a.length);
  }
  
  return b;
}

float[] fn_normalize (float[] a) {
  float[] b = a;
  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(a[i], 2);
  }
  d = pow(d, 0.5);
  
  for (int i = 0; i < a.length; i++) {
    if (d != 0) b[i] = a[i]/d;
    else b[i] = 0;
  } 
  return b;
}

float fn_dot (float[] a, float b[]) {
  float d = 0;
  for (int i = 0; i < min(a.length, b.length); i++) {
    d += a[i] * b[i];
  }
  return d;
}



float[] SOLARCHVISION_WBGRW (float _variable) {
  _variable *= 600.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};

  if (_variable < 0) {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }
  else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  }
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  }
  else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = 255;
    COL[2] = v;
    COL[3] = v;
  }
  else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }
  
  return COL;
}

float[] SOLARCHVISION_BGR (float _variable) {
  _variable *= 400.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};

  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 255;
  }
  else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  }
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }
  
  return COL;
}

float[] SOLARCHVISION_DBGR (float _variable) {
  _variable *= 500.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = v;
  }
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  }
  else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }
  
  return COL;
}

float[] SOLARCHVISION_DWBGR (float _variable) {
  _variable *= 600.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  }
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  }
  else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }
  
  return COL;
}

float[] SOLARCHVISION_DWYR (float _variable) {
  _variable *= 400.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  }
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 255 - 0.5 * v;
    COL[2] = 0;
    COL[3] = 0;
  }  
  else {
    COL[1] = 127;
    COL[2] = 0;
    COL[3] = 0;
  }
  
  return COL;
}


float[] SOLARCHVISION_VDWBGR (float _variable) {
  _variable *= 700.0;
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable < 0) {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 255;
  }
  else if (_variable < 100) {
    v = ((_variable - 0) * 2.55);
    COL[1] = (255 - v);
    COL[2] = 0;
    COL[3] = (255 - v);
  } 
  else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  }
  else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  }
  else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  }
  else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  }
  else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  }
  else if (_variable < 700) {
    v = ((_variable - 600) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  }
  else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }
  
  return COL;
}

float[] SOLARCHVISION_DRYWCBD (float _variable) {
  _variable *= 2.75;
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable <= -2.75) {
    COL[1] = 63;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  }
  else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  }
  else if (_variable < 1) {
    v = (_variable * 255);
    COL[1] = 255 - v;
    COL[2] = 255;
    COL[3] = 255;
  }
  else if (_variable < 2) {
    v = ((_variable - 1) * 255);
    COL[1] = 0;
    COL[2] = 255 - v;
    COL[3] = 255;
  }
  else if (_variable < 2.75) {
    v = ((_variable - 2) * 255);
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 255 - v;
  }
  else {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 63;
  }

  return COL;
}

float[] SOLARCHVISION_DRYWCBDx3 (float _variable) {
  //_variable *= 3;
  _variable *= 2.75; // to maintain the ranges with normal DRYWCBD
  
  float v;
  float[] COL = {255, 0, 0, 0};
  if (_variable <= -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  }
  else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  }
  else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  }
  else if (_variable < 1) {
    v = (_variable * 255);
    COL[1] = 255 - v;
    COL[2] = 255;
    COL[3] = 255;
  }
  else if (_variable < 2) {
    v = ((_variable - 1) * 255);
    COL[1] = 0;
    COL[2] = 255 - v;
    COL[3] = 255;
  }
  else if (_variable < 2.75) {
    v = ((_variable - 2) * 255);
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 255 - v;
  }
  else {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}

float[] SOLARCHVISION_DBCW(float _variable) {
  _variable = 1 - _variable;
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }
  
  float r,g,b;
  r = COL[3]; 
  g = COL[2];
  b = COL[1];
  COL[1] = r;
  COL[2] = g;
  COL[3] = b;

  return COL;
}


float[] GET_COLOR_STYLE (int COLOR_STYLE, float j) {
  float[] c = {255, 0, 0, 0};
  
  if (COLOR_STYLE == 0) {
    c[0] = _Opacity(STUDY_O_scale);
    c[1] = 0;
    c[2] = 0;
    c[3] = 0;
  }
  else if (COLOR_STYLE == 19) {
    float[] _COL = SOLARCHVISION_DWYR(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 18) {
    //float[] _COL = SOLARCHVISION_DRYWCBDx3(2.0 * (j - 0.5) * (2.0 / 2.75));
    float[] _COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5) * (2.0 / 2.75));
    c[0] = 255;
    c[1] = _COL[3];
    c[2] = _COL[2];
    c[3] = _COL[1]; 
  }  
  else if (COLOR_STYLE == 17) {
    //float[] _COL = SOLARCHVISION_DRYWCBDx3(2.0 * (j - 0.5) * (2.0 / 2.75));
    float[] _COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5) * (2.0 / 2.75));
    c[0] = 255;
    c[1] = 255 - _COL[3];
    c[2] = 255 - _COL[2];
    c[3] = 255 - _COL[1]; 
  }   
  else if (COLOR_STYLE == 16) {
    float[] _COL = SOLARCHVISION_DBCW(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  }   
  else if (COLOR_STYLE == 15) {
    float[] _COL = SOLARCHVISION_DRYW(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 14) {
    float[] _COL = SOLARCHVISION_DBGR(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 13) {
    float[] _COL = SOLARCHVISION_DWBGR(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 12) {
    float[] _COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 11) {
    float[] _COL = SOLARCHVISION_BGR(j);
    c[0] = 127;
    c[1] = 255 - 0.5 * _COL[1];
    c[2] = 255 - 0.5 * _COL[2];
    c[3] = 255 - 0.5 * _COL[3];
    STUDY_Diagrams.stroke(255 - 0.5 * _COL[1], 255 - 0.5 * _COL[2], 255 - 0.5 * _COL[3], 127);
  }  
  else if (COLOR_STYLE == 10) {
    float[] _COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = 255 - _COL[1];
    c[2] = 255 - _COL[2];
    c[3] = 255 - _COL[3];
  } 
  else if (COLOR_STYLE == 9) {
    float[] _COL = SOLARCHVISION_WBGRW(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 8) {
    float[] _COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = 255 - _COL[1];
    c[2] = 255 - _COL[2];
    c[3] = 255 - _COL[3];
  }
  else if (COLOR_STYLE == 7) {
    float[] _COL = SOLARCHVISION_WBGRW(j);
    c[0] = 255;
    c[1] = 255 - _COL[1];
    c[2] = 255 - _COL[2];
    c[3] = 255 - _COL[3];
  }     
  else if (COLOR_STYLE == 6) {
    float[] _COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = _COL[3];
    c[2] = _COL[2];
    c[3] = _COL[1];
  } 
  else if (COLOR_STYLE == 4) {
    float[] _COL = SOLARCHVISION_VDWBGR(j);
    c[0] = STUDY_O_scale;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  }      
  else if (COLOR_STYLE == 3) {
    float[] _COL = SOLARCHVISION_VDWBGR(j);
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 2) {
    float[] _COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5) * (2.0 / 2.75));
    c[0] = STUDY_O_scale;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  }      
  else if (COLOR_STYLE == 1) {
    float[] _COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5) * (2.0 / 2.75));
    c[0] = 255;
    c[1] = _COL[1];
    c[2] = _COL[2];
    c[3] = _COL[3];
  } 
  else if (COLOR_STYLE == 5) {
    c[0] = 255;
    c[1] = 0;
    c[2] = 0;
    c[3] = 0;
  }
  else if (COLOR_STYLE == -1) {
    float[] _COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5) * (2.0 / 2.75));
    c[0] = 255;
    c[1] = 255 - _COL[3];
    c[2] = 255 - _COL[2];
    c[3] = 255 - _COL[1];
  } 
  
  
  return c;
}


void SOLARCHVISION_Calendar () {
  CalendarMM = new String [365][2];
  CalendarDD = new String [365][2];
  CalendarDay = new String [365][2];
  
  CalendarDate = new int [365][2];
  
  int k = 285;
  for (int l = 0; l < 2; l += 1) {
    for (int i = 0; i < 12; i += 1) {
      for (int j = 0; j < CalendarLength[i]; j += 1) {
        k += 1;
        if (k == 365) k = 0; 
        CalendarMM[k][l] = CalendarMonth[i][l];
        CalendarDD[k][l] = String.valueOf(j + 1);
        CalendarDay[k][l] = CalendarDD[k][l] + " " + CalendarMM[k][l];
        
        CalendarDate[k][0] = i + 1;
        CalendarDate[k][1] = j + 1;
      }
    }
  }
}

int Convert2Day (int Date_Angle) {
  int DAY = (Date_Angle + 360) % 360;
  if (DAY >=  31) DAY += 1;
  if (DAY >=  62) DAY += 1;
  if (DAY >=  93) DAY += 1;
  if (DAY >= 124) DAY += 1;
  if (DAY >= 155) DAY += 1;
  DAY = DAY % 365;
  return DAY; 
}

int Convert2Date (int _MONTH, int _DAY) {
  int k = 0;
  for (int i = 0; i < (_MONTH - 1); i += 1) {
    for (int j = 0; j < CalendarLength[i]; j += 1) {
      k += 1;
      if (k == 365) k = 0; 
    }
  }
  k += _DAY - 1;
  
  k = k % 365;
  return k;
}

void SOLARCHVISION_update_date () {
  _MONTH = CalendarDate[int(_DATE)][0]; 
  _DAY = CalendarDate[int(_DATE)][1];
  _HOUR = int(24 * (_DATE - int(_DATE)));
}



void SOLARCHVISION_try_update_ENSEMBLE (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {
  
  ENSEMBLE_XML_Files = getfiles(ENSEMBLE_directory); // slow <<<<<<<<<<<< this line didn't work well below... but it is rather slow here! 
  
  ENSEMBLE = new float [24][365][num_layers][(1 + ENSEMBLE_end - ENSEMBLE_start)];
  ENSEMBLE_Flag = new int [24][365][num_layers][(1 + ENSEMBLE_end - ENSEMBLE_start)]; // -1: undefined, 0: interpolated, 1: data

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_layers; l += 1) {
        for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) {
          ENSEMBLE[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_Flag[i][j][l][k] = -1; 
        }
      }
    }
  }

  if (Load_ENSEMBLE == 1) {
    
    int any_file_downloaded = 0;
  
    for (int f = 0; f < num_layers; f++) {
      if (LAYERS_ENSEMBLE[f].equals("")) {
      }
      else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + DEFINED_STATIONS[STATION_NUMBER][8] + "_" + LAYERS_ENSEMBLE[f] + "_000-384.xml";

        int File_Found = -1;

        //println (FN);
        for (int i = ENSEMBLE_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
          //println(ENSEMBLE_XML_Files[i]); 
            
          if (ENSEMBLE_XML_Files[i].equals(FN)) {
            //println ("FILE FOUND:", FN);
            File_Found = i;
            
            break; // <<<<<<<<<<
          }
        }
      
        if (File_Found == -1) {
          if (Download_ENSEMBLE == 1) {
            String the_directory = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + nf(THE_HOUR, 2) + "/" + LAYERS_ENSEMBLE[f] + "/raw";
            String the_link = "http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/xml/" + the_directory + "/" + FN + ".bz2";
            String the_target = ENSEMBLE_directory + "/" + FN + ".bz2";
      
            println("Try downloading: " + the_link);
            
            try{
              saveBytes(the_target, loadBytes(the_link));
              
              any_file_downloaded = 1;
              
              /*
              String[] new_file = {FN};
              ENSEMBLE_XML_Files = concat(ENSEMBLE_XML_Files, new_file); // fast
              //ENSEMBLE_XML_Files = getfiles(ENSEMBLE_directory); //slow! 
              
              File_Found = ENSEMBLE_XML_Files.length - 1;
              //println("Added:", File_Found);    
              */
            } 
            catch (Exception e) {
              println ("LINK NOT AVAILABLE:", the_link); 
            }              
          } 
        }
      }
    }


    if (any_file_downloaded != 0) {
      launch("C:/SOLARCHVISION_2015/BatchFiles/unzipNAEFS.bat".replace('/', char(92)));
      //ENSEMBLE_XML_Files = getfiles(ENSEMBLE_directory); // slow
    }
        
        
    for (int f = 0; f < num_layers; f++) {
      if (LAYERS_ENSEMBLE[f].equals("")) {
      }
      else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + DEFINED_STATIONS[STATION_NUMBER][8] + "_" + LAYERS_ENSEMBLE[f] + "_000-384.xml";

        int File_Found = -1;

        //println (FN);
        for (int i = ENSEMBLE_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
          //println(ENSEMBLE_XML_Files[i]); 
            
          if (ENSEMBLE_XML_Files[i].equals(FN)) {
            //println ("FILE FOUND:", FN);
            File_Found = i;
            
            break; // <<<<<<<<<<
          }
        }        


        if (File_Found != -1) SOLARCHVISION_LoadENSEMBLE((ENSEMBLE_directory + "/" + FN), f);
        else println ("FILE NOT FOUND:", FN);
      }
    }
    

    
    SOLARCHVISION_postProcess_ENSEMBLE();

  }
    
}

void SOLARCHVISION_postProcess_ENSEMBLE () {

  if (Load_ENSEMBLE == 1) {
    
    int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  
    
    for (int l = 0; l < num_layers; l += 1) {
      
      if (LAYERS_ENSEMBLE[l].equals("")) {  // <<<<<<<<<< to make it faster but this won't process the HRDPS layers those not available in NAEFS layers! 
      }
      else 
      {
        //////////////////////////////////////  PASS 1  //////////////////////////////////////  
        
        for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) {
          float pre_v = FLOAT_undefined;
          int pre_num = 0;
          
          for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
          int j = (int(j_for + _DATE + 365 - 286) % 365);
  
            for (int i = 0; i < 24; i += 1) {
              
              if (ENSEMBLE[i][j][l][k] > 0.9 * FLOAT_undefined) {
                if (pre_v < 0.9 * FLOAT_undefined) {
                  pre_num += 1;
                  
                  float next_v = FLOAT_undefined;
                  int next_i = i;
                  int next_j = j;
                  int next_num = 0;
                  while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                    next_num += 1;
                    next_i += 1;
                    if (next_i == 24) {
                      next_i -= 24;
                      next_j += 1; 
                    }
                    if (next_j == 365) {
                      next_j = 0;
                    }
                    if (ENSEMBLE[next_i][next_j][l][k] > 0.9 * FLOAT_undefined) {
                    }
                    else {
                      next_v = ENSEMBLE[next_i][next_j][l][k];
                      
                      if (l == _winddir) {
                        if ((next_v - pre_v) > 180) next_v -= 360;
                        if ((next_v - pre_v) < -180) next_v += 360;
                      } 
                    }  
                  }
                  if (next_num < MAX_SEARCH) {
                    //if (l == _winddir) ENSEMBLE[i][j][l][k] = ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360;
                    //else ENSEMBLE[i][j][l][k] = (next_num * pre_v + pre_num * next_v) / (pre_num + next_num);
                    
                    float interpolation_pow = pow(2.0, interpolation_weight);
                
                    ENSEMBLE[i][j][l][k] = (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow));
                    if (l == _winddir) ENSEMBLE[i][j][l][k] = (ENSEMBLE[i][j][l][k] + 360) % 360;
                    
                    
                    //println("[i][j][l][k]", i, j, l, k);
                    ENSEMBLE_Flag[i][j][l][k] = 0; // On Layers: RH and TMP it didn't work with MODEL_RUN == 12!!!!!!!!!!!!!!!!!!??????????
                  }
                  else {
                    ENSEMBLE_Flag[i][j][l][k] = -1;
                  }
                }
              }
              else {
                ENSEMBLE_Flag[i][j][l][k] = 1;
                pre_v = ENSEMBLE[i][j][l][k];
                pre_num = 0;
              }
              
              //if ((k == 43) && (ENSEMBLE[i][j][l][k] < 0.9 * FLOAT_undefined)) println(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0] + ":", i, j, l, ENSEMBLE[i][j][l][k]);
            }
          }
        }

        //////////////////////////////////////  PASS 2  //////////////////////////////////////      
        
        if (Climatic_weather_forecast != 0) {
        
          int keep_num_add_days = num_add_days;
          
          num_add_days = 7; // 1; for faster results      
        
          float[][][] _valuesO;
          float[][][] _valuesO_overcast;
          float[][][] _valuesO_scattered;
          float[][][] _valuesO_clear;
          
          _valuesO           = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
          _valuesO_overcast  = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
          _valuesO_scattered = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
          _valuesO_clear     = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
    
          for (int i = 0; i < 24; i += 1) {      
          
            for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
              for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
                
                for (int j = 0; j < STUDY_max_j_end_parameters; j += 1) {
                  
                  int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
    
                  if (now_j >= 365) {
                    now_j = now_j % 365; 
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365; 
                  }           
              
  
                  _valuesO          [i][j][(k * num_add_days + j_ADD)] = FLOAT_undefined;
                  _valuesO_overcast [i][j][(k * num_add_days + j_ADD)] = FLOAT_undefined;
                  _valuesO_scattered[i][j][(k * num_add_days + j_ADD)] = FLOAT_undefined;
                  _valuesO_clear    [i][j][(k * num_add_days + j_ADD)] = FLOAT_undefined; 
          
                  float Pa = CLIMATE_WY2[i][now_j][l][k];
        
                  if (Pa > 0.9 * FLOAT_undefined) {
                  }
                  else {
                    _valuesO[i][j][(k * num_add_days + j_ADD)] = Float.valueOf(Pa);
                    
                    if (SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, _daily, 2, i, now_j, k) == 1) {
                      _valuesO_overcast[i][j][(k * num_add_days + j_ADD)] = Float.valueOf(Pa);
                    }
                    
                    if (SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, _daily, 3, i, now_j, k) == 1) {
                      _valuesO_scattered[i][j][(k * num_add_days + j_ADD)] = Float.valueOf(Pa);
                    }
                    
                    if (SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, _daily, 4, i, now_j, k) == 1) {
                      _valuesO_clear[i][j][(k * num_add_days + j_ADD)] = Float.valueOf(Pa);
                    }                  
                  }
                  
                }        
              }
            }  
          }
        
          float[][] _valuesH;
          float[][] _valuesH_overcast;
          float[][] _valuesH_scattered;
          float[][] _valuesH_clear;
          
          _valuesH           = new float [24][STUDY_max_j_end_parameters];
          _valuesH_overcast  = new float [24][STUDY_max_j_end_parameters];
          _valuesH_scattered = new float [24][STUDY_max_j_end_parameters];
          _valuesH_clear     = new float [24][STUDY_max_j_end_parameters];
          
          for (int i = 0; i < 24; i += 1) {
            for (int j = 0; j < STUDY_max_j_end_parameters; j += 1) {      
              _valuesH          [i][j] = SOLARCHVISION_NORMAL(_valuesO          [i][j])[N_Middle];
              _valuesH_overcast [i][j] = SOLARCHVISION_NORMAL(_valuesO_overcast [i][j])[N_Middle];
              _valuesH_scattered[i][j] = SOLARCHVISION_NORMAL(_valuesO_scattered[i][j])[N_Middle];
              _valuesH_clear    [i][j] = SOLARCHVISION_NORMAL(_valuesO_clear    [i][j])[N_Middle];
              
              //if (l == _drybulb) println("Average at hour", i, ", day", j, "=", _valuesH[i][j]);
            }
          }
    
          num_add_days = keep_num_add_days;
          
    
    
    
          for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) {
            int pre_num = 0;
            
            float pre_v = FLOAT_undefined;
            int pre_hour = -1; // that means it is undefined.
            int pre_day = -1; // that means it is undefined.
            
            for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
              int now_j = (int(j_for + _DATE + 365 - 286) % 365);
               if (now_j >= 365) {
                now_j = now_j % 365; 
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365; 
              }        
              
              for (int i = 0; i < 24; i += 1) {
                if (ENSEMBLE_Flag[i][now_j][l][k] == 0) { // if it was interpolated then ...
                
                  if (pre_v < 0.9 * FLOAT_undefined) {
                    pre_num += 1;
                    
                    float next_v = FLOAT_undefined;
                    int next_hour = -1; // that means it is undefined.
                    int next_day = -1; // that means it is undefined.
                    
                    int next_i = i;
                    int next_j = now_j;
                    int next_num = 0;
                    
                    while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                      next_num += 1;
                      next_i += 1;
                      if (next_i == 24) {
                        next_i -= 24;
                        next_j += 1; 
                      }
                      if (next_j == 365) {
                        next_j = 0; 
                      }
                      if (ENSEMBLE_Flag[next_i][next_j][l][k] != 0) { // if it wasn't interpolated then ...
                        next_v = ENSEMBLE[next_i][next_j][l][k];
                        next_hour = next_i;
                        next_day = (int(next_j - _DATE + 286 + 365) % 365); 
    
    
                        // non-linear post processing for some parameters
                        if ((l == _drybulb) || (l == _relhum)) {
                            
                          if ((pre_v < 0.9 * FLOAT_undefined) && (next_v < 0.9 * FLOAT_undefined)) {
                            // replacing linear interpolated forecast with new values based on hourly patterns of observations in recent days.
                            
                            float linear_climate = 0;
                            float current_dist = 0;
    
                            if (Climatic_weather_forecast == 1) {
                              linear_climate = (next_num * _valuesH[pre_hour][pre_day] + pre_num * _valuesH[next_hour][next_day]) / (pre_num + next_num);
                              current_dist = _valuesH[i][j_for] - linear_climate;
                            }
                            else {                    
                              if ((SOLARCHVISION_filter("ENSEMBLE", _cloudcover, _daily, 2, i, now_j, k)) == 1) {
                                linear_climate = (next_num * _valuesH_overcast[pre_hour][pre_day] + pre_num * _valuesH_overcast[next_hour][next_day]) / (pre_num + next_num);
                                current_dist = _valuesH_overcast[i][j_for] - linear_climate;
                              }
                              else if ((SOLARCHVISION_filter("ENSEMBLE", _cloudcover, _daily, 3, i, now_j, k)) == 1) {
                                linear_climate = (next_num * _valuesH_scattered[pre_hour][pre_day] + pre_num * _valuesH_scattered[next_hour][next_day]) / (pre_num + next_num);
                                current_dist = _valuesH_scattered[i][j_for] - linear_climate;
                              }
                              //else if ((SOLARCHVISION_filter("ENSEMBLE", _cloudcover, _daily, 4, i, now_j, k)) == 1) {
                              else {
                                linear_climate = (next_num * _valuesH_clear[pre_hour][pre_day] + pre_num * _valuesH_clear[next_hour][next_day]) / (pre_num + next_num);
                                current_dist = _valuesH_clear[i][j_for] - linear_climate;
                              }
                            }                          
  
    
                            ENSEMBLE[i][now_j][l][k] = ENSEMBLE[i][now_j][l][k] + current_dist;
                          }
                        }       
                        
                        
                        if (l == _winddir) {
                          if ((next_v - pre_v) > 180) next_v -= 360;
                          if ((next_v - pre_v) < -180) next_v += 360;
                        } 
                      }  
                    }
            
                    ENSEMBLE_Flag[i][now_j][l][k] = 0;
                  }
                  else {
                    ENSEMBLE_Flag[i][now_j][l][k] = -1;
                  }
                  
                }
                else {
                  ENSEMBLE_Flag[i][now_j][l][k] = 1;
                  pre_v = ENSEMBLE[i][now_j][l][k];
                  pre_num = 0;
                  
                  pre_hour = i;
                  pre_day = j_for;
    
                }
              }
            }
            
          }
        }
        
        //////////////////////////////////////  END PASS 2  //////////////////////////////////////
        
      }
    }
    
    println("Post-processing solar components ...");
  
    int num_count = (1 + CLIMATE_WY2_end - CLIMATE_WY2_start);
    
    for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) {
      for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
        int j = ((j_for + BEGIN_DAY) % 365);
        for (int i = 0; i < 24; i += 1) {
          if (ENSEMBLE[i][j][_cloudcover][k] > 0.9 * FLOAT_undefined) {
          }
          else {
            float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
            float HOUR_ANGLE = i; 
            
            float[] SunR = SOLARCHVISION_SunPositionRadiation(LocationLatitude, DATE_ANGLE, HOUR_ANGLE, ENSEMBLE[i][j][_cloudcover][k]);
            float T = ENSEMBLE[i][j][_drybulb][k];
    
            ENSEMBLE[i][j][_dirnorrad][k] = SunR[4];
            ENSEMBLE_Flag[i][j][_dirnorrad][k] = 0;
            
            ENSEMBLE[i][j][_difhorrad][k] = SunR[5];
            ENSEMBLE_Flag[i][j][_difhorrad][k] = 0;
  
            ENSEMBLE[i][j][_glohorrad][k] = SunR[4] * SunR[3] + SunR[5];
            ENSEMBLE_Flag[i][j][_glohorrad][k] = 0;
  
         
  //---------------------------------------------------------------------
            if (Climatic_solar_forecast == 1) {
    
              float Forecast_CC = ENSEMBLE[i][j][_cloudcover][k];
              float Forecast_AP = ENSEMBLE[i][j][_pressure][k];
              
              float CC_epsilon = 1.0; // defines a range for finding near previous results: 1.0 results in e.g. 2 < CC < 4 for CC at 3  
              float AP_epsilon = 50.0;
              
              float _valuesSUM_DIR = 0;
              float _valuesSUM_DIF = 0;
              float _valuesSUM_GLO = 0;
              float sum_count = 0;
              
              float process_add_days = 11;
              
              for (int q = 0; q < num_count; q += 1) {
                   
                for (int j_ADD = 0; j_ADD < process_add_days; j_ADD += 1) { 
            
                  int now_i = i;
                  int now_j = int(j + (j_ADD - int(0.5 * process_add_days)) + 365) % 365;
                  
                  if (now_j >= 365) {
                   now_j = now_j % 365; 
                  }
                  if (now_j < 0) {
                   now_j = (now_j + 365) % 365; 
                  }
        
                
                  if ((CLIMATE_WY2[now_i][now_j][_cloudcover][q] > 0.9 * FLOAT_undefined) || (CLIMATE_WY2[now_i][now_j][_pressure][q] > 0.9 * FLOAT_undefined)) {
                  }
                  else {
                    float CC_dist = abs(Forecast_CC - CLIMATE_WY2[now_i][now_j][_cloudcover][q]);
                    float AP_dist = abs(Forecast_AP - CLIMATE_WY2[now_i][now_j][_pressure][q]);
                    if ((CC_dist < CC_epsilon) && (AP_dist < AP_epsilon)) {
                      
                      float _weight;
                      
                      _weight = 1; 
                      _weight *= pow(abs(1 - pow(CC_dist/CC_epsilon, 2)), 2); // to add more wights to closer cases
                      _weight *= pow(abs(1 - pow(AP_dist/AP_epsilon, 2)), 2);
                      
                      sum_count += _weight;
                      
                      if (CLIMATE_WY2[now_i][now_j][_dirnorrad][q] > 0.9 * FLOAT_undefined) {} else _valuesSUM_DIR += _weight * CLIMATE_WY2[now_i][now_j][_dirnorrad][q]; 
                      if (CLIMATE_WY2[now_i][now_j][_difhorrad][q] > 0.9 * FLOAT_undefined) {} else _valuesSUM_DIF += _weight * CLIMATE_WY2[now_i][now_j][_difhorrad][q]; 
                      if (CLIMATE_WY2[now_i][now_j][_glohorrad][q] > 0.9 * FLOAT_undefined) {} else _valuesSUM_GLO += _weight * CLIMATE_WY2[now_i][now_j][_glohorrad][q]; 
        
                    }
                  }
                }
              }
              
              if (sum_count != 0) {
                _valuesSUM_DIR /= sum_count;
                _valuesSUM_DIF /= sum_count;
                _valuesSUM_GLO /= sum_count;
    
                ENSEMBLE[i][j][_dirnorrad][k] = _valuesSUM_DIR;
                ENSEMBLE[i][j][_difhorrad][k] = _valuesSUM_DIF;
                ENSEMBLE[i][j][_glohorrad][k] = _valuesSUM_GLO;
                
              }  
              else {
                //println("Cannot find simillar conditions in climate file at i:", i, ", j:", j, ", k:", k); 
              }
            }      
  
  //---------------------------------------------------------------------
         
            ENSEMBLE[i][j][_direffect][k] = ENSEMBLE[i][j][_dirnorrad][k] * (18 - T);
            ENSEMBLE_Flag[i][j][_direffect][k] = 0;
            
            ENSEMBLE[i][j][_difeffect][k] = ENSEMBLE[i][j][_difhorrad][k] * (18 - T);
            ENSEMBLE_Flag[i][j][_difeffect][k] = 0; 
            
          }     
        }
      }
    }
  

  }
  
}


void SOLARCHVISION_LoadENSEMBLE (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;
  
  int continue_process = 1;
  
  XML FileALL = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  
  try {
    FileALL = loadXML(FileName);
  }
  catch (Exception e) {
    println("Can't read:", FileName);
    continue_process = 0;
  }
  
  if (continue_process == 1) { 
  
    //println (_YEAR, _MONTH, _DAY, _HOUR);
   
    XML[] children0 = FileALL.getChildren("forecast");
   
    for (int Li = 0; Li < children0.length; Li++) {
        
      int _a1 = children0[Li].getInt("forecast_hour");
      String _a2 = children0[Li].getString("valid_time");
  
      //println("Li=", Li, "hour =", _a1, "date:", _a2);
      
      if (Li >= 0) {
        
        int THE_YEAR = int(_a2.substring(0, 4));
        int THE_MONTH = int(_a2.substring(4, 6));
        int THE_DAY = int(_a2.substring(6, 8));
        int THE_HOUR = int(_a2.substring(8));
        
        //println (THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);
  
        int now_i = int(THE_HOUR);
        int now_j = Convert2Date(THE_MONTH, THE_DAY);
        
        //println (now_i, now_j);
        
        now_i -= int(-LocationTimeZone / 15);
        if (now_i < 0) {
          now_i += 24;
          now_j -= 1;
          if (now_j < 0) {
            now_j += 365;
          } 
        }
        
        //println (now_i, now_j);
        //println ("-------------");
        
        XML[] _c = children0[Li].getChildren("model");
        //println("number of members:", _c.length);
      
        for (int Lk = 0; Lk < _c.length; Lk++) {
          int k = _c[Lk].getInt("id") - 1;
         
          if (k < (1 + ENSEMBLE_end - ENSEMBLE_start)) {
  
            ENSEMBLE[now_i][now_j][Load_Layer][k] = Float.valueOf(_c[Lk].getContent());
          }
        }
      }
    }
  }  
}


void SOLARCHVISION_PlotENSEMBLE (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
  _pix = (100.0 * STUDY_S_View / level_pix);

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);
  
  color_data_lines = color(0, 0, 63, _Opacity(STUDY_O_scale));
  
  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  int start_z = get_startZ_endZ(databaseNumber_ENSEMBLE)[0];
  int end_z = get_startZ_endZ(databaseNumber_ENSEMBLE)[1]; 
  
  if (STUDY_print_title != 0) {
    
    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
  
    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER); 
    STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_drw_Layer][_LAN]), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
  
  }
  
  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [(1 + ENSEMBLE_end - ENSEMBLE_start)];
  _valuesB = new float [(1 + ENSEMBLE_end - ENSEMBLE_start)]; 

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [(1 + ENSEMBLE_end - ENSEMBLE_start)];
  _valuesNUM = new float [(1 + ENSEMBLE_end - ENSEMBLE_start)];
 
  for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) { 
    _valuesA[k] = FLOAT_undefined;
    _valuesB[k] = FLOAT_undefined;
    _valuesSUM[k] = FLOAT_undefined;
    _valuesNUM[k] = 0;
  }
  
  float[] Ax_LINES = {0};
  float[] Ay_LINES = {0};
  float[] Az_LINES = {0};
  float[] Bx_LINES = {0};
  float[] By_LINES = {0};
  float[] Bz_LINES = {0};
  
  File_output_node = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_norm = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_prob = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  
  String Main_name = MAKE_mainname();

  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
    
    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      
      STUDY_Diagrams.text(CalendarDay[int((365 + j + 286 + BEGIN_DAY) % 365)][_LAN], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (num_add_days > 1) {
        //STUDY_Diagrams.text(("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }
    
    String _FilenamesAdd = "";
    if (num_add_days > 1) {
        //_FilenamesAdd = ("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/FORECAST_node_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_node[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(FORECAST)");

      File_output_node[(j - STUDY_j_start)].print("Hour\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        File_output_node[(j - STUDY_j_start)].print(nf(l, 4) + "        \t");
      }
      File_output_node[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/FORECAST_norm_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_norm[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(FORECAST)");
      File_output_norm[(j - STUDY_j_start)].print("Hour\t");
      for (int l = 0; l < 9; l += 1) {
        File_output_norm[(j - STUDY_j_start)].print(N_Title[l] + "\t"); 
      }
      File_output_norm[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/FORECAST_prob_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_prob[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(FORECAST)");

      File_output_prob[(j - STUDY_j_start)].print("Hour:\t");
      File_output_prob[(j - STUDY_j_start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) File_output_norm[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) File_output_prob[(j - STUDY_j_start)].print(nf(i, 2) + "\t");

      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

        _valuesA[k] = FLOAT_undefined;
        _valuesB[k] = FLOAT_undefined;
        
        if ((k + 1) == 22) {
          STUDY_Diagrams.stroke(127, 0, 255, 127); 
          STUDY_Diagrams.fill(127, 0, 255);
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 6);
        }
        else {
          float[] _COL = GET_COLOR_STYLE(COLOR_STYLE, (1.0 * k / (1 + ENSEMBLE_end - ENSEMBLE_start)));
          STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
          STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 
          
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
        }
        
        int _plot = 1;
        
        if (_plot == 1) {
          
          int now_k = k;
          int now_i = i;
          int now_j = (j + BEGIN_DAY + 365) % 365;

          if (now_j >= 365) {
           now_j = now_j % 365; 
          }
          if (now_j < 0) {
           now_j = (now_j + 365) % 365; 
          }

          int next_i = now_i + dT;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = 0; //i % 24;
            next_j += 1; //int((i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
              //next_k += 1; 
            }
          }

          Pa = ENSEMBLE[now_i][now_j][STUDY_drw_Layer][now_k]; 
          if (Pa > 0.9 * FLOAT_undefined) {
            _valuesA[k] = FLOAT_undefined;
            
            if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("[undefined]\t"); 
          }
          else {
            int drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
            
            if (drw_count == 1) {

              _valuesA[k] = Pa;
              _valuesA[k] += STUDY_V_offset[STUDY_drw_Layer];
              
              _valuesSUM[k] += _valuesA[k];
              _valuesNUM[k] += 1;

              if ((ENSEMBLE_Flag[now_i][now_j][STUDY_drw_Layer][now_k] == 1) && ((draw_data_lines == 1))) STUDY_Diagrams.ellipse((j + ((i + 0.5) / 24.0)) * sx_Plot, _valuesA[k] * sy_Plot, 5, 5);

                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
                  if (_valuesA[k] < 0.9 * FLOAT_undefined) File_output_node[(j - STUDY_j_start)].print(nfs(_valuesA[k] - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + "\t"); 
                  else File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
                }
                            
              if (next_k < (1 + ENSEMBLE_end - ENSEMBLE_start)) {
                
                Pb = ENSEMBLE[next_i][next_j][STUDY_drw_Layer][next_k];
                if (Pb > 0.9 * FLOAT_undefined) {
                  _valuesB[k] = FLOAT_undefined;
                }
                else {
                  _valuesB[k] = Pb;
                  _valuesB[k] += STUDY_V_offset[STUDY_drw_Layer];
                  
                  if (draw_data_lines == 1) {
                    if ((STUDY_drw_Layer == _winddir) && (abs(_valuesB[k] - _valuesA[k]) > 180)) {
                      
                    }
                    else {
                      Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                      Ay_LINES = append(Ay_LINES, _valuesA[k] * sy_Plot);
                      Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                      Bx_LINES = append(Bx_LINES, (j + ((i + 0.5 + dT) / 24.0)) * sx_Plot);
                      By_LINES = append(By_LINES, _valuesB[k] * sy_Plot);
                      Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                    } 
                  }
                }
              }
            }
            else {
              if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("not_the_case\t");
            }
          }          
        }
      }
 
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].println();
  
      _interval += 1; 
      if ((_interval % sum_interval) == 0) {
        for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
          _valuesSUM[k] += _valuesA[k];
          _valuesNUM[k] += 1;
          
          if ((_valuesSUM[k] < 0.9 * FLOAT_undefined) && (_valuesNUM[k] != 0)) {
            _valuesSUM[k] /= _valuesNUM[k];
          }
        }    
        if (draw_probs == 1) {
          SOLARCHVISION_draw_probabilities(i, j, start_z, end_z, _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }  

        for (int k = 0; k < (1 + ENSEMBLE_end - ENSEMBLE_start); k += 1) {
          _valuesSUM[k] = 0;
          _valuesNUM[k] = 0;
        }
        
      }        

      if (draw_sorted == 1) {
        SOLARCHVISION_draw_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (draw_normals == 1) {
        SOLARCHVISION_draw_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)].println("Source: " + nf(_YEAR, 4) + nf(_MONTH, 2) + nf(_DAY, 2) + nf(_HOUR, 2) + "_GEPS-NAEFS-RAW_" + DEFINED_STATIONS[STATION_NUMBER][8] + "_" + LAYERS_ENSEMBLE[STUDY_drw_Layer] + "_000-384.xml" + ", Environment Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      File_output_node[(j - STUDY_j_start)].println("Interpolated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      if (LAYERS_Unit[STUDY_drw_Layer].equals("kW°C/m²") || LAYERS_Unit[STUDY_drw_Layer].equals("W/m²")) File_output_node[(j - STUDY_j_start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      File_output_node[(j - STUDY_j_start)].flush(); 
      File_output_node[(j - STUDY_j_start)].close(); 
    }
    
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)].println("Source: " + nf(_YEAR, 4) + nf(_MONTH, 2) + nf(_DAY, 2) + nf(_HOUR, 2) + "_GEPS-NAEFS-RAW_" + DEFINED_STATIONS[STATION_NUMBER][8] + "_" + LAYERS_ENSEMBLE[STUDY_drw_Layer] + "_000-384.xml" + ", Environment Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      File_output_norm[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_norm[(j - STUDY_j_start)].println("* : SOLARCHVISION internal algorithm");
      if (LAYERS_Unit[STUDY_drw_Layer].equals("kW°C/m²") || LAYERS_Unit[STUDY_drw_Layer].equals("W/m²")) File_output_norm[(j - STUDY_j_start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      File_output_norm[(j - STUDY_j_start)].flush(); 
      File_output_norm[(j - STUDY_j_start)].close(); 
    }

    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)].println("Source: " + nf(_YEAR, 4) + nf(_MONTH, 2) + nf(_DAY, 2) + nf(_HOUR, 2) + "_GEPS-NAEFS-RAW_" + DEFINED_STATIONS[STATION_NUMBER][8] + "_" + LAYERS_ENSEMBLE[STUDY_drw_Layer] + "_000-384.xml" + ", Environment Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      File_output_prob[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      if (LAYERS_Unit[STUDY_drw_Layer].equals("kW°C/m²") || LAYERS_Unit[STUDY_drw_Layer].equals("W/m²")) File_output_prob[(j - STUDY_j_start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      File_output_prob[(j - STUDY_j_start)].flush(); 
      File_output_prob[(j - STUDY_j_start)].close(); 
    }

  }

  if (draw_data_lines == 1) {
    SOLARCHVISION_draw_data_lines(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }    

  STUDY_Diagrams.popMatrix();
} 


void SOLARCHVISION_try_update_CLIMATE_WY2 () {
  
  
  CLIMATE_WY2 = new float [24][365][num_layers][(1 + CLIMATE_WY2_end - CLIMATE_WY2_start)];
 
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_layers; l += 1) {
        for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
          CLIMATE_WY2[i][j][l][k] = FLOAT_undefined;
        }
      }
    }
  }
  
  
  if (Load_CLIMATE_WY2 == 1) {

    String FN = DEFINED_STATIONS[STATION_NUMBER][9] + ".wy2";
  
    int File_Found = -1;
  
    //println (FN);
    for (int i = 0; i < CLIMATE_WY2_Files.length; i++) {

      if (CLIMATE_WY2_Files[i].toLowerCase().equals(FN.toLowerCase())) {
        //println ("FILE FOUND:", FN);
        File_Found = i;
        
        break; // <<<<<<<<<<
      }
    }
    
    if (File_Found != -1) SOLARCHVISION_LoadCLIMATE_WY2((CLIMATE_WY2_directory + "/" + FN));
    else println ("FILE NOT FOUND:", FN);
  }

}


void SOLARCHVISION_LoadCLIMATE_WY2 (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;
  
    
  println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f += 1) {
    
    lineSTR = FileALL[f];
    //println (lineSTR);
    
    int CLIMATE_YEAR = int(lineSTR.substring(6, 10));
    int CLIMATE_MONTH = int(lineSTR.substring(10, 12));
    int CLIMATE_DAY = int(lineSTR.substring(12, 14));
    int CLIMATE_HOUR = int(lineSTR.substring(14, 16));
    
    //println (CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);
    
    int i = int(CLIMATE_HOUR) - 1;
    int j = Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_WY2_start);
    
    //println (i);
    
    CLIMATE_WY2[i][j][_pressure][k] = float(lineSTR.substring(85, 90)); // 10 times in Pa
    CLIMATE_WY2[i][j][_drybulb][k] = float(lineSTR.substring(91, 95)); // 10 times in °C
    //CLIMATE_WY2[i][j][_relhum][k] = 50; // Relative Humidity is not presented in DCLIMATE files!
    CLIMATE_WY2[i][j][_glohorrad][k] = float(lineSTR.substring(20, 24)); // Wh/m²
    CLIMATE_WY2[i][j][_dirnorrad][k] = float(lineSTR.substring(26, 30)); // Wh/m²
    CLIMATE_WY2[i][j][_difhorrad][k] = float(lineSTR.substring(32, 36)); // Wh/m²
    CLIMATE_WY2[i][j][_windspd][k] = float(lineSTR.substring(105, 109)); // 10 times in m/s
    CLIMATE_WY2[i][j][_winddir][k] = float(lineSTR.substring(101, 104)); // °
    CLIMATE_WY2[i][j][_cloudcover][k] = float(lineSTR.substring(113, 115)); // 0.1 times in %
    CLIMATE_WY2[i][j][_ceilingsky][k] = float(lineSTR.substring(61, 65)); // 0.1 times in m
    
    if (CLIMATE_WY2[i][j][_pressure][k] == 99999) CLIMATE_WY2[i][j][_pressure][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_pressure][k] = 0.1 * CLIMATE_WY2[i][j][_pressure][k];
    
    if (CLIMATE_WY2[i][j][_drybulb][k] == 9999) CLIMATE_WY2[i][j][_drybulb][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_drybulb][k] = 0.1 * CLIMATE_WY2[i][j][_drybulb][k];
    
    if (CLIMATE_WY2[i][j][_glohorrad][k] == 9999) CLIMATE_WY2[i][j][_glohorrad][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_glohorrad][k] = CLIMATE_WY2[i][j][_glohorrad][k] / 3.6; // Wh/m²
    
    if (CLIMATE_WY2[i][j][_dirnorrad][k] == 9999) CLIMATE_WY2[i][j][_dirnorrad][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_dirnorrad][k] = CLIMATE_WY2[i][j][_dirnorrad][k] / 3.6; // Wh/m²
    
    if (CLIMATE_WY2[i][j][_difhorrad][k] == 9999) CLIMATE_WY2[i][j][_difhorrad][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_difhorrad][k] = CLIMATE_WY2[i][j][_difhorrad][k] / 3.6; // Wh/m²
    
    if (CLIMATE_WY2[i][j][_windspd][k] == 9999) CLIMATE_WY2[i][j][_windspd][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_windspd][k] = 0.1 * 3.6 * CLIMATE_WY2[i][j][_windspd][k];
    
    if (CLIMATE_WY2[i][j][_winddir][k] == 999) CLIMATE_WY2[i][j][_winddir][k] = FLOAT_undefined;
    
    if (CLIMATE_WY2[i][j][_cloudcover][k] == 99) CLIMATE_WY2[i][j][_cloudcover][k] = FLOAT_undefined;
    
    if (CLIMATE_WY2[i][j][_ceilingsky][k] == 7777) CLIMATE_WY2[i][j][_ceilingsky][k] = 1000;
    if (CLIMATE_WY2[i][j][_ceilingsky][k] >= 1000) CLIMATE_WY2[i][j][_ceilingsky][k] = 1000; // <<<<<<<<<
    
    if (CLIMATE_WY2[i][j][_ceilingsky][k] == 9999) CLIMATE_WY2[i][j][_ceilingsky][k] = FLOAT_undefined;
    else CLIMATE_WY2[i][j][_ceilingsky][k] = 10 * CLIMATE_WY2[i][j][_ceilingsky][k];

  }

  float Pa, Pb, Pc;
  float T, R_dir, R_dif;
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
        Pa = CLIMATE_WY2[i][j][_drybulb][k];
        Pb = CLIMATE_WY2[i][j][_dirnorrad][k];
        Pc = CLIMATE_WY2[i][j][_difhorrad][k];
                  
        if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined)) {
        }
        else {
          T = Pa;
          R_dir = Pb;
          R_dif = Pc;
          CLIMATE_WY2[i][j][_direffect][k] = (18 - T) * R_dir;
          CLIMATE_WY2[i][j][_difeffect][k] = (18 - T) * R_dif;
        }
        
        Pa = CLIMATE_WY2[i][j][_ceilingsky][k];
      }
    }
  }
}


void SOLARCHVISION_PlotCLIMATE_WY2 (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    
  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);
  
  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  
  _pix = (100.0 * STUDY_S_View / level_pix);
  
  int start_z = get_startZ_endZ(databaseNumber_CLIMATE_WY2)[0];
  int end_z = get_startZ_endZ(databaseNumber_CLIMATE_WY2)[1]; 
  
  if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
    
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER);
      STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start) + "-" + String.valueOf(end_z + CLIMATE_WY2_start) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
  
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, CENTER); 
      STUDY_Diagrams.text((LAYERS_Title[STUDY_drw_Layer][_LAN]), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
    
  }   

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
  _valuesB = new float [((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
  _valuesNUM = new float [((1 + CLIMATE_WY2_end - CLIMATE_WY2_start) * num_add_days)];
  
  float[] Ax_LINES = {0};
  float[] Ay_LINES = {0};
  float[] Az_LINES = {0};
  float[] Bx_LINES = {0};
  float[] By_LINES = {0};
  float[] Bz_LINES = {0};

  File_output_node = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_norm = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_prob = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  
  String Main_name = MAKE_mainname();
  
  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {
    
    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      
      STUDY_Diagrams.text(CalendarDay[int((365 + j * per_day + 286 + BEGIN_DAY) % 365)][_LAN], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (num_add_days > 1) {
        //STUDY_Diagrams.text(("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }    
    
    String _FilenamesAdd = "";
    if (num_add_days > 1) {
        _FilenamesAdd = ("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/Climate_node_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_WY2_start) + "_to_" + String.valueOf(end_z + CLIMATE_WY2_start) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_node[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(CWEED)");

      File_output_node[(j - STUDY_j_start)].print("Hour:\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        File_output_node[(j - STUDY_j_start)].print(nf(l, 4) + "        \t");
      }
      File_output_node[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)] = createWriter("/" + Main_name + "Climate_norm_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_WY2_start) + "_to_" + String.valueOf(end_z + CLIMATE_WY2_start) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_norm[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(CWEED)");
      File_output_norm[(j - STUDY_j_start)].print("Hour:\t");
      for (int l = 0; l < 9; l += 1) {
        File_output_norm[(j - STUDY_j_start)].print(N_Title[l] + "\t"); 
      }
      File_output_norm[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)] = createWriter("/" + Main_name + "Climate_prob_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_WY2_start) + "_to_" + String.valueOf(end_z + CLIMATE_WY2_start) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_prob[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(CWEED)");

      File_output_prob[(j - STUDY_j_start)].print("Hour:\t");
      File_output_prob[(j - STUDY_j_start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) File_output_norm[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) File_output_prob[(j - STUDY_j_start)].print(nf(i, 2) + "\t");

      for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
        for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
          
          _valuesA[(k * num_add_days + j_ADD)] = FLOAT_undefined;
          _valuesB[(k * num_add_days + j_ADD)] = FLOAT_undefined;
       
          float[] _COL = GET_COLOR_STYLE(COLOR_STYLE, (1.0 * k / (1 + CLIMATE_WY2_end - CLIMATE_WY2_start)));
          STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
          STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 

          int _plot = 0;
          
          if ((start_z <= k) && (end_z >= k)) {
            _plot = 1;
          }
          
          if (_plot == 1) {
            
            int now_k = k;
            int now_i = i;
            int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
            
            
            if (now_j >= 365) {
             now_j = now_j % 365; 
            }
            if (now_j < 0) {
             now_j = (now_j + 365) % 365; 
            }
  
            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1; 
              }
            }

            Pa = CLIMATE_WY2[now_i][now_j][STUDY_drw_Layer][now_k]; 
            if (Pa > 0.9 * FLOAT_undefined) {
              _valuesA[(k * num_add_days + j_ADD)] = FLOAT_undefined;
              
              if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
            }
            else {
              int drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);

              if (drw_count == 1) {
                _valuesA[(k * num_add_days + j_ADD)] = Pa;
                _valuesA[(k * num_add_days + j_ADD)] += STUDY_V_offset[STUDY_drw_Layer];
                
                _valuesSUM[(k * num_add_days + j_ADD)] += _valuesA[(k * num_add_days + j_ADD)];
                _valuesNUM[(k * num_add_days + j_ADD)] += 1;

                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
                  if (_valuesA[(k * num_add_days + j_ADD)] < 0.9 * FLOAT_undefined) File_output_node[(j - STUDY_j_start)].print(nfs(_valuesA[(k * num_add_days + j_ADD)] - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + "\t"); 
                  else File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
                }

                if (next_k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start)) {
                  Pb = CLIMATE_WY2[next_i][next_j][STUDY_drw_Layer][next_k];
                  if (Pb > 0.9 * FLOAT_undefined) {
                    _valuesB[(k * num_add_days + j_ADD)] = FLOAT_undefined;
                  }
                  else {
                    _valuesB[(k * num_add_days + j_ADD)] = Pb;
                    _valuesB[(k * num_add_days + j_ADD)] += STUDY_V_offset[STUDY_drw_Layer];
                    
                    if (draw_data_lines == 1) {
                      if ((STUDY_drw_Layer == _winddir) && (abs(_valuesB[(k * num_add_days + j_ADD)] - _valuesA[(k * num_add_days + j_ADD)]) > 180)) {
                      }
                      else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * num_add_days + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * num_add_days + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                      } 
                    }
                  }
                }
              }
              else {
                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("not_the_case\t");
              }
            }
          }
        }
      }
      
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].println();
        
      _interval += 1; 
      if ((_interval % sum_interval) == 0) {
        for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
          for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
            _valuesSUM[(k * num_add_days + j_ADD)] += _valuesA[(k * num_add_days + j_ADD)];
            _valuesNUM[(k * num_add_days + j_ADD)] += 1;
            
            if ((_valuesSUM[(k * num_add_days + j_ADD)] < 0.9 * FLOAT_undefined) && (_valuesNUM[(k * num_add_days + j_ADD)] != 0)) {
              _valuesSUM[(k * num_add_days + j_ADD)] /= _valuesNUM[(k * num_add_days + j_ADD)];
            }
          }
        }        
        if (draw_probs == 1) {
          SOLARCHVISION_draw_probabilities(i, j, ((start_z - 1) * num_add_days + 1), ((end_z - 1) * num_add_days + num_add_days), _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
        for (int k = 0; k < (1 + CLIMATE_WY2_end - CLIMATE_WY2_start); k += 1) {
          for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
            _valuesSUM[(k * num_add_days + j_ADD)] = 0;
            _valuesNUM[(k * num_add_days + j_ADD)] = 0;
          }
        }    
      }      
      
      if (draw_sorted == 1) {
        SOLARCHVISION_draw_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (draw_normals == 1) {
        SOLARCHVISION_draw_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    
    }
    
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][9] + ".wy2" + ", Environment Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      File_output_node[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_node[(j - STUDY_j_start)].flush(); 
      File_output_node[(j - STUDY_j_start)].close(); 
    }
    
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][9] + ".wy2" + ", Environment Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      File_output_norm[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_norm[(j - STUDY_j_start)].println("* : SOLARCHVISION internal algorithm");
      File_output_norm[(j - STUDY_j_start)].flush(); 
      File_output_norm[(j - STUDY_j_start)].close(); 
    }

    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][9] + ".wy2" + ", Environment Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      File_output_prob[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_prob[(j - STUDY_j_start)].flush(); 
      File_output_prob[(j - STUDY_j_start)].close(); 
    }

  }
  
  if (draw_data_lines == 1) {
    SOLARCHVISION_draw_data_lines(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }       
  
  STUDY_Diagrams.popMatrix();
} 


void SOLARCHVISION_try_update_CLIMATE_EPW () {
  
  CLIMATE_EPW = new float [24][365][num_layers][(1 + CLIMATE_EPW_end - CLIMATE_EPW_start)];
 
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_layers; l += 1) {
        for (int k = 0; k <(1 + CLIMATE_EPW_end - CLIMATE_EPW_start); k += 1) {
          CLIMATE_EPW[i][j][l][k] = FLOAT_undefined;
        }
      }
    }
  }

  if (Load_CLIMATE_EPW == 1) {

    String FN = DEFINED_STATIONS[STATION_NUMBER][10] + ".epw";
  
    int File_Found = -1;
  
    //println (FN);
    for (int i = 0; i < CLIMATE_EPW_Files.length; i++) {

      if (CLIMATE_EPW_Files[i].toLowerCase().equals(FN.toLowerCase())) {
        //println ("FILE FOUND:", FN);
        File_Found = i;
        
        break; // <<<<<<<<<<
      }
    }
    
    if (File_Found != -1) SOLARCHVISION_LoadCLIMATE_EPW((CLIMATE_EPW_directory + "/" + FN));
    else println ("FILE NOT FOUND:", FN);
  }

}

void SOLARCHVISION_LoadCLIMATE_EPW (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;
  
    
  //println("lines = ", FileALL.length);

  for (int f = 8; f < FileALL.length; f += 1) {
    
    lineSTR = FileALL[f];
    
    String[] parts = split(lineSTR, ',');
    
    int CLIMATE_YEAR = int(parts[0]);
    int CLIMATE_MONTH = int(parts[1]);
    int CLIMATE_DAY = int(parts[2]);
    int CLIMATE_HOUR = int(parts[3]);
    
    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);
    
    int i = int(CLIMATE_HOUR) - 1;
    int j = Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = 0; // on EPW:TMY files we have only one year 
    
    //println(i);
    
    CLIMATE_EPW[i][j][_pressure][k] = float(parts[9]) * 0.01; // 10 times in Pa
    CLIMATE_EPW[i][j][_drybulb][k] = float(parts[6]); // in °C
    CLIMATE_EPW[i][j][_relhum][k] = float(parts[8]); // 0 - 110%
    CLIMATE_EPW[i][j][_glohorrad][k] = float(parts[13]); // Wh/m²
    CLIMATE_EPW[i][j][_dirnorrad][k] = float(parts[14]); // Wh/m²
    CLIMATE_EPW[i][j][_difhorrad][k] = float(parts[15]); // Wh/m²
    CLIMATE_EPW[i][j][_windspd][k] = float(parts[21]); // in m/s
    CLIMATE_EPW[i][j][_winddir][k] = float(parts[20]); // ° 
    CLIMATE_EPW[i][j][_cloudcover][k] = float(parts[23]); // 0.1 times in % ... there is also total_sky_cover on[22]
    CLIMATE_EPW[i][j][_ceilingsky][k] = float(parts[25]); // in m
    
    
    if (CLIMATE_EPW[i][j][_pressure][k] == 999999) CLIMATE_EPW[i][j][_pressure][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_drybulb][k] == 99.9) CLIMATE_EPW[i][j][_drybulb][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_relhum][k] == 999) CLIMATE_EPW[i][j][_relhum][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_glohorrad][k] == 9999) CLIMATE_EPW[i][j][_glohorrad][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_dirnorrad][k] >= 9999) CLIMATE_EPW[i][j][_dirnorrad][k] = FLOAT_undefined;
    if (CLIMATE_EPW[i][j][_dirnorrad][k] < 0) CLIMATE_EPW[i][j][_dirnorrad][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_difhorrad][k] >= 9999) CLIMATE_EPW[i][j][_difhorrad][k] = FLOAT_undefined;
    if (CLIMATE_EPW[i][j][_difhorrad][k] < 0) CLIMATE_EPW[i][j][_difhorrad][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_windspd][k] == 999) CLIMATE_EPW[i][j][_windspd][k] = FLOAT_undefined;
    else CLIMATE_EPW[i][j][_windspd][k] = 3.6 * CLIMATE_EPW[i][j][_windspd][k];
    
    if (CLIMATE_EPW[i][j][_winddir][k] == 999) CLIMATE_EPW[i][j][_winddir][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_cloudcover][k] == 99) CLIMATE_EPW[i][j][_cloudcover][k] = FLOAT_undefined;
    
    if (CLIMATE_EPW[i][j][_ceilingsky][k] == 77777) CLIMATE_EPW[i][j][_ceilingsky][k] = 1000;
    if (CLIMATE_EPW[i][j][_ceilingsky][k] == 88888) CLIMATE_EPW[i][j][_ceilingsky][k] = 1000;
    if (CLIMATE_EPW[i][j][_ceilingsky][k] >= 1000) CLIMATE_EPW[i][j][_ceilingsky][k] = 1000; 
    
    if (CLIMATE_EPW[i][j][_ceilingsky][k] == 99999) CLIMATE_EPW[i][j][_ceilingsky][k] = FLOAT_undefined;

  }

  float Pa, Pb, Pc;
  float T, R_dir, R_dif;
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int k = 0; k <(1 + CLIMATE_EPW_end - CLIMATE_EPW_start); k += 1) {
        Pa = CLIMATE_EPW[i][j][_drybulb][k];
        Pb = CLIMATE_EPW[i][j][_dirnorrad][k];
        Pc = CLIMATE_EPW[i][j][_difhorrad][k];
                  
        if ((Pa > 0.9 * FLOAT_undefined) ||(Pb > 0.9 * FLOAT_undefined) ||(Pc > 0.9 * FLOAT_undefined)) {
        }
        else {
          T = Pa;
          R_dir = Pb;
          R_dif = Pc;
          CLIMATE_EPW[i][j][_direffect][k] = (18 - T) * R_dir;
          CLIMATE_EPW[i][j][_difeffect][k] = (18 - T) * R_dif;
        }
        
        Pa = CLIMATE_EPW[i][j][_ceilingsky][k];
      }
    }
  }
}

void SOLARCHVISION_PlotCLIMATE_EPW (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);
  
  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  
  _pix = (100.0 * STUDY_S_View / level_pix);

  int start_z = get_startZ_endZ(databaseNumber_CLIMATE_EPW)[0];
  int end_z = get_startZ_endZ(databaseNumber_CLIMATE_EPW)[1]; 
  
  if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
    
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER);
      STUDY_Diagrams.text(("[Typical Year] "), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
  
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, CENTER); 
      STUDY_Diagrams.text((LAYERS_Title[STUDY_drw_Layer][_LAN]), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
    
  }    

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [((1 + CLIMATE_EPW_end - CLIMATE_EPW_start) * num_add_days)];
  _valuesB = new float [((1 + CLIMATE_EPW_end - CLIMATE_EPW_start) * num_add_days)];

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [((1 + CLIMATE_EPW_end - CLIMATE_EPW_start) * num_add_days)];
  _valuesNUM = new float [((1 + CLIMATE_EPW_end - CLIMATE_EPW_start) * num_add_days)];
  
  float[] Ax_LINES = {0};
  float[] Ay_LINES = {0};
  float[] Az_LINES = {0};
  float[] Bx_LINES = {0};
  float[] By_LINES = {0};
  float[] Bz_LINES = {0};

  File_output_node = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_norm = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_prob = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  
  String Main_name = MAKE_mainname();
  
  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {

    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      
      STUDY_Diagrams.text(CalendarDay[int((365 + j * per_day + 286 + BEGIN_DAY) % 365)][_LAN], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (num_add_days > 1) {
        //STUDY_Diagrams.text(("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }    
    
    String _FilenamesAdd = "";
    if (num_add_days > 1) {
        _FilenamesAdd = ("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/Climate_node_" + LocationName + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_node[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(CWEED)");

      File_output_node[(j - STUDY_j_start)].print("Hour:\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        File_output_node[(j - STUDY_j_start)].print(nf(l, 4) + "        \t");
      }
      File_output_node[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)] = createWriter("/" + Main_name + "Climate_norm_" + LocationName + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_norm[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(CWEED)");
      File_output_norm[(j - STUDY_j_start)].print("Hour:\t");
      for (int l = 0; l < 9; l += 1) {
        File_output_norm[(j - STUDY_j_start)].print(N_Title[l] + "\t"); 
      }
      File_output_norm[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)] = createWriter("/" + Main_name + "Climate_prob_" + LocationName + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_prob[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(CWEED)");

      File_output_prob[(j - STUDY_j_start)].print("Hour:\t");
      File_output_prob[(j - STUDY_j_start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) File_output_norm[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) File_output_prob[(j - STUDY_j_start)].print(nf(i, 2) + "\t");

      for (int k = 0; k < (1 + CLIMATE_EPW_end - CLIMATE_EPW_start); k += 1) {
        for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
          
          _valuesA[(k * num_add_days + j_ADD)] = FLOAT_undefined;
          _valuesB[(k * num_add_days + j_ADD)] = FLOAT_undefined;
       
          float[] _COL = GET_COLOR_STYLE(COLOR_STYLE, (1.0 * k / (1 + CLIMATE_EPW_end - CLIMATE_EPW_start)));
          STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
          STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 

          int _plot = 0;

          //if ((start_z <= k + 1) && (end_z >= k + 1)) {
            _plot = 1;
          //}
          
          if (_plot == 1) {
            
            int now_k = k;
            int now_i = i;
            int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
            
            
            if (now_j >= 365) {
             now_j = now_j % 365; 
            }
            if (now_j < 0) {
             now_j = (now_j + 365) % 365; 
            }
  
            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1; 
              }
            }

            Pa = CLIMATE_EPW[now_i][now_j][STUDY_drw_Layer][now_k]; 
            if (Pa > 0.9 * FLOAT_undefined) {
              _valuesA[(k * num_add_days + j_ADD)] = FLOAT_undefined;
              
              if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
            }
            else {
              int drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);

              if (drw_count == 1) {
                _valuesA[(k * num_add_days + j_ADD)] = Pa;
                _valuesA[(k * num_add_days + j_ADD)] += STUDY_V_offset[STUDY_drw_Layer];
                
                _valuesSUM[(k * num_add_days + j_ADD)] += _valuesA[(k * num_add_days + j_ADD)];
                _valuesNUM[(k * num_add_days + j_ADD)] += 1;

                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
                  if (_valuesA[(k * num_add_days + j_ADD)] < 0.9 * FLOAT_undefined) File_output_node[(j - STUDY_j_start)].print(nfs(_valuesA[(k * num_add_days + j_ADD)] - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + "\t"); 
                  else File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
                }

                if (next_k < (1 + CLIMATE_EPW_end - CLIMATE_EPW_start)) {
                  Pb = CLIMATE_EPW[next_i][next_j][STUDY_drw_Layer][next_k];
                  if (Pb > 0.9 * FLOAT_undefined) {
                    _valuesB[(k * num_add_days + j_ADD)] = FLOAT_undefined;
                  }
                  else {
                    _valuesB[(k * num_add_days + j_ADD)] = Pb;
                    _valuesB[(k * num_add_days + j_ADD)] += STUDY_V_offset[STUDY_drw_Layer];
                    
                    if (draw_data_lines == 1) {
                      if ((STUDY_drw_Layer == _winddir) && (abs(_valuesB[(k * num_add_days + j_ADD)] - _valuesA[(k * num_add_days + j_ADD)]) > 180)) {
                      }
                      else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * num_add_days + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * num_add_days + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                      } 
                    }
                  }
                }
              }
              else {
                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("not_the_case\t");
              }
            }
          }
        }
      }
      
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].println();
        
      _interval += 1; 
      if ((_interval % sum_interval) == 0) {
        for (int k = 0; k < (1 + CLIMATE_EPW_end - CLIMATE_EPW_start); k += 1) {
          for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
            _valuesSUM[(k * num_add_days + j_ADD)] += _valuesA[(k * num_add_days + j_ADD)];
            _valuesNUM[(k * num_add_days + j_ADD)] += 1;
            
            if ((_valuesSUM[(k * num_add_days + j_ADD)] < 0.9 * FLOAT_undefined) && (_valuesNUM[(k * num_add_days + j_ADD)] != 0)) {
              _valuesSUM[(k * num_add_days + j_ADD)] /= _valuesNUM[(k * num_add_days + j_ADD)];
            }
          }
        }        
        if (draw_probs == 1) {
          SOLARCHVISION_draw_probabilities(i, j, ((start_z - CLIMATE_EPW_start) * num_add_days + 1), ((end_z - CLIMATE_EPW_start) * num_add_days + num_add_days), _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
        for (int k = 0; k < (1 + CLIMATE_EPW_end - CLIMATE_EPW_start); k += 1) {
          for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
            _valuesSUM[(k * num_add_days + j_ADD)] = 0;
            _valuesNUM[(k * num_add_days + j_ADD)] = 0;
          }
        }    
      }      
      
      if (draw_sorted == 1) {
        SOLARCHVISION_draw_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (draw_normals == 1) {
        SOLARCHVISION_draw_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    
    }
    
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][10] + ".epw");
      File_output_node[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_node[(j - STUDY_j_start)].flush(); 
      File_output_node[(j - STUDY_j_start)].close(); 
    }
    
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][10] + ".epw");
      File_output_norm[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_norm[(j - STUDY_j_start)].println("* : SOLARCHVISION internal algorithm");
      File_output_norm[(j - STUDY_j_start)].flush(); 
      File_output_norm[(j - STUDY_j_start)].close(); 
    }

    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)].println("Source: " + DEFINED_STATIONS[STATION_NUMBER][10] + ".epw");
      File_output_prob[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_prob[(j - STUDY_j_start)].flush(); 
      File_output_prob[(j - STUDY_j_start)].close(); 
    }

  }
  
  if (draw_data_lines == 1) {
    SOLARCHVISION_draw_data_lines(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }       
  
  STUDY_Diagrams.popMatrix();
} 





void SOLARCHVISION_try_update_OBSERVED () {
  
  
  OBSERVED = new float [24][365][num_layers][(1 + OBSERVED_end - OBSERVED_start)];
  OBSERVED_Flag = new int [24][365][num_layers][(1 + OBSERVED_end - OBSERVED_start)]; // -1: undefined, 0: interpolated, 1: data
 
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_layers; l += 1) {
        for (int k = 0; k < (1 + OBSERVED_end - OBSERVED_start); k += 1) {
          OBSERVED[i][j][l][k] = FLOAT_undefined;
          OBSERVED_Flag[i][j][l][k] = -1; 
        }
      }
    }
  }

  if (Load_OBSERVED == 1) {
    
    for (int q = 0; q < numberOfNearestStations_OBSERVED; q++) {
      nearest_Station_OBSERVED[q] = -1;
      nearest_Station_OBSERVED_dist[q] = FLOAT_undefined;
    }
    
    for (int q = 0; q < numberOfNearestStations_OBSERVED; q++) {
      for (int f = 0; f < STATION_SWOB_INFO.length; f += 1) {
     
        float _lat = float(STATION_SWOB_INFO[f][3]);
        float _lon = float(STATION_SWOB_INFO[f][4]); 
        if (_lon > 180) _lon -= 360; // << important!
      
       
        float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
        
        if (nearest_Station_OBSERVED_dist[q] > d) {
          
          int added_before = 0;
          
          for (int p = 0; p < q; p++) {
            if (nearest_Station_OBSERVED[p] == f) added_before = 1;
          }
          
          if (added_before == 0) {
            nearest_Station_OBSERVED_dist[q] = d;
            nearest_Station_OBSERVED[q] = f;
          }
        }     
      }
      
      nearest_Station_OBSERVED[q] = nearest_Station_OBSERVED[q];
    }    
    
    
      
    
    // this line tries to update the most recent files! << 
    int THE_YEAR = year(); 
    int THE_MONTH = month();
    int THE_DAY = day();
    int THE_HOUR = hour(); 
  
  
    float THE_DATE = _DATE;
  
    int now_i = int(THE_HOUR);
    int now_j = Convert2Date(THE_MONTH, THE_DAY);
  
    now_i += int(-LocationTimeZone / 15);
    if (now_i > 23) {
      now_i -= 24;
      now_j += 1;
      if (now_j > 364) {
        now_j -= 365;
        THE_YEAR += 1;
      }
      THE_DATE += 1;
      if (THE_DATE > 364) THE_DATE -= 365; 
    }         
    THE_HOUR = now_i;
  
    for (int j_for = 0; j_for < STUDY_max_j_end_observations * 24; j_for += 1) {
      
      THE_MONTH = CalendarDate[int(THE_DATE)][0]; 
      THE_DAY = CalendarDate[int(THE_DATE)][1];
      
      for (int q = 0; q < numberOfNearestStations_OBSERVED; q++) {
        
        int f = nearest_Station_OBSERVED[q];
        
        if (f != -1) {
        
          String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + STATION_SWOB_INFO[f][6] + "-" + STATION_SWOB_INFO[f][11] + "-swob.xml";
  
          int File_Found = -1;

          //println (FN);
          for (int i = OBSERVED_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
            //println(OBSERVED_XML_Files[i]); 
            
            if (OBSERVED_XML_Files[i].equals(FN)) {
              
              File_Found = i;
              println("Found:", File_Found);
              
              break; // <<<<<<<<<<
            }
          }
          
          if ((File_Found == -1) && (Download_OBSERVED != 0)) {
            String the_link = "http://dd.weatheroffice.gc.ca/observations/swob-ml/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + STATION_SWOB_INFO[f][6] + "/" + FN;
            String the_target = OBSERVED_directory + "/" + FN;
  
            println("Try downloading: " + the_link);
            
            try{
              saveBytes(the_target, loadBytes(the_link));
              
              String[] new_file = {FN};
              OBSERVED_XML_Files = concat(OBSERVED_XML_Files, new_file);
              
              File_Found = OBSERVED_XML_Files.length - 1;
              println("Added:", File_Found);
            } 
            catch (Exception e) {
  
            }  
          }
  
          if (File_Found != -1) SOLARCHVISION_LoadOBSERVED((OBSERVED_directory + "/" + FN), q);
          else println ("FILE NOT FOUND:", FN);
        }
      }
      
      now_i -= 1;
      if (now_i < 0) {
        now_i += 24;
        now_j -= 1;
        if (now_j < 0) {
          now_j += 365;
          THE_YEAR -= 1;
        }
        THE_DATE -= 1;
        if (THE_DATE < 0) THE_DATE += 364; 
      }
      THE_HOUR = now_i;
    }
    
  }
    
  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  
  
  for (int l = 0; l < num_layers; l += 1) {
    if (LAYERS_ENSEMBLE[l].equals("")) {
    }
    else {
      for (int k = 0; k < (1 + OBSERVED_end - OBSERVED_start); k += 1) {
        float pre_v = FLOAT_undefined;
        int pre_num = 0;
        
        for (int j_for = 0; j_for <= STUDY_max_j_end_observations; j_for += 1) { // should be controlled.
        int j = (int(j_for + _DATE - STUDY_max_j_end_observations + 365 - 286) % 365); // should be controlled.
        
          for (int i = 0; i < 24; i += 1) {
            if (OBSERVED[i][j][l][k] > 0.9 * FLOAT_undefined) {
              if (pre_v < 0.9 * FLOAT_undefined) {
                pre_num += 1;
                
                float next_v = FLOAT_undefined;
                int next_i = i;
                int next_j = j;
                int next_num = 0;
                while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                  next_num += 1;
                  next_i += 1;
                  if (next_i == 24) {
                    next_i -= 24;
                    next_j += 1; 
                  }
                  if (next_j == 365) {
                    next_j = 0; 
                  }
                  if (OBSERVED[next_i][next_j][l][k] > 0.9 * FLOAT_undefined) {
                  }
                  else {
                    next_v = OBSERVED[next_i][next_j][l][k];
                    
                    if (l == _winddir) {
                      if ((next_v - pre_v) > 180) next_v -= 360;
                      if ((next_v - pre_v) < -180) next_v += 360;
                    } 
                  }  
                }
                if (next_num < MAX_SEARCH) {
                  if (l == _winddir) OBSERVED[i][j][l][k] = ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360;
                  else OBSERVED[i][j][l][k] = (next_num * pre_v + pre_num * next_v) / (pre_num + next_num);
                  
                  OBSERVED_Flag[i][j][l][k] = 0;
                }
                else {
                  OBSERVED_Flag[i][j][l][k] = -1;
                }
              }
            }
            else {
              OBSERVED_Flag[i][j][l][k] = 1;
              pre_v = OBSERVED[i][j][l][k];
              pre_num = 0;
            }
          }
        }
      }
    }
  }
  
}


void SOLARCHVISION_LoadOBSERVED (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;
  
  XML FileALL = loadXML(FileName);

  XML[] children0 = FileALL.getChildren("om:member");
  XML[] children1 = children0[0].getChildren("om:Observation");
  XML[] children2 = children1[0].getChildren("om:samplingTime");
  XML[] children3 = children2[0].getChildren("gml:TimeInstant");
  XML[] children4 = children3[0].getChildren("gml:timePosition");
  String _TimeInstant = String.valueOf(children4[0].getContent());
  //println(_TimeInstant);
  
  int THE_YEAR = int(_TimeInstant.substring(0, 4));
  int THE_MONTH = int(_TimeInstant.substring(5, 7));
  int THE_DAY = int(_TimeInstant.substring(8, 10));
  int THE_HOUR = int(_TimeInstant.substring(11, 13));
  
  //println (THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

  int now_i = int(THE_HOUR);
  int now_j = Convert2Date(THE_MONTH, THE_DAY);
  
  //println (now_i, now_j);
  
  now_i -= int(-LocationTimeZone / 15);
  
  if (now_i < 0) {
    now_i += 24;
    now_j -= 1;
    if (now_j < 0) {
      now_j += 365;
    } 
  }
  
  //println (now_i, now_j);
  //println ("-------------");
  
  children2 = children1[0].getChildren("om:result");
  children3 = children2[0].getChildren("elements");
  children4 = children3[0].getChildren("element");
  
  for (int Li = 0; Li < children4.length; Li++) {
    
    String _a1 = children4[Li].getString("name");
    String _a2 = children4[Li].getString("value");
    String _a3 = children4[Li].getString("uom");

    //println("Li=", Li, _a1, _a2, _a3);
    
    if (_a2.toUpperCase().equals("MSNG")) { // missing values
      _a2 = String.valueOf(FLOAT_undefined);
    }
    
    if (_a1.equals("stn_pres")) {
      OBSERVED[now_i][now_j][_pressure][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_pressure][Load_Layer] = 1;
    }
    
    if (_a1.equals("air_temp")) {
      OBSERVED[now_i][now_j][_drybulb][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_drybulb][Load_Layer] = 1;
    }
    
    if (_a1.equals("rel_hum")) {
      OBSERVED[now_i][now_j][_relhum][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_relhum][Load_Layer] = 1;
    } 
    
    if (_a1.equals("tot_cld_amt")) {
      OBSERVED[now_i][now_j][_cloudcover][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_cloudcover][Load_Layer] = 1;
    }    
    
    if (_a1.equals("avg_wnd_dir_10m_mt50-60")) {
      OBSERVED[now_i][now_j][_winddir][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_winddir][Load_Layer] = 1;
    }    
    
    if (_a1.equals("avg_wnd_spd_10m_mt50-60")) {
      OBSERVED[now_i][now_j][_windspd][Load_Layer] = Float.valueOf(_a2);
      OBSERVED_Flag[now_i][now_j][_windspd][Load_Layer] = 1;
    }
    
    if (_a1.equals("pcpn_amt_pst6hrs")) {
      OBSERVED[now_i][now_j][A_precipitation][Load_Layer] = Float.valueOf(_a2); // past 6 hours!
      OBSERVED_Flag[now_i][now_j][A_precipitation][Load_Layer] = 1;
    }
    
    if (_a1.equals("avg_globl_solr_radn_pst1hr")) {
      if (_a2.equals(_undefined)) {
      }
      else {
        //if (_a3.equals("W/m²")) {
          OBSERVED[now_i][now_j][_glohorrad][Load_Layer] = 1000 * Float.valueOf(_a2) / 3.6; // we should check the units!
          OBSERVED_Flag[now_i][now_j][_glohorrad][Load_Layer] = 1;
        //}
      }
    }
    
    if (_a1.equals("tot_globl_solr_radn_pst1hr")) {
      if (_a2.equals(_undefined)) {
      }
      else {
        //if (_a3.equals("kJ/m²")) {
          OBSERVED[now_i][now_j][_glohorrad][Load_Layer] = Float.valueOf(_a2) / 3.6; // we should check the units!
          OBSERVED_Flag[now_i][now_j][_glohorrad][Load_Layer] = 1;
        //}
      }
    }
  }
}


void SOLARCHVISION_PlotOBSERVED (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
  _pix = (100.0 * STUDY_S_View / level_pix);

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);
  
  color_data_lines = color(63, 0, 0, _Opacity(STUDY_O_scale)); 
  
  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  int start_z = get_startZ_endZ(databaseNumber_OBSERVED)[0];
  int end_z = get_startZ_endZ(databaseNumber_OBSERVED)[1]; 
  
  if (STUDY_print_title != 0) {
    
    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
  
    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER); 
    //STUDY_Diagrams.text(("[Observations:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_drw_Layer][_LAN]), 0, (0.5 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale);
  
  }
  
  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [(1 + OBSERVED_end - OBSERVED_start)];
  _valuesB = new float [(1 + OBSERVED_end - OBSERVED_start)]; 

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [(1 + OBSERVED_end - OBSERVED_start)];
  _valuesNUM = new float [(1 + OBSERVED_end - OBSERVED_start)];
 
  for (int k = 0; k < (1 + OBSERVED_end - OBSERVED_start); k += 1) { 
    _valuesA[k] = FLOAT_undefined;
    _valuesB[k] = FLOAT_undefined;
    _valuesSUM[k] = FLOAT_undefined;
    _valuesNUM[k] = 0;
  }
  
  float[] Ax_LINES = {0};
  float[] Ay_LINES = {0};
  float[] Az_LINES = {0};
  float[] Bx_LINES = {0};
  float[] By_LINES = {0};
  float[] Bz_LINES = {0};

  File_output_node = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_norm = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  File_output_prob = new PrintWriter [(STUDY_j_end - STUDY_j_start)];
  
  String Main_name = MAKE_mainname();

  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
    String _FilenamesAdd = "";
    if (num_add_days > 1) {
        //_FilenamesAdd = ("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/OBSERVATION_node_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_node[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(OBSERVATION)");

      File_output_node[(j - STUDY_j_start)].print("Hour\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        File_output_node[(j - STUDY_j_start)].print(STATION_SWOB_INFO[nearest_Station_OBSERVED[l]][6] + "\t"); 
      }
      File_output_node[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/OBSERVATION_norm_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_norm[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(OBSERVATION)");
      File_output_norm[(j - STUDY_j_start)].print("Hour\t");
      for (int l = 0; l < 9; l += 1) {
        File_output_norm[(j - STUDY_j_start)].print(N_Title[l] + "\t"); 
      }
      File_output_norm[(j - STUDY_j_start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)] = createWriter("/" + Main_name + "/OBSERVATION_prob_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_drw_Layer][_EN] + "_" + sky_scenario_file[sky_scenario] + "_" + CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + ".txt");
      File_output_prob[(j - STUDY_j_start)].println(CalendarDay[((365 + j + 286 + BEGIN_DAY) % 365)][_LAN] + _FilenamesAdd + "\t" + sky_scenario_file[sky_scenario] + "\t" + LAYERS_Title[STUDY_drw_Layer][_EN] + "(" + LAYERS_Unit[STUDY_drw_Layer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(OBSERVATION)");

      File_output_prob[(j - STUDY_j_start)].print("Hour:\t");
      File_output_prob[(j - STUDY_j_start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) File_output_norm[(j - STUDY_j_start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) File_output_prob[(j - STUDY_j_start)].print(nf(i, 2) + "\t");

      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

        _valuesA[k] = FLOAT_undefined;
        _valuesB[k] = FLOAT_undefined;
        
        if ((k + 1) == 22) {
          STUDY_Diagrams.stroke(127, 0, 255, 127); 
          STUDY_Diagrams.fill(127, 0, 255);
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 6);
        }
        else {
          float[] _COL = GET_COLOR_STYLE(COLOR_STYLE, (1.0 * k / (1 + OBSERVED_end - OBSERVED_start)));
          STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
          STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 
          
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
        }
        
        int _plot = 1;
        
        if (_plot == 1) {
          
          int now_k = k;
          int now_i = i;
          int now_j = (j + BEGIN_DAY + 365) % 365;

          if (now_j >= 365) {
           now_j = now_j % 365; 
          }
          if (now_j < 0) {
           now_j = (now_j + 365) % 365; 
          }

          int next_i = now_i + dT;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = 0; //i % 24;
            next_j += 1; //int((i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
              //next_k += 1; 
            }
          }

          Pa = OBSERVED[now_i][now_j][STUDY_drw_Layer][now_k]; 
          if (Pa > 0.9 * FLOAT_undefined) {
            _valuesA[k] = FLOAT_undefined;

            if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("[undefined]\t"); 
          }
          else {
            int drw_count = 1; //SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
            
            if (drw_count == 1) {

              _valuesA[k] = Pa;
              _valuesA[k] += STUDY_V_offset[STUDY_drw_Layer];
              
              _valuesSUM[k] += _valuesA[k];
              _valuesNUM[k] += 1;

              //if ((OBSERVED_Flag[now_i][now_j][STUDY_drw_Layer][now_k] == 1) && ((draw_data_lines == 1))) STUDY_Diagrams.ellipse((j + ((i + 0.5) / 24.0)) * sx_Plot, _valuesA[k] * sy_Plot, 5, 5);

                if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
                  if (_valuesA[k] < 0.9 * FLOAT_undefined) File_output_node[(j - STUDY_j_start)].print(nfs(_valuesA[k] - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + "\t"); 
                  else File_output_node[(j - STUDY_j_start)].print("[undefined]\t");
                }
                            
              if (next_k < (1 + OBSERVED_end - OBSERVED_start)) {
                
                Pb = OBSERVED[next_i][next_j][STUDY_drw_Layer][next_k];
                if (Pb > 0.9 * FLOAT_undefined) {
                  _valuesB[k] = FLOAT_undefined;
                }
                else {
                  _valuesB[k] = Pb;
                  _valuesB[k] += STUDY_V_offset[STUDY_drw_Layer];
                  
                  if (draw_data_lines == 1) {
                    if ((STUDY_drw_Layer == _winddir) && (abs(_valuesB[k] - _valuesA[k]) > 180)) {
                      
                    }
                    else {
                      Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                      Ay_LINES = append(Ay_LINES, _valuesA[k] * sy_Plot);
                      Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                      Bx_LINES = append(Bx_LINES, (j + ((i + 0.5 + dT) / 24.0)) * sx_Plot);
                      By_LINES = append(By_LINES, _valuesB[k] * sy_Plot);
                      Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                    } 
                  }
                }
              }
            }
            else {
              if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].print("not_the_case\t");
            }
          }          
        }
      }
 
      if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) File_output_node[(j - STUDY_j_start)].println();
  
      _interval += 1; 
      if ((_interval % sum_interval) == 0) {
        for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
          _valuesSUM[k] += _valuesA[k];
          _valuesNUM[k] += 1;
          
          if ((_valuesSUM[k] < 0.9 * FLOAT_undefined) && (_valuesNUM[k] != 0)) {
            _valuesSUM[k] /= _valuesNUM[k];
          }
        }    
        if (draw_probs == 1) {
          //SOLARCHVISION_draw_probabilities(i, j, start_z, end_z, _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }  

        for (int k = 0; k < (1 + OBSERVED_end - OBSERVED_start); k += 1) {
          _valuesSUM[k] = 0;
          _valuesNUM[k] = 0;
        }
        
      }        

      if (draw_sorted == 1) {
        SOLARCHVISION_draw_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (draw_normals == 1) {
        SOLARCHVISION_draw_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (draw_data_lines == 1)) {
      File_output_node[(j - STUDY_j_start)].println("Source: Environment Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      File_output_node[(j - STUDY_j_start)].println("The data might be interpolated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_node[(j - STUDY_j_start)].flush(); 
      File_output_node[(j - STUDY_j_start)].close(); 
    }
    
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      File_output_norm[(j - STUDY_j_start)].println("Source: Environment Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      File_output_norm[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_norm[(j - STUDY_j_start)].println("* : SOLARCHVISION internal algorithm");
      File_output_norm[(j - STUDY_j_start)].flush(); 
      File_output_norm[(j - STUDY_j_start)].close(); 
    }

    if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
      File_output_prob[(j - STUDY_j_start)].println("Source: Environment Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      File_output_prob[(j - STUDY_j_start)].println("Calculated and processed by SOLARCHVISION 2015: www.solarchvision.com");
      File_output_prob[(j - STUDY_j_start)].flush(); 
      File_output_prob[(j - STUDY_j_start)].close(); 
    }

  }

  if (draw_data_lines == 1) {
    SOLARCHVISION_draw_data_lines(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }    

  STUDY_Diagrams.popMatrix();
} 



void SOLARCHVISION_draw_Grid_Cartesian_TIME (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
  
  float Shift_DOWN = 0;
  if (STUDY_V_belowLine[STUDY_drw_Layer] != 0) Shift_DOWN = -100;
  
  for (int i = 100; i >= Shift_DOWN; i -= 25) {
    if (-STUDY_V_offset[STUDY_drw_Layer] + roundTo(i / STUDY_V_scale[STUDY_drw_Layer], 0.1) != 0) {
      STUDY_Diagrams.stroke(0, 63);
      STUDY_Diagrams.fill(0, 63);
    }
    else {
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
    }
    my_line(STUDY_j_start * sx_Plot, -i * STUDY_S_View, 0, STUDY_j_end * sx_Plot, -i * STUDY_S_View, 0); 
    
    if ((i >= 0) || (STUDY_V_belowLine[STUDY_drw_Layer] != 0)) {  
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER);
      STUDY_Diagrams.text(((nf(-STUDY_V_offset[STUDY_drw_Layer] + roundTo(i / STUDY_V_scale[STUDY_drw_Layer], 0.1), 0, 1)) + LAYERS_Unit[STUDY_drw_Layer]), -5, -i * STUDY_S_View);
      //STUDY_Diagrams.text(((String.valueOf(int(-STUDY_V_offset[STUDY_drw_Layer] + roundTo(i / STUDY_V_scale[STUDY_drw_Layer], 0.1)))) + LAYERS_Unit[STUDY_drw_Layer]), -5, -i * STUDY_S_View);
    }
  }
  
  STUDY_Diagrams.stroke(0, 63);
  STUDY_Diagrams.fill(0, 63); 
  for (int i = STUDY_j_start; i <= STUDY_j_end; i += 1) {
    if (i < STUDY_j_end) {
      int j_step = 3;
      for (int j = j_step; j <= 24; j += j_step) {
        if (j != 24) {
          my_line((i + j / 24.0) * sx_Plot, -5 * STUDY_S_View, 0, (i + j / 24.0) * sx_Plot, 5 * STUDY_S_View, 0);
        }
        else {
          my_line((i + j / 24.0) * sx_Plot, -105 * STUDY_S_View, 0, (i + j / 24.0) * sx_Plot, (5 - Shift_DOWN) * STUDY_S_View, 0);
        }
      }
    }
  }
  
  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textAlign(CENTER, CENTER); 

  for (int i = STUDY_j_start; i < STUDY_j_end; i += 1) {
    if (STUDY_U_scale >= 0.75) {
      STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
      STUDY_Diagrams.text("12:00", (i - ((0 - 12) / 24.0)) * sx_Plot, 0.1 * sx_Plot / STUDY_U_scale);
    }
  }

  SOLARCHVISION_print_other_info(sx_Plot, STUDY_V_belowLine[STUDY_drw_Layer]);
}  



void SOLARCHVISION_draw_Grid_Spherical_POSITION (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int fill_back) {
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
  
  if (fill_back != 0) {
    for (int i = STUDY_j_start; i < STUDY_j_end; i += 1) {
    
      STUDY_Diagrams.stroke(223);
      STUDY_Diagrams.fill(223);
      STUDY_Diagrams.ellipse((i + obj_offset_x) * sx_Plot, 0, 2 * 90 * obj_scale * sx_Plot , 2 * 90 * obj_scale * sx_Plot);
    }
  }

  for (int i = STUDY_j_start; i < STUDY_j_end; i += 1) {
    for (int t = 0; t < 360; t += 15) {
      
      if ((t % 45) != 0) {
        STUDY_Diagrams.stroke(0, 63);
        STUDY_Diagrams.fill(0, 63);
      }
      else {
        
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
      }
      int r = 0;
      if ((t % 45) != 0) r = 15;
      
      my_line((i + obj_offset_x + r * obj_scale * (cos_ang(t))) * sx_Plot, -(r * obj_scale * (sin_ang(t))) * sx_Plot, 0, (i + obj_offset_x + 90 * obj_scale * (cos_ang(t))) * sx_Plot, -(90 * obj_scale * (sin_ang(t))) * sx_Plot, 0); 
      
      if (((t + 45) % 90) == 0) {
        STUDY_Diagrams.stroke(0, 127);
        STUDY_Diagrams.fill(0, 127);
        STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
        
        String ORI = "";
        switch((360 + 90 - t) % 360) {
          case 0 : ORI = "N"; break;
          case 45 : ORI = "NE"; break;
          case 90 : ORI = "E"; break;
          case 135 : ORI = "SE"; break;
          case 180 : ORI = "S"; break;
          case 225 : ORI = "SW"; break;
          case 270 : ORI = "W"; break;
          case 315 : ORI = "NW"; break; 
        }
        
        STUDY_Diagrams.text(ORI, (i + obj_offset_x + 110 * obj_scale * (cos_ang(t))) * sx_Plot, -(110 * obj_scale * (sin_ang(t))) * sx_Plot);
        //STUDY_Diagrams.text(String.valueOf((360 + 90 - t) % 360), (i + obj_offset_x + 110 * obj_scale * (cos_ang(t))) * sx_Plot, -(110 * obj_scale * (sin_ang(t))) * sx_Plot);
      }
    }
    
    float impact_scale = 1;
    if ((plot_impacts == -2) || (plot_impacts == -1)) impact_scale = STUDY_V_scale[_windspd] * 45 / 50.0;
    
    for (int r = 90; r > 0; r -= 15) {
      if ((r % 90) != 0) {
        STUDY_Diagrams.stroke(0, 63);
        STUDY_Diagrams.noFill();
      }
      else {
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.noFill(); 
      }
      
      STUDY_Diagrams.ellipse((i + obj_offset_x) * sx_Plot, 0, 2 * r * obj_scale * sx_Plot , 2 * r * obj_scale * sx_Plot);
      
      int t = 90;
      if (t == 90) {
        STUDY_Diagrams.stroke(0, 127);
        STUDY_Diagrams.fill(0, 127);
        STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
        STUDY_Diagrams.text(nf(int(r / impact_scale), 1), (i + obj_offset_x + r * obj_scale * (cos_ang(t))) * sx_Plot, -(r * obj_scale * (sin_ang(t))) * sx_Plot);
      }      
    }
  }
 
}  


void SOLARCHVISION_draw_Grid_DAILY (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textAlign(CENTER, CENTER); 

  for (int i = STUDY_j_start; i < STUDY_j_end; i += 1) {
    if ((STUDY_U_scale >= 0.75) || (((i - STUDY_j_start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      
      STUDY_Diagrams.text(CalendarDay[int((365 + i * per_day + 286 + BEGIN_DAY) % 365)][_LAN], (i - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (num_add_days > 1) {
        STUDY_Diagrams.text(("±" + int(num_add_days / 2) + _WORDS[2][_LAN] + "s"), (0 + i - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }
  }
  
  SOLARCHVISION_print_other_info(sx_Plot, 1);
  
}


void SOLARCHVISION_print_other_info (float sx_Plot, float the_STUDY_V_belowLine) {
  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
  STUDY_Diagrams.textAlign(LEFT, TOP);

  if (impacts_source == databaseNumber_CLIMATE_EPW) STUDY_Diagrams.text((_WORDS[0][_LAN] + ":" + LocationName + "\n"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text((_WORDS[0][_LAN] + ":" + LocationName + "\n("), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (impacts_source == databaseNumber_ENSEMBLE)    STUDY_Diagrams.text((_WORDS[0][_LAN] + ":" + LocationName + "\n(" + nf(_YEAR, 4) + "_" + nf(_MONTH, 2) + "_" + nf(_DAY, 2) + "_" + nf(_HOUR, 2) + ")"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (impacts_source == databaseNumber_OBSERVED)    STUDY_Diagrams.text((_WORDS[0][_LAN] + ":" + LocationName + "\n(" + nf(_YEAR, 4) + "_" + nf(_MONTH, 2) + "_" + nf(_DAY, 2) + "_" + nf(_HOUR, 2) + ")"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);

  switch(sky_scenario) {
    case 1 : STUDY_Diagrams.stroke(0, 0, 0); STUDY_Diagrams.fill(0, 0, 0); break;
    case 2 : STUDY_Diagrams.stroke(0, 0, 255); STUDY_Diagrams.fill(0, 0, 255); break;
    case 3 : STUDY_Diagrams.stroke(0, 127, 0); STUDY_Diagrams.fill(0, 127, 0); break;
    case 4 : STUDY_Diagrams.stroke(255, 0, 0); STUDY_Diagrams.fill(255, 0, 0); break;
  }
  
  STUDY_Diagrams.textAlign(RIGHT, TOP);

  STUDY_Diagrams.text(sky_scenario_text[sky_scenario], (STUDY_j_end - STUDY_j_start - 0.05) * sx_Plot, (0.3 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
}  



void SOLARCHVISION_draw_data_lines (float[] Ax_LINES, float[] Ay_LINES, float[] Az_LINES, float[] Bx_LINES, float[] By_LINES, float[] Bz_LINES) {
  //STUDY_Diagrams.stroke(color_data_lines);
  //STUDY_Diagrams.fill(color_data_lines);
  //STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
  
  STUDY_Diagrams.stroke(0, _Opacity(STUDY_O_scale));
  STUDY_Diagrams.fill(0, _Opacity(STUDY_O_scale));
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.5);
  
  for (int i = 1; i < Ax_LINES.length; i += 1) {
    my_line(Ax_LINES[i], Ay_LINES[i], Az_LINES[i], Bx_LINES[i], By_LINES[i], Bz_LINES[i]); 
  } 
}


void SOLARCHVISION_draw_probabilities (int i, int j, int start_z, int end_z, float[] _valuesSUM, float[] _valuesNUM, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  int PAL_TYPE = STUDY_Pallet_PROB_CLR; 
  int PAL_DIR = STUDY_Pallet_PROB_DIR;  
  float PAL_Multiplier = STUDY_Pallet_PROB_MLT;
  
  float txt_max_width = (sum_interval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale;
  float txt_max_height = _pix;
  if (txt_max_height > txt_max_width) STUDY_Diagrams.textSize(0.9 * txt_max_width);
  else STUDY_Diagrams.textSize(0.9 * txt_max_height);
   
  STUDY_Diagrams.textAlign(CENTER, CENTER);
  
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
  
  float min_v = tan_ang(89.99);
  float max_v = tan_ang(-89.99);
  
  for (int k = 0; k < _valuesSUM.length; k += 1) {
    if (_valuesSUM[k] < 0.9 * FLOAT_undefined) {
      if (min_v > _valuesSUM[k]) min_v = _valuesSUM[k];
      if (max_v < _valuesSUM[k]) max_v = _valuesSUM[k];
    }
  } 
  
  if ((min_v != tan_ang(89.99)) && (max_v != tan_ang(-89.99))) {    
    min_v = roundTo((min_v * abs(sy_Plot)), _pix) / _pix;
    max_v = roundTo((max_v * abs(sy_Plot)), _pix) / _pix;
    
    if (STUDY_drw_Layer == _winddir) min_v = 0;

    int[] _probs;
    int total_probs = 0;
    
    _probs = new int [int((1 + max_v - min_v))];
    
    for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
      if (_valuesSUM[k] < 0.9 * FLOAT_undefined) {
        float the_value = _valuesSUM[k];
        
        if (STUDY_drw_Layer == _winddir) {
          if (roundTo((the_value * abs(sy_Plot)), _pix) >= (360 * abs(sy_Plot))) the_value -= 360;
        }
        
        int h = int(roundTo((roundTo((the_value * abs(sy_Plot)), _pix) / _pix) - min_v, 1));
        _probs[h] += 1;
        total_probs += 1;
      }
    }

    if (total_probs != 0) {
      for (int n = 0; n < _probs.length; n += 1) {
        float prob_V = 1.0 * _probs[n] / total_probs;
        
        //if (int(roundTo(100 * prob_V, 1)) > 0) {
        if ((100 * prob_V) > 0) {
          
          float _u = PAL_Multiplier * prob_V;
          
          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;
          
          float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
          STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
          STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0); 
          STUDY_Diagrams.rect((j + ((i + 1) / 24.0)) * sx_Plot, -((min_v + n) * _pix) - 0.5 * _pix, -(sum_interval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale, _pix); 
          
          if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
            STUDY_Diagrams.stroke(127);
            STUDY_Diagrams.fill(127);
            STUDY_Diagrams.strokeWeight(0);
          }
          else {
            STUDY_Diagrams.stroke(255);
            STUDY_Diagrams.fill(255);
            STUDY_Diagrams.strokeWeight(2);
          }   
          STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (j + ((i + 1) / 24.0)) * sx_Plot - 0.5 * (sum_interval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale, -((min_v + n) * _pix) - 0.05 * txt_max_height);
          
          if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
            File_output_prob[(j - STUDY_j_start)].print(nfs((min_v + n) * _pix / abs(sy_Plot) - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + ":\t" + nf(100 * prob_V, 3, 3) + "\t"); 
          }
        }
      }  
      
      if ((Export_STUDY_info_prob == 1) && (draw_probs == 1)) {
        File_output_prob[(j - STUDY_j_start)].println(""); 
      }
    }
  }

  float pal_length = 400;
  for (int q = 0; q < 11; q += 1) {
    float prob_V = 10 * q / 100.0;
    
    float _u = PAL_Multiplier * prob_V;
    
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
    
    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);  
    STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
    STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);     
    
    STUDY_Diagrams.strokeWeight(0); 
    
    float Y_OFFSET = (0.25 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale;
 
    //STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, 125 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 
    STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, Y_OFFSET, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View);
    
    if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
      STUDY_Diagrams.stroke(127);
      STUDY_Diagrams.fill(127);
      STUDY_Diagrams.strokeWeight(0);
    }
    else {
      STUDY_Diagrams.stroke(255);
      STUDY_Diagrams.fill(255);
      STUDY_Diagrams.strokeWeight(2);
    }   
    
    STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
    STUDY_Diagrams.textAlign(CENTER, CENTER);
    //STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 + 125 - 0.05 * 20) * STUDY_S_View);
    STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, Y_OFFSET + (10 - 0.05 * 20) * STUDY_S_View);
  }
}


void SOLARCHVISION_draw_sorted (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  int PAL_TYPE = STUDY_Pallet_SORT_CLR; 
  int PAL_DIR = STUDY_Pallet_SORT_DIR;  
  float PAL_Multiplier = STUDY_Pallet_SORT_MLT;

  float[] sorted_valuesA = sort(_valuesA);
  int num_sorted_valuesA = 0;
  for (int l = 0; l < sorted_valuesA.length; l += 1) {
    if (sorted_valuesA[l] < 0.9 * FLOAT_undefined) {
      num_sorted_valuesA += 1;
    }
    else break;
  }
  
  float[] sorted_valuesB = sort(_valuesB);
  int num_sorted_valuesB = 0;
  for (int l = 0; l < sorted_valuesB.length; l += 1) {
    if (sorted_valuesB[l] < 0.9 * FLOAT_undefined) {
      num_sorted_valuesB += 1;
    }
    else break;
  }
  
  int num_sorted_valuesAB = min(num_sorted_valuesA, num_sorted_valuesB);
  
  for (int l = 0; l < (num_sorted_valuesAB - 1); l += 1) {
    float sort_V = 1.1 * (0.5 - ((num_sorted_valuesAB - (l + 1)) / float(num_sorted_valuesAB)));
    
    float _u = 0.5 + 0.5 * 0.75 * (PAL_Multiplier * sort_V);
    
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
    
    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
    STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
    STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);    
    
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.0); 
    //STUDY_Diagrams.rect((j + ((i + 1) / 24.0)) * sx_Plot, sorted_valuesA[l] * sy_Plot, -(1 * 100 / 24.0) * STUDY_U_scale, (sorted_valuesA[(l + 1)] - sorted_valuesA[l]) * sy_Plot);
    
    float P1x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
    float P2x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
    float P3x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
    float P4x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
    
    float P1y = sorted_valuesA[l] * sy_Plot;
    float P2y = sorted_valuesA[(l + 1)] * sy_Plot;
    float P3y = sorted_valuesB[(l + 1)] * sy_Plot;
    float P4y = sorted_valuesB[l] * sy_Plot; 
    
    STUDY_Diagrams.quad(P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y);
    /*
    STUDY_Diagrams.stroke(255);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.5); 
    STUDY_Diagrams.line(P1x, P1y, P4x, P4y); 
    STUDY_Diagrams.line(P2x, P2y, P3x, P3y);
    */
  }
  
  String[] _txt = {"MIN", "", "25%", "", "MED", "", "75%", "", "MAX"}; 
  float pal_length = 400;
  for (int q = 0; q < 9; q += 1) {
    float sort_V = 1.1 * (q - 4) / 8.0;
    
    float _u = 0.5 + 0.5 * 0.75 * (PAL_Multiplier * sort_V);
    
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
    
    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
    STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
    STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);     
     
    float Y_OFFSET = (0.25 + STUDY_V_belowLine[STUDY_drw_Layer]) * sx_Plot / STUDY_U_scale;

    //STUDY_Diagrams.strokeWeight(0.0);
    STUDY_Diagrams.stroke(255); STUDY_Diagrams.strokeWeight(0.5); 
    //STUDY_Diagrams.rect((700 + q * (pal_length / 9.0)) * STUDY_S_View, 125 * STUDY_S_View, (pal_length / 9.0) * STUDY_S_View, 20 * STUDY_S_View);
    STUDY_Diagrams.rect((700 + q * (pal_length / 9.0)) * STUDY_S_View, Y_OFFSET, (pal_length / 9.0) * STUDY_S_View, 20 * STUDY_S_View);
    
    if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
      STUDY_Diagrams.stroke(127);
      STUDY_Diagrams.fill(127);
      STUDY_Diagrams.strokeWeight(0);
    }
    else {
      STUDY_Diagrams.stroke(255);
      STUDY_Diagrams.fill(255);
      STUDY_Diagrams.strokeWeight(2);
    }   

    STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
    STUDY_Diagrams.textAlign(CENTER, CENTER);
    //STUDY_Diagrams.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * STUDY_S_View, (10 + 125 - 0.05 * 20) * STUDY_S_View);
    STUDY_Diagrams.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * STUDY_S_View, Y_OFFSET + (10 - 0.05 * 20) * STUDY_S_View);
    
  }   
}


void SOLARCHVISION_draw_normals (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  float[] NormalsA = SOLARCHVISION_NORMAL(_valuesA);
  float[] NormalsB = SOLARCHVISION_NORMAL(_valuesB);
  
  if (STUDY_drw_Layer == _winddir) {
    float[] X_valuesA;
    float[] Y_valuesA;
    X_valuesA = new float [_valuesA.length];
    Y_valuesA = new float [_valuesA.length];
    
    for (int l = 0; l < _valuesA.length; l += 1) {
      if (_valuesA[l] < 0.9 * FLOAT_undefined) {
        X_valuesA[l] = cos_ang(90 - _valuesA[l]); 
        Y_valuesA[l] = sin_ang(90 - _valuesA[l]);
      }
      else {
        X_valuesA[l] = FLOAT_undefined; 
        Y_valuesA[l] = FLOAT_undefined;
      }
    }
            
    float[] X_NormalsA = SOLARCHVISION_NORMAL(X_valuesA);
    float[] Y_NormalsA = SOLARCHVISION_NORMAL(Y_valuesA);
    
    for (int l = 0; l < NormalsA.length; l += 1) {
      if (NormalsA[l] < 0.9 * FLOAT_undefined) {
        NormalsA[l] = 90 - atan2_ang(Y_NormalsA[l], X_NormalsA[l]);
        if (NormalsA[l] < 0) NormalsA[l] += 360;
      }
      
      if ((l == N_Max) || (l == N_Min)) {
        NormalsA[l] = FLOAT_undefined;
      }
    }
    
    float[] X_valuesB;
    float[] Y_valuesB;
    X_valuesB = new float [_valuesB.length];
    Y_valuesB = new float [_valuesB.length];
    
    for (int l = 0; l < _valuesB.length; l += 1) {
      if (_valuesB[l] < 0.9 * FLOAT_undefined) {
        X_valuesB[l] = cos_ang(90 - _valuesB[l]); 
        Y_valuesB[l] = sin_ang(90 - _valuesB[l]);
      }
      else {
        X_valuesB[l] = FLOAT_undefined; 
        Y_valuesB[l] = FLOAT_undefined;
      }
    }
            
    float[] X_NormalsB = SOLARCHVISION_NORMAL(X_valuesB);
    float[] Y_NormalsB = SOLARCHVISION_NORMAL(Y_valuesB);
    
    for (int l = 0; l < NormalsB.length; l += 1) {
      if (NormalsB[l] < 0.9 * FLOAT_undefined) {
        NormalsB[l] = 90 - atan2_ang(Y_NormalsB[l], X_NormalsB[l]);
        if (NormalsB[l] < 0) NormalsB[l] += 360;
      }
      
      if ((l == N_Max) || (l == N_Min)) {
        NormalsB[l] = FLOAT_undefined;
      }
    }
  }
  int _OPACITY = 191;
  
  for (int l = 0; l < 9; l += 1) {
  //for (int l = 0; l < 3; l += 1) {
  //for (int l = 3; l < 9; l += 1) {
  
  //for (int p = 0; p < 3; p += 1) { 
    //int l = 3 * int(impact_layer / 3) + p;

  //for (int p = 0; p < 1; p += 1) { 
    //int l = impact_layer;


    if (l == N_Middle) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 191, 0, _OPACITY);
      STUDY_Diagrams.fill(0, 191, 0, _OPACITY);
    }
    else if (l == N_MidHigh) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(191, 0, 0, _OPACITY);
      STUDY_Diagrams.fill(191, 0, 0, _OPACITY);
    } 
    else if (l == N_MidLow) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 0, 191, _OPACITY);
      STUDY_Diagrams.fill(0, 0, 191, _OPACITY);
    } 
    else if (l == N_Max) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(255, 127, 127, _OPACITY);
      STUDY_Diagrams.fill(255, 127, 127, _OPACITY);
    } 
    else if (l == N_Min) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(127, 127, 255, _OPACITY);
      STUDY_Diagrams.fill(127, 127, 255, _OPACITY);
    }
    else if (l == N_M50) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 127, 0);
      STUDY_Diagrams.fill(0, 127, 0);
    }
    else if (l == N_M75) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(127, 0, 0);
      STUDY_Diagrams.fill(127, 0, 0);
    } 
    else if (l == N_M25) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 0, 127);
      STUDY_Diagrams.fill(0, 0, 127);
    } 
    else {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 0, 0);
      STUDY_Diagrams.fill(0, 0, 0);
    }


/*
    if (l == impact_layer) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 191, 0, _OPACITY);
      STUDY_Diagrams.fill(0, 191, 0, _OPACITY);
    }
*/

/////////////////////////////// 
/*
    if (now_drawing == databaseNumber_CLIMATE_WY2) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 127, 0);
      STUDY_Diagrams.fill(0, 127, 0);
    }
    if (now_drawing == databaseNumber_ENSEMBLE) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(127, 0, 0);
      STUDY_Diagrams.fill(127, 0, 0);
    }
    if (now_drawing == databaseNumber_OBSERVED) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 0, 127);
      STUDY_Diagrams.fill(0, 0, 127);
    }
    if (now_drawing == databaseNumber_CLIMATE_EPW) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 127, 0);
      STUDY_Diagrams.fill(0, 127, 0);
    }    
*/    
    
    //STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
    //STUDY_Diagrams.stroke(0, 127, 0);
    //STUDY_Diagrams.fill(0, 127, 0);
    
/////////////////////////////// 

    
    float z_l = 60; //l;
    if (l == N_M75) z_l = 61;
    if (l == N_M50) z_l = 61;
    if (l == N_M25) z_l = 61;
    if (l == N_Ave) z_l = 62;
    
    if ((NormalsA[l] < 0.9 * FLOAT_undefined) && (NormalsB[l] < 0.9 * FLOAT_undefined)) {
      my_line((j + ((i + 0.5) / 24.0)) * sx_Plot, NormalsA[l] * sy_Plot, z_l * sz_Plot * STUDY_W_scale, (j + ((i + 0.5 + dT) / 24.0)) * sx_Plot, NormalsB[l] * sy_Plot, z_l * sz_Plot * STUDY_W_scale); 
    } 
    
    if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) {
      if (NormalsA[l] < 0.9 * FLOAT_undefined) File_output_norm[(j - STUDY_j_start)].print(nfs(NormalsA[l] - STUDY_V_offset[STUDY_drw_Layer], 5, 5) + "\t"); 
      else File_output_norm[(j - STUDY_j_start)].print("[undefined]\t");
    }

  }
  if ((Export_STUDY_info_norm == 1) && (draw_normals == 1)) File_output_norm[(j - STUDY_j_start)].println();
}  




void SOLARCHVISION_DevelopDATA (int data_source) {

  float keep_per_day = per_day;
  int keep_num_add_days = num_add_days;
  if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
    per_day = 1;
    num_add_days = 1;
  }
  
  int start_z = get_startZ_endZ(data_source)[0];
  int end_z = get_startZ_endZ(data_source)[1]; 
  int layers_count = get_startZ_endZ(data_source)[2]; 
 
  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float RAIN, T, WS, R_dir, R_dif;

  float[] _valuesSUM; 
  _valuesSUM = new float [layers_count];
  
  for (int k = 0; k < layers_count; k += 1) {
      _valuesSUM[k] = FLOAT_undefined;
  }



  
  for (int j = STUDY_j_start; j <= STUDY_j_end; j += 1) { 
    for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
        for (int i = 0; i < 24; i += 1) {
  
          int now_k = k;
          int now_i = i;
          int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
          
          if (now_j >= 365) {
           now_j = now_j % 365; 
          }
          if (now_j < 0) {
           now_j = (now_j + 365) % 365; 
          }
          
          int next_i = now_i + 12;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = next_i - 24; 
            next_j += 1; 
            if (next_j >= 365) {
              next_j = next_j % 365;
            }
          }
          
          
          int pre_i = now_i - 12;
          int pre_j = now_j;
          int pre_k = now_k;
          if (pre_i < 0) {
            pre_i = pre_i + 24; 
            pre_j -= 1; 
            if (pre_j < 0) {
              pre_j = (pre_j + 365) % 365;
            }
          }       
          
          
          
          if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = FLOAT_undefined;
          if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = FLOAT_undefined;
          if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = FLOAT_undefined;
          
          T = FLOAT_undefined;
          R_dir = FLOAT_undefined;
          R_dif = FLOAT_undefined;
          
          if ((i == 0) && (j == STUDY_j_start)) _valuesSUM[now_k] = 0; 
  
          if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
          if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            R_dir = FLOAT_undefined;
          }
          else {
            R_dir = Pa;
          }
    
          if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k];
          if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[now_i][now_j][_difhorrad][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            R_dif = FLOAT_undefined;
          }
          else {
            R_dif = Pa;
          }
          
          if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[now_i][now_j][_drybulb][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[now_i][now_j][_drybulb][now_k];
          if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[now_i][now_j][_drybulb][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            T = FLOAT_undefined;
          }
          else {
            T = Pa;
          }
          
          if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[now_i][now_j][_windspd][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[now_i][now_j][_windspd][now_k];
          if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[now_i][now_j][_windspd][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            WS = FLOAT_undefined;
          }
          else {
            WS = Pa;
          }        
          
          if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[now_i][now_j][A_precipitation][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[now_i][now_j][A_precipitation][now_k];
          if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[now_i][now_j][A_precipitation][now_k];
          
          if (data_source == databaseNumber_CLIMATE_EPW) Pb = CLIMATE_EPW[next_i][next_j][A_precipitation][now_k];
          if (data_source == databaseNumber_CLIMATE_WY2) Pb = CLIMATE_WY2[next_i][next_j][A_precipitation][now_k];
          if (data_source == databaseNumber_ENSEMBLE) Pb = ENSEMBLE[next_i][next_j][A_precipitation][now_k];
          //if (data_source == databaseNumber_CLIMATE_EPW) Pb = CLIMATE_EPW[pre_i][pre_j][A_precipitation][now_k];
          //if (data_source == databaseNumber_CLIMATE_WY2) Pb = CLIMATE_WY2[pre_i][pre_j][A_precipitation][now_k];
          //if (data_source == databaseNumber_ENSEMBLE) Pb = ENSEMBLE[pre_i][pre_j][A_precipitation][now_k];
          
          if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined)) {
            RAIN = FLOAT_undefined;
          }
          else {
            RAIN = Pb - Pa;
            //RAIN = Pa - Pb;
            
            if (T <= 0) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Lewis
            //if ((T < 5) && (T > -5)) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Mojtaba          
            
          }    
          
            
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);
          float HOUR_ANGLE = now_i; 
          
          float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
  
  
  
  
  
  
          if (develop_option == DEV_OP_0) {  
            
            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 
             
              if (Materials_DirectArea_Flag[now_i][now_j] == -1) {
                _valuesSUM[now_k] = FLOAT_undefined;
              } 
              else {
                _valuesSUM[now_k] = 0.001 * (R_dir * Materials_DirectArea[Materials_Selection][now_i][now_j] + R_dif * Materials_DiffuseArea[Materials_Selection][now_i][now_j]);
              }
  
  
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 0.5;
            STUDY_V_offset[_developed] = 0;
            STUDY_V_belowLine[_developed] = 1;
            LAYERS_Unit[_developed] = "KW";
            LAYERS_Title[_developed][_EN] = "Direct radiation on surfaces with material #" + String.valueOf(Materials_Selection);
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ?? 
          }         
  
   
          if (develop_option == DEV_OP_1) {
            float Alpha = Angle_inclination;
            float Beta = Angle_orientation;
            
             
            
            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 
             
              _valuesSUM[now_k] = SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 0.1;
            STUDY_V_offset[_developed] = 0;
            STUDY_V_belowLine[_developed] = 0;
            LAYERS_Unit[_developed] = "W/m²";
            LAYERS_Title[_developed][_EN] = "Radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ??         
          } 
          
          if (develop_option == DEV_OP_2) {
            float Alpha = Angle_inclination;
            float Beta = Angle_orientation;
            
            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 
              
              _valuesSUM[now_k] += SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
            }
  
              
            STUDY_V_scale[_developed] = 2.5;
            STUDY_V_offset[_developed] = -40;
            STUDY_V_belowLine[_developed] = 1;
            LAYERS_Unit[_developed] = "kWh/m²";
            LAYERS_Title[_developed][_EN] = "Accumulated radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ?? 
          } 
          
          if (develop_option == DEV_OP_3) {
            float Alpha = asin_ang(SunR[3]);
            float Beta = atan2_ang(SunR[2], SunR[1]) + 90;
            
            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 
             
              _valuesSUM[now_k] = SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 0.1;
            STUDY_V_offset[_developed] = 0;
            STUDY_V_belowLine[_developed] = 0;
            LAYERS_Unit[_developed] = "W/m²";
            LAYERS_Title[_developed][_EN] = "Radiation on solar tracker";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ?? 
          }         
          
          if (develop_option == DEV_OP_4) {
            float Alpha = asin_ang(SunR[3]);
            float Beta = atan2_ang(SunR[2], SunR[1]) + 90;
            
            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 
             
              _valuesSUM[now_k] += SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = 0.001 * _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 2.5;
            STUDY_V_offset[_developed] = -40;
            STUDY_V_belowLine[_developed] = 1;
            LAYERS_Unit[_developed] = "kWh/m²";
            LAYERS_Title[_developed][_EN] = "Accumulated radiation on solar tracker";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ?? 
          } 
          
          
          if (develop_option == DEV_OP_5) {
            
            if (T < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] += (T - 18) / 24;
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 1.0;
            STUDY_V_offset[_developed] = 0;
            STUDY_V_belowLine[_developed] = -1;
            LAYERS_Unit[_developed] = "°C";
            LAYERS_Title[_developed][_EN] = "Accumulated degree day (based on 18°C)";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ??         
          } 
          
          if (develop_option == DEV_OP_6) {
            
            _valuesSUM[now_k] = 0;
            float sum_count = 0;
            
            int num_count = join_hour_numbers;
            
      
            for (int _count = 1; _count <= num_count; _count += 1) {
              
              int plus_i = - (_count - 1);
              
              int new_k = k;
              int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
              int new_j = (j + BEGIN_DAY + 365 + floor((i + plus_i) / 24.0)) % 365;
              
              if (new_j >= 365) {
               new_j = new_j % 365; 
              }
              if (now_j < 0) {
               new_j = (new_j + 365) % 365; 
              }
              
              float T_new = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[new_i][new_j][develop_Layer][new_k];
              if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[new_i][new_j][develop_Layer][new_k];
              if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[new_i][new_j][develop_Layer][new_k];
  
              if (Pa > 0.9 * FLOAT_undefined) {
                T_new = FLOAT_undefined;
              }
              else {
                T_new = Pa;
              }            
              
              if (T_new < 0.9 * FLOAT_undefined) {
                float _weight = (num_count - _count + 1);
                if (join_type == 1) _weight = 1;
                sum_count += _weight;
                _valuesSUM[now_k] += _weight * T_new;
                
              }           
            } 
           
            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
            else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = FLOAT_undefined;
            }
            
            _valuesSUM[now_k] = 0;
  
              
            STUDY_V_scale[_developed] = STUDY_V_scale[develop_Layer];
            STUDY_V_offset[_developed] = STUDY_V_offset[develop_Layer];
            STUDY_V_belowLine[_developed] = STUDY_V_belowLine[develop_Layer];
            LAYERS_Unit[_developed] = LAYERS_Unit[develop_Layer];
            LAYERS_Title[_developed][_EN] = String.valueOf(join_hour_numbers) + "-hour PASSIVE trend of " + LAYERS_Title[develop_Layer][_EN];
            LAYERS_Title[_developed][_FR] = String.valueOf(join_hour_numbers) + "-hour PASSIVE trend of " + LAYERS_Title[develop_Layer][_FR]; // ??    
          }     
      
      
          if (develop_option == DEV_OP_7) {
            
            _valuesSUM[now_k] = 0;
            float sum_count = 0;
            
            int num_count = join_hour_numbers;
            
      
            for (int _count = 1; _count <= ceil((num_count + 1) / 2); _count += 1) {
              for (int dir_count = -1; dir_count <= 1; dir_count += 2) {
              
                int plus_i = dir_count * (_count - 1);
                
                int new_k = k;
                int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                int new_j = (j + BEGIN_DAY + 365 + floor((i + plus_i) / 24.0)) % 365;
                
                if (new_j >= 365) {
                 new_j = new_j % 365; 
                }
                if (now_j < 0) {
                 new_j = (new_j + 365) % 365; 
                }
                
                float T_new = FLOAT_undefined;
                
                if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[new_i][new_j][develop_Layer][new_k];
                if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[new_i][new_j][develop_Layer][new_k];
                if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[new_i][new_j][develop_Layer][new_k];
                
                if (Pa > 0.9 * FLOAT_undefined) {
                  T_new = FLOAT_undefined;
                }
                else {
                  T_new = Pa;
                }            
                
                if (T_new < 0.9 * FLOAT_undefined) {
                  float _weight = (num_count - _count + 1);
                  if (join_type == 1) _weight = 1;
                  sum_count += _weight;
                  _valuesSUM[now_k] += _weight * T_new;
                  
                }    
              }       
            } 
           
            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
            else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = FLOAT_undefined;
            }
            
            _valuesSUM[now_k] = 0;
  
              
            STUDY_V_scale[_developed] = STUDY_V_scale[develop_Layer];
            STUDY_V_offset[_developed] = STUDY_V_offset[develop_Layer];
            STUDY_V_belowLine[_developed] = STUDY_V_belowLine[develop_Layer];
            LAYERS_Unit[_developed] = LAYERS_Unit[develop_Layer];
            LAYERS_Title[_developed][_EN] = String.valueOf(join_hour_numbers) + "-hour NORMAL trend of " + LAYERS_Title[develop_Layer][_EN];
            LAYERS_Title[_developed][_FR] = String.valueOf(join_hour_numbers) + "-hour NORMAL trend of " + LAYERS_Title[develop_Layer][_FR]; // ??
  
          }           
          
          if (develop_option == DEV_OP_8) {
            
            _valuesSUM[now_k] = 0;
            float sum_count = 0;
            
            int num_count = join_hour_numbers;
            
      
            for (int _count = num_count; _count > 0; _count -= 1) {
              
              int plus_i = _count - 1;
              
              int new_k = k;
              int new_i = ((i + plus_i) + 24 * floor((i + plus_i) / 24.0)) % 24;
              int new_j = (j + BEGIN_DAY + 365 + floor((i + plus_i) / 24.0)) % 365;
              
              if (new_j >= 365) {
               new_j = new_j % 365; 
              }
              if (now_j < 0) {
               new_j = (new_j + 365) % 365; 
              }
              
              float T_new = FLOAT_undefined;
              
              if (data_source == databaseNumber_CLIMATE_EPW) Pa = CLIMATE_EPW[new_i][new_j][develop_Layer][new_k];
              if (data_source == databaseNumber_CLIMATE_WY2) Pa = CLIMATE_WY2[new_i][new_j][develop_Layer][new_k];
              if (data_source == databaseNumber_ENSEMBLE) Pa = ENSEMBLE[new_i][new_j][develop_Layer][new_k];
  
              if (Pa > 0.9 * FLOAT_undefined) {
                T_new = FLOAT_undefined;
              }
              else {
                T_new = Pa;
              }            
              
              if (T_new < 0.9 * FLOAT_undefined) {
                float _weight = (num_count - _count + 1);
                if (join_type == 1) _weight = 1;
                sum_count += _weight;
                _valuesSUM[now_k] += _weight * T_new;
                
              }           
            } 
           
            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
            else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = FLOAT_undefined;
            }
            
            _valuesSUM[now_k] = 0;
  
              
            STUDY_V_scale[_developed] = STUDY_V_scale[develop_Layer];
            STUDY_V_offset[_developed] = STUDY_V_offset[develop_Layer];
            STUDY_V_belowLine[_developed] = STUDY_V_belowLine[develop_Layer];
            LAYERS_Unit[_developed] = LAYERS_Unit[develop_Layer];
            LAYERS_Title[_developed][_EN] = String.valueOf(join_hour_numbers) + "-hour ACTIVE trend of " + LAYERS_Title[develop_Layer][_EN];
            LAYERS_Title[_developed][_FR] = String.valueOf(join_hour_numbers) + "-hour ACTIVE trend of " + LAYERS_Title[develop_Layer][_FR]; // ??    
          } 
          
  
          if (develop_option == DEV_OP_9) {
            
            if (RAIN < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] = RAIN;
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 2.5;
            STUDY_V_offset[_developed] = 0; //-20.0 / (1.0 * level_pix); // so that we can have two views on probabilites above and below zero.
            STUDY_V_belowLine[_developed] = 0; //1;
            LAYERS_Unit[_developed] = "mm/12hours";
            LAYERS_Title[_developed][_EN] = "12-hour Surface Accumulated Precipitation";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ??         
          } 
  
          if (develop_option == DEV_OP_10) {
            
            if (RAIN < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] = RAIN;
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 4.0;
            STUDY_V_offset[_developed] = 0; 
            STUDY_V_belowLine[_developed] = 1;
            LAYERS_Unit[_developed] = "mm/h";
            LAYERS_Title[_developed][_EN] = "Hourly Surface Precipitation (interpolated)";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ??         
          } 
          
          
          if (develop_option == DEV_OP_11) {
           
            if (WS < 0.9 * FLOAT_undefined) { 
             
              _valuesSUM[now_k] = 0.5 * 1.23 * 1 * pow(WS / 3.6, 3); 
              
              if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[now_i][now_j][_developed][now_k] = _valuesSUM[now_k];
            }
              
            STUDY_V_scale[_developed] = 0.05;
            STUDY_V_offset[_developed] = 0;
            STUDY_V_belowLine[_developed] = 0;
            LAYERS_Unit[_developed] = "W/m²";
            LAYERS_Title[_developed][_EN] = "Wind power";
            LAYERS_Title[_developed][_FR] = LAYERS_Title[_developed][_EN]; // ?? 
          }    
  
  
          
          
          
         
          if ((develop_option == DEV_OP_2) || (develop_option == DEV_OP_4)) {
           
            if ((i == 23) && (develop_per_day == 1)) {
              for (int l = i + 1 - 24; l <= i ; l += 1) {
                if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[l][now_j][_developed][now_k] = ENSEMBLE[now_i][now_j][_developed][now_k];
              }
              //sum_interval = 24;
              STUDY_V_scale[_developed] = 10;
              STUDY_V_offset[_developed] = 0;
              STUDY_V_belowLine[_developed] = 0;
              LAYERS_Unit[_developed] += "/day";
              
              _valuesSUM[now_k] = 0;
            }
            
            if (((i == 11) || (i == 23)) && (develop_per_day == 2)) {
              for (int l = i + 1 - 12 ; l <= i; l += 1) {
                if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[l][now_j][_developed][now_k] = ENSEMBLE[now_i][now_j][_developed][now_k];
              }
              //sum_interval = 12;
              STUDY_V_scale[_developed] = 10;
              STUDY_V_offset[_developed] = 0;
              STUDY_V_belowLine[_developed] = 0;
              LAYERS_Unit[_developed] += "/12hours";
              
              _valuesSUM[now_k] = 0;
            }   
  
            if (((i == 5) || (i == 11) || (i == 17) || (i == 23)) && (develop_per_day == 3)) {
              for (int l = i + 1 - 6 ; l <= i; l += 1) {
                if (data_source == databaseNumber_CLIMATE_EPW) CLIMATE_EPW[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_WY2) CLIMATE_WY2[l][now_j][_developed][now_k] = CLIMATE_WY2[now_i][now_j][_developed][now_k];
                if (data_source == databaseNumber_ENSEMBLE) ENSEMBLE[l][now_j][_developed][now_k] = ENSEMBLE[now_i][now_j][_developed][now_k];
              }
              //sum_interval = 6;
              STUDY_V_scale[_developed] = 10;
              STUDY_V_offset[_developed] = 0;
              STUDY_V_belowLine[_developed] = 0;
              LAYERS_Unit[_developed] += "/6hours";
              
              _valuesSUM[now_k] = 0;
            }     
          }
        }
      }
    } 
  }
  
  per_day = keep_per_day;
  num_add_days = keep_num_add_days;
  

}





int N_MidLow = 0;
int N_Middle = 1;
int N_MidHigh = 2;

int N_M25 = 3;
int N_M50 = 4;
int N_M75 = 5;

int N_Min = 6;
int N_Ave = 7;
int N_Max = 8;

String[] N_Title = {
  "Mid-LOW*       ",   
  "MIDDLE*        ", 
  "Mid-HIGH*      ", 
 
  "25th Percentile", 
  "50th P.(Median)", 
  "75th Percentile", 

  "MINIMUM        ", 
  "AVERAGE        ", 
  "MAXIMUM        "

};

int[] reverse_N;
{
  reverse_N = new int [9];
  reverse_N[N_MidLow] = N_MidHigh;
  reverse_N[N_Middle] = N_Middle;
  reverse_N[N_MidHigh] = N_MidLow;
  reverse_N[N_M25] = N_M75;
  reverse_N[N_M50] = N_M50;
  reverse_N[N_M75] = N_M25;
  reverse_N[N_Min] = N_Max;
  reverse_N[N_Ave] = N_Ave;
  reverse_N[N_Max] = N_Min;
}

float[] SOLARCHVISION_NORMAL (float[] _values) {

  float[] weight_array = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  float[] return_array = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  
  int NV = 0; // the number of values without counting undefined values
  float _weight = 0; 
  
  _values = sort(_values);
  for (int i = 0; i < _values.length; i += 1) {
    if (_values[i] < 0.9 * FLOAT_undefined) NV += 1;
  }

  if (NV > 0) {
    for (int i = 0; i < NV; i += 1) {
      if (_values[i] < 0.9 * FLOAT_undefined) {
        _weight = 1;
        weight_array[N_Ave] += _weight;
        return_array[N_Ave] += _values[i];
        
        _weight = (0.5 * (NV + 1)) - abs((0.5 * (NV + 1)) - (i + 1));
        weight_array[N_Middle] += _weight;
        return_array[N_Middle] += _values[i] * _weight;
        
        _weight = (i + 1);
        weight_array[N_MidHigh] += _weight;
        return_array[N_MidHigh] += _values[i] * _weight;
        
        _weight = (NV + 1 - i);
        weight_array[N_MidLow] += _weight;
        return_array[N_MidLow] += _values[i] * _weight; 
      }
    }

    return_array[N_Ave] /= weight_array[N_Ave];
    return_array[N_Middle] /= weight_array[N_Middle];
    return_array[N_MidHigh] /= weight_array[N_MidHigh];
    return_array[N_MidLow] /= weight_array[N_MidLow];
    
    return_array[N_Max] = _values[(NV - 1)];
    return_array[N_Min] = _values[0];

    if ((NV % 2) == 1) {

      return_array[N_M50] = _values[(floor(NV / 2))];
    }
    else {
      
      return_array[N_M50] = 0.5 * (_values[(floor(NV / 2))] + _values[(floor(NV / 2) - 1)]);

    }
    
    int q;
    
    q = int(roundTo((NV * 0.75), 1));
    if (q > NV - 1) q = NV - 1;
    return_array[N_M75] = _values[q];

    q = int(roundTo((NV * 0.25), 1));
    if (q < 0) q = 0;
    return_array[N_M25] = _values[q];
  }
  else {
    for (int i = 0; i < return_array.length; i += 1) {
      return_array[i] = FLOAT_undefined;
    }
  }
  
  return return_array; 
}



int SOLARCHVISION_filter (String data_type, int _cloudcover, int type_of_filter, int scenario_of_sky, int now_i, int now_j, int now_k) {
  
  float total_sky = 0;
  int num_sky = 0;
  
  int start_q = now_i;
  int end_q = now_i;
  
  if (type_of_filter == _daily) {
    start_q = 0;
    end_q = 23;
  }
  
  for (int q = start_q; q <= end_q; q += 1) {
    float _sky = FLOAT_undefined;
    if (data_type.equals("OBSERVED")) _sky = OBSERVED[q][now_j][_cloudcover][now_k];
    if (data_type.equals("ENSEMBLE")) _sky = ENSEMBLE[q][now_j][_cloudcover][now_k];
    if (data_type.equals("CLIMATE_WY2")) _sky = CLIMATE_WY2[q][now_j][_cloudcover][now_k];
    if (data_type.equals("CLIMATE_EPW")) _sky = CLIMATE_EPW[q][now_j][_cloudcover][now_k];
    
    if (_sky > 0.9 * FLOAT_undefined) {
    }
    else {
      total_sky += _sky;
      num_sky += 1;
    }
  }
  

  int _return = 0;
  
  if (num_sky != 0) {
    total_sky /= num_sky;
    
    if (scenario_of_sky == 1) _return = 1;
    else if ((scenario_of_sky == 4) && (total_sky <= 3.33)) _return = 1;
    else if ((scenario_of_sky == 3) && (total_sky > 3.33) && (total_sky <= 6.66)) _return = 1; 
    else if ((scenario_of_sky == 2) && (total_sky > 6.66)) _return = 1;
  }
  
  return _return;
}


int[] SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS (float[] _values) {
  
  float[] _normals = SOLARCHVISION_NORMAL(_values);
  
  int[] return_array = new int [9];
  
  for (int l = 0; l < 9; l += 1) {
    return_array[l] = -1;
    if (_normals[l] < 0.9 * FLOAT_undefined) {
    
      float _dist = FLOAT_undefined;
      
      for (int i = 0; i < _values.length; i += 1) {
        if (_dist > abs(_normals[l] - _values[i])) {
          _dist = abs(_normals[l] - _values[i]);
          return_array[l] = i;
        }
      }
    }
    else return_array[l] = -1;
  }
  
  return return_array; 
}


int[] SOLARCHVISION_PROCESS_DAILY_SCENARIOS (int layers_count, int start_z, int end_z, int j, float DATE_ANGLE) {

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;
 
  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  float[] _valuesSUM_RAD; 
  float[] _valuesSUM_EFF;
  float[] _valuesNUM;
  _valuesSUM_RAD = new float [(layers_count * num_add_days)];
  _valuesSUM_EFF = new float [(layers_count * num_add_days)];
  _valuesNUM = new float [(layers_count * num_add_days)];
  
  for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
    for (int k = 0; k < layers_count; k += 1) { 
      _valuesSUM_RAD[(k * num_add_days + j_ADD)] = FLOAT_undefined;
      _valuesSUM_EFF[(k * num_add_days + j_ADD)] = FLOAT_undefined;
      _valuesNUM[(k * num_add_days + j_ADD)] = 0;
    }          
  }

  for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {
    
    for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
      
      for (int i = 0; i < 24; i += 1) {
        
        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
        
        int now_k = k;
        int now_i = i;
        int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;

        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
        
        if (impacts_source == databaseNumber_CLIMATE_WY2) {
            Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
            Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
            Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
            Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
        }
        if (impacts_source == databaseNumber_ENSEMBLE) {
            Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
            Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
            Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
            Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
        }            
        if (impacts_source == databaseNumber_OBSERVED) {
            Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
            Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
            Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
            Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
        }   
        if (impacts_source == databaseNumber_CLIMATE_EPW) {
            Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
            Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
            Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
            Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
        }   
        
        if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
        }
        else {
    
          int drw_count = 0;
          if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
          if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
          if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
          if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
          
          if (drw_count == 1) {
            _values_R_dir = 0.001 * Pa;
            _values_R_dif = 0.001 * Pb;
            _values_E_dir = 0.0001 * Pc;
            _values_E_dif = 0; //0.0001 * Pd;
            
            if (_valuesSUM_RAD[(k * num_add_days + j_ADD)] > 0.9 * FLOAT_undefined) {
              _valuesSUM_RAD[(k * num_add_days + j_ADD)] = 0;
              _valuesSUM_EFF[(k * num_add_days + j_ADD)] = 0;
              _valuesNUM[(k * num_add_days + j_ADD)] = 0; 
            }                  
    
            _valuesSUM_RAD[(k * num_add_days + j_ADD)] += ((_values_R_dir * SunR[3]) + (_values_R_dif)); // calculates total horizontal radiation
            _valuesSUM_EFF[(k * num_add_days + j_ADD)] += ((_values_E_dir * SunR[3]) + (_values_E_dif)); // calculates total horizontal effects
            _valuesNUM[(k * num_add_days + j_ADD)] += 1;
          }
        }
      }
    }
  }
  
  if (Impact_TYPE == Impact_PASSIVE) 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_EFF);
  else 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_RAD);
}


void SOLARCHVISION_PlotIMPACT (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  float keep_per_day = per_day;
  int keep_num_add_days = num_add_days;
  
  if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
    per_day = 1;
    num_add_days = 1;
  }
  
  int start_z = get_startZ_endZ(impacts_source)[0];
  int end_z = get_startZ_endZ(impacts_source)[1]; 
  int layers_count = get_startZ_endZ(impacts_source)[2]; 


  if ((plot_impacts == -2) || (plot_impacts == -1)) {
    
    SOLARCHVISION_build_WindRose_Image_array(); 
    
    int RES = WindRose_RES;
    
    Rendered_WindRose_RES = RES;
    
    if (plot_impacts == -2) Impact_TYPE = Impact_SPD_DIR; 
    if (plot_impacts == -1) Impact_TYPE = Impact_SPD_DIR_TMP;
    
    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;

    float[] _values_w_dir;
    float[] _values_w_spd; 
    float[] _values_w_tmp; 
    _values_w_dir = new float [layers_count];
    _values_w_spd = new float [layers_count]; 
    _values_w_tmp = new float [layers_count]; 

    for (int k = 0; k < layers_count; k += 1) { 
      _values_w_dir[k] = FLOAT_undefined;
      _values_w_spd[k] = FLOAT_undefined;
      _values_w_tmp[k] = FLOAT_undefined;
    }

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_SPD_DIR) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_SPD_DIR_TMP) {  
      //PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
      PAL_TYPE = 12; PAL_DIR = -1;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_SPD_DIR) PAL_Multiplier = 1.0;
    if (Impact_TYPE == Impact_SPD_DIR_TMP) PAL_Multiplier = 1.0 / 30.0;

    for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
      
      PGraphics WIND_Diagrams = createGraphics(RES, RES); 
      WIND_Diagrams.beginDraw();
      //WIND_Diagrams.background(255);
      WIND_Diagrams.translate(0.5 * RES, 0.5 * RES);
    
      for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {    
        for (int i = 0; i < 24; i += 1) {
          if (isInHourlyRange(i) == 1) {
          
            for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
    
              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;
             
              int _plot = 1;
              
              if (_plot == 1) {
                
                int now_k = k;
                int now_i = i;
                int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
    
                if (now_j >= 365) {
                 now_j = now_j % 365; 
                }
                if (now_j < 0) {
                 now_j = (now_j + 365) % 365; 
                }
  
                if (impacts_source == databaseNumber_CLIMATE_WY2) {
                    Pa = CLIMATE_WY2[now_i][now_j][_winddir][now_k]; 
                    Pb = CLIMATE_WY2[now_i][now_j][_windspd][now_k]; 
                    Pc = CLIMATE_WY2[now_i][now_j][_drybulb][now_k];
                }
                if (impacts_source == databaseNumber_ENSEMBLE) {
                    Pa = ENSEMBLE[now_i][now_j][_winddir][now_k]; 
                    Pb = ENSEMBLE[now_i][now_j][_windspd][now_k]; 
                    Pc = ENSEMBLE[now_i][now_j][_drybulb][now_k];
                }            
                if (impacts_source == databaseNumber_OBSERVED) {
                    Pa = OBSERVED[now_i][now_j][_winddir][now_k]; 
                    Pb = OBSERVED[now_i][now_j][_windspd][now_k]; 
                    Pc = OBSERVED[now_i][now_j][_drybulb][now_k];
                }   
                if (impacts_source == databaseNumber_CLIMATE_EPW) {
                    Pa = CLIMATE_EPW[now_i][now_j][_winddir][now_k]; 
                    Pb = CLIMATE_EPW[now_i][now_j][_windspd][now_k]; 
                    Pc = CLIMATE_EPW[now_i][now_j][_drybulb][now_k];
                }   
                
                if (Pa > 0.9 * FLOAT_undefined || Pb > 0.9 * FLOAT_undefined || Pc > 0.9 * FLOAT_undefined) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                }
                else {
                  int drw_count = 0;
                  if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                      
                  if ((impacts_source == databaseNumber_ENSEMBLE) && (ENSEMBLE_Flag[now_i][now_j][_winddir][now_k] != 1)) drw_count = 0;
                    
                  if (drw_count == 1) {
  
                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;
              
                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (STUDY_V_scale[_windspd] / 2.0) * (_values_w_spd[k] / 50.0);
                    
                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 
               
                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));
         
                    float _u = 0;
         
                    if (Impact_TYPE == Impact_SPD_DIR) {
  
                      float _s = (STUDY_O_scale / 100) * 255 / (0.333 * layers_count); 
  
                      if (sky_scenario > 1) _s *= 3; // to improve visibility of those cases.
                      
                      _s /= float(num_add_days);
                      
                      if (_s < 10) _s = 10;
                      
                      WIND_Diagrams.stroke(0, _s);
                      WIND_Diagrams.fill(0, _s); 
  
                      WIND_Diagrams.strokeWeight(STUDY_T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_SPD_DIR_TMP) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);
                      
                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;
                      
                      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
                      
                      WIND_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
                      
                      WIND_Diagrams.strokeWeight(STUDY_T_scale * 2);
                      WIND_Diagrams.noFill(); 
                    }
                    
                    WIND_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    
                  }
                }
              }
            }
          }
        }
      }
      WIND_Diagrams.endDraw();
      WindRose_Image[j + 1] = WIND_Diagrams;      
    }

    
 

    PGraphics total_WIND_Diagrams = createGraphics(RES, RES); 
    total_WIND_Diagrams.beginDraw();
    //total_WIND_Diagrams.background(255);
    total_WIND_Diagrams.translate(0.5 * RES, 0.5 * RES);

    for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
      for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {    
        for (int i = 0; i < 24; i += 1) {
          if (isInHourlyRange(i) == 1) {
          
            for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
    
              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;
             
              int _plot = 1;
              
              if (_plot == 1) {
                
                int now_k = k;
                int now_i = i;
                int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
    
                if (now_j >= 365) {
                 now_j = now_j % 365; 
                }
                if (now_j < 0) {
                 now_j = (now_j + 365) % 365; 
                }
  
                if (impacts_source == databaseNumber_CLIMATE_WY2) {
                    Pa = CLIMATE_WY2[now_i][now_j][_winddir][now_k]; 
                    Pb = CLIMATE_WY2[now_i][now_j][_windspd][now_k]; 
                    Pc = CLIMATE_WY2[now_i][now_j][_drybulb][now_k];
                }
                if (impacts_source == databaseNumber_ENSEMBLE) {
                    Pa = ENSEMBLE[now_i][now_j][_winddir][now_k]; 
                    Pb = ENSEMBLE[now_i][now_j][_windspd][now_k]; 
                    Pc = ENSEMBLE[now_i][now_j][_drybulb][now_k];
                }            
                if (impacts_source == databaseNumber_OBSERVED) {
                    Pa = OBSERVED[now_i][now_j][_winddir][now_k]; 
                    Pb = OBSERVED[now_i][now_j][_windspd][now_k]; 
                    Pc = OBSERVED[now_i][now_j][_drybulb][now_k];
                }   
                if (impacts_source == databaseNumber_CLIMATE_EPW) {
                    Pa = CLIMATE_EPW[now_i][now_j][_winddir][now_k]; 
                    Pb = CLIMATE_EPW[now_i][now_j][_windspd][now_k]; 
                    Pc = CLIMATE_EPW[now_i][now_j][_drybulb][now_k];
                }   
                
                if (Pa > 0.9 * FLOAT_undefined || Pb > 0.9 * FLOAT_undefined || Pc > 0.9 * FLOAT_undefined) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                }
                else {
                  int drw_count = 0;
                  if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                  if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                      
                  if ((impacts_source == databaseNumber_ENSEMBLE) && (ENSEMBLE_Flag[now_i][now_j][_winddir][now_k] != 1)) drw_count = 0;
                    
                  if (drw_count == 1) {
  
                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;
            
                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (STUDY_V_scale[_windspd] / 2.0) * (_values_w_spd[k] / 50.0);
                    
                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 
               
                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));
                  
                    float _u = 0;
         
                    if (Impact_TYPE == Impact_SPD_DIR) {
  
                      float _s = (STUDY_O_scale / 100) * 255 / (0.333 * layers_count) / (STUDY_j_end - STUDY_j_start);
  
                      if (sky_scenario > 1) _s *= 3; // to improve visibility of those cases.
                      
                      _s /= float(num_add_days);
                      
                      if (_s < 10) _s = 10;
                      
                      total_WIND_Diagrams.stroke(0, _s);
                      total_WIND_Diagrams.fill(0, _s); 
  
                      total_WIND_Diagrams.strokeWeight(STUDY_T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_SPD_DIR_TMP) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);
                      
                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;
                      
                      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
                      total_WIND_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
                      
                      total_WIND_Diagrams.strokeWeight(STUDY_T_scale * 2);
                      total_WIND_Diagrams.noFill(); 
                    }
                    
                    total_WIND_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);

                  }
                }
              }
            }
          }
        }
      }
    }
    total_WIND_Diagrams.endDraw();
    WindRose_Image[0] = total_WIND_Diagrams;          

    for (int j = STUDY_j_start - 1; j < STUDY_j_end; j += 1) {
      if ((j != -1) || (draw_impact_summary == 1)) {
        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
        STUDY_Diagrams.stroke(223);
        STUDY_Diagrams.fill(223); 
        STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
      
        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.noFill(); 
        STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
  
        STUDY_Diagrams.imageMode(CENTER); 
        STUDY_Diagrams.image(WindRose_Image[j + 1], (j + 100 * obj_scale) * sx_Plot, 0, int((180 * obj_scale) * sx_Plot), int((180 * obj_scale) * sx_Plot));
      }
    }   
    
    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
    
    if (draw_impact_summary == 1) {
      int j = -1; // << to put the summary graph before the daily graphs
      
      int keep_STUDY_j_start = STUDY_j_start;
      int keep_STUDY_j_end = STUDY_j_end;
      STUDY_j_start = j;
      STUDY_j_end = j + 1;
      SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
      STUDY_j_start = keep_STUDY_j_start;
      STUDY_j_end = keep_STUDY_j_end;

      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.noFill(); 
      STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);      
    }

    if (Impact_TYPE != Impact_SPD_DIR) { 
      
      float pal_length = 400;
      for (int q = 0; q < 11; q += 1) {
        float _u = 0;
      
        if (Impact_TYPE == Impact_SPD_DIR_TMP) _u = 0.1 * q;
        
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;
        
        float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
        STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
        STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);         
        
        STUDY_Diagrams.strokeWeight(0);
        STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

        if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
          STUDY_Diagrams.stroke(127);
          STUDY_Diagrams.fill(127);
          STUDY_Diagrams.strokeWeight(0);
        }
        else {
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.fill(255);
          STUDY_Diagrams.strokeWeight(2);
        }  

        STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
        STUDY_Diagrams.textAlign(CENTER, CENTER);

        if (Impact_TYPE == Impact_SPD_DIR_TMP) STUDY_Diagrams.text(nf(0.2 * (q - 5) / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      }
    }         


    if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start - 1) + "-" + String.valueOf(end_z + CLIMATE_WY2_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (impacts_source == databaseNumber_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_SPD_DIR) {  
        STUDY_Diagrams.text(("Wind direction and speed"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_SPD_DIR_TMP) {  
        STUDY_Diagrams.text(("Wind direction and speed with air temperature"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }           
    }
    
    if (Display_WindRose_Image != 0) WIN3D_Update = 1;
  } 




  
  if ((plot_impacts == 0) || (plot_impacts == 1)) {

    if (update_impacts == 1)  {

      SOLARCHVISION_calculate_SolarImpact_CurrentSection();
      
      int RES1 = SolarImpact_RES1;
      int RES2 = SolarImpact_RES2;
  
      if (plot_impacts == 0) Impact_TYPE = Impact_ACTIVE; 
      if (plot_impacts == 1) Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;
      
      float _values_R_dir;
      float _values_R_dif;
      
      float _values_E_dir;
      float _values_E_dif;
      
      int now_k = 0;
      int now_i = 0;
      int now_j = 0;
  
      int PAL_TYPE = 0; 
      int PAL_DIR = 1;
      float PAL_Multiplier = 1; 
      
      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
        PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
        PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT; 
      }        
  
      for (int p = 0; p < 1; p += 1) { 
        int l = impact_layer;

        for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {
 
          now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
      
          if (now_j >= 365) {
           now_j = now_j % 365; 
          }
          if (now_j < 0) {
           now_j = (now_j + 365) % 365; 
          }
   
         
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
          STUDY_Diagrams.stroke(223);
          STUDY_Diagrams.fill(223); 
          STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
        
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.noFill(); 
          STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
    
          STUDY_Diagrams.imageMode(CENTER); 
          STUDY_Diagrams.image(SolarImpact_Image[j + 1], (j + 100 * obj_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY_U_scale), int((180 * obj_scale) * sx_Plot), int((180 * obj_scale) * sx_Plot));

          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.fill(0);
          STUDY_Diagrams.textAlign(CENTER, CENTER); 
          STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
          
          String scenario_text = "";
          //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
          //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);
          
        }
        
        //----------------------
        if (camera_variation == 0) draw_impact_summary = 1; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        //----------------------
        
        if (draw_impact_summary == 1) { 
          int j = -1; // << to put the summary graph before the daily graphs
  
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
          STUDY_Diagrams.stroke(223);
          STUDY_Diagrams.fill(223); 
          //STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
          
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.noFill(); 
          //STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);
          
          STUDY_Diagrams.imageMode(CENTER); 
          //STUDY_Diagrams.image(SolarImpact_Image[j + 1], (j + 100 * obj_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY_U_scale), int((180 * obj_scale) * sx_Plot), int((180 * obj_scale) * sx_Plot));
          
          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.fill(0);
          STUDY_Diagrams.textAlign(CENTER, CENTER); 
          STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        }
        
        String scenario_text = "";
        //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
        //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY_Diagrams.text(scenario_text, ((STUDY_j_start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);
  
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, CENTER); 
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(0); 
  
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, CENTER); 
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(0); 
        
        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY_Diagrams.text(N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY_Diagrams.text(N_Title[reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
        }            
        //?? French
      }

      float pal_length = 400;
      for (int q = 0; q < 11; q += 1) {
        float _u = 0;
        
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) {
          _u = 0.2 * q - 0.5;
          _u = (_u - 0.5) * 0.75 + 0.5;
        }        
        
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;
        
        float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
        STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
        STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);         
        
        STUDY_Diagrams.strokeWeight(0);
        STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 
  
        if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
          STUDY_Diagrams.stroke(127);
          STUDY_Diagrams.fill(127);
          STUDY_Diagrams.strokeWeight(0);
        }
        else {
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.fill(255);
          STUDY_Diagrams.strokeWeight(2);
        }  
                    
        STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
        if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
        if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      }
  
      if (STUDY_print_title != 0) {
      
        STUDY_Diagrams.stroke(0); 
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
        
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, TOP); 
        //if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start - 1) + "-" + String.valueOf(end_z + CLIMATE_WY2_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //if (impacts_source == databaseNumber_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
  
        String Model_Description = "";
        //if (camera_variation == 1) Model_Description = "TR: Place-des-Arts";
        //if (camera_variation == 2) Model_Description = "EV_BUILDING";
  
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY_Diagrams.text((Model_Description + "Analysis of Active Potentials (kW/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY_Diagrams.text((Model_Description + "Analysis of Passive Potentials (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
          //?? French
        }    
  
      }

    }

    if (Display_SolarImpact_Image != 0) WIN3D_Update = 1;
  }





  if ((plot_impacts == 2) || (plot_impacts == 3)) {
    
    if (rebuild_SolarProjection_array != 0) {
      SOLARCHVISION_build_SolarProjection_array();
    }
    
    if (plot_impacts == 2) Impact_TYPE = Impact_ACTIVE; 
    if (plot_impacts == 3) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;
    
    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             
    
    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT; 

    //for (int p = 0; p < 3; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(impact_layer / 3) + p;
      
    for (int p = 0; p < 1; p += 1) { 
      int l = impact_layer;
   
    //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + 1; //impact_layer;    

      float[][] TOTAL_valuesSUM_RAD = new float [1 + int(90 / stp_slp)][1 + int(360 / stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(90 / stp_slp)][1 + int(360 / stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(90 / stp_slp)][1 + int(360 / stp_dir)];
      int[][] TOTAL_valuesNUM = new int [1 + int(90 / stp_slp)][1 + int(360 / stp_dir)];

      for (int a = 0; a <= int(90 / stp_slp); a += 1) { 
        for (int b = 0; b < int(360 / stp_dir); b += 1) {
          TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
          TOTAL_valuesNUM[a][b] = 0;
        }
      }
      
      for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {

        now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
    
        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
 
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / num_add_days);
            int j_ADD = nk % num_add_days; 

            for (int a = 0; a <= int(90 / stp_slp); a += 1) { 
              float Alpha = a * stp_slp;
              for (int b = 0; b < int(360 / stp_dir); b += 1) {
                float Beta = b * stp_dir;
                
                float _valuesSUM_RAD = 0;
                float _valuesSUM_EFF_P = 0;
                float _valuesSUM_EFF_N = 0;
                int _valuesNUM = 0; 


                for (int i = 0; i < 24; i += 1) {
                  if (isInHourlyRange(i) == 1) {              
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
  
                    if (SunR[3] > 0) {
    
                      now_k = k;
                      now_i = i;
                      now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
    
                      if (now_j >= 365) {
                       now_j = now_j % 365; 
                      }
                      if (now_j < 0) {
                       now_j = (now_j + 365) % 365; 
                      }
    
                      if (impacts_source == databaseNumber_CLIMATE_WY2) {
                          Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
                          Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
                          Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
                          Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
                      }
                      if (impacts_source == databaseNumber_ENSEMBLE) {
                          Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
                          Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
                          Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
                          Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
                      }            
                      if (impacts_source == databaseNumber_OBSERVED) {
                          Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
                          Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
                          Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
                          Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
                      }   
                      if (impacts_source == databaseNumber_CLIMATE_EPW) {
                          Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
                          Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
                          Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
                          Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
                      }       
          
                      if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                        _values_R_dir = FLOAT_undefined;
                        _values_R_dif = FLOAT_undefined;
                        _values_E_dir = FLOAT_undefined;
                        _values_E_dif = FLOAT_undefined;
                      }
                      else {
      
                        int drw_count = 0;
                        if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                        if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                        if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                        if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                        
                        if (drw_count == 1) {
                          _values_R_dir = 0.001 * Pa;
                          _values_R_dif = 0.001 * Pb;
                          _values_E_dir = 0.001 * Pc;
                          _values_E_dif = 0.001 * Pd;
                          
                          if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                            _valuesSUM_RAD = 0;
                            _valuesSUM_EFF_P = 0;
                            _valuesSUM_EFF_N = 0;
                            _valuesNUM = 0; 
                          }                             
                          else {
  
                            if (_values_E_dir < 0) {
                              _valuesSUM_EFF_N += -SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo); 
                            }
                            else {
                              _valuesSUM_EFF_P += SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo); 
                            }
  
                            _valuesSUM_RAD += SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 
                            
                            _valuesNUM += 1;
                            
                          }
                        }
                      }
                    }
                  }
                }
                
      
                if (_valuesNUM != 0) {
                  //float _valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
                  //float _valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
                  float _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);

                  _valuesSUM_RAD *= _valuesMUL;
                  _valuesSUM_EFF_P *= _valuesMUL;
                  _valuesSUM_EFF_N *= _valuesMUL;
                  
                  if (TOTAL_valuesNUM[a][b] == 0) {
                    TOTAL_valuesSUM_RAD[a][b] = 0;
                    TOTAL_valuesSUM_EFF_P[a][b] = 0;
                    TOTAL_valuesSUM_EFF_N[a][b] = 0;
                  }

                  TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
                  TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
                  TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
                  TOTAL_valuesNUM[a][b] += 1;
                }
                else {
                  _valuesSUM_RAD = FLOAT_undefined;
                  _valuesSUM_EFF_P = FLOAT_undefined;
                  _valuesSUM_EFF_N = FLOAT_undefined;
                }


                float AVERAGE, PERCENTAGE, COMPARISON;
                
                AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
                if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

      
                float _valuesSUM = FLOAT_undefined;
                if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 
                
                //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> _valuesSUM_RAD:", _valuesSUM_RAD, "COMPARISON:", COMPARISON);  
                
                if (_valuesSUM < 0.9 * FLOAT_undefined) {
                
                  float _u = 0;
                  
                  if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
                  
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
                  
                  //float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
                  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, roundTo(_u, 0.1));
                  STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                  STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 
                  
                  
                  STUDY_Diagrams.strokeWeight(0);
                  
                  float x1 = (j + obj_offset_x + (90 - Alpha - 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
                  float y1 = (                  -(90 - Alpha - 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
                  float x2 = (j + obj_offset_x + (90 - Alpha + 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
                  float y2 = (                  -(90 - Alpha + 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot; 
          
                  float x3 = (j + obj_offset_x + (90 - Alpha + 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot;
                  float y3 = (                  -(90 - Alpha + 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot; 
                  float x4 = (j + obj_offset_x + (90 - Alpha - 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot;
                  float y4 = (                  -(90 - Alpha - 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot; 
          
                  STUDY_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4); 
                  
                }
              }
            }

            STUDY_Diagrams.stroke(0);
            STUDY_Diagrams.fill(0);
            STUDY_Diagrams.textAlign(CENTER, CENTER); 
            STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
            
            String scenario_text = "";
            //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
            //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY_U_scale);
          }
        }
      }
      
      
  
      if (draw_impact_summary == 1) { 

        int j = -1; // << to put the summary graph before the daily graphs

        for (int a = 0; a <= int(90 / stp_slp); a += 1) { 
          float Alpha = a * stp_slp;
          for (int b = 0; b < int(360 / stp_dir); b += 1) {
            float Beta = b * stp_dir;

            if (TOTAL_valuesNUM[a][b] != 0) {
              TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
            }
            else {
              TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
            }
      
      
            float AVERAGE, PERCENTAGE, COMPARISON;
            
            AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
            if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
      
      
            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD[a][b];
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 
            
            //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> (TOTAL) _valuesSUM_RAD:", TOTAL_valuesSUM_RAD[a][b], "COMPARISON:", COMPARISON);  
            
            if (_valuesSUM < 0.9 * FLOAT_undefined) {
            
              float _u = 0;

              if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
              if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
              
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;
              
              //float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
              float[] _COL = GET_COLOR_STYLE(PAL_TYPE, roundTo(_u, 0.1));
              STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
              STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);               
              
              STUDY_Diagrams.strokeWeight(0);
              
              float x1 = (j + obj_offset_x + (90 - Alpha - 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
              float y1 = (                  -(90 - Alpha - 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
              float x2 = (j + obj_offset_x + (90 - Alpha + 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot;
              float y2 = (                  -(90 - Alpha + 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 - 0.5 * stp_dir))) * sx_Plot; 
      
              float x3 = (j + obj_offset_x + (90 - Alpha + 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot;
              float y3 = (                  -(90 - Alpha + 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot; 
              float x4 = (j + obj_offset_x + (90 - Alpha - 0.5 * stp_slp) * obj_scale * (cos_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot;
              float y4 = (                  -(90 - Alpha - 0.5 * stp_slp) * obj_scale * (sin_ang(Beta - 90 + 0.5 * stp_dir))) * sx_Plot; 
      
              STUDY_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4); 
              
            }
          }
        }

        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.noFill(); 
        STUDY_Diagrams.rect((j + obj_offset_x - 100 * obj_scale) * sx_Plot, (-100 * obj_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * obj_scale) * sx_Plot, (200 * obj_scale) * sx_Plot);

        
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.textAlign(CENTER, CENTER); 
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        
        String scenario_text = "";
        //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
        //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY_U_scale);

        int keep_STUDY_j_start = STUDY_j_start;
        int keep_STUDY_j_end = STUDY_j_end;
        STUDY_j_start = j;
        STUDY_j_end = j + 1;
        SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
        STUDY_j_start = keep_STUDY_j_start;
        STUDY_j_end = keep_STUDY_j_end;
      }


      String scenario_text = "";
      //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
      //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(N_Title[reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French        
    }
    
    float pal_length = 400;
    for (int q = 0; q < 11; q += 1) {
      float _u = 0;
      
      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) {
        _u = 0.2 * q - 0.5;
        _u = (_u - 0.5) * 0.75 + 0.5;
      }        
      
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
      
      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
      STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);       
      
      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

      if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      }
      else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   
                  
      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
    }
    
    
    if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start - 1) + "-" + String.valueOf(end_z + CLIMATE_WY2_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (impacts_source == databaseNumber_ENSEMBLE) STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Solar radiation on hemisphere (kW/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Solar effects on hemisphere (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }  

    }

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0); 
  } 



  if ((plot_impacts == 4) || (plot_impacts == 5)) {
    if (plot_impacts == 4) Impact_TYPE = Impact_ACTIVE; 
    if (plot_impacts == 5) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;
   
    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

    //for (int p = 0; p < 3; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(impact_layer / 3) + p;
      
    for (int p = 0; p < 1; p += 1) { 
      int l = impact_layer;
      
    //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + 1; //impact_layer;    
 
      for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {

        now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
    
        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
 
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / num_add_days);
            int j_ADD = nk % num_add_days; 
            
            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i += 1) {
              if (isInHourlyRange(i) == 1) {
                if ((i > _sunrise) && (i < _sunset)) {
                  
                  float HOUR_ANGLE = i; 
                  float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
                  
                  float Alpha = 90 - acos_ang(SunR[3]);
                  float Beta = 180 - atan2_ang(SunR[1], SunR[2]);
  
                  now_k = k;
                  now_i = i;
                  now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
      
                  if (now_j >= 365) {
                   now_j = now_j % 365; 
                  }
                  if (now_j < 0) {
                   now_j = (now_j + 365) % 365; 
                  }
  
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                      Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
                  }
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                      Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
                      Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
                      Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
                  }            
                  if (impacts_source == databaseNumber_OBSERVED) {
                      Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
                      Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
                      Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
                  }   
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {
                      Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
                  }          
      
                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  }
                  else {
  
                    int drw_count = 0;
                    if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                      
                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;
                      
                      if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF = 0;
                        _valuesNUM = 0; 
                      }                             
                      else {
                        _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                        _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                        _valuesNUM = 1;
                      }
                    }
                  }
        
                  float _valuesSUM = FLOAT_undefined;
                  if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 
                  
                  if (_valuesSUM < 0.9 * FLOAT_undefined) {
                  
                    float _u = 0;
                    
                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (PAL_Multiplier * _valuesSUM);
                    
                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;
                    
                    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
                    STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                    STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);                     
                    
                    STUDY_Diagrams.strokeWeight(0);
                    
                    STUDY_Diagrams.ellipse((j + obj_offset_x + (90 - Alpha) * obj_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * obj_scale * (sin_ang(Beta - 90))) * sx_Plot, 0.075 * sx_Plot, 0.075 * sx_Plot);
  
                    if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
                      STUDY_Diagrams.stroke(127);
                      STUDY_Diagrams.fill(127);
                      STUDY_Diagrams.strokeWeight(0);
                    }
                    else {
                      STUDY_Diagrams.stroke(255);
                      STUDY_Diagrams.fill(255);
                      STUDY_Diagrams.strokeWeight(2);
                    }   
                    
                    STUDY_Diagrams.textSize(STUDY_S_View * 4.0 * STUDY_U_scale);
                    
                    STUDY_Diagrams.textAlign(CENTER, CENTER);
                    if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(_valuesSUM, 1, 1), (j + obj_offset_x + (90 - Alpha) * obj_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * obj_scale * (sin_ang(Beta - 90))) * sx_Plot);
                    if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(_valuesSUM), 1), (j + obj_offset_x + (90 - Alpha) * obj_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * obj_scale * (sin_ang(Beta - 90))) * sx_Plot);
      
                  }
                }
              }
            }
            
            STUDY_Diagrams.stroke(0);
            STUDY_Diagrams.fill(0);
            STUDY_Diagrams.textAlign(CENTER, CENTER); 
            STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
            
            String scenario_text = "";
            //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
            //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95  * sx_Plot / STUDY_U_scale);
            
          }
        }
      }
      
      String scenario_text = "";
      //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
      //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(N_Title[reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French
    }
    
    float pal_length = 400;
    for (int q = 0; q < 11; q += 1) {
      float _u = 0;
      
      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) {
        _u = 0.2 * q - 0.5;
        _u = (_u - 0.5) * 0.75 + 0.5;
      }        
      
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
      
      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
      STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);       
      
      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

      if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      }
      else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   
                  
      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
    } 
    
    
    if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start - 1) + "-" + String.valueOf(end_z + CLIMATE_WY2_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (impacts_source == databaseNumber_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Direct solar radiation (kWh/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Direct solar effects (kWh°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }  
    }   
  } 



  if ((plot_impacts == 6) || (plot_impacts == 7)) {
    if (plot_impacts == 6) Impact_TYPE = Impact_ACTIVE; 
    if (plot_impacts == 7) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;
   
    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

 
    for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {

      now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
  
      if (now_j >= 365) {
       now_j = now_j % 365; 
      }
      if (now_j < 0) {
       now_j = (now_j + 365) % 365; 
      }
 
      float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

      float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
      float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

      int[] Normals_COL_N;
      Normals_COL_N = new int [9];
      Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);
      
      for (int i = 0; i < 24; i += 1) {
      //for (int i = 10; i <= 14; i += 2) {
      //for (int i = 12; i <= 12; i += 2) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
        
        float Alpha = 90 - acos_ang(SunR[3]);
        float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

        now_i = i;
        now_j = int(j * per_day + BEGIN_DAY + 365) % 365;

        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }

        
        { // Direct 
          int RES1 = 50; // 100; 
          int RES2 = RES1;
          float ZOOM = 7200 / float(RES1); // ??? might not be correct!!!!
  
          PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-Alpha,0,Beta);

          STUDY_Diagrams.imageMode(CENTER); 
          STUDY_Diagrams.image(Image_RGBA, (j + obj_offset_x + (90 - Alpha) * obj_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * obj_scale * (sin_ang(Beta - 90))) * sx_Plot, RES1, RES2);

          if (Materials_DirectArea_Flag[now_i][now_j] == -1) {

            Materials_DirectArea_Flag[now_i][now_j] = 1; 

            for (int mt = 0; mt < Materials_Number; mt++) {                 
              Materials_DirectArea[mt][now_i][now_j] = 0;
            }   
              
            if ((i > _sunrise) && (i < _sunset)) {
                     
              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;
                
                color COL = Image_RGBA.get(Image_X, Image_Y);
  
                int COL_A = COL >> 24 & 0xFF;
                
                if (COL_A != 0) {
                  int COL_R = COL >> 16 & 0xFF; 
                  int COL_G = COL >> 8 & 0xFF; 
                  int COL_B = COL & 0xFF;
                  
                  for (int mt = 0; mt < Materials_Number; mt++) {  
                  
                    if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                      Materials_DirectArea[mt][now_i][now_j] += 1;
                    }
                  }
                }
              }  
  
              for (int mt = 0; mt < Materials_Number; mt++) {                 
                Materials_DirectArea[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2) ; //???
                
                if (Materials_Selection == mt) println("Direct:", mt, now_i, now_j, Materials_DirectArea[mt][now_i][now_j]); 
              }

              STUDY_Diagrams.imageMode(CORNER);              
            }
          }
        }
        
        /*

        { // Diffuse
          int RES1 = 25; // 100; 
          int RES2 = RES1;
          float ZOOM = 7200 / float(RES1); // ??? might not be correct!!!!

          if (Materials_DiffuseArea_Flag[now_i][now_j] == -1) {
            
            Materials_DiffuseArea_Flag[now_i][now_j] = 1; 
            
            for (int mt = 0; mt < Materials_Number; mt++) {                 
              Materials_DiffuseArea[mt][now_i][now_j] = 0;
            }                 
            
            int num_diffuse_views = 0;
          
            for (int vNo = 1; vNo < skyVertices.length; vNo++) {
              
              float skyAngle_Alpha = asin_ang(skyVertices[vNo][2]);
              float skyAngle_Beta = atan2_ang(skyVertices[vNo][1], skyVertices[vNo][0]) + 90;
                
              if (skyAngle_Alpha >= 0) {
                
                num_diffuse_views += 1;
    
                PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-skyAngle_Alpha,0,skyAngle_Beta);
      
                STUDY_Diagrams.imageMode(CENTER); 
                STUDY_Diagrams.image(Image_RGBA, (j + obj_offset_x + (90 - skyAngle_Alpha) * obj_scale * (cos_ang(skyAngle_Beta - 90))) * sx_Plot, -((90 - skyAngle_Alpha) * obj_scale * (sin_ang(skyAngle_Beta - 90))) * sx_Plot, RES1, RES2);
                       
                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;
                  
                  color COL = Image_RGBA.get(Image_X, Image_Y);
    
                  int COL_A = COL >> 24 & 0xFF;
                  
                  if (COL_A != 0) {
                    int COL_R = COL >> 16 & 0xFF; 
                    int COL_G = COL >> 8 & 0xFF; 
                    int COL_B = COL & 0xFF;
                    
                    for (int mt = 0; mt < Materials_Number; mt++) {  
                    
                      if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                        Materials_DiffuseArea[mt][now_i][now_j] += 1;
                      }
                    }
                  }
                }  
    
                STUDY_Diagrams.imageMode(CORNER);
              }
            }
            for (int mt = 0; mt < Materials_Number; mt++) {                 
              Materials_DiffuseArea[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2); //???
              Materials_DiffuseArea[mt][now_i][now_j] *= 2.0 / float(num_diffuse_views); // note: multiply by 2 to have a area equal to roof!
              
              if (Materials_Selection == mt) println("Diffuse:", mt, now_i, now_j, Materials_DiffuseArea[mt][now_i][now_j]); 
            }
            
            //---------------------------------------------
            // applying calculated diffuse model at this time for the rest of year.
            for (int mt = 0; mt < Materials_Number; mt++) {
              for (int loop_i = 0; loop_i < 24; loop_i += 1) {
                for (int loop_j = 0; loop_j < 365; loop_j += 1) {
                  Materials_DiffuseArea[mt][loop_i][loop_j] = Materials_DiffuseArea[mt][now_i][now_j];
                  Materials_DiffuseArea_Flag[loop_i][loop_j] = 1;
                }
              }  
            }
            //---------------------------------------------                          
          }
        }
        
        */
        
      }
    }
    
    if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
  
      STUDY_Diagrams.text(("Solar perspectives"), 0, 1.4 * sx_Plot / STUDY_U_scale);
    }   
  } 


  if ((plot_impacts == 8) || (plot_impacts == 9)) {

    //for (int p = 0; p < 3; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(impact_layer / 3) + p;
      
    for (int p = 0; p < 1; p += 1) { 
      int l = impact_layer;
      
    //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(impact_layer / 3) + 1; //impact_layer;    
    
      int target_window = 1;
      SOLARCHVISION_draw_SunPathCycles(x_Plot, y_Plot - (1 * p * sx_Plot / STUDY_U_scale), z_Plot, sx_Plot, sy_Plot, sz_Plot, l, target_window);
      
      SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
      
      String scenario_text = "";
      //if (impacts_source == databaseNumber_CLIMATE_WY2) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_WY2_start - 1, 0);
      //if (impacts_source == databaseNumber_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(N_Title[reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French
    }    
    

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             
  
    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;
    
    float pal_length = 400;

    float pal_offsetY = 175;    
    if (STUDY_j_end == 2) {
      pal_offsetY = 325;
    }
    
    for (int q = 0; q < 11; q += 1) {
      float _u = 0;
      
      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) {
        _u = 0.2 * q - 0.5;
        _u = (_u - 0.5) * 0.75 + 0.5;
      }        
      
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
      
      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
      STUDY_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);       
      
      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -pal_offsetY * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View);

      if (_COL[1] + _COL[2] + _COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      }
      else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   
                  
      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY_S_View);
    } 
    
    
    if (STUDY_print_title != 0) {
    
      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (impacts_source == databaseNumber_CLIMATE_WY2) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_WY2_start - 1) + "-" + String.valueOf(end_z + CLIMATE_WY2_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (impacts_source == databaseNumber_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(CENTER, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Direct solar radiation (kWh/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY_S_View + (pal_length / 11.0) * STUDY_S_View, -pal_offsetY * STUDY_S_View + 20 * STUDY_S_View);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Direct solar effects (kWh°C/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY_S_View + (pal_length / 11.0) * STUDY_S_View, -pal_offsetY * STUDY_S_View + 20 * STUDY_S_View);
        //?? French
      }  
    }   

    
  } 





  if ((plot_impacts == 8) || (plot_impacts == 9)) {
    
  }
  else {
    SOLARCHVISION_draw_Grid_DAILY(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  }

  keep_per_day = per_day;
  num_add_days = keep_num_add_days;


  STUDY_Diagrams.popMatrix();
} 



void SOLARCHVISION_draw_SunPathCycles (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int l, int target_window) {

  // target_window1: 1:STUDY, 2:WORLD, 3:WIN3D 4:OBJ-export

  int start_z = get_startZ_endZ(impacts_source)[0];
  int end_z = get_startZ_endZ(impacts_source)[1]; 
  int layers_count = get_startZ_endZ(impacts_source)[2]; 

  
  
  int TES_hour = 1; //4; // 1 = every 1 hour, 4 = every 15 minutes

  //if (plot_impacts == 8) 
  Impact_TYPE = Impact_ACTIVE; 
  if (plot_impacts == 9) Impact_TYPE = Impact_PASSIVE;

  float Pa1 = FLOAT_undefined;
  float Pb1 = FLOAT_undefined;
  float Pc1 = FLOAT_undefined;
  float Pd1 = FLOAT_undefined;

  float Pa2 = FLOAT_undefined;
  float Pb2 = FLOAT_undefined;
  float Pc2 = FLOAT_undefined;
  float Pd2 = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;
 
  int now_k = 0;
  int now_i1 = 0;
  int now_i2 = 0;
  int now_j = 0;

  int PAL_TYPE = 0; 
  int PAL_DIR = 1;

  if (target_window == 3) {
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath3D_Pallet_ACTIVE_CLR; PAL_DIR = SunPath3D_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath3D_Pallet_PASSIVE_CLR; PAL_DIR = SunPath3D_Pallet_PASSIVE_DIR;
    }
  }
  else {
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }
  }  

  float PAL_Multiplier = 1; 
  if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
  if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;



  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {
    
    if (target_window == 3) {
      println("j", j); 
    }
    
    float[][][] SunPathMesh = new float [24 * TES_hour][1 + int(per_day / num_add_days)][3];        
 
    for (int more_J = 0; more_J < per_day; more_J += num_add_days) {
      
      now_j = (more_J + j * int(per_day) + BEGIN_DAY + 365) % 365;
  
      if (now_j >= 365) {
       now_j = now_j % 365; 
      }
      if (now_j < 0) {
       now_j = (now_j + 365) % 365; 
      }
 
      float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

      float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
      float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

      int[] Normals_COL_N;
      Normals_COL_N = new int [9];
      {
        int keep_filter_type = filter_type;
        filter_type = _hourly;
        
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, more_J + j, DATE_ANGLE);
        
        filter_type = keep_filter_type;
      }

      for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
        if (nk != -1) {
          int k = int(nk / num_add_days);
          int j_ADD = nk % num_add_days; 
          
          float _valuesSUM_RAD = 0;
          float _valuesSUM_EFF = 0;
          int _valuesNUM = 0; 
          
          for (float i = 0; i < 24; i += 1.0 / float(TES_hour)) {
              
            float HOUR_ANGLE = i; 
            float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
            
            float Alpha = 90 - acos_ang(SunR[3]);
            float Beta = 180 - atan2_ang(SunR[1], SunR[2]);
            
            //-------------- to extend graph to the horizon ---------------
            if (Alpha < 0) {              
              
              if (SunR[1] > 0) { 
                float[] SunR_rise = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, _sunrise);

                Alpha = 0;
                Beta = 180 - atan2_ang(SunR_rise[1], SunR_rise[2]);   
              }
              else {
                float[] SunR_set = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, _sunset);

                Alpha = 0;
                Beta = 180 - atan2_ang(SunR_set[1], SunR_set[2]);   
              } 
            }
            //-----------------------------------------------------------

            now_k = k;
            
            now_i1 = floor(i);
            now_i2 = (1 + now_i1) % 24;
            float i_ratio = i - now_i1; 
            
            now_j = int(more_J + j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;

            if (now_j >= 365) {
             now_j = now_j % 365; 
            }
            if (now_j < 0) {
             now_j = (now_j + 365) % 365; 
            }

            if (impacts_source == databaseNumber_CLIMATE_WY2) {
                Pa1 = CLIMATE_WY2[now_i1][now_j][_dirnorrad][now_k]; 
                Pb1 = CLIMATE_WY2[now_i1][now_j][_difhorrad][now_k]; 
                Pc1 = CLIMATE_WY2[now_i1][now_j][_direffect][now_k]; 
                Pd1 = CLIMATE_WY2[now_i1][now_j][_difeffect][now_k]; 
                
                Pa2 = CLIMATE_WY2[now_i2][now_j][_dirnorrad][now_k]; 
                Pb2 = CLIMATE_WY2[now_i2][now_j][_difhorrad][now_k]; 
                Pc2 = CLIMATE_WY2[now_i2][now_j][_direffect][now_k]; 
                Pd2 = CLIMATE_WY2[now_i2][now_j][_difeffect][now_k];                     
            }
            if (impacts_source == databaseNumber_ENSEMBLE) {
                Pa1 = ENSEMBLE[now_i1][now_j][_dirnorrad][now_k]; 
                Pb1 = ENSEMBLE[now_i1][now_j][_difhorrad][now_k]; 
                Pc1 = ENSEMBLE[now_i1][now_j][_direffect][now_k]; 
                Pd1 = ENSEMBLE[now_i1][now_j][_difeffect][now_k]; 
                
                Pa2 = ENSEMBLE[now_i2][now_j][_dirnorrad][now_k]; 
                Pb2 = ENSEMBLE[now_i2][now_j][_difhorrad][now_k]; 
                Pc2 = ENSEMBLE[now_i2][now_j][_direffect][now_k]; 
                Pd2 = ENSEMBLE[now_i2][now_j][_difeffect][now_k];                     
            }            
            if (impacts_source == databaseNumber_OBSERVED) {
                Pa1 = OBSERVED[now_i1][now_j][_dirnorrad][now_k]; 
                Pb1 = OBSERVED[now_i1][now_j][_difhorrad][now_k]; 
                Pc1 = OBSERVED[now_i1][now_j][_direffect][now_k]; 
                Pd1 = OBSERVED[now_i1][now_j][_difeffect][now_k]; 
                
                Pa2 = OBSERVED[now_i2][now_j][_dirnorrad][now_k]; 
                Pb2 = OBSERVED[now_i2][now_j][_difhorrad][now_k]; 
                Pc2 = OBSERVED[now_i2][now_j][_direffect][now_k]; 
                Pd2 = OBSERVED[now_i2][now_j][_difeffect][now_k];                     
            }   
            if (impacts_source == databaseNumber_CLIMATE_EPW) {
                Pa1 = CLIMATE_EPW[now_i1][now_j][_dirnorrad][now_k]; 
                Pb1 = CLIMATE_EPW[now_i1][now_j][_difhorrad][now_k]; 
                Pc1 = CLIMATE_EPW[now_i1][now_j][_direffect][now_k]; 
                Pd1 = CLIMATE_EPW[now_i1][now_j][_difeffect][now_k]; 
                
                Pa2 = CLIMATE_EPW[now_i2][now_j][_dirnorrad][now_k]; 
                Pb2 = CLIMATE_EPW[now_i2][now_j][_difhorrad][now_k]; 
                Pc2 = CLIMATE_EPW[now_i2][now_j][_direffect][now_k]; 
                Pd2 = CLIMATE_EPW[now_i2][now_j][_difeffect][now_k];                     
            }          

            if ((Pa1 > 0.9 * FLOAT_undefined) || (Pb1 > 0.9 * FLOAT_undefined) || (Pc1 > 0.9 * FLOAT_undefined) || (Pd1 > 0.9 * FLOAT_undefined)
             || (Pa2 > 0.9 * FLOAT_undefined) || (Pb2 > 0.9 * FLOAT_undefined) || (Pc2 > 0.9 * FLOAT_undefined) || (Pd2 > 0.9 * FLOAT_undefined)) {
              _values_R_dir = FLOAT_undefined;
              _values_R_dif = FLOAT_undefined;
              _values_E_dir = FLOAT_undefined;
              _values_E_dif = FLOAT_undefined;
            }
            else {

              int drw_count = 0;
              if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i1, now_j, now_k);
              if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i1, now_j, now_k);
              if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i1, now_j, now_k);
              if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i1, now_j, now_k);
                
              if (drw_count == 1) {
                _values_R_dir = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                _values_R_dif = 0.001 * (Pb1 * (1 - i_ratio) + Pb2 * i_ratio);
                _values_E_dir = 0.001 * (Pc1 * (1 - i_ratio) + Pc2 * i_ratio);
                _values_E_dif = 0.001 * (Pd1 * (1 - i_ratio) + Pd2 * i_ratio);
                
                if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                  _valuesSUM_RAD = 0;
                  _valuesSUM_EFF = 0;
                  _valuesNUM = 0; 
                }                             
                else {
                  _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                  _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                  _valuesNUM = 1;
                }
              }
            }
  
            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 
            
            int row_J = more_J / num_add_days;

            SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
            SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
            SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;

          }
        }
        else {
          for (float i = 0; i < 24; i += 1.0 / float(TES_hour)) {
            
            float _valuesSUM = FLOAT_undefined; 
              
            float HOUR_ANGLE = i; 
            float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
            
            float Alpha = 90 - acos_ang(SunR[3]);
            float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

            int row_J = more_J / num_add_days;

            SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
            SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
            SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;       
          }
        }            
      }
    }
  
    int Number_Of_Face_Subdivisions = (24 * TES_hour) * (1 + int(per_day / num_add_days)); // for combined materials we need to know this number before baking each object.

    if (target_window == 4) {

      String the_filename = "";
      String TEXTURE_path = "";


      PGraphics[] Face_Texture = new PGraphics [1 + Number_Of_Face_Subdivisions];
      
      num_vertices_added = 0;
      
      if (objExportMaterialLibrary != 0) {

        the_filename = "sunPattern_Pallet.bmp";

        TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
          
        TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
          
        println("Saving texture:", TEXTURE_path);
        
        int RES1 = 256; // adding two pixels to left and right as margin
        int RES2 = 2;      
    
        PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       
     
     
        Pallet_Texture.loadPixels();
            
        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;
          
          float _val = (Image_X / (0.5 * RES1)) - 1; 
          
          float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;        
        
          float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);  
          
          Pallet_Texture.pixels[np] = color(_COL[1], _COL[2], _COL[3], _COL[0]);        
        }
        
        Pallet_Texture.updatePixels();   
     
        Pallet_Texture.save(TEXTURE_path);      
  
      
        mtlOutput.println("newmtl " + "sunPattern");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
  
        //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map  

        objOutput.println("usemtl " +  the_filename.replace('.', '_'));

      }    
      
      obj_lastGroupNumber += 1;
      objOutput.println("g SunPattern");      
    }  

    int end_turn = 1;
    if (target_window == 4) end_turn = 3;
    for (int _turn = 1; _turn <= end_turn; _turn += 1) {

      
      for (int more_J = 0; more_J < per_day - num_add_days; more_J += num_add_days) { //count one less!
  
        now_j = (more_J + j * int(per_day) + BEGIN_DAY + 365) % 365;
    
        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
   
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);
  
        for (float i = 0; i < 24; i += 1.0 / float(TES_hour)) {  
          if (isInHourlyRange(i) == 1) {
            if ((i > _sunrise - 1.0 / float(TES_hour)) && (i < _sunset + 1.0 / float(TES_hour))) {              

              if (target_window == 4) {
               
              }             
              else if (target_window == 3) {
                WIN3D_Diagrams.beginShape();
                WIN3D_Diagrams.noStroke();
              }               
              else if (target_window == 2) {
                WORLD_Diagrams.beginShape();
                WORLD_Diagrams.noStroke();
              }
              else if (target_window == 1) {
                STUDY_Diagrams.beginShape();
                STUDY_Diagrams.noStroke();
              }  
              
              for (int s = 0; s < 4; s += 1) {
                
                int a = int(i * TES_hour);
                int b = more_J / num_add_days;
                
                if ((s == 1) || (s == 2)) {
                  a += 1;
                }
      
                if ((s == 2) || (s == 3)) {
                  b += 1;
                }
                
                if (a > (24 * TES_hour - 1)) a = a % (24 * TES_hour);
  
                float Alpha = SunPathMesh[a][b][0];
                float Beta = SunPathMesh[a][b][1];
                float _valuesSUM = SunPathMesh[a][b][2];
  
                if (Alpha >= 0) {
      
                  if (_valuesSUM < 0.9 * FLOAT_undefined) {
                  
                    float _u = 0;
                    
                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (PAL_Multiplier * _valuesSUM);
                    
                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;
                    
                    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
  
                    float r = sx_Plot;
  
                    if (target_window == 4) {
                      
                    }
                    else if (target_window == 3) {
                      WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], 127);
                      
                      float x = cos_ang(Alpha) * (cos_ang(Beta - 90)) * WIN3D_scale3D * r + x_Plot;
                      float y = cos_ang(Alpha) * (sin_ang(Beta - 90)) * WIN3D_scale3D * r + y_Plot;
                      float z = sin_ang(Alpha) * WIN3D_scale3D * sz_Plot + z_Plot;
                      
                      WIN3D_Diagrams.vertex(x, -y, z);
                    }
                    else if (target_window == 2) {
                      // ??????????????????????????
                    }                  
                    else if (target_window == 1) {
      
                      STUDY_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                      
                      float x = (90 - Alpha) * (cos_ang(Beta - 90)) * obj_scale * r + x_Plot * obj_scale;
                      float y = (90 - Alpha) * (sin_ang(Beta - 90)) * obj_scale * r + y_Plot * obj_scale;
                      
                      float ox = (j + obj_offset_x) * sx_Plot;
                      
                      STUDY_Diagrams.vertex(ox + x, -y);
                    }
  
                  }
                }
              }
              
              if (target_window == 4) {
                
              }
              else if (target_window == 3) {
                WIN3D_Diagrams.endShape(CLOSE);
              }  
              else if (target_window == 2) {
                WORLD_Diagrams.endShape(CLOSE);
              }
              else if (target_window == 1) {
                STUDY_Diagrams.endShape(CLOSE);              
              }            
            }
          }
        }
  
      }
      
    }

    
    
      
    if (target_window == 3) {
      WIN3D_Diagrams.strokeWeight(1);
      WIN3D_Diagrams.stroke(127);
    }
    else if (target_window == 2) {
      WORLD_Diagrams.strokeWeight(1);
      WORLD_Diagrams.stroke(127);
    }
    else if (target_window == 1) {
      STUDY_Diagrams.strokeWeight(1);
      STUDY_Diagrams.stroke(127);
    }  
    
    int max_j_to_draw_grid = STUDY_j_end;
    if (target_window == 3) {
      max_j_to_draw_grid = 1; // draw it just once!
    }
    if (j < max_j_to_draw_grid) {
      
      
      float s_SunPath = sx_Plot;
      
    
      for (int myDATE = 90; myDATE <= 270; myDATE += 30) {
        
        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, myDATE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, myDATE);        
        
        float myHOUR_step = 1.0 / float(TES_hour);
        
        for (float myHOUR = 0; myHOUR < 24; myHOUR += myHOUR_step) {


          
          float HourA = myHOUR;
          float HourB = myHOUR + myHOUR_step;

          float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, HourA);
          float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, HourB);
          
          if ((SunA[3] < 0) && (SunB[3] > 0)) {
            SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, _sunrise);
            SunA[3] = 0;
          }
          if ((SunA[3] > 0) && (SunB[3] < 0)) {
            SunB = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, _sunset);
            SunB[3] = 0;
          }


          
          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == 3) {
            
              float x1 = SunA[1] * WIN3D_scale3D * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D_scale3D * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D_scale3D * s_SunPath + z_Plot;
      
              float x2 = SunB[1] * WIN3D_scale3D * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D_scale3D * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D_scale3D * s_SunPath + z_Plot;
            
              WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
            }
            else if (target_window == 2) {
              // ??????????????????????????
            }                  
            else if (target_window == 1) {
              
              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          
    
              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          
              
              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * obj_scale * s_SunPath + x_Plot * obj_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * obj_scale * s_SunPath + y_Plot * obj_scale;
    
              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * obj_scale * s_SunPath + x_Plot * obj_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * obj_scale * s_SunPath + y_Plot * obj_scale;
              
              float ox = (j + obj_offset_x) * sx_Plot;
      
              STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);
            }        
          }
        }
      }
        
      for (float myHOUR = 0; myHOUR < 24; myHOUR += 1) {
        
        int myDATE_step = num_add_days;
  
        int myDATE_start = 0;
        int myDATE_end = 360; 
  
        if (target_window != 3) {
          if (STUDY_j_end == 2) {
            if (j == 0) {
              myDATE_start = 90;
              myDATE_end = 270;
            }
            if (j == 1) {
              myDATE_start = 270;
              myDATE_end = 450;
            }     
          } 
        }
        
        for (int myDATE = myDATE_start; myDATE <= myDATE_end; myDATE += myDATE_step) {
          float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, myHOUR);
          float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, (myDATE + myDATE_step), myHOUR);
          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == 3) {        
  
              float x1 = SunA[1] * WIN3D_scale3D * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D_scale3D * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D_scale3D * s_SunPath + z_Plot;
      
              float x2 = SunB[1] * WIN3D_scale3D * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D_scale3D * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D_scale3D * s_SunPath + z_Plot;
              
              float ox = (j + obj_offset_x) * sx_Plot;
            
              WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
            }
            else if (target_window == 2) {
              // ??????????????????????????
            }                  
            else if (target_window == 1) {
              
              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          
    
              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          
              
              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * obj_scale * s_SunPath + x_Plot * obj_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * obj_scale * s_SunPath + y_Plot * obj_scale;
    
              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * obj_scale * s_SunPath + x_Plot * obj_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * obj_scale * s_SunPath + y_Plot * obj_scale;
              
              float ox = (j + obj_offset_x) * sx_Plot;
              
              STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);
            }                 
          }
        }
      }
      
  
      
      if (target_window == 3) {  
        WIN3D_Diagrams.stroke(0);
        WIN3D_Diagrams.fill(0);
        WIN3D_Diagrams.textAlign(CENTER, CENTER);
      }
      else if (target_window == 2) {  
        WORLD_Diagrams.stroke(0);
        WORLD_Diagrams.fill(0);
        WORLD_Diagrams.textAlign(CENTER, CENTER);
      }
      else if (target_window == 1) {  
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
      }      
      
      for (int i = 0; i < 360; i += 1) {
        if (target_window == 3) {  
          
          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D_scale3D + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D_scale3D + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = s_SunPath * cos((i + 5) * PI / 180) * WIN3D_scale3D + x_Plot;
          float y2 = s_SunPath * sin((i + 5) * PI / 180) * WIN3D_scale3D + y_Plot;
          float z2 = 0 + z_Plot;
          
          WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2); 
        }
        else if (target_window == 2) {
          // ??????????????????????????
        }                  
        else if (target_window == 1) {
          // no nead for a circle here in this case! 
        }        
      }

      for (int i = 0; i < 360; i += 5) {
        if (target_window == 3) {  
          
          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D_scale3D + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D_scale3D + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = 1.05 * s_SunPath * cos((i) * PI / 180) * WIN3D_scale3D + x_Plot;
          float y2 = 1.05 * s_SunPath * sin((i) * PI / 180) * WIN3D_scale3D + y_Plot;
          float z2 = 0 + z_Plot;
          
          WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
        }
        
        else if (target_window == 2) {
          // ??????????????????????????
        }                  
        else if (target_window == 1) {

          float x1 = 90 * s_SunPath * cos(i * PI / 180) * obj_scale + x_Plot * obj_scale;
          float y1 = 90 * s_SunPath * sin(i * PI / 180) * obj_scale + y_Plot * obj_scale;

          float x2 = 90 * 1.05 * s_SunPath * cos((i) * PI / 180) * obj_scale + x_Plot * obj_scale;
          float y2 = 90 * 1.05 * s_SunPath * sin((i) * PI / 180) * obj_scale + y_Plot * obj_scale;

          float ox = (j + obj_offset_x) * sx_Plot;

          STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);  
        }           
      }


      for (int i = 0; i < 360; i += 15) {
        
        String txt = nf((90 - i + 360) % 360, 0);
        if (i == 0) {
          txt = "E"; 
        }
        else if (i == 90) {
          txt = "N"; 
        }
        else if (i == 180) {
          txt = "W"; 
        }
        else if (i == 270) {
          txt = "S"; 
        }
        
        float txtSize = 0.1;
        if (txt.length() > 1) txtSize *= 0.75;
        
        if (target_window == 3) {
          
          float x = 1.10 * s_SunPath * cos(i * PI / 180) * WIN3D_scale3D + x_Plot;
          float y = 1.10 * s_SunPath * sin(i * PI / 180) * WIN3D_scale3D + y_Plot;
          float z = 0 + z_Plot;
          
          WIN3D_Diagrams.textSize(txtSize * WIN3D_scale3D * s_SunPath);
          WIN3D_Diagrams.text(txt, x, -y, z);
        }
        else if (target_window == 2) {
          // ??????????????????????????
        }                  
        else if (target_window == 1) {
          float x = 90 * 1.10 * s_SunPath * cos(i * PI / 180) * obj_scale+ x_Plot * obj_scale;
          float y = 90 * 1.10 * s_SunPath * sin(i * PI / 180) * obj_scale + y_Plot * obj_scale;
          
          float ox = (j + obj_offset_x) * sx_Plot;
          
          STUDY_Diagrams.textSize(txtSize * 0.4 * s_SunPath);
          STUDY_Diagrams.text(txt, ox + x, -y);          
        }           
      }   
      

    }

  }


  
}

void STUDY_keyPressed (KeyEvent e) {
    


  if (e.isAltDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

      }
    }
    else {
      switch(key) {
        case '0' : camera_variation = 0; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '1' : camera_variation = 1; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '2' : camera_variation = 2; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '3' : camera_variation = 3; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '4' : camera_variation = 4; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '5' : camera_variation = 5; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        case '6' : camera_variation = 6; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        //case '7' : camera_variation = 7; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        //case '8' : camera_variation = 8; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        //case '9' : camera_variation = 9; STUDY_Update = 1; STUDY_record_PDF = 1;break;
        
 
      }
    }    
  }
  else if (e.isControlDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

      }
    }
    else {
      switch(key) {

        case 's' :STATION_NUMBER = (STATION_NUMBER + 1) % DEFINED_STATIONS.length; 
                  //SOLARCHVISION_update_station(0); 
                  WORLD_Update = 1;
                  WIN3D_Update = 1; 
                  STUDY_Update = 1;
                  ROLLOUT_Update = 1;

                  initializationStep = 8; 
                  frameCount = initializationStep; 
                  textAlign(CENTER, CENTER); 
                  textSize(MESSAGE_S_View);                    
                  loop(); 
                  break;
        case 'S' :STATION_NUMBER = (STATION_NUMBER - 1 + DEFINED_STATIONS.length) % DEFINED_STATIONS.length; 
                  //SOLARCHVISION_update_station(0); 
                  WORLD_Update = 1;
                  WIN3D_Update = 1; 
                  STUDY_Update = 1;
                  ROLLOUT_Update = 1;
                  
                  initializationStep = 8; 
                  frameCount = initializationStep; 
                  textAlign(CENTER, CENTER); 
                  textSize(MESSAGE_S_View);                    
                  loop(); 
                  break;              
        
        case 'r' : STUDY_record_AUTO = (STUDY_record_AUTO + 1) % 2; STUDY_Update = 0; ROLLOUT_Update = 1; break;
        case 'R' : STUDY_record_AUTO = (STUDY_record_AUTO + 1) % 2; STUDY_Update = 0; ROLLOUT_Update = 1; break;

        
        case '^' : draw_data_lines = 1; Export_STUDY_info_node = 1; STUDY_record_JPG = 0; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '&' : draw_normals = 1; Export_STUDY_info_norm = 1; STUDY_record_JPG = 0; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '%' : draw_probs = 1; Export_STUDY_info_prob = 1; STUDY_record_JPG = 0; STUDY_Update = 1; ROLLOUT_Update = 1; break;                 
        
      }
    }    
  }
  else if (e.isShiftDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

      }
    }
  }

  
  if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
  
    if (key == CODED) { 
      switch(keyCode) {
        /*
        case 112 : develop_option = DEV_OP_1; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 113 : develop_option = DEV_OP_2; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 114 : develop_option = DEV_OP_3; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 115 : develop_option = DEV_OP_4; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 116 : develop_option = DEV_OP_5; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 117 : develop_option = DEV_OP_6; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 118 : develop_option = DEV_OP_7; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 119 : develop_option = DEV_OP_8; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 120 : develop_option = DEV_OP_9; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 121 : develop_option = DEV_OP_10; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 122 : develop_option = DEV_OP_11; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        */

        case 112 : impacts_source = databaseNumber_ENSEMBLE; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 113 : impacts_source = databaseNumber_OBSERVED; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 114 : impacts_source = databaseNumber_CLIMATE_WY2; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 115 : impacts_source = databaseNumber_CLIMATE_EPW; STUDY_Update = 1; ROLLOUT_Update = 1; break;          

        /*
        case 115 : if (((abs(plot_impacts) % 2 == 0) && (plot_impacts != 6)) || (plot_impacts == 7)) plot_impacts = 6;
                   else plot_impacts = 7; 
                   STUDY_Update = 1; ROLLOUT_Update = 1; break;        
        */
        case 116 : if (((abs(plot_impacts) % 2 == 0) && (plot_impacts != 4)) || (plot_impacts == 5)) plot_impacts = 4;
                   else plot_impacts = 5; 
                   STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 117 : if (((abs(plot_impacts) % 2 == 0) && (plot_impacts != 2)) || (plot_impacts == 3)) plot_impacts = 2;
                   else plot_impacts = 3; 
                   STUDY_Update = 1; ROLLOUT_Update = 1; break;                   
        case 118 : if (((abs(plot_impacts) % 2 == 0) && (plot_impacts != 0)) || (plot_impacts == 1)) plot_impacts = 0;
                   else plot_impacts = 1; 
                   STUDY_Update = 1; ROLLOUT_Update = 1; break;           
        case 119 : if (((abs(plot_impacts) % 2 == 0) && (plot_impacts != -2)) || (plot_impacts == -1)) plot_impacts = -2;
                   else plot_impacts = -1; 
                   STUDY_Update = 1; ROLLOUT_Update = 1; break;

        
        case 35  :_DATE += 1;
                  if (int(_DATE) == 365) _DATE -= 365;
                  if (int(_DATE) == 286) _YEAR += 1;
                  SOLARCHVISION_update_date(); 
                  SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
                  
        case 36  :_DATE -= 1;
                  if (int(_DATE) < 0) _DATE += 365;
                  if (int(_DATE) == 285) _YEAR -= 1;
                  SOLARCHVISION_update_date(); 
                  SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
     
        case 33:_DATE += 1; 
                  if (_DATE >= 365) _DATE -= 365;
                  if ((_DATE == 286) || (_DATE == 286.5)) _YEAR += 1;
                  SOLARCHVISION_update_date(); 
                  BEGIN_DAY = int(BEGIN_DAY + 1) % 365; 
                  SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break; 
                  
        case 34 :_DATE -= 1; 
                  if (_DATE < 0) _DATE += 365;
                  if ((_DATE == 285) || (_DATE == 285.5)) _YEAR -= 1;
                  SOLARCHVISION_update_date(); 
                  BEGIN_DAY = int(365 + BEGIN_DAY - 1) % 365;
                  SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break; 
                 
        case LEFT  :BEGIN_DAY = (365 + BEGIN_DAY - 1) % 365; update_DevelopDATA = 1; BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case RIGHT :BEGIN_DAY = (BEGIN_DAY + 1) % 365; update_DevelopDATA = 1; BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
              
        case UP   :STUDY_drw_Layer = (STUDY_drw_Layer + 1) % num_layers; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case DOWN :STUDY_drw_Layer = (STUDY_drw_Layer + num_layers - 1) % num_layers; STUDY_Update = 1; ROLLOUT_Update = 1; break; 
      }
    }
  }
  
  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key != CODED) { 
      switch(key) {
  
        case '|' :if (_DATE == 1.0 * int(_DATE)) _DATE += 0.5;
                  else _DATE -= 0.5;
                  SOLARCHVISION_update_date(); 
                  SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;
                 
        case ';': draw_impact_summary = (draw_impact_summary + 1) % 2;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;

        case TAB :SOALRCHVISION_refreshDateTabs();                   
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
                
        case '}' :STUDY_j_end += 1; 
                  if (STUDY_j_end > STUDY_j_start + 61) STUDY_j_end -= 1;
                  STUDY_U_scale = 18.0 / float(STUDY_j_end - STUDY_j_start);
                  /*
                  if ((impacts_source == databaseNumber_CLIMATE_WY2) || (impacts_source == databaseNumber_CLIMATE_EPW)) { 
                    per_day = int(365 / float(STUDY_j_end - STUDY_j_start));
                  } 
                  if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
                    per_day = 1;
                  }
                  */
                  update_DevelopDATA = 1;

                  rebuild_SolarProjection_array = 1;
                  rebuild_SolarImpact_Image_array = 1;
                  rebuild_WindRose_Image_array = 1;
                  SOLARCHVISION_resize_allSection_SolarImpact_array();

                  BAR_d_Update = 1;STUDY_Update = 1; ROLLOUT_Update = 1; break;
                  
        case '{' :STUDY_j_end -= 1; 
                  if (STUDY_j_end <= STUDY_j_start) STUDY_j_end += 1;
                  STUDY_U_scale = 18.0 / float(STUDY_j_end - STUDY_j_start);
                  /*
                  if ((impacts_source == databaseNumber_CLIMATE_WY2) || (impacts_source == databaseNumber_CLIMATE_EPW)) { 
                    per_day = int(365 / float(STUDY_j_end - STUDY_j_start));
                  } 
                  if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
                    per_day = 1;
                  }                  
                  */
                  update_DevelopDATA = 1;
                  
                  rebuild_SolarProjection_array = 1;
                  rebuild_SolarImpact_Image_array = 1;
                  rebuild_WindRose_Image_array = 1;   
                  SOLARCHVISION_resize_allSection_SolarImpact_array();
               
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;

        /*      
        case '*' :join_type *= -1;
                  update_DevelopDATA = 1;
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break; 
        */

    
        case 'a'  :Angle_inclination -= 5;
                  if (Angle_inclination < -90) Angle_inclination = -90;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break; 
        case 'A'  :Angle_inclination += 5;
                  if (Angle_inclination > 90) Angle_inclination = 90;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'z' :Angle_orientation = (Angle_orientation - 5 + 360) % 360;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break; 
        case 'Z' :Angle_orientation = (Angle_orientation + 5) % 360;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break; 
        
        case 'd' :develop_per_day = (develop_per_day + 1) % 4;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break; 
        case 'D' :develop_per_day = (develop_per_day - 1 + 4) % 4;
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break; 
      
        case '>' :if ((plot_impacts == -2) || (plot_impacts == -1)) {
                    STUDY_O_scale *= ROLLOUT_Update = 1; pow(2.0, (1.0 / 4.0)); 
                  }
                  else {
                    impact_layer = (impact_layer + 1) % 9; 
                  }
                  STUDY_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case '<' :if ((plot_impacts == -2) || (plot_impacts == -1)) {
                    STUDY_O_scale *= ROLLOUT_Update = 1; pow(0.5, (1.0 / 4.0)); 
                  }
                  else {
                    impact_layer = (impact_layer + 9 - 1) % 9;
                     
                  }
                  STUDY_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;

        case 'h' :H_layer_option = (H_layer_option + 1) % 8; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'H' :H_layer_option = (H_layer_option + 8 - 1) % 8; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'f' :F_layer_option = (F_layer_option + 1) % 6; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'F' :F_layer_option = (F_layer_option + 6 - 1) % 6; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        //case 'g' :filter_type = (filter_type + 1) % 2; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        //case 'G' :filter_type = (filter_type + 2 - 1) % 2; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case '=' :STUDY_V_scale[STUDY_drw_Layer] *= pow(2.0, (1.0 / 2.0)); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '_' :STUDY_V_scale[STUDY_drw_Layer] *= pow(0.5, (1.0 / 2.0)); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        
        case 'c' :COLOR_STYLE = (COLOR_STYLE + 1) % n_COLOR_STYLE; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'C' :COLOR_STYLE = (COLOR_STYLE - 1 + n_COLOR_STYLE) % n_COLOR_STYLE; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        
        case 'V' :draw_data_lines = int((draw_data_lines + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'v' :draw_data_lines = int((draw_data_lines + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case '`' :num_add_days += 2;
                  if (num_add_days > 365) num_add_days = 365;
                  update_DevelopDATA = 1; 
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '~' :num_add_days -= 2;
                  if (num_add_days < 1) num_add_days = 1;
                  update_DevelopDATA = 1; 
                  BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
                  
        case 'l' :Materials_Selection += 1;
                  Materials_Selection %= Materials_Number; 
                  update_DevelopDATA = 1;
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'L' :Materials_Selection += Materials_Number - 1;
                  Materials_Selection %= Materials_Number;
                  update_DevelopDATA = 1; 
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;  
        
        case 'm' :draw_sorted = int((draw_sorted + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'M' :draw_sorted = int((draw_sorted + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case 'n' :draw_normals = int((draw_normals + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'N' :draw_normals = int((draw_normals + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case 'b' :draw_probs = int((draw_probs + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'B' :draw_probs = int((draw_probs + 1) % 2); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        
        case 'j' :if (level_pix < 32) level_pix *= pow(2.0, (1.0 / 1.0)); STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'J' :if (level_pix > 2) level_pix *= pow(0.5, (1.0 / 1.0)); STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case 'i' :if (sum_interval > 24) sum_interval -= 24;
                  if (sum_interval > 6) sum_interval -= 6; 
                  else if (sum_interval > 1) sum_interval -= 1;
                  if (sum_interval == 5) sum_interval = 4;
                  println("sum_interval =", sum_interval);
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'I' :if (sum_interval < 6) sum_interval += 1;
                  else if (sum_interval < 24) sum_interval += 6;
                  else sum_interval += 24;
                  if (sum_interval == 5) sum_interval = 6;
                  println("sum_interval =", sum_interval);
                  STUDY_Update = 1; ROLLOUT_Update = 1; break;
                  
        case '!' :sky_scenario = 1; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '@' :sky_scenario = 2; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '#' :sky_scenario = 3; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case '$' :sky_scenario = 4; update_DevelopDATA = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
  
        case 's' : STUDY_record_JPG = 1; STUDY_record_PDF = 0; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        case 'S' : STUDY_record_PDF = 1; STUDY_record_JPG = 0; STUDY_Update = 1; ROLLOUT_Update = 1; break; 


      }
  
    }
  }
 
}


float[] SOLARCHVISION_DRYW (float _variable) {
  _variable = 1 - _variable;
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }
  
  return COL;
}

float[] SOLARCHVISION_WYRD (float _variable) {
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }

  return COL;
}




void SOLARCHVISION_draw_SunPattern3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 

  if (frame_variation == 1) Display_SUN3D_Pattern = 0; // <<<<<<<<<<< to avoid memory problem!
  
  if (Display_SUN3D_Pattern != 0) {

    float keep_per_day = per_day;
    int keep_num_add_days = num_add_days;
    if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
      per_day = 1;
      num_add_days = 1;
    }    

    int previous_STUDY_j_end = STUDY_j_end;
    STUDY_j_end = 1 + STUDY_j_start;
    
    float previous_DATE = _DATE;
    
    SOLARCHVISION_draw_SunPathCycles(x_SunPath, x_SunPath,x_SunPath, s_SunPath, s_SunPath, s_SunPath, impact_layer, 3);

    per_day = keep_per_day;
    num_add_days = keep_num_add_days; 
    STUDY_j_end = previous_STUDY_j_end;
    _DATE = previous_DATE;
    SOLARCHVISION_update_date();
  
  }
  
}

void SOLARCHVISION_draw_SunPath3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath, float LocationLatitude) { 

  if (Display_SUN3D_Path != 0) {

    float keep_per_day = per_day;
    int keep_num_add_days = num_add_days;
    if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
      per_day = 1;
      num_add_days = 1;
    }    
    
    float previous_DATE = _DATE;
    



    int TES_hour = 4; // 1 = every 1 hour, 4 = every 15 minutes

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    
    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath3D_Pallet_ACTIVE_CLR; PAL_DIR = SunPath3D_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath3D_Pallet_PASSIVE_CLR; PAL_DIR = SunPath3D_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * SunPath3D_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * SunPath3D_Pallet_PASSIVE_MLT;

  
    
    WIN3D_Diagrams.pushMatrix();
    WIN3D_Diagrams.translate(x_SunPath, y_SunPath, z_SunPath);
  
    WIN3D_Diagrams.strokeWeight(0); 
    WIN3D_Diagrams.stroke(0, 0, 0);
    WIN3D_Diagrams.fill(0, 0, 0);
    
    WIN3D_Diagrams.line(-1 * s_SunPath, 0, 0, 1 * s_SunPath, 0, 0); 
    WIN3D_Diagrams.line(0, -1 * s_SunPath, 0, 0, 1 * s_SunPath, 0);
  
    WIN3D_Diagrams.stroke(255, 255, 0);
    

    
    int start_z = get_startZ_endZ(impacts_source)[0];
    int end_z = get_startZ_endZ(impacts_source)[1]; 
    int layers_count = get_startZ_endZ(impacts_source)[2]; 
    
    for (int p = 0; p < 1; p += 1) { 
      
      int l = impact_layer;
    
      int DATE_step = 1;
      
      int J_START = STUDY_j_start;
      int J_END = STUDY_j_end;
      
      if (Day_of_Impact_to_Display > 0) {
        J_START = Day_of_Impact_to_Display - 1;
        J_END = Day_of_Impact_to_Display;
      }
    
      for (int j = J_START; j < J_END; j += DATE_step) {
        
        int now_k = 0;
        int now_i1 = 0;
        int now_i2 = 0;
        int now_j = 0;
    
        now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
    
        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
     
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
        
        //println(j, now_j, DATE_ANGLE);
       
        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);
        
        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);
        
        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / num_add_days);
            int j_ADD = nk % num_add_days; 
    
            for (float i = 0; i < 24; i += 1.0 / float(TES_hour)) {
              if (isInHourlyRange(i) == 1) {
              
                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
                
                now_k = k;
                
                now_i1 = floor(i);
                now_i2 = (1 + now_i1) % 24;
                float i_ratio = i - now_i1;
                
                now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
      
                if (now_j >= 365) {
                 now_j = now_j % 365; 
                }
                if (now_j < 0) {
                 now_j = (now_j + 365) % 365; 
                }
                
                float Pa1 = FLOAT_undefined;
                float Pa2 = FLOAT_undefined;
                
                if (Impact_TYPE == Impact_ACTIVE) {
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                      Pa1 = CLIMATE_WY2[now_i1][now_j][_dirnorrad][now_k]; 
                      Pa2 = CLIMATE_WY2[now_i2][now_j][_dirnorrad][now_k];
                  }
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                      Pa1 = ENSEMBLE[now_i1][now_j][_dirnorrad][now_k]; 
                      Pa2 = ENSEMBLE[now_i2][now_j][_dirnorrad][now_k];
                  }   
                  if (impacts_source == databaseNumber_OBSERVED) {
                      Pa1 = OBSERVED[now_i1][now_j][_dirnorrad][now_k]; 
                      Pa2 = OBSERVED[now_i2][now_j][_dirnorrad][now_k];
                  }   
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {
                      Pa1 = CLIMATE_EPW[now_i1][now_j][_dirnorrad][now_k]; 
                      Pa2 = CLIMATE_EPW[now_i2][now_j][_dirnorrad][now_k];
                  }
                } 
                
                if (Impact_TYPE == Impact_PASSIVE) {
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                      Pa1 = CLIMATE_WY2[now_i1][now_j][_direffect][now_k]; 
                      Pa2 = CLIMATE_WY2[now_i2][now_j][_direffect][now_k];
                  }
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                      Pa1 = ENSEMBLE[now_i1][now_j][_direffect][now_k]; 
                      Pa2 = ENSEMBLE[now_i2][now_j][_direffect][now_k];
                  }   
                  if (impacts_source == databaseNumber_OBSERVED) {
                      Pa1 = OBSERVED[now_i1][now_j][_direffect][now_k]; 
                      Pa2 = OBSERVED[now_i2][now_j][_direffect][now_k];
                  }   
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {
                      Pa1 = CLIMATE_EPW[now_i1][now_j][_direffect][now_k]; 
                      Pa2 = CLIMATE_EPW[now_i2][now_j][_direffect][now_k];
                  }
                }                  
     
                if ((Pa1 > 0.9 * FLOAT_undefined) && (Pa2 > 0.9 * FLOAT_undefined)) {
                }
                else {
                  
                  float sun_V = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                  
                  float _u = 0;
                  
                  if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * sun_V);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (PAL_Multiplier * sun_V);
                  
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
                  
                  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);    
                  
                  WIN3D_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
                  WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                  
                  WIN3D_Diagrams.strokeWeight(4);
                  
                  float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE - 0.5 * (1.0 / float(TES_hour)));
                  float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE + 0.5 * (1.0 / float(TES_hour)));

                  float x1 = SunA[1] * WIN3D_scale3D * s_SunPath;
                  float y1 = SunA[2] * WIN3D_scale3D * s_SunPath;
                  float z1 = SunA[3] * WIN3D_scale3D * s_SunPath;

                  float x2 = SunB[1] * WIN3D_scale3D * s_SunPath;
                  float y2 = SunB[2] * WIN3D_scale3D * s_SunPath;
                  float z2 = SunB[3] * WIN3D_scale3D * s_SunPath;

                  WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);

                } 
              }
            }
          }
        }
      }
    }  

    WIN3D_Diagrams.popMatrix();


  
    per_day = keep_per_day;
    num_add_days = keep_num_add_days; 
    _DATE = previous_DATE;
    SOLARCHVISION_update_date();
  
  }
} 


int Display_SolarRotation = 0;

void SOLARCHVISION_draw_SolarRotation (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath, float LocationLatitude) { 

  if (Display_SolarRotation != 0) {

    WIN3D_Diagrams.pushMatrix();
    WIN3D_Diagrams.translate(x_SunPath, y_SunPath, z_SunPath);
  
    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0);
    
    for (int j = 90; j <= 270; j += 30) {
      float HOUR_step = 1;
      for (float HOUR = 0; HOUR <= 24; HOUR += HOUR_step) {
        float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, j, (HOUR + HOUR_step));
        WIN3D_Diagrams.line(s_SunPath * SunA[1] * WIN3D_scale3D, -s_SunPath * SunA[2] * WIN3D_scale3D, s_SunPath * SunA[3] * WIN3D_scale3D, s_SunPath * SunB[1] * WIN3D_scale3D, -s_SunPath * SunB[2] * WIN3D_scale3D, s_SunPath * SunB[3] * WIN3D_scale3D);
      }
    }
    
    for (int HOUR = 0; HOUR <= 24; HOUR += 1) {
      float DATE_step = 1;
      for (int j = 0; j <= 360; j += DATE_step) {
        float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, (j + DATE_step), HOUR);
        WIN3D_Diagrams.line(s_SunPath * SunA[1] * WIN3D_scale3D, -s_SunPath * SunA[2] * WIN3D_scale3D, s_SunPath * SunA[3] * WIN3D_scale3D, s_SunPath * SunB[1] * WIN3D_scale3D, -s_SunPath * SunB[2] * WIN3D_scale3D, s_SunPath * SunB[3] * WIN3D_scale3D);
      }
    }
    
    WIN3D_Diagrams.popMatrix();
    

  }
} 



void WIN3D_keyPressed (KeyEvent e) {

  if (e.isAltDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

        case RIGHT :SpatialImpact_Rotation[SpatialImpact_sectionType] = (SpatialImpact_Rotation[SpatialImpact_sectionType] + 15) % 360; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
        case LEFT :SpatialImpact_Rotation[SpatialImpact_sectionType] = (SpatialImpact_Rotation[SpatialImpact_sectionType] + 360 - 15) % 360; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;           
        
        case UP   :SpatialImpact_Elevation[SpatialImpact_sectionType] += SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;        
        case DOWN :SpatialImpact_Elevation[SpatialImpact_sectionType] -= SpatialImpact_positionStep; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1;  
                  break; 

        case 33 :SpatialImpact_Elevation[SpatialImpact_sectionType] += 4 * SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;        
        case 34 :SpatialImpact_Elevation[SpatialImpact_sectionType] -= 4 * SpatialImpact_positionStep; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break; 
        
        case 35 :SpatialImpact_scale_U[SpatialImpact_sectionType] *= pow(2.0, 0.5); SpatialImpact_scale_V[SpatialImpact_sectionType] *= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case 36 :SpatialImpact_scale_U[SpatialImpact_sectionType] /= pow(2.0, 0.5); SpatialImpact_scale_V[SpatialImpact_sectionType] /= pow(2.0, 0.5);                   
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        
      }
    }
    else {
      switch(key) {
        
        case 'U' :SpatialImpact_offset_U[SpatialImpact_sectionType] += SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case 'u' :SpatialImpact_offset_U[SpatialImpact_sectionType] -= SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;        
        case 'V' :SpatialImpact_offset_V[SpatialImpact_sectionType] += SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case 'v' :SpatialImpact_offset_V[SpatialImpact_sectionType] -= SpatialImpact_positionStep;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;  
                  
        case ']' :SpatialImpact_sectionType = (SpatialImpact_sectionType + 1) % 4;
                  SolarImpact_sectionType = SpatialImpact_sectionType; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case '[' :SpatialImpact_sectionType = (SpatialImpact_sectionType + 4 - 1) % 4;
                  SolarImpact_sectionType = SpatialImpact_sectionType;
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1; 
                  ROLLOUT_Update = 1; 
                  break;        
        
        case '0' :SpatialImpact_Elevation[SpatialImpact_sectionType] = 0; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
                  
        case '.' :SpatialImpact_Rotation[SpatialImpact_sectionType] = 0; 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections();
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;                   
                  break;                  
        
        case '/' :SpatialImpact_Power *= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
        case '*' :SpatialImpact_Power /= pow(2.0, 0.5);  
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
        
        case '+' :SpatialImpact_Grade *= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
        case '-' :SpatialImpact_Grade /= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;

        case '>' :SpatialImpact_Grade /= pow(2.0, 0.25); 
                  SpatialImpact_Power /= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
        case '<' :SpatialImpact_Grade *= pow(2.0, 0.25); 
                  SpatialImpact_Power *= pow(2.0, 0.5); 
                  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;  
                  break;
                  

        
        case ENTER :SOLARCHVISION_calculate_windFlow(); WIN3D_Update = 1; break;                  
 
      }
    }    
  }

 
  else if (e.isControlDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

        
        case 33: 
                 if (Work_with_2D_or_3D == 1) {
                   selectedFractal_numbers[selectedFractal_numbers.length - 1] -= 1;
                   if (selectedFractal_numbers[selectedFractal_numbers.length - 1] < 0) {
                     selectedFractal_numbers[selectedFractal_numbers.length - 1] = allFractal_XYZSRA.length - 1;
                   }                   
                 }

                 if (Work_with_2D_or_3D == 2) {
                   selectedObject2D_numbers[selectedObject2D_numbers.length - 1] -= 1;
                   if (selectedObject2D_numbers[selectedObject2D_numbers.length - 1] < 0) {
                     selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = allObject2D_XYZS.length - 1;
                   }
                 }        
        
                 if (Work_with_2D_or_3D == 3) {
                   selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] -= 1;
                   if (selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] < 0) {
                     selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] = allPolymesh_Faces.length - 1;
                   }
                 }

                 if (Work_with_2D_or_3D == 4) {
                   selectedFace_numbers[selectedFace_numbers.length - 1] -= 1;
                   if (selectedFace_numbers[selectedFace_numbers.length - 1] < 0) {
                     selectedFace_numbers[selectedFace_numbers.length - 1] = allFaces.length - 1;
                   }
                 }
                 
                 if (Work_with_2D_or_3D == 5) {
                   selectedVertex_numbers[selectedVertex_numbers.length - 1] -= 1;
                   if (selectedVertex_numbers[selectedVertex_numbers.length - 1] < 0) {
                     selectedVertex_numbers[selectedVertex_numbers.length - 1] = allVertices.length - 1;
                   }
                 }
                 
                 if (Work_with_2D_or_3D == 8) {
                   selectedSection_numbers[selectedSection_numbers.length - 1] -= 1;
                   if (selectedSection_numbers[selectedSection_numbers.length - 1] < 0) {
                     selectedSection_numbers[selectedSection_numbers.length - 1] = allSection_UVERAB.length - 1;
                   }                   
                 }                 
                 
                 println("SOLARCHVISION_calculate_selection_Pivot 27");
                 SOLARCHVISION_calculate_selection_Pivot();
                 
                 SOLARCHVISION_reset_selectedRefValues();  
                 
                 WIN3D_Update = 1;
                 ROLLOUT_Update = 1; 
                 break;  

        case 34: 
                 if (Work_with_2D_or_3D == 1) {
                   selectedFractal_numbers[selectedFractal_numbers.length - 1] += 1;
                   if (selectedFractal_numbers[selectedFractal_numbers.length - 1] > allFractal_XYZSRA.length - 1) {
                     selectedFractal_numbers[selectedFractal_numbers.length - 1] = 0;
                   }
                 }         
        
                 if (Work_with_2D_or_3D == 2) {
                   selectedObject2D_numbers[selectedObject2D_numbers.length - 1] += 1;
                   if (selectedObject2D_numbers[selectedObject2D_numbers.length - 1] > allObject2D_XYZS.length - 1) {
                     selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = 0;
                   }
                 } 
                 
                 if (Work_with_2D_or_3D == 3) {
                   selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] += 1;
                   if (selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] > allPolymesh_Faces.length - 1) {
                     selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] = 0;
                   }
                 }  

                 if (Work_with_2D_or_3D == 4) {
                   selectedFace_numbers[selectedFace_numbers.length - 1] += 1;
                   if (selectedFace_numbers[selectedFace_numbers.length - 1] > allFaces.length - 1) {
                     selectedFace_numbers[selectedFace_numbers.length - 1] = 0;
                   }
                 }  

                 if (Work_with_2D_or_3D == 5) {
                   selectedVertex_numbers[selectedVertex_numbers.length - 1] += 1;
                   if (selectedVertex_numbers[selectedVertex_numbers.length - 1] > allVertices.length - 1) {
                     selectedVertex_numbers[selectedVertex_numbers.length - 1] = 0;
                   }
                 }  
                 
                 if (Work_with_2D_or_3D == 8) {
                   selectedSection_numbers[selectedSection_numbers.length - 1] += 1;
                   if (selectedSection_numbers[selectedSection_numbers.length - 1] > allSection_UVERAB.length - 1) {
                     selectedSection_numbers[selectedSection_numbers.length - 1] = 0;
                   }
                 }                   
                 
                 println("SOLARCHVISION_calculate_selection_Pivot 28");
                 SOLARCHVISION_calculate_selection_Pivot();
                 
                 SOLARCHVISION_reset_selectedRefValues();  
                 
                 WIN3D_Update = 1;
                 ROLLOUT_Update = 1; 
                 break;          
        
        case LEFT  :WIN3D_X_coordinate += WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case RIGHT :WIN3D_X_coordinate -= WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; break; 
        case UP    :WIN3D_Y_coordinate += WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case DOWN  :WIN3D_Y_coordinate -= WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        
        
      }
    }
    else {
      switch(key) {
        case '.' :WIN3D_X_coordinate = 0;
                  WIN3D_Y_coordinate = 0;
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
                  
        case '0' :WIN3D_X_coordinate = 0;
                  WIN3D_Y_coordinate = 0;
                  //WIN3D_ZOOM_coordinate = 60;
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;                  
                  
        case '5' :WIN3D_RX_coordinate = 0;
                  WIN3D_RY_coordinate = 0;
                  WIN3D_RZ_coordinate = 0; 
                  
                  WIN3D_X_coordinate = 0;
                  WIN3D_Y_coordinate = 0;
                  WIN3D_Z_coordinate = 0;   
                  
                  WIN3D_S_coordinate = 1;
   
                  WIN3D_ZOOM_coordinate = 60;               
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
          
        case '2' :Display_Trees_People = (Display_Trees_People + 1) % 2; WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        
        case '3' :Display_Building_Model = (Display_Building_Model + 1) % 2; WIN3D_Update = 1; ROLLOUT_Update = 1; break;
 


          

 
        case ' ' :SOLARCHVISION_render_Shadows_selectedSections(); 
                  WIN3D_Update = 1;
                  break;
                    
        case ENTER :SOLARCHVISION_calculate_SolarImpact_selectedSections();
                    WIN3D_Update = 1;
                    break;
        
      }
    }    
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key == CODED) { 
      switch(keyCode) {

        case 155: // INSERT 
                  SOLARCHVISION_deselectAll();

                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1;
                  break;
      }
    }    
    else {
      switch(key) {

        case DELETE: 
                  SOLARCHVISION_deleteSelection();
                  
                  WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 

                  break;        
        
        case ',' :
                  if (WIN3D_View_Type == 1) {
                    WIN3D_Z_coordinate += WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; 
                  } 
                  else {
                    WIN3D_ZOOM_coordinate /= pow(2.0, 0.25); WIN3D_Update = 1; ROLLOUT_Update = 1; 
                  }
                  break;
                  
        case '.' :
                  if (WIN3D_View_Type == 1) {
                    WIN3D_Z_coordinate -= WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1; 
                  } 
                  else {
                    WIN3D_ZOOM_coordinate *= pow(2.0, 0.25); WIN3D_Update = 1; ROLLOUT_Update = 1; 
                  }
                  break;
  
        case '0' :
                  if (WIN3D_View_Type == 1) {
                    WIN3D_Z_coordinate += WIN3D_S_coordinate * OBJECTS_scale; WIN3D_Update = 1; ROLLOUT_Update = 1;
                  } 
                  else {
                    WIN3D_ZOOM_coordinate /= pow(2.0, 0.25); WIN3D_Update = 1; ROLLOUT_Update = 1; 
                  }
                  break;
                  
        case '5' :
                  //WIN3D_RX_coordinate = 0; WIN3D_RY_coordinate = 0; WIN3D_RZ_coordinate = 0;
                  SOLARCHVISION_look_Camera_towards_Selection(); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        
        case '1' :
                  //WIN3D_RZ_coordinate = 315; 
                  WIN3D_RZ_coordinate += WIN3D_RS_coordinate; SOLARCHVISION_reverseTransform_Camera(); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case '3' :
                  //WIN3D_RZ_coordinate = 45; 
                  WIN3D_RZ_coordinate -= WIN3D_RS_coordinate; SOLARCHVISION_reverseTransform_Camera();
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case '7' :
                  //WIN3D_RZ_coordinate = 225;
                  WIN3D_RX_coordinate -= WIN3D_RS_coordinate; SOLARCHVISION_reverseTransform_Camera(); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case '9' :
                  //WIN3D_RZ_coordinate = 135;
                  WIN3D_RX_coordinate += WIN3D_RS_coordinate; SOLARCHVISION_reverseTransform_Camera(); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
  
        case '2' :
                  //WIN3D_RX_coordinate += WIN3D_RS_coordinate; 
                  SOLARCHVISION_rotateZ_Camera_around_Selection(WIN3D_RS_coordinate);
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        
        case '4' :
                  //WIN3D_RZ_coordinate -= WIN3D_RS_coordinate; 
                  SOLARCHVISION_rotateXY_Camera_around_Selection(-WIN3D_RS_coordinate);
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
                  
        case '6' :
                  //WIN3D_RZ_coordinate += WIN3D_RS_coordinate; 
                  SOLARCHVISION_rotateXY_Camera_around_Selection(WIN3D_RS_coordinate);
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break; 
                  
        case '8' :
                  //WIN3D_RX_coordinate -= WIN3D_RS_coordinate; 
                  SOLARCHVISION_rotateZ_Camera_around_Selection(-WIN3D_RS_coordinate);
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        
        case '*' ://OBJECTS_scale *= 2.0; SKY3D_scale *= 2.0;
                  SOLARCHVISION_move_Camera_towards_Selection(0.5); 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case '/' ://OBJECTS_scale /= 2.0; SKY3D_scale /= 2.0; 
                  SOLARCHVISION_move_Camera_towards_Selection(2.0);
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;
  
        case '+' :WIN3D_ZOOM_coordinate = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * WIN3D_ZOOM_coordinate)); WIN3D_Update = 1; ROLLOUT_Update = 1; break;
        case '-' :WIN3D_ZOOM_coordinate = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * WIN3D_ZOOM_coordinate)); WIN3D_Update = 1; ROLLOUT_Update = 1; break; 
        
        case 'O' :WIN3D_View_Type = 0; WIN3D_Update = 1; ROLLOUT_Update = 1; ROLLOUT_Update = 1; break;
        case 'o' :WIN3D_View_Type = 0; WIN3D_Update = 1; ROLLOUT_Update = 1; ROLLOUT_Update = 1; break;
        
        case 'P' ://WIN3D_ZOOM_coordinate = 60;
                  WIN3D_View_Type = 1; WIN3D_Update = 1; ROLLOUT_Update = 1; break; 
        case 'p' ://WIN3D_ZOOM_coordinate = 60;
                  WIN3D_View_Type = 1; WIN3D_Update = 1; ROLLOUT_Update = 1; break; 
  
        case 'K' :WIN3D_FACES_SHADE = (WIN3D_FACES_SHADE + 5 - 1) % 5; WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break;
        case 'k' :WIN3D_FACES_SHADE = (WIN3D_FACES_SHADE + 1) % 5; WIN3D_Update = 1;
                  ROLLOUT_Update = 1; 
                  break; 
        
        case 't' :MODEL3D_TESSELLATION += 1; WIN3D_update_VerticesSolarValue = 1; WIN3D_Update = 1; break; 
        case 'T' :MODEL3D_TESSELLATION -= 1;
                  if (MODEL3D_TESSELLATION < 0) MODEL3D_TESSELLATION = 0;
                  WIN3D_update_VerticesSolarValue = 1; 
                  WIN3D_Update = 1; ROLLOUT_Update = 1; break;

        case ']' :Day_of_Impact_to_Display += 1;
                  if (Day_of_Impact_to_Display > STUDY_j_end) Day_of_Impact_to_Display = 0;
                  WIN3D_Update = 1; 
                  ROLLOUT_Update = 1; 
                  break; 
        case '[' :Day_of_Impact_to_Display -= 1;
                  if (Day_of_Impact_to_Display < 0) Day_of_Impact_to_Display = STUDY_j_end;
                  WIN3D_Update = 1; 
                  ROLLOUT_Update = 1; 
                  break; 
                  
        case ENTER: if (WIN3D_FACES_SHADE == Shade_Global_Solar) rebuild_SolarProjection_array = 1;   
                    if (WIN3D_FACES_SHADE == Shade_Vertex_Solar) WIN3D_update_VerticesSolarValue = 1;
                    WIN3D_Update = 1;
                    ROLLOUT_Update = 1;  
                    break;                  
          
        case ' ': SOLARCHVISION_RecordFrame();
                  ROLLOUT_Update = 1; 
                  break;              

        case 'x' :SOLARCHVISION_export_objects(); ROLLOUT_Update = 1; break;
        case 'y' :SOLARCHVISION_export_objects_script(); ROLLOUT_Update = 1; break;
        
      }
    }
  }
}





int frame_variation = 0;

void SOLARCHVISION_update_frame_layout () {
 
 if (frame_variation == 0) {

    STUDY_include = 1;
    WIN3D_include = 1;
    WORLD_include = 1;

    WIN3D_CX_View = 0;
    WIN3D_CY_View = a_pixel + b_pixel + 0;
    WIN3D_X_View = int(1.25 * h_pixel);
    WIN3D_Y_View = h_pixel;
    WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);
    WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);

    WORLD_CX_View = int(1.25 * h_pixel);
    WORLD_CY_View = a_pixel + b_pixel + 0;
    WORLD_X_View = int(1.75 * h_pixel);
    WORLD_Y_View = h_pixel;
    WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);
    WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);

    STUDY_CX_View = 0;
    STUDY_CY_View = a_pixel + b_pixel + h_pixel;
    STUDY_X_View = 2 * w_pixel;
    STUDY_Y_View = 1 * h_pixel;
    STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);   
    STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);     

 }
 else if (frame_variation == 1) {

    STUDY_include = 0;
    WIN3D_include = 1;
    WORLD_include = 0;
   
    WIN3D_CX_View = 0;
    WIN3D_CY_View = a_pixel + b_pixel + 0;
    WIN3D_X_View = 3 * h_pixel;
    WIN3D_Y_View = 2 * h_pixel;
    WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);
    WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);
 }  
 else if (frame_variation == 2) {

    STUDY_include = 1;
    WIN3D_include = 0;
    WORLD_include = 0;
   
    STUDY_CX_View = 0;
    STUDY_CY_View = a_pixel + b_pixel + 0;
    STUDY_X_View = 2 * w_pixel;
    STUDY_Y_View = 2 * h_pixel;
    STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);   
    STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);  
 } 
 else if (frame_variation == 3) {
   
    STUDY_include = 0;
    WIN3D_include = 0;
    WORLD_include = 1;
   
    WORLD_CX_View = 0;
    WORLD_CY_View = a_pixel + b_pixel + 0;
    WORLD_X_View = 2 * w_pixel;
    WORLD_Y_View = 2 * h_pixel;
    WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);
    WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
 } 

  WORLD_Update = 1;
  WIN3D_Update = 1; 
  STUDY_Update = 1;    
}


 

void keyPressed (KeyEvent e) {

  if (frameCount > Last_initializationStep) {
  
    if (automated == 0) {
      X_clicked = -1;
      Y_clicked = -1;
  
      if ((BAR_a_selected_parent != -1) || (BAR_a_selected_child != 0)) {
      
        BAR_a_selected_parent = -1;
        BAR_a_selected_child = 0;
    
        image(pre_screen, 0, a_pixel);
      }
      
      addNewSelectionToPreviousSelection = 0;
    
      //println("key: " + key);
      //println("keyCode: " + keyCode);
      
      
    
      STUDY_keyPressed(e);
    
      WIN3D_keyPressed(e);
  
      if (e.isAltDown() == true) {
        
        if (key == CODED) { 
          switch(keyCode) {
  
          }
        }
        else {
          switch(key) {
            case 'l' : frame_variation = (frame_variation + 1) % 4; SOLARCHVISION_update_frame_layout(); ROLLOUT_Update = 1; break;
            case 'L' : frame_variation = (frame_variation + 4 - 1) % 4; SOLARCHVISION_update_frame_layout(); ROLLOUT_Update = 1; break;
          }
        }    
      }
      else if (e.isControlDown() == true) {
        
        addNewSelectionToPreviousSelection = 1;
        
        if (key == CODED) { 
          switch(keyCode) {
            case 112 : ROLLOUT_parent = 0; ROLLOUT_Update = 1; break;
            case 113 : ROLLOUT_parent = 1; ROLLOUT_Update = 1; break;
            case 114 : ROLLOUT_parent = 2; ROLLOUT_Update = 1; break;
            case 115 : ROLLOUT_parent = 3; ROLLOUT_Update = 1; break;
            case 116 : ROLLOUT_parent = 4; ROLLOUT_Update = 1; break;
            case 117 : ROLLOUT_parent = 5; ROLLOUT_Update = 1; break;
            case 118 : ROLLOUT_parent = 6; ROLLOUT_Update = 1; break;
            case 119 : ROLLOUT_parent = 7; ROLLOUT_Update = 1; break;
          }
        }
        else {
          switch(key) {
            
            case 'f' :
              ResetFontStyle();     
              WORLD_Update = 1;
              WIN3D_Update = 1; 
              STUDY_Update = 1;
              ROLLOUT_Update = 1; 
              break;
  
            case 'F' :
              ResetFontStyle();     
              WORLD_Update = 1;
              WIN3D_Update = 1; 
              STUDY_Update = 1;
              ROLLOUT_Update = 1; 
              break;                   
        
     
          }
        }    
      }
      else if (e.isShiftDown() == true) {
        
        addNewSelectionToPreviousSelection = -1;
        
        if (key == CODED) { 
          switch(keyCode) {
            case 112 : ROLLOUT_child = 1; ROLLOUT_Update = 1; break;
            case 113 : ROLLOUT_child = 2; ROLLOUT_Update = 1; break;
            case 114 : ROLLOUT_child = 3; ROLLOUT_Update = 1; break;
            case 115 : ROLLOUT_child = 4; ROLLOUT_Update = 1; break;
            case 116 : ROLLOUT_child = 5; ROLLOUT_Update = 1; break;
            case 117 : ROLLOUT_child = 6; ROLLOUT_Update = 1; break;
            case 118 : ROLLOUT_child = 7; ROLLOUT_Update = 1; break;
            case 119 : ROLLOUT_child = 8; ROLLOUT_Update = 1; break;
          }
        }
      }
  
      
      if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
        if (key == CODED) { 
          switch(key) {
  
          } 
        }   
      }
      
      if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
        
        if (key != CODED) { 
          switch(key) {
            
       
                     
            case 'g' :
                      AERIAL_graphOption = (AERIAL_graphOption + 1) % 2;
                      WORLD_Update = 1;
                      WIN3D_Update = 1; 
                      ROLLOUT_Update = 1; 
                      break;
        
            case 'G' :
                      AERIAL_graphOption = (AERIAL_graphOption + 2 - 1) % 2;
                      WORLD_Update = 1;
                      WIN3D_Update = 1; 
                      ROLLOUT_Update = 1; 
                      break;                 
          }
        }  
      }      
  
      if ((STUDY_Update != 0) || (WORLD_Update != 0) || (WIN3D_Update != 0) || (ROLLOUT_Update != 0)) redraw();    
    }
  }
}

void keyReleased() {   
    
  addNewSelectionToPreviousSelection = 0;
}


float EquationOfTime (float DateAngle) {
  float b = DateAngle;

  return 0.01  * (9.87 * sin_ang(2 * b) - 7.53 * cos_ang(b) - 1.5 * sin_ang(b));
}

float E = 2.7182818284;

float[] SOLARCHVISION_SunPositionRadiation (float LocationLatitude, float DateAngle, float HourAngleOrigin, float CloudCover) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle); 
  
  float Declination = 23.45 * sin_ang(DateAngle - 180.0);
  
  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngleOrigin);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngleOrigin);
  
  float x = c; 
  float y = -(a * cos_ang(LocationLatitude) + b * sin_ang(LocationLatitude));
  float z = -a * sin_ang(LocationLatitude) + b * cos_ang(LocationLatitude);
  
  float Io = 1367.0; // W/m²
  Io = Io * (1.0 - (0.0334 * sin_ang(DateAngle)));
  
  float ALT_ = (asin_ang(z)) * PI / 180; 
  float ALT_true = ALT_ + 0.061359 * (0.1594 + 1.1230 * ALT_ + 0.065656 * ALT_ * ALT_) / (1 + 28.9344 * ALT_ + 277.3971 * ALT_ * ALT_);
  
  float PPo = pow(E, (-LocationElevation / 8435.2));
  float Bb = ((sin_ang (ALT_true * 180 / PI)) + (0.50572 * pow((57.29578 * ALT_true + 6.07995), -1.6364)));
  float m = PPo / Bb;
  
  float StationTurbidity;

  StationTurbidity = (2.0 - 0.2) * (0.1 * CloudCover) + 0.2;
  
  float AtmosphereRatio;
  if (z < 0.01) AtmosphereRatio = 0.0; 
  else AtmosphereRatio = pow(E, (-m * StationTurbidity));
    
  float Idirect = Io * AtmosphereRatio; // Optical air mass: global Meteorological Database for Engineers, Planners and Education; Version 5.00 - Edition 2003
  
  float Idiffuse;
  if (z < 0.01) Idiffuse = 0.0;
  else Idiffuse = ((0.5 + 0.5 * (0.1 * CloudCover)) * z * (Io - Idirect)) / (1.0 - 1.4 * z * log(Idirect / Io));
  
  float[] return_array = {0, x, y, z, Idirect, Idiffuse}; 
  return return_array; 
}

float[] SOLARCHVISION_SunPosition (float Latitude, float DateAngle, float HourAngleOrigin) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle);
  
  float Declination = 23.45 * sin_ang(DateAngle - 180.0);

  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngle);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngle);

  float x = c; 
  float y = -(a * cos_ang(Latitude) + b * sin_ang(Latitude));
  float z = -a * sin_ang(Latitude) + b * cos_ang(Latitude);

  float[] return_array = {0, x, y, z}; 
  return return_array; 
}

float SOLARCHVISION_Sunrise (float Latitude, float DateAngle) {
  
  float a = 0;
  
  float Declination = 23.5 * sin_ang(DateAngle - 180.0);
  
  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  }
  else if (q < -1.0) {
    a = 24.0;
  }
  else a = acos_ang(q) / 15.0;
  
  //return (a - EquationOfTime(DateAngle));
  return a;
}

float SOLARCHVISION_Sunset (float Latitude, float DateAngle) {
  
  float a = 0;
  
  float Declination = 23.5 * sin_ang(DateAngle - 180.0);
  
  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  }
  else if (q < -1.0) {
    a = 24.0;
  }
  else a = acos_ang(q) / 15.0;
  
  
  //return ((24 - a) - EquationOfTime(DateAngle));
  return (24 - a);
}

float SOLARCHVISION_DayTime (float Latitude, float DateAngle) {
  return abs((SOLARCHVISION_Sunset(Latitude, DateAngle)) -(SOLARCHVISION_Sunrise(Latitude, DateAngle)));
}

String Default_Font = "MS Sans Serif";

/*
"MS Sans Serif"
"Microsoft Sans Serif"
"Arial Narrow"
"Arial"
"Times New Roman"
"Calibri"
"Cambria"
"Georgia"
"Courier New"
"Franklin Gothic Medium"
"BankGothic Md BT"
*/

PFont SOLARCHVISION_font;

void LoadDefaultFontStyle () {
  
  println("Loading font:", Default_Font);
  
  SOLARCHVISION_font = createFont(Default_Font, 36, true);
  
  ResetFontStyle();
}

void ResetFontStyle () {
  
                 textFont(SOLARCHVISION_font);
  WORLD_Diagrams.textFont(SOLARCHVISION_font);
  WIN3D_Diagrams.textFont(SOLARCHVISION_font);
  STUDY_Diagrams.textFont(SOLARCHVISION_font);
}

void SOLARCHVISION_add_Object2D (String t, int m, float x, float y, float z, float s) {

  int n = m;
  
  if (n == 0) {
    if (t.equals("PEOPLE")) n = int(random(1, 1 + Object2D_PEOPLE_Files_Num));
    else if (t.equals("TREES")) n = int(random(1 + Object2D_PEOPLE_Files_Num, 1 + Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num));
  }

  //println(t, n);
  
  int d = 1; 
  int r = int(random(2));
  if (r == 0) d = -1; 

  int[] TempObject2D_MAP = {d * n}; 
  allObject2D_MAP = concat(allObject2D_MAP, TempObject2D_MAP);
  
  float[][] TempObject2D_XYZS = {{x, y, z, s}};
  allObject2D_XYZS = (float[][]) concat(allObject2D_XYZS, TempObject2D_XYZS);
  
  allObject2D_num += 1;
}



PImage[] Object2DImages;
float[] Object2DImageRatios;

void SOLARCHVISION_LoadObject2DImages () {

  Object2D_ImagePath = new String [1];
  Object2D_ImagePath[0] = "";
  
  String[] Object2D_Filenames_PEOPLE = sort(getfiles(Object2DFolder_PEOPLE));
  String[] Object2D_Filenames_TREES = sort(getfiles(Object2DFolder_TREES));  

  Object2D_ImagePath = concat(Object2D_ImagePath, Object2D_Filenames_PEOPLE);
  Object2D_ImagePath = concat(Object2D_ImagePath, Object2D_Filenames_TREES);
  
  Object2D_PEOPLE_Files_Num = Object2D_Filenames_PEOPLE.length;
  Object2D_TREES_Files_Num = Object2D_Filenames_TREES.length;

  
  int n = Object2D_ImagePath.length;
  
  Object2DImages = new PImage [n + 1];
  Object2DImageRatios = new float [n + 1];
 
  for (int i = 1; i < n; i += 1) { // leaving [0] null  

    if (i <= Object2D_PEOPLE_Files_Num) {
      Object2D_ImagePath[i] = Object2DFolder_PEOPLE + "/" + Object2D_ImagePath[i];
    }
    else {
      Object2D_ImagePath[i] = Object2DFolder_TREES + "/" + Object2D_ImagePath[i];
    }
  }
  
  for (int i = 1; i < n; i += 1) {
    //println(Object2D_ImagePath[i]);
    Object2DImages[i] = loadImage(Object2D_ImagePath[i]);
    
    if (Object2DImages[i].height != 0) {
      Object2DImageRatios[i] = float(Object2DImages[i].width) / float(Object2DImages[i].height);
    }
    else {
      Object2DImageRatios[i] = 1;
    }
  }  
}



void SOLARCHVISION_LoadWorldImages () {

  WORLD_VIEW_Filenames = sort(getfiles(WorldViewFolder));

  number_of_WORLD_viewports = WORLD_VIEW_Filenames.length;

  WORLD_VIEW_Name = new String [number_of_WORLD_viewports][2];
  
  WORLD_VIEW_BoundariesX = new float [number_of_WORLD_viewports][2];
  WORLD_VIEW_BoundariesY = new float [number_of_WORLD_viewports][2];
    
  WORLD_VIEW_GridDisplay = new int [number_of_WORLD_viewports];

  for (int i = 0; i < number_of_WORLD_viewports; i += 1) {
    String MapFilename = WorldViewFolder + "/" + WORLD_VIEW_Filenames[i];
    
    String[] Parts = split(WORLD_VIEW_Filenames[i], '_');
    
    WORLD_VIEW_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
    WORLD_VIEW_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
    WORLD_VIEW_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
    WORLD_VIEW_BoundariesY[i][1] =  float(Parts[4]) * 0.001;
    
    WORLD_VIEW_Name[i][0] = Parts[5];
    WORLD_VIEW_Name[i][1] = Parts[6];
    
    float a = (WORLD_VIEW_BoundariesY[i][1] - WORLD_VIEW_BoundariesY[i][0]) / 2;
    if (a < 1) a = 1;
    WORLD_VIEW_GridDisplay[i] = int(a);
    
  }
}





int FindGoodViewport (float pointLongitude, float pointLatitude) {
  
  int return_VIEWPORT = WORLD_VIEW_Number;
  
  if (WORLD_VIEW_Auto == 1) {
  
    float d1 = FLOAT_undefined;
    float d2 = FLOAT_undefined;
    
    for (int i = 0; i < number_of_WORLD_viewports; i++) {

      int check_it = 0; 

      String started_with = WORLD_VIEW_Filenames[i].substring(0, 1);
      
      if (WORLD_viewport_ZOOM == 1) {
        if (started_with.equals("A")) check_it = 1;
      }
      else if (WORLD_viewport_ZOOM == 2) {
        if (started_with.equals("B")) check_it = 1;
      }
      else if (WORLD_viewport_ZOOM == 3) {
        if (started_with.equals("C")) check_it = 1;
      }
      else if (WORLD_viewport_ZOOM == 4) {
        if (started_with.equals("D")) check_it = 1;
      }
      else if (WORLD_viewport_ZOOM == 5) {
        if (started_with.equals("E")) check_it = 1;
      }
      else {
        check_it = 1;
      }

      if (check_it == 1) {  
      
        if (isInside(pointLongitude, pointLatitude, WORLD_VIEW_BoundariesX[i][0], WORLD_VIEW_BoundariesY[i][0], WORLD_VIEW_BoundariesX[i][1], WORLD_VIEW_BoundariesY[i][1]) == 1) {
          float d_Center = dist(pointLongitude, pointLatitude, 0.5 * (WORLD_VIEW_BoundariesX[i][0] + WORLD_VIEW_BoundariesX[i][1]), 0.5 * (WORLD_VIEW_BoundariesY[i][0] + WORLD_VIEW_BoundariesY[i][1]));
          float d_Size = dist(WORLD_VIEW_BoundariesX[i][0], WORLD_VIEW_BoundariesY[i][0], WORLD_VIEW_BoundariesX[i][1], WORLD_VIEW_BoundariesY[i][1]);
          
          if (d2 > 0.95 * d_Size) {
            if (d1 > d_Center) {
              d1 = d_Center;
              d2 = d_Size;
              
              return_VIEWPORT = i;
            }
          }
        }
      }
    }
  }
  
  if (return_VIEWPORT != WORLD_VIEW_Number) {
    Load_WORLDViewImage(return_VIEWPORT);
    
    if (Display_EARTH3D != 0) WIN3D_Update = 1;    
  }

  return (return_VIEWPORT);
}


PImage WORLDViewImage;

void Load_WORLDViewImage (int n) {

  println("Loading:", WorldViewFolder + "/" + WORLD_VIEW_Filenames[n]);
  
  WORLDViewImage = loadImage(WorldViewFolder + "/" + WORLD_VIEW_Filenames[n]);
  


}




String StationICAO;
String StationType;

float StationLatitude;
float StationLongitude;
float StationElevation;

int STATION_SWOB_NUMBER = 0;
String[][] STATION_SWOB_INFO;

void SOLARCHVISION_getSWOB_Coordinates () {
  try {
    String[] FileALL = loadStrings(SWOBFolder + "/SWOB_UTF8.txt");
  
    String lineSTR;
    String[] input;
  
    STATION_SWOB_NUMBER = FileALL.length - 1; // to skip the first description line 
  
    STATION_SWOB_INFO = new String [STATION_SWOB_NUMBER][12]; 
  
    int n_Locations = 0;
  
    for (int f = 0; f < STATION_SWOB_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  
  
      String StationNameEnglish = "";
      String StationNameFrench = "";
      String StationProvince = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationICAO = "";
      String StationWMO = ""; 
      String StationClimate = "";
      String StationDST = ""; //Daylight saving time
      String StationSTD = ""; //Standard Time      
      String StationType = ""; // MAN/AUTO
  
      String[] parts = split(lineSTR, '\t');
  
      if (12 < parts.length) {
        
        StationNameFrench = parts[1];
        StationNameEnglish = parts[2];
        StationProvince = parts[3];
        
        StationType = parts[4];
        if (StationType.equals("Manned")) StationType = "MAN";
        if (StationType.equals("Auto")) StationType = "AUTO";
    
        StationLatitude = float(parts[5]);
        StationLongitude = float(parts[6]);
        StationElevation = float(parts[7]);
    
        StationICAO = parts[8];
        StationWMO = parts[9];
        StationClimate = parts[10];
        StationDST = parts[11];
        StationSTD = parts[12]; 
    
        STATION_SWOB_INFO[n_Locations][0] = StationNameEnglish;
        STATION_SWOB_INFO[n_Locations][1] = StationNameFrench;
        STATION_SWOB_INFO[n_Locations][2] = StationProvince;
        STATION_SWOB_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_SWOB_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_SWOB_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_SWOB_INFO[n_Locations][6] = StationICAO;
        STATION_SWOB_INFO[n_Locations][7] = StationWMO;
        STATION_SWOB_INFO[n_Locations][8] = StationClimate;
        STATION_SWOB_INFO[n_Locations][9] = StationDST;
        STATION_SWOB_INFO[n_Locations][10] = StationSTD;
        STATION_SWOB_INFO[n_Locations][11] = StationType;
  
        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading SWOB coordinates.");
  }
}



int STATION_NAEFS_NUMBER = 0;
String[][] STATION_NAEFS_INFO;

void SOLARCHVISION_getNAEFS_Coordinates () {
  try {
    String[] FileALL = loadStrings(NAEFSFolder + "/NAEFS_UTF8.txt");
  
    String lineSTR;
    String[] input;
  
    STATION_NAEFS_NUMBER = FileALL.length - 1; // to skip the first description line 
  
    STATION_NAEFS_INFO = new String [STATION_NAEFS_NUMBER][7]; 
  
    int n_Locations = 0;
  
    for (int f = 0; f < STATION_NAEFS_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  
  
      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";      
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationFilename = "";
  
      String[] parts = split(lineSTR, '\t');
  
      if (3 < parts.length) {

        StationFilename = parts[0];
        
        StationNameEnglish = split(StationFilename, '_')[0];
        StationProvince = split(StationFilename, '_')[1];
        StationCountry = split(StationFilename, '_')[2];
    
        int l = 0;
        
        l = parts[1].length();
        if (((parts[1].substring(l - 1, l)).equals("N")) || ((parts[1].substring(l - 1, l)).equals("S"))) {
          String[] the_parts = split(parts[1], ':');
          StationLatitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
          if ((parts[1].substring(l - 1, l)).equals("S")) StationLatitude *= -1;
        }
        else {
          StationLatitude = float(parts[1]);
        }
  
        l = parts[2].length();
        if (((parts[2].substring(l - 1, l)).equals("E")) || ((parts[2].substring(l - 1, l)).equals("W"))) {
          String[] the_parts = split(parts[2], ':');
          StationLongitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
          if ((parts[2].substring(l - 1, l)).equals("W")) StationLongitude *= -1;
        }
        else {
          StationLongitude = float(parts[2]);
        }
  
        l = parts[3].length();
        StationElevation = float(parts[3].substring(0, l - 1));
    
        STATION_NAEFS_INFO[n_Locations][0] = StationNameEnglish;
        STATION_NAEFS_INFO[n_Locations][1] = StationProvince;
        STATION_NAEFS_INFO[n_Locations][2] = StationCountry;        
        STATION_NAEFS_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_NAEFS_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_NAEFS_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_NAEFS_INFO[n_Locations][6] = StationFilename;
  
        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading NAEFS coordinates.");
  }
}


int STATION_CWEEDS_NUMBER = 0;
String[][] STATION_CWEEDS_INFO;

void SOLARCHVISION_getCWEEDS_Coordinates () {
  try {
    String[] FileALL = loadStrings(CWEEDSFolder + "/CWEEDS_UTF8.txt");
  
    String lineSTR;
    String[] input;
  
    STATION_CWEEDS_NUMBER = FileALL.length - 1; // to skip the first description line 
  
    STATION_CWEEDS_INFO = new String [STATION_CWEEDS_NUMBER][7]; 
  
    int n_Locations = 0;
  
    for (int f = 0; f < STATION_CWEEDS_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationFilename = "";
      
      String[] parts = split(lineSTR, '_');
      
      if (4 < parts.length) {
        
        StationFilename = lineSTR; 
  
        StationCountry = "CA";
        StationProvince = parts[0];
        StationNameEnglish = parts[1];
    
        
        StationLatitude = float(parts[2]) * 0.01;
        StationLongitude = float(parts[3]) * -0.01;
        StationElevation = 0; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
        STATION_CWEEDS_INFO[n_Locations][0] = StationNameEnglish;
        STATION_CWEEDS_INFO[n_Locations][1] = StationProvince;
        STATION_CWEEDS_INFO[n_Locations][2] = StationCountry;
        STATION_CWEEDS_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_CWEEDS_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_CWEEDS_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_CWEEDS_INFO[n_Locations][6] = StationFilename;
  
        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading CWEEDS coordinates.");
  }
}


int STATION_EPW_NUMBER = 0;
String[][] STATION_EPW_INFO;

void SOLARCHVISION_getEPW_Coordinates () {
  try {
    String[] FileALL = loadStrings(EPWFolder + "/EPW_UTF8.txt");
  
    String lineSTR;
    String[] input;
  
    STATION_EPW_NUMBER = FileALL.length - 1; // to skip the first description line 
  
    STATION_EPW_INFO = new String [STATION_EPW_NUMBER][9]; 
  
    int n_Locations = 0;
  
    for (int f = 0; f < STATION_EPW_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      float StationTimeZone = 0.0;      
      String StationWMO = ""; 
      String StationFilename = "";

      
      String[] parts = split(lineSTR, ',');
      
      if (10 < parts.length) {
        StationNameEnglish = parts[1];
        StationProvince = parts[2];
        StationCountry = parts[3];
        
        StationWMO = parts[5];
        
        StationLatitude = float(parts[6]);
        StationLongitude = float(parts[7]);
        StationTimeZone = 15 * float(parts[8]); 
        StationElevation = float(parts[9]);

        StationFilename = parts[10]; 
        
        STATION_EPW_INFO[n_Locations][0] = StationNameEnglish;
        STATION_EPW_INFO[n_Locations][1] = StationProvince;
        STATION_EPW_INFO[n_Locations][2] = StationCountry;
        STATION_EPW_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_EPW_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_EPW_INFO[n_Locations][5] = String.valueOf(StationElevation);      
        STATION_EPW_INFO[n_Locations][6] = String.valueOf(StationTimeZone);
        STATION_EPW_INFO[n_Locations][7] = StationWMO;
        STATION_EPW_INFO[n_Locations][8] = StationFilename;
        
        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading EPW coordinates.");
  }
}



int SOLARCHVISION_addToVertices (float x, float y, float z) {
  
  float[][] newVertex = {{x, y, z}}; 
  
  allVertices = (float[][]) concat(allVertices, newVertex);
  
  return(allVertices.length - 1);
}

int SOLARCHVISION_addToFaces (int[] f) {

  int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
  
  allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);
  
  int[][] newFace = {f}; 
  
  allFaces = (int[][]) concat(allFaces, newFace);
  
  if (addToLastPolymesh == 0) {
    SOLARCHVISION_beginNewObject();
  }
  else {
    allPolymesh_Faces[allPolymesh_Faces.length - 1][1] = allFaces.length - 1;
  }

  return(allFaces.length - 1);
}

int SOLARCHVISION_addToSolids (float v, float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz) {
  
  ParametricGeometry[] newSolidObject = {new ParametricGeometry(v, x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz)}; 
  SolidObjects = (ParametricGeometry[]) concat(SolidObjects, newSolidObject);  
  
  if (addToLastPolymesh == 0) {
    // no nead to call SOLARCHVISION_beginNewObject(); here again!
  }
  else {
    allPolymesh_Solids[allPolymesh_Solids.length - 1][1] = SolidObjects.length - 1;
  }

  return(SolidObjects.length - 1);
}

void SOLARCHVISION_beginNewObject () {
  
  if (addToLastPolymesh == 0) { 

    int[][] newObject_Solids = {{SolidObjects.length, -1}}; // i.e. null because start > end 
    
    allPolymesh_Solids = (int[][]) concat(allPolymesh_Solids, newObject_Solids);      
    
    int[][] newObject_Faces = {{allFaces.length, 0}}; // i.e. null because start > end   
    
    allPolymesh_Faces = (int[][]) concat(allPolymesh_Faces, newObject_Faces);
    
    float[][] newObject_PivotXYZ = {{0,0,0}}; 
    
    allPolymesh_SolarPivotXYZ = (float[][]) concat(allPolymesh_SolarPivotXYZ, newObject_PivotXYZ);

    int[][] newObject_Pivot = {{defaultSolarPivotType}};

    allPolymesh_SolarPivotType = (int[][]) concat(allPolymesh_SolarPivotType, newObject_Pivot);        
  }

  WIN3D_update_VerticesSolarValue = 1; // <<<<<<<
}


       
void SOLARCHVISION_duplicateSelection () {

  if (Work_with_2D_or_3D == 1) {
    
    int number_of_Fractal_before = allFractal_XYZSRA.length; 

    for (int o = 0; o < selectedFractal_numbers.length; o++) {

      int OBJ_NUM = selectedFractal_numbers[o];

      if (OBJ_NUM != 0) {    
        
        float x = allFractal_XYZSRA[OBJ_NUM][0];
        float y = allFractal_XYZSRA[OBJ_NUM][1];
        float z = allFractal_XYZSRA[OBJ_NUM][2];
        float d = allFractal_XYZSRA[OBJ_NUM][3];
        float rot = allFractal_XYZSRA[OBJ_NUM][4];
        float as_Solid = allFractal_XYZSRA[OBJ_NUM][5];
        
        int n = allFractal_Type[OBJ_NUM];
        int dMin = allFractal_DegreeMin[OBJ_NUM];
        int dMax = allFractal_DegreeMax[OBJ_NUM];
        int s = allFractal_Seed[OBJ_NUM];
        float TrunkSize = allFractal_TrunkSize[OBJ_NUM];
        float LeafSize = allFractal_LeafSize[OBJ_NUM];
        
        randomSeed(millis());
        SOLARCHVISION_add_FractalPlant(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize, as_Solid);        
      }
    }
    
    // selecting new objetcs
    
    selectedFractal_numbers = new int [1];
    selectedFractal_numbers[0] = 0;
    
    for (int o = number_of_Fractal_before; o < allFractal_XYZSRA.length; o++) {
      
      int[] newlyAddedFractal = {o};
      
      selectedFractal_numbers = concat(selectedFractal_numbers, newlyAddedFractal);
    }     
  }  

  if (Work_with_2D_or_3D == 2) {

    int n1 = Object2D_PEOPLE_Files_Num;
   
    int number_of_Object2D_before = allObject2D_XYZS.length; 

    for (int o = 0; o < selectedObject2D_numbers.length; o++) {

      int OBJ_NUM = selectedObject2D_numbers[o];

      if (OBJ_NUM != 0) {    
        
        float x = allObject2D_XYZS[OBJ_NUM][0];
        float y = allObject2D_XYZS[OBJ_NUM][1];
        float z = allObject2D_XYZS[OBJ_NUM][2];
        float s = allObject2D_XYZS[OBJ_NUM][3];
        
        int n = allObject2D_MAP[OBJ_NUM];
        
        if (abs(n) > n1) SOLARCHVISION_add_Object2D("TREES", n, x, y, z, s);
        else SOLARCHVISION_add_Object2D("PEOPLE", n, x, y, z, s);
      }
    }
    
    // selecting new objetcs
    
    selectedObject2D_numbers = new int [1];
    selectedObject2D_numbers[0] = 0;
    
    for (int o = number_of_Object2D_before; o < allObject2D_XYZS.length; o++) {
      
      int[] newlyAddedObject2D = {o};
      
      selectedObject2D_numbers = concat(selectedObject2D_numbers, newlyAddedObject2D);
    }       
  }


  if (Work_with_2D_or_3D == 3) {
    
    int SOLID_added = 0;
    
    int number_of_Polymeshes_before = allPolymesh_Faces.length;
    
    for (int o = 0; o < selectedPolymesh_numbers.length; o++) {
    
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {
        
        if ((0 < allPolymesh_Faces[OBJ_NUM][0]) && (allPolymesh_Faces[OBJ_NUM][0] <= allPolymesh_Faces[OBJ_NUM][1])) { 

          int number_of_Vertices_before = allVertices.length;
          
          addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
          
          int new_OBJ_NUM = allPolymesh_Faces.length - 1;
          
          allPolymesh_SolarPivotType[new_OBJ_NUM][0] = allPolymesh_SolarPivotType[OBJ_NUM][0];
          
          allPolymesh_SolarPivotXYZ[new_OBJ_NUM][0] = allPolymesh_SolarPivotXYZ[OBJ_NUM][0];
          allPolymesh_SolarPivotXYZ[new_OBJ_NUM][1] = allPolymesh_SolarPivotXYZ[OBJ_NUM][1];
          allPolymesh_SolarPivotXYZ[new_OBJ_NUM][2] = allPolymesh_SolarPivotXYZ[OBJ_NUM][2];
          
          if ((0 <= allPolymesh_Solids[OBJ_NUM][1]) && (allPolymesh_Solids[OBJ_NUM][0] <= allPolymesh_Solids[OBJ_NUM][1])) { 
            for (int s = allPolymesh_Solids[OBJ_NUM][0]; s <= allPolymesh_Solids[OBJ_NUM][1]; s++) {
              SOLARCHVISION_addToSolids(SolidObjects[s].value, SolidObjects[s].posX, SolidObjects[s].posY, SolidObjects[s].posZ, SolidObjects[s].powX, SolidObjects[s].powY, SolidObjects[s].powZ, SolidObjects[s].scaleX, SolidObjects[s].scaleY, SolidObjects[s].scaleZ, -SolidObjects[s].rotX, -SolidObjects[s].rotY, -SolidObjects[s].rotZ);
              
              SOLID_added += 1;
            }
          }

 
          int[] PolymeshVertices_OLD = {0}; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = {0}; // keeps the list of new vertex numbers
      
          for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
  
            if ((0 < f) && (f < allFaces.length)) {
           
              int[] newFace = {};
              
              for (int j = 0; j < allFaces[f].length; j++) {
                int vNo = allFaces[f][j];
                
                int vertex_listed = 0;
                
                for (int q = 1; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;                      
                  }
                }         
               
                if (vertex_listed == 0) {
                  int[] newVertexListed = {vNo};
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
                
                  float x = allVertices[vNo][0];
                  float y = allVertices[vNo][1];
                  float z = allVertices[vNo][2];
  
                  int[] newVertexAdded = {SOLARCHVISION_addToVertices(x, y, z)};
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
                  
                  vertex_listed = PolymeshVertices_OLD.length - 1;
                } 
                
                println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
                
                int[] new_vertexItem = {number_of_Vertices_before + vertex_listed - 1};
                
                newFace = concat(newFace, new_vertexItem); 
              }
              
              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];
              
              SOLARCHVISION_addToFaces(newFace);
              
  
            }
          }

        }
      }
    }    
    

    // selecting new objetcs
    
    selectedPolymesh_numbers = new int [1];
    selectedPolymesh_numbers[0] = 0;
    
    for (int o = number_of_Polymeshes_before; o < allPolymesh_Faces.length; o++) {
      
      int[] newlyAddedPolymesh = {o};
      
      selectedPolymesh_numbers = concat(selectedPolymesh_numbers, newlyAddedPolymesh);
    }       
  
    
    if (SOLID_added != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections();
  }




  if (Work_with_2D_or_3D == 4) {
    
    int number_of_Faces_before = allFaces.length;
    
    for (int o = 0; o < selectedFace_numbers.length; o++) {
      
      int f = selectedFace_numbers[o];        

      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;

      int number_of_Vertices_before = allVertices.length;
      
      int[] PolymeshVertices_OLD = {0}; // keeps the list of exiting vertex numbers
      int[] PolymeshVertices_NEW = {0}; // keeps the list of new vertex numbers
  
      if ((0 < f) && (f < allFaces.length)) {
     
        int[] newFace = {};
        
        for (int j = 0; j < allFaces[f].length; j++) {
          int vNo = allFaces[f][j];
          
          int vertex_listed = 0;
          
          for (int q = 1; q < PolymeshVertices_OLD.length; q++) {
            if (vNo == PolymeshVertices_OLD[q]) {
              vertex_listed = q;
              break;                      
            }
          }         
         
          if (vertex_listed == 0) {
            int[] newVertexListed = {vNo};
            PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
          
            float x = allVertices[vNo][0];
            float y = allVertices[vNo][1];
            float z = allVertices[vNo][2];

            int[] newVertexAdded = {SOLARCHVISION_addToVertices(x, y, z)};
            PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
            
            vertex_listed = PolymeshVertices_OLD.length - 1;
          } 
          
          println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
          
          int[] new_vertexItem = {number_of_Vertices_before + vertex_listed - 1};
          
          newFace = concat(newFace, new_vertexItem); 
        }
        
        defaultMaterial = allFaces_MTLV[f][0];
        defaultTessellation = allFaces_MTLV[f][1];
        defaultLayer = allFaces_MTLV[f][2];
        defaultVisibility = allFaces_MTLV[f][3];        
        
        SOLARCHVISION_addToFaces(newFace);
        

      }

    }
    
    
    // selecting new objetcs
    
    selectedFace_numbers = new int [1];
    selectedFace_numbers[0] = 0;
    
    for (int o = number_of_Faces_before; o < allFaces.length; o++) {
      
      int[] newlyAddedFace = {o};
      
      selectedFace_numbers = concat(selectedFace_numbers, newlyAddedFace);
    }      
  }    

  
  if (Work_with_2D_or_3D == 8) {
    
    int number_of_Section_before = allSection_UVERAB.length; 

    for (int o = 0; o < selectedSection_numbers.length; o++) {

      int OBJ_NUM = selectedSection_numbers[o];

      if (OBJ_NUM != 0) {    
        
        float Section_offset_U = allSection_UVERAB[OBJ_NUM][0];
        float Section_offset_V = allSection_UVERAB[OBJ_NUM][1];
        float Section_Elevation = allSection_UVERAB[OBJ_NUM][2];
        float Section_Rotation = allSection_UVERAB[OBJ_NUM][3];
        float Section_scale_U = allSection_UVERAB[OBJ_NUM][4];
        float Section_scale_V = allSection_UVERAB[OBJ_NUM][5];
  
        int Section_Type = allSection_Type[OBJ_NUM];
        int Section_RES1 = allSection_RES1[OBJ_NUM];
        int Section_RES2 = allSection_RES2[OBJ_NUM];

        SOLARCHVISION_add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);        
      }
    }
    
    // selecting new objetcs
    
    selectedSection_numbers = new int [1];
    selectedSection_numbers[0] = 0;
    
    for (int o = number_of_Section_before; o < allSection_UVERAB.length; o++) {
      
      int[] newlyAddedSection = {o};
      
      selectedSection_numbers = concat(selectedSection_numbers, newlyAddedSection);
    }     
  }  

}
       




void SOLARCHVISION_deleteSelection () {

  if (Work_with_2D_or_3D == 8) {
    
    selectedSection_numbers = sort(selectedSection_numbers);
    
    for (int o = selectedSection_numbers.length - 1; o > 0; o--) { // the first node is null 

      int OBJ_NUM = selectedSection_numbers[o];
      
      if (OBJ_NUM != 0) {    

        {
          float[][] startList = (float[][]) subset(allSection_UVERAB, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSection_UVERAB, OBJ_NUM + 1);
          
          allSection_UVERAB = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allSection_Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSection_Type, OBJ_NUM + 1);
          
          allSection_Type = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allSection_RES1, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSection_RES1, OBJ_NUM + 1);
          
          allSection_RES1 = (int[]) concat(startList, endList);
        }
        
        {
          int[] startList = (int[]) subset(allSection_RES2, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSection_RES2, OBJ_NUM + 1);
          
          allSection_RES2 = (int[]) concat(startList, endList);
        }

        {
          PImage[] startList = (PImage[]) subset(allSection_SpatialImpact, 0, OBJ_NUM);
          PImage[] endList = (PImage[]) subset(allSection_SpatialImpact, OBJ_NUM + 1);
          
          allSection_SpatialImpact = (PImage[]) concat(startList, endList);
        }
        
        {
          PImage[][] startList = (PImage[][]) subset(allSection_SolarImpact, 0, OBJ_NUM);
          PImage[][] endList = (PImage[][]) subset(allSection_SolarImpact, OBJ_NUM + 1);
          
          allSection_SolarImpact = (PImage[][]) concat(startList, endList);
        }        
    
        allSection_num -= 1;
      }

    }

  }

  
  if (Work_with_2D_or_3D == 1) {
    
    selectedFractal_numbers = sort(selectedFractal_numbers);
    
    for (int o = selectedFractal_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedFractal_numbers[o];
      
      if (OBJ_NUM != 0) {    

        {
          float[][] startList = (float[][]) subset(allFractal_XYZSRA, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allFractal_XYZSRA, OBJ_NUM + 1);
          
          allFractal_XYZSRA = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractal_Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractal_Type, OBJ_NUM + 1);
          
          allFractal_Type = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractal_DegreeMin, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractal_DegreeMin, OBJ_NUM + 1);
          
          allFractal_DegreeMin = (int[]) concat(startList, endList);
        }
        
        {
          int[] startList = (int[]) subset(allFractal_DegreeMax, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractal_DegreeMax, OBJ_NUM + 1);
          
          allFractal_DegreeMax = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractal_Seed, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractal_Seed, OBJ_NUM + 1);
          
          allFractal_Seed = (int[]) concat(startList, endList);
        }

        {
          float[] startList = (float[]) subset(allFractal_TrunkSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allFractal_TrunkSize, OBJ_NUM + 1);
          
          allFractal_TrunkSize = (float[]) concat(startList, endList);
        }

        {
          float[] startList = (float[]) subset(allFractal_LeafSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allFractal_LeafSize, OBJ_NUM + 1);
          
          allFractal_LeafSize = (float[]) concat(startList, endList);
        }
    
        allFractal_num -= 1;
      }

    }
    
  }
  
  
  if (Work_with_2D_or_3D == 2) {
    
    selectedObject2D_numbers = sort(selectedObject2D_numbers);
    
    for (int o = selectedObject2D_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedObject2D_numbers[o];
      
      if (OBJ_NUM != 0) {    

        {
          float[][] startList = (float[][]) subset(allObject2D_XYZS, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allObject2D_XYZS, OBJ_NUM + 1);
          
          allObject2D_XYZS = (float[][]) concat(startList, endList);
        }
    
        {
          int[] startList = (int[]) subset(allObject2D_MAP, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allObject2D_MAP, OBJ_NUM + 1);
          
          allObject2D_MAP = (int[]) concat(startList, endList);
        }   
        
        allObject2D_num -= 1;
      }

    }
    
  }


  int[] keep_selectedVertex_numbers = {0};
  if (Work_with_2D_or_3D == 3) {

    SOLARCHVISION_convertPolymesh2Vertex(); // finding & then keeping objects vertices so that we could delete the isolated ones later  
    keep_selectedVertex_numbers = selectedVertex_numbers;

    selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
    
    int Solids_updated = 0;  

    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {
      
        int startFace = allPolymesh_Faces[OBJ_NUM][0];
        int endFace = allPolymesh_Faces[OBJ_NUM][1];
        
        {
          float[][] startList = (float[][]) subset(allPolymesh_SolarPivotXYZ, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allPolymesh_SolarPivotXYZ, OBJ_NUM + 1);
          
          allPolymesh_SolarPivotXYZ = (float[][]) concat(startList, endList);
        } 

        {
          int[][] startList = (int[][]) subset(allPolymesh_SolarPivotType, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allPolymesh_SolarPivotType, OBJ_NUM + 1);
          
          allPolymesh_SolarPivotType = (int[][]) concat(startList, endList);
        } 

          
        {
        
          if (startFace <= endFace) {
          
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] -= 1 + endFace - startFace;
              }
            }  
          }  
          
          int[][] startList = (int[][]) subset(allPolymesh_Faces, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allPolymesh_Faces, OBJ_NUM + 1);
          
          allPolymesh_Faces = (int[][]) concat(startList, endList);
        }  
       
        {
          int[][] startList = (int[][]) subset(allFaces, 0, startFace);
          int[][] endList = (int[][]) subset(allFaces, endFace + 1);
          
          allFaces = (int[][]) concat(startList, endList);
        }
        
        {
          int[][] startList = (int[][]) subset(allFaces_MTLV, 0, startFace);
          int[][] endList = (int[][]) subset(allFaces_MTLV, endFace + 1);
          
          allFaces_MTLV = (int[][]) concat(startList, endList);          
        }
        
        
        
        int startSolid = allPolymesh_Solids[OBJ_NUM][0];
        int endSolid = allPolymesh_Solids[OBJ_NUM][1];
        
        {
          
          if (startSolid <= endSolid) {
            for (int i = OBJ_NUM + 1; i < allPolymesh_Solids.length; i++) {
            
              for (int j = 0; j < 2; j++) {
                allPolymesh_Solids[i][j] -= 1 + endSolid - startSolid;
              }
            }    
          }
          
          int[][] startList = (int[][]) subset(allPolymesh_Solids, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allPolymesh_Solids, OBJ_NUM + 1);
          
          allPolymesh_Solids = (int[][]) concat(startList, endList);
        }  
    
        
        if ((0 <= startSolid) && (startSolid <= endSolid)) {
          
          ParametricGeometry[] startList = (ParametricGeometry[]) subset(SolidObjects, 0, startSolid);
          ParametricGeometry[] endList = (ParametricGeometry[]) subset(SolidObjects, endSolid + 1);
          
          SolidObjects = (ParametricGeometry[]) concat(startList, endList);
          
          Solids_updated = 1;
          
        }

      }
    }
    
    if (Solids_updated != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections();
    
    WIN3D_update_VerticesSolarValue = 1;

  }

  if ((Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { // note that for deleting vertices we should first delete the faces that have those vertices...
    
    if (Work_with_2D_or_3D == 5) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);
      
      SOLARCHVISION_convertVertex2Face(); 
      
    }
    
    selectedFace_numbers = sort(selectedFace_numbers);

    SOLARCHVISION_convertFace2Polymesh();    

    selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] -= 1;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] -= 1; // because deleting a face also changes the end pointer of the same object 

            {
              int[][] startList = (int[][]) subset(allFaces, 0, f);
              int[][] endList = (int[][]) subset(allFaces, f + 1);
              
              allFaces = (int[][]) concat(startList, endList);
            }
              
            {
              int[][] startList = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] endList = (int[][]) subset(allFaces_MTLV, f + 1);
              
              allFaces_MTLV = (int[][]) concat(startList, endList);          
            }      

            { // to avoid deleting the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }
 
          }
  
        }

      }
    }
    
    WIN3D_update_VerticesSolarValue = 1;
    
  }
  
  if (Work_with_2D_or_3D == 5) { // note that for deleting vertices we first deleted the faces that have those vertices above 
    
    selectedVertex_numbers = sort(selectedVertex_numbers);

    for (int q = selectedVertex_numbers.length - 1; q > 0; q--) { // the first node is null

      int vNo = selectedVertex_numbers[q];
      
      {
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);
        
        allVertices = (float[][]) concat(startList, endList);
      }
      
      for (int i = 1; i < allFaces.length; i++) { // the first node is null
        for (int j = 0; j < allFaces[i].length; j++) {
          if (allFaces[i][j] > vNo) {
            
            allFaces[i][j] -= 1;
          }
        }
      }
      
    } 
  }


  SOLARCHVISION_deselectAll();
  
  if (Work_with_2D_or_3D == 3) {
    
    selectedVertex_numbers = keep_selectedVertex_numbers;
    
    SOLARCHVISION_deleteIsolatedVerticesSelection(); // <<<<<<
  }  


}

void SOLARCHVISION_deleteIsolatedVerticesSelection () {

  selectedVertex_numbers = sort(selectedVertex_numbers);
  
  for (int q = selectedVertex_numbers.length - 1; q > 0; q--) { // the first node is null
  
    int vNo = selectedVertex_numbers[q];
  
    int found = -1;
  
    for (int i = 1; i < allFaces.length; i++) { // the first node is null
      for (int j = 0; j < allFaces[i].length; j++) {
        if (allFaces[i][j] == vNo) {
          found = 1;
        }
      }
    }
    
    if (found == -1) {
      {
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);
        
        allVertices = (float[][]) concat(startList, endList);
      }
      
      for (int i = 1; i < allFaces.length; i++) { // the first node is null
        for (int j = 0; j < allFaces[i].length; j++) {
          if (allFaces[i][j] > vNo) {
            
            allFaces[i][j] -= 1;

          }
        }
      }
    }
    
    
    WIN3D_update_VerticesSolarValue = 1;  
  } 

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;  
  
  println("SOLARCHVISION_calculate_selection_Pivot 29");
  SOLARCHVISION_calculate_selection_Pivot();

}

void SOLARCHVISION_deleteIsolatedVerticesScene () {

  for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null
  
    int found = -1;
  
    for (int i = 1; i < allFaces.length; i++) { // the first node is null
      for (int j = 0; j < allFaces[i].length; j++) {
        if (allFaces[i][j] == vNo) {
          found = 1;
        }
      }
    }
    
    if (found == -1) {
      {
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);
        
        allVertices = (float[][]) concat(startList, endList);
      }
      
      for (int i = 1; i < allFaces.length; i++) { // the first node is null
        for (int j = 0; j < allFaces[i].length; j++) {
          if (allFaces[i][j] > vNo) {
            
            allFaces[i][j] -= 1;

          }
        }
      }
    }
    
    
    WIN3D_update_VerticesSolarValue = 1;  
  } 

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;  
  
  println("SOLARCHVISION_calculate_selection_Pivot 30");
  SOLARCHVISION_calculate_selection_Pivot();

}


void SOLARCHVISION_selectIsolatedVertices () {
  
  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;  

  for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null
  
    int found = -1;
  
    for (int i = 1; i < allFaces.length; i++) { // the first node is null
      for (int j = 0; j < allFaces[i].length; j++) {
        if (allFaces[i][j] == vNo) {
          found = 1;
        }
      }
    }
    
    if (found == -1) {
      
      int[] newIsolatedVertex = {vNo};
      
      selectedVertex_numbers = concat(selectedVertex_numbers, newIsolatedVertex);


      WIN3D_update_VerticesSolarValue = 1; 
    }
  } 

  Work_with_2D_or_3D = 5; 
  BAR_b_Update = 1;
  
  println("SOLARCHVISION_calculate_selection_Pivot 31");
  SOLARCHVISION_calculate_selection_Pivot();      
}



void SOLARCHVISION_selectNearVertices () {
  
  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 

    if (Work_with_2D_or_3D == 3) { 

      SOLARCHVISION_convertPolymesh2Vertex();    
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      SOLARCHVISION_convertFace2Vertex(); 
      
    }
    
    selectedVertex_numbers = sort(selectedVertex_numbers);
    
    int[] pre_selectedVertex_numbers = selectedVertex_numbers;
    
    for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null 

      int isNearEnough = -1;

      for (int i = 1; i < pre_selectedVertex_numbers.length; i++) { // the first node is null

        int q = pre_selectedVertex_numbers[i];
        
        int found = -1;
        
        for (int j = 0; j < selectedVertex_numbers.length; j++) {
          
          if (vNo == selectedVertex_numbers[j]) {
            
            found = 1;

            break;
          }
        } 
        
        if (found == -1) { 
          
          float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
          
          if (d <= Modify_Input_WeldTreshold) { 

            isNearEnough = 1;
            
            break;
          }
        }
      }
      
      if (isNearEnough == 1) {
        
        int[] newVertex_number = {vNo};
        
        selectedVertex_numbers = concat(selectedVertex_numbers, newVertex_number);
      }

    } 

    println("SOLARCHVISION_calculate_selection_Pivot 32");
    SOLARCHVISION_calculate_selection_Pivot();
  } 
}



void SOLARCHVISION_weldSceneVerticesSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 

    if (Work_with_2D_or_3D == 3) { 

      SOLARCHVISION_convertPolymesh2Vertex();    
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      SOLARCHVISION_convertFace2Vertex(); 
      
    }
    
    selectedVertex_numbers = sort(selectedVertex_numbers);
  
    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];
    
      int found = -1;
    
      for (int i = 1; i < allFaces.length; i++) { // the first node is null
        for (int j = 0; j < allFaces[i].length; j++) {
          
          int q = allFaces[i][j];
          
          if (q > vNo) { // it is faster than (q != vNo)
          
            float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
            
            if (d <= Modify_Input_WeldTreshold) { 
            
              allFaces[i][j] = vNo;

              found = q;
            }
          }
        }
      }
      
      if (found != -1) {
        
        int q = found;

        {
          float[][] startList = (float[][]) subset(allVertices, 0, q);
          float[][] endList = (float[][]) subset(allVertices, q + 1);
          
          allVertices = (float[][]) concat(startList, endList);
        }
        
        for (int i = 1; i < allFaces.length; i++) { // the first node is null
          for (int j = 0; j < allFaces[i].length; j++) {
            if (allFaces[i][j] > q) {
              
              allFaces[i][j] -= 1;
            }
          }
        }
      }
      
    } 
  
    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  
  
    println("SOLARCHVISION_calculate_selection_Pivot 33");
    SOLARCHVISION_calculate_selection_Pivot();
  }
}



void SOLARCHVISION_weldObjectsVerticesSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 

    if (Work_with_2D_or_3D == 3) { 

      SOLARCHVISION_convertPolymesh2Vertex();    
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      SOLARCHVISION_convertFace2Vertex(); 
      
    }
    
    SOLARCHVISION_convertVertex2Face();
    
    selectedVertex_numbers = sort(selectedVertex_numbers);
    
    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];
      
      int found = -1;
    
      for (int m = o - 1; m > 0; m--) { // the first node is null 
          
        int q = selectedVertex_numbers[m];

        float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
        
        if (d <= Modify_Input_WeldTreshold) { 
          
          for (int i = 1; i < selectedFace_numbers.length; i++) { // the first node is null
           int f = selectedFace_numbers[i];
          
            for (int j = 0; j < allFaces[f].length; j++) {
              if (allFaces[f][j] == q) {
                
                allFaces[f][j] = vNo;
                
                found = q;
              }
            }
          }
        }
      }
      
      if (found != -1) {
        
        int q = found;

        {
          float[][] startList = (float[][]) subset(allVertices, 0, q);
          float[][] endList = (float[][]) subset(allVertices, q + 1);
          
          allVertices = (float[][]) concat(startList, endList);
        }
        
        for (int i = 1; i < allFaces.length; i++) { // the first node is null
          for (int j = 0; j < allFaces[i].length; j++) {
            if (allFaces[i][j] > q) {
              
              allFaces[i][j] -= 1;
            }
          }
        }
      }      
    } 
  
    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  
  
    println("SOLARCHVISION_calculate_selection_Pivot 34");
    SOLARCHVISION_calculate_selection_Pivot();
  }
}



void SOLARCHVISION_repositionVerticesSelection () {

  if (Work_with_2D_or_3D == 5) { 
   
    SOLARCHVISION_calculate_selection_BoundingBox();
    
    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];

      allVertices[vNo][0] = selection_BoundingBox[1][0]; // center
      allVertices[vNo][1] = selection_BoundingBox[1][1]; // center
      allVertices[vNo][2] = selection_BoundingBox[1][2]; // center

    } 
    
    println("SOLARCHVISION_calculate_selection_Pivot 35");
    SOLARCHVISION_calculate_selection_Pivot();
  }
}



void SOLARCHVISION_separateVerticesSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 

    if (Work_with_2D_or_3D == 3) { 

      SOLARCHVISION_convertPolymesh2Vertex();    
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      SOLARCHVISION_convertFace2Vertex(); 
      
    }
    
    selectedVertex_numbers = sort(selectedVertex_numbers);
  
    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];
    
      for (int i = 1; i < allFaces.length; i++) { // the first node is null
        for (int j = 0; j < allFaces[i].length; j++) {
          
          if (allFaces[i][j] == vNo) { 
          
            allFaces[i][j] = SOLARCHVISION_addToVertices(allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]); 
          
          }
        }
      }
    } 
  
    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  
  
    println("SOLARCHVISION_calculate_selection_Pivot 36");
    SOLARCHVISION_calculate_selection_Pivot();
  }
}



void SOLARCHVISION_inserCornerOpenningsSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += allFaces[f].length;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += allFaces[f].length; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += allFaces[f].length;
              }
            }              


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              float[][] new_Vertices = new float [allFaces[f].length][3];
            
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  
                  new_Vertices[i][j] = pow(Modify_Input_OpenningArea, 0.5) * base_Vertices[i][j] + (1 - pow(Modify_Input_OpenningArea, 0.5)) * G_face[j];
                }
              }
              
              int[] new_Vertex_numbers = new int [allFaces[f].length];
              
              for(int s = 0; s < allFaces[f].length; s++) {
                
                new_Vertex_numbers[s] = SOLARCHVISION_addToVertices(new_Vertices[s][0], new_Vertices[s][1], new_Vertices[s][2]); 
              } 
            
              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];              
            
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;

                int[][] newFace = {{new_Vertex_numbers[s], allFaces[f][s], allFaces[f][s_next], new_Vertex_numbers[s_next]}};
                int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);           
              }
    
                       
              { // modifying the base face to shape the openning  
                for(int s = 0; s < allFaces[f].length; s++) {
                  allFaces[f][s] = new_Vertex_numbers[s];
                }
              } 
              
            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    
    
    selectedFace_numbers = new_selectedFace_numbers;
    
    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 37");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }  
  
}


void SOLARCHVISION_insertParallelOpenningsSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += 2 * allFaces[f].length;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += 2 * allFaces[f].length; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += 2 * allFaces[f].length;
              }
            }              


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              
              float[][] new_A_EdgeVertices = new float [allFaces[f].length][3];
              float[][] new_B_EdgeVertices = new float [allFaces[f].length][3];
              float[][] new_CenterVertices = new float [allFaces[f].length][3];
            
              for(int s = 0; s < allFaces[f].length; s++) {

                int s_prev = (s + allFaces[f].length - 1) % allFaces[f].length;
                int s_next = (s + 1) % allFaces[f].length;
                
                for (int j = 0; j < 3; j++) {
                  
                  new_A_EdgeVertices[s][j] = Modify_Input_OpenningDeviation * base_Vertices[s][j] + (1 - Modify_Input_OpenningDeviation) * 0.5 * (base_Vertices[s_prev][j] + base_Vertices[s][j]);
                  new_B_EdgeVertices[s][j] = Modify_Input_OpenningDeviation * base_Vertices[s][j] + (1 - Modify_Input_OpenningDeviation) * 0.5 * (base_Vertices[s_next][j] + base_Vertices[s][j]);
                  
                  new_CenterVertices[s][j] = pow(Modify_Input_OpenningArea, 0.5) * base_Vertices[s][j] + (1 - pow(Modify_Input_OpenningArea, 0.5)) * G_face[j];
                }
              }
              
              int[] new_A_EdgeVertex_numbers = new int [allFaces[f].length]; // on the edge (1/3)
              int[] new_B_EdgeVertex_numbers = new int [allFaces[f].length]; // on the other edge (2/3)
              int[] new_CenterVertex_numbers = new int [allFaces[f].length]; // in the center
              
              for(int s = 0; s < allFaces[f].length; s++) {
                
                new_A_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_A_EdgeVertices[s][0], new_A_EdgeVertices[s][1], new_A_EdgeVertices[s][2]); 
                new_B_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_B_EdgeVertices[s][0], new_B_EdgeVertices[s][1], new_B_EdgeVertices[s][2]);
                new_CenterVertex_numbers[s] = SOLARCHVISION_addToVertices(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              }               
              

            
              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];
            
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;
                
                {
                  int[][] newFace = {{allFaces[f][s], new_B_EdgeVertex_numbers[s], new_CenterVertex_numbers[s], new_A_EdgeVertex_numbers[s]}};
                  int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                }   
        
                {
                  int[][] newFace = {{new_B_EdgeVertex_numbers[s], new_A_EdgeVertex_numbers[s_next], new_CenterVertex_numbers[s_next], new_CenterVertex_numbers[s]}};
                  int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                }                 
              }
    
                       
              { // modifying the base face to shape the openning  
                for(int s = 0; s < allFaces[f].length; s++) {
                  allFaces[f][s] = new_CenterVertex_numbers[s];
                }
              } 
              
            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    
    selectedFace_numbers = new_selectedFace_numbers;
    
    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 38");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }  
  
}



void SOLARCHVISION_insertRotatedOpenningsSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += allFaces[f].length;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += allFaces[f].length; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += allFaces[f].length;
              }
            }              


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              float[][] new_EdgeVertices = new float [allFaces[f].length][3];
              float[][] new_CenterVertices = new float [allFaces[f].length][3];
            
              for(int s = 0; s < allFaces[f].length; s++) {

                int s_prev = (s + allFaces[f].length - 1) % allFaces[f].length;
                
                for (int j = 0; j < 3; j++) {
                  
                  new_EdgeVertices[s][j] = Modify_Input_OpenningDeviation * base_Vertices[s][j] + (1 - Modify_Input_OpenningDeviation) * base_Vertices[s_prev][j];
                  
                  new_CenterVertices[s][j] = pow(Modify_Input_OpenningArea, 0.5) * new_EdgeVertices[s][j] + (1 - pow(Modify_Input_OpenningArea, 0.5)) * G_face[j];
                }
              }
              
              int[] new_EdgeVertex_numbers = new int [allFaces[f].length]; // on the edge
              int[] new_CenterVertex_numbers = new int [allFaces[f].length]; // in the center
              
              for(int s = 0; s < allFaces[f].length; s++) {
                
                new_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
                new_CenterVertex_numbers[s] = SOLARCHVISION_addToVertices(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              } 
              
              
            
              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];
              
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;

                int[][] newFace = {{new_EdgeVertex_numbers[s], allFaces[f][s], new_EdgeVertex_numbers[s_next], new_CenterVertex_numbers[s_next], new_CenterVertex_numbers[s]}};
                int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);           
              }
    
                       
              { // modifying the base face to match new center face
                for(int s = 0; s < allFaces[f].length; s++) {
                  allFaces[f][s] = new_CenterVertex_numbers[s];
                }
              } 
              
            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    
    
    selectedFace_numbers = new_selectedFace_numbers;
    
    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 39");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }    
}


void SOLARCHVISION_insertEdgeOpenningsSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += allFaces[f].length;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += allFaces[f].length; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += allFaces[f].length;
              }
            }              


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              float[][] new_EdgeVertices = new float [allFaces[f].length][3];
            
              for(int s = 0; s < allFaces[f].length; s++) {

                int s_prev = (s + allFaces[f].length - 1) % allFaces[f].length;
                
                for (int j = 0; j < 3; j++) {
                  
                  new_EdgeVertices[s][j] = Modify_Input_OpenningDeviation * base_Vertices[s][j] + (1 - Modify_Input_OpenningDeviation) * base_Vertices[s_prev][j];

                }
              }
              
              int[] new_EdgeVertex_numbers = new int [allFaces[f].length]; // on the edge
              
              for(int s = 0; s < allFaces[f].length; s++) {
                
                new_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
              } 
              
              
            
              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];
            
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;

                int[][] newFace = {{new_EdgeVertex_numbers[s], allFaces[f][s], new_EdgeVertex_numbers[s_next]}};
                int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);           
              }
    
                       
              { // modifying the base face to match new center face
                for(int s = 0; s < allFaces[f].length; s++) {
                  allFaces[f][s] = new_EdgeVertex_numbers[s];
                }
              } 
              
            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    
    
    selectedFace_numbers = new_selectedFace_numbers;
    
    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 40");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }    
}


void SOLARCHVISION_tessellateRowsColumnsFaceSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            if (allFaces[f].length == 4) {
            
              for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
                for (int j = 0; j < 2; j++) {
                  allPolymesh_Faces[i][j] += Modify_Input_TessellateRows * Modify_Input_TessellateColumns - 1;
                }
              }  
              allPolymesh_Faces[OBJ_NUM][1] += Modify_Input_TessellateRows * Modify_Input_TessellateColumns - 1; // because adding the faces also changes the end pointer of the same object 
  
              for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
                if (new_selectedFace_numbers[p] > f) {  
                  new_selectedFace_numbers[p] += Modify_Input_TessellateRows * Modify_Input_TessellateColumns - 1;
                }
              }             
  
  
              int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
              int[][] midList_Faces = new int [0][0];
              int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
              
              
              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = new int [0][0];
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);
  
              { 
                float[][] base_Vertices = new float [allFaces[f].length][3];
  
                for(int i = 0; i < allFaces[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                  }
                }
                
    
                
                float[][] new_EdgeVertices = new float [(Modify_Input_TessellateRows + 1) * (Modify_Input_TessellateColumns + 1)][3];
              
                for (int i = 0; i <= Modify_Input_TessellateRows; i++) {
                  
                  for (int j = 0; j <= Modify_Input_TessellateColumns; j++) {
                    
                    int s = i * (Modify_Input_TessellateColumns + 1) + j;

                    for (int k = 0; k < 3; k++) {
                      
                      float u = i / float(Modify_Input_TessellateRows);
                      float v = j / float(Modify_Input_TessellateColumns);
                      
                      new_EdgeVertices[s][k] = Bilinear(base_Vertices[0][k], base_Vertices[1][k], base_Vertices[2][k], base_Vertices[3][k], u, v);
  
                    }
                  }
                }
                
                int[] new_EdgeVertex_numbers = new int [(Modify_Input_TessellateRows + 1) * (Modify_Input_TessellateColumns + 1)]; // on the edge
                
                for (int i = 0; i <= Modify_Input_TessellateRows; i++) {
                  
                  for (int j = 0; j <= Modify_Input_TessellateColumns; j++) {
                    
                    int s = i * (Modify_Input_TessellateColumns + 1) + j;
                  
                    if ((i == 0) && (j == 0)) {
                      new_EdgeVertex_numbers[s] = allFaces[f][0];
                    }
                    else if ((i == Modify_Input_TessellateRows) && (j == 0)) {
                      new_EdgeVertex_numbers[s] = allFaces[f][1];
                    }
                    else if ((i == Modify_Input_TessellateRows) && (j == Modify_Input_TessellateColumns)) {
                      new_EdgeVertex_numbers[s] = allFaces[f][2];
                    }
                    else if ((i == 0) && (j == Modify_Input_TessellateColumns)) {
                      new_EdgeVertex_numbers[s] = allFaces[f][3];
                    }                    
                    else {
                      new_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                    } 
                  } 
                }
                          
  
                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];
             
                for (int i = 0; i < Modify_Input_TessellateRows; i++) {
                  
                  for (int j = 0; j < Modify_Input_TessellateColumns; j++) {
                    
                    int s = i * Modify_Input_TessellateColumns + j;  // number of face
                    
                    // number of vertices
                    int s00 = i * (Modify_Input_TessellateColumns + 1) + j; 
                    int s01 = s00 + 1;
                    int s10 = s00 + (Modify_Input_TessellateColumns + 1);
                    int s11 = s00 + (Modify_Input_TessellateColumns + 1) + 1;
    
                    int[][] newFace = {{new_EdgeVertex_numbers[s00], new_EdgeVertex_numbers[s10], new_EdgeVertex_numbers[s11], new_EdgeVertex_numbers[s01]}};
                    int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
                  
                    midList_Faces = (int[][]) concat(midList_Faces, newFace);
                    midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 
       
                    if (s > 0) { // the first teselated face was replaced by the base face... so only add other items
                      int[] newFace_number = {f + s}; 
                      new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);  
                    }        
                  }
                }
  
              }
             
              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  
  
              allFaces = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
    
              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              
              
                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
                
                selectedFace_numbers = (int[]) concat(startList, endList);         
              }
            }

 
          }
  
        }

      }
    }
    
    selectedFace_numbers = new_selectedFace_numbers;

    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 41");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }  
}



void SOLARCHVISION_tessellateRectangularFaceSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += allFaces[f].length - 1;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += allFaces[f].length - 1; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += allFaces[f].length - 1;
              }
            }             


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = new int [0][0];
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = new int [0][0];
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              float[][] new_EdgeVertices = new float [allFaces[f].length][3];
            
              for(int s = 0; s < allFaces[f].length; s++) {

                int s_prev = (s + allFaces[f].length - 1) % allFaces[f].length;
                
                for (int j = 0; j < 3; j++) {
                  new_EdgeVertices[s][j] = 0.5 * base_Vertices[s][j] + 0.5 * base_Vertices[s_prev][j];
                }
              }
              
              int[] new_EdgeVertex_numbers = new int [allFaces[f].length]; // on the edge
              
              for(int s = 0; s < allFaces[f].length; s++) {
                
                new_EdgeVertex_numbers[s] = SOLARCHVISION_addToVertices(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
              } 
              
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = SOLARCHVISION_addToVertices(G_face[0], G_face[1], G_face[2]); 
                        

              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];              
            
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;

                int[][] newFace = {{new_EdgeVertex_numbers[s], allFaces[f][s], new_EdgeVertex_numbers[s_next], new_CenterVertex_number}};
                int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 
      
                if (s > 0) { // the first teselated face was replaced by the base face... so only add other items
                  int[] newFace_number = {f + s}; 
                  new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);  
                }        
              }

            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    selectedFace_numbers = new_selectedFace_numbers;

    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 42");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }  
}



void SOLARCHVISION_tessellateTriangularFaceSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = selectedFace_numbers;
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
            
            for (int i = OBJ_NUM + 1; i < allPolymesh_Faces.length; i++) {
              for (int j = 0; j < 2; j++) {
                allPolymesh_Faces[i][j] += allFaces[f].length - 1;
              }
            }  
            allPolymesh_Faces[OBJ_NUM][1] += allFaces[f].length - 1; // because adding the faces also changes the end pointer of the same object 

            for (int p = new_selectedFace_numbers.length - 1; p > 0; p--) { // the first node is null
              if (new_selectedFace_numbers[p] > f) {  
                new_selectedFace_numbers[p] += allFaces[f].length - 1;
              }
            }             


            int[][] startList_Faces = (int[][]) subset(allFaces, 0, f);
            int[][] midList_Faces = new int [0][0];
            int[][] endList_Faces = (int[][]) subset(allFaces, f + 1);
            
            
            int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
            int[][] midList_Faces_MTLV = new int [0][0];
            int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

            { 
              float[][] base_Vertices = new float [allFaces[f].length][3];

              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces[f][i])][j];
                }
              }
              
              float[] G_face = {0,0,0};  
              
              for(int i = 0; i < allFaces[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces[f].length);
                }
              }
              
              
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = SOLARCHVISION_addToVertices(G_face[0], G_face[1], G_face[2]); 
                        

              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];                
            
              for(int s = 0; s < allFaces[f].length; s++) { 
                
                int s_next = (s + 1) % allFaces[f].length;

                int[][] newFace = {{allFaces[f][s], allFaces[f][s_next], new_CenterVertex_number}};
                int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
              
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 
      
                if (s > 0) { // the first teselated face was replaced by the base face... so only add other items
                  int[] newFace_number = {f + s}; 
                  new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);  
                }        
              }

            }
           
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

            allFaces = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                selectedFace_numbers[i] -= 1;
              }              
            
              int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
              int[] endList = (int[]) subset(selectedFace_numbers, q + 1);
              
              selectedFace_numbers = (int[]) concat(startList, endList);         
            }

 
          }
  
        }

      }
    }
    
    selectedFace_numbers = new_selectedFace_numbers;

    Work_with_2D_or_3D = 4; 
    BAR_b_Update = 1;
    
    println("SOLARCHVISION_calculate_selection_Pivot 43");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }
}

void SOLARCHVISION_extrudeFaceEdgesSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) { 

    if (Work_with_2D_or_3D == 3) { 
      
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);

      SOLARCHVISION_convertPolymesh2Face();    
  
      selectedFace_numbers = sort(selectedFace_numbers);
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convertFace2Polymesh();    
  
      selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
      
    }
    
    int[] new_selectedFace_numbers = {0};
    
    for (int o = selectedPolymesh_numbers.length - 1; o > 0; o--) { // the first node is null 
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {
        
        addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;

        for (int q = selectedFace_numbers.length - 1; q > 0; q--) { // the first node is null

          int f = selectedFace_numbers[q];
          
          int startFace = allPolymesh_Faces[OBJ_NUM][0];
          int endFace = allPolymesh_Faces[OBJ_NUM][1];          
          
          if ((startFace <= f) && (f <= endFace)) {
          
            float[][] base_Vertices = new float [allFaces[f].length][3];
            float[][] top_Vertices = new float [allFaces[f].length][3];
            
            for (int s = 0; s < allFaces[f].length; s++) {
              int vNo = allFaces[f][s];
              
              base_Vertices[s][0] = allVertices[vNo][0];
              base_Vertices[s][1] = allVertices[vNo][1];
              base_Vertices[s][2] = allVertices[vNo][2];
              
              top_Vertices[s][0] = allVertices[vNo][0];
              top_Vertices[s][1] = allVertices[vNo][1];
              top_Vertices[s][2] = allVertices[vNo][2];              
            }
              
            for (int s = 0; s < allFaces[f].length; s++) {
      
              int s_next = (s + 1) % allFaces[f].length;
              int s_prev = (s + allFaces[f].length - 1) % allFaces[f].length;
              
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {UV.x, UV.y, UV.z};
              W = fn_normalize(W);
    
              top_Vertices[s][0] += W[0] * Modify_Input_OpenningDepth;
              top_Vertices[s][1] += W[1] * Modify_Input_OpenningDepth;
              top_Vertices[s][2] += W[2] * Modify_Input_OpenningDepth;
            }  
            
            int[] base_Vertex_numbers = new int [allFaces[f].length];
            int[] top_Vertex_numbers = new int [allFaces[f].length];
            
            for(int s = 0; s < allFaces[f].length; s++) {
              
              base_Vertex_numbers[s] = SOLARCHVISION_addToVertices(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
              top_Vertex_numbers[s] = SOLARCHVISION_addToVertices(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }        
       
            for(int s = 0; s < allFaces[f].length; s++) {
              
              int s_next = (s + 1) % allFaces[f].length;

              if (Modify_Input_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace = {{base_Vertex_numbers[s], top_Vertex_numbers[s], top_Vertex_numbers[s_next], base_Vertex_numbers[s_next]}};  
                allFaces = (int[][]) concat(allFaces, newFace);
              }
              else {
                int[][] newFace = {{base_Vertex_numbers[s], base_Vertex_numbers[s_next], top_Vertex_numbers[s_next], top_Vertex_numbers[s]}};  
                allFaces = (int[][]) concat(allFaces, newFace);         
              }       
              
              int[][] newFace_MTLV = {{allFaces_MTLV[f][0], allFaces_MTLV[f][1], allFaces_MTLV[f][2], allFaces_MTLV[f][3]}}; 
              allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);
            }  
            
            { // adding the cap
              int[][] newFace = {top_Vertex_numbers};  
              allFaces = (int[][]) concat(allFaces, newFace);         
     
              int[][] newFace_MTLV = {{allFaces_MTLV[f][0], allFaces_MTLV[f][1], allFaces_MTLV[f][2], allFaces_MTLV[f][3]}}; 
              allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);  
              
              int[] lastFace = {allFaces.length - 1};
  
              new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, lastFace);       
            }
            
            
            allPolymesh_Faces[allPolymesh_Faces.length - 1][1] = allFaces.length - 1;

          }
        }

      }
    }
    
    selectedFace_numbers = new_selectedFace_numbers;

    println("SOLARCHVISION_calculate_selection_Pivot 101");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }    
}



void SOLARCHVISION_offsetVerticesSelection (int _type, float _amount) {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 

    if (Work_with_2D_or_3D == 3) { 

      SOLARCHVISION_convertPolymesh2Vertex();    
      
    }
    
    if (Work_with_2D_or_3D == 4) { 
      
      SOLARCHVISION_convertFace2Vertex(); 
      
    }
    
    float[][] selectedVertex_offsetValues = new float [selectedVertex_numbers.length][3];
    int[] selectedVertex_offsetNum = new int [selectedVertex_numbers.length];
    
    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) { 
      selectedVertex_offsetValues[o][0] = 0;
      selectedVertex_offsetValues[o][1] = 0;
      selectedVertex_offsetValues[o][2] = 0;
      
      selectedVertex_offsetNum[o] = 0;
    }
    
    selectedVertex_numbers = sort(selectedVertex_numbers);
  
    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];
    
      for (int f = 1; f < allFaces.length; f++) { // the first node is null
        for (int j = 0; j < allFaces[f].length; j++) {
          
          if (allFaces[f][j] == vNo) { 
            
            float[][] base_Vertices = new float [allFaces[f].length][3];
            
            for (int s = 0; s < allFaces[f].length; s++) {

              base_Vertices[s][0] = allVertices[allFaces[f][s]][0];
              base_Vertices[s][1] = allVertices[allFaces[f][s]][1];
              base_Vertices[s][2] = allVertices[allFaces[f][s]][2];
            }
            
            for(int s = 0; s < base_Vertices.length; s++) {
              
              int s_next = (s + 1) % base_Vertices.length;
              int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
              PVector UV = new PVector(0,0,0);
              
              if (_type == 0) UV = U.cross(V);
              if (_type == 1) UV = PVector.add(U, V);
              
              float[] W = {UV.x, UV.y, UV.z};
              W = fn_normalize(W);
              
              selectedVertex_offsetValues[o][0] += W[0] * _amount;
              selectedVertex_offsetValues[o][1] += W[1] * _amount;
              selectedVertex_offsetValues[o][2] += W[2] * _amount;
              
              selectedVertex_offsetNum[o] += 1;
            }
                      
          }
        }
      }
      
      if (selectedVertex_offsetNum[o] != 0) {
        selectedVertex_offsetValues[o][0] /= float(selectedVertex_offsetNum[o]);
        selectedVertex_offsetValues[o][1] /= float(selectedVertex_offsetNum[o]);
        selectedVertex_offsetValues[o][2] /= float(selectedVertex_offsetNum[o]);
        
      }
      
    } 


    for (int o = selectedVertex_numbers.length - 1; o > 0; o--) { // the first node is null 
  
      int vNo = selectedVertex_numbers[o];
    
      allVertices[vNo][0] += selectedVertex_offsetValues[o][0];
      allVertices[vNo][1] += selectedVertex_offsetValues[o][1];
      allVertices[vNo][2] += selectedVertex_offsetValues[o][2];
    } 

    println("SOLARCHVISION_calculate_selection_Pivot 102");
    SOLARCHVISION_calculate_selection_Pivot();
    
    WIN3D_update_VerticesSolarValue = 1;
  }    
}





void SOLARCHVISION_changeVisibilityFacesSelection (int new_vsb) {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 
    
    if (Work_with_2D_or_3D == 3) { 
  
      SOLARCHVISION_convertPolymesh2Face();    
      
    }
    
    if (Work_with_2D_or_3D == 5) { 
      
      SOLARCHVISION_convertVertex2Face(); 
      
    }
    
    for (int o = selectedFace_numbers.length - 1; o > 0; o--) { // the first node is null
      
      int f = selectedFace_numbers[o];
    
      allFaces_MTLV[f][3] = new_vsb;
    }
    
  }
  
}


void SOLARCHVISION_changeVisibilityFacesScene (int new_vsb) {
  
  for (int f = allFaces.length - 1; f > 0; f--) { // the first node is null
    allFaces_MTLV[f][3] = new_vsb;
  }
  
}


void SOLARCHVISION_reverseVisibilityFacesScene () {
  
  for (int f = allFaces.length - 1; f > 0; f--) { // the first node is null
    
    int vsb = allFaces_MTLV[f][3];
    int new_vsb = vsb;
    
    if (vsb == 0) new_vsb = 1;
    else if (vsb == 1) new_vsb = 0;
  
    allFaces_MTLV[f][3] = new_vsb;
  }
  
}


void SOLARCHVISION_isolateSelection () {

  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5)) { 
    
    SOLARCHVISION_changeVisibilityFacesScene(0);
    SOLARCHVISION_changeVisibilityFacesSelection(1);
  }
}






void SOLARCHVISION_deselectAll () {

  selectedSection_numbers = new int [1];
  selectedSection_numbers[0] = 0;  
  
  selectedFractal_numbers = new int [1];
  selectedFractal_numbers[0] = 0;

  selectedObject2D_numbers = new int [1];
  selectedObject2D_numbers[0] = 0;

  selectedPolymesh_numbers = new int [1];
  selectedPolymesh_numbers[0] = 0;
  
  selectedFace_numbers = new int [1];
  selectedFace_numbers[0] = 0;

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;  
  
  println("SOLARCHVISION_calculate_selection_Pivot 0");
  SOLARCHVISION_calculate_selection_Pivot();
}

void SOLARCHVISION_selectAll () {

  if (Work_with_2D_or_3D == 1) {
    selectedFractal_numbers = new int [allFractal_XYZSRA.length];
    for (int i = 0; i < selectedFractal_numbers.length; i++) { 
      selectedFractal_numbers[i] = i;
    }
  }

  if (Work_with_2D_or_3D == 2) {
    selectedObject2D_numbers = new int [allObject2D_XYZS.length];
    for (int i = 0; i < selectedObject2D_numbers.length; i++) { 
      selectedObject2D_numbers[i] = i;
    }
  }
  
  if (Work_with_2D_or_3D == 3) {
    selectedPolymesh_numbers = new int [allPolymesh_Faces.length];
    for (int i = 0; i < selectedPolymesh_numbers.length; i++) { 
      selectedPolymesh_numbers[i] = i;
    }
  }

  if (Work_with_2D_or_3D == 4) {
    selectedFace_numbers = new int [allFaces.length];
    for (int i = 0; i < selectedFace_numbers.length; i++) { 
      selectedFace_numbers[i] = i;
    }
  }

  if (Work_with_2D_or_3D == 5) {
    selectedVertex_numbers = new int [allVertices.length];
    for (int i = 0; i < selectedVertex_numbers.length; i++) { 
      selectedVertex_numbers[i] = i;
    }
  }
  
  if (Work_with_2D_or_3D == 8) {
    selectedSection_numbers = new int [allSection_UVERAB.length];
    for (int i = 0; i < selectedSection_numbers.length; i++) { 
      selectedSection_numbers[i] = i;
    }
  }  
  
  println("SOLARCHVISION_calculate_selection_Pivot 44");
  SOLARCHVISION_calculate_selection_Pivot();
}


void SOLARCHVISION_reverseSelection () {

  if (Work_with_2D_or_3D == 1) {
    int[] pre_selectedFractal_numbers = sort(selectedFractal_numbers);
    selectedFractal_numbers[0] = 0; 
    
    selectedFractal_numbers = new int [1];
    selectedFractal_numbers[0] = 0;
    
    for (int i = 1; i < allFractal_XYZSRA.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedFractal_numbers.length; j++) {
        
        if (pre_selectedFractal_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedFractal_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedFractal_numbers = concat(selectedFractal_numbers, new_Item);
      }
    }
  }    
  
  if (Work_with_2D_or_3D == 2) {
    int[] pre_selectedObject2D_numbers = sort(selectedObject2D_numbers);
    selectedObject2D_numbers[0] = 0; 
    
    selectedObject2D_numbers = new int [1];
    selectedObject2D_numbers[0] = 0;
    
    for (int i = 1; i < allObject2D_XYZS.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedObject2D_numbers.length; j++) {
        
        if (pre_selectedObject2D_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedObject2D_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedObject2D_numbers = concat(selectedObject2D_numbers, new_Item);
      }
    }
  }  

  if (Work_with_2D_or_3D == 3) {
    int[] pre_selectedPolymesh_numbers = sort(selectedPolymesh_numbers);
    selectedPolymesh_numbers[0] = 0; 
    
    selectedPolymesh_numbers = new int [1];
    selectedPolymesh_numbers[0] = 0;
    
    for (int i = 1; i < allPolymesh_Faces.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedPolymesh_numbers.length; j++) {
        
        if (pre_selectedPolymesh_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedPolymesh_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedPolymesh_numbers = concat(selectedPolymesh_numbers, new_Item);
      }
    }
  }  

  if (Work_with_2D_or_3D == 4) {
    int[] pre_selectedFace_numbers = sort(selectedFace_numbers);
    selectedFace_numbers[0] = 0; 
    
    selectedFace_numbers = new int [1];
    selectedFace_numbers[0] = 0;
    
    for (int i = 1; i < allFaces.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedFace_numbers.length; j++) {
        
        if (pre_selectedFace_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedFace_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedFace_numbers = concat(selectedFace_numbers, new_Item);
      }
    }
  }  
  
  if (Work_with_2D_or_3D == 5) {
    int[] pre_selectedVertex_numbers = sort(selectedVertex_numbers);
    selectedVertex_numbers[0] = 0; 
    
    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;
    
    for (int i = 1; i < allVertices.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedVertex_numbers.length; j++) {
        
        if (pre_selectedVertex_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedVertex_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
      }
    }
  }

  if (Work_with_2D_or_3D == 8) {
    int[] pre_selectedSection_numbers = sort(selectedSection_numbers);
    selectedSection_numbers[0] = 0; 
    
    selectedSection_numbers = new int [1];
    selectedSection_numbers[0] = 0;
    
    for (int i = 1; i < allSection_UVERAB.length; i++) {
      int found = -1; 
      
      for (int j = 1; j < pre_selectedSection_numbers.length; j++) {
        
        if (pre_selectedSection_numbers[j] == i) {
          found = 1;
          break;
        }
        else if (pre_selectedSection_numbers[j] > i) {
          break; 
        }
      }
      
      if (found == -1) {
        int[] new_Item = {i};
        
        selectedSection_numbers = concat(selectedSection_numbers, new_Item);
      }
    }
  }    

  println("SOLARCHVISION_calculate_selection_Pivot 45");
  SOLARCHVISION_calculate_selection_Pivot();
}  





void SOLARCHVISION_convertFace2Polymesh () {
  
  selectedPolymesh_numbers = new int [1];
  selectedPolymesh_numbers[0] = 0; 
  
  for (int i = 1; i < selectedFace_numbers.length; i++) {
    
    int f = selectedFace_numbers[i];
    
    for (int j = 0; j < allFaces[f].length; j++) {
      
      for (int OBJ_NUM = 1; OBJ_NUM < allPolymesh_Faces.length; OBJ_NUM++) {
      
        if ((allPolymesh_Faces[OBJ_NUM][0] <= f) && (f <= allPolymesh_Faces[OBJ_NUM][1])) { 
        
          int previously_added = 0;
          for (int q = 0; q < selectedPolymesh_numbers.length; q++) {
            if (selectedPolymesh_numbers[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {OBJ_NUM};
            selectedPolymesh_numbers = concat(selectedPolymesh_numbers, new_Item);
          }
        }
      }
    }
  }  

}


void SOLARCHVISION_convertVertex2Polymesh () {

  selectedPolymesh_numbers = new int [1];
  selectedPolymesh_numbers[0] = 0; 
  
  for (int i = 1; i < selectedVertex_numbers.length; i++) {
    
    int vNo = selectedVertex_numbers[i];
    
    for (int f = 1; f < allFaces.length; f++) {
      
      for (int j = 0; j < allFaces[f].length; j++) {
        
        if (allFaces[f][j] == vNo) { 
        
          for (int OBJ_NUM = 1; OBJ_NUM < allPolymesh_Faces.length; OBJ_NUM++) {
          
            if ((allPolymesh_Faces[OBJ_NUM][0] <= f) && (f <= allPolymesh_Faces[OBJ_NUM][1])) { 
            
              int previously_added = 0;
              for (int q = 0; q < selectedPolymesh_numbers.length; q++) {
                if (selectedPolymesh_numbers[q] == OBJ_NUM) {
                  previously_added = 1;
                  break;
                }
              }
              if (previously_added == 0) {
                int[] new_Item = {OBJ_NUM};
                selectedPolymesh_numbers = concat(selectedPolymesh_numbers, new_Item);
              }
            }
          }
        }
      }
    }  
  } 
  
}


void SOLARCHVISION_convertVertex2Face () {

  selectedFace_numbers = new int [1];
  selectedFace_numbers[0] = 0; 
  
  for (int i = 1; i < selectedVertex_numbers.length; i++) {
    
    int vNo = selectedVertex_numbers[i];

    for (int f = 1; f < allFaces.length; f++) {
      
      for (int j = 0; j < allFaces[f].length; j++) {
        
        if (allFaces[f][j] == vNo) { 
        
          int previously_added = 0;
          for (int q = 0; q < selectedFace_numbers.length; q++) {
            if (selectedFace_numbers[q] == f) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {f};
            selectedFace_numbers = concat(selectedFace_numbers, new_Item);
          }
        }
      }
    }  
  }
  
}



void SOLARCHVISION_convertPolymesh2Face () {

  selectedFace_numbers = new int [1];
  selectedFace_numbers[0] = 0; 
  
  for (int i = 1; i < selectedPolymesh_numbers.length; i++) {
    
    int OBJ_NUM = selectedPolymesh_numbers[i];
    
    for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) { 
      
      int previously_added = 0;
      for (int q = 0; q < selectedFace_numbers.length; q++) {
        if (selectedFace_numbers[q] == f) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {f};
        selectedFace_numbers = concat(selectedFace_numbers, new_Item);
      }
    }  
  }

}


void SOLARCHVISION_convertPolymesh2Vertex () {
  
  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0; 
  
  for (int i = 1; i < selectedPolymesh_numbers.length; i++) {
    
    int OBJ_NUM = selectedPolymesh_numbers[i];
    
    for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) { 
      
      for (int j = 0; j < allFaces[f].length; j++) {
        
        int vNo = allFaces[f][j];
        
        int previously_added = 0;
        for (int q = 0; q < selectedVertex_numbers.length; q++) {
          if (selectedVertex_numbers[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {vNo};
          selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
        }
      }
    }  
  }

}


void SOLARCHVISION_convertFace2Vertex () {

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0; 
  
  for (int i = 1; i < selectedFace_numbers.length; i++) {
    
    int f = selectedFace_numbers[i];
    
    for (int j = 0; j < allFaces[f].length; j++) {
      
      int vNo = allFaces[f][j];
      
      int previously_added = 0;
      for (int q = 0; q < selectedVertex_numbers.length; q++) {
        if (selectedVertex_numbers[q] == vNo) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {vNo};
        selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
      }
    }
  }

}


int[] selectedVertex_softSelectionVertices = new int[0]; 
float[] selectedVertex_softSelectionValues = new float[0];

void SOLARCHVISION_convertVertex2softSelection () { 

  int[] keep_selectedVertex_numbers = selectedVertex_numbers;
  
  SOLARCHVISION_convertVertex2Polymesh();
  
  SOLARCHVISION_convertPolymesh2Vertex();
  
  selectedVertex_softSelectionVertices = new int[selectedVertex_numbers.length]; 
  selectedVertex_softSelectionValues = new float[selectedVertex_numbers.length];

  for (int q = 1; q < selectedVertex_numbers.length; q++) {
    
    int n = selectedVertex_numbers[q];
    
    float d_min = FLOAT_undefined;
    
    for (int p = 1; p < keep_selectedVertex_numbers.length; p++) {
      
      int m = keep_selectedVertex_numbers[p];
      
      float d = dist(allVertices[m][0], allVertices[m][1], allVertices[m][2], allVertices[n][0], allVertices[n][1], allVertices[n][2]);
      
      if (d_min > d) {
        d_min = d; 
      }
    }
    
    selectedVertex_softSelectionValues[q] = SOLARCHVISION_softVertexSelectionFunction(d_min);
  }
  
  selectedVertex_softSelectionVertices = selectedVertex_numbers;
  
  selectedVertex_numbers = keep_selectedVertex_numbers;
}


            
void SOLARCHVISION_add_Octahedron (int m, int tes, int lyr, int vsb, int spv, float x, float y, float z, float rx, float ry, float rz, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  float teta = rot * PI / 180.0;
  
  float[] X_ = new float [6];
  float[] Y_ = new float [6];
  float[] Z_ = new float [6];

  float q = pow(2, 0.5);

  X_[0] = 0;  Y_[0] = 0;  Z_[0] = q;
  X_[1] = q;  Y_[1] = 0;  Z_[1] = 0;
  X_[2] = 0;  Y_[2] = q;  Z_[2] = 0;
  X_[3] = -q;  Y_[3] = 0;  Z_[3] = 0;
  X_[4] = 0;  Y_[4] = -q;  Z_[4] = 0;
  X_[5] = 0;  Y_[5] = 0;  Z_[5] = -q;
  
  for (int i = 0; i < 6; i += 1) {
    X_[i] *= rx;
    Y_[i] *= ry;
    Z_[i] *= rz;

    float X_r = X_[i] * cos(teta) - Y_[i] * sin(teta);
    float Y_r = X_[i] * sin(teta) + Y_[i] * cos(teta);
    float Z_r = Z_[i];
    
    X_[i] = X_r + x;
    Y_[i] = Y_r + y;
    Z_[i] = Z_r + z;
  }
  
  int[] v = new int [6];
  
  for(int i = 0; i < 6; i++) {
    v[i] = SOLARCHVISION_addToVertices(X_[i], Y_[i], Z_[i]); 
  } 

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;
  
  {
    int[] newFace = {v[1], v[2], v[0]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      

  {
    int[] newFace = {v[2], v[3], v[0]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      

  {
    int[] newFace = {v[3], v[4], v[0]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      

  {
    int[] newFace = {v[4], v[1], v[0]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      

  {
    int[] newFace = {v[1], v[5], v[2]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      

  {
    int[] newFace = {v[2], v[5], v[3]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      
  {
    int[] newFace = {v[3], v[5], v[4]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }  
  
  {
    int[] newFace = {v[4], v[5], v[1]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }      
}            
     


void SOLARCHVISION_add_House_Core (int m, int tes, int lyr, int vsb, int spv, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  float teta = rot * PI / 180.0;

  float x1 = rx;  
  float x2 = -rx;
  float x3 = -rx;
  float x4 = rx;

  float y1 = ry;  
  float y2 = ry;
  float y3 = -ry;
  float y4 = -ry;
  
  float z0 = -rz; 
  float z1 = rz;
  float z2 = h2;

  float[] vx = { 1,-1,-1, 1, 1,-1,-1, 1, 1,-1};
  float[] vy = { 1, 1,-1,-1, 1, 1,-1,-1, 0, 0};
  //float[] vz = {-1,-1,-1,-1, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz};
  float[] vz = {0,0,0,0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz};
  
  for (int i = 0; i < 10; i++) {
    vx[i] *= rx;
    vy[i] *= ry;
    vz[i] *= rz;
    
    float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
    float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
    float vz_rot = z + vz[i];
    
    vx[i] = vx_rot;
    vy[i] = vy_rot;
    vz[i] = vz_rot;
  }  

  int b1 = SOLARCHVISION_addToVertices(vx[0], vy[0], vz[0]);
  int b2 = SOLARCHVISION_addToVertices(vx[1], vy[1], vz[1]);
  int b3 = SOLARCHVISION_addToVertices(vx[2], vy[2], vz[2]);
  int b4 = SOLARCHVISION_addToVertices(vx[3], vy[3], vz[3]);

  int t1 = SOLARCHVISION_addToVertices(vx[4], vy[4], vz[4]);
  int t2 = SOLARCHVISION_addToVertices(vx[5], vy[5], vz[5]);
  int t3 = SOLARCHVISION_addToVertices(vx[6], vy[6], vz[6]);
  int t4 = SOLARCHVISION_addToVertices(vx[7], vy[7], vz[7]);

  int m1 = SOLARCHVISION_addToVertices(vx[8], vy[8], vz[8]);
  int m2 = SOLARCHVISION_addToVertices(vx[9], vy[9], vz[9]);


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;


  {//West
    int[] newFace = {t3, m2, t2, b2, b3};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }  
  {//Roof-South
    int[] newFace = {m1, m2, t3, t4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }  
  {//East
    int[] newFace = {t1, m1, t4, b4, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }    
  {//North
    int[] newFace = {t2, t1, b1, b2};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }  
  {//South
    int[] newFace = {t4, t3, b3, b4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }    
  {//Roof-North
    int[] newFace = {m2, m1, t1, t2};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }    
  {//Bottom
    int[] newFace = {b4, b3, b2, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
}



void SOLARCHVISION_add_Box_Core (int m, int tes, int lyr, int vsb, int spv, float x, float y, float z, float rx, float ry, float rz, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  float teta = rot * PI / 180.0;

  int t1 = SOLARCHVISION_addToVertices(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z + rz);
  int t2 = SOLARCHVISION_addToVertices(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z + rz);
  int t3 = SOLARCHVISION_addToVertices(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z + rz);
  int t4 = SOLARCHVISION_addToVertices(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z + rz);

  int b1 = SOLARCHVISION_addToVertices(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z - rz);
  int b2 = SOLARCHVISION_addToVertices(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z - rz);
  int b3 = SOLARCHVISION_addToVertices(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z - rz);
  int b4 = SOLARCHVISION_addToVertices(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z - rz);

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  {//West
    int[] newFace = {t3, t2, b2, b3};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//Roof
    int[] newFace = {t1, t2, t3, t4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//East
    int[] newFace = {t1, t4, b4, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//North
    int[] newFace = {t2, t1, b1, b2};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//South
    int[] newFace = {t4, t3, b3, b4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//Bottom
    int[] newFace = {b4, b3, b2, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }     
}


void SOLARCHVISION_add_Box_Corners (int m, int tes, int lyr, int vsb, int spv, float x1, float y1, float z1, float x2, float y2, float z2) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int t1 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int t2 = SOLARCHVISION_addToVertices(x1, y2, z2);
  int t3 = SOLARCHVISION_addToVertices(x1, y1, z2);
  int t4 = SOLARCHVISION_addToVertices(x2, y1, z2);

  int b1 = SOLARCHVISION_addToVertices(x2, y2, z1);
  int b2 = SOLARCHVISION_addToVertices(x1, y2, z1);
  int b3 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int b4 = SOLARCHVISION_addToVertices(x2, y1, z1);

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;


  {//West
    int[] newFace = {t3, t2, b2, b3};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//Roof
    int[] newFace = {t1, t2, t3, t4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//East
    int[] newFace = {t1, t4, b4, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//North
    int[] newFace = {t2, t1, b1, b2};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//South
    int[] newFace = {t4, t3, b3, b4};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }
  {//Bottom
    int[] newFace = {b4, b3, b2, b1};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_addToFaces(newFace);
  }   
}


void SOLARCHVISION_add_H_shade (int m, int tes, int lyr, int vsb, int spv, float x0, float y0, float z0, float d, float w, float Alpha, float Beta) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  float rx = 0.5 * d * cos_ang(Beta);
  float ry = 0.5 * d * sin_ang(Beta);
  
  float wx = w * cos_ang(Beta - 90) * cos_ang(Alpha);
  float wy = w * sin_ang(Beta - 90) * cos_ang(Alpha);
  float wz = w * sin_ang(Alpha);
  
  float x1 = x0 + rx;
  float y1 = y0 + ry;
  float z1 = z0;

  float x2 = x0 - rx;
  float y2 = y0 - ry;
  float z2 = z0;

  float x3 = wx + x0 - rx;
  float y3 = wy + y0 - ry;
  float z3 = wz + z0;

  float x4 = wx + x0 + rx;
  float y4 = wy + y0 + ry;
  float z4 = wz + z0;

  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);
  int v4 = SOLARCHVISION_addToVertices(x4, y4, z4);
  
  {
    int[] newFace = {v1, v2, v3, v4};
    SOLARCHVISION_addToFaces(newFace);
  }

}


void SOLARCHVISION_add_V_shade (int m, int tes, int lyr, int vsb, int spv, float x0, float y0, float z0, float h, float d, float t, float t0) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  float dx = d * cos_ang(t + t0 - 90);
  float dy = d * sin_ang(t + t0 - 90);

  float x1 = x0;
  float y1 = y0;
  float z1 = z0 - 0.5 * h;

  float x2 = x0;
  float y2 = y0;
  float z2 = z0 + 0.5 * h;

  float x3 = x0 + dx;
  float y3 = y0 + dy;
  float z3 = z0 + 0.5 * h;

  float x4 = x0 + dx;
  float y4 = y0 + dy;
  float z4 = z0 - 0.5 * h;
  
  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);
  int v4 = SOLARCHVISION_addToVertices(x4, y4, z4);
  
  {
    int[] newFace = {v1, v2, v3, v4};
    SOLARCHVISION_addToFaces(newFace);
  }

}



void SOLARCHVISION_add_Mesh2 (int m, int tes, int lyr, int vsb, int spv, float x1, float y1, float z1, float x3, float y3, float z3) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv; 
  
  float x2 = x3;
  float y2 = y3;
  float z2 = z3;

  float x4 = x1;
  float y4 = y1;
  float z4 = z1;
  
  if (z1 == z3) {
    y2 = y1;
    y4 = y3;
  }
  else if (y1 == y3) {
    x2 = x1;
    x4 = x3;
  }
  else if (x1 == x3) {
    z2 = z1;
    z4 = z3;
  }  
  
  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);
  int v4 = SOLARCHVISION_addToVertices(x4, y4, z4);

  
  {
    int[] newFace = {v1, v2, v3, v4};
    SOLARCHVISION_addToFaces(newFace);
  }

}

void SOLARCHVISION_add_Mesh4 (int m, int tes, int lyr, int vsb, int spv, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;  
  
  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);
  int v4 = SOLARCHVISION_addToVertices(x4, y4, z4);
  
  {
    int[] newFace = {v1, v2, v3, v4};
    SOLARCHVISION_addToFaces(newFace);
  }

}

void SOLARCHVISION_add_Mesh3 (int m, int tes, int lyr, int vsb, int spv, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);

  {
    int[] newFace = {v1, v2, v3};
    SOLARCHVISION_addToFaces(newFace);
  }

}

void SOLARCHVISION_add_Mesh5 (int m, int tes, int lyr, int vsb, int spv, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int v1 = SOLARCHVISION_addToVertices(x1, y1, z1);
  int v2 = SOLARCHVISION_addToVertices(x2, y2, z2);
  int v3 = SOLARCHVISION_addToVertices(x3, y3, z3);
  int v4 = SOLARCHVISION_addToVertices(x4, y4, z4);
  int v5 = SOLARCHVISION_addToVertices(x5, y5, z5);
  
  {
    int[] newFace = {v1, v2, v3, v4, v5};
    SOLARCHVISION_addToFaces(newFace);
  }

}

void SOLARCHVISION_add_Polygon (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int[] newFace = {SOLARCHVISION_addToVertices(cx + r * cos_ang(0), cy + r * sin_ang(0), cz)};
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n) + rot;
    int[] f = {SOLARCHVISION_addToVertices(cx + r * cos_ang(t), cy + r * sin_ang(t), cz)};
    newFace = concat(newFace, f);
  } 

  SOLARCHVISION_addToFaces(newFace);

}



void SOLARCHVISION_add_PolygonExtrude (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, float h, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int[] vT = new int [n];
  int[] vB = new int [n];
  
  vT[0] = SOLARCHVISION_addToVertices(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz + 0.5 * h);
  vB[0] = SOLARCHVISION_addToVertices(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h);
  
  int[] newFaceT = {vT[0]};
  int[] newFaceB = {vB[0]};
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n);
    
    vT[i] = SOLARCHVISION_addToVertices(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + 0.5 * h);
    vB[i] = SOLARCHVISION_addToVertices(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz - 0.5 * h);
    int[] fT = {vT[i]};
    int[] fB = {vB[i]};
    
    newFaceT = concat(newFaceT, fT);
    newFaceB = concat(newFaceB, fB);
  } 
 
  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  SOLARCHVISION_addToFaces(newFaceT);
  
  if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
  SOLARCHVISION_addToFaces(newFaceB);
  
  for (int i = 0; i < n; i++) {
    int next_i = (i + 1) % n;
   
    int[] newFace = {vT[i], vB[i], vB[next_i], vT[next_i]};
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
    SOLARCHVISION_addToFaces(newFace);
  }

}


void SOLARCHVISION_add_PolygonHyper (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, float h, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int[] newFace = {SOLARCHVISION_addToVertices(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h)};
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n);
    int[] f = {SOLARCHVISION_addToVertices(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + (2 * (i % 2) - 1) * 0.5 * h)};
    newFace = concat(newFace, f);
  } 

  SOLARCHVISION_addToFaces(newFace);

}



void SOLARCHVISION_add_Icosahedron (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int[] vT = new int [6];
  int[] vB = new int [6];
  
  vT[0] = SOLARCHVISION_addToVertices(cx, cy, cz + r);
  vB[0] = SOLARCHVISION_addToVertices(cx, cy, cz - r);
  
  for (int i = 1; i <= 5; i++) {
    float t = i * 72;
    
    float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;
    
    vT[i] = SOLARCHVISION_addToVertices(cx + R_in * cos_ang(t + rot), cy + R_in * sin_ang(t + rot), cz + H_in);
    vB[i] = SOLARCHVISION_addToVertices(cx + R_in * cos_ang(t + 36 + rot), cy + R_in * sin_ang(t + 36 + rot), cz - H_in);
  } 


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  for (int i = 1; i <= 5; i++) {
    
    int next_i = (i % 5) + 1;
    
    {
      int[] newFaceT = new int [3];
      int[] newFaceB = new int [3];
      
      newFaceT[0] = vT[i];
      newFaceT[1] = vT[next_i];
      newFaceT[2] = vT[0];
  
      newFaceB[0] = vB[i];
      newFaceB[1] = vB[next_i];
      newFaceB[2] = vT[next_i]; 
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));   
      SOLARCHVISION_addToFaces(newFaceT);
      SOLARCHVISION_addToFaces(newFaceB);
      
    }
    
    {
      int[] newFaceT = new int [3];
      int[] newFaceB = new int [3];
  
      newFaceT[0] = vT[next_i];
      newFaceT[1] = vT[i];
      newFaceT[2] = vB[i];

      newFaceB[0] = vB[next_i];
      newFaceB[1] = vB[i];
      newFaceB[2] = vB[0];    
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      SOLARCHVISION_addToFaces(newFaceT);
      SOLARCHVISION_addToFaces(newFaceB);
       
    }
  }   
  
}  
  

void SOLARCHVISION_add_QuadSphere (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, int Tessellation) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv; 
  
  // i.e. Rhombic Triacontahedron
  
  int[] vT = new int [6];
  int[] vB = new int [6];
  
  vT[0] = SOLARCHVISION_addToVertices(cx, cy, cz + r);
  vB[0] = SOLARCHVISION_addToVertices(cx, cy, cz - r);
  
  for (int i = 1; i <= 5; i++) {
    float t = i * 72;
    
    float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;
    
    vT[i] = SOLARCHVISION_addToVertices(cx + R_in * cos_ang(t), cy + R_in * sin_ang(t), cz + H_in);
    vB[i] = SOLARCHVISION_addToVertices(cx + R_in * cos_ang(t + 36), cy + R_in * sin_ang(t + 36), cz - H_in);
  } 

  int[] vM1 = new int [6]; // between T0 and Ti  
  int[] vM2 = new int [6]; // between Ti and Bi
  int[] vM3 = new int [6]; // between Ti and Bi
  int[] vM4 = new int [6]; // between Bi and B0
  //CAUTION: VMx[0] will remain undefined below to keep simillar i variables! 
  for (int i = 1; i <= 5; i++) {
    
    int next_i = (i % 5) + 1;
    
    float[] G;
    
    int A, B, C;
   
    { 
      A = i;
      B = next_i;
      C = 0;
      
      float[][] the_points = {{allVertices[vT[A]][0] - cx, allVertices[vT[A]][1] - cy, allVertices[vT[A]][2] - cz}
                            , {allVertices[vT[B]][0] - cx, allVertices[vT[B]][1] - cy, allVertices[vT[B]][2] - cz}
                            , {allVertices[vT[C]][0] - cx, allVertices[vT[C]][1] - cy, allVertices[vT[C]][2] - cz}};

      G = fn_normalize(fn_G(the_points));
      vM1[i] = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }
    
    { 
      A = next_i;
      B = i;
      C = i;
      
      float[][] the_points = {{allVertices[vT[A]][0] - cx, allVertices[vT[A]][1] - cy, allVertices[vT[A]][2] - cz}
                            , {allVertices[vT[B]][0] - cx, allVertices[vT[B]][1] - cy, allVertices[vT[B]][2] - cz}
                            , {allVertices[vB[C]][0] - cx, allVertices[vB[C]][1] - cy, allVertices[vB[C]][2] - cz}};

      G = fn_normalize(fn_G(the_points));
      vM2[i] = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    } 
    
    { 
      A = i;
      B = next_i;
      C = next_i;
      
      float[][] the_points = {{allVertices[vB[A]][0] - cx, allVertices[vB[A]][1] - cy, allVertices[vB[A]][2] - cz}
                            , {allVertices[vB[B]][0] - cx, allVertices[vB[B]][1] - cy, allVertices[vB[B]][2] - cz}
                            , {allVertices[vT[C]][0] - cx, allVertices[vT[C]][1] - cy, allVertices[vT[C]][2] - cz}};
      
      G = fn_normalize(fn_G(the_points));
      vM3[i] = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }    
    
    { 
      A = next_i;
      B = i;
      C = 0;
      
      float[][] the_points = {{allVertices[vB[A]][0] - cx, allVertices[vB[A]][1] - cy, allVertices[vB[A]][2] - cz}
                            , {allVertices[vB[B]][0] - cx, allVertices[vB[B]][1] - cy, allVertices[vB[B]][2] - cz}
                            , {allVertices[vB[C]][0] - cx, allVertices[vB[C]][1] - cy, allVertices[vB[C]][2] - cz}};
      
      G = fn_normalize(fn_G(the_points));
      vM4[i] = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }      
    
  }    


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  for (int i = 1; i <= 5; i++) {
    
    int next_i = (i % 5) + 1;
    int prev_i = ((i + 5 - 2) % 5) + 1;

    {
      int[] newFace = new int [4];
      
      newFace[0] = vT[0];
      newFace[1] = vM1[prev_i];
      newFace[2] = vT[i];
      newFace[3] = vM1[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }

    {
      int[] newFace = new int [4];
      
      newFace[0] = vT[i];
      newFace[1] = vM2[i];
      newFace[2] = vT[next_i];
      newFace[3] = vM1[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }
    
    {
      int[] newFace = new int [4];
      
      newFace[0] = vT[i];
      newFace[1] = vM3[prev_i];
      newFace[2] = vB[i];
      newFace[3] = vM2[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }    
    
    {
      int[] newFace = new int [4];
      
      newFace[0] = vT[next_i];
      newFace[1] = vM2[i];
      newFace[2] = vB[i];
      newFace[3] = vM3[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }     

    {
      int[] newFace = new int [4];
      
      newFace[0] = vB[i];
      newFace[1] = vM4[i];
      newFace[2] = vB[next_i];
      newFace[3] = vM3[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }
    
    {
      int[] newFace = new int [4];
      
      newFace[0] = vB[i];
      newFace[1] = vM4[prev_i];
      newFace[2] = vB[0];
      newFace[3] = vM4[i];
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      
      if (Tessellation == 0) {
        SOLARCHVISION_addToFaces(newFace);
      }
      else {
        SOLARCHVISION_addToFaces_afterSphericalTessellation(m, tes, lyr, vsb, spv, cx, cy, cz, r, newFace);
      }
    }    
    
    
  }    

}


void SOLARCHVISION_addToFaces_afterSphericalTessellation (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, int[] f) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int A = f[0];
  int B = f[1];
  int C = f[2];
  int D = f[3];

  int M, N;  // 
  int MM, NN; // MM: mirror of M based on AB; NN: mirror of N baesd on CD

  float[] G;
  
  { 
    float[][] the_points = {{allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz}
                          , {allVertices[A][0] - cx, allVertices[A][1] - cy, allVertices[A][2] - cz}
                          , {allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz}};
    
    G = fn_normalize(fn_G(the_points));
    M = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
    G[0] = (allVertices[C][0] - cx) + (allVertices[D][0] - cx) - (allVertices[M][0] - cx);
    G[1] = (allVertices[C][1] - cy) + (allVertices[D][1] - cy) - (allVertices[M][1] - cy);
    G[2] = (allVertices[C][2] - cz) + (allVertices[D][2] - cz) - (allVertices[M][2] - cz);
    G = fn_normalize(G);
    MM = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);    
  }   
 

  { 
    float[][] the_points = {{allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz}
                          , {allVertices[C][0] - cx, allVertices[C][1] - cy, allVertices[C][2] - cz}
                          , {allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz}};
    
    G = fn_normalize(fn_G(the_points));
    N = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);

    
    G[0] = (allVertices[A][0] - cx) + (allVertices[B][0] - cx) - (allVertices[N][0] - cx);
    G[1] = (allVertices[A][1] - cy) + (allVertices[B][1] - cy) - (allVertices[N][1] - cy);
    G[2] = (allVertices[A][2] - cz) + (allVertices[B][2] - cz) - (allVertices[N][2] - cz);
    G = fn_normalize(G);    
    NN = SOLARCHVISION_addToVertices(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
  }




  
  {
    int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
    
    allFaces_MTLV = (int[][]) concat(allFaces_MTLV, newFace_MTLV);
    
    
    int[][] newFace = {{M, B, N, D}}; 
    
    allFaces = (int[][]) concat(allFaces, newFace);
  }

  {
    int[][] newFace_MTLV = {{defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility}}; 
    
    //allFaces_MTLV = (int[][]) concat(allFaces_MTLV, newFace_MTLV);
    
    
    int[][] newFace = {{MM, B, M, A}}; 
    
    //allFaces = (int[][]) concat(allFaces, newFace);
  }

}




 
String objMapsSubfolder = "maps/";

PrintWriter mtlOutput;
PrintWriter objOutput;


int obj_lastVertexNumber;
int obj_lastVtextureNumber;
int obj_lastFaceNumber;
int obj_lastGroupNumber;



int num_vertices_added = 0;

void SOLARCHVISION_export_objects () {
  
  String fileBasename = ProjectName;
  
  String objFilename = Model3DFolder + "/" + fileBasename + ".obj";
  String mtlFilename = Model3DFolder + "/" + fileBasename + ".mtl";


  if (objExportMaterialLibrary != 0) {
    mtlOutput = createWriter(mtlFilename);
    mtlOutput.println("#SOLARCHVISION");
  }

  objOutput = createWriter(objFilename);
  objOutput.println("#SOLARCHVISION");
  if (objExportMaterialLibrary != 0) {
    objOutput.println("mtllib " + fileBasename + ".mtl");
  }
  
  obj_lastVertexNumber = 0; 
  obj_lastVtextureNumber = 0; 
  obj_lastFaceNumber = 0;
  obj_lastGroupNumber = 0;

  if (Display_EARTH3D != 0) {
    
    if (objExportMaterialLibrary != 0) {
  
      mtlOutput.println("newmtl EarthSphere");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
  
      if (Display_EARTH3D_TEXTURE != 0) {
        
        int n = 0;
        if (Day_of_Impact_to_Display < EARTH_IMAGES.length) n = Day_of_Impact_to_Display;
              
        String old_TEXTURE_path = EARTH_IMAGES_Path + "/" + EARTH_IMAGES_Filenames[n];
        
        String the_filename = old_TEXTURE_path.substring(old_TEXTURE_path.lastIndexOf("/") + 1); // image name
    
        String new_TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
    
        println("Copying texture:", old_TEXTURE_path, ">", new_TEXTURE_path);
        saveBytes(new_TEXTURE_path, loadBytes(old_TEXTURE_path));
  
        //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map        
        mtlOutput.println("\tmap_d " + objMapsSubfolder + the_filename); // diffuse map
      }
    }
    
    
    if (objExportPolyToPoly == 1) {
      obj_lastGroupNumber += 1;  
      objOutput.println("g EarthSphere"); 
    }
    
    if (objExportMaterialLibrary != 0) {
      objOutput.println("usemtl EarthSphere");
    }
    

    float EARTH_IMAGES_OffsetX = 0; //EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0] + 180;
    float EARTH_IMAGES_OffsetY = 0; //EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1] - 90;
    
    float EARTH_IMAGES_ScaleX = 1; //(EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][1] - EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0]) / 360.0;
    float EARTH_IMAGES_ScaleY = 1; //(EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1] - EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][0]) / 180.0;

    float CEN_lon = 0; //0.5 * (EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0] + EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][1]);
    float CEN_lat = 0; //0.5 * (EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][0] + EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1]);
    
    float delta_Alpha = -7.5; //-2.5;
    float delta_Beta = -7.5; //-2.5;
    
    float r = FLOAT_R_earth;


    for (int _turn = 1; _turn < 4; _turn += 1) {
    
      int f = 0;
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
          f += 1;
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s += 1) {
            
            float a = Alpha;
            float b = Beta;
            
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);
            
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
            
            
            // calculating u and v
            subFace[s][3] = (_lon / EARTH_IMAGES_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / EARTH_IMAGES_ScaleY / 180.0 + 0.5);
          
            
            // rotating to location coordinates 
            float tb = -LocationLongitude;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;
            
            float ta = 90 - LocationLatitude;
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
  
            // move it down!
            z2 -= FLOAT_R_earth;
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
  
          }
  
          for (int s = 0; s < subFace.length; s++) {
            
            float x = subFace[s][0];
            float y = subFace[s][1];
            float z = subFace[s][2];
            float u = subFace[s][3];
            float v = subFace[s][4];
  
            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
            
            if (_turn == 1) {
              objOutput.println("v " + nf(x, 0, objExportPrecisionVertex) + " " + nf(y, 0, objExportPrecisionVertex) + " " + nf(z, 0, objExportPrecisionVertex));
            }

            if (_turn == 2) {
              objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
            }
            
            if (_turn == 3) {
              obj_lastVertexNumber += 1;
              obj_lastVtextureNumber += 1;
            }
          }
  
          String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber - 0, 0);
          
          String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
          
          if (objExportPolyToPoly == 0) {
            if (_turn == 3) {
              obj_lastGroupNumber += 1;
              objOutput.println("g EarthSphere_" + nf(f, 0));
            }
          } 
          
          if (_turn == 3) {
            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          }        
        
        }
      }
    }
  }


  if (Display_LAND_MESH != 0) {
    
    if (objExportMaterialLibrary != 0) {

      mtlOutput.println("newmtl LandMesh");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
  
      if (Display_LAND_TEXTURE != 0) {
        
        int n = 0;
        if (Day_of_Impact_to_Display < EARTH_IMAGES.length) n = Day_of_Impact_to_Display;
              
        String old_TEXTURE_path = LAND_TEXTURE_ImagePath;
        
        String the_filename = old_TEXTURE_path.substring(old_TEXTURE_path.lastIndexOf("/") + 1); // image name
    
        String new_TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
    
        println("Copying texture:", old_TEXTURE_path, ">", new_TEXTURE_path);
        saveBytes(new_TEXTURE_path, loadBytes(old_TEXTURE_path));
  
        //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map        
        mtlOutput.println("\tmap_d " + objMapsSubfolder + the_filename); // diffuse map
      }
    }

    if (objExportPolyToPoly == 1) {
      obj_lastGroupNumber += 1;  
      objOutput.println("g LandMesh");
    }

    if (objExportMaterialLibrary != 0) {
      objOutput.println("usemtl LandMesh");
    }
    
    int LAND_firstVertexNumber = obj_lastVertexNumber;
    int LAND_firstVtextureNumber = obj_lastVtextureNumber;
    
    for (int _turn = 1; _turn < 4; _turn += 1) {
    
      for (int i = 0; i < LAND_n_I * LAND_n_J; i++) {
        
        int the_I = i / LAND_n_J;
        int the_J = i % LAND_n_J;
        
        float x = LAND_MESH[the_I][the_J][0];
        float y = LAND_MESH[the_I][the_J][1];
        float z = LAND_MESH[the_I][the_J][2];
  
        float u = x / LAND_TEXTURE_scale_U + 0.5;
        float v = y / LAND_TEXTURE_scale_V + 0.5;
        
        if (_turn == 1) {
          objOutput.println("v " + nf(x, 0, objExportPrecisionVertex) + " " + nf(y, 0, objExportPrecisionVertex) + " " + nf(z, 0, objExportPrecisionVertex));
        }
        
        if (_turn == 2) {
          objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
        }
  
        if (_turn == 3) {
          obj_lastVertexNumber += 1;
          obj_lastVtextureNumber += 1;
        }
        
      }
    }
    
    int f = 0;
    for (int i = 0; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {
        f += 1;
        
        int A = i * LAND_n_J + j + 1;
        int B = (i + 1) * LAND_n_J + j + 1;
        int C = (i + 1) * LAND_n_J + j + 2;
        int D = i * LAND_n_J + j + 2;
        
        int vNo1 = LAND_firstVertexNumber + A;
        int vNo2 = LAND_firstVertexNumber + B;
        int vNo3 = LAND_firstVertexNumber + C;
        int vNo4 = LAND_firstVertexNumber + D;
        
        int vtNo1 = LAND_firstVtextureNumber + A;
        int vtNo2 = LAND_firstVtextureNumber + B;
        int vtNo3 = LAND_firstVtextureNumber + C;
        int vtNo4 = LAND_firstVtextureNumber + D;

        String n1_txt = nf(vNo1, 0); 
        String n2_txt = nf(vNo2, 0); 
        String n3_txt = nf(vNo3, 0); 
        String n4_txt = nf(vNo4, 0); 
        
        String m1_txt = nf(vtNo1, 0);
        String m2_txt = nf(vtNo2, 0);
        String m3_txt = nf(vtNo3, 0);
        String m4_txt = nf(vtNo4, 0);
        
        if (objExportPolyToPoly == 0) {
          obj_lastGroupNumber += 1;
          objOutput.println("g LandMesh_" + nf(f, 0));
        } 
        
        obj_lastFaceNumber += 1;            
        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
        if (objExportBackSides != 0) {
          obj_lastFaceNumber += 1;
          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
        }        

      }
    }
  }








  if (Display_Sections != 0) {

    for (int f = 1; f <= allSection_num; f++) {
      
      float Section_offset_U = allSection_UVERAB[f][0];
      float Section_offset_V = allSection_UVERAB[f][1];
      float Section_Elevation = allSection_UVERAB[f][2];
      float Section_Rotation = allSection_UVERAB[f][3];
      float Section_scale_U = allSection_UVERAB[f][4];
      float Section_scale_V = allSection_UVERAB[f][5];

      int Section_Type = allSection_Type[f];
      int Section_RES1 = allSection_RES1[f];
      int Section_RES2 = allSection_RES2[f];

      if (Section_Type != 0) {

        String the_filename = "Impact_" + nf(f, 0) + ".bmp";
      
        if (objExportMaterialLibrary != 0) {
        
          String new_TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
    
          if (Display_SolarImpact_Image != 0) {
            println("Saving texture:", new_TEXTURE_path);
            allSection_SolarImpact[f][Day_of_Impact_to_Display].save(new_TEXTURE_path);
          } else if (Display_SpatialImpact_Image != 0) {
            println("Saving texture:", new_TEXTURE_path);
            allSection_SpatialImpact[f].save(new_TEXTURE_path);              
          }
    
          mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
          //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map        
        }
        
        int Display_solarch_texture = 0;
    
        if (Section_Type != 0) {
  
          if (objExportPolyToPoly == 1) {
            obj_lastGroupNumber += 1;  
            objOutput.println("g Impact_" + nf(f, 0));
          }
          
          if (objExportMaterialLibrary != 0) {
            objOutput.println("usemtl " + the_filename.replace('.', '_'));
          }
          
          for (int _turn = 1; _turn < 4; _turn += 1) {
            for (int q = 0; q < 4; q++) {
                
              float[] ImageVertex = SOLARCHVISION_getCorners_Section(q, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
              
              float x = ImageVertex[0];
              float y = ImageVertex[1];
              float z = ImageVertex[2];
              float u = ImageVertex[3];
              float v = ImageVertex[4];
  
              
              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
              
              if (_turn == 1) {
                objOutput.println("v " + nf(x, 0, objExportPrecisionVertex) + " " + nf(y, 0, objExportPrecisionVertex) + " " + nf(z, 0, objExportPrecisionVertex));
              }
              
              if (_turn == 2) {
                objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
              }
              
              if (_turn == 3) {
                obj_lastVertexNumber += 1;
                obj_lastVtextureNumber += 1;
              }
            }
          }   
  
          
          String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber - 0, 0);
          
          String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
  
          obj_lastFaceNumber += 1;            
          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          if (objExportBackSides != 0) {
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
          }          
        }  
  
      }
    }
  }




  if (Display_Trees_People != 0) {

    if (objExportMaterialLibrary != 0) {
      
      int[] Object2D_ImageUsed = new int [Object2D_ImagePath.length];
      
      for (int i = 0; i < Object2D_ImageUsed.length; i++) {
         Object2D_ImageUsed[i] = 0;
      }
      
      for (int f = 1; f <= allObject2D_num; f++) {

        int n = abs(allObject2D_MAP[f]);

        Object2D_ImageUsed[n] += 1;
      }
    
      for (int i = 1; i < Object2D_ImagePath.length; i++) {
        
        if (Object2D_ImageUsed[i] != 0) {
        
          String old_TEXTURE_path = Object2D_ImagePath[i];
          
          String new_TEXTURE_path = "";
          
          String opacity_TEXTURE_path = "";
          
          String the_filename = "";
          
          if (Object2D_ImagePath[i].equals("")) {
          }  
          else {
    
            the_filename = old_TEXTURE_path.substring(old_TEXTURE_path.lastIndexOf("/") + 1); // image name
      
            new_TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
            opacity_TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + "opacity_" + the_filename;
      
            println("Copying texture:", old_TEXTURE_path, ">", new_TEXTURE_path);
            saveBytes(new_TEXTURE_path, loadBytes(old_TEXTURE_path));
            
            println("Making opacity texture:", new_TEXTURE_path);
            
            int RES1 = Object2DImages[i].width;
            int RES2 = Object2DImages[i].height;
            
            PImage Opacity_Texture = createImage(RES1, RES2, ARGB);
    
            Opacity_Texture.loadPixels();
            
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
            
              color COL = Object2DImages[i].get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              
              float COL_V = (COL >> 24 & 0xFF);
              
              Opacity_Texture.pixels[np] = color(COL_V, COL_V, COL_V, COL_V);        
            }
            
            Opacity_Texture.updatePixels();
            
            Opacity_Texture.save(opacity_TEXTURE_path);
            
            
            mtlOutput.println("newmtl " + "Object2D_" + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
        
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
            //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map        
            mtlOutput.println("\tmap_d " + objMapsSubfolder + "opacity_" + the_filename); // diffuse map
          }
        }    
      }
    }
    
    for (int f = 1; f <= allObject2D_num; f++) {

      int n = abs(allObject2D_MAP[f]);
      
      int w = Object2DImages[n].width; 
      int h = Object2DImages[n].height;
              
      float x = allObject2D_XYZS[f][0];
      float y = allObject2D_XYZS[f][1];
      float z = allObject2D_XYZS[f][2];
      
      float rh = allObject2D_XYZS[f][3] * 0.5;
      float rw = rh * Object2DImageRatios[n];
      
      float t = WIN3D_RZ_coordinate * PI / 180.0;
      if (WIN3D_View_Type == 1) t = atan2(y - CAM_y, x - CAM_x) + 0.5 * PI; 
      
      if (allObject2D_MAP[f] < 0) t += PI;            
      
      if (objExportPolyToPoly == 1) {
        obj_lastGroupNumber += 1;  
        objOutput.println("g Object2D_" + nf(f, 0) + "_type" + nf(n, 0));
      }

      if (objExportMaterialLibrary != 0) {
        objOutput.println("usemtl Object2D_" + Object2D_ImagePath[n].substring(Object2D_ImagePath[n].lastIndexOf("/") + 1).replace('.', '_'));
      }
      
      num_vertices_added = 0;
      
      for (int _turn = 1; _turn < 4; _turn += 1) {
  
        { 
          
          if (_turn == 1) {
            float x1 = x - rw * cos(t);
            float y1 = y - rw * sin(t);
            float z1 = z;
      
            float x2 = x + rw * cos(t);
            float y2 = y + rw * sin(t);
            float z2 = z;
      
            float x3 = x + rw * cos(t);
            float y3 = y + rw * sin(t);
            float z3 = z + 2 * rh;
    
            float x4 = x - rw * cos(t);
            float y4 = y - rw * sin(t);
            float z4 = z + 2 * rh;
          
            objOutput.println("v " + nf(x1, 0, objExportPrecisionVertex) + " " + nf(y1, 0, objExportPrecisionVertex) + " " + nf(z1, 0, objExportPrecisionVertex));
            objOutput.println("v " + nf(x2, 0, objExportPrecisionVertex) + " " + nf(y2, 0, objExportPrecisionVertex) + " " + nf(z2, 0, objExportPrecisionVertex));
            objOutput.println("v " + nf(x3, 0, objExportPrecisionVertex) + " " + nf(y3, 0, objExportPrecisionVertex) + " " + nf(z3, 0, objExportPrecisionVertex));
            objOutput.println("v " + nf(x4, 0, objExportPrecisionVertex) + " " + nf(y4, 0, objExportPrecisionVertex) + " " + nf(z4, 0, objExportPrecisionVertex));
            
            num_vertices_added += 4;
          }
          
          if (_turn == 2) {
            objOutput.println("vt 0 0 0");
            objOutput.println("vt 1 0 0");
            objOutput.println("vt 1 1 0");      
            objOutput.println("vt 0 1 0");
          }

          if (_turn == 3) {
            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;

            String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 1, 0); 
            String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 3, 0);
            String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4, 0);
            
            String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 1, 0); 
            String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 3, 0);
            String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4, 0);      
    
            if (objExportPolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println("g Object2D_" + nf(f, 0) + "_ver");
            } 
            
            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (objExportBackSides != 0) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
          }
  
        }
        
        
        if (n > Object2D_PEOPLE_Files_Num) { // case: trees    
        
          float ratio = 0.5;
        
          for (int back_front = -1; back_front <= 1; back_front += 2) {

            if (_turn == 1) {
            
              float rot = back_front * PI / 2 + t;
              
              float x1 = x - rw * cos(t);
              float y1 = y - rw * sin(t);
              float z1 = z + 2 * rh * ratio;
        
              float x2 = x + rw * cos(t);
              float y2 = y + rw * sin(t);
              float z2 = z + 2 * rh * ratio;
        
              float x3 = x + rw * cos(t) + rw * cos(rot);
              float y3 = y + rw * sin(t) + rw * sin(rot);
              float z3 = z + 2 * rh * ratio;
      
              float x4 = x - rw * cos(t) + rw * cos(rot);
              float y4 = y - rw * sin(t) + rw * sin(rot);
              float z4 = z + 2 * rh * ratio;
          
              objOutput.println("v " + nf(x1, 0, objExportPrecisionVertex) + " " + nf(y1, 0, objExportPrecisionVertex) + " " + nf(z1, 0, objExportPrecisionVertex));
              objOutput.println("v " + nf(x2, 0, objExportPrecisionVertex) + " " + nf(y2, 0, objExportPrecisionVertex) + " " + nf(z2, 0, objExportPrecisionVertex));
              objOutput.println("v " + nf(x3, 0, objExportPrecisionVertex) + " " + nf(y3, 0, objExportPrecisionVertex) + " " + nf(z3, 0, objExportPrecisionVertex));
              objOutput.println("v " + nf(x4, 0, objExportPrecisionVertex) + " " + nf(y4, 0, objExportPrecisionVertex) + " " + nf(z4, 0, objExportPrecisionVertex));
              
              num_vertices_added += 4;
            }
            
            if (_turn == 2) {
              objOutput.println("vt 0 " + nf(1 - ratio, 0, objExportPrecisionVtexture) + " 0");
              objOutput.println("vt 1 " + nf(1 - ratio, 0, objExportPrecisionVtexture) + " 0");
              objOutput.println("vt 1 1 0");      
              objOutput.println("vt 0 1 0");
            }
      
            if (_turn == 3) {
              
              int q = (back_front + 1) / 2;
             
              String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
              String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
              String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
              String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 4, 0);
              
              String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
              String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
              String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 4, 0);      

              if (objExportPolyToPoly == 0) {
                obj_lastGroupNumber += 1;
                objOutput.println("g Object2D_" + nf(f, 0) + "_hor" + nf(q, 0));
              } 
              
              obj_lastFaceNumber += 1;            
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              if (objExportBackSides != 0) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
              }
              
            }    
          }    
        }         
        
      }    
    }

  }


  if (Display_Building_Model != 0) {

    
    
    int Create_Face_Texture = 0;
    
    if ((WIN3D_FACES_SHADE == Shade_Global_Solar) || (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) || (WIN3D_FACES_SHADE == Shade_Vertex_Elevation)) {
      Create_Face_Texture = 1;
    }
    
    if (Create_Face_Texture == 0) {

      if (objExportMaterialLibrary != 0) {

        int[] Materials_Used = new int [Materials_Number];
        
        for (int i = 0; i < Materials_Used.length; i++) {
           Materials_Used[i] = 0;
        }

        for (int f = 1; f < allFaces.length; f++) {
      
          int mt = allFaces_MTLV[f][0];

          Materials_Used[mt] += 1;
        }    
        
        for (int mt = 0; mt < Materials_Number; mt++) {
          
          if (Materials_Used[mt] != 0) {
  
            float a = Materials_Color[mt][0] / 255.0; 
            float r = Materials_Color[mt][1] / 255.0; 
            float g = Materials_Color[mt][2] / 255.0; 
            float b = Materials_Color[mt][3] / 255.0; 
            
            mtlOutput.println("newmtl SurfaceMaterial_" + nf(mt, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // ambient
            mtlOutput.println("\tKd " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
        
            mtlOutput.println("\td " + nf(a, 0, 3)); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr " + nf(a, 0, 3)); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter      
          }
        }
      }


      for (int OBJ_NUM = 1; OBJ_NUM < allPolymesh_Faces.length; OBJ_NUM++) {
        
        if (allPolymesh_Faces[OBJ_NUM][0] <= allPolymesh_Faces[OBJ_NUM][1]) {
          
          for (int back_or_front = 1 - objExportBackSides; back_or_front <= 1; back_or_front++) {
          
            num_vertices_added = 0;
            
            for (int _turn = 1; _turn < 4; _turn += 1) {
              
              if (_turn == 3) {
                if (objExportPolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }
              }  
              
              int prev_mt = -1;
  
              for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
                
                if (_turn == 3) {
                  if (objExportMaterialLibrary != 0) {
                    int mt = allFaces_MTLV[f][0];
                    if (prev_mt != mt) {
                      objOutput.println("usemtl SurfaceMaterial_" + nf(mt, 0));
                      prev_mt = mt;
                    }
                  }                
                }                  
      
                int Tessellation = allFaces_MTLV[f][1];
                
                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_TESSELLATION;
                }
                
                if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
          
                for (int n = 0; n < TotalSubNo; n++) {
                 
                  float[][] base_Vertices = new float [allFaces[f].length][3];
                  for (int j = 0; j < allFaces[f].length; j++) {
                    int vNo = allFaces[f][j];
                    base_Vertices[j][0] = allVertices[vNo][0];
                    base_Vertices[j][1] = allVertices[vNo][1];
                    base_Vertices[j][2] = allVertices[vNo][2];
                  }
                  
                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
          
                  for (int s = 0; s < subFace.length; s++) {

                    if (_turn == 1) {
                      objOutput.println("v " + nf(subFace[s][0], 0, objExportPrecisionVertex) + " " +  nf(subFace[s][1], 0, objExportPrecisionVertex) + " " +  nf(subFace[s][2], 0, objExportPrecisionVertex));
                    }
                    
                    if (_turn == 2) {
                      
                      float t = PI / float(subFace.length);

                      float u = 0.5 * cos((2 * s + 1) * t) / cos(t) + 0.5;
                      float v = 0.5 * sin((2 * s + 1) * t) / cos(t) + 0.5;
                      
                      objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
                    }
                    
                  }
                  
                  
                  if (_turn == 3) {
                    
                    num_vertices_added += subFace.length;
                    
                    if (objExportPolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }                    
  
                    obj_lastFaceNumber += 1;
                    
                    objOutput.print("f ");
                    if (back_or_front == 1) {
                      for (int s = 0; s < subFace.length; s++) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s < subFace.length - 1) {
                          objOutput.print(" ");
                        } 
                      }
                    }
                    else {
                      for (int s = subFace.length - 1; s >= 0; s--) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s > 0) {
                          objOutput.print(" ");
                        } 
                      }
                    }
                    objOutput.println("");
                  }                    

                }
              }
            }
  
            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;              
          }
        }
      }

    
    }
    else {
      
      int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
      int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
      float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 

      for (int OBJ_NUM = 1; OBJ_NUM < allPolymesh_Faces.length; OBJ_NUM++) {
        
        if (allPolymesh_Faces[OBJ_NUM][0] <= allPolymesh_Faces[OBJ_NUM][1]) {
          
          int Number_Of_Face_Subdivisions = 0; // for combined materials we need to know this number before baking each object.
      
          if (objExportMaterialLibrary != 0) {
                
            for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
  
              int Tessellation = allFaces_MTLV[f][1];
            
              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_TESSELLATION;
              }
              
              if ((allFaces[f].length != 4) && (Tessellation == 0)) {
                Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
              }
              
              if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
        
              for (int n = 0; n < TotalSubNo; n++) {
    
                Number_Of_Face_Subdivisions += 1;
              }
            }
          }
       
          println("Number_Of_Face_Subdivisions", Number_Of_Face_Subdivisions);   
              
          for (int back_or_front = 1 - objExportBackSides; back_or_front <= 1; back_or_front++) {
          
            String the_filename = "";
            String TEXTURE_path = "";
  
  
            PGraphics[] Face_Texture = new PGraphics [1 + Number_Of_Face_Subdivisions];
            
            num_vertices_added = 0;
            
            if (objExportMaterialLibrary != 0) {
              if (objExportCombinedMaterial == 1) {            
  
                the_filename = "Combined_Texture" + "_obj" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + ".bmp";
  
                TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
        
                println("Combined texture:", TEXTURE_path);
                
                mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
            
                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          
                //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
                mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map  
                
              }
            }         
           

            
            for (int _turn = 1; _turn < 4; _turn += 1) {
              
              int CurrentFaceTextureNumber = -1;
              
              if (_turn == 3) {
                if (objExportPolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }
                
                if (objExportMaterialLibrary != 0) {
                  if (objExportCombinedMaterial == 1) { 
                    objOutput.println("usemtl " +  the_filename.replace('.', '_'));
                  }
                }                 
              }  
  
              for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
      
                int Tessellation = allFaces_MTLV[f][1];
                
                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_TESSELLATION;
                }
                
                if ((allFaces[f].length != 4) && (Tessellation == 0)) {
                  Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
                }
                
                if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
          
                float x1 = 0;
                float y1 = 0;
                float z1 = 0;
          
                float x2 = 0;
                float y2 = 0;
                float z2 = 0;
          
                float x3 = 0;
                float y3 = 0;
                float z3 = 0;
          
                float x4 = 0;
                float y4 = 0;
                float z4 = 0;
          
                for (int n = 0; n < TotalSubNo; n++) {
  
                 CurrentFaceTextureNumber += 1;
                 
                 if (_turn == 1) {   
                   
                    if (objExportMaterialLibrary != 0) {
                      
                      if (objExportCombinedMaterial == 0) { 
                        the_filename = "Face_Texture" + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0) + ".jpg";
                        
                        TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
                
                        println("Baking texture:", TEXTURE_path);
                      }
                   
                      
                      int RES1 = objExportBakingResolution;
                      int RES2 = objExportBakingResolution;                      
                      
                      Face_Texture[CurrentFaceTextureNumber] = createGraphics(RES1, RES2, P2D);
  
                      Face_Texture[CurrentFaceTextureNumber].beginDraw();
                      
                      float[][] base_Vertices = new float [allFaces[f].length][3];
                      for (int j = 0; j < allFaces[f].length; j++) {
                        int vNo = allFaces[f][j];
                        base_Vertices[j][0] = allVertices[vNo][0];
                        base_Vertices[j][1] = allVertices[vNo][1];
                        base_Vertices[j][2] = allVertices[vNo][2];
                      }
                      
                      float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
              
                      Face_Texture[CurrentFaceTextureNumber].noStroke();
                      Face_Texture[CurrentFaceTextureNumber].beginShape(QUADS);
                      
                      for (int s = 0; s < subFace.length; s++) {

                        float[] _COL = {255, 255, 255, 255};
                  
                        if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
                          int s_next = (s + 1) % subFace.length;
                          int s_prev = (s + subFace.length - 1) % subFace.length;
                          
                          if (back_or_front == 0) {
                            int s_temp = s_next;
                            s_next = s_prev;
                            s_prev = s_temp;
                          }
                          
                          _COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                        }              
                    
                        if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
                          
                          _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Spatial(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                        }                  
                        
                        if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
                          
                          _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                        }
              
                        Face_Texture[CurrentFaceTextureNumber].fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                        
                        if (s == 0) {
                          Face_Texture[CurrentFaceTextureNumber].vertex(0, 0);
                          x1 = subFace[s][0];
                          y1 = subFace[s][1];
                          z1 = subFace[s][2];
                        }
                        if (s == 1) {
                          Face_Texture[CurrentFaceTextureNumber].vertex(RES1, 0);
                          x2 = subFace[s][0];
                          y2 = subFace[s][1];
                          z2 = subFace[s][2];
                        }            
                        if (s == 2) { 
                          Face_Texture[CurrentFaceTextureNumber].vertex(RES1, RES2);
                          x3 = subFace[s][0];
                          y3 = subFace[s][1];
                          z3 = subFace[s][2];
                        }          
                        if (s == 3) {
                          Face_Texture[CurrentFaceTextureNumber].vertex(0, RES2);
                          x4 = subFace[s][0];
                          y4 = subFace[s][1];
                          z4 = subFace[s][2];
                        }
                      }
                    
                      //Face_Texture[CurrentFaceTextureNumber].endShape(CLOSE);
                      Face_Texture[CurrentFaceTextureNumber].endShape();
                 
                      Face_Texture[CurrentFaceTextureNumber].endDraw();
                      
                      if (objExportCombinedMaterial == 0) {
                        Face_Texture[CurrentFaceTextureNumber].save(TEXTURE_path);
  
                        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
                    
                        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
                  
                        //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
                        mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map  
                      }
                    }

                    objOutput.println("v " + nf(x1, 0, objExportPrecisionVertex) + " " +  nf(y1, 0, objExportPrecisionVertex) + " " +  nf(z1, 0, objExportPrecisionVertex));
                    objOutput.println("v " + nf(x2, 0, objExportPrecisionVertex) + " " +  nf(y2, 0, objExportPrecisionVertex) + " " +  nf(z2, 0, objExportPrecisionVertex));
                    objOutput.println("v " + nf(x3, 0, objExportPrecisionVertex) + " " +  nf(y3, 0, objExportPrecisionVertex) + " " +  nf(z3, 0, objExportPrecisionVertex));
                    objOutput.println("v " + nf(x4, 0, objExportPrecisionVertex) + " " +  nf(y4, 0, objExportPrecisionVertex) + " " +  nf(z4, 0, objExportPrecisionVertex));
                  }
                  
                  if (_turn == 2) {

                    float u1 = 0;
                    float v1 = 1;
                    
                    float u2 = 1;
                    float v2 = 1;
                    
                    float u3 = 1;
                    float v3 = 0;
                    
                    float u4 = 0;
                    float v4 = 0;
                    
                    if (objExportCombinedMaterial == 1) {
                      
                      // also considering two pixles added to the left and right
                      
                      u1 = (CurrentFaceTextureNumber * (2 + objExportBakingResolution) + 1) / float(Number_Of_Face_Subdivisions * (2 + objExportBakingResolution));
                      v1 = 1;
                      
                      u2 = (CurrentFaceTextureNumber * (2 + objExportBakingResolution) + objExportBakingResolution + 1) / float(Number_Of_Face_Subdivisions * (2 + objExportBakingResolution));
                      v2 = 1;
                      
                      u3 = u2;
                      v3 = 0;
                      
                      u4 = u1;
                      v4 = 0;
                    
                    }
                    
                    objOutput.println("vt " + nf(u1, 0, objExportPrecisionVtexture) + " " + nf(v1, 0, objExportPrecisionVtexture) + " 0");
                    objOutput.println("vt " + nf(u2, 0, objExportPrecisionVtexture) + " " + nf(v2, 0, objExportPrecisionVtexture) + " 0");
                    objOutput.println("vt " + nf(u3, 0, objExportPrecisionVtexture) + " " + nf(v3, 0, objExportPrecisionVtexture) + " 0");
                    objOutput.println("vt " + nf(u4, 0, objExportPrecisionVtexture) + " " + nf(v4, 0, objExportPrecisionVtexture) + " 0");
                  
                  }
                  
                  if (_turn == 3) {

                    num_vertices_added += 4;
  
                    if (objExportPolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }
                    
                    if (objExportMaterialLibrary != 0) {
                      if (objExportCombinedMaterial == 0) {
                        objOutput.println("usemtl " +  the_filename.replace('.', '_'));
                      }
                    }
                    
                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
                    
                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
                    
                    obj_lastFaceNumber += 1;
                    if (back_or_front == 1) {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    }
                    else {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                  
                }
              }
            }
  
  
            if (objExportMaterialLibrary != 0) {
              if (objExportCombinedMaterial == 1) {            
  
                int RES1 = (2 + objExportBakingResolution) * Number_Of_Face_Subdivisions; // adding two pixels to left and right as margin
                int RES2 = objExportBakingResolution;      
            
                PGraphics Combined_Texture = createGraphics(RES1, RES2, P2D);          
          
                Combined_Texture.beginDraw();
          
                for (int i = 0; i < Number_Of_Face_Subdivisions; i++) {
                  
                  int w = Face_Texture[i].width;
                  int h = Face_Texture[i].height;
                  
                  Combined_Texture.image(Face_Texture[i], i * (2 + objExportBakingResolution), 0, w + 2, h); // first stretching the image by 2 pixel below!
                  Combined_Texture.image(Face_Texture[i], i * (2 + objExportBakingResolution) + 1, 0); // then adding the original on top.
  
                }
                
                Combined_Texture.endDraw();
                
                Combined_Texture.save(TEXTURE_path);
              }
  
            }            

            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;              
          }
        }
      }
    }
  }

  


  if (Display_FractalPlant != 0) {

    if (objExportMaterialLibrary != 0) {
      
      if (allFractal_num != 0) {
        
        mtlOutput.println("newmtl " + "FractalPlant_Trunk");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 0.750 0.500"); // ambient
        mtlOutput.println("\tKd 1.000 0.750 0.500"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
    
        mtlOutput.println("newmtl " + "FractalPlant_Leaf");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 0.500 0.750 0.250"); // ambient
        mtlOutput.println("\tKd 0.500 0.750 0.250"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      }
    }

    
    for (int f = 1; f <= allFractal_num; f++) {

      float x = allFractal_XYZSRA[f][0];
      float y = allFractal_XYZSRA[f][1];
      float z = allFractal_XYZSRA[f][2];
      
      float r = allFractal_XYZSRA[f][3] * 0.5;
      float rot = allFractal_XYZSRA[f][4];
      float as_Solid = allFractal_XYZSRA[f][5];

      int n = allFractal_Type[f];

      int dMin = allFractal_DegreeMin[f];

      int dMax = allFractal_DegreeMax[f];

      int s = allFractal_Seed[f];

      float TrunkSize = allFractal_TrunkSize[f];
      
      float LeafSize = allFractal_LeafSize[f];
      
      randomSeed(s);

      if (n == 0) {

        num_vertices_added = 0;
        
        if (objExportPolyToPoly == 1) {
          obj_lastGroupNumber += 1;
          objOutput.println("g FractalPlant_" + nf(f, 0));
          
        }    
        
        float Alpha = 0;
        float Beta = rot; 
        
        for (int _turn = 1; _turn < 4; _turn += 1) {
          SOLARCHVISION_Plant_branch_objExport(_turn, x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, as_Solid);
        }

        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;                
        
      }
    }
  }  


  
  if (Display_windFlow != 0) {  
    
    int PAL_TYPE = windFlow_Pallet_CLR; 
    int PAL_DIR = windFlow_Pallet_DIR; 
    float PAL_Multiplier = windFlow_Pallet_MLT;
    
    String the_filename = "";

    if (objExportMaterialLibrary != 0) {
      
      the_filename = "windFlow_Pallet.bmp";
      
      String TEXTURE_path = Model3DFolder + "/" + objMapsSubfolder + the_filename;
        
      println("Saving texture:", TEXTURE_path);
      
      int RES1 = 256; // adding two pixels to left and right as margin
      int RES2 = 2;      
  
      PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       
   
   
      Pallet_Texture.loadPixels();
          
      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;
        
        float _val = (Image_X / (0.5 * RES1)) - 1; 
        
        float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;        
      
        float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);  
        
        Pallet_Texture.pixels[np] = color(_COL[1], _COL[2], _COL[3], _COL[0]);        
      }
      
      Pallet_Texture.updatePixels();   
   
      Pallet_Texture.save(TEXTURE_path);      

    
      mtlOutput.println("newmtl " + "windFlow");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      //mtlOutput.println("\tmap_Ka " + objMapsSubfolder + the_filename); // ambient map
      mtlOutput.println("\tmap_Kd " + objMapsSubfolder + the_filename); // diffuse map  
  
    }    
    
    num_vertices_added = 0;
    
    for (int q = 1; q < windFlow_Lines.length; q++) {

      int n1 = windFlow_Lines[q][0];
      int n2 = windFlow_Lines[q][1];
      
      float x1 = windFlow_Vertices[n1][0];
      float y1 = windFlow_Vertices[n1][1];
      float z1 = windFlow_Vertices[n1][2];

      float x2 = windFlow_Vertices[n2][0];
      float y2 = windFlow_Vertices[n2][1];
      float z2 = windFlow_Vertices[n2][2];
            
      
      float _val = windFlow_Pallet_MLT * windFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

      float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float the_dist = dist(x1, y1, z1, x2, y2, z2);
      
      float[] W = {x2 - x1, y2 - y1, z2 - z1};
      W = fn_normalize(W);
  
      float Alpha = asin_ang(W[2]);
      float Beta = atan2_ang(W[1], W[0]) + 90;   

      

      objOutput.println("v " + nf(x1, 0, objExportPrecisionVertex) + " " +  nf(y1, 0, objExportPrecisionVertex) + " " +  nf(z1, 0, objExportPrecisionVertex));
      objOutput.println("v " + nf(x2, 0, objExportPrecisionVertex) + " " +  nf(y2, 0, objExportPrecisionVertex) + " " +  nf(z2, 0, objExportPrecisionVertex));
    
      for (int i = 0; i < 4; i++) {

        float px = 0.1 * the_dist * cos(i * HALF_PI);
        float py = 0;
        float pz = 0.1 * the_dist * sin(i * HALF_PI); 
      
        float pz_rot = pz;
        float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
        float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  
        
        px = px_rot;
        py = py_rot;
        pz = pz_rot;
      
        px_rot = px;
        py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
        pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);
    
        px = px_rot;
        py = py_rot;
        pz = pz_rot;    
  
        objOutput.println("v " + nf(x1 + px, 0, objExportPrecisionVertex) + " " +  nf(y1 + py, 0, objExportPrecisionVertex) + " " +  nf(z1 + pz, 0, objExportPrecisionVertex));      
      }
      
      for (int i = 0; i < 6; i++) {
        
        float u1 = 1 - _u;
        
        if (u1 > 0.999) u1 = 0.999;
        if (u1 < 0.001) u1 = 0.001;
        
        objOutput.println("vt " + nf(u1, 0, objExportPrecisionVtexture) + " 0 0");
      }
      
      num_vertices_added += 6;
      
      obj_lastGroupNumber += 1;
      objOutput.println("g windFlow_" + nf(q, 0));
      
      if (objExportMaterialLibrary != 0) {
        objOutput.println("usemtl windFlow");
      }      

      String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 5, 0); 
      String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 4, 0);
      String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
      String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
      String n5_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
      String n6_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
      
      String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 5, 0); 
      String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 4, 0);
      String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
      String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
      String m5_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
      String m6_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
      
      objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
      objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n4_txt + "/" + m4_txt + " " + n5_txt + "/" + m5_txt);
      objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n5_txt + "/" + m5_txt + " " + n6_txt + "/" + m6_txt);
      objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n6_txt + "/" + m6_txt + " " + n3_txt + "/" + m3_txt);
      
      obj_lastFaceNumber += 4;

    }

    obj_lastVertexNumber += num_vertices_added;
    obj_lastVtextureNumber += num_vertices_added;         
  }


  if (Display_SUN3D_Pattern != 0) {

    float keep_per_day = per_day;
    int keep_num_add_days = num_add_days;
    if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
      per_day = 1;
      num_add_days = 1;
    }    
    
    float previous_DATE = _DATE;
    
    SOLARCHVISION_draw_SunPathCycles(0, 0, 0, 0.9 * SKY3D_scale, 0.9 * SKY3D_scale, 0.9 * SKY3D_scale, impact_layer, 4);

    per_day = keep_per_day;
    num_add_days = keep_num_add_days; 
    _DATE = previous_DATE;
    SOLARCHVISION_update_date();
  
  }

  if (objExportMaterialLibrary != 0) {
    mtlOutput.flush(); 
    mtlOutput.close();
  }
 
  objOutput.flush(); 
  objOutput.close();   
 
  
  println("End of exporting the mesh."); 
 
  SOLARCHVISION_explore_output(objFilename);
}



void SOLARCHVISION_export_objects_script () {
  
  String scrFilename = Model3DFolder + "/" + ProjectName + "_ObjectsMesh.scr";

  PrintWriter scrOutput = createWriter(scrFilename);
  
  scrOutput.println("-osnap off");
  
  for (int f = 1; f < allFaces.length; f++) {
    
    if ((allFaces[f].length == 3) || (allFaces[f].length == 4)) {
      
      scrOutput.println("3dface");
      
      for (int j = 0; j < allFaces[f].length; j++) {
        
        float x = allVertices[allFaces[f][j]][0];
        float y = allVertices[allFaces[f][j]][1];
        float z = allVertices[allFaces[f][j]][2];
        
        /*
        { 
          z += 20;
          x *= 1000000;
          y *= 1000000;
          z *= 1000000;
        }
        */
        
        scrOutput.println(x + "," + y + "," + z);
      }
      scrOutput.println();
      scrOutput.println();
    }
  }
  
  scrOutput.println("zoom e");
  
  scrOutput.flush(); 
  scrOutput.close();   
  
  println("End of scripting the mesh."); 
  
  SOLARCHVISION_explore_output(scrFilename);
}
    
  
void SOLARCHVISION_import_objects (String FileName, int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float sx, float sy, float sz) {
  
  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;
  
  int[] importVerticeNumber = {0};
  
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;
    
  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f += 1) {
    
    lineSTR = FileALL[f];
    //println (lineSTR);
    
    lineSTR = lineSTR.replace("  ", " ");
    
    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("g")) {
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % 8);
      
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    }
    
    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);
      
      int[] v = {SOLARCHVISION_addToVertices(x, y, z)};
      
      importVerticeNumber = concat(importVerticeNumber, v);
    }
    
    if (parts[0].toLowerCase().equals("f")) {
      
      //println(parts);
      
      int FaceDegree = parts.length - 1; // if we don't have space at the end of the line.
      
      if (parts[FaceDegree].equals("")) {  // if we have 1 space at the end of the line.
        FaceDegree -= 1;
      }
      
      int[] newFace = new int [FaceDegree]; 
    
      for (int n = 0; n < newFace.length; n += 1) {
        
        String[] the_numbers = split(parts[n + 1], '/');
        
        int vertexNumber = int(the_numbers[0]);
        
        if (vertexNumber > 0) {
          newFace[n] = importVerticeNumber[vertexNumber];
        }
        else if (vertexNumber < 0) { // for negative numbering
          newFace[n] = allVertices.length - abs(vertexNumber);
        }
        else { // case 0
        }
      }
      
      //println(newFace);
      
      SOLARCHVISION_addToFaces(newFace);
    }
    
  }
}  


float SOLARCHVISION_import_objects_asParametricBox (String FileName, int m, float cx, float cy, float cz, float sx, float sy, float sz) {

  float[][] importVertices = {{}};
  
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;
    
  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f += 1) {
    
    lineSTR = FileALL[f];
    //println (lineSTR);
    
    lineSTR = lineSTR.replace("  ", " ");
    
    String[] parts = split(lineSTR, ' ');
    
    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);
      
      float[][] v = {{x, y, z}};
      
      importVertices = (float[][]) concat(importVertices, v);
    }
  }
  
  float min_X = FLOAT_undefined;
  float max_X = -FLOAT_undefined;
  float min_Y = FLOAT_undefined;
  float max_Y = -FLOAT_undefined;
  float min_Z = FLOAT_undefined;
  float max_Z = -FLOAT_undefined;
  
  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];
    
    if (min_X > x) min_X = x;
    if (max_X < x) max_X = x;
    if (min_Y > y) min_Y = y;
    if (max_Y < y) max_Y = y;
    if (min_Z > z) min_Z = z;
    if (max_Z < z) max_Z = z;
  }
  
  float cen_X = 0.5 * (min_X + max_X);
  float cen_Y = 0.5 * (min_Y + max_Y);
  float cen_Z = 0.5 * (min_Z + max_Z);

  float R_out = 0;
  float X_out = 0;
  float Y_out = 0;
  float Z_out = 0;
  
  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];
    
    float r = dist(cen_X, cen_Y, cen_Z, x, y, z);
    
    if (R_out < r) {
      R_out = r;
      
      X_out = x;
      Y_out = y;
      Z_out = z;
    }
  }  

  float T_out = atan2_ang(Y_out, X_out);

  X_out = 0;
  Y_out = 0;
  Z_out = 0;
  
  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = (importVertices[vNo][0] - cen_X) * cos_ang(-T_out) - (importVertices[vNo][1] - cen_Y) * sin_ang(-T_out);
    float y = (importVertices[vNo][0] - cen_X) * sin_ang(-T_out) + (importVertices[vNo][1] - cen_Y) * cos_ang(-T_out);
    float z = importVertices[vNo][2];
    
    if (X_out < abs(x)) X_out = abs(x);
    if (Y_out < abs(y)) Y_out = abs(y);
    if (Z_out < abs(z)) Z_out = abs(z);
  }  
  
  //SOLARCHVISION_add_Box_Core(m, cen_X,cen_Y,cen_Z, X_out,Y_out,Z_out, T_out);
  SOLARCHVISION_addToSolids(1, cen_X,cen_Y,cen_Z, CubePower,CubePower,CubePower, X_out,Y_out,Z_out, 0, 0, T_out);
  
  return min_Z;
}  




void SOLARCHVISION_add_2Dobjects_onLand () {
  
  randomSeed(0);
  
  if (Display_LAND_TEXTURE != 0) {
  
    for (int i = 0; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {
        
        float pixel_area = dist(LAND_MESH[i][j][0], LAND_MESH[i][j][1], LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j+1][1]) * dist(LAND_MESH[i+1][j][0], LAND_MESH[i+1][j][1], LAND_MESH[i][j+1][0], LAND_MESH[i][j+1][1]);
        
        int max_n = int(pixel_area / 200.0);
        //int max_n = int(pixel_area / 50.0);

        
        if (max_n > 100) max_n = 100;
       
        //if (i > 8) max_n = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
       
        for (int n = 0; n < max_n; n += 1) {
          
          float di = random(1);
          float dj = random(1);
  
          float x = Bilinear(LAND_MESH[i][j][0], LAND_MESH[i][j+1][0], LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j][0], di, dj);
          float y = Bilinear(LAND_MESH[i][j][1], LAND_MESH[i][j+1][1], LAND_MESH[i+1][j+1][1], LAND_MESH[i+1][j][1], di, dj);
          float z = Bilinear(LAND_MESH[i][j][2], LAND_MESH[i][j+1][2], LAND_MESH[i+1][j+1][2], LAND_MESH[i+1][j][2], di, dj);
          
          float u = (x / LAND_TEXTURE_scale_U + 0.5) * LAND_TEXTURE.width;
          float v = (-y / LAND_TEXTURE_scale_V + 0.5) * LAND_TEXTURE.height;          
          
          color COL = LAND_TEXTURE.get(int(u), int(v));
          //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
          float r = COL >> 16 & 0xFF; 
          float g = COL >> 8 & 0xFF;
          float b = COL & 0xFF;
                                        
          if ((g > r + 10) && (g > b + 10)) { // looks more green
            if (g < 127) { // not on grass (light green)
              if (z + LocationElevation > 5) { // not in water (below see level)
              
                //float s = 5 + random(10); 
                float s = 10 + random(20); // bigger trees
    
                SOLARCHVISION_add_Object2D("TREES", 0, x, y, z, s);
              }
            }
          }

        }  
      }
    }    
  }
  else {
  
    for (int i = 0; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {
        
        float pixel_area = dist(LAND_MESH[i][j][0], LAND_MESH[i][j][1], LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j+1][1]) * dist(LAND_MESH[i+1][j][0], LAND_MESH[i+1][j][1], LAND_MESH[i][j+1][0], LAND_MESH[i][j+1][1]);
        
        int max_n = int(pixel_area / 500.0);
        if (max_n > 100) max_n = 100;
       
        if (i > 2) max_n = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
       
        //if (i < Skip_LAND_MESH_Center) max_n = 10;
        //else max_n = 0; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        
        //for (int n = 0; n < 10; n += 1) {
        for (int n = 0; n < max_n; n += 1) {
          
          float di = random(1);
          float dj = random(1);
  
          float x = Bilinear(LAND_MESH[i][j][0], LAND_MESH[i][j+1][0], LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j][0], di, dj);
          float y = Bilinear(LAND_MESH[i][j][1], LAND_MESH[i][j+1][1], LAND_MESH[i+1][j+1][1], LAND_MESH[i+1][j][1], di, dj);
          float z = Bilinear(LAND_MESH[i][j][2], LAND_MESH[i][j+1][2], LAND_MESH[i+1][j+1][2], LAND_MESH[i+1][j][2], di, dj);
          
          if (z + LocationElevation > 0) { // i.e. above sea level 
          
            if (dist(x,y,0,0) > 2.5) { // i.e. No 2D at the center!
            
              int t = 1;
  
              float r = random(i + 1); //  to illustrate more people at the center
              
              if (r < 1) t = 0; 
  
              
              if (dist(x,y,0,0) < 25) t = 0; // i.e. No tree around the center!
              
              if (t == 0) {
                SOLARCHVISION_add_Object2D("PEOPLE", 0, x, y, z, 2.5);
              }
              else {
                SOLARCHVISION_add_Object2D("TREES", 0, x, y, z, 5 + random(10));
              }
    
            }
          }
        }  
      }
    }
  }
  

}

void SOLARCHVISION_add_2Dobjects_polar (int people_or_trees, int n, float x0, float y0, float z0, float r1, float r2) {
  
  for (int i = 0; i < n; i += 1) {
    
    float a = random(360);
    float b = pow(random(pow(r1, 2), pow(r2, 2)), 0.5); // to make it uniform on the surface

    float x = x0 + b * cos_ang(a);
    float y = y0 + b * sin_ang(a);
    float z = z0;
    
    if (people_or_trees == 0) {
      SOLARCHVISION_add_Object2D("PEOPLE", 0, x, y, z, 2.5);
    }
    else {
      SOLARCHVISION_add_Object2D("TREES", 0, x, y, z, 5 + random(10));
    }
  }  
}

void SOLARCHVISION_add_2Dobjects_plane (int people_or_trees, int n, float x0, float y0, float z0, float rx, float ry) {
  
  for (int i = 0; i < n; i += 1) {
    
    //float a = random(-rx, rx); 
    //float b = random(-ry, ry);

    // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
    float a = random(1-rx, rx-1);  
    float b = random(1-ry, ry-1);

    float x = x0 + a;
    float y = y0 + b;
    float z = z0;
    
    if (people_or_trees == 0) {
      SOLARCHVISION_add_Object2D("PEOPLE", 0, x, y, z, 2.5);
    }
    else {
      SOLARCHVISION_add_Object2D("TREES", 0, x, y, z, 5 + random(10));
    }
  }  
}

void SOLARCHVISION_add_2Dobjects_Mesh2 (int people_or_trees, int n, float x1, float y1, float z1, float x2, float y2, float z2) {
  
  float x0 = 0.5 * (x1 + x2);
  float y0 = 0.5 * (y1 + y2);
  float z0 = 0.5 * (z1 + z2);

  float rx = 0.5 * abs(x2 - x1);
  float ry = 0.5 * abs(y2 - y1);
  
  for (int i = 0; i < n; i += 1) {
    
    //float a = random(-rx, rx); 
    //float b = random(-ry, ry);

    // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
    float a = random(1-rx, rx-1);  
    float b = random(1-ry, ry-1);

    float x = x0 + a;
    float y = y0 + b;
    float z = z0;
    
    if (people_or_trees == 0) {
      SOLARCHVISION_add_Object2D("PEOPLE", 0, x, y, z, 2.5);
    }
    else {
      SOLARCHVISION_add_Object2D("TREES", 0, x, y, z, 5 + random(10));
    }
  }  
}






              
void SOLARCHVISION_remove_All () {
  
  SOLARCHVISION_remove_FractalPlants();
  SOLARCHVISION_remove_2Dobjects();
  SOLARCHVISION_remove_3Dobjects();
  SOLARCHVISION_remove_Sections();
  
  WIN3D_Update = 1;
}


void SOLARCHVISION_remove_Sections () {
  allSection_UVERAB = new float [1][6]; 
  allSection_UVERAB[0][0] = 0;
  allSection_UVERAB[0][1] = 0;
  allSection_UVERAB[0][2] = 0;
  allSection_UVERAB[0][3] = 0;
  allSection_UVERAB[0][4] = 0;
  allSection_UVERAB[0][5] = 0;
  
  allSection_Type = new int [1];
  allSection_Type[0] = 0;

  allSection_RES1 = new int [1];
  allSection_RES1[0] = 0;

  allSection_RES2 = new int [1];
  allSection_RES2[0] = 0;
  
  allSection_SpatialImpact = new PImage [1];
  allSection_SpatialImpact[0] = createImage(2, 2, RGB);

  allSection_SolarImpact = new PImage[1][(1 + STUDY_j_end - STUDY_j_start)];
  {
    int i = 0;
    for (int j = STUDY_j_start; j <= STUDY_j_end; j += 1) { 
      allSection_SolarImpact[i][j] = createImage(2, 2, RGB);
    } 
  }      

  allSection_num = 0;
  
  SOLARCHVISION_deselectAll();  
}

void SOLARCHVISION_resize_allSection_SolarImpact_array () { // called when STUDY_j_end changes

  allSection_SolarImpact = new PImage[1 + allSection_num][(1 + STUDY_j_end - STUDY_j_start)];
  {
    for (int i = 0; i <= allSection_num; i++) {
      for (int j = STUDY_j_start; j <= STUDY_j_end; j += 1) { 
        allSection_SolarImpact[i][j] = createImage(2, 2, RGB);
      } 
    }
  }  

}


void SOLARCHVISION_remove_FractalPlants () {
  allFractal_XYZSRA = new float [1][6]; 
  allFractal_XYZSRA[0][0] = 0;
  allFractal_XYZSRA[0][1] = 0;
  allFractal_XYZSRA[0][2] = 0;
  allFractal_XYZSRA[0][3] = 0;
  allFractal_XYZSRA[0][4] = 0;
  allFractal_XYZSRA[0][5] = 0;
  
  allFractal_Type = new int [1];
  allFractal_Type[0] = 0;

  allFractal_DegreeMin = new int [1];
  allFractal_DegreeMin[0] = 0;

  allFractal_DegreeMax = new int [1];
  allFractal_DegreeMax[0] = 0;

  allFractal_Seed = new int [1];
  allFractal_Seed[0] = 0;

  allFractal_TrunkSize = new float [1];
  allFractal_TrunkSize[0] = 0;

  allFractal_LeafSize = new float [1];
  allFractal_LeafSize[0] = 0;
  
  allFractal_num = 0;
  
  SOLARCHVISION_deselectAll();  
}

void SOLARCHVISION_remove_2Dobjects () {
  allObject2D_XYZS = new float [1][4]; 
  allObject2D_XYZS[0][0] = 0;
  allObject2D_XYZS[0][1] = 0;
  allObject2D_XYZS[0][2] = 0;
  allObject2D_XYZS[0][3] = 0;
  
  allObject2D_MAP = new int [1];
  allObject2D_MAP[0] = 0;
  
  allObject2D_num = 0;
  
  SOLARCHVISION_deselectAll();
}

void SOLARCHVISION_remove_3Dobjects () {
  
  defaultMaterial = 7;
  defaultTessellation = 0;
  defaultSolarPivotType = 0;

  allVertices = new float [1][3];
  allVertices[0][0] = 0;
  allVertices[0][1] = 0;
  allVertices[0][2] = 0;
   
  allFaces = new int [1][3];
  allFaces[0][0] = 0;
  allFaces[0][1] = 0;
  allFaces[0][2] = 0;
  
  allFaces_MTLV = new int [1][4];
  allFaces_MTLV[0][0] = 0;
  allFaces_MTLV[0][1] = 0;
  allFaces_MTLV[0][2] = 0;
  allFaces_MTLV[0][3] = 0;

  allPolymesh_SolarPivotXYZ = new float [1][3];
  allPolymesh_SolarPivotXYZ[0][0] = 0;
  allPolymesh_SolarPivotXYZ[0][1] = 0;
  allPolymesh_SolarPivotXYZ[0][2] = 0;
  
  allPolymesh_SolarPivotType = new int [1][1];
  allPolymesh_SolarPivotType[0][0] = 0;
  
  allPolymesh_Faces = new int [1][2];
  allPolymesh_Faces[0][0] = 0;
  allPolymesh_Faces[0][1] = -1;

  allPolymesh_Solids = new int [1][2];
  allPolymesh_Solids[0][0] = 0;
  allPolymesh_Solids[0][1] = -1;
  
  SOLARCHVISION_remove_ParametricGeometries();

  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
 
  SOLARCHVISION_deselectAll();
 
  urbanVertices_start = 0;
  urbanVertices_end = 0;
  urbanFaces_start = 0;
  urbanFaces_end = 0; 
  
  //rebuild_SolarProjection_array = 1;
  //rebuild_SolarImpact_Image_array = 1;
  //rebuild_WindRose_Image_array = 1;  
  
  WIN3D_update_VerticesSolarValue = 1;  
 
}

int urbanVertices_start = 0;
int urbanVertices_end = 0;
int urbanFaces_start = 0;
int urbanFaces_end = 0;

void SOLARCHVISION_add_urban () {
  
  if (urbanVertices_start == 0) { // avoids overloading the urban model when it was loaded before.
    if (Load_URBAN_MESH == 1) {
      urbanVertices_start = allVertices.length;
      urbanFaces_start = allFaces.length;
      
      //float h = (HeightAboveGround - LocationElevation);
      float h = 0; //-20; // ?????????????????????????????????????????
  
      SOLARCHVISION_import_objects("C:/SOLARCHVISION_2015/Import/Stations/" + DEFINED_STATIONS[STATION_NUMBER][0] + ".obj", -1,0,0,1,1, 0,0,h, 1,1,1);
      
      urbanVertices_end = allVertices.length;
      urbanFaces_end = allFaces.length;
    }
  }
}

void SOLARCHVISION_add_3Dbase (int m, int tes, int lyr, int vsb, int spv) {
  
  if (Load_LAND_MESH != 0) {
  
    //SOLARCHVISION_add_Mesh2(-2, -150, -150, 0, 150, 150, 0);
    
    for (int i = 0; i < Skip_LAND_MESH_Center; i += 1) {  
      for (int j = 0; j < LAND_n_J - 1; j += 1) {
        // Material -2 for colored elevations
        SOLARCHVISION_add_Mesh4(m, tes, lyr, vsb, spv, LAND_MESH[i][j][0], LAND_MESH[i][j][1], LAND_MESH[i][j][2] , LAND_MESH[i+1][j][0], LAND_MESH[i+1][j][1], LAND_MESH[i+1][j][2] , LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j+1][1], LAND_MESH[i+1][j+1][2] , LAND_MESH[i][j+1][0], LAND_MESH[i][j+1][1], LAND_MESH[i][j+1][2]);
      }
    }  
  }
}  

int MAX_Default_Models_Number = 7;

void SOLARCHVISION_add_DefaultModel (int n) {

  if (Load_LAND_MESH == 1) {
    SOLARCHVISION_add_2Dobjects_onLand(); 
  }    
  else {
    //SOLARCHVISION_add_2Dobjects_polar(0, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // people
    //SOLARCHVISION_add_2Dobjects_polar(1, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // trees
  }  


  
  //if (n != 0) {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_Mesh2(8,0,0,1,1, -100, -100, 0, 100, 100, 0);
  //}
  
  if (n == 1) {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_House_Core(0,0,0,1,1, 0, 0, 0, 6, 6, 6, 6, 90);
  }
  
  if (n == 2) {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_House_Core(0,0,0,1,1, 0, 0, 0, 6, 6, 6, 6, 0);
  }  
  
  if (n == 3) {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_PolygonHyper(0,0,0,1,1, 0, 0, 5,  10, 10, 4, 0);
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_House_Core(7,0,0,1,1, 25, 25, 0, 6, 6, 6, 6, 0);    
  }   

  if (n == 4) {
    for (int i = 0; i < int(10 + random(10)); i++) {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      SOLARCHVISION_add_House_Core(7,0,0,1,1, random(-80, 80), random(-80, 80), 0, random(5, 10), random(5, 10), random(5, 10), random(2.5, 7.5), random(360));
    }
  }    


  if (n == 5) {
    //SOLARCHVISION Complex:

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 0, 0, 1, 3, 3);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 0, 0, 1, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 0, 1, 1, 1, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 2, 1, 1, 3, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 0, 2, 1, 3, 3);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 0, 0, 6, 4, 0.5);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 7, 0, 0, 9, 2, 2);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 7, 3, 0, 9, 4, 4);
    
    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 0, 0, 13, 4, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 0, 0, 13, 1, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 1, 0, 10.5, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 12.5, 1, 0, 13, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 3, 0, 13, 4, 1);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 4, 0, 1, 8, 2);
    
    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 5, 0, 4, 8, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 5, 0, 4, 5.5, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 5.5, 0, 2.5, 7.5, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 3.5, 5.5, 0, 4, 7.5, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 7.5, 0, 4, 8, 2);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5, 5, 0, 8, 8, 1);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 9, 5, 0, 11, 9, 1);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 12, 5, 0, 13, 7, 4);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 12, 8, 0, 13, 9, 8);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 9, 0, 4, 11, 1);
    
    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5, 9, 0, 8, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5, 9, 0, 5.5, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5.5, 9, 0, 7.5, 9.5, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5.5, 10.5, 0, 7.5, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 7.5, 9, 0, 8, 11, 2);
    
    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 12, 0, 3, 13, 3);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 12, 0, 3, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 12, 1, 1, 13, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 12, 1, 3, 13, 2);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 12, 2, 3, 13, 3);
    
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 4, 12, 0, 8, 13, 2);
    
    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 9, 10, 0, 13, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 9, 10, 0, 10, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 10, 0, 12, 10.5, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 12.5, 0, 12, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 12, 10, 0, 13, 13, 1);
    
    float model_scale = 12; // to make grid scale equal to 12m. <<<<

    for (int i = 1; i < allVertices.length; i++) {
      allVertices[i][0] -= 6.5;
      allVertices[i][1] -= 6.5; 

      allVertices[i][0] *= model_scale;
      allVertices[i][1] *= model_scale; 
      allVertices[i][2] *= model_scale; 
      
    }

  }      

  if (n == 6) {
    {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 10;
      SOLARCHVISION_add_FractalSphere(1,0,0,1,1, x,y,z, r, 5, 0, 90);
      SOLARCHVISION_addToSolids(1, x,y,z, 2,2,2, r,r,r, 0,0,0);
    }
  
    {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      float x = 30;
      float y = 0;
      float z = 0;
      float r = 8;
      SOLARCHVISION_add_FractalSphere(2,0,0,1,1, x,y,z, r, 4, 0, 90);
      SOLARCHVISION_addToSolids(1, x,y,z, 2,2,2, r,r,r, 0,0,0);
    }
  
    {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      float x = 0;
      float y = 20;
      float z = 0;
      float r = 8;
      SOLARCHVISION_add_FractalSphere(3,0,0,1,1, x,y,z, r, 3, 0, 90);
      SOLARCHVISION_addToSolids(1, x,y,z, 2,2,2, r,r,r, 0,0,0);
    }
  }
 
  if (n == 7) {
    SOLARCHVISION_add_ParametricGeometries();
  }      

 
}

void SOLARCHVISION_add_3Dobjects () {
  
  SOLARCHVISION_add_3Dbase(-2, 0, 0, 1, 0);
  
  SOLARCHVISION_add_DefaultModel(Load_Default_Models);
  
}



void SOLARCHVISION_add_ParametricSurface (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float rx, float ry, float rz, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv; 
  
  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;  
  
  float teta = rot * PI / 180.0;
  
  float stp_u = 0.1; //0.05;
  float stp_v = 0.1; //0.05;
  
  float start_u = -1;
  float start_v = -1;
  float end_u = 1;
  float end_v = 1;
  
  if (n == 1) {start_u = 0;}
  if (n == 2) {start_u = 0;}

  for (float a = start_u; a < end_u; a += stp_u) {
    for (float b = start_v; b < end_v; b += stp_v) {

      int[] newFace = {};
      
      for (int i = 0; i < 4; i++) {
        
        float u = a;
        float v = b;
        
        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;
        
        float x = 0;
        float y = 0;
        float z = 0;
        
        if (n == 1) { // LOGO:
          float x0 = cos(u * PI); 
          float y0 = sin(v * PI);
          float z0 = -sin(u * PI) * cos(v * PI);
          
          float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
          x = 0;
          y = 0;
          z = 0;
          if (d != 0) {
            x = x0 / d;  
            y = y0 / d;  
            z = z0 / d;  
          }        
        }
        else if (n == 2) { 
          x = cos(u * PI); 
          y = sin(v * PI);
          z = -sin(u * PI) * cos(v * PI);
        }        
        else if (n == 3) {
          x = sin(u * PI); 
          y = sin(v * PI);
          z = cos((u + v) * PI);
        }
        else if (n == 4) {
          float x0 = sin(u * PI); 
          float y0 = sin(v * PI);
          float z0 = cos((u + v) * PI);
          
          float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
          x = 0;
          y = 0;
          z = 0;
          if (d != 0) {
            x = x0 / d;  
            y = y0 / d;  
            z = z0 / d;  
          }
        }
        else if (n == 5) {
          x = u; 
          y = v; 
          z = cos(0.5 * u * PI) * cos(0.5 * v * PI); 
        }        
        else if (n == 6) {
          x = u; 
          y = v; 
          z = sin(u * PI) * sin(v * PI); 
        }
        else if (n == 7) {
          x = u; 
          y = v; 
          z = 0.5 * cos(u * PI) + cos(v * PI); 
        }
        

        x *= rx;
        y *= ry;
        z *= rz;
        
        float x_rot = cx + x * cos(teta) - y * sin(teta);
        float y_rot = cy + x * sin(teta) + y * cos(teta);
        float z_rot = cz + z;
        
        x = x_rot;
        y = y_rot;
        z = z_rot;

        int[] f = {SOLARCHVISION_addToVertices(x,y,z)};
        newFace = concat(newFace, f);
      }
      
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));      
    
      SOLARCHVISION_addToFaces(newFace);      
    }
  }
}




void SOLARCHVISION_build_SkySphere (int Tessellation) {
  
  SOLARCHVISION_add_FractalSphere(0,0,0,1,1, 0,0,0, 1, Tessellation, 1, 90); // SKY
  
}



float OBJECTS_scale = 1.0;  



PGraphics ViewFromTheSky (int SKY2D_X_View, int SKY2D_Y_View, float SKY2D_ZOOM_coordinate, float SKY2D_X_coordinate, float SKY2D_Y_coordinate, float SKY2D_Z_coordinate, float SKY2D_RX_coordinate, float SKY2D_RY_coordinate, float SKY2D_RZ_coordinate) {

  PGraphics SKY2D_Diagrams = createGraphics(SKY2D_X_View, SKY2D_Y_View, P3D);   
  
  SKY2D_Diagrams.beginDraw();
  
  SKY2D_Diagrams.background(233);
  
  //float ZOOM = 0.456 * SKY2D_ZOOM_coordinate * PI / 180;
  float ZOOM = 0.125 * SKY2D_ZOOM_coordinate * PI / 180;
  
  SKY2D_Diagrams.ortho(ZOOM * SKY2D_X_View * -1, ZOOM * SKY2D_X_View * 1, ZOOM  * SKY2D_Y_View * -1, ZOOM  * SKY2D_Y_View * 1, 0.00001, 100000);
  
  SKY2D_Diagrams.translate(0, 1.0 * SKY2D_Y_View, 0); // << IMPORTANT! 

  SKY2D_Diagrams.pushMatrix();
  
  SKY2D_Diagrams.translate(0, 0, 0);
  
  SKY2D_Diagrams.fill(0);
  SKY2D_Diagrams.textAlign(CENTER, CENTER); 
  SKY2D_Diagrams.textSize(5 * (SKY2D_ZOOM_coordinate / 30.0));
  SKY2D_Diagrams.text(LocationName + " [" + nfp(LocationLatitude, 0, 1) + ", " + nfp(LocationLongitude, 0, 1) + "]", 0, 60 * (SKY2D_ZOOM_coordinate / 30.0), 0);
 
  SKY2D_Diagrams.popMatrix();

  SKY2D_Diagrams.translate(SKY2D_X_coordinate, SKY2D_Y_coordinate, SKY2D_Z_coordinate);
  SKY2D_Diagrams.rotateX(SKY2D_RX_coordinate * PI / 180); 
  SKY2D_Diagrams.rotateY(SKY2D_RY_coordinate * PI / 180);
  SKY2D_Diagrams.rotateZ(SKY2D_RZ_coordinate * PI / 180); 

  SKY2D_Diagrams.hint(ENABLE_DEPTH_TEST);

  for (int f = 1; f < allFaces.length; f++) {

    int vsb = allFaces_MTLV[f][3];
    
    if (vsb > 0) {
    
      color c = color(0, 0, 0);
  
      int mt = allFaces_MTLV[f][0];
      c = color(Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3], Materials_Color[mt][0]);
      
      SKY2D_Diagrams.stroke(c);
      SKY2D_Diagrams.fill(c);
  
      int Tessellation = allFaces_MTLV[f][1];
      
      int TotalSubNo = 1;  
      if (allFaces_MTLV[f][0] == 0) {
        Tessellation += MODEL3D_TESSELLATION;
      }
      if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
      for (int n = 0; n < TotalSubNo; n++) {
        
        float[][] base_Vertices = new float [allFaces[f].length][3];
        for (int j = 0; j < allFaces[f].length; j++) {
          int vNo = allFaces[f][j];
          base_Vertices[j][0] = allVertices[vNo][0];
          base_Vertices[j][1] = allVertices[vNo][1];
          base_Vertices[j][2] = allVertices[vNo][2];
        }
        
        float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
     
        SKY2D_Diagrams.beginShape();
        
        for (int s = 0; s < subFace.length; s++) {
    
          SKY2D_Diagrams.vertex(subFace[s][0] * WIN3D_scale3D, -subFace[s][1] * WIN3D_scale3D, subFace[s][2] * WIN3D_scale3D);
        }
        
        SKY2D_Diagrams.endShape(CLOSE);
      }
    }
    
  }

  SKY2D_Diagrams.endDraw();

  return SKY2D_Diagrams;
}


void SOLARCHVISION_draw_SKY3D () {
  
  if (Display_SKY3D != 0) {
  
    for (int f = 1; f < skyFaces.length; f++) {
      
      if (WIN3D_FACES_SHADE != Shade_Global_Solar) {
      
        color c = color(191, 191, 255);
    
        WIN3D_Diagrams.noStroke();
    
        if (WIN3D_FACES_SHADE == Shade_Surface_Materials) {
          //WIN3D_Diagrams.fill(255, 255, 255);
          WIN3D_Diagrams.noFill();
        }
        else {
          WIN3D_Diagrams.fill(c);
        }    
        
        WIN3D_Diagrams.beginShape();
        
        for (int j = 0; j < skyFaces[f].length; j++) {
          int vNo = skyFaces[f][j];
          WIN3D_Diagrams.vertex(skyVertices[vNo][0] * SKY3D_scale * WIN3D_scale3D, -(skyVertices[vNo][1] * SKY3D_scale * WIN3D_scale3D), skyVertices[vNo][2] * SKY3D_scale * WIN3D_scale3D);
        }    
        
        WIN3D_Diagrams.endShape(CLOSE);
      }

      else {

        int PAL_TYPE = 0; 
        int PAL_DIR = 1;
        float PAL_Multiplier = 1; 
        
        if (Impact_TYPE == Impact_ACTIVE) {
          PAL_TYPE = SKY3D_Pallet_ACTIVE_CLR; 
          PAL_DIR = SKY3D_Pallet_ACTIVE_DIR;  
          PAL_Multiplier = 1.0 * SKY3D_Pallet_ACTIVE_MLT;  
        }
        if (Impact_TYPE == Impact_PASSIVE) {
          PAL_TYPE = SKY3D_Pallet_PASSIVE_CLR; 
          PAL_DIR = SKY3D_Pallet_PASSIVE_DIR;  
          PAL_Multiplier = 0.05 * SKY3D_Pallet_PASSIVE_MLT; 
        }             
        
         
  
        int Tessellation = 0;
        
        int TotalSubNo = 1;  
        Tessellation = SKY3D_TESSELLATION;
        if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
    
        for (int n = 0; n < TotalSubNo; n++) {
          
          float[][] base_Vertices = new float [skyFaces[f].length][3];
          for (int j = 0; j < skyFaces[f].length; j++) {
            int vNo = skyFaces[f][j];
            base_Vertices[j][0] = skyVertices[vNo][0];
            base_Vertices[j][1] = skyVertices[vNo][1];
            base_Vertices[j][2] = skyVertices[vNo][2];
          }
          
          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
          
          for (int j = 0; j < subFace.length; j++) {
            subFace[j] = fn_normalize(subFace[j]);
          }
       
          WIN3D_Diagrams.beginShape();
          
          for (int s = 0; s < subFace.length; s++) {
            
            int s_next = (s + 1) % subFace.length;
            int s_prev = (s + subFace.length - 1) % subFace.length;
            
            //if ((subFace[s][2] > -0.2) && (subFace[s_prev][2] > -0.2) && (subFace[s_next][2] > -0.2)) // to remove below
            { 
              float[] _COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
        
              WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
              
              WIN3D_Diagrams.vertex(subFace[s][0] * SKY3D_scale * WIN3D_scale3D, -(subFace[s][1] * SKY3D_scale * WIN3D_scale3D), subFace[s][2] * SKY3D_scale * WIN3D_scale3D);
            }            
          }
          
          WIN3D_Diagrams.endShape(CLOSE);
        }
      }
  
    }
  }
}














void SOLARCHVISION_draw_windFlow () {
  
 
  
  if (Display_windFlow != 0) {  

    int PAL_TYPE = windFlow_Pallet_CLR; 
    int PAL_DIR = windFlow_Pallet_DIR; 
    float PAL_Multiplier = windFlow_Pallet_MLT;
   
    

    for (int q = 1; q < windFlow_Lines.length; q++) {

      int n1 = windFlow_Lines[q][0];
      int n2 = windFlow_Lines[q][1];
      
      float x1 = windFlow_Vertices[n1][0];
      float y1 = windFlow_Vertices[n1][1];
      float z1 = windFlow_Vertices[n1][2];

      float x2 = windFlow_Vertices[n2][0];
      float y2 = windFlow_Vertices[n2][1];
      float z2 = windFlow_Vertices[n2][2];
            
      
      float _val = windFlow_Pallet_MLT * windFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

      float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
      
      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);      

      /*    
      WIN3D_Diagrams.stroke(_COL[1], _COL[2], _COL[3], _COL[0]);
      WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);

      WIN3D_Diagrams.strokeWeight(1);
      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_scale3D, -y1 * OBJECTS_scale * WIN3D_scale3D, z1 * OBJECTS_scale * WIN3D_scale3D, x2 * OBJECTS_scale * WIN3D_scale3D, -y2 * OBJECTS_scale * WIN3D_scale3D, z2 * OBJECTS_scale * WIN3D_scale3D);
      
      WIN3D_Diagrams.strokeWeight(4);      
      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_scale3D, -y1 * OBJECTS_scale * WIN3D_scale3D, z1 * OBJECTS_scale * WIN3D_scale3D, 0.5 * (x2 + x1) * OBJECTS_scale * WIN3D_scale3D, -0.5 * (y2 + y1) * OBJECTS_scale * WIN3D_scale3D, 0.5 * (z2 + z1) * OBJECTS_scale * WIN3D_scale3D);
      */
      

      float the_dist = dist(x1, y1, z1, x2, y2, z2);
      
      float[] W = {x2 - x1, y2 - y1, z2 - z1};
      W = fn_normalize(W);
  
      float Alpha = asin_ang(W[2]);
      float Beta = atan2_ang(W[1], W[0]) + 90;   

      WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], 127);
      WIN3D_Diagrams.noStroke();
      
      for (int i = 0; i < 4; i++) {
        
        WIN3D_Diagrams.beginShape();
      
        WIN3D_Diagrams.vertex(x2 * OBJECTS_scale * WIN3D_scale3D, -y2 * OBJECTS_scale * WIN3D_scale3D, z2 * OBJECTS_scale * WIN3D_scale3D);  
  
        for (int j = 0; j < 2; j++) {
          
          float px = 0.1 * the_dist * cos((i + j) * HALF_PI);
          float py = 0;
          float pz = 0.1 * the_dist * sin((i + j) * HALF_PI); 
        
          float pz_rot = pz;
          float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
          float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  
          
          px = px_rot;
          py = py_rot;
          pz = pz_rot;
        
          px_rot = px;
          py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
          pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);
      
          px = px_rot;
          py = py_rot;
          pz = pz_rot;          
      
          WIN3D_Diagrams.vertex((x1 + px) * OBJECTS_scale * WIN3D_scale3D, -(y1 + py) * OBJECTS_scale * WIN3D_scale3D, (z1 + pz) * OBJECTS_scale * WIN3D_scale3D);  
        }
        
        WIN3D_Diagrams.endShape(CLOSE);
      }

    }


    WIN3D_Diagrams.strokeWeight(0);

  }

}


PImage[] TROPO_IMAGES;

//String TROPO_IMAGES_Path = "C:/SOLARCHVISION_2015/Output/2015-12-04/GDPS_00/World/Winds";
String TROPO_IMAGES_Path = "C:/SOLARCHVISION_2015/Output/2015-12-04/GDPS_00/World/Winds_less";


void Load_TROPO_IMAGES () {
  
  String[] TROPO_IMAGES_Filenames = sort(getfiles(TROPO_IMAGES_Path));
  
  TROPO_IMAGES = new PImage [TROPO_IMAGES_Filenames.length];
  
  for (int i = 0; i < TROPO_IMAGES_Filenames.length; i++) {
   
    println("Loading:", TROPO_IMAGES_Path + "/" + TROPO_IMAGES_Filenames[i]);
    
    TROPO_IMAGES[i] = loadImage(TROPO_IMAGES_Path + "/" + TROPO_IMAGES_Filenames[i]);
  }
}


void SOLARCHVISION_draw_TROPO3D () {
  if (Display_TROPO3D != 0) {

    WIN3D_Diagrams.strokeWeight(1);
    
    for (int n = 0; n < TROPO_IMAGES.length; n++) {
    
      float TROPO_IMAGES_OffsetX = 0; //TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + 180;
      float TROPO_IMAGES_OffsetY = 0; //TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - 90;
      
      float TROPO_IMAGES_ScaleX = 1; //(TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0]) / 360.0;
      float TROPO_IMAGES_ScaleY = 1; //(TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0]) / 180.0;
  
      float CEN_lon = 0; //0.5 * (TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1]);
      float CEN_lat = 0; //0.5 * (TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1]);
      
      float delta_Alpha = -2.5;
      float delta_Beta = -2.5;
      
      float r = FLOAT_R_earth + (TROPO_IMAGES.length - n) * 17000;
      
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s += 1) {
            
            float a = Alpha;
            float b = Beta;
            
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);
            
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
            
            if (Display_TROPO3D_TEXTURE != 0) {
              // calculating u and v
              subFace[s][3] = (_lon / TROPO_IMAGES_ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / TROPO_IMAGES_ScaleY / 180.0 + 0.5);
            }         
            
            // rotating to location coordinates 
            float tb = -LocationLongitude;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;
            
            float ta = 90 - LocationLatitude;
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
  
            // move it down!
            z2 -= FLOAT_R_earth;
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
  
          }
          
          WIN3D_Diagrams.beginShape();
          
          WIN3D_Diagrams.noStroke();
          
          if (Display_TROPO3D_TEXTURE != 0) {
  
            WIN3D_Diagrams.texture(TROPO_IMAGES[n]);
          }
  
          for (int s = 0; s < subFace.length; s++) {
        
            WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, subFace[s][3] * TROPO_IMAGES[n].width, subFace[s][4] * TROPO_IMAGES[n].height);  
          }
          
          WIN3D_Diagrams.endShape(CLOSE);        
        }
      }
    }
  }
}




PImage[] EARTH_IMAGES;

String EARTH_IMAGES_Path = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/EarthSurface";

String[] EARTH_IMAGES_Filenames = sort(getfiles(EARTH_IMAGES_Path));

void Load_EARTH_IMAGES () {
  
  EARTH_IMAGES = new PImage [EARTH_IMAGES_Filenames.length];
  
  for (int i = 0; i < EARTH_IMAGES_Filenames.length; i++) {
   
    println("Loading:", EARTH_IMAGES_Path + "/" + EARTH_IMAGES_Filenames[i]);
    
    EARTH_IMAGES[i] = loadImage(EARTH_IMAGES_Path + "/" + EARTH_IMAGES_Filenames[i]);
  }
}


void SOLARCHVISION_draw_EARTH3D () {
  if (Display_EARTH3D != 0) {

    WIN3D_Diagrams.strokeWeight(1);
    
    int n = 0;
    if (Day_of_Impact_to_Display < EARTH_IMAGES.length) n = Day_of_Impact_to_Display;

    float EARTH_IMAGES_OffsetX = 0; //EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0] + 180;
    float EARTH_IMAGES_OffsetY = 0; //EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1] - 90;
    
    float EARTH_IMAGES_ScaleX = 1; //(EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][1] - EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0]) / 360.0;
    float EARTH_IMAGES_ScaleY = 1; //(EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1] - EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][0]) / 180.0;

    float CEN_lon = 0; //0.5 * (EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][0] + EARTH_IMAGES_BoundariesX[EARTH_IMAGES_Number][1]);
    float CEN_lat = 0; //0.5 * (EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][0] + EARTH_IMAGES_BoundariesY[EARTH_IMAGES_Number][1]);
    
    float delta_Alpha = -2.5;
    float delta_Beta = -2.5;
    
    float r = FLOAT_R_earth;
    
    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];

        for (int s = 0; s < 4; s += 1) {
          
          float a = Alpha;
          float b = Beta;
          
          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);
          
          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;
          
          if (Display_EARTH3D_TEXTURE != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / EARTH_IMAGES_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / EARTH_IMAGES_ScaleY / 180.0 + 0.5);
          }         
          
          // rotating to location coordinates 
          float tb = -LocationLongitude;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;
          
          float ta = 90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

          // move it down!
          z2 -= FLOAT_R_earth;

          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;

        }
        
        WIN3D_Diagrams.beginShape();
        
        WIN3D_Diagrams.noStroke();
        
        if (Display_EARTH3D_TEXTURE != 0) {

          WIN3D_Diagrams.texture(EARTH_IMAGES[n]);
        }

        for (int s = 0; s < subFace.length; s++) {
      
          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, subFace[s][3] * EARTH_IMAGES[n].width, subFace[s][4] * EARTH_IMAGES[n].height);  
        }
        
        WIN3D_Diagrams.endShape(CLOSE);        
      }
    }
  }
}



String MOON_IMAGE_Filename = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Moon/Moon.jpg";

PImage MOON_IMAGE; 

void SOLARCHVISION_draw_MOON3D () {
  if (Display_MOON3D != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    float MOON_IMAGE_OffsetX = 0; 
    float MOON_IMAGE_OffsetY = 0; 
    
    float MOON_IMAGE_ScaleX = 1; 
    float MOON_IMAGE_ScaleY = 1; 

    float CEN_lon = 0; 
    float CEN_lat = 0; 
    
    float delta_Alpha = -5;
    float delta_Beta = -10;
    
    float r = 1737000.0 * planetary_magnification;
    float d = 384400000.0 - FLOAT_R_earth;

    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];
        
        for (int s = 0; s < 4; s += 1) {
          
          float a = Alpha;
          float b = Beta;
          
          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);
          
          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;
          
          if (Display_MOON3D_TEXTURE != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / MOON_IMAGE_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / MOON_IMAGE_ScaleY / 180.0 + 0.5);
          }         
         
          // rotating to location coordinates
         
          
          float tb = 0;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;
          
          float ta = -90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
          
          // move it up here!
          y2 += d * sin_ang(-LocationLatitude);      
          z2 += d * cos_ang(-LocationLatitude);
          
          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;
        }
        
        WIN3D_Diagrams.beginShape();
        
        WIN3D_Diagrams.noStroke();
        
        if (Display_MOON3D_TEXTURE != 0) {

          WIN3D_Diagrams.texture(MOON_IMAGE);
        }

        for (int s = 0; s < subFace.length; s++) {
      
          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, subFace[s][3] * MOON_IMAGE.width, subFace[s][4] * MOON_IMAGE.height);  
        }
        
        WIN3D_Diagrams.endShape(CLOSE);        
      }
    }
  }
}


String STAR_IMAGE_Filename = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Sun/Sun.jpg";

PImage STAR_IMAGE;

void SOLARCHVISION_draw_STAR3D () {
  if (Display_STAR3D != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    float STAR_IMAGE_OffsetX = 0; 
    float STAR_IMAGE_OffsetY = 0; 
    
    float STAR_IMAGE_ScaleX = 1; 
    float STAR_IMAGE_ScaleY = 1; 

    float CEN_lon = 0; 
    float CEN_lat = 0; 
    
    float delta_Alpha = -5;
    float delta_Beta = -10;
    
    float r = 696.0 * planetary_magnification; // * 1000000; // multiply this later
    float d = 150000.0; // * 1000000; // multiply this later 
    
    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];
        
        for (int s = 0; s < 4; s += 1) {
          
          float a = Alpha;
          float b = Beta;
          
          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);
          
          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;
          
          if (Display_STAR3D_TEXTURE != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / STAR_IMAGE_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / STAR_IMAGE_ScaleY / 180.0 + 0.5);
          }         
         
          // rotating to location coordinates
          
          float tb = 0;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;
          
          float ta = -90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
          
          // scale it here!
          x2 *= 1000000.0;
          y2 *= 1000000.0;
          z2 *= 1000000.0;
          
          // move it to scale here!
          y2 += 1000000.0 * d * sin_ang(-LocationLatitude);      
          z2 += 1000000.0 * d * cos_ang(-LocationLatitude);

          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;
        }
        
        WIN3D_Diagrams.beginShape();
        
        WIN3D_Diagrams.noStroke();
        
        if (Display_STAR3D_TEXTURE != 0) {

          WIN3D_Diagrams.texture(STAR_IMAGE);
        }

        for (int s = 0; s < subFace.length; s++) {
      
          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, subFace[s][3] * STAR_IMAGE.width, subFace[s][4] * STAR_IMAGE.height);  
        }
        
        WIN3D_Diagrams.endShape(CLOSE);        
      }
    }
  }
}



void SOLARCHVISION_draw_land () {

  if ((Display_LAND_MESH == 1) && (Load_LAND_MESH == 1)) {
    
    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0, 0, 0);
    if (Display_MODEL3D_EDGES == 0) WIN3D_Diagrams.noStroke();
    if (Display_LAND_TEXTURE == 1) WIN3D_Diagrams.noStroke();

    int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
    int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
    float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 


    int Tessellation = LAND_TESSELLATION;
    if (WIN3D_FACES_SHADE == Shade_Surface_Base) {
      Tessellation = 0;
    }
      
    int TotalSubNo = 1;  
    if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
    

    for (int i = Skip_LAND_MESH_Center; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {

        for (int n = 0; n < TotalSubNo; n++) {
          
          float[][] base_Vertices = new float [4][3];

          base_Vertices[0][0] = LAND_MESH[i][j][0];
          base_Vertices[0][1] = LAND_MESH[i][j][1];
          base_Vertices[0][2] = LAND_MESH[i][j][2];

          base_Vertices[1][0] = LAND_MESH[i+1][j][0];
          base_Vertices[1][1] = LAND_MESH[i+1][j][1];
          base_Vertices[1][2] = LAND_MESH[i+1][j][2];

          base_Vertices[2][0] = LAND_MESH[i+1][j+1][0];
          base_Vertices[2][1] = LAND_MESH[i+1][j+1][1];
          base_Vertices[2][2] = LAND_MESH[i+1][j+1][2];
          
          base_Vertices[3][0] = LAND_MESH[i][j+1][0];
          base_Vertices[3][1] = LAND_MESH[i][j+1][1];
          base_Vertices[3][2] = LAND_MESH[i][j+1][2];

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
          

          
          WIN3D_Diagrams.beginShape();
          
          if (Display_LAND_TEXTURE != 0) {
            WIN3D_Diagrams.texture(LAND_TEXTURE);
          }
          
          for (int s = 0; s < subFace.length; s++) {
            
            if (Display_LAND_TEXTURE == 0) {
              
              if (WIN3D_FACES_SHADE != Shade_Surface_Wire) {
                
                float[] _COL = {255, 255, 255, 255};
                
                if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
                  int s_next = (s + 1) % subFace.length;
                  int s_prev = (s + subFace.length - 1) % subFace.length;
                  
                  _COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                }
                
                
  
                if (WIN3D_FACES_SHADE == Shade_Surface_White) {
                  _COL = SOLARCHVISION_vertexRender_Shade_Surface_White(255);
                }                   
            
                if (WIN3D_FACES_SHADE == Shade_Surface_Materials) {
                  //_COL = SOLARCHVISION_vertexRender_Shade_Surface_Materials(mt);
                  _COL = SOLARCHVISION_vertexRender_Shade_Surface_White(223);
                }    
      
                if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
                  
                  _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                }              
                
                if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
                  
                  _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Spatial(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                }                  
  
  
                WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);              
                //if (subFace[s][2] + LocationElevation < 0) WIN3D_Diagrams.fill(127, 127, 255); // i.e. water
              }
              else {
                WIN3D_Diagrams.noFill();    
              }

               WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D);
            }              
            else {              
              float u = (subFace[s][0] / LAND_TEXTURE_scale_U + 0.5);
              float v = (-subFace[s][1] / LAND_TEXTURE_scale_V + 0.5);

              WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, u * LAND_TEXTURE.width, v * LAND_TEXTURE.height);  
            }

          }
          
          WIN3D_Diagrams.endShape(CLOSE);


          if (Display_LAND_TEXTURE != 0) {
            
            if (Display_LAND_DEPTH != 0) {
            
              WIN3D_Diagrams.fill(223, 223, 223);
              WIN3D_Diagrams.noStroke();
  
              float CrustDepth = 100; // The crust ranges from 5–70 km
    
              for (int s = 0; s < subFace.length; s++) {
    
                int s_next = (s + 1) % subFace.length;
              
                float u = (subFace[s][0] / LAND_TEXTURE_scale_U + 0.5);
                float v = (-subFace[s][1] / LAND_TEXTURE_scale_V + 0.5);
    
                float u_next = (subFace[s_next][0] / LAND_TEXTURE_scale_U + 0.5);
                float v_next = (-subFace[s_next][1] / LAND_TEXTURE_scale_V + 0.5);
                
                WIN3D_Diagrams.beginShape();
                
                WIN3D_Diagrams.texture(LAND_TEXTURE);                  
                
                WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_scale3D, u * LAND_TEXTURE.width, v * LAND_TEXTURE.height);
                WIN3D_Diagrams.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s_next][1] * OBJECTS_scale * WIN3D_scale3D, subFace[s_next][2] * OBJECTS_scale * WIN3D_scale3D, u_next * LAND_TEXTURE.width, v_next * LAND_TEXTURE.height);
                WIN3D_Diagrams.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s_next][1] * OBJECTS_scale * WIN3D_scale3D, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D_scale3D, u_next * LAND_TEXTURE.width, v_next * LAND_TEXTURE.height);
                WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_scale3D, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D_scale3D, u * LAND_TEXTURE.width, v * LAND_TEXTURE.height);
    
                WIN3D_Diagrams.endShape(CLOSE);
    
              }
            }
          }
          
          
          
        }

        
        
      }
    }
    
  }

}



float[] SOLARCHVISION_vertexRender_Shade_Surface_White (int c) {  

 float[] _COL = {c, c, c, c};
  
 return _COL;  
}

float[] SOLARCHVISION_vertexRender_Shade_Surface_Materials (int mt) {  

 float[] _COL = {Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]};
  
 return _COL;  
}


float[] SOLARCHVISION_vertexRender_Shade_Vertex_Spatial (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  SpatialImpactType = 0;
  float val = ParametricGeometries_SpatialImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);

  float _u = PAL_Multiplier * val + 0.5;
  
  if (PAL_DIR == -1) _u = 1 - _u;
  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
  if (PAL_DIR == 2) _u =  0.5 * _u;
  
  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);     
  
  return _COL;  
}

float[] SOLARCHVISION_vertexRender_Shade_Vertex_Elevation (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  float _u = PAL_Multiplier * 0.1 * VERTEX_now[2] + 0.5;

  if (PAL_DIR == -1) _u = 1 - _u;
  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
  if (PAL_DIR == 2) _u =  0.5 * _u;

  float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);  
  
  return _COL;  
}


float[] SOLARCHVISION_vertexRender_Shade_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
  PVector U = new PVector(VERTEX_next[0] - VERTEX_now[0], VERTEX_next[1] - VERTEX_now[1], VERTEX_next[2] - VERTEX_now[2]);
  PVector V = new PVector(VERTEX_prev[0] - VERTEX_now[0], VERTEX_prev[1] - VERTEX_now[1], VERTEX_prev[2] - VERTEX_now[2]);
  PVector UV = U.cross(V);
  float[] W = {UV.x, UV.y, UV.z};
  W = fn_normalize(W);
  
  float Alpha = asin_ang(W[2]);
  float Beta = atan2_ang(W[1], W[0]) + 90;       
  
  int a = int((Alpha + 90) / stp_slp);
  int b = int(Beta / stp_dir);
  
  if (a < 0) a += int(180 / stp_slp);
  if (b < 0) b += int(360 / stp_dir);
  if (a > int(180 / stp_slp)) a -= int(180 / stp_slp);
  if (b > int(360 / stp_dir)) b -= int(360 / stp_dir);
  
  float _valuesSUM = LocationExposure[Day_of_Impact_to_Display][a][b];
  
  float[] _COL = {255, 223, 223, 223};
  
  if (_valuesSUM < 0.9 * FLOAT_undefined) {
  
    float _u = 0;
    
    if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
    
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;

    _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
  }
  
  return _COL;
}


int SOLARCHVISION_getShader_PAL_TYPE () {
  
  int PAL_TYPE = 0; 

  if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR;
    if (Impact_TYPE == Impact_PASSIVE) PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
  }              

  if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
    PAL_TYPE = SPATIAL_Pallet_CLR; 
  }                  
  
  if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
    PAL_TYPE = ELEVATION_Pallet_CLR;
  }  
  
  return PAL_TYPE;
}


int SOLARCHVISION_getShader_PAL_DIR () {

  int PAL_DIR = 1;

  if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;
    if (Impact_TYPE == Impact_PASSIVE) PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
  }              

  if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
    PAL_DIR = SPATIAL_Pallet_DIR;
  }                  
  
  if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
    PAL_DIR = ELEVATION_Pallet_DIR;
  }  
  
  return PAL_DIR;
}


float SOLARCHVISION_getShader_PAL_Multiplier () {

  float PAL_Multiplier = 1; 

  if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;    
  }              
  
  if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
    PAL_Multiplier = SPATIAL_Pallet_MLT;
  }                  
  
  if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
    PAL_Multiplier = ELEVATION_Pallet_MLT;
  }

  return PAL_Multiplier;
}



void SOLARCHVISION_draw_3Dobjects () {

  if (Display_Building_Model != 0) {
    
    if (Display_MODEL3D_NORMALS != 0) {
      
      for (int f = 1; f < allFaces.length; f++) {
        
        int vsb = allFaces_MTLV[f][3];
        
        if (vsb > 0) {
        
          float[][] base_Vertices = new float [allFaces[f].length][3];
          for (int j = 0; j < allFaces[f].length; j++) {
            int vNo = allFaces[f][j];
            base_Vertices[j][0] = allVertices[vNo][0];
            base_Vertices[j][1] = allVertices[vNo][1];
            base_Vertices[j][2] = allVertices[vNo][2];
          }
          
          float G_x0 = 0;
          float G_y0 = 0;
          float G_z0 = 0;
          
          float G_x1 = 0;
          float G_y1 = 0;
          float G_z1 = 0;
          
          float n = float(base_Vertices.length);
            
          for (int s = 0; s < base_Vertices.length; s++) {
    
            int s_next = (s + 1) % base_Vertices.length;
            int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
            
            PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
            PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
            PVector UV = U.cross(V);
            float[] W = {UV.x, UV.y, UV.z};
            W = fn_normalize(W);
            
            float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D_scale3D;
            float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D_scale3D;
            float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D_scale3D;
  
            float x1 = (base_Vertices[s][0] + W[0]) * OBJECTS_scale * WIN3D_scale3D;
            float y1 = (base_Vertices[s][1] + W[1]) * OBJECTS_scale * WIN3D_scale3D;
            float z1 = (base_Vertices[s][2] + W[2]) * OBJECTS_scale * WIN3D_scale3D;
            
            G_x0 += x0 / n;
            G_y0 += y0 / n;
            G_z0 += z0 / n;
            
            G_x1 += x1 / n;
            G_y1 += y1 / n;
            G_z1 += z1 / n;
          }
          
          WIN3D_Diagrams.strokeWeight(3);
          WIN3D_Diagrams.stroke(127, 255, 127);
          WIN3D_Diagrams.line(G_x0, -G_y0, G_z0, G_x1, -G_y1, G_z1);        
          
          WIN3D_Diagrams.strokeWeight(1);
          WIN3D_Diagrams.stroke(0, 127, 0);
          
          for (int s = 0; s < base_Vertices.length; s++) {
            
            float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D_scale3D;
            float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D_scale3D;
            float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D_scale3D;
  
            WIN3D_Diagrams.line(x0, -y0, z0, G_x1, -G_y1, G_z1);   
          }
        }

      }
    }
    
    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0, 0, 0);
    if (Display_MODEL3D_EDGES == 0) WIN3D_Diagrams.noStroke();

    int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
    int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
    float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 
  
    if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      }             
      
      if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
      if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;    
    }              
  
    if (WIN3D_FACES_SHADE == Shade_Surface_Materials) {
  
    }              
  
    if (WIN3D_FACES_SHADE == Shade_Surface_White) {
  
    }     
    
    if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
  
    }                  
    
    if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
  
    }
    

    
  
    if (WIN3D_FACES_SHADE != Shade_Vertex_Solar) {
      for (int f = 1; f < allFaces.length; f++) {
        
        int vsb = allFaces_MTLV[f][3];
        
        if (vsb > 0) {        
        
          if (((Load_URBAN_MESH == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
          }
          else {
            
            if (WIN3D_FACES_SHADE == Shade_Surface_Base) {
              
              WIN3D_Diagrams.fill(255, 255, 255);
              
              WIN3D_Diagrams.beginShape();
              
              for (int j = 0; j < allFaces[f].length; j++) {
                int vNo = allFaces[f][j];
                
                WIN3D_Diagrams.vertex(allVertices[vNo][0] * OBJECTS_scale * WIN3D_scale3D, -(allVertices[vNo][1] * OBJECTS_scale * WIN3D_scale3D), allVertices[vNo][2] * OBJECTS_scale * WIN3D_scale3D);
              }    
              
              WIN3D_Diagrams.endShape(CLOSE);
              
            }

            else {
              
              int mt = allFaces_MTLV[f][0];
              
              int Tessellation = allFaces_MTLV[f][1];
              
              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_TESSELLATION;
              }
              if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
          
              for (int n = 0; n < TotalSubNo; n++) {
                
                float[][] base_Vertices = new float [allFaces[f].length][3];
                for (int j = 0; j < allFaces[f].length; j++) {
                  int vNo = allFaces[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }
                
                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
             
                WIN3D_Diagrams.beginShape();
                
                for (int s = 0; s < subFace.length; s++) {
                  
                  if (WIN3D_FACES_SHADE != Shade_Surface_Wire) {
                    
                    float[] _COL = {255, 255, 255, 255};
                    
                    if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;
                      
                      _COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }              
                
                    if (WIN3D_FACES_SHADE == Shade_Surface_Materials) {
                      _COL = SOLARCHVISION_vertexRender_Shade_Surface_Materials(mt);
                    }              
                
                    if (WIN3D_FACES_SHADE == Shade_Surface_White) {
                      _COL = SOLARCHVISION_vertexRender_Shade_Surface_White(255);
                    }     
                    
                    if (WIN3D_FACES_SHADE == Shade_Vertex_Spatial) {
                      
                      _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Spatial(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }                  
                    
                    if (WIN3D_FACES_SHADE == Shade_Vertex_Elevation) {
                      
                      _COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }
                    
                    WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
                  }
                  else {
                    WIN3D_Diagrams.noFill();
                  }
                  
                  
                  WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_scale3D);
          
                }
                
                WIN3D_Diagrams.endShape(CLOSE);
              }
            }
          }
        }
      }
    }
    else if (WIN3D_FACES_SHADE == Shade_Vertex_Solar) {
      if (WIN3D_update_VerticesSolarValue == 0) {
        try {
    
          int N_baked = 0;
          
          for (int f = 1; f < allFaces.length; f++) {
            
            int vsb = allFaces_MTLV[f][3];
        
            if (vsb > 0) {
            
              if (((Load_URBAN_MESH == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
              }
              else {
      
                int Tessellation = allFaces_MTLV[f][1];
                
                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_TESSELLATION;
                }
                if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
                
                for (int n = 0; n < TotalSubNo; n++) {
                  
                  float[][] base_Vertices = new float [allFaces[f].length][3];
                  for (int j = 0; j < allFaces[f].length; j++) {
                    int vNo = allFaces[f][j];
                    base_Vertices[j][0] = allVertices[vNo][0];
                    base_Vertices[j][1] = allVertices[vNo][1];
                    base_Vertices[j][2] = allVertices[vNo][2];
                  }            
                  
                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
               
                  WIN3D_Diagrams.beginShape();
                  
                  for (int s = 0; s < subFace.length; s++) {
        
                    N_baked += 1;
                    
                    float _valuesSUM = 0;
                    if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = WIN3D_VerticesSolarEnergy[N_baked];
                    if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = WIN3D_VerticesSolarEffect[N_baked];
                    
                    if (_valuesSUM < 0.9 * FLOAT_undefined) {
                      
                      float _u = 0;
                    
                      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
                      
                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;
            
                      float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
                      
                      WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);          
              
                      WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_scale3D);
                    }
                  }
                  
                  WIN3D_Diagrams.endShape(CLOSE);
                }
              }
            }
          }
        } catch (Exception e) {WIN3D_update_VerticesSolarValue = 1; WIN3D_Update = 1;}
      }
      else {
        cursor(WAIT);
        
        WIN3D_VerticesSolarEnergy = new float [1];
        WIN3D_VerticesSolarEffect = new float [1];
        WIN3D_VerticesSolarEnergy[0] = FLOAT_undefined; 
        WIN3D_VerticesSolarEffect[0] = FLOAT_undefined; 
        
        float keep_per_day = per_day;
        int keep_num_add_days = num_add_days;
        if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
          per_day = 1;
          num_add_days = 1;
        }
        
        int start_z = get_startZ_endZ(impacts_source)[0];
        int end_z = get_startZ_endZ(impacts_source)[1]; 
        int layers_count = get_startZ_endZ(impacts_source)[2]; 
          
        Impact_TYPE = Impact_ACTIVE; 
        if (plot_impacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;
    
        float Pa = FLOAT_undefined;
        float Pb = FLOAT_undefined;
        float Pc = FLOAT_undefined;
        float Pd = FLOAT_undefined;
        
        float _values_R_dir;
        float _values_R_dif;
        float _values_E_dir;
        float _values_E_dif;
        
        int now_k = 0;
        int now_i = 0;
        int now_j = 0;
        
        int[][] PROCESSED_DAILY_SCENARIOS = {{}};  
    
        for (int f = 1; f < allFaces.length; f++) {
  
          println("calculating %", nf(100.0 * f / (1.0 * allFaces.length), 0,2)); 
          
          int vsb = allFaces_MTLV[f][3];
        
          if (vsb > 0) {
          
            if (((Load_URBAN_MESH == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
            }
            else {    
            
              int Tessellation = allFaces_MTLV[f][1];
              
              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_TESSELLATION;
              }
              if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
                      
              for (int n = 0; n < TotalSubNo; n++) {
    
                float[][] base_Vertices = new float [allFaces[f].length][3];
                for (int j = 0; j < allFaces[f].length; j++) {
                  int vNo = allFaces[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }            
                
                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                
                WIN3D_Diagrams.beginShape();
                
                for (int s = 0; s < subFace.length; s++) {
                  
                  int s_next = (s + 1) % subFace.length;
                  int s_prev = (s + subFace.length - 1) % subFace.length;
                  
                  PVector U = new PVector(subFace[s_next][0] - subFace[s][0], subFace[s_next][1] - subFace[s][1], subFace[s_next][2] - subFace[s][2]);
                  PVector V = new PVector(subFace[s_prev][0] - subFace[s][0], subFace[s_prev][1] - subFace[s][1], subFace[s_prev][2] - subFace[s][2]);
                  PVector UV = U.cross(V);
                  float[] W = {UV.x, UV.y, UV.z};
                  W = fn_normalize(W);
                  
                  float Alpha = asin_ang(W[2]);
                  float Beta = atan2_ang(W[1], W[0]) + 90; 
                  
                  float _valuesSUM_RAD = 0;
                  float _valuesSUM_EFF_P = 0;
                  float _valuesSUM_EFF_N = 0;
                  int _valuesNUM = 0; 
                  
                  
                  int l = impact_layer;
                  
                  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {
                  
                    now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
                  
                    if (now_j >= 365) {
                     now_j = now_j % 365; 
                    }
                    if (now_j < 0) {
                     now_j = (now_j + 365) % 365; 
                    }
                   
                    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
                  
                    float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
                    float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);
      
                    int[] Normals_COL_N;
                    
                  
                    if (PROCESSED_DAILY_SCENARIOS.length > STUDY_j_end - STUDY_j_start) {
                      Normals_COL_N = PROCESSED_DAILY_SCENARIOS[STUDY_j_end - STUDY_j_start];
                    }
                    else {
                      Normals_COL_N = new int [9];
                      Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);
                      
                      int[][] newNormals = {Normals_COL_N};
                      PROCESSED_DAILY_SCENARIOS = (int[][]) concat(PROCESSED_DAILY_SCENARIOS, newNormals);
                      println("length of PROCESSED_DAILY_SCENARIOS =", PROCESSED_DAILY_SCENARIOS.length);
                    }
                  
                    int nk = Normals_COL_N[l];
                    
                    if (nk != -1) {
                      int k = int(nk / num_add_days);
                      int j_ADD = nk % num_add_days; 
                  
            
                      for (int i = 0; i < 24; i += 1) {
                      
                        if (isInHourlyRange(i) == 1) {
                      
                          float HOUR_ANGLE = i; 
                          float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
          
                          if (SunR[3] > 0) {
                  
                            now_k = k;
                            now_i = i;
                            now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
                      
                            if (now_j >= 365) {
                             now_j = now_j % 365; 
                            }
                            if (now_j < 0) {
                             now_j = (now_j + 365) % 365; 
                            }
                      
                            if (impacts_source == databaseNumber_CLIMATE_WY2) {
                                Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
                                Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
                                Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
                                Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
                            }
                            if (impacts_source == databaseNumber_ENSEMBLE) {
                                Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
                                Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
                                Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
                                Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
                            }            
                            if (impacts_source == databaseNumber_OBSERVED) {
                                Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
                                Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
                                Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
                                Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
                            }   
                            if (impacts_source == databaseNumber_CLIMATE_EPW) {
                                Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
                                Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
                                Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
                                Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
                            }       
                      
                            if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                              _values_R_dir = FLOAT_undefined;
                              _values_R_dif = FLOAT_undefined;
                              _values_E_dir = FLOAT_undefined;
                              _values_E_dif = FLOAT_undefined;
                            }
                            else {
                      
                              int drw_count = 0;
                              if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                              if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                              if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                              if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                              
                              if (drw_count == 1) {
                                _values_R_dir = 0.001 * Pa; 
                                _values_R_dif = 0.001 * Pb;  
                                _values_E_dir = 0.001 * Pc;
                                _values_E_dif = 0.001 * Pd;
                                
                                if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                                  _valuesSUM_RAD = 0;
                                  _valuesSUM_EFF_P = 0;
                                  _valuesSUM_EFF_N = 0;
                                  _valuesNUM = 0; 
                                }                             
                                else {
                                 
                                  float[] VECT = {0, 0, 0}; 
                                  
                                  if (abs(Alpha) > 89.99) {
                                    VECT[0] = 0;
                                    VECT[1] = 0;
                                    VECT[2] = 1;      
                                  } else if (Alpha < -89.99) {
                                    VECT[0] = 0;
                                    VECT[1] = 0;
                                    VECT[2] = -1;
                                  } else {
                                    VECT[0] = sin_ang(Beta);
                                    VECT[1] = -cos_ang(Beta);
                                    VECT[2] = tan_ang(Alpha);      
                                  }  
                                  
                                  VECT = fn_normalize(VECT);
                                  
                                  float[] SunV = {SunR[1], SunR[2], SunR[3]};
                                  
                                  float SunMask = fn_dot(fn_normalize(SunV), fn_normalize(VECT));
                                  if (SunMask <= 0) SunMask = 0; // removes backing faces 
                                  
                                  float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));
                            
                                  float[] ray_start = subFace[s];     
                                  float[] ray_direction = {SunR[1],SunR[2],SunR[3]}; // NOT SURE!
                                  
                                  if (fn_dot(W, ray_direction) > 0) { // removes backing faces
                                  
                                    if (SOLARCHVISION_is3Dintersected(ray_start, ray_direction, MAX_SHADING_DIST) == 1) { 
                                      if (_values_E_dir < 0) {
                                        _valuesSUM_EFF_P += -(_values_E_dir * SunMask); 
                                        _valuesSUM_EFF_N += -(_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
                                      }
                                      else {
                                        _valuesSUM_EFF_N += (_values_E_dir * SunMask); 
                                        _valuesSUM_EFF_P += (_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
                                      }
                                      
                                      _valuesSUM_RAD += (_values_R_dif * SkyMask); // only approximate diffuse radiation!
                                    }
                                    else { 
                                      if (_values_E_dir < 0) {
                                        _valuesSUM_EFF_N += -((_values_E_dir * SunMask) + (_values_E_dif * SkyMask)); 
                                      }
                                      else {
                                        _valuesSUM_EFF_P += ((_values_E_dir * SunMask) + (_values_E_dif * SkyMask)); 
                                      }
                                      
                                      _valuesSUM_RAD += ((_values_R_dir * SunMask) + (_values_R_dif * SkyMask)); // calculates total radiation
                                    }
                                  
                                  }
                                  _valuesNUM += 1;
                                  
                                }
                              }
                            }
                          }
                        }
                      }
                    }
  
                  }    
                  
                  float _valuesMUL = 0;
                  
                  if (_valuesNUM != 0) {
                    _valuesMUL = 12.0 / (1.0 * _valuesNUM); // this might be approximate!
                    
                    _valuesSUM_RAD *= _valuesMUL;
                    _valuesSUM_EFF_P *= _valuesMUL;
                    _valuesSUM_EFF_N *= _valuesMUL;
                  }    
                  else {
                    _valuesSUM_RAD = 0; //FLOAT_undefined;
                    _valuesSUM_EFF_P = 0; //FLOAT_undefined;
                    _valuesSUM_EFF_N = 0; //FLOAT_undefined;
                  }                   
                  
               
             
                  float AVERAGE, PERCENTAGE, COMPARISON;
                  
                  AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
                  if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
                  else PERCENTAGE = 0.0;
                  COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
                  
                  //println("3D-Model >> _valuesSUM_RAD:", _valuesSUM_RAD, "|COMPARISON:", COMPARISON);
                  
                  {
                    float[] ADD_values_RAD = {_valuesSUM_RAD};
                    WIN3D_VerticesSolarEnergy = concat(WIN3D_VerticesSolarEnergy, ADD_values_RAD);
                    
                    float[] ADD_values_EFF = {COMPARISON};
                    WIN3D_VerticesSolarEffect = concat(WIN3D_VerticesSolarEffect, ADD_values_EFF);
                  }
      
                  float _valuesSUM = 0;
                  if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON;
                  
                  if (_valuesSUM < 0.9 * FLOAT_undefined) {
                  
                    float _u = 0;
                    
                    if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
                    
                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;
          
                    float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);
          
                    WIN3D_Diagrams.fill(_COL[1], _COL[2], _COL[3], _COL[0]);
            
                    WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_scale3D);
                  }
                }
                WIN3D_Diagrams.endShape(CLOSE);
              }
            }
          }
        }
        WIN3D_update_VerticesSolarValue = 0;
        
        cursor(ARROW);
      }
    }
  }
}


float Orthographic_Zoom () {

  float ZOOM = 0.5 * WIN3D_ZOOM_coordinate * PI / 180;
  
  ZOOM *= CAM_z / 56.0;

  return ZOOM;
}


void SOLARCHVISION_look_Camera_towards_Selection () {
  
  SOLARCHVISION_lookXY_Camera_towards_Selection();
  SOLARCHVISION_lookZ_Camera_towards_Selection();
}

void SOLARCHVISION_lookXY_Camera_towards_Selection () {

  float xO = CAM_x / OBJECTS_scale;
  float yO = CAM_y / OBJECTS_scale;
  float zO = CAM_z / OBJECTS_scale;
  
  float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
  float xA = ray_end[0] / OBJECTS_scale;
  float yA = ray_end[1] / OBJECTS_scale;
  float zA = ray_end[2] / OBJECTS_scale;
  
  float xB = selected_Pivot_XYZ[0];
  float yB = selected_Pivot_XYZ[1];
  float zB = selected_Pivot_XYZ[2];     

  WIN3D_RZ_coordinate += atan2_ang((yB - yO), (xB - xO)) - atan2_ang((yA - yO), (xA - xO));
  
  SOLARCHVISION_reverseTransform_Camera();

}


void SOLARCHVISION_lookZ_Camera_towards_Selection () {

  float xO = CAM_x / OBJECTS_scale;
  float yO = CAM_y / OBJECTS_scale;
  float zO = CAM_z / OBJECTS_scale;
  
  float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
  float xA = ray_end[0] / OBJECTS_scale;
  float yA = ray_end[1] / OBJECTS_scale;
  float zA = ray_end[2] / OBJECTS_scale;
  
  float xB = selected_Pivot_XYZ[0];
  float yB = selected_Pivot_XYZ[1];
  float zB = selected_Pivot_XYZ[2];          

  WIN3D_RX_coordinate += atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));
  
  SOLARCHVISION_reverseTransform_Camera();

}

void SOLARCHVISION_move_Camera_towards_Mouse (float t) {
  
  float xA = CAM_x / OBJECTS_scale;
  float yA = CAM_y / OBJECTS_scale;
  float zA = CAM_z / OBJECTS_scale;
  
  float Image_X = mouseX - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
  float Image_Y = mouseY - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);
  
  float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);  
  float xO = ray_end[0] / OBJECTS_scale;
  float yO = ray_end[1] / OBJECTS_scale;
  float zO = ray_end[2] / OBJECTS_scale;
  
  float dx = xA - xO;
  float dy = yA - yO;
  float dz = zA - zO;

  float xB = xO + t * dx; 
  float yB = yO + t * dy;
  float zB = zO + t * dz;
  
  CAM_x = xB * OBJECTS_scale;           
  CAM_y = yB * OBJECTS_scale;
  CAM_z = zB * OBJECTS_scale;     
  
  SOLARCHVISION_reverseTransform_Camera();


  WIN3D_S_coordinate *= t; // just to adjust panning better
}

void SOLARCHVISION_move_Camera_towards_Selection (float t) {
  
  float xA = CAM_x / OBJECTS_scale;
  float yA = CAM_y / OBJECTS_scale;
  float zA = CAM_z / OBJECTS_scale;
  
  float xO = selected_Pivot_XYZ[0];
  float yO = selected_Pivot_XYZ[1];
  float zO = selected_Pivot_XYZ[2];                
  
  float dx = xA - xO;
  float dy = yA - yO;
  float dz = zA - zO;

  float xB = xO + t * dx; 
  float yB = yO + t * dy;
  float zB = zO + t * dz;
  
  CAM_x = xB * OBJECTS_scale;           
  CAM_y = yB * OBJECTS_scale;
  CAM_z = zB * OBJECTS_scale;     
  
  SOLARCHVISION_reverseTransform_Camera();
  

  WIN3D_S_coordinate *= t; // just to adjust panning better
}

void SOLARCHVISION_rotateZ_Camera_around_Selection (float t) {
  
  WIN3D_RX_coordinate += t;

  float xA = CAM_x / OBJECTS_scale;
  float yA = CAM_y / OBJECTS_scale;
  float zA = CAM_z / OBJECTS_scale;

  float xO = selected_Pivot_XYZ[0];
  float yO = selected_Pivot_XYZ[1];
  float zO = selected_Pivot_XYZ[2];                

  float xB = xA - xO;
  float yB = yA - yO;
  float zB = zA - zO;

  // rotate to make it on yz plane
  
  float xC = xB * cos_ang(-WIN3D_RZ_coordinate) - yB * sin_ang(-WIN3D_RZ_coordinate); 
  float yC = xB * sin_ang(-WIN3D_RZ_coordinate) + yB * cos_ang(-WIN3D_RZ_coordinate);
  float zC = zB;

  // rotate it on yz plane
 
  float xD = xC;
  float yD = yC * cos_ang(t) - zC * sin_ang(t);
  float zD = yC * sin_ang(t) + zC * cos_ang(t);
  
  // rotate to back from yz plane
  
  float xE = xD * cos_ang(WIN3D_RZ_coordinate) - yD * sin_ang(WIN3D_RZ_coordinate); 
  float yE = xD * sin_ang(WIN3D_RZ_coordinate) + yD * cos_ang(WIN3D_RZ_coordinate);
  float zE = zD;
  
  float xF = xE + xO;
  float yF = yE + yO;
  float zF = zE + zO;
  
  CAM_x = xF * OBJECTS_scale;           
  CAM_y = yF * OBJECTS_scale;
  CAM_z = zF * OBJECTS_scale; 
  
  SOLARCHVISION_reverseTransform_Camera();
  
}


void SOLARCHVISION_rotateXY_Camera_around_Selection (float t) {
  
  WIN3D_RZ_coordinate += t;

  float xA = CAM_x / OBJECTS_scale;
  float yA = CAM_y / OBJECTS_scale;
  float zA = CAM_z / OBJECTS_scale;
  
  float xO = selected_Pivot_XYZ[0];
  float yO = selected_Pivot_XYZ[1];
  float zO = selected_Pivot_XYZ[2];                
  
  float dx = xA - xO;
  float dy = yA - yO;
  
  float xB = xO + dx * cos_ang(t) - dy * sin_ang(t); 
  float yB = yO + dx * sin_ang(t) + dy * cos_ang(t);
  float zB = zA;
  
  CAM_x = xB * OBJECTS_scale;           
  CAM_y = yB * OBJECTS_scale;
  CAM_z = zB * OBJECTS_scale;   
  
  SOLARCHVISION_reverseTransform_Camera();
  
}


void SOLARCHVISION_reverseTransform_Camera () { // computing WIN3D_X_coordinate, WIN3D_Y_coordinate and WIN3D_Z_coordinate from new set of camera start and end points.

  float px, py, pz;
  
  px = CAM_x;
  py = CAM_y;
  pz = CAM_z;  

  float CAM_x1, CAM_y1, CAM_z1;
  
  CAM_z1 = pz;
  CAM_x1 = px * cos_ang(-WIN3D_RZ_coordinate) - py * sin_ang(-WIN3D_RZ_coordinate);
  CAM_y1 = px * sin_ang(-WIN3D_RZ_coordinate) + py * cos_ang(-WIN3D_RZ_coordinate);  
  
  px = CAM_x1;
  py = CAM_y1;
  pz = CAM_z1;  

  CAM_x1 = px;
  CAM_y1 = py * cos_ang(-WIN3D_RX_coordinate) - pz * sin_ang(-WIN3D_RX_coordinate);
  CAM_z1 = py * sin_ang(-WIN3D_RX_coordinate) + pz * cos_ang(-WIN3D_RX_coordinate);    


  float CAM_x2, CAM_y2, CAM_z2;

  CAM_fov = WIN3D_ZOOM_coordinate * PI / 180;

  CAM_dist = (0.5 * refScale) / tan(0.5 * CAM_fov);
  
  CAM_x2 = 0;
  CAM_y2 = 0;
  CAM_z2 = CAM_dist;
  
  CAM_x2 *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_y2 *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_z2 *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);  


  WIN3D_X_coordinate = CAM_x2 - CAM_x1; 
  WIN3D_Y_coordinate = -(CAM_y2 - CAM_y1); 
  WIN3D_Z_coordinate = CAM_z2 - CAM_z1;   


}


void SOLARCHVISION_transform_Camera () {
  
  CAM_fov = WIN3D_ZOOM_coordinate * PI / 180;

  CAM_dist = (0.5 * refScale) / tan(0.5 * CAM_fov);
  
  CAM_x = 0;
  CAM_y = 0;
  CAM_z = CAM_dist;

  
  CAM_x *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_y *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_z *= tan(0.5 * CAM_fov) / tan(0.5 * PI / 3.0);
    
  CAM_x -= WIN3D_X_coordinate;
  CAM_y += WIN3D_Y_coordinate;
  CAM_z -= WIN3D_Z_coordinate;
  
  float px, py, pz;
  
  px = CAM_x;
  py = CAM_y * cos_ang(WIN3D_RX_coordinate) - CAM_z * sin_ang(WIN3D_RX_coordinate);
  pz = CAM_y * sin_ang(WIN3D_RX_coordinate) + CAM_z * cos_ang(WIN3D_RX_coordinate);
  
  CAM_x = px;
  CAM_y = py;
  CAM_z = pz;
  
  pz = CAM_z;
  px = CAM_x * cos_ang(WIN3D_RZ_coordinate) - CAM_y * sin_ang(WIN3D_RZ_coordinate);
  py = CAM_x * sin_ang(WIN3D_RZ_coordinate) + CAM_y * cos_ang(WIN3D_RZ_coordinate);
  
  CAM_x = px;
  CAM_y = py;
  CAM_z = pz;   
  
  //println("Camera:", nf(CAM_x,0,4), nf(CAM_y,0,4), nf(CAM_z,0,4));

}

 

void SOLARCHVISION_put_Camera () {  
  
  if (WIN3D_View_Type == 1) {

    float aspect = 1.0 / WIN3D_R_View;
    
    float zFar = CAM_dist * CAM_clipFar;
    float zNear = CAM_dist * CAM_clipNear;
    
    WIN3D_Diagrams.perspective(CAM_fov, aspect, zNear, zFar);

    WIN3D_Diagrams.translate(0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View, 0); // << IMPORTANT!
  }
  else {

    float ZOOM = Orthographic_Zoom();
    
    WIN3D_Diagrams.ortho(ZOOM * WIN3D_X_View * -1, ZOOM * WIN3D_X_View * 1, ZOOM  * WIN3D_Y_View * -1, ZOOM  * WIN3D_Y_View * 1, 0.00001, 100000);
    
    WIN3D_Diagrams.translate(0, 1.0 * WIN3D_Y_View, 0); // << IMPORTANT! 
  }

  WIN3D_Diagrams.translate(WIN3D_X_coordinate * WIN3D_scale3D, WIN3D_Y_coordinate * WIN3D_scale3D, WIN3D_Z_coordinate * WIN3D_scale3D);
  
  WIN3D_Diagrams.rotateX(WIN3D_RX_coordinate * PI / 180); 
  WIN3D_Diagrams.rotateZ(WIN3D_RZ_coordinate * PI / 180); 

}
  

  


float[][] allObject2D_Vertices;
int[][] allObject2D_Faces;

void SOLARCHVISION_draw_2Dobjects () {

  allObject2D_Faces = new int [1 + allObject2D_num][4];
    
  allObject2D_Vertices = new float [4 * allObject2D_num + 1][3];
  allObject2D_Vertices[0][0] = 0;
  allObject2D_Vertices[0][1] = 0;
  allObject2D_Vertices[0][2] = 0;

  if (Display_Trees_People != 0) {
    
    float[] DistZ = new float [1 + allObject2D_num];
   
    for (int f = 1; f <= allObject2D_num; f++) {
      float x = allObject2D_XYZS[f][0] * OBJECTS_scale;
      float y = allObject2D_XYZS[f][1] * OBJECTS_scale;
      float z = allObject2D_XYZS[f][2] * OBJECTS_scale;
      
      DistZ[f] = dist(x, y, z, CAM_x, CAM_y, CAM_z);
    }
    
    for (int g = 1; g <= allObject2D_num; g++) {
      
      int f = 0;
      float max_dist = -1;
      
      for (int q = 1; q <= allObject2D_num; q++) {
        if (max_dist < DistZ[q]) {
          max_dist = DistZ[q];
          f = q;
        }
      }
      
      DistZ[f] = -1;
      
      
      
      if (f != 0) {

        int n = abs(allObject2D_MAP[f]);
      
        int w = Object2DImages[n].width; 
        int h = Object2DImages[n].height;
                
        float x = allObject2D_XYZS[f][0] * OBJECTS_scale;
        float y = allObject2D_XYZS[f][1] * OBJECTS_scale;
        float z = allObject2D_XYZS[f][2] * OBJECTS_scale;
        
        float rh = allObject2D_XYZS[f][3] * 0.5 * OBJECTS_scale;
        float rw = rh * Object2DImageRatios[n];
        
        float t = WIN3D_RZ_coordinate * PI / 180.0;
        if (WIN3D_View_Type == 1) t = atan2(y - CAM_y, x - CAM_x) + 0.5 * PI; 
        
        if (allObject2D_MAP[f] < 0) t += PI;         
        
        WIN3D_Diagrams.beginShape();
        
        WIN3D_Diagrams.texture(Object2DImages[n]);    
        WIN3D_Diagrams.stroke(255, 255, 255, 0);
        WIN3D_Diagrams.fill(255, 255, 255, 0);
        
        WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_scale3D, -(y - rw * sin(t)) * WIN3D_scale3D, z * WIN3D_scale3D, 0, h);
        WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_scale3D, -(y + rw * sin(t)) * WIN3D_scale3D, z * WIN3D_scale3D, w, h);
        WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_scale3D, -(y + rw * sin(t)) * WIN3D_scale3D, (z + 2 * rh) * WIN3D_scale3D, w, 0);
        WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_scale3D, -(y - rw * sin(t)) * WIN3D_scale3D, (z + 2 * rh) * WIN3D_scale3D, 0, 0);

        WIN3D_Diagrams.endShape(CLOSE);
        
        {
          allObject2D_Vertices[f * 4 - 3][0] = (x - rw * cos(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 3][1] = (y - rw * sin(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 3][2] = (z) / OBJECTS_scale;

          allObject2D_Vertices[f * 4 - 2][0] = (x + rw * cos(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 2][1] = (y + rw * sin(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 2][2] = (z) / OBJECTS_scale;

          allObject2D_Vertices[f * 4 - 1][0] = (x + rw * cos(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 1][1] = (y + rw * sin(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 1][2] = (z + 2 * rh) / OBJECTS_scale;

          allObject2D_Vertices[f * 4 - 0][0] = (x - rw * cos(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 0][1] = (y - rw * sin(t)) / OBJECTS_scale;
          allObject2D_Vertices[f * 4 - 0][2] = (z + 2 * rh) / OBJECTS_scale;

          allObject2D_Faces[f][0] = f * 4 - 3;
          allObject2D_Faces[f][1] = f * 4 - 2;
          allObject2D_Faces[f][2] = f * 4 - 1;
          allObject2D_Faces[f][3] = f * 4 - 0;
        }        
        

        
        if (n > Object2D_PEOPLE_Files_Num) { // case: trees   
        
          float ratio = 0.5;
        
          for (int back_front = -1; back_front <= 1; back_front += 2) {
            
            float rot = back_front * PI / 2 + t;
            
            WIN3D_Diagrams.beginShape();
            
            WIN3D_Diagrams.texture(Object2DImages[n]);    
            WIN3D_Diagrams.stroke(255, 255, 255, 0);
            WIN3D_Diagrams.fill(255, 255, 255, 0);
            
            WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_scale3D, -(y - rw * sin(t)) * WIN3D_scale3D, (z + 2 * rh * ratio) * WIN3D_scale3D, 0, h * ratio);
            WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_scale3D, -(y + rw * sin(t)) * WIN3D_scale3D, (z + 2 * rh * ratio) * WIN3D_scale3D, w, h * ratio);
            WIN3D_Diagrams.vertex((x + rw * cos(t) + rw * cos(rot)) * WIN3D_scale3D, -(y + rw * sin(t) + rw * sin(rot)) * WIN3D_scale3D, (z + 2 * rh * ratio) * WIN3D_scale3D, w, 0);
            WIN3D_Diagrams.vertex((x - rw * cos(t) + rw * cos(rot)) * WIN3D_scale3D, -(y - rw * sin(t) + rw * sin(rot)) * WIN3D_scale3D, (z + 2 * rh * ratio) * WIN3D_scale3D, 0, 0);
            
            WIN3D_Diagrams.endShape(CLOSE);
          }    
        }    
      }  
    }
  }

}


int SOLARCHVISION_is3Dintersected (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  int hit = 0;

  for (int f = 1; f < allFaces.length; f++) {

    int vsb = allFaces_MTLV[f][3];
    
    if (vsb > 0) {
    
      if (hit == 0) {
  
        float backAngles = FLOAT_undefined;  
        float foreAngles = FLOAT_undefined;
    
        float delta = 0.5; 
        float delta_step = -0.5; // going the other way
        
        float[] x = {FLOAT_undefined, FLOAT_undefined};
        float[] y = {FLOAT_undefined, FLOAT_undefined};
        float[] z = {FLOAT_undefined, FLOAT_undefined};
        
        float[] AnglesAll = {0, 0};   
        
        float MAX_AnglesAll = 0;
        int MAX_o = -1;
    
        for (int q = 0; q < 16; q++) {
        //for (int q = 0; q < 12; q++) {
          
          if (hit == 0) {
          
            for (int o = 0; o < 2; o++) {
      
              float delta_test = delta;
              
              if (o == 0) delta_test -= delta_step;
              else delta_test += delta_step;
              
              if (delta_test < 0.01) delta_test = 0.01; // << in order to avoid returning the initial ray point on the surface!
              
              x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
              y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
              z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
              
              AnglesAll[o] = 0;      
            
              for (int i = 0; i < allFaces[f].length; i++) {
                int next_i = (i + 1) % allFaces[f].length;
                
                float[] vectA = {allVertices[allFaces[f][i]][0] - x[o], allVertices[allFaces[f][i]][1] - y[o], allVertices[allFaces[f][i]][2] - z[o]}; 
                float[] vectB = {allVertices[allFaces[f][next_i]][0] - x[o], allVertices[allFaces[f][next_i]][1] - y[o], allVertices[allFaces[f][next_i]][2] - z[o]};
                
                float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
                
                AnglesAll[o] += t;
        
              }
            }
  
            if (q == 0) {
              foreAngles = AnglesAll[0];
              backAngles = AnglesAll[1];
  
              MAX_o = 0; 
              delta = 0;
            } 
            else {
              
              if (AnglesAll[0] < AnglesAll[1]) {
                MAX_o = 1;          
                MAX_AnglesAll = AnglesAll[1];
                
                backAngles = AnglesAll[1]; 
                
                delta += delta_step;   
              }
              else {
                MAX_o = 0;
                MAX_AnglesAll = AnglesAll[0];
                
                foreAngles = AnglesAll[0];
                
                delta -= delta_step;
              } 
              
              delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
      
            }
      
            if (MAX_AnglesAll > 359) {
            //if (MAX_AnglesAll > 357) {
              
              if (delta > 0.01) { // << in order to avoid returning the initial ray point on the surface!
                hit = 1;
              }
            }
          }
        }
      }
    }
  }

  return hit;
}


float[] SOLARCHVISION_3Dintersect (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allFaces.length][4];

  for (int f = 1; f < allFaces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  float[] pre_angle_to_allFaces = new float [allFaces.length];
  
  for (int f = 1; f < allFaces.length; f++) {
    pre_angle_to_allFaces[f] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allFaces.length; f++) {

    int vsb = allFaces_MTLV[f][3];
    
    if (vsb > 0) {    
    
      float backAngles = FLOAT_undefined;  
      float foreAngles = FLOAT_undefined;
  
      float delta = 0.5; 
      float delta_step = 0.5;
      
      float delta_dir = -1;
      
      float[] x = {FLOAT_undefined, FLOAT_undefined};
      float[] y = {FLOAT_undefined, FLOAT_undefined};
      float[] z = {FLOAT_undefined, FLOAT_undefined};
      
      float[] AnglesAll = {0, 0};   
      
      float MAX_AnglesAll = 0;
      int MAX_o = -1;
  
      //for (int q = 0; q < 16; q++) {
      for (int q = 0; q < 32; q++) {
      
        for (int o = 0; o < 2; o++) {
  
          float delta_test = delta;
          
          if (o == 0) delta_test -= delta_step;
          else delta_test += delta_step;
          
          x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
          y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
          z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
          
          AnglesAll[o] = 0;      
        
          for (int i = 0; i < allFaces[f].length; i++) {
            int next_i = (i + 1) % allFaces[f].length;
            
            float[] vectA = {allVertices[allFaces[f][i]][0] - x[o], allVertices[allFaces[f][i]][1] - y[o], allVertices[allFaces[f][i]][2] - z[o]}; 
            float[] vectB = {allVertices[allFaces[f][next_i]][0] - x[o], allVertices[allFaces[f][next_i]][1] - y[o], allVertices[allFaces[f][next_i]][2] - z[o]};
            
            float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
            
            AnglesAll[o] += t;
    
          }
        }
  
  
        if (q == 0) {
          foreAngles = AnglesAll[0];
          backAngles = AnglesAll[1];
          
          //if (AnglesAll[0] < AnglesAll[1]) {
            MAX_o = 1;
            delta = 1;
          //}
          //else {
          //  MAX_o = 0;
          //  delta = 0;       
          //}
        } 
        else {
          
          if (AnglesAll[0] < AnglesAll[1]) {
            MAX_o = 1;          
            MAX_AnglesAll = AnglesAll[1];
            
            backAngles = AnglesAll[1]; 
            
            delta += delta_step;   
          }
          else {
            MAX_o = 0;
            MAX_AnglesAll = AnglesAll[0];
            
            foreAngles = AnglesAll[0];
            
            delta -= delta_step;
          } 
          
          //delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
          delta_step *= 0.75; 
  
        }
  
        //println(delta, delta_step);
           
  
        //if (MAX_AnglesAll > 359) {
        if (MAX_AnglesAll > 357) { // <<<<<<<<<<<<<<<<<<<<<<<<<
          if (pre_angle_to_allFaces[f] < MAX_AnglesAll) {
            pre_angle_to_allFaces[f] = MAX_AnglesAll;
            
            hitPoint[f][0] = x[MAX_o];
            hitPoint[f][1] = y[MAX_o];
            hitPoint[f][2] = z[MAX_o];
            hitPoint[f][3] = delta;
          }        
        }
        
        if (pre_angle_to_allFaces[f] > 0.9 * FLOAT_undefined) {
          pre_angle_to_allFaces[f] = MAX_AnglesAll;
        }       
  
        
      }
    }

  }

  float[] return_point = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, -1};
  
  float pre_dist = FLOAT_undefined;
  
  for (int f = 1; f < allFaces.length; f++) {
    
    float hx = hitPoint[f][0];
    float hy = hitPoint[f][1];
    float hz = hitPoint[f][2];
    float h_delta = hitPoint[f][3];

    //if ((hx < 0.9 * FLOAT_undefined) && (hy < 0.9 * FLOAT_undefined) && (hz < 0.9 * FLOAT_undefined)) {
    
      float hd = dist(hx, hy, hz, ray_pnt[0], ray_pnt[1], ray_pnt[2]);
      
      //if (hd < pre_dist) {
      //if ((hd < pre_dist) && (hd > 0.02)) {
      if ((hd < pre_dist) && (h_delta > 0.005)) {
        
        pre_dist = hd;
        
        return_point[0] = hx;
        return_point[1] = hy;
        return_point[2] = hz;
        return_point[3] = hd;
        return_point[4] = f;
      }
    
    //}
  }
 
  return return_point;
  
}



float[] SOLARCHVISION_2Dintersect (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allObject2D_Faces.length][4];

  for (int f = 1; f < allObject2D_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  float[] pre_angle_to_allObject2D_Faces = new float [allObject2D_Faces.length];
  
  for (int f = 1; f < allObject2D_Faces.length; f++) {
    pre_angle_to_allObject2D_Faces[f] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allObject2D_Faces.length; f++) {

    float backAngles = FLOAT_undefined;  
    float foreAngles = FLOAT_undefined;

    float delta = 0.5; 
    float delta_step = 0.5;
    
    float delta_dir = -1;
    
    float[] x = {FLOAT_undefined, FLOAT_undefined};
    float[] y = {FLOAT_undefined, FLOAT_undefined};
    float[] z = {FLOAT_undefined, FLOAT_undefined};
    
    float[] AnglesAll = {0, 0};   
    
    float MAX_AnglesAll = 0;
    int MAX_o = -1;

    //for (int q = 0; q < 16; q++) {
    for (int q = 0; q < 32; q++) {
    
      for (int o = 0; o < 2; o++) {

        float delta_test = delta;
        
        if (o == 0) delta_test -= delta_step;
        else delta_test += delta_step;
        
        x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
        y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
        z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
        
        AnglesAll[o] = 0;      
      
        for (int i = 0; i < allObject2D_Faces[f].length; i++) {
          int next_i = (i + 1) % allObject2D_Faces[f].length;
          
          float[] vectA = {allObject2D_Vertices[allObject2D_Faces[f][i]][0] - x[o], allObject2D_Vertices[allObject2D_Faces[f][i]][1] - y[o], allObject2D_Vertices[allObject2D_Faces[f][i]][2] - z[o]}; 
          float[] vectB = {allObject2D_Vertices[allObject2D_Faces[f][next_i]][0] - x[o], allObject2D_Vertices[allObject2D_Faces[f][next_i]][1] - y[o], allObject2D_Vertices[allObject2D_Faces[f][next_i]][2] - z[o]};
          
          float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
          
          AnglesAll[o] += t;
  
        }
      }


      if (q == 0) {
        foreAngles = AnglesAll[0];
        backAngles = AnglesAll[1];
        
        //if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;
          delta = 1;
        //}
        //else {
        //  MAX_o = 0;
        //  delta = 0;       
        //}
      } 
      else {
        
        if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;          
          MAX_AnglesAll = AnglesAll[1];
          
          backAngles = AnglesAll[1]; 
          
          delta += delta_step;   
        }
        else {
          MAX_o = 0;
          MAX_AnglesAll = AnglesAll[0];
          
          foreAngles = AnglesAll[0];
          
          delta -= delta_step;
        } 
        
        //delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
        delta_step *= 0.75; 

      }

      //println(delta, delta_step);
         

      //if (MAX_AnglesAll > 359) {
      if (MAX_AnglesAll > 357) { // <<<<<<<<<<<<<<<<<<<<<<<<<
        if (pre_angle_to_allObject2D_Faces[f] < MAX_AnglesAll) {
          pre_angle_to_allObject2D_Faces[f] = MAX_AnglesAll;
          
          hitPoint[f][0] = x[MAX_o];
          hitPoint[f][1] = y[MAX_o];
          hitPoint[f][2] = z[MAX_o];
          hitPoint[f][3] = delta;
        }        
      }
      
      if (pre_angle_to_allObject2D_Faces[f] > 0.9 * FLOAT_undefined) {
        pre_angle_to_allObject2D_Faces[f] = MAX_AnglesAll;
      }       

      
    }

  }

  float[] return_point = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, -1};
  
  float pre_dist = FLOAT_undefined;
  
  for (int f = 1; f < allObject2D_Faces.length; f++) {
    
    float hx = hitPoint[f][0];
    float hy = hitPoint[f][1];
    float hz = hitPoint[f][2];
    float h_delta = hitPoint[f][3];

    //if ((hx < 0.9 * FLOAT_undefined) && (hy < 0.9 * FLOAT_undefined) && (hz < 0.9 * FLOAT_undefined)) {
    
      float hd = dist(hx, hy, hz, ray_pnt[0], ray_pnt[1], ray_pnt[2]);
      
      //if (hd < pre_dist) {
      //if ((hd < pre_dist) && (hd > 0.02)) {
      if ((hd < pre_dist) && (h_delta > 0.005)) {
        
        pre_dist = hd;
        
        return_point[0] = hx;
        return_point[1] = hy;
        return_point[2] = hz;
        return_point[3] = hd;
        return_point[4] = f;
      }
    
    //}
  }
 
  return return_point;
  
}


float[] SOLARCHVISION_1Dintersect (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allFractal_Faces.length][4];

  for (int f = 1; f < allFractal_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  float[] pre_angle_to_allFractal_Faces = new float [allFractal_Faces.length];
  
  for (int f = 1; f < allFractal_Faces.length; f++) {
    pre_angle_to_allFractal_Faces[f] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allFractal_Faces.length; f++) {

    float backAngles = FLOAT_undefined;  
    float foreAngles = FLOAT_undefined;

    float delta = 0.5; 
    float delta_step = 0.5;
    
    float delta_dir = -1;
    
    float[] x = {FLOAT_undefined, FLOAT_undefined};
    float[] y = {FLOAT_undefined, FLOAT_undefined};
    float[] z = {FLOAT_undefined, FLOAT_undefined};
    
    float[] AnglesAll = {0, 0};   
    
    float MAX_AnglesAll = 0;
    int MAX_o = -1;

    //for (int q = 0; q < 16; q++) {
    for (int q = 0; q < 32; q++) {
    
      for (int o = 0; o < 2; o++) {

        float delta_test = delta;
        
        if (o == 0) delta_test -= delta_step;
        else delta_test += delta_step;
        
        x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
        y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
        z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
        
        AnglesAll[o] = 0;      
      
        for (int i = 0; i < allFractal_Faces[f].length; i++) {
          int next_i = (i + 1) % allFractal_Faces[f].length;
          
          float[] vectA = {allFractal_Vertices[allFractal_Faces[f][i]][0] - x[o], allFractal_Vertices[allFractal_Faces[f][i]][1] - y[o], allFractal_Vertices[allFractal_Faces[f][i]][2] - z[o]}; 
          float[] vectB = {allFractal_Vertices[allFractal_Faces[f][next_i]][0] - x[o], allFractal_Vertices[allFractal_Faces[f][next_i]][1] - y[o], allFractal_Vertices[allFractal_Faces[f][next_i]][2] - z[o]};
          
          float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
          
          AnglesAll[o] += t;
  
        }
      }


      if (q == 0) {
        foreAngles = AnglesAll[0];
        backAngles = AnglesAll[1];
        
        //if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;
          delta = 1;
        //}
        //else {
        //  MAX_o = 0;
        //  delta = 0;       
        //}
      } 
      else {
        
        if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;          
          MAX_AnglesAll = AnglesAll[1];
          
          backAngles = AnglesAll[1]; 
          
          delta += delta_step;   
        }
        else {
          MAX_o = 0;
          MAX_AnglesAll = AnglesAll[0];
          
          foreAngles = AnglesAll[0];
          
          delta -= delta_step;
        } 
        
        //delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
        delta_step *= 0.75; 

      }

      //println(delta, delta_step);
         

      //if (MAX_AnglesAll > 359) {
      if (MAX_AnglesAll > 357) { // <<<<<<<<<<<<<<<<<<<<<<<<<
        if (pre_angle_to_allFractal_Faces[f] < MAX_AnglesAll) {
          pre_angle_to_allFractal_Faces[f] = MAX_AnglesAll;
          
          hitPoint[f][0] = x[MAX_o];
          hitPoint[f][1] = y[MAX_o];
          hitPoint[f][2] = z[MAX_o];
          hitPoint[f][3] = delta;
        }        
      }
      
      if (pre_angle_to_allFractal_Faces[f] > 0.9 * FLOAT_undefined) {
        pre_angle_to_allFractal_Faces[f] = MAX_AnglesAll;
      }       

      
    }

  }

  float[] return_point = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, -1};
  
  float pre_dist = FLOAT_undefined;
  
  for (int f = 1; f < allFractal_Faces.length; f++) {
    
    float hx = hitPoint[f][0];
    float hy = hitPoint[f][1];
    float hz = hitPoint[f][2];
    float h_delta = hitPoint[f][3];

    //if ((hx < 0.9 * FLOAT_undefined) && (hy < 0.9 * FLOAT_undefined) && (hz < 0.9 * FLOAT_undefined)) {
    
      float hd = dist(hx, hy, hz, ray_pnt[0], ray_pnt[1], ray_pnt[2]);
      
      //if (hd < pre_dist) {
      //if ((hd < pre_dist) && (hd > 0.02)) {
      if ((hd < pre_dist) && (h_delta > 0.005)) {
        
        pre_dist = hd;
        
        return_point[0] = hx;
        return_point[1] = hy;
        return_point[2] = hz;
        return_point[3] = hd;
        return_point[4] = f;
      }
    
    //}
  }
 
  return return_point;
  
}


float[] SOLARCHVISION_8Dintersect (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allSection_Faces.length][4];

  for (int f = 1; f < allSection_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  float[] pre_angle_to_allSection_Faces = new float [allSection_Faces.length];
  
  for (int f = 1; f < allSection_Faces.length; f++) {
    pre_angle_to_allSection_Faces[f] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allSection_Faces.length; f++) {

    float backAngles = FLOAT_undefined;  
    float foreAngles = FLOAT_undefined;

    float delta = 0.5; 
    float delta_step = 0.5;
    
    float delta_dir = -1;
    
    float[] x = {FLOAT_undefined, FLOAT_undefined};
    float[] y = {FLOAT_undefined, FLOAT_undefined};
    float[] z = {FLOAT_undefined, FLOAT_undefined};
    
    float[] AnglesAll = {0, 0};   
    
    float MAX_AnglesAll = 0;
    int MAX_o = -1;

    //for (int q = 0; q < 16; q++) {
    for (int q = 0; q < 32; q++) {
    
      for (int o = 0; o < 2; o++) {

        float delta_test = delta;
        
        if (o == 0) delta_test -= delta_step;
        else delta_test += delta_step;
        
        x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
        y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
        z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
        
        AnglesAll[o] = 0;      
      
        for (int i = 0; i < allSection_Faces[f].length; i++) {
          int next_i = (i + 1) % allSection_Faces[f].length;
          
          float[] vectA = {allSection_Vertices[allSection_Faces[f][i]][0] - x[o], allSection_Vertices[allSection_Faces[f][i]][1] - y[o], allSection_Vertices[allSection_Faces[f][i]][2] - z[o]}; 
          float[] vectB = {allSection_Vertices[allSection_Faces[f][next_i]][0] - x[o], allSection_Vertices[allSection_Faces[f][next_i]][1] - y[o], allSection_Vertices[allSection_Faces[f][next_i]][2] - z[o]};
          
          float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
          
          AnglesAll[o] += t;
  
        }
      }


      if (q == 0) {
        foreAngles = AnglesAll[0];
        backAngles = AnglesAll[1];
        
        //if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;
          delta = 1;
        //}
        //else {
        //  MAX_o = 0;
        //  delta = 0;       
        //}
      } 
      else {
        
        if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;          
          MAX_AnglesAll = AnglesAll[1];
          
          backAngles = AnglesAll[1]; 
          
          delta += delta_step;   
        }
        else {
          MAX_o = 0;
          MAX_AnglesAll = AnglesAll[0];
          
          foreAngles = AnglesAll[0];
          
          delta -= delta_step;
        } 
        
        //delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
        delta_step *= 0.75; 

      }

      //println(delta, delta_step);
         

      //if (MAX_AnglesAll > 359) {
      if (MAX_AnglesAll > 357) { // <<<<<<<<<<<<<<<<<<<<<<<<<
        if (pre_angle_to_allSection_Faces[f] < MAX_AnglesAll) {
          pre_angle_to_allSection_Faces[f] = MAX_AnglesAll;
          
          hitPoint[f][0] = x[MAX_o];
          hitPoint[f][1] = y[MAX_o];
          hitPoint[f][2] = z[MAX_o];
          hitPoint[f][3] = delta;
        }        
      }
      
      if (pre_angle_to_allSection_Faces[f] > 0.9 * FLOAT_undefined) {
        pre_angle_to_allSection_Faces[f] = MAX_AnglesAll;
      }       

      
    }

  }

  float[] return_point = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, -1};
  
  float pre_dist = FLOAT_undefined;
  
  for (int f = 1; f < allSection_Faces.length; f++) {
    
    float hx = hitPoint[f][0];
    float hy = hitPoint[f][1];
    float hz = hitPoint[f][2];
    float h_delta = hitPoint[f][3];

    //if ((hx < 0.9 * FLOAT_undefined) && (hy < 0.9 * FLOAT_undefined) && (hz < 0.9 * FLOAT_undefined)) {
    
      float hd = dist(hx, hy, hz, ray_pnt[0], ray_pnt[1], ray_pnt[2]);
      
      //if (hd < pre_dist) {
      //if ((hd < pre_dist) && (hd > 0.02)) {
      if ((hd < pre_dist) && (h_delta > 0.005)) {
        
        pre_dist = hd;
        
        return_point[0] = hx;
        return_point[1] = hy;
        return_point[2] = hz;
        return_point[3] = hd;
        return_point[4] = f;
      }
    
    //}
  }
 
  return return_point;
  
}




float[] SOLARCHVISION_0Dintersect (float[] ray_pnt, float[] ray_dir, float max_distance) {

  float[] ray_normal = fn_normalize(ray_dir);   

  float[][] hitPoint = new float [(LAND_n_I - 1) * (LAND_n_J - 1) + 1][4];

  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  float[] pre_angle_to_allFaces = new float [(LAND_n_I - 1) * (LAND_n_J - 1) + 1];
  
  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {
    pre_angle_to_allFaces[f] = FLOAT_undefined;
  }
  
  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {
    
    int LAND_i = (f - 1) / (LAND_n_J - 1);
    int LAND_j = (f - 1) % (LAND_n_J - 1);
    
    float backAngles = FLOAT_undefined;  
    float foreAngles = FLOAT_undefined;

    float delta = 0.5; 
    float delta_step = 0.5;
    
    float delta_dir = -1;
    
    float[] x = {FLOAT_undefined, FLOAT_undefined};
    float[] y = {FLOAT_undefined, FLOAT_undefined};
    float[] z = {FLOAT_undefined, FLOAT_undefined};
    
    float[] AnglesAll = {0, 0};   
    
    float MAX_AnglesAll = 0;
    int MAX_o = -1;

    //for (int q = 0; q < 16; q++) {
    for (int q = 0; q < 32; q++) {
    
      for (int o = 0; o < 2; o++) {

        float delta_test = delta;
        
        if (o == 0) delta_test -= delta_step;
        else delta_test += delta_step;
        
        x[o] = ray_pnt[0] + delta_test * ray_normal[0] * max_distance; 
        y[o] = ray_pnt[1] + delta_test * ray_normal[1] * max_distance; 
        z[o] = ray_pnt[2] + delta_test * ray_normal[2] * max_distance; 
        
        AnglesAll[o] = 0;      
      
        for (int i = 0; i < 4; i++) {
          
          float xA = FLOAT_undefined;
          float yA = FLOAT_undefined;
          float zA = FLOAT_undefined;
          
          float xB = FLOAT_undefined;
          float yB = FLOAT_undefined;
          float zB = FLOAT_undefined;

          if (i == 0) {
            xA = LAND_MESH[LAND_i][LAND_j][0];
            yA = LAND_MESH[LAND_i][LAND_j][1];
            zA = LAND_MESH[LAND_i][LAND_j][2];
            
            xB = LAND_MESH[LAND_i][LAND_j + 1][0];
            yB = LAND_MESH[LAND_i][LAND_j + 1][1];
            zB = LAND_MESH[LAND_i][LAND_j + 1][2];            
          }
          else if (i == 1) {
            xA = LAND_MESH[LAND_i][LAND_j + 1][0];
            yA = LAND_MESH[LAND_i][LAND_j + 1][1];
            zA = LAND_MESH[LAND_i][LAND_j + 1][2];
            
            xB = LAND_MESH[LAND_i + 1][LAND_j + 1][0];
            yB = LAND_MESH[LAND_i + 1][LAND_j + 1][1];
            zB = LAND_MESH[LAND_i + 1][LAND_j + 1][2];            
          }   
          else if (i == 2) {
            xA = LAND_MESH[LAND_i + 1][LAND_j + 1][0];
            yA = LAND_MESH[LAND_i + 1][LAND_j + 1][1];
            zA = LAND_MESH[LAND_i + 1][LAND_j + 1][2];
            
            xB = LAND_MESH[LAND_i + 1][LAND_j][0];
            yB = LAND_MESH[LAND_i + 1][LAND_j][1];
            zB = LAND_MESH[LAND_i + 1][LAND_j][2];            
          }              
          else if (i == 3) {
            xA = LAND_MESH[LAND_i + 1][LAND_j][0];
            yA = LAND_MESH[LAND_i + 1][LAND_j][1];
            zA = LAND_MESH[LAND_i + 1][LAND_j][2];
            
            xB = LAND_MESH[LAND_i][LAND_j][0];
            yB = LAND_MESH[LAND_i][LAND_j][1];
            zB = LAND_MESH[LAND_i][LAND_j][2];            
          }      
          
          float[] vectA = {xA - x[o], yA - y[o], zA - z[o]}; 
          float[] vectB = {xB - x[o], yB - y[o], zB - z[o]};
          
          float t = acos_ang(fn_dot(fn_normalize(vectA), fn_normalize(vectB)));
          
          AnglesAll[o] += t;
  
        }
      }


      if (q == 0) {
        foreAngles = AnglesAll[0];
        backAngles = AnglesAll[1];
        
        //if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;
          delta = 1;
        //}
        //else {
        //  MAX_o = 0;
        //  delta = 0;       
        //}
      } 
      else {
        
        if (AnglesAll[0] < AnglesAll[1]) {
          MAX_o = 1;          
          MAX_AnglesAll = AnglesAll[1];
          
          backAngles = AnglesAll[1]; 
          
          delta += delta_step;   
        }
        else {
          MAX_o = 0;
          MAX_AnglesAll = AnglesAll[0];
          
          foreAngles = AnglesAll[0];
          
          delta -= delta_step;
        } 
        
        //delta_step *= 0.666; // 0.5; <<<<<<<<<<<<<<<          
        delta_step *= 0.75; 

      }

      //println(delta, delta_step);
         

      //if (MAX_AnglesAll > 359) {
      if (MAX_AnglesAll > 357) { // <<<<<<<<<<<<<<<<<<<<<<<<<
        if (pre_angle_to_allFaces[f] < MAX_AnglesAll) {
          pre_angle_to_allFaces[f] = MAX_AnglesAll;
          
          hitPoint[f][0] = x[MAX_o];
          hitPoint[f][1] = y[MAX_o];
          hitPoint[f][2] = z[MAX_o];
          hitPoint[f][3] = delta;
        }        
      }
      
      if (pre_angle_to_allFaces[f] > 0.9 * FLOAT_undefined) {
        pre_angle_to_allFaces[f] = MAX_AnglesAll;
      }       

      
    }

  }

  float[] return_point = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, -1};
  
  float pre_dist = FLOAT_undefined;
  
  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {
    
    float hx = hitPoint[f][0];
    float hy = hitPoint[f][1];
    float hz = hitPoint[f][2];
    float h_delta = hitPoint[f][3];

    //if ((hx < 0.9 * FLOAT_undefined) && (hy < 0.9 * FLOAT_undefined) && (hz < 0.9 * FLOAT_undefined)) {
    
      float hd = dist(hx, hy, hz, ray_pnt[0], ray_pnt[1], ray_pnt[2]);
      
      //if (hd < pre_dist) {
      //if ((hd < pre_dist) && (hd > 0.02)) {
      if ((hd < pre_dist) && (h_delta > 0.005)) {
        
        pre_dist = hd;
        
        return_point[0] = hx;
        return_point[1] = hy;
        return_point[2] = hz;
        return_point[3] = hd;
        return_point[4] = f;
      }
    
    //}
  }
 
  return return_point;
  
}




float[][] getSubFace (float[][] base_Vertices, int Tessellation, int n) {

  float[][] return_vertices = {};
    
  int TotalSubNo = 1;
  if (Tessellation > 0) TotalSubNo = base_Vertices.length * int(roundTo(pow(4, Tessellation - 1), 1));   
  
  if ((Tessellation <= 0) || (n < 0) || (n >= TotalSubNo)) {
    return_vertices = new float [base_Vertices.length][3];
    
    for (int j = 0; j < base_Vertices.length; j++) {
      return_vertices[j] = base_Vertices[j];
    }
  }
  else {
    return_vertices = new float [4][3];
      
    int div = base_Vertices.length;
    
    int the_first = n % div;
    int the_next = (the_first + 1) % div;
    int the_previous = (the_first + div - 1) % div;

    float[] A = {0,0,0};
    float[] B = {0,0,0};
    float[] C = {0,0,0};
    float[] D = {0,0,0};
    
    for (int i = 0; i < 3; i++) {

      A[i] = base_Vertices[the_first][i];
      B[i] = 0.5 * (A[i] + base_Vertices[the_next][i]);
      D[i] = 0.5 * (A[i] + base_Vertices[the_previous][i]);
      
      for (int j = 0; j < base_Vertices.length; j++) {
        C[i] += base_Vertices[j][i] / (1.0 * base_Vertices.length);
      }
    }
    
    if (Tessellation == 1) {
      return_vertices[0] = A; 
      return_vertices[1] = B; 
      return_vertices[2] = C; 
      return_vertices[3] = D; 
    } 
    else {

      int section = n / div;
      int res = int(roundTo(pow(2, Tessellation - 1), 1));
      int u = section / res;
      int v = section % res;
      
      float x1 = (1.0 * u) / (1.0 * res);
      float y1 = (1.0 * v) / (1.0 * res);
      float x2 = (1.0 * (u + 1)) / (1.0 * res);
      float y2 = (1.0 * (v + 1)) / (1.0 * res);
      
      float[] P0 = {0,0,0};
      float[] P1 = {0,0,0};
      float[] P2 = {0,0,0};
      float[] P3 = {0,0,0};
      
      for (int i = 0; i < 3; i++) {
        P0[i] = Bilinear(A[i], B[i], C[i], D[i], x1, y1); 
        P1[i] = Bilinear(A[i], B[i], C[i], D[i], x2, y1); 
        P2[i] = Bilinear(A[i], B[i], C[i], D[i], x2, y2); 
        P3[i] = Bilinear(A[i], B[i], C[i], D[i], x1, y2); 
      }      
      
      //return_vertices[0] = P0; 
      //return_vertices[1] = P1; 
      //return_vertices[2] = P2; 
      //return_vertices[3] = P3;

      //to rotate tri-grid cells:

      int d = ((u % 2) + ((v + 1) % 2)) % 2; 
      if (d == 0) {
        return_vertices[0] = P0; 
        return_vertices[1] = P1; 
        return_vertices[2] = P2; 
        return_vertices[3] = P3;     
      }
      else {
        return_vertices[0] = P1; 
        return_vertices[1] = P2; 
        return_vertices[2] = P3; 
        return_vertices[3] = P0;          
      }  
    }
      
  }
  
 
  return return_vertices;
}


float Bilinear (float f_00, float f_10, float f_11, float f_01, float x, float y) {
  
  float f_xy = f_00 * (1 - x) * (1 - y) + f_10 * x * (1 - y) + f_01 * (1 - x) * y + f_11 * x * y;

  return f_xy;
}
  
  
  
  
// ---------------------------------------------------------

   
float LAND_TEXTURE_scale_U = 1000; // 1km
float LAND_TEXTURE_scale_V = 1000; // 1km
PImage LAND_TEXTURE = createImage(2, 2, RGB);

String LAND_TEXTURE_ImagePath = "";

void SOLARCHVISION_LoadLAND_TEXTURE (String LandDirectory) {

  LAND_TEXTURE_scale_U = 1000; // 1km
  LAND_TEXTURE_scale_V = 1000; // 1km  
  LAND_TEXTURE = createImage(2, 2, RGB);
  
  Display_LAND_TEXTURE = 0;
  
  if (LAND_TEXTURE_ImagePath.equals("")) {
  
    String[] filenames = getfiles(LandDirectory);
  
    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        //println(filenames[i]);
  
        int _L = filenames[i].length();
        String _Extention = filenames[i].substring(_L - 4,_L);
        //println(_Extention);
        if (_Extention.toLowerCase().equals(".jpg")) {
          
          String[] Parts = split(filenames[i], '_');
          
          if (Parts[0].toUpperCase().equals("USE")) {
            
            if (Parts.length > 2) {
          
              LAND_TEXTURE_scale_U = float(Parts[1]); 
              LAND_TEXTURE_scale_V = float(Parts[2]);
              
              LAND_TEXTURE_ImagePath = LandDirectory + "/" + filenames[i];
      
              LAND_TEXTURE = loadImage(LAND_TEXTURE_ImagePath);
              
              Display_LAND_TEXTURE = 1;
             
              break;
            } 
          }
        }
      }
    }
  }
}

   

//Cartesian
//int LAND_n_I_base = 15;
//int LAND_n_J_base = 15;
//int LAND_n_I = LAND_n_I_base * 2 + 1;
//int LAND_n_J = LAND_n_J_base * 2 + 1;    

//Polar
int LAND_n_I_base = 0;
int LAND_n_J_base = 0;
int LAND_n_I = 13 + 1; //16 + 1; //13 + 1; // 24 + 1;
int LAND_n_J = 24 + 1;     




double LAND_mid_lat;
double LAND_mid_lon;

float[][][] LAND_MESH;

void SOLARCHVISION_LoadLAND_MESH (String ProjectSite) {

  String LandDirectory = LandFolder + "/" + ProjectSite + "/"  + ProjectSite;
  
  LAND_mid_lat = LocationLatitude;
  LAND_mid_lon = LocationLongitude;
  
  LAND_MESH = new float [LAND_n_I][LAND_n_J][3];
  
  for (int i = 0; i < LAND_n_I; i += 1) {
    for (int j = 0; j < LAND_n_J; j += 1) {
      LAND_MESH[i][j][0] = FLOAT_undefined;
      LAND_MESH[i][j][1] = FLOAT_undefined;
      LAND_MESH[i][j][2] = FLOAT_undefined;
    }
  }

  try { 
  
    if (Load_LAND_MESH == 1) {
  
      for (int i = 0; i < LAND_n_I; i += 1) {
    
        XML FileALL = loadXML(LandDirectory + "/" + nf(i - LAND_n_I_base, 0) + ".xml");
  
        XML[] children0 = FileALL.getChildren("result");
        
        for (int j = 0; j < LAND_n_J; j += 1) {
    
          String txt_elevation = children0[j].getChild("elevation").getContent();
          
          XML[] children1 = children0[j].getChildren("location");
          
          String txt_latitude = children1[0].getChild("lat").getContent();
          String txt_longitude = children1[0].getChild("lng").getContent();
          
          //println(txt_longitude, txt_latitude, txt_elevation);
    
          double _lon = Double.parseDouble(txt_longitude); 
          double _lat = Double.parseDouble(txt_latitude); 
    
          double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * R_earth);
          double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * R_earth);
          
          float x = (float) du * cos_ang((float) _lat);
          float y = (float) dv; 
          float z = float(txt_elevation);
    
          //println(i, j);
          //println(x,y,z);
          
          LAND_MESH[i][j][0] = x;      
          LAND_MESH[i][j][1] = y;      
          LAND_MESH[i][j][2] = z;      
        }
      }
      
      float h = LAND_MESH[LAND_n_I_base][LAND_n_J_base][2];
      
      h += HeightAboveGround;
      
      for (int i = 0; i < LAND_n_I; i += 1) {
        for (int j = 0; j < LAND_n_J; j += 1) {
          
          LAND_MESH[i][j][2] -= h; 
          
        }
      }
    
    }
  }
  
  catch (Exception e) {
    println("ERROR loading LAND_MESH!");  
  }

  LAND_TEXTURE_ImagePath = "";
  
  SOLARCHVISION_LoadLAND_TEXTURE(LandDirectory);

}


void SOLARCHVISION_DownloadLAND_MESH() {

  LAND_mid_lat = LocationLatitude;
  LAND_mid_lon = LocationLongitude;
  
  LAND_MESH = new float [LAND_n_I][LAND_n_J][3];


  for (int i = 0; i < LAND_n_I; i += 1) {

    String the_link = "";

    //double stp_lat = 1.0 / 2224.5968; // equals to 50m <<<<<<<< Note: for many locations this one is applied
    double stp_lat = 40.0 / 2224.5968; // equals to 2km 
    
    double stp_lon = stp_lat / cos_ang((float) LAND_mid_lat); 

    for (int j = 0; j < LAND_n_J; j += 1) {

      float t = j * 360.0 / (LAND_n_J - 1);
      
      //float q = 2;
      //float q = pow(2, 0.5); // <<<<<<<< Note: for many locations this one is applied
      //float q = 1.25;
      float q = 1.125;

      
      float r = 0;
      if (i > 0) r = pow(q, i - 1);

      double _lon = LAND_mid_lon + stp_lon * r * cos_ang(t);
      double _lat = LAND_mid_lat + stp_lat * r * sin_ang(t);
      
      double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * R_earth);
      double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * R_earth);
      
      float x = (float) du * cos_ang((float) LAND_mid_lat);
      float y = (float) dv; 
      
      //println(dist_lon_lat(_lon, _lat, LAND_mid_lon, LAND_mid_lat));
      //println(dist(x,y,0,0));
      //println("____________");
  
      //String txt_latitude = String.valueOf(_lat);
      //String txt_longitude = String.valueOf(_lon);
      
      String txt_latitude = nf((float) _lat, 0, 5);
      String txt_longitude = nf((float) _lon, 0, 5);      
      
      if (the_link.equals("")) the_link = "https://maps.googleapis.com/maps/api/elevation/xml?locations=";
      else the_link += "%7C"; //"|";
      
      the_link += txt_latitude + "," + txt_longitude;

    }

    println(nf(i, 0), ":", the_link);
    //link(the_link);
    
    String LandFile = LandFolder + "/" + nf(LocationLatitude, 0, 5) + "_" + nf(LocationLongitude, 0, 5) + "/" + nf(i, 0) + ".xml";
    saveBytes(LandFile, loadBytes(the_link));

    
    XML FileALL = loadXML(LandFile);

    XML[] children0 = FileALL.getChildren("result");

    for (int j = 0; j < LAND_n_J; j += 1) {

      String txt_elevation = children0[j].getChild("elevation").getContent();
      
      XML[] children1 = children0[j].getChildren("location");
      
      String txt_latitude = children1[0].getChild("lat").getContent();
      String txt_longitude = children1[0].getChild("lng").getContent();
      
      //println(txt_longitude, txt_latitude, txt_elevation);

      double _lon = Double.parseDouble(txt_longitude); 
      double _lat = Double.parseDouble(txt_latitude); 

      double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * R_earth);
      double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * R_earth);
      
      float x = (float) du * cos_ang((float) _lat);
      float y = (float) dv; 
      float z = float(txt_elevation);

      //println(i, j);
      //println(x,y,z);
      
      LAND_MESH[i][j][0] = x;      
      LAND_MESH[i][j][1] = y;      
      LAND_MESH[i][j][2] = z;    
    
      if ((i == 0) && (j == 0)) LocationElevation = z;
    }
  }
  
  float h = LAND_MESH[LAND_n_I_base][LAND_n_J_base][2];
  
  h += HeightAboveGround;
  
  for (int i = 0; i < LAND_n_I; i += 1) {
    for (int j = 0; j < LAND_n_J; j += 1) {
      
      LAND_MESH[i][j][2] -= h; 
      
    }
  }

  Download_LAND_MESH = 0;

}


 
class ParametricGeometry { 
  float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotX, rotY, rotZ; 
  
  ParametricGeometry (float v, float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz) {  
    value = v;
    posX = x;
    posY = y; 
    posZ = z;    
    powX = px;
    powY = py;
    powZ = pz;    
    scaleX = sx;
    scaleY = sy; 
    scaleZ = sz;
    rotX = -tx;
    rotY = -ty;
    rotZ = -tz;
  } 
  
  void updatePosition (float x, float y, float z) {  
    posX = x;
    posY = y; 
    posZ = z;
  }   
  
  void RotateX (float t) {  
    rotX -= t;
  }

  void RotateY (float t) {  
    rotY -= t;
  }   

  void RotateZ (float t) {  
    rotZ -= t;
  }     
 
  void Scale (float a, float b, float c) {  
    scaleX *= a;
    scaleY *= b;
    scaleZ *= c;
  }     
  
  float Distance (float a, float b, float c) {
    a -= posX;
    b -= posY;    
    c -= posZ;
    
    
///////////////////////// NOT SURE START!    
    float x1 = a;
    float y1 = b * cos_ang(rotX) - c * sin_ang(rotX); 
    float z1 = b * sin_ang(rotX) + c * cos_ang(rotX);
   
    a = x1;
    b = y1;
    c = z1;  

    float x2 = c * sin_ang(rotY) + a * cos_ang(rotY);
    float y2 = b; 
    float z2 = c * cos_ang(rotY) - a * sin_ang(rotY);
    
    a = x2;
    b = y2;
    c = z2;      
///////////////////////// NOT SURE END!
    
    float x = a * cos_ang(rotZ) - b * sin_ang(rotZ);
    float y = a * sin_ang(rotZ) + b * cos_ang(rotZ); 
    float z = c;    

    x += posX;
    y += posY;  
    z += posZ;

    //fffffffffffffffffffffff
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value); 
    return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))));

    
  } 
  
} 


void SOLARCHVISION_remove_ParametricGeometries () {
  SolidObjects = new ParametricGeometry[0];
}


ParametricGeometry[] SolidObjects = {};

void SOLARCHVISION_add_ParametricGeometries () {

/*
  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 10;
    float dy = 10;
    float dz = 45;
    float x = 0;
    float y = 10.1;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 

    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    for (float i = 0; i < 45; i += 3) {
      SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
      
      SOLARCHVISION_add_2Dobjects_plane(0, 10, x,y,i, dx, dy); // people  
    }   
  }  

  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 10;
    float dy = 10;
    float dz = 45;
    float x = -30;
    float y = 10.1;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 

    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    for (float i = 0; i < 45; i += 3) {
      SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
      
      SOLARCHVISION_add_2Dobjects_plane(0, 10, x,y,i, dx, dy); // people  
    }   
  }    

  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 10;
    float dy = 10;
    float dz = 45;
    float x = 30;
    float y = 10.1;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 

    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    for (float i = 0; i < 45; i += 3) {
      SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
      
      SOLARCHVISION_add_2Dobjects_plane(0, 10, x,y,i, dx, dy); // people  
    }    
  }    


  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float d = 1.0;
    for (float i = 0; i < 45; i += d) {
      SOLARCHVISION_add_H_shade(1,0,0,1,1, 30,0,i, 20,d, 90-4*i,0); // south
    }
  }
  
  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float d = 1.0;
    for (float i = -10; i <= 10; i += d) {
      SOLARCHVISION_add_V_shade(6,0,0,1,1, i-30,0,22.5, 45,d, 4.5*i,0); // south
    }    
  }
  
  
  {
    float d = 1.0;
    for (float i = 0; i < 45; i += d) {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      
      float x = 0;
      float y = 0;
      float z = i;
      int spv = 1; // X-axis
      
      SOLARCHVISION_add_H_shade(1,0,spv,1,1, x,y,z, 20,d, 0,0); // south
      
      int n = allPolymesh_SolarPivotXYZ.length - 1;
      
      allPolymesh_SolarPivotXYZ[n][0] = x;
      allPolymesh_SolarPivotXYZ[n][1] = y;
      allPolymesh_SolarPivotXYZ[n][2] = z;
    }
    
    for (float i = -10; i <= 10; i += d) {
      addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
      
      float x = i;
      float y = 0;
      float z = 22.5;
      int spv = 3; // Z-axis
      
      SOLARCHVISION_add_V_shade(3,0,spv,1,1, x,y,z, 45,d, 0,0); // south
      
      int n = allPolymesh_SolarPivotXYZ.length - 1;
      
      allPolymesh_SolarPivotXYZ[n][0] = x;
      allPolymesh_SolarPivotXYZ[n][1] = y;
      allPolymesh_SolarPivotXYZ[n][2] = z;
    }    
  }    
*/  
 
  /* 
  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
       
    float d = 1.0;
    
    for (float i = 0; i < 45; i += d) {
       
      SOLARCHVISION_add_H_shade(1,0,0,1,1, 0,0,i, 20,d, 90-4*i,0); // south
      //SOLARCHVISION_add_H_shade(2,0,0,1,1, 10,10,i, 20,d, 90-4*i,90); // east
      //SOLARCHVISION_add_H_shade(3,0,0,1,1, -10,10,i, 20,d, 90-4*i,270); // west

    }
    
    for (float i = -10; i <= 10; i += d) {
       
      //SOLARCHVISION_add_V_shade(4,0,0,1,1, i,20,22.5, 45,d, 4.5*i,180); // north
      
      SOLARCHVISION_add_V_shade(6,0,0,1,1, i,0,22.5, 45,d, 4.5*i,0); // south
    }    
  }
  */
 
 
  



  
  //SOLARCHVISION_add_2Dobjects_plane(0, 100, 0,0,0, 50,50); // people
  //SOLARCHVISION_add_2Dobjects_plane(1, 25, 0,40,0, 50,10); // trees back
  //SOLARCHVISION_add_2Dobjects_plane(1, 25, 0,-30,0, 50,20); // trees front
/*
  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
  SOLARCHVISION_add_PolygonHyper(0,0,0,1,1, 30,-30,4.5, 9, 9, 6, 0);  // hyper
  

  {  
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 5;
    float dy = 5;
    float dz = 5;
    float x = -30;
    float y = -30;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_add_House_Core(7,0,0,1,1, x,y,z, dx,dy,dz, dz, rot); // house 
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot);
   } 

  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float r = 5;    
    float x = 0;
    float y = -30;
    float z = r;
    //SOLARCHVISION_add_FractalSphere(1,0,0,1,1, x,y,z, r, 2, 0, 0);
    SOLARCHVISION_add_FractalSphere(1,0,0,1,1, x,y,z, r, 4, 0, 0);
    SOLARCHVISION_addToSolids(1, x,y,z, 2,2,2, r,r,r, 0,0,0);
  }    
*/

  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 100;
    float dy = 100;
    float dz = 10;
    float x = 0;
    float y = 0;
    float z = -dz;    
    float rot = 0;
    SOLARCHVISION_add_Box_Core(7,0,0,1,1, x,y,z, dx, dy, dz, rot);
    //SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 
  }  

  SOLARCHVISION_add_2Dobjects_polar(1, 40, 0,0,0, 40,100); // trees
  SOLARCHVISION_add_2Dobjects_polar(0, 100, 0,0,0, 0,100); // people
  


  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 24;
    float dy = 24;
    float dz = 18;
    float x = 0;
    float y = 0;
    float z = 0;    
    float rot = 0;
    SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 

    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    for (float i = 6; i <= dz; i += 6) {
      if (i != dz) {
        
        SOLARCHVISION_add_Mesh2(6,0,0,1,1, x-dx,y-dy,i, x-dx/3.0,y+dy/3.0,i); // floors
        SOLARCHVISION_add_Mesh2(6,0,0,1,1, x-dx,y+dy/3.0,i, x+dx/3.0,y+dy,i); // floors
        SOLARCHVISION_add_Mesh2(6,0,0,1,1, x+dx/3.0,y-dy/3.0,i, x+dx,y+dy,i); // floors
        SOLARCHVISION_add_Mesh2(6,0,0,1,1, x-dx/3.0,y-dy,i, x+dx,y-dy/3.0,i); // floors

      }
      
      SOLARCHVISION_add_2Dobjects_Mesh2(0, 10, x-dx,y-dy,i, x-dx/3.0,y+dy/3.0,i); // people  
      SOLARCHVISION_add_2Dobjects_Mesh2(0, 10, x-dx,y+dy/3.0,i, x+dx/3.0,y+dy,i); // people
      SOLARCHVISION_add_2Dobjects_Mesh2(0, 10, x+dx/3.0,y-dy/3.0,i, x+dx,y+dy,i); // people
      SOLARCHVISION_add_2Dobjects_Mesh2(0, 10, x-dx/3.0,y-dy,i, x+dx,y-dy/3.0,i); // people
    }   
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    SOLARCHVISION_add_PolygonHyper(0,1,0,1,1, x-0.5*dx,y+0.5*dy,z+dz+4.5, 9, 9, 4, 0);  // hyper
    
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    for (float i = 0; i < dy; i += 6) {
      SOLARCHVISION_add_H_shade(1,0,0,1,1, x+0.5*dx,-i,z+dz+2, dx,2, -45,0); // south
    }     
  }  


  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
       

    SOLARCHVISION_add_H_shade(1,0,0,1,1, 12,-24,3, 24,6, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,9, 24,1, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,10, 24,1, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,11, 24,1, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,12, 24,1, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,15, 24,1, 0,0); // south
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -12,-24,18, 24,1, 0,0); // south

    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,12,3, 24,6, 0,270); // west    
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,9, 24,1, 0,270); // west
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,10, 24,1, 0,270); // west
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,11, 24,1, 0,270); // west
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,12, 24,1, 0,270); // west
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,15, 24,1, 0,270); // west
    SOLARCHVISION_add_H_shade(1,0,0,1,1, -24,-12,18, 24,1, 0,270); // west

    for (float i = 0; i < 24; i += 3) {
      SOLARCHVISION_add_V_shade(1,0,0,1,1, 24,-i,12, 12,1, -45,90); // east
    }

    for (float i = 0; i < 24; i += 3) {
      SOLARCHVISION_add_V_shade(1,0,0,1,1, -i,24,12, 12,1, 0,180); // north
    }
  }

  {  
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = 30;
    float y = 30;
    float z = 9;    
    float rot = 30;
    SOLARCHVISION_add_Box_Core(4,0,0,1,1, x,y,z, dx, dy, dz, rot);
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot); 
  }   

  {  
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float dx = 5;
    float dy = 5;
    float dz = 5;
    float x = 50;
    float y = -50;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_add_House_Core(6,0,0,1,1, x,y,z, dx,dy,dz, dz, rot); // house 
    SOLARCHVISION_addToSolids(1, x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot);
   } 

  {
    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
    float r = 5;    
    float x = 0;
    float y = -50;
    float z = r;
    SOLARCHVISION_add_FractalSphere(2,0,0,1,1, x,y,z, r, 3, 0, 0);
    SOLARCHVISION_addToSolids(1, x,y,z, 2,2,2, r,r,r, 0,0,0);
  }      

  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
  SOLARCHVISION_add_PolygonHyper(0,1,0,1,1, -50,-50,4.5, 9, 9, 6, 0);  // hyper

}





void SOLARCHVISION_build_SolarImpact_Image_array () {

  SolarImpact_Image = new PImage [(1 + STUDY_j_end - STUDY_j_start)];
  
  for (int j = STUDY_j_start - 1; j < STUDY_j_end; j += 1) { // total image at j = -1 
    
    SolarImpact_Image[j + 1] = createImage(2, 2, RGB); // empty and small
    
  }  
  
  rebuild_SolarImpact_Image_array = 0;
}

void SOLARCHVISION_build_WindRose_Image_array () {
  
  WindRose_Image = new PImage [(1 + STUDY_j_end - STUDY_j_start)];
  
  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
    
    WindRose_Image[j + 1] = createImage(2, 2, RGB); // empty and small
    
  }  
  
  rebuild_WindRose_Image_array = 0;
}

int Day_of_Impact_to_Display = 0; // 0:total 1:day-1 2:day-2 etc.

PImage[] WindRose_Image;

int Display_WindRose_Image = 0; // 0:talse 1:true

int WindRose_RES = 400;

int Rendered_WindRose_RES = WindRose_RES;


PImage[] SolarImpact_Image;

int Display_SolarImpact_Image = 0; // 0:talse 1:true
int SolarImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float SolarImpact_Rotation = 0; // North is up by default

float SolarImpact_scale_U = float(DEFINED_STATIONS[STATION_NUMBER][7]); // i.e. 500 = 500m 
float SolarImpact_scale_V = float(DEFINED_STATIONS[STATION_NUMBER][7]); // i.e. 500 = 500m 

float SolarImpact_offset_U = 0;
float SolarImpact_offset_V = 0; 

int SolarImpact_RES1 = 200;
int SolarImpact_RES2 = 200;

float SolarImpact_Elevation;


void SOLARCHVISION_calculate_SolarImpact_CurrentSection () {

  if (rebuild_SolarProjection_array != 0) {
    SOLARCHVISION_build_SolarImpact_Image_array();
  }
  
  if (SolarImpact_sectionType != 0) {

    cursor(WAIT);
    
    int start_z = get_startZ_endZ(impacts_source)[0];
    int end_z = get_startZ_endZ(impacts_source)[1]; 
    int layers_count = get_startZ_endZ(impacts_source)[2];     
      

    int RES1 = SolarImpact_RES1;
    int RES2 = SolarImpact_RES2;

    if (plot_impacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
    if (plot_impacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;
    
    float _values_R_dir;
    float _values_R_dif;
    
    float _values_E_dir;
    float _values_E_dif;
    
    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    float PAL_Multiplier = 1; 
    
    if (Impact_TYPE == Impact_ACTIVE) {
      PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
      PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT; 
    }             

    for (int p = 0; p < 1; p += 1) { 
      int l = impact_layer;

      PImage total_Image_RGBA = createImage(RES1, RES2, RGB);
      
      float[][][] total_Matrix_ARGB;
      total_Matrix_ARGB = new float [4][RES1][RES2];

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;
        
        total_Matrix_ARGB[0][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[1][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[2][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[3][Image_X][Image_Y] = 0; 
      }

      for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {
 
        now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;
    
        if (now_j >= 365) {
         now_j = now_j % 365; 
        }
        if (now_j < 0) {
         now_j = (now_j + 365) % 365; 
        }
 
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        int DATE_ANGLE_approximate = int((DATE_ANGLE + 15) / 30) * 30;
        if (DATE_ANGLE_approximate == 360) DATE_ANGLE_approximate = 0;
        
        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);
        
        //println(DATE_ANGLE, DATE_ANGLE_approximate);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);
        
        //println("j =", j);
        //println(Normals_COL_N);
        
        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / num_add_days);
            int j_ADD = nk % num_add_days; 

            float[][][] Matrix_ARGB;
            
            Matrix_ARGB = new float [4][RES1][RES2];

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
              
              Matrix_ARGB[0][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[1][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[2][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[3][Image_X][Image_Y] = FLOAT_undefined;
            }

            PImage Image_RGBA = createImage(RES1, RES2, RGB);



              
            int _valuesNUM = 0;  

            for (int i = 4; i <= 20; i += 1) { // to make it faster. Also the images are not available out of this period. 
              if (isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {
  
                  now_k = k;
                  now_i = i;
                  now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
      
                  if (now_j >= 365) {
                   now_j = now_j % 365; 
                  }
                  if (now_j < 0) {
                   now_j = (now_j + 365) % 365; 
                  }
    
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                      Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
                  }
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                      Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
                      Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
                      Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
                  }            
                  if (impacts_source == databaseNumber_OBSERVED) {
                      Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
                      Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
                      Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
                  }   
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {
                      Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
                  }   
    
                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined; 
                  }
                  else {
      
                    int drw_count = 0;
                    if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    
                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;  
                      _values_R_dif = 0.001 * Pb; 
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;
                      
                      for (int RAD_TYPE = 0; RAD_TYPE <= 1; RAD_TYPE += 1) { 
                        float RAD_VALUE = 0;
                        float EFF_VALUE = 0;
                        if (RAD_TYPE == 0) {
                          RAD_VALUE = _values_R_dir; 
                          EFF_VALUE = _values_E_dir;
                        }
                        else { 
                          //float MULT_dif = 2.0;
                          float MULT_dif = E; // 2.718
                          
                          RAD_VALUE = _values_R_dif * MULT_dif;
                          EFF_VALUE = _values_E_dif * MULT_dif;
                        }
    
                        PImage[] Shadings = new PImage[2];
                        for (int SHD = 0; SHD <= 1; SHD += 1) {
                          String[] STR_SHD = {"F" , "T"};
                          String File_Name = "";
    
                          if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Financial_District")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Financial_District" + "/";
                          }   
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Ryerson_University")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Ryerson_University" + "/";
                          }   
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Place_Bonaventure")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Place_Bonaventure" + "/";
                          }                      
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Montreal_Downtown")) { 
                            if (camera_variation == 1) File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/MONTREAL_DOWNTOWN" + "/";
                            if (camera_variation == 2) File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/EV_BUILDING" + "/";
                          }
                          else {
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";
                          }                          
                          
                          
                          if (RAD_TYPE == 0) {
                            File_Name += nf(DATE_ANGLE_approximate, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
                          }
                          else {
                            File_Name += "DIF_" + STR_SHD[SHD];
                          }
                          
                          
                          if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Financial_District")) { 
                            File_Name += "_" + "Financial_District" + "_Camera" + nf(camera_variation, 2) + ".PNG";
                          }    
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Ryerson_University")) { 
                            File_Name += "_" + "Ryerson_University" + "_Camera" + nf(camera_variation, 2) + ".PNG";
                          }    
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Place_Bonaventure")) { 
                            File_Name += "_" + "Place_Bonaventure" + "_Camera" + nf(camera_variation, 2) + ".PNG";
                          }                      
                          else if (DEFINED_STATIONS[STATION_NUMBER][0].equals("Montreal_Downtown")) { 
                            if (camera_variation == 1) File_Name += "_" + "Montreal_Downtown.PNG";
                            if (camera_variation == 2) File_Name += "_" + "Montreal_EV_BUILDING_B.PNG";
                          }
                          else {
                            File_Name += "_" + SceneName + "_" + NearLatitude_Stamp() + "_Camera" + nf(camera_variation, 2) + ".PNG";
                          }
    
                          //println (File_Name);
                          Shadings[SHD]  = loadImage(File_Name);
                        }   
       
                        for (int np = 0; np < (RES1 * RES2); np++) {
                          int Image_X = np % RES1;
                          int Image_Y = np / RES1;
                          
                          if (Matrix_ARGB[0][Image_X][Image_Y] > 0.9 * FLOAT_undefined) {
                            Matrix_ARGB[0][Image_X][Image_Y] = 0;
                            Matrix_ARGB[1][Image_X][Image_Y] = 0;
                            Matrix_ARGB[2][Image_X][Image_Y] = 0;
                            Matrix_ARGB[3][Image_X][Image_Y] = 0;
                          }                             
                  
                          color COL0 = Shadings[0].get(Image_X, Image_Y);
                          color COL1 = Shadings[1].get(Image_X, Image_Y);
                          //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                          float COL_V0 = (COL0 >> 8 & 0xFF) / 255.0; 
                          float COL_V1 = (COL1 >> 8 & 0xFF) / 255.0;
                         
                          float COL_Alpha = (COL1 >> 24 & 0xFF);
                          
                          Matrix_ARGB[0][Image_X][Image_Y] = COL_Alpha;
                          
                          if (Impact_TYPE == Impact_ACTIVE) {  
                            Matrix_ARGB[2][Image_X][Image_Y] += RAD_VALUE * COL_V1;
                          }
                          if (Impact_TYPE == Impact_PASSIVE) {
                            if (EFF_VALUE < 0) {
                              Matrix_ARGB[1][Image_X][Image_Y] -= EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[3][Image_X][Image_Y] -= EFF_VALUE * (COL_V0 - COL_V1); 
                            }
                            else {
                              Matrix_ARGB[3][Image_X][Image_Y] += EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[1][Image_X][Image_Y] += EFF_VALUE * (COL_V0 - COL_V1);
                            }
                          }
                          
                          if (np == 0) _valuesNUM += 1;
    
                        }
                      }
                    }
                  }
                }
              }
            }
  
            float _valuesMUL = 0;
            
            if (_valuesNUM != 0) {
              //_valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
              //_valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
              _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);
            }
           
            Image_RGBA.loadPixels();
  
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
  
              float Image_A = Matrix_ARGB[0][Image_X][Image_Y] * _valuesMUL;
              float Image_R = Matrix_ARGB[1][Image_X][Image_Y] * _valuesMUL;
              float Image_G = Matrix_ARGB[2][Image_X][Image_Y] * _valuesMUL;
              float Image_B = Matrix_ARGB[3][Image_X][Image_Y] * _valuesMUL;
              
              total_Matrix_ARGB[0][Image_X][Image_Y] += Image_A;
              total_Matrix_ARGB[1][Image_X][Image_Y] += Image_R;
              total_Matrix_ARGB[2][Image_X][Image_Y] += Image_G;
              total_Matrix_ARGB[3][Image_X][Image_Y] += Image_B; 

             
              float[] _c = {0, 0, 0, 0};
              
              float _u = 0;
              
              float _valuesSUM = FLOAT_undefined;
              
              if (Impact_TYPE == Impact_ACTIVE) {
                _valuesSUM = Image_G;
                
                //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
                //_u = (0.1 * PAL_Multiplier * _valuesSUM);
                _u = (0.2 * PAL_Multiplier * _valuesSUM);
              }
           
              if (Impact_TYPE == Impact_PASSIVE) {
                float AVERAGE, PERCENTAGE, COMPARISON;
                
                AVERAGE = (Image_B - Image_R);
                if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
                
                _valuesSUM = COMPARISON;
                
                //_u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
                _u = 0.5 + 0.5 * 0.75 * (0.2 * PAL_Multiplier * _valuesSUM);
              }
              
              
              //if ((Image_X == RES1 / 2) && (Image_Y == RES2 / 2)) println("Image Processing: <CENTER> _valuesSUM =", _valuesSUM); 
              //if ((Image_X == RES1 - 1) && (Image_Y == RES2 - 1)) println("Image Processing: <CORNER> _valuesSUM =", _valuesSUM); 
              
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;
              
              _c = GET_COLOR_STYLE(PAL_TYPE, _u);
              
              if (Image_A != 0) Image_RGBA.pixels[np] = color(_c[1], _c[2], _c[3]);
              else Image_RGBA.pixels[np] = color(223, 223, 223);
  
            }
          
            Image_RGBA.updatePixels(); 
            
            if (camera_variation == 0) {
              SolarImpact_Image[j + 1] = Image_RGBA;           
              if (SolarImpact_record_JPG == 1) {
                String myFile = get_SolarImpact_Filename() + "_solar_" + nf(Impact_TYPE, 1) + "_" + nf(j + 1, 0) + ".jpg";
                SolarImpact_Image[j + 1].save(myFile);
                if (j == 0) SOLARCHVISION_explore_output(myFile);
                println("File created:" + myFile);                  
              }
            }            
          }
        }
      }
      
      //----------------------
      if (camera_variation == 0) draw_impact_summary = 1; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      //----------------------
      
      if (draw_impact_summary == 1) { 
        int j = -1; // << to put the summary graph before the daily graphs
        
        total_Image_RGBA.loadPixels();
        
        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;
        
          float Image_A = total_Matrix_ARGB[0][Image_X][Image_Y] / (1.0 * (STUDY_j_end - STUDY_j_start));
          float Image_R = total_Matrix_ARGB[1][Image_X][Image_Y] / (1.0 * (STUDY_j_end - STUDY_j_start));
          float Image_G = total_Matrix_ARGB[2][Image_X][Image_Y] / (1.0 * (STUDY_j_end - STUDY_j_start));
          float Image_B = total_Matrix_ARGB[3][Image_X][Image_Y] / (1.0 * (STUDY_j_end - STUDY_j_start));
         
          float[] _c = {0, 0, 0, 0};
          
          float _u = 0;
          
          float _valuesSUM = FLOAT_undefined;
          
          if (Impact_TYPE == Impact_ACTIVE) {
            _valuesSUM = Image_G;
            
            //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
            //_u = (0.1 * PAL_Multiplier * _valuesSUM);
            _u = (0.2 * PAL_Multiplier * _valuesSUM);
          }
         
          if (Impact_TYPE == Impact_PASSIVE) {
            float AVERAGE, PERCENTAGE, COMPARISON;
            
            AVERAGE = (Image_B - Image_R);
            if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
            
            _valuesSUM = COMPARISON;
            
            //_u = 0.5 + 0.5 * 0.75 * (0.1 * PAL_Multiplier * _valuesSUM);
            _u = 0.5 + 0.5 * 0.75 * (0.2 * PAL_Multiplier * _valuesSUM);
          }
          
          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;
          
          _c = GET_COLOR_STYLE(PAL_TYPE, _u);
          
          if (Image_A != 0) total_Image_RGBA.pixels[np] = color(_c[1], _c[2], _c[3]);
          else total_Image_RGBA.pixels[np] = color(223, 223, 223);
        
        }
        
        total_Image_RGBA.updatePixels(); 
        
        if (camera_variation == 0) {
          SolarImpact_Image[0] = total_Image_RGBA;           
          if (SolarImpact_record_JPG == 1) {
            String myFile = get_SolarImpact_Filename() + "_solar_" + nf(Impact_TYPE, 1) + "_" + nf(0, 0) + ".jpg";
            SolarImpact_Image[0].save(myFile);
            //SOLARCHVISION_explore_output(myFile);
            println("File created:" + myFile);                
          }
        }      
      }
    }
    
    cursor(ARROW);
  }
}
    


void SOLARCHVISION_render_Shadows_selectedSections () {
  
  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

    int f = selectedSection_numbers[o];
    
    if (f != 0) {        
      
      SolarImpact_sectionType = allSection_Type[f];
      SolarImpact_RES1 = allSection_RES1[f];
      SolarImpact_RES2 = allSection_RES2[f];     

      SolarImpact_offset_U = allSection_UVERAB[f][0];
      SolarImpact_offset_V = allSection_UVERAB[f][1];
      SolarImpact_Elevation = 0.1 + allSection_UVERAB[f][2];
      SolarImpact_Rotation = allSection_UVERAB[f][3];
      SolarImpact_scale_U = allSection_UVERAB[f][4];
      SolarImpact_scale_V = allSection_UVERAB[f][5];
      
      SceneName = "temp_" + Section_Stamp();

      SOLARCHVISION_render_Shadows_CurrentSection();

    }
  }

  Display_SolarImpact_Image = 1;
  Display_SpatialImpact_Image = 0;
  ROLLOUT_Update = 1; 

}




void SOLARCHVISION_calculate_SolarImpact_selectedSections () {
  
  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

    int f = selectedSection_numbers[o];
    
    if (f != 0) {        
      
      SolarImpact_sectionType = allSection_Type[f];
      SolarImpact_RES1 = allSection_RES1[f];
      SolarImpact_RES2 = allSection_RES2[f];     

      SolarImpact_offset_U = allSection_UVERAB[f][0];
      SolarImpact_offset_V = allSection_UVERAB[f][1];
      SolarImpact_Elevation = 0.1 + allSection_UVERAB[f][2];
      SolarImpact_Rotation = allSection_UVERAB[f][3];
      SolarImpact_scale_U = allSection_UVERAB[f][4];
      SolarImpact_scale_V = allSection_UVERAB[f][5];
      
      SceneName = "temp_" + Section_Stamp();

      SOLARCHVISION_calculate_SolarImpact_CurrentSection();
      for (int j = STUDY_j_start - 1; j < STUDY_j_end; j += 1) {

        allSection_SolarImpact[f][j + 1] = createImage(SolarImpact_RES1, SolarImpact_RES2, RGB);
        
        allSection_SolarImpact[f][j + 1].copy(SolarImpact_Image[j + 1], 0, 0, SolarImpact_RES1, SolarImpact_RES2, 0, 0, SolarImpact_RES1, SolarImpact_RES2);

      } 

    }
  }

}




void SOLARCHVISION_calculate_SpatialImpact_selectedSections () {
  
  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
    
    int f = selectedSection_numbers[o];
    
    if (f != 0) {        
      
      SpatialImpact_sectionType = allSection_Type[f];
      SpatialImpact_RES1 = allSection_RES1[f];
      SpatialImpact_RES2 = allSection_RES2[f];     

      SpatialImpact_offset_U[SpatialImpact_sectionType] = allSection_UVERAB[f][0];
      SpatialImpact_offset_V[SpatialImpact_sectionType] = allSection_UVERAB[f][1];
      SpatialImpact_Elevation[SpatialImpact_sectionType] = allSection_UVERAB[f][2];
      SpatialImpact_Rotation[SpatialImpact_sectionType] = allSection_UVERAB[f][3];
      SpatialImpact_scale_U[SpatialImpact_sectionType] = allSection_UVERAB[f][4];
      SpatialImpact_scale_V[SpatialImpact_sectionType] = allSection_UVERAB[f][5];
      
      {
        if ((SpatialImpact_Image.width != SpatialImpact_RES1) || (SpatialImpact_Image.height != SpatialImpact_RES2)) {
          SpatialImpact_Image = createImage(SpatialImpact_RES1, SpatialImpact_RES2, ARGB);
        }
        SOLARCHVISION_calculate_SpatialImpact_CurrentSection();
        
        allSection_SpatialImpact[f].copy(SpatialImpact_Image, 0, 0, SpatialImpact_RES1, SpatialImpact_RES2, 0, 0, SpatialImpact_RES1, SpatialImpact_RES2); 
      }
      
    }
  }
}






float[] SpatialImpact_scale_U = {100, 100, 100, 100}; // i.e. 100m
float[] SpatialImpact_scale_V = {100, 100, 100, 100}; // i.e. 100m

float[] SpatialImpact_offset_U = {0, 0, 0, 0}; 
float[] SpatialImpact_offset_V = {0, 0, 0, 0}; 

int SpatialImpact_RES1 = 400; //400;
int SpatialImpact_RES2 = 400; //400;

PImage SpatialImpact_Image = createImage(SpatialImpact_RES1, SpatialImpact_RES2, ARGB);



int Display_SpatialImpact_Image = 1; // 0:false, 1:true
int SpatialImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float[] SpatialImpact_Elevation = {0, 0.1, 0, 0}; // <<<
float[] SpatialImpact_Rotation = {0, 0, 0, 0};

float SpatialImpact_positionStep = 1.25;


int SpatialImpactType = 0; // INTERNAL! 0:simple 1:complex

float ParametricGeometries_SpatialImpact_atXYZ (float x, float y, float z) {

  float v = 0;
  
  if (SpatialImpactType == 0) v = ParametricGeometries_SpatialImpact_atXYZ_simple(x, y, z);
  else v = ParametricGeometries_SpatialImpact_atXYZ_complex(x, y, z);
  
  return v;
}

float ParametricGeometries_SpatialImpact_atXYZ_simple (float x, float y, float z) {

  float val = 1;
  
  for (int n = 0; n < SolidObjects.length; n++) {
    
    float r = SolidObjects[n].value;
    float d = SolidObjects[n].Distance(x, y, z);

    d *= pow(d, SpatialImpact_Power);

    if (val < 0) val *= abs(d - r);
    else {
      val *= d - r;
    }

  }
  
  if (SolidObjects.length > 0) {
    float val_sign = 1;
    if (val < 0) {
      val_sign = -1;
      val = abs(val);
    } 
    val = pow(val, 1.0 / float(SolidObjects.length));
    val *= val_sign;    
  } 

  return val;  
}



float ParametricGeometries_SpatialImpact_atXYZ_complex (float x, float y, float z) {

  float deltaX = SpatialImpact_Wspd * cos_ang(SpatialImpact_Wdir);
  float deltaY = SpatialImpact_Wspd * sin_ang(SpatialImpact_Wdir);

  float[] val = {1, 1};

  for (int o = 0; o < 2; o++) {

    for (int n = 0; n < SolidObjects.length; n++) {

      float r = SolidObjects[n].value;
      float d = SolidObjects[n].Distance(x + o * deltaX , y + o * deltaY, z);
      
      d *= pow(d, SpatialImpact_Power);
  
      if (val[o] < 0) val[o] *= abs(d - r);
      else {
        val[o] *= d - r;
      }        
    }
    
    if (SolidObjects.length > 0) {
      float val_sign = 1;
      if (val[o] < 0) {
        val_sign = -1;
        val[o] = abs(val[o]);
      } 
      val[o] = pow(val[o], 1.0 / float(SolidObjects.length));
      val[o] *= val_sign;    
    }     
  }
  
  return val[1] - val[0];
}




float[][] windFlow_Vertices = {{0,0,0,0}}; // keeping values at the 4th member
int[][] windFlow_Lines = {{0,0}};

void SOLARCHVISION_calculate_windFlow () {

  cursor(WAIT);  

  windFlow_Vertices = new float [1][4];
  windFlow_Vertices[0][0] = 0; 
  windFlow_Vertices[0][1] = 0; 
  windFlow_Vertices[0][2] = 0; 
  windFlow_Vertices[0][3] = 0;   


  windFlow_Lines = new int [1][2];
  windFlow_Lines[0][0] = 0;
  windFlow_Lines[0][1] = 0;  
  



        
  float deltaX = -SpatialImpact_Wspd * cos_ang(SpatialImpact_Wdir);
  float deltaY = -SpatialImpact_Wspd * sin_ang(SpatialImpact_Wdir);
  float deltaZ = 0;   

/* 

  float Section_offset_U = SpatialImpact_offset_U[SpatialImpact_sectionType];
  float Section_offset_V = SpatialImpact_offset_V[SpatialImpact_sectionType];
  float Section_Elevation = SpatialImpact_Elevation[SpatialImpact_sectionType];
  float Section_Rotation = SpatialImpact_Rotation[SpatialImpact_sectionType];
  float Section_scale_U = SpatialImpact_scale_U[SpatialImpact_sectionType];
  float Section_scale_V = SpatialImpact_scale_V[SpatialImpact_sectionType];

  int Section_Type = SpatialImpact_sectionType;
  int Section_RES1 = SpatialImpact_RES1;
  int Section_RES2 = SpatialImpact_RES2; 

  float[] SectionCorner_A = SOLARCHVISION_getCorners_Section(0, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
  float[] SectionCorner_B = SOLARCHVISION_getCorners_Section(1, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
  float[] SectionCorner_C = SOLARCHVISION_getCorners_Section(2, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
  float[] SectionCorner_D = SOLARCHVISION_getCorners_Section(3, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2); 
  
  for (int i = 0; i < SpatialImpact_RES1; i += 10) {
    for (int j = 0; j < SpatialImpact_RES2; j += 10) {
      
      float x = Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));
      float y = Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));
      float z = Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));

*/   


  for (float z = 2.5; z <= 40; z += 10) {
    for (float y = -80; y <= 80; y += 10) {
      for (float x = -80; x <= 80; x += 10) {
        
    

        float[] test_point = {x, y, z};


        int num_steps = 1; //1; //4;
        
        for (int n = 0; n < num_steps; n += 1) {
          
          SpatialImpactType = 0;
          float inside_or_outside = ParametricGeometries_SpatialImpact_atXYZ(test_point[0], test_point[1], test_point[2]);
          
          if (inside_or_outside > 0) {
          
            SpatialImpactType = 1;
            float val = ParametricGeometries_SpatialImpact_atXYZ(test_point[0], test_point[1], test_point[2]);
  
    
            float MinimumDistance_trace = 1 / float(num_steps);
    
            //-----------------------------------------------------------------------------------------------------------------------------------------
            float[][] tracedPoints = SOLARCHVISION_3DtraceContour(MinimumDistance_trace, test_point[0], test_point[1], test_point[2], val);
            //-----------------------------------------------------------------------------------------------------------------------------------------
    
            float[] point_min = tracedPoints[0];
            //float[] point_equ = tracedPoints[1];
            //float[] point_max = tracedPoints[2];
            
            float[] v1 = {deltaX, deltaY, deltaZ};
            
            float[] v2 = {point_min[0] - x, point_min[1] - y, point_min[2] - z};
  
            float acceleration = -SpatialImpact_Wspd * (point_min[3] - val);
  
            float dx = v1[0] + v2[0] * acceleration;
            float dy = v1[1] + v2[1] * acceleration;
            float dz = v1[2] + v2[2] * acceleration;
    
            //float scale = 1.0 / float(num_steps);
            float scale = 0.1 / float(num_steps); // <<<<<<<<<<<<<<<<<<<<
    
            float x1 = test_point[0] - 0.5 * dx * scale;
            float y1 = test_point[1] - 0.5 * dy * scale;
            float z1 = test_point[2] - 0.5 * dz * scale;
            
            float x2 = test_point[0] + 0.5 * dx * scale;
            float y2 = test_point[1] + 0.5 * dy * scale;
            float z2 = test_point[2] + 0.5 * dz * scale;
  
  
            float AB = (dist(x1,y1,z1, x2,y2,z2) / scale - SpatialImpact_Wspd) / SpatialImpact_Wspd; 
        
            int point_prev = 0;
            int point_next = 0;
            
            {
              float[][] newVertex = {{x1, y1, z1, AB}};
              windFlow_Vertices = (float[][]) concat(windFlow_Vertices, newVertex);
              
              point_prev = windFlow_Vertices.length - 1;
            }      
        
  
            {
              float[][] newVertex = {{x2, y2, z2, AB}};
              windFlow_Vertices = (float[][]) concat(windFlow_Vertices, newVertex);
              
              point_next = windFlow_Vertices.length - 1;
            }      
        
            if ((point_prev != 0) && (point_next != 0)) {
              int[][] newU1Line = {{point_prev, point_next}};
              windFlow_Lines = (int[][]) concat(windFlow_Lines, newU1Line);
              
              point_prev = point_next; 
            }      
     
     
            test_point[0] = x2;       
            test_point[1] = y2;
            test_point[2] = z2;
          }

        }
        
      }
    }
  }  
  
  cursor(ARROW);  

  Display_windFlow = 1;                
  ROLLOUT_Update = 1;
  
}










float fn_dot2D (float x1, float y1, float x2, float y2) {
  return x1 * x2 + y1 * y2;
}

float[] SOLARCHVISION_2DtraceContour (int traceType, float epsilon, float x, float y, float z, float dx, float dy, float dz, float v) {

  float t_max = FLOAT_undefined;
  float t_min = FLOAT_undefined;
  float t_equ = 0; //FLOAT_undefined;  
  
  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;
  
  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = x + dx; //FLOAT_undefined;
  
  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = y + dy; //FLOAT_undefined;
  
  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = z + dz; //FLOAT_undefined;
  
  float min_dist = FLOAT_undefined;  
  
  float r = epsilon;
  
  float t = atan2_ang(dy, dx);

  //for (int test_t = -180; test_t < 180; test_t += 5) { 
  for (int test_t = -150; test_t <= 150; test_t += 5) { // <<<<

    float a = r * cos_ang(t + test_t);
    float b = r * sin_ang(t + test_t);
    float c = 0;
    
    if (SpatialImpact_sectionType == 1) {
      float Qx = a * cos_ang(-SpatialImpact_Rotation[SpatialImpact_sectionType]) - b * sin_ang(-SpatialImpact_Rotation[SpatialImpact_sectionType]);
      float Qy = -(a * sin_ang(-SpatialImpact_Rotation[SpatialImpact_sectionType]) + b * cos_ang(-SpatialImpact_Rotation[SpatialImpact_sectionType]));
      float Qz = c;
      
      a = Qx; b = Qy; c = Qz; 
    }
    else if (SpatialImpact_sectionType == 2) {
      float Qx = a * cos_ang(SpatialImpact_Rotation[SpatialImpact_sectionType]) - c * sin_ang(SpatialImpact_Rotation[SpatialImpact_sectionType]);
      float Qy = -(a * sin_ang(SpatialImpact_Rotation[SpatialImpact_sectionType]) + c * cos_ang(SpatialImpact_Rotation[SpatialImpact_sectionType]));
      float Qz = -b; 

      a = Qx; b = Qy; c = Qz; 
    }
    else if (SpatialImpact_sectionType == 3) {
      float Qx = a * cos_ang(90 - SpatialImpact_Rotation[SpatialImpact_sectionType]) - c * sin_ang(90 - SpatialImpact_Rotation[SpatialImpact_sectionType]);
      float Qy = -(a * sin_ang(90 - SpatialImpact_Rotation[SpatialImpact_sectionType]) + c * cos_ang(90 - SpatialImpact_Rotation[SpatialImpact_sectionType]));
      float Qz = -b; 

      a = Qx; b = Qy; c = Qz; 
    }
    
    float test_x = x + a;
    float test_y = y + b;
    float test_z = z + c;
    
    float test_v = ParametricGeometries_SpatialImpact_atXYZ(test_x, test_y, test_z);        
    
    if ((test_v < v_min) || (v_min > 0.9 * FLOAT_undefined)) {
      v_min = test_v;
      t_min = test_t;
      x_min = test_x;
      y_min = test_y;
      z_min = test_z;
    }
    if ((test_v > v_max) || (v_max > 0.9 * FLOAT_undefined))  {
      v_max = test_v;
      t_max = test_t;
      x_max = test_x;
      y_max = test_y;          
      z_max = test_z;
    }
    
    //if (((abs(test_v - v) < min_dist) && (fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0)) || (v_equ > 0.9 * FLOAT_undefined))  {
    if ((abs(test_v - v) < min_dist) || (v_equ > 0.9 * FLOAT_undefined))  {
      //if (fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0) {
      
        min_dist = abs(test_v - v);
        
        v_equ = test_v;
        t_equ = test_t;
        x_equ = test_x;
        y_equ = test_y;          
        z_equ = test_z;
      //}
    }
    
  }     


  float the_X = 0, the_Y = 0, the_Z = 0, the_T = 0;
  
  if (traceType == 0) {
    the_X = x_equ;
    the_Y = y_equ;
    the_Z = z_equ;
    the_T = t_equ;
  }
  if (traceType == -1) {
    the_X = x_min;
    the_Y = y_min;
    the_Z = z_min;
    the_T = t_min;
  }
  if (traceType == 1) {
    the_X = x_max;
    the_Y = y_max;
    the_Z = z_max;
    the_T = t_max;
  }
  
  float[] return_array = {the_X, the_Y, the_Z, cos_ang(t + the_T), sin_ang(t + the_T), 0};
  
  return return_array;
}


float[][] SOLARCHVISION_3DtraceContour (float epsilon, float x, float y, float z, float v) {
  
  float tz_max = FLOAT_undefined;
  float tz_min = FLOAT_undefined;
  float tz_equ = FLOAT_undefined;  

  float txy_max = FLOAT_undefined;
  float txy_min = FLOAT_undefined;
  float txy_equ = FLOAT_undefined;  
  
  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;
  
  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = FLOAT_undefined;
  
  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = FLOAT_undefined;
  
  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = FLOAT_undefined;
  
  float min_dist = FLOAT_undefined;  
  
  float r = epsilon;

  for (int test_tz = -90; test_tz <= 90; test_tz += 30) { // in the space 
  //for (int test_tz = 0; test_tz <= 0; test_tz += 30) { // on the surface! 
    
    float c = r * sin_ang(test_tz);
    
    for (int test_txy = -180; test_txy < 180; test_txy += 15) { 
  
      float a = r * cos_ang(test_tz) * cos_ang(test_txy);
      float b = r * cos_ang(test_tz) * sin_ang(test_txy);
      
      
      float test_x = x + a;
      float test_y = y + b;
      float test_z = z + c;
      
      float test_v = ParametricGeometries_SpatialImpact_atXYZ(test_x, test_y, test_z);        
      
      if ((test_v < v_min) || (v_min > 0.9 * FLOAT_undefined)) {
        v_min = test_v;
        tz_min = test_tz;
        txy_min = test_txy;
        x_min = test_x;
        y_min = test_y;
        z_min = test_z;
      }
      if ((test_v > v_max) || (v_max > 0.9 * FLOAT_undefined))  {
        v_max = test_v;
        tz_max = test_tz;
        txy_max = test_txy;
        x_max = test_x;
        y_max = test_y;          
        z_max = test_z;
      }
      
      if ((abs(test_v - v) < min_dist) || (v_equ > 0.9 * FLOAT_undefined))  {
        
        min_dist = abs(test_v - v);
        
        v_equ = test_v;
        tz_equ = test_tz;
        txy_equ = test_txy;
        x_equ = test_x;
        y_equ = test_y;          
        z_equ = test_z;
      }
      
    }     
  }

  float[][] return_array = {{x_min, y_min, z_min, v_min}, {x_equ, y_equ, z_equ, v_equ}, {x_max, y_max, z_max, v_max}};
  
  return return_array;
}





float[][] SpatialImpact_Contours_U1Vertices = {{0,0,0,0}}; // keeping SpatialImpact value at the 4th member
float[][] SpatialImpact_Contours_V1Vertices = {{0,0,0,0}}; // keeping SpatialImpact value at the 4th member
float[][] SpatialImpact_Contours_V2Vertices = {{0,0,0,0}}; // keeping SpatialImpact value at the 4th member
int[][] SpatialImpact_Contours_U1Lines = {{0,0}};
int[][] SpatialImpact_Contours_V1Lines = {{0,0}};
int[][] SpatialImpact_Contours_V2Lines = {{0,0}};

int PROCESS_subdivisions = 1; //1; // 0,1,2,3

float deltaSpatialImpact = 0.05;
float deltaSpatialImpactLines = 0.1 * deltaSpatialImpact;


void SOLARCHVISION_calculate_SpatialImpact_CurrentSection () {

  if (SpatialImpact_sectionType != 0) {

    cursor(WAIT);
  
    SpatialImpact_Contours_U1Vertices = new float [1][4];
    SpatialImpact_Contours_U1Vertices[0][0] = 0; 
    SpatialImpact_Contours_U1Vertices[0][1] = 0; 
    SpatialImpact_Contours_U1Vertices[0][2] = 0; 
    SpatialImpact_Contours_U1Vertices[0][3] = 0;   
    
    SpatialImpact_Contours_V1Vertices = new float [1][4];
    SpatialImpact_Contours_V1Vertices[0][0] = 0; 
    SpatialImpact_Contours_V1Vertices[0][1] = 0; 
    SpatialImpact_Contours_V1Vertices[0][2] = 0; 
    SpatialImpact_Contours_V1Vertices[0][3] = 0;
  
    SpatialImpact_Contours_V2Vertices = new float [1][4];
    SpatialImpact_Contours_V2Vertices[0][0] = 0; 
    SpatialImpact_Contours_V2Vertices[0][1] = 0; 
    SpatialImpact_Contours_V2Vertices[0][2] = 0; 
    SpatialImpact_Contours_V2Vertices[0][3] = 0;
  
    SpatialImpact_Contours_U1Lines = new int [1][2];
    SpatialImpact_Contours_U1Lines[0][0] = 0;
    SpatialImpact_Contours_U1Lines[0][1] = 0;
  
    SpatialImpact_Contours_V1Lines = new int [1][2];
    SpatialImpact_Contours_V1Lines[0][0] = 0;
    SpatialImpact_Contours_V1Lines[0][1] = 0;
  
    SpatialImpact_Contours_V2Lines = new int [1][2];
    SpatialImpact_Contours_V2Lines[0][0] = 0;
    SpatialImpact_Contours_V2Lines[0][1] = 0;  
  
  
    int PAL_TYPE = SPATIAL_Pallet_CLR; 
    int PAL_DIR = SPATIAL_Pallet_DIR;
    float PAL_Multiplier = SPATIAL_Pallet_MLT;     
    
    SpatialImpact_Image.loadPixels();

    float Section_offset_U = SpatialImpact_offset_U[SpatialImpact_sectionType];
    float Section_offset_V = SpatialImpact_offset_V[SpatialImpact_sectionType];
    float Section_Elevation = SpatialImpact_Elevation[SpatialImpact_sectionType];
    float Section_Rotation = SpatialImpact_Rotation[SpatialImpact_sectionType];
    float Section_scale_U = SpatialImpact_scale_U[SpatialImpact_sectionType];
    float Section_scale_V = SpatialImpact_scale_V[SpatialImpact_sectionType];

    int Section_Type = SpatialImpact_sectionType;
    int Section_RES1 = SpatialImpact_RES1;
    int Section_RES2 = SpatialImpact_RES2; 

    float[] SectionCorner_A = SOLARCHVISION_getCorners_Section(0, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
    float[] SectionCorner_B = SOLARCHVISION_getCorners_Section(1, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
    float[] SectionCorner_C = SOLARCHVISION_getCorners_Section(2, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
    float[] SectionCorner_D = SOLARCHVISION_getCorners_Section(3, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2); 
    
    for (int i = 0; i < SpatialImpact_RES1; i++) {
      for (int j = 0; j < SpatialImpact_RES2; j++) {
        
        float x = Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));
        float y = Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));
        float z = Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SpatialImpact_RES1), 1 - j / float(SpatialImpact_RES2));
      
        SpatialImpactType = 0;
        float val = ParametricGeometries_SpatialImpact_atXYZ(x, y, z);     
        
        float g =      roundTo(SpatialImpact_Grade * val, deltaSpatialImpact) - 0.5 * deltaSpatialImpact;
        float g_line = roundTo(SpatialImpact_Grade * val, deltaSpatialImpactLines);
        
        float _u = PAL_Multiplier * val + 0.5;
        
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;
        
        float[] _COL = GET_COLOR_STYLE(PAL_TYPE, _u);     
    
        if ((PROCESS_subdivisions == 1) || (PROCESS_subdivisions == 2)) {
          //if ((g == g_line) && (g != 0)) {
          if ((abs(g - g_line) < 0.001) && (g != 0)) {      
            _COL[0] = 0;    
            _COL[1] = 0;//255;
            _COL[2] = 0;//255;
            _COL[3] = 0;//255;
          }
        } 
        
        if ((PROCESS_subdivisions == 2) || (PROCESS_subdivisions == 3)) {
   
          if ((abs(g - g_line) < 0.0001) && (g != 0) && (g_line <= 1)) {
          //if ((g_line > 1 - deltaSpatialImpactLines) && (g_line <= 1)) { // not sure!
  
            float dx = 1;
            float dy = 0;
            float dz = 0;             
            
            float[] test_point_dir = {x, y, z, dx, dy, dz};
  
            SOLARCHVISION_trace_U1Line(test_point_dir, g_line, 100);
            
          }
        }
  
        SpatialImpact_Image.pixels[i + j * SpatialImpact_RES1] = color(_COL[1], _COL[2], _COL[3], _COL[0]);
        
      }
    }
   
    SpatialImpact_Image.updatePixels();
    
    if (SpatialImpact_record_JPG == 1) {
      String myFile = get_SpatialImpact_Filename() + ".jpg";
      SpatialImpact_Image.save(myFile);
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);        
    }    
  
  
  
    if ((PROCESS_subdivisions == 2) || (PROCESS_subdivisions == 3)) {
  /*    
      for (int k = 1; k < SpatialImpact_Contours_U1Vertices.length; k++) {  
  
        float x = SpatialImpact_Contours_U1Vertices[k][0];
        float y = SpatialImpact_Contours_U1Vertices[k][1];
        float z = SpatialImpact_Contours_U1Vertices[k][2];
        
        float val = SpatialImpact_Contours_U1Vertices[k][3]; //ParametricGeometries_SpatialImpact_atXYZ(x, y, z);
        
        float g =      roundTo(SpatialImpact_Grade * val, deltaSpatialImpact) - 0.5 * deltaSpatialImpact;
        float g_line = roundTo(SpatialImpact_Grade * val, deltaSpatialImpactLines);
  
        float dx = 1;
        float dy = 0;
        float dz = 0;   
  
        float[] test_point_dir = {x, y, z, dx, dy, dz}; 
  
        // making the first VVertex on the UVertice
        {
          float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SpatialImpact_Grade}};
          SpatialImpact_Contours_V1Vertices = (float[][]) concat(SpatialImpact_Contours_V1Vertices, newVertex);
        }      
        
        // making the first WVertex on the UVertice
        {
          float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SpatialImpact_Grade}};
          SpatialImpact_Contours_V2Vertices = (float[][]) concat(SpatialImpact_Contours_V2Vertices, newVertex);
        }      
        
  
        SOLARCHVISION_trace_V1Line(test_point_dir, g_line, 100);
      }
  */
  
  
    }
  
    if (SpatialImpact_record_PDF == 1) {
      
      String myFile = get_SpatialImpact_Filename() + ".pdf";
      
      PGraphics SpatialImpact_PDF = createGraphics(SpatialImpact_RES1, SpatialImpact_RES2, PDF, myFile);
      
      SpatialImpact_PDF.beginDraw();
      
      SpatialImpact_PDF.image(SpatialImpact_Image, 0, 0, SpatialImpact_RES1, SpatialImpact_RES2);
  
      if ((PROCESS_subdivisions == 2) || (PROCESS_subdivisions == 3)) {
        if (Display_SpatialImpact_Lines != 0) {
          
          for (int U_or_V_or_W = 0; U_or_V_or_W < 3; U_or_V_or_W++) {
      
            if (U_or_V_or_W == 0) {
              SpatialImpact_PDF.strokeWeight(0.25);
              SpatialImpact_PDF.stroke(255, 0, 0);
              SpatialImpact_PDF.fill(255, 0, 0);  
              } 
            if (U_or_V_or_W == 1) {
              SpatialImpact_PDF.strokeWeight(0.25);
              SpatialImpact_PDF.stroke(0, 255, 0);
              SpatialImpact_PDF.fill(0, 255, 0);  
            }
            if (U_or_V_or_W == 2) {
              SpatialImpact_PDF.strokeWeight(0.25);
              SpatialImpact_PDF.stroke(0, 0, 255);
              SpatialImpact_PDF.fill(0, 0, 255);  
            }
            
            int q_num = 0;
            if (U_or_V_or_W == 0) {
              q_num = SpatialImpact_Contours_U1Lines.length;
            } 
            if (U_or_V_or_W == 1) {
              q_num = SpatialImpact_Contours_V1Lines.length;
            }
            if (U_or_V_or_W == 2) {
              q_num = SpatialImpact_Contours_V2Lines.length;
            }
            
            for (int q = 1; q < q_num; q++) {
              
              float[] i = {0,0};
              float[] j = {0,0};
              
              for (int p = 0; p < 2; p++) {
              
                int n = 0;
                float x0 = 0, y0 = 0, z0 = 0;
                
                if (U_or_V_or_W == 0) {
                  n = SpatialImpact_Contours_U1Lines[q][p];
                  x0 = SpatialImpact_Contours_U1Vertices[n][0];
                  y0 = SpatialImpact_Contours_U1Vertices[n][1];
                  z0 = SpatialImpact_Contours_U1Vertices[n][2];                
                }
                if (U_or_V_or_W == 1) {
                  n = SpatialImpact_Contours_V1Lines[q][p];        
                  x0 = SpatialImpact_Contours_V1Vertices[n][0];
                  y0 = SpatialImpact_Contours_V1Vertices[n][1];
                  z0 = SpatialImpact_Contours_V1Vertices[n][2];
                }
                if (U_or_V_or_W == 2) {
                  n = SpatialImpact_Contours_V2Lines[q][p];        
                  x0 = SpatialImpact_Contours_V2Vertices[n][0];
                  y0 = SpatialImpact_Contours_V2Vertices[n][1];
                  z0 = SpatialImpact_Contours_V2Vertices[n][2];
                }
                
                float r = 0;
                
                if (SpatialImpact_sectionType == 1) {
                  r = -SpatialImpact_Rotation[SpatialImpact_sectionType];
                }
                else if (SpatialImpact_sectionType == 2) {
                  r = SpatialImpact_Rotation[SpatialImpact_sectionType];
                }
                else if (SpatialImpact_sectionType == 3) {
                  r = -SpatialImpact_Rotation[SpatialImpact_sectionType];              
                }     
                
                float x = x0 * cos_ang(r) - y0 * sin_ang(r);
                float y = x0 * sin_ang(r) + y0 * cos_ang(r);
                float z = z0;
            
                float a = 0;
                float b = 0;
                
                if (SpatialImpact_sectionType == 1) {
                  a = x;
                  b = -y;
                }
                else if (SpatialImpact_sectionType == 2) {
                  a = x;
                  b = -z;
                }
                else if (SpatialImpact_sectionType == 3) {
                  a = -y;
                  b = -z;
                }
               
                i[p] = SpatialImpact_RES1 * ((a - SpatialImpact_offset_U[SpatialImpact_sectionType]) / SpatialImpact_scale_U[SpatialImpact_sectionType] + 0.5);
                j[p] = SpatialImpact_RES2 * ((b + SpatialImpact_offset_V[SpatialImpact_sectionType]) / SpatialImpact_scale_V[SpatialImpact_sectionType] + 0.5); 
            
              }   
                  
              SpatialImpact_PDF.line(i[0], j[0], i[1], j[1]);
            }
          }
        }
        
        if (Display_SpatialImpact_Points != 0) {
          SpatialImpact_PDF.strokeWeight(0.5);
          SpatialImpact_PDF.stroke(255, 127, 0);
          SpatialImpact_PDF.noFill();  
          SpatialImpact_PDF.ellipseMode(CENTER);
          
          for (int n = 1; n < SpatialImpact_Contours_U1Vertices.length; n++) {
            
            float x0 = SpatialImpact_Contours_U1Vertices[n][0];
            float y0 = SpatialImpact_Contours_U1Vertices[n][1];
            float z0 = SpatialImpact_Contours_U1Vertices[n][2];
  
            float r = 0;
            
            if (SpatialImpact_sectionType == 1) {
              r = -SpatialImpact_Rotation[SpatialImpact_sectionType];
            }
            else if (SpatialImpact_sectionType == 2) {
              r = SpatialImpact_Rotation[SpatialImpact_sectionType];
            }
            else if (SpatialImpact_sectionType == 3) {
              r = -SpatialImpact_Rotation[SpatialImpact_sectionType];              
            }     
            
            float x = x0 * cos_ang(r) - y0 * sin_ang(r);
            float y = x0 * sin_ang(r) + y0 * cos_ang(r);
            float z = z0;
        
            float a = 0;
            float b = 0;
            
            if (SpatialImpact_sectionType == 1) {
              a = x;
              b = -y;
            }
            else if (SpatialImpact_sectionType == 2) {
              a = x;
              b = -z;
            }
            else if (SpatialImpact_sectionType == 3) {
              a = -y;
              b = -z;
            }
  
            float i = SpatialImpact_RES1 * ((a - SpatialImpact_offset_U[SpatialImpact_sectionType]) / SpatialImpact_scale_U[SpatialImpact_sectionType] + 0.5);
            float j = SpatialImpact_RES2 * ((b + SpatialImpact_offset_V[SpatialImpact_sectionType]) / SpatialImpact_scale_V[SpatialImpact_sectionType] + 0.5);
          
            SpatialImpact_PDF.ellipse(i, j, 1, 1);
          }
      
          SpatialImpact_PDF.strokeWeight(0);
      
        }
      }
  
    
      SpatialImpact_PDF.dispose();
      
      SpatialImpact_PDF.endDraw();
      
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);       
    }
  
    cursor(ARROW);
  }
}



void SOLARCHVISION_draw_SpatialImpact_lines () {

  if (Display_SpatialImpact_Lines != 0) {

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(255, 0, 0);
    WIN3D_Diagrams.fill(255, 0, 0);  

    for (int q = 1; q < SpatialImpact_Contours_U1Lines.length; q++) {
      
      int n1 = SpatialImpact_Contours_U1Lines[q][0];
      int n2 = SpatialImpact_Contours_U1Lines[q][1];
      
      float x1 = SpatialImpact_Contours_U1Vertices[n1][0];
      float y1 = SpatialImpact_Contours_U1Vertices[n1][1];
      float z1 = SpatialImpact_Contours_U1Vertices[n1][2];

      float x2 = SpatialImpact_Contours_U1Vertices[n2][0];
      float y2 = SpatialImpact_Contours_U1Vertices[n2][1];
      float z2 = SpatialImpact_Contours_U1Vertices[n2][2];
      
      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_scale3D, -y1 * OBJECTS_scale * WIN3D_scale3D, z1 * OBJECTS_scale * WIN3D_scale3D, x2 * OBJECTS_scale * WIN3D_scale3D, -y2 * OBJECTS_scale * WIN3D_scale3D, z2 * OBJECTS_scale * WIN3D_scale3D);
    }

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0, 255, 0);
    WIN3D_Diagrams.fill(0, 255, 0);  

    for (int q = 1; q < SpatialImpact_Contours_V1Lines.length; q++) {
      
      int n1 = SpatialImpact_Contours_V1Lines[q][0];
      int n2 = SpatialImpact_Contours_V1Lines[q][1];
      
      float x1 = SpatialImpact_Contours_V1Vertices[n1][0];
      float y1 = SpatialImpact_Contours_V1Vertices[n1][1];
      float z1 = SpatialImpact_Contours_V1Vertices[n1][2];

      float x2 = SpatialImpact_Contours_V1Vertices[n2][0];
      float y2 = SpatialImpact_Contours_V1Vertices[n2][1];
      float z2 = SpatialImpact_Contours_V1Vertices[n2][2];
      
      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_scale3D, -y1 * OBJECTS_scale * WIN3D_scale3D, z1 * OBJECTS_scale * WIN3D_scale3D, x2 * OBJECTS_scale * WIN3D_scale3D, -y2 * OBJECTS_scale * WIN3D_scale3D, z2 * OBJECTS_scale * WIN3D_scale3D);
    }

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(255, 0, 0);
    WIN3D_Diagrams.fill(255, 0, 0);  

    for (int q = 1; q < SpatialImpact_Contours_V2Lines.length; q++) {
      
      int n1 = SpatialImpact_Contours_V2Lines[q][0];
      int n2 = SpatialImpact_Contours_V2Lines[q][1];
      
      float x1 = SpatialImpact_Contours_V2Vertices[n1][0];
      float y1 = SpatialImpact_Contours_V2Vertices[n1][1];
      float z1 = SpatialImpact_Contours_V2Vertices[n1][2];

      float x2 = SpatialImpact_Contours_V2Vertices[n2][0];
      float y2 = SpatialImpact_Contours_V2Vertices[n2][1];
      float z2 = SpatialImpact_Contours_V2Vertices[n2][2];
      
      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_scale3D, -y1 * OBJECTS_scale * WIN3D_scale3D, z1 * OBJECTS_scale * WIN3D_scale3D, x2 * OBJECTS_scale * WIN3D_scale3D, -y2 * OBJECTS_scale * WIN3D_scale3D, z2 * OBJECTS_scale * WIN3D_scale3D);
    }

    WIN3D_Diagrams.strokeWeight(0);

  }
  
}

void SOLARCHVISION_draw_SpatialImpact_points () {
  if (Display_SpatialImpact_Points != 0) {

    WIN3D_Diagrams.strokeWeight(0);
    WIN3D_Diagrams.stroke(255, 127, 0);
    WIN3D_Diagrams.fill(255, 127, 0);  
    
    float R = 1; //0.2;
    
    for (int n = 1; n < SpatialImpact_Contours_U1Vertices.length; n++) {

      float x = SpatialImpact_Contours_U1Vertices[n][0];
      float y = SpatialImpact_Contours_U1Vertices[n][1];
      float z = SpatialImpact_Contours_U1Vertices[n][2];
      
      WIN3D_Diagrams.pushMatrix();
      WIN3D_Diagrams.translate(x * OBJECTS_scale * WIN3D_scale3D, -y * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D);
      WIN3D_Diagrams.sphere(R);
      WIN3D_Diagrams.popMatrix();
    }
    
  }
}

float MinimumDistance_traceU = 1.0;
float MinimumDistance_traceV = 0.25;

void SOLARCHVISION_trace_U1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = 0; 
  int point_next = 0;
  
  for (int n = 0; n < n_Tries; n++) {

    float[][] preVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SpatialImpact_Grade}};
    
    if (point_prev == 0) {
      float nearestPointDist = FLOAT_undefined;
      int nearestPointNum = 0;
      
      for (int q = 1; q < SpatialImpact_Contours_U1Vertices.length; q++) {
        //if (preVertex[0][3] == SpatialImpact_Contours_U1Vertices[q][3]) {
        if (preVertex[0][3] - SpatialImpact_Contours_U1Vertices[q][3] < 0.0001) {
          
          float d = dist(preVertex[0][0], preVertex[0][1], preVertex[0][2], SpatialImpact_Contours_U1Vertices[q][0], SpatialImpact_Contours_U1Vertices[q][1], SpatialImpact_Contours_U1Vertices[q][2]);
          
          if (nearestPointDist > d)  {
            nearestPointDist = d;
            nearestPointNum = q;
          }
        }
      }
      
      if (nearestPointDist < 0.5) {  //i.e. 0.5m 
        point_prev = nearestPointNum;
        
        test_point_dir[0] = SpatialImpact_Contours_U1Vertices[point_prev][0];
        test_point_dir[1] = SpatialImpact_Contours_U1Vertices[point_prev][1];
        test_point_dir[2] = SpatialImpact_Contours_U1Vertices[point_prev][2];
      }             
    } 

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(0, MinimumDistance_traceU, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SpatialImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SpatialImpact_Grade}};
    point_next = 0; 

    float nearestPointDist = FLOAT_undefined;
    int nearestPointNum = 0;

    int next_point_existed = 0;
    
    for (int q = 1; q < SpatialImpact_Contours_U1Vertices.length; q++) {
      //if (newVertex[0][3] == SpatialImpact_Contours_U1Vertices[q][3]) {
      if (abs(newVertex[0][3] - SpatialImpact_Contours_U1Vertices[q][3]) < 0.0001) {
        
        float d = dist(newVertex[0][0], newVertex[0][1], newVertex[0][2], SpatialImpact_Contours_U1Vertices[q][0], SpatialImpact_Contours_U1Vertices[q][1], SpatialImpact_Contours_U1Vertices[q][2]);

        if ((nearestPointDist > d) && (point_prev != q)) { 
          nearestPointDist = d;
          nearestPointNum = q;
        }
      }
    }
      
    if (nearestPointDist < MinimumDistance_traceU) {
      point_next = nearestPointNum;
      
      test_point_dir[0] = SpatialImpact_Contours_U1Vertices[point_next][0];
      test_point_dir[1] = SpatialImpact_Contours_U1Vertices[point_next][1];
      test_point_dir[2] = SpatialImpact_Contours_U1Vertices[point_next][2];

      next_point_existed = 1;        
    }

    
    if (point_next == 0) {
      
      SpatialImpact_Contours_U1Vertices = (float[][]) concat(SpatialImpact_Contours_U1Vertices, newVertex);              
      point_next = SpatialImpact_Contours_U1Vertices.length - 1;
    } 
        
    if ((point_prev != 0) && (point_next != 0)) {
        int[][] newU1Line = {{point_prev, point_next}};
        SpatialImpact_Contours_U1Lines = (int[][]) concat(SpatialImpact_Contours_U1Lines, newU1Line);
        
        point_prev = point_next; 
    }
    
    if (next_point_existed == 1) {
      break; // when reaching an existing line
    }     
   
  }
}

void SOLARCHVISION_trace_V1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = SpatialImpact_Contours_V1Vertices.length - 1; // the last added point
  int point_next = 0;
  
  for (int n = 0; n < n_Tries; n++) {

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(-1, MinimumDistance_traceV, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SpatialImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SpatialImpact_Grade}};

    point_next = 0;
    
    {
      SpatialImpact_Contours_V1Vertices = (float[][]) concat(SpatialImpact_Contours_V1Vertices, newVertex);              
      point_next = SpatialImpact_Contours_V1Vertices.length - 1;
    }
    
    if ((point_prev != 0) && (point_next != 0)) {
      int[][] newV1Line = {{point_prev, point_next}};
      SpatialImpact_Contours_V1Lines = (int[][]) concat(SpatialImpact_Contours_V1Lines, newV1Line);
      
      float val_new = ParametricGeometries_SpatialImpact_atXYZ(test_point_dir[0], test_point_dir[1], test_point_dir[2]);
      float g_new =      roundTo(SpatialImpact_Grade * val_new, deltaSpatialImpact) - 0.5 * deltaSpatialImpact;
      float g_line_new = roundTo(SpatialImpact_Grade * val_new, deltaSpatialImpactLines);
      
      if (g_line - g_line_new >= deltaSpatialImpact) {
        

        float nearestPointDist = FLOAT_undefined;
        int nearestPointNum = 0;
        
        for (int q = 1; q < SpatialImpact_Contours_U1Vertices.length; q++) {

          //if (abs(g_line_new / SpatialImpact_Grade - SpatialImpact_Contours_U1Vertices[q][3]) < 0.0001) {
          if (g_line - g_line_new < 2 * deltaSpatialImpact) {
            
            float d = dist(test_point_dir[0], test_point_dir[1], test_point_dir[2], SpatialImpact_Contours_U1Vertices[q][0], SpatialImpact_Contours_U1Vertices[q][1], SpatialImpact_Contours_U1Vertices[q][2]);
    
            if (nearestPointDist > d) { 
              nearestPointDist = d;
              nearestPointNum = q;
            }
          }
          
        }
        
        if (nearestPointDist < MinimumDistance_traceU) {
          
          int q = nearestPointNum;
          
          float[][] endVertex = {{SpatialImpact_Contours_U1Vertices[q][0], SpatialImpact_Contours_U1Vertices[q][1], SpatialImpact_Contours_U1Vertices[q][2], SpatialImpact_Contours_U1Vertices[q][3]}};
          SpatialImpact_Contours_V2Vertices = (float[][]) concat(SpatialImpact_Contours_V2Vertices, endVertex);
  
          int[][] newV2Line = {{SpatialImpact_Contours_V2Vertices.length - 2, SpatialImpact_Contours_V2Vertices.length - 1}}; // last two WVertices
          SpatialImpact_Contours_V2Lines = (int[][]) concat(SpatialImpact_Contours_V2Lines, newV2Line);      
        }
        
        
        break; // when reaching the area outside contour level
      }
      
       point_prev = point_next; 
    }
    
  }
}




float[][] skyVertices = {{0,0,0}};
int[][] skyFaces = {{0}};

int POINTER_skyVertices = 1;
int POINTER_skyFaces = 1;


float[][] TempObjectVertices = {{0,0,0}};
int[][] TempObjectFaces = {{0}};

int POINTER_TempObjectVertices = 1;
int POINTER_TempObjectFaces = 1;

void SOLARCHVISION_add_FractalSphere (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float r, int Tessellation, int isSky, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  int[] vT = new int [6];
  int[] vB = new int [6];
  
  vT[0] = SOLARCHVISION_addToTempObjectVertices(0,0,1);
  vB[0] = SOLARCHVISION_addToTempObjectVertices(0,0,-1);
  
  for (int i = 1; i <= 5; i++) {
    float q = i * 72 + t;
    
    float R_in = pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = pow(5.0, 0.5) * 1.0 / 5.0;
    
    vT[i] = SOLARCHVISION_addToTempObjectVertices(R_in * cos_ang(q), R_in * sin_ang(q), H_in);
    vB[i] = SOLARCHVISION_addToTempObjectVertices(R_in * cos_ang(q + 36), R_in * sin_ang(q + 36), -H_in);
  } 


  int BuildFaces = 0;

  for (int Loop_Tessellation = 1; Loop_Tessellation <= Tessellation; Loop_Tessellation++) { // added so that the tree generated from the bottom to the top!

    if (Loop_Tessellation == Tessellation) BuildFaces = 1;
    else BuildFaces = 0;

    for (int i = 1; i <= 5; i++) {
      
      int next_i = (i % 5) + 1;
      int prev_i = ((i + 5 - 2) % 5) + 1;
      
      {
        myLozenge(
                  TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2],
                  TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
                  TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2],
                  TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2],                  
                  Loop_Tessellation, BuildFaces);
      }
      
      {
        myLozenge(
                  TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2],
                  TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
                  TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
                  TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2],
                  Loop_Tessellation, BuildFaces);
      }      

      {
        myLozenge(
                  TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
                  TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
                  TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2],
                  TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],
                  Loop_Tessellation, BuildFaces);
      }     

      {
        myLozenge(
  
                  TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
                  TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],                    
                  TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2],
                  TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
              
                  Loop_Tessellation, BuildFaces);
      }

      {
        myLozenge(
                  TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],
                  TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2],
                  TempObjectVertices[vB[next_i]][0], TempObjectVertices[vB[next_i]][1], TempObjectVertices[vB[next_i]][2],
                  TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
                  
                  Loop_Tessellation, BuildFaces);
      }      

  
    }   

  }


  println("Vertices:", POINTER_TempObjectVertices);
  println("Faces:", POINTER_TempObjectFaces);

  if (isSky == 0) {
    SOLARCHVISION_addTempObjectToScene(m,tes,lyr,vsb,spv,cx,cy,cz,r,r,r,t);
  }
  else if (isSky == 1) {
    
     
    skyVertices = new float [1][3]; 
    skyFaces = new int [1][1];
    
    skyFaces[0][0] = 0;
    skyVertices[0][0] = 0;
    skyVertices[0][1] = 0;
    skyVertices[0][2] = 0;

    for (int i = 1; i < POINTER_TempObjectVertices; i++) {
      
      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];
      
      float[][] newVertex = {{x, y, z}}; 

      skyVertices = (float[][]) concat(skyVertices, newVertex);

    }
    
    for (int i = 1; i < POINTER_TempObjectFaces; i++) {
      
      int[][] newFace = {{TempObjectFaces[i][0], TempObjectFaces[i][1], TempObjectFaces[i][2], TempObjectFaces[i][3]}}; 

      skyFaces = (int[][]) concat(skyFaces, newFace);
    }
    
    POINTER_skyVertices = POINTER_TempObjectVertices;
    POINTER_skyFaces = POINTER_TempObjectFaces;    

    POINTER_TempObjectVertices = 1;
    POINTER_TempObjectFaces = 1;  
  }  
  else {
    // Nothing. In this case we should add temp object outside this function. See SuperSphere
  }
  
}  



void SOLARCHVISION_add_SuperSphere (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float px, float py, float pz, float sx, float sy, float sz, int Tessellation, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv; 
  
  SOLARCHVISION_add_FractalSphere(m, tes, lyr, vsb, spv, cx, cy, cz, 1, Tessellation, -1, 90); // passing with isSky:-1

  float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
  value = 1;
  posX = 0;
  posY = 0; 
  posZ = 0;    
  powX = px;
  powY = py;
  powZ = pz;    
  scaleX = 1;
  scaleY = 1; 
  scaleZ = 1;    

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float x = TempObjectVertices[i][0];
    float y = TempObjectVertices[i][1];
    float z = TempObjectVertices[i][2];

    float the_dist = (pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    if (the_dist != 0) {
      x /= the_dist;
      y /= the_dist;
      z /= the_dist;
    }

    TempObjectVertices[i][0] = x;
    TempObjectVertices[i][1] = y;
    TempObjectVertices[i][2] = z;
    
  }
  
  SOLARCHVISION_addTempObjectToScene(m,tes,lyr,vsb,spv,cx,cy,cz,sx,sy,sz,t);
}  


void SOLARCHVISION_add_SuperCylinder (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float sx, float sy, float sz, int n, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv; 
  
  int[] vT = new int [n];
  int[] vB = new int [n];

  vT[0] = SOLARCHVISION_addToTempObjectVertices(1, 0, 1);
  vB[0] = SOLARCHVISION_addToTempObjectVertices(1, 0, -1);
  
  int[] newFaceT = {vT[0]};
  int[] newFaceB = {vB[0]};
  for (int i = 1; i < n; i++) {
    float rot = i * 360.0 / float(n);
    
    vT[i] = SOLARCHVISION_addToTempObjectVertices(cos_ang(rot), sin_ang(rot), 1);
    vB[i] = SOLARCHVISION_addToTempObjectVertices(cos_ang(rot), sin_ang(rot), -1);
    int[] fT = {vT[i]};
    int[] fB = {vB[i]};
    
    newFaceT = concat(newFaceT, fT);
    newFaceB = concat(newFaceB, fB);
  } 
  
  SOLARCHVISION_addToTempObjectFaces(newFaceT, 0); // 0:check_duplicates
  SOLARCHVISION_addToTempObjectFaces(newFaceB, 0); // 0:check_duplicates  

  for (int i = 0; i < n; i++) {
    int next_i = (i + 1) % n;

    int[] newFace = {vT[i], vB[i], vB[next_i], vT[next_i]};
    
    SOLARCHVISION_addToTempObjectFaces(newFace, 0); // 0:check_duplicates
  }  
  
  float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
  value = 1;
  posX = 0;
  posY = 0; 
  posZ = 0;    
  scaleX = 1;
  scaleY = 1; 
  scaleZ = 1;    

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float x = TempObjectVertices[i][0];
    float y = TempObjectVertices[i][1];
    float z = TempObjectVertices[i][2];

    float the_dist = (pow((pow(abs(x - posX) / scaleX, 2) + pow(abs(y - posY) / scaleY, 2)), 0.5) / value);
    if (the_dist != 0) {
      x /= the_dist;
      y /= the_dist;
    }

    TempObjectVertices[i][0] = x;
    TempObjectVertices[i][1] = y;
    TempObjectVertices[i][2] = z;
    
  }
 
  SOLARCHVISION_addTempObjectToScene(m,tes,lyr,vsb,spv,cx,cy,cz,sx,sy,sz,t);  
}


int SOLARCHVISION_addToTempObjectVertices (float x, float y, float z) {

  float[][] newVertex = {{x, y, z}}; 
  
  int vertex_existed = 0;

  float min_dist = FLOAT_undefined;

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float the_dist = fn_dist(newVertex[0], TempObjectVertices[i]);
    
    if (the_dist < 0.1) { // avoid creating duplicate vertices - WELD is necessary for Fractal spheres!

      if (min_dist > the_dist) {
        min_dist = the_dist;
        vertex_existed = i;
      }
    }
  }

  if (vertex_existed == 0) { 

    if (POINTER_TempObjectVertices >= TempObjectVertices.length) {
      TempObjectVertices = (float[][]) concat(TempObjectVertices, newVertex);
    }
    else {
      //TempObjectVertices[POINTER_TempObjectVertices] = new int [3];
      
      TempObjectVertices[POINTER_TempObjectVertices][0] = x;
      TempObjectVertices[POINTER_TempObjectVertices][1] = y;
      TempObjectVertices[POINTER_TempObjectVertices][2] = z;
    }

    vertex_existed = POINTER_TempObjectVertices;

    POINTER_TempObjectVertices += 1;

  }

  return(vertex_existed);
}

int SOLARCHVISION_addToTempObjectFaces (int[] f, int check_duplicates) {

  int face_existed = 0;
  
  if (check_duplicates == 1) {
  
    for (int i = 1; i < POINTER_TempObjectFaces; i++) {
      if (f.length == TempObjectFaces[i].length) {
  
        for (int k = 0; k < f.length; k++) { // "k" introduces different variations that two faces could match
  
          for (int dir = -1; dir <= 1; dir += 2) { // "dir" introduces different diretions that two faces could match
  
            //println("\ndir=", dir);
            
            float total_distances = 0; 
            
            for (int j = 0; j < f.length; j++) {
  
              int q = (j * dir + k + f.length) % f.length;
  
              //print("q=", q, "; k=" );
            
              total_distances += fn_dist(TempObjectVertices[f[q]], TempObjectVertices[TempObjectFaces[i][j]]);
    
            }
  
            if (total_distances < 0.0001) { // avoid creating duplicate faces
              //println("A duplicate face detected :", i);
            
              face_existed = i;
              break;
            }   
  
          }
  
        }
        
      }
      if (face_existed != 0) break; 
    }
  }
  
  if (face_existed == 0) { 
    
    if (POINTER_TempObjectFaces >= TempObjectFaces.length) {
      int[][] newFace = {f}; 
      TempObjectFaces = (int[][]) concat(TempObjectFaces, newFace);
    }
    else {
      TempObjectFaces[POINTER_TempObjectFaces] = new int [f.length];
      
      for (int i = 0; i < f.length; i++) {
        TempObjectFaces[POINTER_TempObjectFaces][i] = f[i];
      }
    }

    face_existed = POINTER_TempObjectFaces;
    
    POINTER_TempObjectFaces += 1;    
    
  }
  
  return(face_existed);
  
}

void SOLARCHVISION_addTempObjectToScene (int m, int tes, int lyr, int vsb, int spv, float cx, float cy, float cz, float sx, float sy, float sz, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultSolarPivotType = spv;
  
  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;
  
  for (int i = 1; i < POINTER_TempObjectFaces; i++) {
    
    int[] new_vert_numbers = new int [TempObjectFaces[i].length];
    
    for (int j = 0; j < TempObjectFaces[i].length; j++) {

      float x0 = TempObjectVertices[TempObjectFaces[i][j]][0] * sx;
      float y0 = TempObjectVertices[TempObjectFaces[i][j]][1] * sy;
      float z0 = TempObjectVertices[TempObjectFaces[i][j]][2] * sz;
      
      float x = x0 * cos_ang(t) - y0 * sin_ang(t);
      float y = x0 * sin_ang(t) + y0 * cos_ang(t);
      float z = z0;
      
      new_vert_numbers[j] = SOLARCHVISION_addToVertices(x + cx, y + cy, z + cz);
    }
    
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));  
    SOLARCHVISION_addToFaces(new_vert_numbers);    
  }

  TempObjectVertices = new float [1][3];
  TempObjectVertices[0][0] = 0;
  TempObjectVertices[0][1] = 0;
  TempObjectVertices[0][2] = 0;
  
  TempObjectFaces = new int [1][1];
  TempObjectFaces[0][0] = 0;

  POINTER_TempObjectVertices = 1;
  POINTER_TempObjectFaces = 1;

}

void myLozenge (float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, int Tessellation, int BuildFaces) {
  

  if (Tessellation > 0) {
 
    if (Tessellation == 1) {

      int[] newPoly = new int [4];
      
      newPoly[0] = SOLARCHVISION_addToTempObjectVertices(x1,y1,z1);    
      newPoly[1] = SOLARCHVISION_addToTempObjectVertices(x2,y2,z2);
      newPoly[2] = SOLARCHVISION_addToTempObjectVertices(x3,y3,z3);
      newPoly[3] = SOLARCHVISION_addToTempObjectVertices(x4,y4,z4);
      
      if (BuildFaces != 0) {
        SOLARCHVISION_addToTempObjectFaces(newPoly, 1); // 1:check_duplicates
      }
      
      {
        // because the vertices might be welded to a nearest point:  
        
        x1 = TempObjectVertices[newPoly[0]][0];
        y1 = TempObjectVertices[newPoly[0]][1];
        z1 = TempObjectVertices[newPoly[0]][2];

        x2 = TempObjectVertices[newPoly[1]][0];
        y2 = TempObjectVertices[newPoly[1]][1];
        z2 = TempObjectVertices[newPoly[1]][2];
 
        x3 = TempObjectVertices[newPoly[2]][0];
        y3 = TempObjectVertices[newPoly[2]][1];
        z3 = TempObjectVertices[newPoly[2]][2];
 
        x4 = TempObjectVertices[newPoly[3]][0];
        y4 = TempObjectVertices[newPoly[3]][1];
        z4 = TempObjectVertices[newPoly[3]][2];
        
      }       
    }
   


    Tessellation -= 1;

    float[] M = {(x1 + x2 + x4) / 3.0, (y1 + y2 + y4) / 3.0, (z1 + z2 + z4) / 3.0};
    float[] N = {(x3 + x2 + x4) / 3.0, (y3 + y2 + y4) / 3.0, (z3 + z2 + z4) / 3.0};
    
    M = fn_normalize(M);
    N = fn_normalize(N);

    myLozenge(x2,y2,z2, N[0],N[1],N[2], x4,y4,z4, M[0],M[1],M[2], Tessellation, BuildFaces);     


    if (BuildFaces != 0) 
    {
      
      float[] P = M;
      
      PVector A_vec = new PVector(x1,y1,z1);
      PVector B_vec = new PVector(x2,y2,z2);
      
      PVector AxB_vec = A_vec.cross(B_vec);
      AxB_vec.normalize();
      
      float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
        
      float[] Q = {P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z};
      
      Q = fn_normalize(Q);
      
      myLozenge(x2,y2,z2, P[0],P[1],P[2], x1,y1,z1, Q[0],Q[1],Q[2], Tessellation, BuildFaces);
    }


    if (BuildFaces != 0) 
    {
      
      float[] P = N;
      
      PVector A_vec = new PVector(x3,y3,z3);
      PVector B_vec = new PVector(x4,y4,z4);
      
      PVector AxB_vec = A_vec.cross(B_vec);
      AxB_vec.normalize();
      
      float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
        
      float[] Q = {P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z};
      
      Q = fn_normalize(Q);
      
      myLozenge(x4,y4,z4, P[0],P[1],P[2], x3,y3,z3, Q[0],Q[1],Q[2], Tessellation, BuildFaces);
    }


  }

}

PVector fn_perpendicular (PVector M, PVector A, PVector B) {

  PVector AB = PVector.sub(B, A);
  PVector AM = PVector.sub(M, A);
  PVector HM = PVector.sub(AM, PVector.mult(AB, PVector.dot(AM, AB) / AB.magSq()));
  
  PVector H = PVector.sub(M, HM);
  
  return H;
}




float SolarAtSurface (float SunR1, float SunR2, float SunR3, float SunR4, float SunR5, float Alpha, float Beta, float THE_ALBEDO) {

  float return_value = FLOAT_undefined;

  if ((SunR1 < 0.9 * FLOAT_undefined) && (SunR2 < 0.9 * FLOAT_undefined) && (SunR3 < 0.9 * FLOAT_undefined) && (SunR4 < 0.9 * FLOAT_undefined) && (SunR5 < 0.9 * FLOAT_undefined)) { 

    float[] VECT = {0, 0, 0}; 

    if (abs(Alpha) > 89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = 1;      
    } else if (Alpha < -89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = -1;
    } else {
      VECT[0] = sin_ang(Beta);
      VECT[1] = -cos_ang(Beta);
      VECT[2] = tan_ang(Alpha);      
    }   
  
    VECT = fn_normalize(VECT);


    float[] SunV = {SunR1, SunR2, SunR3};
  
    float SunMask = fn_dot(fn_normalize(SunV), fn_normalize(VECT));
    if (SunMask <= 0) SunMask = 0; // removes backing faces 
    
    float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));
    
    return_value = (SunR4 * SunMask) + (SunR5 * SkyMask);    

    
/*
    float[] REF_SunV = {SunR1, SunR2, -SunR3};
  
    float REF_SunMask = fn_dot(fn_normalize(REF_SunV), fn_normalize(VECT));
    if (REF_SunMask <= 0) REF_SunMask = 0; // removes backing faces 
   
    float REF_SkyMask = 1 - (0.5 * (1.0 + (Alpha / 90.0)));      
    
    return_value +=  (0.01 * THE_ALBEDO) * ((SunR4 * REF_SunMask) + (SunR5 * REF_SkyMask));
*/

  }
  
  return (return_value);
}




float stp_slp;
float stp_dir;
int n_slp;  
int n_dir;

float[][][]LocationExposure;


int rebuild_SolarProjection_array = 1;
int rebuild_SolarImpact_Image_array = 1;
int rebuild_WindRose_Image_array = 1; 


void SOLARCHVISION_build_SolarProjection_array () {
  
  stp_slp = GlobeRES;
  stp_dir = GlobeRES;
  n_slp = int(roundTo(180.0 / (1.0 * stp_slp), 1)) + 1;  
  n_dir = int(roundTo(360.0 / (1.0 * stp_dir), 1));

  LocationExposure = new float [(1 + STUDY_j_end - STUDY_j_start)][n_slp][n_dir];

  for (int j = 0; j < LocationExposure.length; j += 1) {
    
    for (int a = 0; a < n_slp; a += 1) {
      for (int b = 0; b < n_dir; b += 1) {  
        LocationExposure[j][a][b] = FLOAT_undefined;
      }
    } 
  }
  
  rebuild_SolarProjection_array = 0;
}


void SOLARCHVISION_SolarProjection () {
  
  cursor(WAIT);
  
  if (rebuild_SolarProjection_array != 0) {
    SOLARCHVISION_build_SolarProjection_array();
  }
  
  float keep_per_day = per_day;
  int keep_num_add_days = num_add_days;
  if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
    per_day = 1;
    num_add_days = 1;
  }
  
  int start_z = get_startZ_endZ(impacts_source)[0];
  int end_z = get_startZ_endZ(impacts_source)[1]; 
  int layers_count = get_startZ_endZ(impacts_source)[2];   



  if (plot_impacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
  else Impact_TYPE = Impact_PASSIVE;



  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;
  
  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int l = impact_layer;

  float[][] TOTAL_valuesSUM_RAD = new float [1 + int(180 / stp_slp)][1 + int(360 / stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(180 / stp_slp)][1 + int(360 / stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(180 / stp_slp)][1 + int(360 / stp_dir)];
  int[][] TOTAL_valuesNUM = new int [1 + int(180 / stp_slp)][1 + int(360 / stp_dir)];

  for (int a = 0; a <= int(180 / stp_slp); a += 1) { 
    for (int b = 0; b < int(360 / stp_dir); b += 1) {
      TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      TOTAL_valuesNUM[a][b] = 0;
    }
  }
  
  for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) {

    now_j = (j * int(per_day) + BEGIN_DAY + 365) % 365;

    if (now_j >= 365) {
     now_j = now_j % 365; 
    }
    if (now_j < 0) {
     now_j = (now_j + 365) % 365; 
    }
 
    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

    float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
    float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

    int[] Normals_COL_N;
    Normals_COL_N = new int [9];
    Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

    for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
      if (nk != -1) {
        int k = int(nk / num_add_days);
        int j_ADD = nk % num_add_days; 

        for (int a = 0; a <= int(180 / stp_slp); a += 1) { 
          float Alpha = a * stp_slp - 90;
          for (int b = 0; b < int(360 / stp_dir); b += 1) {
            float Beta = b * stp_dir;
            
            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF_P = 0;
            float _valuesSUM_EFF_N = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i += 1) {
              if (isInHourlyRange(i) == 1) {
              
                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
  
                if (SunR[3] > 0) {
  
                  now_k = k;
                  now_i = i;
                  now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;
  
                  if (now_j >= 365) {
                   now_j = now_j % 365; 
                  }
                  if (now_j < 0) {
                   now_j = (now_j + 365) % 365; 
                  }
  
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                      Pa = CLIMATE_WY2[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_WY2[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_WY2[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_WY2[now_i][now_j][_difeffect][now_k]; 
                  }
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                      Pa = ENSEMBLE[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = ENSEMBLE[now_i][now_j][_difhorrad][now_k]; 
                      Pc = ENSEMBLE[now_i][now_j][_direffect][now_k]; 
                      Pd = ENSEMBLE[now_i][now_j][_difeffect][now_k]; 
                  }            
                  if (impacts_source == databaseNumber_OBSERVED) {
                      Pa = OBSERVED[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = OBSERVED[now_i][now_j][_difhorrad][now_k]; 
                      Pc = OBSERVED[now_i][now_j][_direffect][now_k]; 
                      Pd = OBSERVED[now_i][now_j][_difeffect][now_k]; 
                  }   
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {
                      Pa = CLIMATE_EPW[now_i][now_j][_dirnorrad][now_k]; 
                      Pb = CLIMATE_EPW[now_i][now_j][_difhorrad][now_k]; 
                      Pc = CLIMATE_EPW[now_i][now_j][_direffect][now_k]; 
                      Pd = CLIMATE_EPW[now_i][now_j][_difeffect][now_k]; 
                  }       
      
                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  }
                  else {
  
                    int drw_count = 0;
                    if (impacts_source == databaseNumber_CLIMATE_EPW) drw_count = SOLARCHVISION_filter("CLIMATE_EPW", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_CLIMATE_WY2) drw_count = SOLARCHVISION_filter("CLIMATE_WY2", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_ENSEMBLE) drw_count = SOLARCHVISION_filter("ENSEMBLE", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    if (impacts_source == databaseNumber_OBSERVED) drw_count = SOLARCHVISION_filter("OBSERVED", _cloudcover, filter_type, sky_scenario, now_i, now_j, now_k);
                    
                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;
                      
                      if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF_P = 0;
                        _valuesSUM_EFF_N = 0;
                        _valuesNUM = 0; 
                      }                             
                      else {
  
                        if (_values_E_dir < 0) {
                          _valuesSUM_EFF_N += -SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo); 
                        }
                        else {
                          _valuesSUM_EFF_P += SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo); 
                        }
  
                        _valuesSUM_RAD += SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 
                        
                        _valuesNUM += 1;
                        
                      }
                    }
                  }
                }
              }
            }
            
  
            if (_valuesNUM != 0) {
              //float _valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
              //float _valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
              float _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);
                                 
              _valuesSUM_RAD *= _valuesMUL;
              _valuesSUM_EFF_P *= _valuesMUL;
              _valuesSUM_EFF_N *= _valuesMUL;
              
              if (TOTAL_valuesNUM[a][b] == 0) {
                TOTAL_valuesSUM_RAD[a][b] = 0;
                TOTAL_valuesSUM_EFF_P[a][b] = 0;
                TOTAL_valuesSUM_EFF_N[a][b] = 0;
              }

              TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
              TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
              TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
              TOTAL_valuesNUM[a][b] += 1;
            }
            else {
              _valuesSUM_RAD = FLOAT_undefined;
              _valuesSUM_EFF_P = FLOAT_undefined;
              _valuesSUM_EFF_N = FLOAT_undefined;
            }
            
            
            float AVERAGE, PERCENTAGE, COMPARISON;
            
            AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
            if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

            if (_valuesSUM < 0.9 * FLOAT_undefined) {
              LocationExposure[j + 1][a][b] = _valuesSUM;        
            }

          }
        }
      }
    }
  }
  
  

  for (int a = 0; a <= int(180 / stp_slp); a += 1) { 
    float Alpha = a * stp_slp - 90;
    for (int b = 0; b < int(360 / stp_dir); b += 1) {
      float Beta = b * stp_dir;

      if (TOTAL_valuesNUM[a][b] != 0) {
        TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
      }
      else {
        TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      }

      float AVERAGE, PERCENTAGE, COMPARISON;
      
      AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
      if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
      else PERCENTAGE = 0.0;
      COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


      float _valuesSUM = FLOAT_undefined;
      if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD[a][b];
      if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

      if (_valuesSUM < 0.9 * FLOAT_undefined) {
        LocationExposure[0][a][b] = _valuesSUM;
      }
    }
  }


  keep_per_day = per_day;
  num_add_days = keep_num_add_days;
  
  cursor(ARROW);

}


void SOLARCHVISION_draw_logo (float cx, float cy, float cz, float cr, int the_view) {
  
  float stp_u = 1.0 / 12.0;
  float stp_v = 1.0 / 12.0;
  
  int n_a = 1;
  
  for (float a = -1; a < 1; a += stp_u) {
    
    n_a *= -1;
    
    int n_b = n_a;
    
    for (float b = -1; b < 1; b += stp_v) {
      
      n_b *= -1;

      float[][] newQuad = {{0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}};
      
      for (int i = 0; i < 4; i++) {
        
        float u = a;
        float v = b;
        
        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        //---------------------------------------
        float x0 = cos(u * PI); 
        float y0 = sin(u * PI) * cos(v * PI);
        float z0 = sin(v * PI);
        
        float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
        x0 /= d;  
        y0 /= d;  
        z0 /= d;  
        
        float x = x0;
        float y = y0;
        float z = z0;

        if (the_view == 0) { // corner view: logo
          float t = 0.25 * PI;
          newQuad[i][0] = x0 * cos(t) - z0 * sin(t);
          newQuad[i][1] = y0;   
          newQuad[i][2] = x0 * sin(t) + z0 * cos(t);
        }           
        else if (the_view == 1) { // front view
          newQuad[i][0] = x0;
          newQuad[i][1] = y0;   
          newQuad[i][2] = z0;
        }   
        else if (the_view == -1) { // top view
          newQuad[i][0] = x0;
          newQuad[i][1] = z0;   
          newQuad[i][2] = y0;
        }   

      }
      
      float x1 = cr * newQuad[0][0] + cx;
      float y1 = cr * newQuad[0][1] + cy;
      float z1 = cr * newQuad[0][2] + cz;

      float x2 = cr * newQuad[1][0] + cx;
      float y2 = cr * newQuad[1][1] + cy;
      float z2 = cr * newQuad[1][2] + cz;

      float x3 = cr * newQuad[2][0] + cx;
      float y3 = cr * newQuad[2][1] + cy;
      float z3 = cr * newQuad[2][2] + cz;

      float x4 = cr * newQuad[3][0] + cx;
      float y4 = cr * newQuad[3][1] + cy;
      float z4 = cr * newQuad[3][2] + cz;

      if (n_a * n_b == 1) {
        triangle(x1,y1, x2,y2, x3,y3);
        triangle(x3,y3, x4,y4, x1,y1);
      }
      else {
        triangle(x4,y4, x1,y1, x2,y2);
        triangle(x2,y2, x3,y3, x4,y4);
      }
      
    
    }
  }
}

int mouseWheelConsume = 0;

void mouseWheel(MouseEvent event) {

  if (frameCount > Last_initializationStep) {
  
    if (BAR_a_selected_parent == -1) {
    
      mouseWheelConsume += 1;
      if (mouseWheelConsume % 2 == 0) {
        mouseWheelConsume = 0;
      
        float Wheel_Value = event.getCount(); 
        
        if (automated == 0) {
          X_clicked = mouseX;
          Y_clicked = mouseY;
          
          {
            float displayBarHeight = MESSAGE_S_View;
            float displayBarWidth = 2 * w_pixel; 
        
            X_control = 0.5 * displayBarWidth;
            Y_control = a_pixel + b_pixel + 2 * h_pixel + 0.5 * BAR_d_tab;
            
            for (int i = 0; i < BAR_d_Items.length; i++) {
              
              float x1 = X_control - 0.366 * displayBarWidth;
              float x2 = X_control + 0.5 * displayBarWidth;
              float y1 = Y_control - 0.45 * displayBarHeight;
              float y2 = Y_control + 0.45 * displayBarHeight;
              
              if (BAR_d_Items[i][0].equals("Day")) {
        
                if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
                  
                  int keep_STUDY_i_start = STUDY_i_start;
                  int keep_STUDY_i_end = STUDY_i_end;
                  
                  if (Wheel_Value > 0) {
                    STUDY_i_start += 1; 
                    STUDY_i_end += 1;
                  } 
                  if (Wheel_Value < 0) {
                    STUDY_i_start -= 1; 
                    STUDY_i_end -= 1;
                  } 
                  
                  if (STUDY_i_start < 0) STUDY_i_start = 23;
                  if (STUDY_i_start > 23) STUDY_i_start = 0;
                  if (STUDY_i_end < 0) STUDY_i_end = 23;
                  if (STUDY_i_end > 23) STUDY_i_end = 0;
                  
                  if ((keep_STUDY_i_start != STUDY_i_start) || (keep_STUDY_i_end != STUDY_i_end)) {
                    //update_DevelopDATA = 1;
                    
                    ROLLOUT_Update = 1;
                    STUDY_Update = 1;
                    BAR_d_Update = 1;
                    
                    SOLARCHVISION_check_for_WIN3D_update();
                  }
                }
              }
              
              if (BAR_d_Items[i][0].equals("Year")) {
        
                if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
                  
                  int keep_num_add_days = num_add_days;
                  
                  if (Wheel_Value > 0) num_add_days += 2;
                  if (Wheel_Value < 0) num_add_days -= 2;
                  
                  if (num_add_days > 365 / STUDY_j_end) num_add_days = 365 / STUDY_j_end;
                  if (num_add_days < 1) num_add_days = 1;
                  
                  if (keep_num_add_days != num_add_days) {
                    //update_DevelopDATA = 1;
                  
                    ROLLOUT_Update = 1;
                    STUDY_Update = 1;
                    BAR_d_Update = 1;
                    
                    SOLARCHVISION_check_for_WIN3D_update();               
                  }        
                }        
              }
  
              if (BAR_d_Items[i][0].equals("Scenario")) {
        
                if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
  
                  if (impacts_source == databaseNumber_CLIMATE_WY2) {
                    int keep_Sample_Year_start = Sample_Year_start;
                    int keep_Sample_Year_end = Sample_Year_end;
                    
                    if (Wheel_Value > 0) {Sample_Year_start += 1; Sample_Year_end += 1;}
                    if (Wheel_Value < 0) {Sample_Year_start -= 1; Sample_Year_end -= 1;}
  
                    if (Sample_Year_end < Sample_Year_start) Sample_Year_end = Sample_Year_start;
                    if (Sample_Year_start > Sample_Year_end) Sample_Year_start = Sample_Year_end;
                    
                    if (Sample_Year_start < CLIMATE_WY2_start) Sample_Year_start = CLIMATE_WY2_start;
                    if (Sample_Year_start > CLIMATE_WY2_end) Sample_Year_start = CLIMATE_WY2_end;
                    if (Sample_Year_end < CLIMATE_WY2_start) Sample_Year_end = CLIMATE_WY2_start;
                    if (Sample_Year_end > CLIMATE_WY2_end) Sample_Year_end = CLIMATE_WY2_end;
  
                    if ((keep_Sample_Year_start != Sample_Year_start) || (keep_Sample_Year_end != Sample_Year_end)) {
                      
                      H_layer_option = -1; 
                      
                      //update_DevelopDATA = 1;
                    
                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      BAR_d_Update = 1;
                      
                      SOLARCHVISION_check_for_WIN3D_update();                                       
                    }     
                  }
  
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                    int keep_Sample_Member_start = Sample_Member_start;
                    int keep_Sample_Member_end = Sample_Member_end;
                    
                    if (Wheel_Value > 0) {Sample_Member_start += 1; Sample_Member_end += 1;}
                    if (Wheel_Value < 0) {Sample_Member_start -= 1; Sample_Member_end -= 1;}
  
                    if (Sample_Member_end < Sample_Member_start) Sample_Member_end = Sample_Member_start;
                    if (Sample_Member_start > Sample_Member_end) Sample_Member_start = Sample_Member_end; 
                    
                    if (Sample_Member_start < ENSEMBLE_start) Sample_Member_start = ENSEMBLE_start;
                    if (Sample_Member_start > ENSEMBLE_end) Sample_Member_start = ENSEMBLE_end;
                    if (Sample_Member_end < ENSEMBLE_start) Sample_Member_end = ENSEMBLE_start;
                    if (Sample_Member_end > ENSEMBLE_end) Sample_Member_end = ENSEMBLE_end;
  
                    if ((keep_Sample_Member_start != Sample_Member_start) || (keep_Sample_Member_end != Sample_Member_end)) {
                      
                      F_layer_option = -1; 
                      
                      //update_DevelopDATA = 1;
                    
                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      BAR_d_Update = 1;
                      
                      SOLARCHVISION_check_for_WIN3D_update();                                
                    }                      
                  }   
                  
                  if (impacts_source == databaseNumber_OBSERVED) {
                    int keep_Sample_Station_start = Sample_Station_start;
                    int keep_Sample_Station_end = Sample_Station_end;
                    
                    if (Wheel_Value > 0) {Sample_Station_start += 1; Sample_Station_end += 1;}
                    if (Wheel_Value < 0) {Sample_Station_start -= 1; Sample_Station_end -= 1;}
  
                    if (Sample_Station_end < Sample_Station_start) Sample_Station_end = Sample_Station_start;
                    if (Sample_Station_start > Sample_Station_end) Sample_Station_start = Sample_Station_end; 
                    
                    if (Sample_Station_start < OBSERVED_start) Sample_Station_start = OBSERVED_start;
                    if (Sample_Station_start > OBSERVED_end) Sample_Station_start = OBSERVED_end;
                    if (Sample_Station_end < OBSERVED_start) Sample_Station_end = OBSERVED_start;
                    if (Sample_Station_end > OBSERVED_end) Sample_Station_end = OBSERVED_end;
  
                    if ((keep_Sample_Station_start != Sample_Station_start) || (keep_Sample_Station_end != Sample_Station_end)) {
                      
                      O_layer_option = -1; 
                      
                      //update_DevelopDATA = 1;
                    
                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      BAR_d_Update = 1;
                      
                      SOLARCHVISION_check_for_WIN3D_update();                                     
                    }                      
                  }                
                }        
              }            
          
              
              Y_control += BAR_d_tab;
            }
          }
          
          
          if (WORLD_include == 1) {
            if (isInside(X_clicked, Y_clicked, WORLD_CX_View, WORLD_CY_View, WORLD_CX_View + WORLD_X_View, WORLD_CY_View + WORLD_Y_View) == 1) {
              
              int keep_WORLD_viewport_ZOOM = WORLD_viewport_ZOOM;
              
              if (Wheel_Value < 0) WORLD_viewport_ZOOM += 1;
              if (Wheel_Value > 0) WORLD_viewport_ZOOM -= 1;
              
              if (WORLD_viewport_ZOOM < 1) WORLD_viewport_ZOOM = 1;
              if (WORLD_viewport_ZOOM > 6) WORLD_viewport_ZOOM = 6;
              
              if (keep_WORLD_viewport_ZOOM != WORLD_viewport_ZOOM) {
                WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);
       
                WORLD_Update = 1;   
              }
            }
          }    
          
          if (WIN3D_include == 1) {
            if (isInside(X_clicked, Y_clicked, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
              
              float x0 = selected_Pivot_XYZ[0];
              float y0 = selected_Pivot_XYZ[1];
              float z0 = selected_Pivot_XYZ[2];
              
              if (Modify_Object_Parameters == 0) {
                if (View_Select_Create_Modify >= 4) { // other properties
        
                  int p = int(Wheel_Value);
                  
                  SOLARCHVISION_changeProperties_Selection(p);
                  
                  WIN3D_Update = 1;
                  
                }   
              }
              
              if (View_Select_Create_Modify == 3) { // rotate
      
                float r = (15 * Wheel_Value) * PI / 180.0;
                
                int the_Vector = selected_rotVector;
                
                SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);
                
                WIN3D_Update = 1;
                
              }   
              
              if (View_Select_Create_Modify == 2) { // scale
      
                float s = pow(pow(2.0, 0.25), Wheel_Value);
                
                float sx = s;
                float sy = s;
                float sz = s;
                
                int the_Vector = selected_scaleVector;
              
                if (the_Vector == 0) {sy = 1; sz = 1;}  
                if (the_Vector == 1) {sz = 1; sx = 1;}  
                if (the_Vector == 2) {sx = 1; sy = 1;}                    
                
                SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);
                
                WIN3D_Update = 1;
      
              }          
      
              if (View_Select_Create_Modify == 1) { // move
              
                float d = Wheel_Value;
      
                float dx = d;
                float dy = d;
                float dz = d;
                
                int the_Vector = selected_posVector;
              
                if (the_Vector == 0) {dy = 0; dz = 0;}  
                if (the_Vector == 1) {dz = 0; dx = 0;}  
                if (the_Vector == 2) {dx = 0; dy = 0;}  
      
                SOLARCHVISION_move_Selection(dx, dy, dz);
                
                WIN3D_Update = 1;
                
              }   
              /*             
              if (View_Select_Create_Modify == -1) { // PickSelect 
      
                if (Work_with_2D_or_3D == 1) {
      
                  if (allFractal_num > 0) {
                    
                    selectedFractal_numbers[selectedFractal_numbers.length - 1] += int(Wheel_Value);
                    
      
                    if (selectedFractal_numbers[selectedFractal_numbers.length - 1] < 0) {
                      selectedFractal_numbers[selectedFractal_numbers.length - 1] = allFractal_num - 1;
                    }
        
                    if (selectedFractal_numbers[selectedFractal_numbers.length - 1] > allFractal_num - 1) {
                      selectedFractal_numbers[selectedFractal_numbers.length - 1] = 0;
                    }
                  }
                  
                  //if (pre_selectedFractal_numbers_lastItem != selectedFractal_numbers[selectedFractal_numbers.length - 1]) { 
                    SOLARCHVISION_calculate_selection_Pivot();
                  //}
                  
                  WIN3D_Update = 1;
                }
              
                if (Work_with_2D_or_3D == 2) {
      
                  if (allObject2D_num > 0) {
                    
                    selectedObject2D_numbers[selectedObject2D_numbers.length - 1] += int(Wheel_Value);
                    
      
                    if (selectedObject2D_numbers[selectedObject2D_numbers.length - 1] < 0) {
                      selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = allObject2D_num - 1;
                    }
        
                    if (selectedObject2D_numbers[selectedObject2D_numbers.length - 1] > allObject2D_num - 1) {
                      selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = 0;
                    }
                  }
                  
                  //if (pre_selectedObject2D_numbers_lastItem != selectedObject2D_numbers[selectedObject2D_numbers.length - 1]) { 
                    SOLARCHVISION_calculate_selection_Pivot();
                  //}
                  
                  WIN3D_Update = 1;
                }
                
                if (Work_with_2D_or_3D == 3) {
      
                  selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] += int(Wheel_Value);
                  
                  if (selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] < 0) {
                    selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] = allPolymesh_Faces.length - 1;
                  }
      
                  if (selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] > allPolymesh_Faces.length - 1) {
                    selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1] = 0;
                  }
              
                  //if (pre_selectedPolymesh_numbers_lastItem != selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1]) { 
                    SOLARCHVISION_calculate_selection_Pivot();
                  //}
      
                  WIN3D_Update = 1;            
                }
                
                if (Work_with_2D_or_3D == 4) {
      
                  selectedFace_numbers[selectedFace_numbers.length - 1] += int(Wheel_Value);
                  
                  if (selectedFace_numbers[selectedFace_numbers.length - 1] < 0) {
                    selectedFace_numbers[selectedFace_numbers.length - 1] = allFaces.length - 1;
                  }
      
                  if (selectedFace_numbers[selectedFace_numbers.length - 1] > allFaces.length - 1) {
                    selectedFace_numbers[selectedFace_numbers.length - 1] = 0;
                  }
              
                  //if (pre_selectedFace_numbers_lastItem != selectedFace_numbers[selectedFace_numbers.length - 1]) { 
                    SOLARCHVISION_calculate_selection_Pivot();
                  //}
      
                  WIN3D_Update = 1;            
                }

                if (Work_with_2D_or_3D == 5) {
      
                  selectedVertex_numbers[selectedVertex_numbers.length - 1] += int(Wheel_Value);
                  
                  if (selectedVertex_numbers[selectedVertex_numbers.length - 1] < 0) {
                    selectedVertex_numbers[selectedVertex_numbers.length - 1] = allVertices.length - 1;
                  }
      
                  if (selectedVertex_numbers[selectedVertex_numbers.length - 1] > allVertices.length - 1) {
                    selectedVertex_numbers[selectedVertex_numbers.length - 1] = 0;
                  }
              
                  //if (pre_selectedVertex_numbers_lastItem != selectedVertex_numbers[selectedVertex_numbers.length - 1]) { 
                    SOLARCHVISION_calculate_selection_Pivot();
                  //}
      
                  WIN3D_Update = 1;            
                }
                                
              }
              */
              
              if ((View_Select_Create_Modify == -3) || (View_Select_Create_Modify == -10) || (View_Select_Create_Modify == -12) || (View_Select_Create_Modify == -14)) { // viewport:zoom
      
                if (WIN3D_View_Type == 1) {
                  WIN3D_Z_coordinate += Wheel_Value * WIN3D_S_coordinate * OBJECTS_scale; 
                } 
                else {
                  WIN3D_ZOOM_coordinate /= pow(2.0, Wheel_Value);
                }
                
                WIN3D_Update = 1;
      
              }
              
              if (View_Select_Create_Modify == -4) { // viewport:elevation
                
                if (Wheel_Value > 0) WIN3D_ZOOM_coordinate = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * WIN3D_ZOOM_coordinate)); 
                if (Wheel_Value < 0) WIN3D_ZOOM_coordinate = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * WIN3D_ZOOM_coordinate));
      
                WIN3D_Update = 1; 
      
              }  
              
              if (View_Select_Create_Modify == -5) { // viewport:3DModelSize
                
                if (Wheel_Value > 0) OBJECTS_scale *= pow(2.0, 0.25);
                if (Wheel_Value < 0) OBJECTS_scale /= pow(2.0, 0.25);
      
                WIN3D_Update = 1; 
      
              }          
      
              if (View_Select_Create_Modify == -6) { // viewport:different functions with wheel
      
                if (Modify_Object_Parameters == 0) { // Truck
      
                  if (View_XYZ_ChangeOption == 0) {
      
                    WIN3D_X_coordinate += Wheel_Value * WIN3D_S_coordinate * OBJECTS_scale;
                    
                    WIN3D_Update = 1;
                    
                  }
      
                  if (View_XYZ_ChangeOption == 1) {
      
                    WIN3D_Y_coordinate += Wheel_Value * WIN3D_S_coordinate * OBJECTS_scale;
                    
                    WIN3D_Update = 1;
                    
                  }            
               
                }
                
                
                if (Modify_Object_Parameters == 1) {  // Orbit
      
                  if (View_XYZ_ChangeOption == 0) {
      
                    WIN3D_RX_coordinate += Wheel_Value * WIN3D_RS_coordinate;
                    
                    WIN3D_Update = 1;
                    
                  }
      
                  if (View_XYZ_ChangeOption == 1) {
      
                    WIN3D_RZ_coordinate += Wheel_Value * WIN3D_RS_coordinate;
                    
                    WIN3D_Update = 1;
                    
                  }            
               
                }
                
                
                WIN3D_Update = 1; 
      
              }  
      
  
              if (View_Select_Create_Modify == -7) { // viewport:different functions with wheel
      
                if (Modify_Object_Parameters == 0) { // SkydomeSize
                
                  if (Wheel_Value > 0) SKY3D_scale *= pow(2.0, 0.25);              
                  if (Wheel_Value < 0) SKY3D_scale /= pow(2.0, 0.25);
                  
                  WIN3D_Update = 1;
  
                }
              }
  
              if (View_Select_Create_Modify == -8) { // viewport:different functions with wheel
      
                if (Modify_Object_Parameters == 0) { // AllModelSize
                
                  if (Wheel_Value > 0) {
                    OBJECTS_scale *= pow(2.0, 0.25);
                    SKY3D_scale *= pow(2.0, 0.25);
                  }              
  
                  if (Wheel_Value < 0) {
                    OBJECTS_scale /= pow(2.0, 0.25);
                    SKY3D_scale /= pow(2.0, 0.25);
                  }      
                    
                  WIN3D_Update = 1;
  
                }
              }    
              
              if (View_Select_Create_Modify == -9) { // viewport:TargetRollXY/TargetRoolZ
  
                if (View_XYZ_ChangeOption == 0) {   
                  WIN3D_RX_coordinate += Wheel_Value * WIN3D_RS_coordinate;
                  
                  SOLARCHVISION_reverseTransform_Camera(); 
                }
                
                if (View_XYZ_ChangeOption == 1) {   
                  WIN3D_RZ_coordinate += Wheel_Value * WIN3D_RS_coordinate;
                  
                  SOLARCHVISION_reverseTransform_Camera(); 
                }              
  
                WIN3D_Update = 1;
              }
              
              if (View_Select_Create_Modify == -11) { // viewport:CameraRollXY/CameraRoolZ
  
                if (View_XYZ_ChangeOption == 0) {   
  
                  SOLARCHVISION_rotateZ_Camera_around_Selection(Wheel_Value * WIN3D_RS_coordinate);
                }
                
                if (View_XYZ_ChangeOption == 1) {   
  
                  SOLARCHVISION_rotateXY_Camera_around_Selection(Wheel_Value * WIN3D_RS_coordinate);
                }    
  
                WIN3D_Update = 1;
      
              }            
              
              if (View_Select_Create_Modify == -13) { // viewport:CameraDistance
  
                SOLARCHVISION_move_Camera_towards_Selection(pow(2, -0.5 * Wheel_Value));
  
                WIN3D_Update = 1;
      
              }              
          
              if (View_Select_Create_Modify == -15) { // viewport:PanX
              
                WIN3D_X_coordinate += Wheel_Value * WIN3D_S_coordinate * OBJECTS_scale;
  
                WIN3D_Update = 1;
      
              }         
          
              if (View_Select_Create_Modify == -16) { // viewport:PanY
              
                WIN3D_Y_coordinate += Wheel_Value * WIN3D_S_coordinate * OBJECTS_scale;
  
                WIN3D_Update = 1;
      
              }      
              
              if (View_Select_Create_Modify == -17) { // viewport:DistMouseXY
              
                SOLARCHVISION_move_Camera_towards_Mouse(pow(2, -0.5 * Wheel_Value));
  
                WIN3D_Update = 1;
      
              }                
            }
          }   
        }
      }
    }
  }
}


int dragging_started = 0;

void mouseReleased () {
  
  if (frameCount > Last_initializationStep) {  

    if (automated == 0) {
      
      if (dragging_started != 0) {
        
        X_click2 = mouseX;
        Y_click2 = mouseY;
        
        int swap_tmp = 0;
        
        if (X_click2 < X_click1) {
          swap_tmp = X_click2;
          X_click2 = X_click1;
          X_click1 = swap_tmp;
        }
  
        if (Y_click2 < Y_click1) {
          swap_tmp = Y_click2;
          Y_click2 = Y_click1;
          Y_click1 = swap_tmp;
        }        
      
        if (FRAME_drag_JPG == 1) {
  
          SOLARCHVISION_RecordFrame();
          
          strokeWeight(2);
          if (mouseButton == RIGHT) {
            noStroke();
            fill(127,127);
          }          
          else{
            stroke(255,0,0);
            noFill();
          }          
          
          rect(X_click1, Y_click1, X_click2 - X_click1, Y_click2 - Y_click1);
          strokeWeight(0);
          
          SOLARCHVISION_RecordFrame();
          
          WORLD_Update = 1;
          WIN3D_Update = 1;  
          STUDY_Update = 1;
          ROLLOUT_Update = 1;
          BAR_a_Update = 1;
          BAR_b_Update = 1;
          BAR_d_Update = 1;          
          
          FRAME_drag_JPG = 0;
          
          dragging_started = 0;
        }      
        
        else {        
      
          if (WIN3D_include == 1) {
            if (isInside(mouseX, mouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
      
              if ((View_Select_Create_Modify == -2) || (View_Select_Create_Modify > 1)) { // RectSelect also if scale, rotate, modify, etc. where selected          
    
                float corner1x = X_click1 - 0.5 * WIN3D_X_View - WIN3D_CX_View;
                float corner1y = Y_click1 - 0.5 * WIN3D_Y_View - WIN3D_CY_View;
      
                float corner2x = X_click2 - 0.5 * WIN3D_X_View - WIN3D_CX_View;
                float corner2y = Y_click2 - 0.5 * WIN3D_Y_View - WIN3D_CY_View;
                
                pushMatrix();
              
                translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
                
                noFill();
                
                stroke(127); 
                strokeWeight(2);
                
                rect(corner1x, corner1y, corner2x - corner1x, corner2y - corner1y);
                
                popMatrix();            
      
                if (addNewSelectionToPreviousSelection == 0) SOLARCHVISION_deselectAll();

                if (Work_with_2D_or_3D == 8) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allSection_Faces.length; OBJ_NUM++) {
    
                    int break_loops = 0;
                    
                    int include_OBJ_in_newSelection = -1;    
    
                    if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                    if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
                    
                    int f = OBJ_NUM;
    
                    for (int j = 0; j < allSection_Faces[f].length; j++) {
                      
                      int vNo = allSection_Faces[f][j];
                      
                      float x = allSection_Vertices[vNo][0] * OBJECTS_scale;
                      float y = allSection_Vertices[vNo][1] * OBJECTS_scale;
                      float z = -allSection_Vertices[vNo][2] * OBJECTS_scale;
                      
                      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
    
                      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                          if (mouseButton == RIGHT) {
                            include_OBJ_in_newSelection = 1;
                            break_loops = 1;
                          }
                        }
                        else {
                          if (mouseButton == LEFT) {
                            include_OBJ_in_newSelection = 0;
                            break_loops = 1;
                          }                          
                        }
                        
                        if (break_loops == 1) break;
                      }
                      else {
                        if (mouseButton == LEFT) {
                          include_OBJ_in_newSelection = 0;
                          break_loops = 1;
                        }                          
                      }                  
                      
                      if (break_loops == 1) break;                  
                    }
    
                    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
                          if (selectedSection_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedSection_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedSection_numbers, found_at + 1);
                        
                        selectedSection_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedSection_numbers = (int[]) concat(selectedSection_numbers, new_OBJ_number);
                      }
                      
                    }
                  }
                }  
    
    
                if (Work_with_2D_or_3D == 1) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allFractal_Faces.length; OBJ_NUM++) {
    
                    int break_loops = 0;
                    
                    int include_OBJ_in_newSelection = -1;    
    
                    if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                    if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
                    
                    int f = OBJ_NUM;
    
                    for (int j = 0; j < allFractal_Faces[f].length; j++) {
                      
                      int vNo = allFractal_Faces[f][j];
                      
                      float x = allFractal_Vertices[vNo][0] * OBJECTS_scale;
                      float y = allFractal_Vertices[vNo][1] * OBJECTS_scale;
                      float z = -allFractal_Vertices[vNo][2] * OBJECTS_scale;
                      
                      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
    
                      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                          if (mouseButton == RIGHT) {
                            include_OBJ_in_newSelection = 1;
                            break_loops = 1;
                          }
                        }
                        else {
                          if (mouseButton == LEFT) {
                            include_OBJ_in_newSelection = 0;
                            break_loops = 1;
                          }                          
                        }
                        
                        if (break_loops == 1) break;
                      }
                      else {
                        if (mouseButton == LEFT) {
                          include_OBJ_in_newSelection = 0;
                          break_loops = 1;
                        }                          
                      }                  
                      
                      if (break_loops == 1) break;                  
                    }
    
                    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
                          if (selectedFractal_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedFractal_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedFractal_numbers, found_at + 1);
                        
                        selectedFractal_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedFractal_numbers = (int[]) concat(selectedFractal_numbers, new_OBJ_number);
                      }
                      
                    }
                  }
                }    
    
                if (Work_with_2D_or_3D == 2) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allObject2D_Faces.length; OBJ_NUM++) {
    
                    int break_loops = 0;
                    
                    int include_OBJ_in_newSelection = -1;    
    
                    if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                    if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
                    
                    int f = OBJ_NUM;
                    
                    for (int j = 0; j < allObject2D_Faces[f].length; j++) {
                      
                      int vNo = allObject2D_Faces[f][j];
                      
                      float x = allObject2D_Vertices[vNo][0] * OBJECTS_scale;
                      float y = allObject2D_Vertices[vNo][1] * OBJECTS_scale;
                      float z = -allObject2D_Vertices[vNo][2] * OBJECTS_scale;
                      
                      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
    
                      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                          if (mouseButton == RIGHT) {
                            include_OBJ_in_newSelection = 1;
                            break_loops = 1;
                          }
                        }
                        else {
                          if (mouseButton == LEFT) {
                            include_OBJ_in_newSelection = 0;
                            break_loops = 1;
                          }                          
                        }
                        
                        if (break_loops == 1) break;
                      }
                      else {
                        if (mouseButton == LEFT) {
                          include_OBJ_in_newSelection = 0;
                          break_loops = 1;
                        }                       
                      }
                      
                      if (break_loops == 1) break;              
                    }
                    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
                          if (selectedObject2D_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedObject2D_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedObject2D_numbers, found_at + 1);
                        
                        selectedObject2D_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedObject2D_numbers = (int[]) concat(selectedObject2D_numbers, new_OBJ_number);
                      }
                      
                    }                
                  }
                }    
                
                if (Work_with_2D_or_3D == 3) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allPolymesh_Faces.length; OBJ_NUM++) {
                    
                    int break_loops = 0;
                    
                    int include_OBJ_in_newSelection = -1;    
    
                    if (allPolymesh_Faces[OBJ_NUM][0] <= allPolymesh_Faces[OBJ_NUM][1]) {
                      
                      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
      
                      for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
                        if ((0 < f) && (f < allFaces.length)) { 
                    
                          for (int j = 0; j < allFaces[f].length; j++) {
                            int vNo = allFaces[f][j];
                
                            float x = allVertices[vNo][0] * OBJECTS_scale;
                            float y = allVertices[vNo][1] * OBJECTS_scale;            
                            float z = -allVertices[vNo][2] * OBJECTS_scale;
                            
                            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
      
                            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                              if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                                if (mouseButton == RIGHT) {
                                  include_OBJ_in_newSelection = 1;
                                  break_loops = 1;
                                }
                              }
                              else {
                                if (mouseButton == LEFT) {
                                  include_OBJ_in_newSelection = 0;
                                  break_loops = 1;
                                }                          
                              }
                            }
                            else {
                              if (mouseButton == LEFT) {
                                include_OBJ_in_newSelection = 0;
                                break_loops = 1;
                              }                          
                            }                        
                            
                            if (break_loops == 1) break;
                          }
                          
                          if (break_loops == 1) break;
                          
                        }
                      }
                    }
    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
                          if (selectedPolymesh_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedPolymesh_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedPolymesh_numbers, found_at + 1);
                        
                        selectedPolymesh_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedPolymesh_numbers = (int[]) concat(selectedPolymesh_numbers, new_OBJ_number);
                      }
                      
                    }                
                  }
          
                }
                
                
                if (Work_with_2D_or_3D == 4) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allFaces.length; OBJ_NUM++) {
                    
                    int break_loops = 0;
                    
                    int include_OBJ_in_newSelection = -1;    
                      
                    if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                    if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

                    for (int j = 0; j < allFaces[OBJ_NUM].length; j++) {
                      int vNo = allFaces[OBJ_NUM][j];
          
                      float x = allVertices[vNo][0] * OBJECTS_scale;
                      float y = allVertices[vNo][1] * OBJECTS_scale;            
                      float z = -allVertices[vNo][2] * OBJECTS_scale;
                      
                      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            

                      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                          if (mouseButton == RIGHT) {
                            include_OBJ_in_newSelection = 1;
                            break_loops = 1;
                          }
                        }
                        else {
                          if (mouseButton == LEFT) {
                            include_OBJ_in_newSelection = 0;
                            break_loops = 1;
                          }                          
                        }
                      }
                      else {
                        if (mouseButton == LEFT) {
                          include_OBJ_in_newSelection = 0;
                          break_loops = 1;
                        }                          
                      }                        
                      
                      if (break_loops == 1) break;
                    }


    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
                          if (selectedFace_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedFace_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedFace_numbers, found_at + 1);
                        
                        selectedFace_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedFace_numbers = (int[]) concat(selectedFace_numbers, new_OBJ_number);
                      }
                      
                    }                
                  }
                }                
                
                if (Work_with_2D_or_3D == 5) {
                  
                  for (int OBJ_NUM = 1; OBJ_NUM < allVertices.length; OBJ_NUM++) {
                    
                    int include_OBJ_in_newSelection = -1;    
                      
                    if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
                    if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
        
                    float x = allVertices[OBJ_NUM][0] * OBJECTS_scale;
                    float y = allVertices[OBJ_NUM][1] * OBJECTS_scale;            
                    float z = -allVertices[OBJ_NUM][2] * OBJECTS_scale;
                    
                    float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            

                    if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                      if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                        if (mouseButton == RIGHT) {
                          include_OBJ_in_newSelection = 1;
                        }
                      }
                      else {
                        if (mouseButton == LEFT) {
                          include_OBJ_in_newSelection = 0;
                        }                          
                      }
                    }
                    else {
                      if (mouseButton == LEFT) {
                        include_OBJ_in_newSelection = 0;
                      }                          
                    }                        

    
                    if (include_OBJ_in_newSelection == 1) {
    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
    
                        for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
                          if (selectedVertex_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedVertex_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedVertex_numbers, found_at + 1);
                        
                        selectedVertex_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedVertex_numbers = (int[]) concat(selectedVertex_numbers, new_OBJ_number);
                      }
                      
                    }                
                  }
                }             
                
                println("SOLARCHVISION_calculate_selection_Pivot 1");
                SOLARCHVISION_calculate_selection_Pivot();
                
                SOLARCHVISION_reset_selectedRefValues();  
                
    
    
    
                WIN3D_Update = 1;                        
              }
            }
          }
          
          dragging_started = 0;
        }
      }
    }
  }
  
}

void mouseDragged () {
  
  if (frameCount > Last_initializationStep) {
  
    if (automated == 0) {
        
      if (FRAME_drag_JPG == 1) {
        if (dragging_started == 0) {
          X_click1 = pmouseX;
          Y_click1 = pmouseY;

          dragging_started = 1;
        }
      }      
        
      else if (WIN3D_include == 1) {
        if (isInside(pmouseX, pmouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
          if (isInside(mouseX, mouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
  
            if (dragging_started == 0) {
              
              X_click1 = pmouseX;
              Y_click1 = pmouseY;
      
              dragging_started = 1;
            }
      
            float dx = (mouseX - pmouseX) / float(WIN3D_X_View);
            float dy = (mouseY - pmouseY) / float(WIN3D_Y_View);
  
            if ((View_Select_Create_Modify == -15) || (View_Select_Create_Modify == -16)) { // viewport
  
              if (mouseButton == LEFT) { // CameraRollXY
                
                SOLARCHVISION_rotateXY_Camera_around_Selection(10 * dx * WIN3D_RS_coordinate);
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // CameraRollZ
                
                SOLARCHVISION_rotateZ_Camera_around_Selection(10 * dy * WIN3D_RS_coordinate);
                
                WIN3D_Update = 1;
              }     
            } 
            
            if ((View_Select_Create_Modify == -14) || (View_Select_Create_Modify == -17)) { // viewport
  
              if (mouseButton == LEFT) { // pan
  
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                
                WIN3D_Update = 1;
              }      
            
              if (mouseButton == RIGHT) { // TargetRoll
  
                WIN3D_RZ_coordinate += 10 * dx * WIN3D_RS_coordinate; 
                WIN3D_RX_coordinate += 10 * dy * WIN3D_RS_coordinate;
                
                SOLARCHVISION_reverseTransform_Camera(); 
                
                WIN3D_Update = 1;
              }
  
            }            
            
            if ((View_Select_Create_Modify == -12) || (View_Select_Create_Modify == -13)) { // viewport
            
              if (mouseButton == LEFT) { // CameraRoll
  
                SOLARCHVISION_rotateXY_Camera_around_Selection(10 * dx * WIN3D_RS_coordinate);
                
                SOLARCHVISION_rotateZ_Camera_around_Selection(10 * dy * WIN3D_RS_coordinate);
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // pan
  
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                
                WIN3D_Update = 1;
              }          
    
            }  
            
            if (View_Select_Create_Modify == -11) { // viewport
            
              if (mouseButton == LEFT) { // CameraRollXY
                
                SOLARCHVISION_rotateXY_Camera_around_Selection(10 * dx * WIN3D_RS_coordinate);
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // CameraRollZ
                
                SOLARCHVISION_rotateZ_Camera_around_Selection(10 * dy * WIN3D_RS_coordinate);
                
                WIN3D_Update = 1;
              }          
  
            }            
  
            if (View_Select_Create_Modify == -10) { // viewport
            
              if (mouseButton == LEFT) { // TargetRoll
  
                WIN3D_RZ_coordinate += 10 * dx * WIN3D_RS_coordinate; 
                WIN3D_RX_coordinate += 10 * dy * WIN3D_RS_coordinate;
                
                SOLARCHVISION_reverseTransform_Camera(); 
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // pan
  
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                
                WIN3D_Update = 1;
              }          
    
            }  
            
            if (View_Select_Create_Modify == -9) { // viewport
            
              if (mouseButton == LEFT) { // TargetRollXY
  
                WIN3D_RZ_coordinate += 10 * dx * WIN3D_RS_coordinate; 
                
                SOLARCHVISION_reverseTransform_Camera(); 
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // TargetRollZ
  
                WIN3D_RX_coordinate += 10 * dy * WIN3D_RS_coordinate;
                
                SOLARCHVISION_reverseTransform_Camera(); 
                
                WIN3D_Update = 1;
              }          
    
            }            
           
            if ((View_Select_Create_Modify == -3) || (View_Select_Create_Modify == -7) || (View_Select_Create_Modify == -8)) { // viewport
            
              if (mouseButton == LEFT) { // orbit
      
                WIN3D_RZ_coordinate -= 10 * dx * WIN3D_RS_coordinate; 
                WIN3D_RX_coordinate -= 10 * dy * WIN3D_RS_coordinate;
                
                WIN3D_Update = 1;
              }
              
              if (mouseButton == RIGHT) { // pan
  
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                
                WIN3D_Update = 1;
              }       
    
            }  
            
            if (View_Select_Create_Modify == -4) { 
  
              if (mouseButton == LEFT) { // move Y
    
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale;  
                
                WIN3D_Update = 1;    
              }              
              
              if (mouseButton == RIGHT) { // move X
    
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                
                WIN3D_Update = 1;    
              }    
  
            }
  
            if (View_Select_Create_Modify == -5) { // viewport
  
              if (mouseButton == LEFT) { // pan
            
                WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                
                WIN3D_Update = 1;
              }   
            
              if (mouseButton == RIGHT) { // TargetRoll
  
                WIN3D_RZ_coordinate += 10 * dx * WIN3D_RS_coordinate; 
                WIN3D_RX_coordinate += 10 * dy * WIN3D_RS_coordinate;
                
                SOLARCHVISION_reverseTransform_Camera(); 
                
                WIN3D_Update = 1;
              }
    
            }
  
            if (View_Select_Create_Modify == -6) { // viewport:different functions
    
              if (Modify_Object_Parameters == 0) { // Truck
  
                if (View_XYZ_ChangeOption == 0) {
                  if (mouseButton == LEFT) WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                  if (mouseButton == RIGHT) WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                  WIN3D_Update = 1;  
                }
    
                if (View_XYZ_ChangeOption == 1) {
                  if (mouseButton == RIGHT) WIN3D_X_coordinate += 100 * dx * WIN3D_S_coordinate * OBJECTS_scale;  
                  if (mouseButton == LEFT) WIN3D_Y_coordinate += 100 * dy * WIN3D_S_coordinate * OBJECTS_scale; 
                  WIN3D_Update = 1; 
                }            
             
              }
              
              
              if (Modify_Object_Parameters == 1) {  // Orbit
    
                if (View_XYZ_ChangeOption == 0) {
                  if (mouseButton == LEFT) WIN3D_RX_coordinate -= 10 * dy * WIN3D_RS_coordinate;
                  if (mouseButton == RIGHT) WIN3D_RZ_coordinate -= 10 * dx * WIN3D_RS_coordinate;
                  WIN3D_Update = 1;
                }
    
                if (View_XYZ_ChangeOption == 1) {
                  if (mouseButton == RIGHT) WIN3D_RX_coordinate -= 10 * dy * WIN3D_RS_coordinate;
                  if (mouseButton == LEFT) WIN3D_RZ_coordinate -= 10 * dx * WIN3D_RS_coordinate;
                  WIN3D_Update = 1;
  
                }            
             
              }
              
              
              WIN3D_Update = 1; 
    
            }  
          }
        }
      }  
    } 
  }     
}


void SOLARCHVISION_update_Project_info (File selectedFile) {

  ProjectName = selectedFile.getName().replace(".xml", "").replace(".XML", "").replace(".Xml", ""); // should work most of the times!
  ProjectsFolder =  selectedFile.getAbsolutePath().replace(char(92), '/').replace("/" + selectedFile.getName(), "");
  
  println("New ProjectName:", ProjectName);
  println("New ProjectsFolder:", ProjectsFolder);
 
}

void SOLARCHVISION_fileSelected_New (File selectedFile) {

  String Filename = "";
  
  if (selectedFile == null) {
  } 
  else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');
    
    println("New project:", Filename);
    
    SOLARCHVISION_update_Project_info(selectedFile);
  }
  
}

void SOLARCHVISION_fileSelected_Open (File selectedFile) {

  String Filename = "";
  
  if (selectedFile == null) {
  } 
  else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');
    
    println("Loading:", Filename);
    
    SOLARCHVISION_load_project(Filename);
    
    SOLARCHVISION_update_Project_info(selectedFile);   

  }
  
} 


void SOLARCHVISION_fileSelected_SaveAs (File selectedFile) {

  String Filename = "";
  
  if (selectedFile == null) {
  } 
  else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');
    
    println("Saving to:", Filename);
    
    SOLARCHVISION_save_project(Filename, Display_Output_in_Explorer);
    
    SOLARCHVISION_update_Project_info(selectedFile);   
 
  }
  
}     



void SOLARCHVISION_SelectFile_Import_3DModel (File selectedFile) {

  String Filename = "";
  
  if (selectedFile == null) {
  } 
  else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');
    
    println("Importing:", Filename);
    
    int NUM_allPolymesh_Faces_Before = allPolymesh_Faces.length;
    
    //SOLARCHVISION_import_objects(Filename, -1,0,0,1,1, 0,0,0, 1,1,1); // different objects: different materials
    SOLARCHVISION_import_objects(Filename, Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, 0,0,0, 1,1,1); // apply default material
    
    int NUM_allPolymesh_Faces_After = allPolymesh_Faces.length;
    
    selectedPolymesh_numbers = new int [1 + NUM_allPolymesh_Faces_After - NUM_allPolymesh_Faces_Before];
    for (int i = 0; i < selectedPolymesh_numbers.length - 1; i++) { 
      selectedPolymesh_numbers[i] = i + NUM_allPolymesh_Faces_Before;
      //println(selectedPolymesh_numbers[i]);
    }

    Work_with_2D_or_3D = 3;
    
    SOLARCHVISION_calculate_selection_Pivot();

    WIN3D_Update = 1;
  }

}     



void mouseClicked () {
  
  if (frameCount > Last_initializationStep) {
  
    if (automated == 0) {

      if (FRAME_click_JPG == 1) {

        SOLARCHVISION_RecordFrame();

        dessin_Mouse(1, mouseX, mouseY, 2 * MESSAGE_S_View);        

        SOLARCHVISION_RecordFrame();
/*        
        WORLD_Update = 1;
        WIN3D_Update = 1;  
        STUDY_Update = 1;
        ROLLOUT_Update = 1;
        BAR_a_Update = 1;
        BAR_b_Update = 1;
        BAR_d_Update = 1;          
        
        FRAME_click_JPG = 0;
*/        
      }    
      
      
      if ((BAR_a_selected_parent != -1) && (isInside(mouseX, mouseY, 0, 0, width, a_pixel) == 0)) {
         
        if (mouseButton == LEFT) {
          if (BAR_a_selected_child != 0) {
    
            // should call the functions here!
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Mojtaba Samimi")) { 
              link("http://solarchvision.com/?page_id=102");
            }     
           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("www.solarchvision.com")) { 
              link("http://solarchvision.com/");
            }     

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("New")) { 
              selectInput("Specify project name:", "SOLARCHVISION_fileSelected_New");

              SOLARCHVISION_remove_All();


              //SOLARCHVISION_update_station(0);

            }  

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Save")) { 
              SOLARCHVISION_save_project(ProjectsFolder + "/" + ProjectName + ".xml", 0);   
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hold")) {
              HoldStamp = nf(millis(), 0);
              int pre_Display_Output_in_Explorer = Display_Output_in_Explorer;
              
              SOLARCHVISION_save_project(ProjectsFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml", 0);
            }            

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Fetch")) {
              try {
                SOLARCHVISION_load_project(ProjectsFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml");
              }
              catch (Exception e) {
                println("Cannot find hold file!");
              }
            } 
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Undo")) {
              
              undo_pointer += 1;
              
              if (undo_pointer < undo_stack.length) {
                
                String undo_file = undo_stack[undo_pointer];
                
                {
                  String[] new_Item = {undo_file};
                  
                  redo_stack = (String[]) concat(new_Item, redo_stack);
                }
                
                {
                  String[] startList = (String[]) subset(undo_stack, 0, undo_pointer);
                  String[] endList = (String[]) subset(undo_stack, undo_pointer + 1);
                  
                  undo_stack = (String[]) concat(startList, endList);
                }

                try {
                  SOLARCHVISION_load_project(undo_file);
                }
                catch (Exception e) {
                  println("Cannot find undo file!");
                }
              }
              else { 
                undo_pointer = undo_stack.length - 1;
              }
            }             
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Open...")) { 
              selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
            }          

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Save As...")) { 
              selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Import 3D-Model...")) { 
              selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
            }   
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Export 3D-Model")) {
              SOLARCHVISION_export_objects(); 
            }    

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Quit")) { 
              exit();
            }      
  
  
     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Wind pattern (active)")) {
              plot_impacts = -2;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 1;
              ROLLOUT_Update = 1;               
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Wind pattern (passive)")) {
              plot_impacts = -1;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 1;
              ROLLOUT_Update = 1;               
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Urban solar potential (active)")) {
              plot_impacts = 0;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;              
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Urban solar potential (passive)")) {
              plot_impacts = 1;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Orientation potential (active)")) {
              plot_impacts = 2;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Orientation potential (passive)")) {
              plot_impacts = 3;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hourly sun position (active)")) {
              plot_impacts = 4;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hourly sun position (passive)")) {
              plot_impacts = 5;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("View from sun & sky (active)")) {
              plot_impacts = 6;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("View from sun & sky (passive)")) {
              plot_impacts = 7;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                            
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Annual cycle sun path (active)")) {
              plot_impacts = 8;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;        
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Annual cycle sun path (passive)")) {
              plot_impacts = 9;
              STUDY_setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRose_Image = 0;
              ROLLOUT_Update = 1;                                        
            }  
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pre-bake Selected Sections")) {
              SOLARCHVISION_render_Shadows_selectedSections();              
              WIN3D_Update = 1;                         
            }         
       
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Process Active Impact")) {
              plot_impacts = 0;         
              SOLARCHVISION_calculate_SolarImpact_selectedSections();              
              WIN3D_Update = 1;                         
            }   
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Process Passive Impact")) {
              plot_impacts = 1;         
              SOLARCHVISION_calculate_SolarImpact_selectedSections();              
              WIN3D_Update = 1;                         
            }               

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Process Spatial Impact")) {
              SOLARCHVISION_calculate_SpatialImpact_selectedSections();              
              WIN3D_Update = 1;                         
            }  

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Run wind 3D-model")) {
              SOLARCHVISION_calculate_windFlow();              
              WIN3D_Update = 1;                         
            }  

            for (int n = -2; n <= 14; n++) { 
              if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Layout " + nf(n, 0))) {
                
                STUDY_setup = n;
                STUDY_Update = 1;
                
                if (STUDY_setup == 14) {
                }
                else {  
                  
                  if (frame_variation != 2) {
                    frame_variation = 2;
                    SOLARCHVISION_update_frame_layout();
                  }
                }
              }
            }
       
            


            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Stop REC.")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   
              
              ROLLOUT_Update = 1;            
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("REC. Time Graph")) { 
              STUDY_record_AUTO = 1;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   
              
              ROLLOUT_Update = 1;  
            } 

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("REC. Location Graph")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 1;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   
              
              ROLLOUT_Update = 1;  
            } 

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("REC. Spatial Graph")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 1;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   
              
              ROLLOUT_Update = 1;  
            } 
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("REC. Screenshot")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 1;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   
              
              ROLLOUT_Update = 1;  
            }             
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PDF Time Graph")) { 
              STUDY_record_PDF = 1;
              STUDY_Update = 1;
            }   
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("JPG Time Graph")) { 
              STUDY_record_JPG = 1;
              STUDY_Update = 1;
            }   
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("JPG Location Graph")) { 
              WORLD_record_JPG = 1;
              WORLD_Update = 1;
            } 
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PDF Location Graph")) { 
              WORLD_record_PDF = 1;
              WORLD_Update = 1;
            }   
    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("JPG Spatial Graph")) { 
              WIN3D_record_JPG = 1;
              WIN3D_Update = 1;
            } 
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Screenshot")) { 
              FRAME_record_JPG = 1;
            }             
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Screenshot+Click")) { 
              FRAME_click_JPG = 1;
            }           
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Screenshot+Drag")) { 
              FRAME_drag_JPG = 1;
            }                
            
            if (BAR_a_Items[BAR_a_selected_parent][0].equals("Site")) {
              if (BAR_a_selected_child > 0) {
                if (STATION_NUMBER != BAR_a_selected_child - 1) {
                  
                  STATION_NUMBER = BAR_a_selected_child - 1;
                  
                  SOLARCHVISION_update_station(0);
                }
              } 
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][0].equals("Layer")) {
              if (BAR_a_selected_child > 0) {
                if (STUDY_drw_Layer != BAR_a_selected_child - 1) {
                  
                  if (BAR_a_selected_child < num_layers) {
                  
                    STUDY_drw_Layer = BAR_a_selected_child - 1;
                    
                    develop_Layer = STUDY_drw_Layer;
                    
                    STUDY_Update = 1;  
                    
                  }
                  else {

                    if ((develop_option == DEV_OP_6) || (develop_option == DEV_OP_7) || (develop_option == DEV_OP_8)) {
                      
                      if (STUDY_drw_Layer == develop_Layer) {
                    
                        STUDY_drw_Layer = _developed; 
                      }
                      
                      develop_option = BAR_a_selected_child - num_layers;
                      
                      SOLARCHVISION_DevelopDATA(impacts_source);   
 
                      STUDY_Update = 1;                          
                    }   
                    else {
                      
                      develop_Layer = STUDY_drw_Layer;
                    
                      STUDY_drw_Layer = _developed; 
                      
                      develop_option = BAR_a_selected_child - num_layers;
                      
                      SOLARCHVISION_DevelopDATA(impacts_source);   
 
                      STUDY_Update = 1;                       
                    }                    
                    
                  }
                }
              } 
            }            
  
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Typical Year (TMY)")) {
              impacts_source = databaseNumber_CLIMATE_EPW;
              
              if (Load_CLIMATE_EPW == 0) {
                Load_CLIMATE_EPW = 1;
                SOLARCHVISION_try_update_CLIMATE_EPW();
              }
             
              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              BAR_d_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Long-term (CWEEDS)")) {
              impacts_source = databaseNumber_CLIMATE_WY2;
              
              if (Load_CLIMATE_WY2 == 0) {
                Load_CLIMATE_WY2 = 1;
                SOLARCHVISION_try_update_CLIMATE_WY2();
              }
             
              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              BAR_d_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Weather Forecast (NAEFS)")) {
              impacts_source = databaseNumber_ENSEMBLE;
              
              if (Load_ENSEMBLE == 0) {
                Load_ENSEMBLE = 1;
                SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
              }
             
              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              BAR_d_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Real-time Observed (SWOB)")) {
              impacts_source = databaseNumber_OBSERVED;
              
              if (Load_OBSERVED == 0) {
                Load_OBSERVED = 1;
                SOLARCHVISION_try_update_OBSERVED();
              }
              
              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              BAR_d_Update = 1;
            }           

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Surface Wire")) {
              WIN3D_FACES_SHADE = Shade_Surface_Wire;
              Display_MODEL3D_EDGES = 1; //<<<<<<<<<<<<<<<
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }       
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Surface Base")) {
              WIN3D_FACES_SHADE = Shade_Surface_Base;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Surface White")) {
              WIN3D_FACES_SHADE = Shade_Surface_White;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Surface Materials")) {
              WIN3D_FACES_SHADE = Shade_Surface_Materials;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Global Solar")) {
              WIN3D_FACES_SHADE = Shade_Global_Solar;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Vertex Solar")) {
              WIN3D_FACES_SHADE = Shade_Vertex_Solar;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Vertex Spatial")) {
              WIN3D_FACES_SHADE = Shade_Vertex_Spatial;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shade Vertex Elevation")) {
              WIN3D_FACES_SHADE = Shade_Vertex_Elevation;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Land Mesh")) {
              Display_LAND_MESH = (Display_LAND_MESH + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Land Texture")) {
              Display_LAND_TEXTURE = (Display_LAND_TEXTURE + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Land Depth")) {
              Display_LAND_DEPTH = (Display_LAND_DEPTH + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Edges")) {
              Display_MODEL3D_EDGES = (Display_MODEL3D_EDGES  + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Normals")) {
              Display_MODEL3D_NORMALS = (Display_MODEL3D_NORMALS  + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Leaves")) {
              Display_Leaves = (Display_Leaves + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }                
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Living Objects")) {
              Display_Trees_People = (Display_Trees_People + 1) % 2;
              Display_FractalPlant = Display_Trees_People; // <<<<<<<
              Display_Leaves = Display_FractalPlant; // <<<<<<
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Building Objects")) {
              Display_Building_Model = (Display_Building_Model + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Urban")) {
              Display_URBAN_MESH = (Display_URBAN_MESH + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Sections")) {
              Display_Sections = (Display_Sections + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Sky")) {
              Display_SKY3D = (Display_SKY3D + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Sun Path")) {
              Display_SUN3D_Path = (Display_SUN3D_Path + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Sun Pattern")) {
              Display_SUN3D_Pattern = (Display_SUN3D_Pattern + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Star")) {
              Display_STAR3D = (Display_STAR3D + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Moon")) {
              Display_MOON3D = (Display_MOON3D + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Earth")) {
              Display_EARTH3D = (Display_EARTH3D + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Troposphere")) {
              Display_TROPO3D = (Display_TROPO3D + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Shading Section")) {
              Display_SolarImpact_Image = (Display_SolarImpact_Image + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Spatial Section")) {
              Display_SpatialImpact_Image = (Display_SpatialImpact_Image + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected Sections")) {
              selectedSection_displayEdges = (selectedSection_displayEdges + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Wind Flow")) {
              Display_windFlow = (Display_windFlow + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected Faces")) {
              selectedFace_displayEdges = (selectedFace_displayEdges + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected Faces Vertex Count")) {
              selectedFace_displayVertexCount = (selectedFace_displayVertexCount + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected Vertices")) {
              selectedVertex_displayVertices = (selectedVertex_displayVertices + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected Solar Pivots")) {
              selectedPolymesh_displaySolarPivots = (selectedPolymesh_displaySolarPivots + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected 3-D Pivot")) {
              selectedPolymesh_displayPivot = (selectedPolymesh_displayPivot + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected 3-D Edges")) {
              selectedPolymesh_displayEdges = (selectedPolymesh_displayEdges + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected 3-D Box")) {
              selectedPolymesh_displayBox = (selectedPolymesh_displayBox + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected 2½D Edges")) {
              selectedObject2D_displayEdges = (selectedObject2D_displayEdges + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide Selected ∞-D Edges")) {
              selectedFractal_displayEdges = (selectedFractal_displayEdges + 1) % 2;
              
              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }              
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide SWOB points")) {
              Display_SWOB_points = (Display_SWOB_points  + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide SWOB nearest")) {
              Display_SWOB_nearest = (Display_SWOB_nearest + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide NAEFS points")) {
              Display_NAEFS_points = (Display_NAEFS_points + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide NAEFS nearest")) {
              Display_NAEFS_nearest = (Display_NAEFS_nearest  + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide CWEEDS points")) {
              Display_CWEEDS_points = (Display_CWEEDS_points + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide CWEEDS nearest")) {
              Display_CWEEDS_nearest = (Display_CWEEDS_nearest + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide EPW points")) {
              Display_EPW_points = (Display_EPW_points + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Display/Hide EPW nearest")) {
              Display_EPW_nearest = (Display_EPW_nearest + 1) % 2;
              
              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Fractal")) {
              set_to_Create_Fractal();
              SOLARCHVISION_highlight_in_BAR_b("Fractal");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Tree")) {
              set_to_Create_Tree();
              SOLARCHVISION_highlight_in_BAR_b("Tree");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Person")) {
              set_to_Create_Person();
              SOLARCHVISION_highlight_in_BAR_b("Person");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 1")) {
              set_to_Create_Parametric(1);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 2")) {
              set_to_Create_Parametric(2);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 3")) {
              set_to_Create_Parametric(3);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 4")) {
              set_to_Create_Parametric(4);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 5")) {
              set_to_Create_Parametric(5);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 6")) {
              set_to_Create_Parametric(6);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Parametric 7")) {
              set_to_Create_Parametric(7);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              BAR_b_Update = 1;  
            }            

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Tri")) {
              set_to_Create_Tri();
              SOLARCHVISION_highlight_in_BAR_b("Tri");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Poly")) {
              set_to_Create_Poly();
              SOLARCHVISION_highlight_in_BAR_b("Poly");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Extrude")) {
              set_to_Create_Extrude();
              SOLARCHVISION_highlight_in_BAR_b("Extrude");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hyper")) {
              set_to_Create_Hyper();
              SOLARCHVISION_highlight_in_BAR_b("Hyper");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("House")) {
              set_to_Create_House();
              SOLARCHVISION_highlight_in_BAR_b("House");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Box")) {
              set_to_Create_Box();
              SOLARCHVISION_highlight_in_BAR_b("Box");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Octahedron")) {
              set_to_Create_Octahedron();
              SOLARCHVISION_highlight_in_BAR_b("Octahedron");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Sphere")) {
              set_to_Create_Sphere();
              SOLARCHVISION_highlight_in_BAR_b("Sphere");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Cylinder")) {
              set_to_Create_Cylinder();
              SOLARCHVISION_highlight_in_BAR_b("Cylinder");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Cushion")) {
              set_to_Create_Cushion();
              SOLARCHVISION_highlight_in_BAR_b("Cushion");
              BAR_b_Update = 1;  
            }
            
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Move")) {
              //set_to_Modify_Move(selected_posVector);
              set_to_Modify_Move(3);
              SOLARCHVISION_highlight_in_BAR_b("MV³");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("MoveX")) {
              set_to_Modify_Move(0);
              SOLARCHVISION_highlight_in_BAR_b("MVx");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("MoveY")) {
              set_to_Modify_Move(1);
              SOLARCHVISION_highlight_in_BAR_b("MVy");
              BAR_b_Update = 1;  
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("MoveZ")) {
              set_to_Modify_Move(2);
              SOLARCHVISION_highlight_in_BAR_b("MVz");
              BAR_b_Update = 1;  
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Scale")) {
              //set_to_Modify_Scale(selected_scaleVector);
              set_to_Modify_Scale(3);
              SOLARCHVISION_highlight_in_BAR_b("SC³");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("ScaleX")) {
              set_to_Modify_Scale(0);
              SOLARCHVISION_highlight_in_BAR_b("SCx");
              BAR_b_Update = 1;  
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("ScaleY")) {
              set_to_Modify_Scale(1);
              SOLARCHVISION_highlight_in_BAR_b("SCy");
              BAR_b_Update = 1;  
            }      
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("ScaleZ")) {
              set_to_Modify_Scale(2);
              SOLARCHVISION_highlight_in_BAR_b("SCz");
              BAR_b_Update = 1;  
            }                
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Rotate")) {
              //set_to_Modify_Rotate(selected_rotVector);
              set_to_Modify_Rotate(2); // <<<<<<
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("RotateX")) {
              set_to_Modify_Rotate(0);
              SOLARCHVISION_highlight_in_BAR_b("RTx");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("RotateY")) {
              set_to_Modify_Rotate(1);
              SOLARCHVISION_highlight_in_BAR_b("RTy");
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("RotateZ")) {
              set_to_Modify_Rotate(2);
              SOLARCHVISION_highlight_in_BAR_b("RTz");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("SolarPivot")) {
              set_to_Modify_SolarPivot(0);
              SOLARCHVISION_highlight_in_BAR_b("SPvt0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick SolarPivot")) {
              set_to_Modify_SolarPivot(1);
              SOLARCHVISION_highlight_in_BAR_b("SPvt1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign SolarPivot")) {
              set_to_Modify_SolarPivot(2);
              SOLARCHVISION_highlight_in_BAR_b("SPvt2");
              BAR_b_Update = 1;  
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Save Current Pivot")) {
              SOLARCHVISION_save_selection_Pivot();
              SOLARCHVISION_highlight_in_BAR_b("<pvt>");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Reset Saved Pivot")) {
              SOLARCHVISION_apply_saved_Pivot();
              SOLARCHVISION_highlight_in_BAR_b(">pvt<");
              BAR_b_Update = 1;  
              WIN3D_Update = 1;
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Use Selection Pivot")) {
              SOLARCHVISION_calculate_selection_Pivot();
              SOLARCHVISION_highlight_in_BAR_b("|pvt|");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Use Origin Pivot")) {
              SOLARCHVISION_apply_origin_Pivot();
              SOLARCHVISION_highlight_in_BAR_b(".pvt.");
              BAR_b_Update = 1;  
              WIN3D_Update = 1;
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick Study Plane")) {
              set_to_Pick_Study_Plane();
              SOLARCHVISION_highlight_in_BAR_b("PSP");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change Seed/Material")) {
              set_to_Modify_Seed(0);
              SOLARCHVISION_highlight_in_BAR_b("Mat0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick Seed/Material")) {
              set_to_Modify_Seed(1);
              SOLARCHVISION_highlight_in_BAR_b("Mat1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign Seed/Material")) {
              set_to_Modify_Seed(2);
              SOLARCHVISION_highlight_in_BAR_b("Mat2");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change Tessellation")) {
              set_to_Modify_Tessellation(0);
              SOLARCHVISION_highlight_in_BAR_b("Tes0");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick Tessellation")) {
              set_to_Modify_Tessellation(1);
              SOLARCHVISION_highlight_in_BAR_b("Tes1");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign Tessellation")) {
              set_to_Modify_Tessellation(2);
              SOLARCHVISION_highlight_in_BAR_b("Tes2");
              BAR_b_Update = 1;  
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change Layer")) {
              set_to_Modify_Layer(0);
              SOLARCHVISION_highlight_in_BAR_b("Lyr0");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick Layer")) {
              set_to_Modify_Layer(1);
              SOLARCHVISION_highlight_in_BAR_b("Lyr1");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign Layer")) {
              set_to_Modify_Layer(2);
              SOLARCHVISION_highlight_in_BAR_b("Lyr2");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change Visibility")) {
              set_to_Modify_Visibility(0);
              SOLARCHVISION_highlight_in_BAR_b("Vsb0");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick Visibility")) {
              set_to_Modify_Visibility(1);
              SOLARCHVISION_highlight_in_BAR_b("Vsb1");
              BAR_b_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign Visibility")) {
              set_to_Modify_Visibility(2);
              SOLARCHVISION_highlight_in_BAR_b("Vsb2");
              BAR_b_Update = 1;  
            }            
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Flip FaceNormal")) {
              set_to_Modify_FaceNormal(1);
              SOLARCHVISION_highlight_in_BAR_b("FNorm1");
              BAR_b_Update = 1;  
            }                

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Set-Out FaceNormal")) {
              set_to_Modify_FaceNormal(2);
              SOLARCHVISION_highlight_in_BAR_b("FNorm2");
              BAR_b_Update = 1;  
            }   

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Set-In FaceNormal")) {
              set_to_Modify_FaceNormal(3);
              SOLARCHVISION_highlight_in_BAR_b("FNorm3");
              BAR_b_Update = 1;  
            }   

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Get FaceFirstVertex")) {
              set_to_Modify_FaceFirstVertex(1);
              SOLARCHVISION_highlight_in_BAR_b("F1stV");
              BAR_b_Update = 1;  
            }     

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeMax")) {
              set_to_Modify_DegreeMax(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMax0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick DegreeMax")) {
              set_to_Modify_DegreeMax(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMax1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign DegreeMax")) {
              set_to_Modify_DegreeMax(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMax2");
              BAR_b_Update = 1;  
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeDif")) {
              set_to_Modify_DegreeDif(0);
              SOLARCHVISION_highlight_in_BAR_b("dgDif0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick DegreeDif")) {
              set_to_Modify_DegreeDif(1);
              SOLARCHVISION_highlight_in_BAR_b("dgDif1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign DegreeDif")) {
              set_to_Modify_DegreeDif(2);
              SOLARCHVISION_highlight_in_BAR_b("dgDif2");
              BAR_b_Update = 1;  
            }                 

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeMin")) {
              set_to_Modify_DegreeMin(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMin0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick DegreeMin")) {
              set_to_Modify_DegreeMin(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMin1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign DegreeMin")) {
              set_to_Modify_DegreeMin(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMin2");
              BAR_b_Update = 1;  
            }     

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change TrunkSize")) {
              set_to_Modify_TrunkSize(0);
              SOLARCHVISION_highlight_in_BAR_b("trSz0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick TrunkSize")) {
              set_to_Modify_TrunkSize(1);
              SOLARCHVISION_highlight_in_BAR_b("trSz1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign TrunkSize")) {
              set_to_Modify_TrunkSize(2);
              SOLARCHVISION_highlight_in_BAR_b("trSz2");
              BAR_b_Update = 1;  
            }     
     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change LeafSize")) {
              set_to_Modify_LeafSize(0);
              SOLARCHVISION_highlight_in_BAR_b("lfSz0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick LeafSize")) {
              set_to_Modify_LeafSize(1);
              SOLARCHVISION_highlight_in_BAR_b("lfSz1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign LeafSize")) {
              set_to_Modify_LeafSize(2);
              SOLARCHVISION_highlight_in_BAR_b("lfSz2");
              BAR_b_Update = 1;  
            }     
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("AllFractalProps")) {
              set_to_Modify_AllFractalProps(0);
              SOLARCHVISION_highlight_in_BAR_b("allFP0");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pick AllFractalProps")) {
              set_to_Modify_AllFractalProps(1);
              SOLARCHVISION_highlight_in_BAR_b("allFP1");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Assign AllFractalProps")) {
              set_to_Modify_AllFractalProps(2);
              SOLARCHVISION_highlight_in_BAR_b("allFP2");
              BAR_b_Update = 1;  
            }                 
 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeMax")) {
              set_to_Modify_DegreeMax(0);
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeDif")) {
              set_to_Modify_DegreeDif(0);
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change DegreeMin")) {
              set_to_Modify_DegreeMin(0);
            }     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change TrunkSize")) {
              set_to_Modify_TrunkSize(0);
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Change LeafSize")) {
              set_to_Modify_LeafSize(0);
            }           
  
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Orthographic")) {
              set_to_View_ProjectionType(0);
              SOLARCHVISION_highlight_in_BAR_b("P<>");
              BAR_b_Update = 1;  
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Perspective")) {
              set_to_View_ProjectionType(1);
              SOLARCHVISION_highlight_in_BAR_b("P><");
              BAR_b_Update = 1;  
            }   

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Reverse Selection")) {
              SOLARCHVISION_reverseSelection();
              WIN3D_Update = 1;
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Deselect All")) {
              SOLARCHVISION_deselectAll();
              WIN3D_Update = 1;
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select All")) {
              SOLARCHVISION_selectAll();
              WIN3D_Update = 1;
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Section")) {
              Work_with_2D_or_3D = 8;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Fractal")) {
              Work_with_2D_or_3D = 1;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Object2D")) {
              Work_with_2D_or_3D = 2;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Polymesh")) {
              Work_with_2D_or_3D = 3;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Face")) {
              Work_with_2D_or_3D = 4;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Vertex")) {
              Work_with_2D_or_3D = 5;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Soft Selection")) {
              SOLARCHVISION_convertVertex2softSelection();
              
              Work_with_2D_or_3D = 6;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }                 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Vertex >> Polymesh")) {
              SOLARCHVISION_convertVertex2Polymesh();
              Work_with_2D_or_3D = 3;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Face >> Polymesh")) {
              SOLARCHVISION_convertFace2Polymesh();
              Work_with_2D_or_3D = 3;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Polymesh >> Face")) {
              SOLARCHVISION_convertPolymesh2Face();
              Work_with_2D_or_3D = 4;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Polymesh >> Vertex")) {
              SOLARCHVISION_convertPolymesh2Vertex();
              Work_with_2D_or_3D = 5;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Face >> Vertex")) {
              SOLARCHVISION_convertFace2Vertex();
              Work_with_2D_or_3D = 5;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Vertex >> Face")) {
              SOLARCHVISION_convertVertex2Face();
              Work_with_2D_or_3D = 4;
              WIN3D_Update = 1;
              BAR_b_Update = 1;  
            }       
         
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Click Select")) {
              set_to_View_ClickSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±CS");
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Click Select+")) {
              set_to_View_ClickSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+CS");
              BAR_b_Update = 1;  
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Click Select-")) {
              set_to_View_ClickSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-CS");
              BAR_b_Update = 1;  
            }            
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Window Select")) {
              set_to_View_WindowSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±WS");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Window Select+")) {
              set_to_View_WindowSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+WS");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Window Select-")) {
              set_to_View_WindowSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-WS");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Near Vertices")) {
              SOLARCHVISION_selectNearVertices();
              WIN3D_Update = 1;  
            }

            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Weld Objects Vertices Selection")) {
              SOLARCHVISION_weldObjectsVerticesSelection();
              WIN3D_Update = 1;  
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Weld Scene Vertices Selection")) {
              SOLARCHVISION_weldSceneVerticesSelection();
              WIN3D_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Reposition Vertices Selection")) {
              SOLARCHVISION_repositionVerticesSelection();
              WIN3D_Update = 1;  
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Separate Vertices Selection")) {
              SOLARCHVISION_separateVerticesSelection();
              WIN3D_Update = 1;  
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Select Isolated Vertices")) {
              SOLARCHVISION_selectIsolatedVertices();
              WIN3D_Update = 1;  
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Delete All Isolated Vertices")) {
              SOLARCHVISION_deleteIsolatedVerticesScene();
              WIN3D_Update = 1;  
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Delete Isolated Vertices Selection")) {
              SOLARCHVISION_deleteIsolatedVerticesSelection();
              WIN3D_Update = 1;  
            }              
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Delete Selection")) {
              SOLARCHVISION_deleteSelection();
              WIN3D_Update = 1;              
            }      
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Duplicate Selection")) {
              SOLARCHVISION_duplicateSelection();
              WIN3D_Update = 1;              
            }      
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Insert Corner Opennings")) {
              SOLARCHVISION_inserCornerOpenningsSelection();
              WIN3D_Update = 1;              
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Insert Parallel Opennings")) {
              SOLARCHVISION_insertParallelOpenningsSelection();              
              WIN3D_Update = 1;              
            }     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Insert Rotated Opennings")) {
              SOLARCHVISION_insertRotatedOpenningsSelection();
              WIN3D_Update = 1;              
            }       
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Insert Edge Opennings")) {
              SOLARCHVISION_insertEdgeOpenningsSelection();
              WIN3D_Update = 1;              
            } 
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Tessellate Rows & Columns")) {
              SOLARCHVISION_tessellateRowsColumnsFaceSelection();
              WIN3D_Update = 1;              
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Tessellate Rectangular")) {
              SOLARCHVISION_tessellateRectangularFaceSelection();
              WIN3D_Update = 1;              
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Tessellation Triangular")) {
              SOLARCHVISION_tessellateTriangularFaceSelection();
              WIN3D_Update = 1;              
            }            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Extrude Face Edges")) {
              SOLARCHVISION_extrudeFaceEdgesSelection();
              WIN3D_Update = 1;              
            }    
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Offset(above) Vertices")) {
              SOLARCHVISION_offsetVerticesSelection(0, abs(Modify_Input_OffsetAmount));
              WIN3D_Update = 1;              
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Offset(below) Vertices")) {
              SOLARCHVISION_offsetVerticesSelection(0, -abs(Modify_Input_OffsetAmount));
              WIN3D_Update = 1;              
            }             
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Offset(expand) Vertices")) {
              SOLARCHVISION_offsetVerticesSelection(1, -abs(Modify_Input_OffsetAmount));
              WIN3D_Update = 1;              
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Offset(shrink) Vertices")) {
              SOLARCHVISION_offsetVerticesSelection(1, abs(Modify_Input_OffsetAmount));
              WIN3D_Update = 1;              
            }               
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Reverse Visibility of All Faces")) {
              SOLARCHVISION_reverseVisibilityFacesScene();
              WIN3D_Update = 1;              
            } 
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hide All Faces")) {
              SOLARCHVISION_changeVisibilityFacesScene(0);
              WIN3D_Update = 1;              
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Unhide All Faces")) {
              SOLARCHVISION_changeVisibilityFacesScene(1);
              WIN3D_Update = 1;              
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Hide Selected Faces")) {
              SOLARCHVISION_changeVisibilityFacesSelection(0);
              WIN3D_Update = 1;              
            }  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Unhide Selected Faces")) {
              SOLARCHVISION_changeVisibilityFacesSelection(1);
              WIN3D_Update = 1;              
            }     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Isolate Selected Faces")) {
              SOLARCHVISION_isolateSelection();
              WIN3D_Update = 1;              
            }         
   
               
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TargetRoll")) {
              set_to_View_TargetRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("TRL");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TargetRollZ")) {
              set_to_View_TargetRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("TRLz");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TargetRollXY")) {
              set_to_View_TargetRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("TRLxy");
              BAR_b_Update = 1;  
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("CameraRoll")) {
              set_to_View_CameraRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("CRL");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("CameraRollZ")) {
              set_to_View_CameraRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("CRLz");
              BAR_b_Update = 1;  
            }                
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("CameraRollXY")) {
              set_to_View_CameraRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("CRLxy");
              BAR_b_Update = 1;  
            }
                
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Orbit")) {
              set_to_View_Orbit(0);
              SOLARCHVISION_highlight_in_BAR_b("OR");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("OrbitZ")) {
              set_to_View_Orbit(1);
              SOLARCHVISION_highlight_in_BAR_b("ORz");
              BAR_b_Update = 1;  
            }           
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("OrbitXY")) {
              set_to_View_Orbit(2);
              SOLARCHVISION_highlight_in_BAR_b("ORxy");
              BAR_b_Update = 1;  
            }   
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Pan")) {
              set_to_View_Pan(0);
              SOLARCHVISION_highlight_in_BAR_b("Pan");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PanX")) {
              set_to_View_Pan(1);
              SOLARCHVISION_highlight_in_BAR_b("PanX");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PanY")) {
              set_to_View_Pan(2);
              SOLARCHVISION_highlight_in_BAR_b("PanY");
              BAR_b_Update = 1;  
            }          
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Zoom")) {
              set_to_View_Zoom(0);
              SOLARCHVISION_highlight_in_BAR_b("±ZM");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Zoom as default")) {
              set_to_View_Zoom(1);
              SOLARCHVISION_highlight_in_BAR_b("0ZM");
              BAR_b_Update = 1;  
            }
  
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TruckX")) {
              set_to_View_Truck(1);
              SOLARCHVISION_highlight_in_BAR_b("DIx");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TruckY")) {
              set_to_View_Truck(2);
              SOLARCHVISION_highlight_in_BAR_b("DIy");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("TruckZ")) {
              set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("DIz");
              BAR_b_Update = 1;  
            }          
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("DistZ")) {
              set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDZ");
              BAR_b_Update = 1;  
            }     
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("CameraDistance")) {
              set_to_View_CameraDistance(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDS");
              BAR_b_Update = 1;  
            }   
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("DistMouseXY")) {
              set_to_View_DistMouseXY(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDM");
              BAR_b_Update = 1;  
            }  
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Look at origin")) {
              set_to_View_LookAtOrigin(0);
              SOLARCHVISION_highlight_in_BAR_b("LAO");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Look at selection")) {
              set_to_View_LookAtSelection(0);
              SOLARCHVISION_highlight_in_BAR_b("LAS");
              BAR_b_Update = 1;  
            }          
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("3DModelSize")) {
              set_to_View_3DModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SZ");
              BAR_b_Update = 1;  
            }          
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("SkydomeSize")) {
              set_to_View_SkydomeSize();
              SOLARCHVISION_highlight_in_BAR_b("±SK");
              BAR_b_Update = 1;  
            }       
         
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("AllModelSize")) {
              set_to_View_AllModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SA");
              BAR_b_Update = 1;  
            }     
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Shrink 3DViewSpace")) {
              set_to_View_3DViewSpace(0);
              SOLARCHVISION_highlight_in_BAR_b("AllViewsports");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Enlarge 3DViewSpace")) {
              set_to_View_3DViewSpace(1);
              SOLARCHVISION_highlight_in_BAR_b("Expand3DView");
              BAR_b_Update = 1;  
            } 
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Top")) {
              set_to_View_3DViewPoint(0);
              SOLARCHVISION_highlight_in_BAR_b("Top");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Front")) {
              set_to_View_3DViewPoint(1);
              SOLARCHVISION_highlight_in_BAR_b("Front");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Left")) {
              set_to_View_3DViewPoint(2);
              SOLARCHVISION_highlight_in_BAR_b("Left");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Back")) {
              set_to_View_3DViewPoint(3);
              SOLARCHVISION_highlight_in_BAR_b("Back");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Right")) {
              set_to_View_3DViewPoint(4);
              SOLARCHVISION_highlight_in_BAR_b("Right");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("Bottom")) {
              set_to_View_3DViewPoint(5);
              SOLARCHVISION_highlight_in_BAR_b("Bottom");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("S.W.")) {
              set_to_View_3DViewPoint(6);
              SOLARCHVISION_highlight_in_BAR_b("S.W.");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("S.E.")) {
              set_to_View_3DViewPoint(7);
              SOLARCHVISION_highlight_in_BAR_b("S.E.");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("N.E.")) {
              set_to_View_3DViewPoint(8);
              SOLARCHVISION_highlight_in_BAR_b("N.E.");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("N.W.")) {
              set_to_View_3DViewPoint(9);
              SOLARCHVISION_highlight_in_BAR_b("N.W.");
              BAR_b_Update = 1;  
            }
            
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotX:Minimum")) {
              set_to_View_PivotX(-1);
              SOLARCHVISION_highlight_in_BAR_b("X<");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotX:Center")) {
              set_to_View_PivotX(0);
              SOLARCHVISION_highlight_in_BAR_b("X|");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotX:Maximum")) {
              set_to_View_PivotX(1);
              SOLARCHVISION_highlight_in_BAR_b("X>");
              BAR_b_Update = 1;  
            }
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotY:Minimum")) {
              set_to_View_PivotY(-1);
              SOLARCHVISION_highlight_in_BAR_b("Y<");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotY:Center")) {
              set_to_View_PivotY(0);
              SOLARCHVISION_highlight_in_BAR_b("Y|");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotY:Maximum")) {
              set_to_View_PivotY(1);
              SOLARCHVISION_highlight_in_BAR_b("Y>");
              BAR_b_Update = 1;  
            }
  
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotZ:Minimum")) {
              set_to_View_PivotZ(-1);
              SOLARCHVISION_highlight_in_BAR_b("Z<");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotZ:Center")) {
              set_to_View_PivotZ(0);
              SOLARCHVISION_highlight_in_BAR_b("Z|");
              BAR_b_Update = 1;  
            }
            if (BAR_a_Items[BAR_a_selected_parent][BAR_a_selected_child].equals("PivotZ:Maximum")) {
              set_to_View_PivotZ(1);
              SOLARCHVISION_highlight_in_BAR_b("Z>");
              BAR_b_Update = 1;  
            }
  
  
          }
        }
        
        BAR_a_selected_parent = -1;
        BAR_a_selected_child = 0;
    
        image(pre_screen, 0, a_pixel);
        
        X_clicked = -1;
        Y_clicked = -1;      
      }   
      else {    

        X_clicked = mouseX;
        Y_clicked = mouseY;

        if (isInside(X_clicked, Y_clicked, 0, 0, width, a_pixel) == 1) {
          BAR_a_Update = 1;
        }
    
        if (isInside(X_clicked, Y_clicked, 0, a_pixel, width, a_pixel + b_pixel) == 1) {
          BAR_b_Update = 1; 
        }
  
        if (isInside(X_clicked, Y_clicked, 0, a_pixel + b_pixel + 2 * h_pixel, width, a_pixel + b_pixel + 2 * h_pixel + d_pixel) == 1) {
          BAR_d_Update = 1; 
        }  
        
        if (WORLD_include == 1) {
          if (isInside(X_clicked, Y_clicked, WORLD_CX_View, WORLD_CY_View, WORLD_CX_View + WORLD_X_View, WORLD_CY_View + WORLD_Y_View) == 1) {

          float WORLD_VIEW_OffsetX = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0] + 180;
          float WORLD_VIEW_OffsetY = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - 90;
            
          float WORLD_VIEW_ScaleX = (WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) / 360.0;
          float WORLD_VIEW_ScaleY = (WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) / 180.0;    
            
            float mouse_lon = 360.0 * ((mouseX - WORLD_CX_View) * WORLD_VIEW_ScaleX / WORLD_X_View - 0.5) + WORLD_VIEW_OffsetX;
            float mouse_lat = -180.0 * ((mouseY - WORLD_CY_View) * WORLD_VIEW_ScaleY / WORLD_Y_View - 0.5) + WORLD_VIEW_OffsetY;
            //float mouse_lon = LocationLongitude;
            //float mouse_lat = LocationLatitude;
  
            
            pre_LocationLatitude = LocationLatitude;
            pre_LocationLongitude = LocationLongitude;
            
            LocationLatitude = mouse_lat;
            LocationLongitude = mouse_lon;
            
            if (mouseButton == LEFT) {
              WORLD_viewport_ZOOM = 6;
            }
            
            if ((pre_LocationLatitude != LocationLatitude) || (pre_LocationLongitude != LocationLongitude)) {
              WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);
            } 
            
            
            
            {
              int nearest_STATION_NAEFS = -1;
              float nearest_STATION_NAEFS_dist = FLOAT_undefined;
                        
              for (int f = 0; f < STATION_NAEFS_INFO.length; f += 1) {
              
                float _lat = float(STATION_NAEFS_INFO[f][3]);
                float _lon = float(STATION_NAEFS_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!
              
                float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
                
                if (nearest_STATION_NAEFS_dist > d) {
                  nearest_STATION_NAEFS_dist = d;
                  nearest_STATION_NAEFS = f;
                } 
                
              }
          
              {
                int f = nearest_STATION_NAEFS;
  
                if (DEFINED_STATIONS[STATION_NUMBER][8].equals(STATION_NAEFS_INFO[f][6])) {
                }
                else {
                  
                  STATION_NUMBER = 0; // <<<<<<<<<< overwrite station 0
  
                  DEFINED_STATIONS[STATION_NUMBER][3] = nf(mouse_lat, 0, 0);                
                  DEFINED_STATIONS[STATION_NUMBER][4] = nf(mouse_lon, 0, 0); 
                  
                  DEFINED_STATIONS[STATION_NUMBER][8] = STATION_NAEFS_INFO[f][6]; // naefs filename
       
                  println("nearest naefs filename:", STATION_NAEFS_INFO[f][6]);    
    
                  Selected_STATION = STATION_NUMBER;
  
                  if (impacts_source == databaseNumber_ENSEMBLE) {
                    DEFINED_STATIONS[STATION_NUMBER][0] = STATION_NAEFS_INFO[f][0];
                    DEFINED_STATIONS[STATION_NUMBER][1] = STATION_NAEFS_INFO[f][1];
                    DEFINED_STATIONS[STATION_NUMBER][2] = STATION_NAEFS_INFO[f][2];
        
                    //DEFINED_STATIONS[STATION_NUMBER][3] = STATION_NAEFS_INFO[f][3];
                    //DEFINED_STATIONS[STATION_NUMBER][4] = STATION_NAEFS_INFO[f][4];
                    DEFINED_STATIONS[STATION_NUMBER][5] = nf(roundTo(float(STATION_NAEFS_INFO[f][2]), 15), 0, 0);                      
                    
                    BAR_a_Items[N_Site_in_Bar_a][1] = DEFINED_STATIONS[STATION_NUMBER][0]; // <<<<<<<<
  
                    ROLLOUT_parent = 0;
                    ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;
                    
                                  
                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
                    
                  }
                }
              }
            }        
            
  
            {
              int nearest_STATION_CWEEDS = -1;
              float nearest_STATION_CWEEDS_dist = FLOAT_undefined;
                        
              for (int f = 0; f < STATION_CWEEDS_INFO.length; f += 1) {
              
                float _lat = float(STATION_CWEEDS_INFO[f][3]);
                float _lon = float(STATION_CWEEDS_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!
              
                float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
                
                if (nearest_STATION_CWEEDS_dist > d) {
                  nearest_STATION_CWEEDS_dist = d;
                  nearest_STATION_CWEEDS = f;
                } 
                
              }
  
              {
                int f = nearest_STATION_CWEEDS;
                
                if (DEFINED_STATIONS[STATION_NUMBER][9].equals(STATION_CWEEDS_INFO[f][6])) {  
                }
                else {
                  
                  STATION_NUMBER = 0; // <<<<<<<<<< overwrite station 0
  
                  DEFINED_STATIONS[STATION_NUMBER][3] = nf(mouse_lat, 0, 0);                
                  DEFINED_STATIONS[STATION_NUMBER][4] = nf(mouse_lon, 0, 0); 
                  
                  DEFINED_STATIONS[STATION_NUMBER][9] = STATION_CWEEDS_INFO[f][6]; // CWEEDS filename
       
                  println("nearest CWEEDS filename:", STATION_CWEEDS_INFO[f][6]);       
       
                  Selected_STATION = STATION_NUMBER;
                  
                  if (impacts_source == databaseNumber_CLIMATE_WY2) { 
  
                    DEFINED_STATIONS[STATION_NUMBER][0] = STATION_CWEEDS_INFO[f][0];
                    DEFINED_STATIONS[STATION_NUMBER][1] = STATION_CWEEDS_INFO[f][1];
                    DEFINED_STATIONS[STATION_NUMBER][2] = STATION_CWEEDS_INFO[f][2]; 
        
                    //DEFINED_STATIONS[STATION_NUMBER][3] = STATION_CWEEDS_INFO[f][3];
                    //DEFINED_STATIONS[STATION_NUMBER][4] = STATION_CWEEDS_INFO[f][4];
                    DEFINED_STATIONS[STATION_NUMBER][5] = STATION_CWEEDS_INFO[f][6]; 
                    DEFINED_STATIONS[STATION_NUMBER][6] = STATION_CWEEDS_INFO[f][5];   
     
                    BAR_a_Items[N_Site_in_Bar_a][1] = DEFINED_STATIONS[STATION_NUMBER][0]; // <<<<<<<<
                    
                    ROLLOUT_parent = 0;
                    ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;
                  
                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_CLIMATE_WY2();
                  }
                }
              }
            }          
  
  
            {
              int nearest_STATION_EPW = -1;
              float nearest_STATION_EPW_dist = FLOAT_undefined;
                        
              for (int f = 0; f < STATION_EPW_INFO.length; f += 1) {
              
                float _lat = float(STATION_EPW_INFO[f][3]);
                float _lon = float(STATION_EPW_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!
              
                float d = dist_lon_lat(_lon, _lat,  LocationLongitude, LocationLatitude);
                
                if (nearest_STATION_EPW_dist > d) {
                  nearest_STATION_EPW_dist = d;
                  nearest_STATION_EPW = f;
                } 
                
              }
  
              {
                int f = nearest_STATION_EPW;
                
                if (DEFINED_STATIONS[STATION_NUMBER][10].equals(STATION_EPW_INFO[f][8])) {  
                }
                else {
  
                  STATION_NUMBER = 0; // <<<<<<<<<< overwrite station 0
  
                  DEFINED_STATIONS[STATION_NUMBER][3] = nf(mouse_lat, 0, 0);                
                  DEFINED_STATIONS[STATION_NUMBER][4] = nf(mouse_lon, 0, 0); 
                  
                  DEFINED_STATIONS[STATION_NUMBER][10] = STATION_EPW_INFO[f][8]; // epw filename
       
                  println("nearest epw filename:", STATION_EPW_INFO[f][8]);       
  
                  Selected_STATION = STATION_NUMBER;
                    
                  if (impacts_source == databaseNumber_CLIMATE_EPW) {     
                    DEFINED_STATIONS[STATION_NUMBER][0] = STATION_EPW_INFO[f][0];
                    DEFINED_STATIONS[STATION_NUMBER][1] = STATION_EPW_INFO[f][1];
                    DEFINED_STATIONS[STATION_NUMBER][2] = STATION_EPW_INFO[f][2]; 
        
                    //DEFINED_STATIONS[STATION_NUMBER][3] = STATION_EPW_INFO[f][3];
                    //DEFINED_STATIONS[STATION_NUMBER][4] = STATION_EPW_INFO[f][4];
                    DEFINED_STATIONS[STATION_NUMBER][5] = STATION_EPW_INFO[f][6]; 
                    DEFINED_STATIONS[STATION_NUMBER][6] = STATION_EPW_INFO[f][5];    
          
                    BAR_a_Items[N_Site_in_Bar_a][1] = DEFINED_STATIONS[STATION_NUMBER][0]; // <<<<<<<<
                    
                    ROLLOUT_parent = 0;
                    ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;
  
                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_CLIMATE_EPW();
                  }
                }
              }
            }          
  
                          
  
            
            WORLD_Update = 1;
          } 
        }
        
        if (WIN3D_include == 1) {
          if (isInside(X_clicked, Y_clicked, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
      
            float Image_X = 0;
            float Image_Y = 0;
    
            Image_X = X_clicked - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
            Image_Y = Y_clicked - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);
    
            float[] ray_direction = new float [3];
    
            float[] ray_start = {CAM_x, CAM_y, CAM_z};
    
            float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);
            
            ray_start[0] /= OBJECTS_scale;
            ray_start[1] /= OBJECTS_scale;
            ray_start[2] /= OBJECTS_scale;          
            
            ray_end[0] /= OBJECTS_scale;
            ray_end[1] /= OBJECTS_scale;
            ray_end[2] /= OBJECTS_scale;
    
            if (WIN3D_View_Type == 0) {
              float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);
    
              ray_center[0] /= OBJECTS_scale;
              ray_center[1] /= OBJECTS_scale;
              ray_center[2] /= OBJECTS_scale;
              
              ray_start[0] += ray_end[0] - ray_center[0];
              ray_start[1] += ray_end[1] - ray_center[1];
              ray_start[2] += ray_end[2] - ray_center[2];
            }
            
            ray_direction[0] = ray_end[0] - ray_start[0];
            ray_direction[1] = ray_end[1] - ray_start[1];
            ray_direction[2] = ray_end[2] - ray_start[2];
            
            float max_dist = 2 * dist(ray_start[0], ray_start[1], ray_start[2], ray_end[0], ray_end[1], ray_end[2]);
            
            
            
            float[] RxP = new float [5];
            
            if (mouseButton == RIGHT) {
              RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction, max_dist);
            }
            else if (mouseButton == LEFT) {
              //if ((Work_with_2D_or_3D == 8) && ((View_Select_Create_Modify == -1) || (View_Select_Create_Modify > 1) && (View_Select_Create_Modify != 17)))  { // only if the user wants to select a Section
              if ((Work_with_2D_or_3D == 8) && ((View_Select_Create_Modify != 0) && (View_Select_Create_Modify != 1) && (View_Select_Create_Modify != 17)))  { // only if the user wants to select a Section
                RxP = SOLARCHVISION_8Dintersect(ray_start, ray_direction, max_dist);
              }                      
              //else if ((Work_with_2D_or_3D == 1) && ((View_Select_Create_Modify == -1) || (View_Select_Create_Modify > 1)))  { // only if the user wants to select a Fractal-Tree 
              else if ((Work_with_2D_or_3D == 1) && ((View_Select_Create_Modify != 0) && (View_Select_Create_Modify != 1)))  { // only if the user wants to select a Fractal-Tree
                RxP = SOLARCHVISION_1Dintersect(ray_start, ray_direction, max_dist);
              }        
              //else if ((Work_with_2D_or_3D == 2) && ((View_Select_Create_Modify == -1) || (View_Select_Create_Modify > 1)))  { // only if the user wants to select a 2D-object
              else if ((Work_with_2D_or_3D == 2) && ((View_Select_Create_Modify != 0) && (View_Select_Create_Modify != 1)))  { // only if the user wants to select a 2D-object 
                RxP = SOLARCHVISION_2Dintersect(ray_start, ray_direction, max_dist);
              }
              else {
                RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction, max_dist);
              }
            }
            
            
            //println(ray_start[0], ray_start[1], ray_start[2], ">>", ray_end[0], ray_end[1], ray_end[2], ">>", RxP[0], RxP[1], RxP[2], RxP[3], RxP[4]);
            
            if (RxP[4] > 0) {
                           
              if (View_Select_Create_Modify == 1) { // move
    
                float x0 = RxP[0];
                float y0 = RxP[1];
                float z0 = RxP[2];
              
                if (Work_with_2D_or_3D == 3) {
    
                  float dx = x0 - selected_Pivot_XYZ[0]; 
                  float dy = y0 - selected_Pivot_XYZ[1]; 
                  float dz = z0 - selected_Pivot_XYZ[2];
  
                  int the_Vector = selected_posVector;
                
                  if (the_Vector == 0) {dy = 0; dz = 0;}  
                  if (the_Vector == 1) {dz = 0; dx = 0;}  
                  if (the_Vector == 2) {dx = 0; dy = 0;} 
    
                  SOLARCHVISION_move_Selection(dx, dy, dz);
                }
    
                if (Work_with_2D_or_3D == 2) {
    
                  float dx = x0 - allObject2D_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][0]; 
                  float dy = y0 - allObject2D_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][1]; 
                  float dz = z0 - allObject2D_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][2];              
  
                  int the_Vector = selected_posVector;
                
                  if (the_Vector == 0) {dy = 0; dz = 0;}  
                  if (the_Vector == 1) {dz = 0; dx = 0;}  
                  if (the_Vector == 2) {dx = 0; dy = 0;} 
    
                  SOLARCHVISION_move_Selection(dx, dy, dz);
                }
    
                if (Work_with_2D_or_3D == 1) {
    
                  float dx = x0 - allFractal_XYZSRA[selectedFractal_numbers[selectedFractal_numbers.length - 1]][0]; 
                  float dy = y0 - allFractal_XYZSRA[selectedFractal_numbers[selectedFractal_numbers.length - 1]][1]; 
                  float dz = z0 - allFractal_XYZSRA[selectedFractal_numbers[selectedFractal_numbers.length - 1]][2];              
  
                  int the_Vector = selected_posVector;
                
                  if (the_Vector == 0) {dy = 0; dz = 0;}  
                  if (the_Vector == 1) {dz = 0; dx = 0;}  
                  if (the_Vector == 2) {dx = 0; dy = 0;} 
    
                  SOLARCHVISION_move_Selection(dx, dy, dz);
                }
                
              }   
              
              if (mouseButton == LEFT) { // modify should work only with left click because the right click returns the land info, not objects info
              
                if ((Modify_Object_Parameters != 0) && (View_Select_Create_Modify >= 4)) { // Pick/Assign properties 
                  
                  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4)) {
      
                    int f = int(RxP[4]);
                  
                    if ((View_Select_Create_Modify == 4) || (View_Select_Create_Modify == 5) || (View_Select_Create_Modify == 6) || (View_Select_Create_Modify == 7)) {
                      
                      if (Modify_Object_Parameters == 1) { // Pick 
                        if (View_Select_Create_Modify == 4) Create_Default_Material = allFaces_MTLV[f][0];
                        if (View_Select_Create_Modify == 5) Create_Default_Tessellation = allFaces_MTLV[f][1];
                        if (View_Select_Create_Modify == 6) Create_Default_Layer = allFaces_MTLV[f][2];
                        if (View_Select_Create_Modify == 7) Create_Default_Visibility = allFaces_MTLV[f][3];
                      } 
                      if (Modify_Object_Parameters == 2) { // Assign(sub) 
                        if (View_Select_Create_Modify == 4) allFaces_MTLV[f][0] = Create_Default_Material;
                        if (View_Select_Create_Modify == 5) allFaces_MTLV[f][1] = Create_Default_Tessellation;
                        if (View_Select_Create_Modify == 6) allFaces_MTLV[f][2] = Create_Default_Layer;
                        if (View_Select_Create_Modify == 7) allFaces_MTLV[f][3] = Create_Default_Visibility; 
                      }
                      if (Modify_Object_Parameters == 3) { // Assign(all) 
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allPolymesh_Faces.length; i++) {
                          if ((allPolymesh_Faces[i][0] <= f) && (f <= allPolymesh_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {
                          for (int q = allPolymesh_Faces[OBJ_NUM][0]; q <= allPolymesh_Faces[OBJ_NUM][1]; q++) {                    
                            if (View_Select_Create_Modify == 4) allFaces_MTLV[q][0] = Create_Default_Material;
                            if (View_Select_Create_Modify == 5) allFaces_MTLV[q][1] = Create_Default_Tessellation;
                            if (View_Select_Create_Modify == 6) allFaces_MTLV[q][2] = Create_Default_Layer;
                            if (View_Select_Create_Modify == 7) allFaces_MTLV[q][3] = Create_Default_Visibility;
                          }
                        }
                      }    
                    }
                    
                    if (View_Select_Create_Modify == 14) {
                      if (Modify_Object_Parameters == 1) { // Pick 
                        //?????????????????????????????????????????????????
                      }     
                      if (Modify_Object_Parameters == 2) { // Assign
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allPolymesh_Faces.length; i++) {
                          if ((allPolymesh_Faces[i][0] <= f) && (f <= allPolymesh_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {
                          allPolymesh_SolarPivotXYZ[OBJ_NUM][0] = selection_BoundingBox[1 + selection_alignX][0];
                          allPolymesh_SolarPivotXYZ[OBJ_NUM][1] = selection_BoundingBox[1 + selection_alignY][1];
                          allPolymesh_SolarPivotXYZ[OBJ_NUM][2] = selection_BoundingBox[1 + selection_alignZ][2];
                        }
                      }                   
                    }
                    
                    if (View_Select_Create_Modify == 15) { //FaceNormal
                    
                      if (Work_with_2D_or_3D == 4) {
                        
                        selectedFace_numbers = new int [2];
                        selectedFace_numbers[0] = 0;
                        selectedFace_numbers[1] = f;       
                        
                        selectedFace_displayVertexCount = 1;                 
                        
                        int n = allFaces[f].length;
                        
                        if (n > 2) {
                          int[] tmpFace = new int[n];
                          float[] G = {0,0,0}; 
                          for (int j = 0; j < n; j++) {
                            tmpFace[j] = allFaces[f][j];
                            G[0] += allVertices[tmpFace[j]][0] / float(n); 
                            G[1] += allVertices[tmpFace[j]][1] / float(n);
                            G[2] += allVertices[tmpFace[j]][2] / float(n);
                          }  
                          
                          int flip_face = 0;
                          if (Modify_Object_Parameters == 1) flip_face = 1;
                          else {
                            PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                            PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);
                            
                            PVector GAxGB = AG.cross(BG);
                           
                            PVector PG = new PVector(selected_Pivot_XYZ[0] - G[0], selected_Pivot_XYZ[1] - G[1], selected_Pivot_XYZ[2] - G[2]);
                           
                            float V = PG.dot(GAxGB); 
                            
                            if (Modify_Object_Parameters == 2) {
                              if (V > 0) flip_face = 1;
                            }
                            if (Modify_Object_Parameters == 3) {
                              if (V < 0) flip_face = 1;
                            }
                          }

                          if (flip_face == 1) {
                            for (int j = 0; j < n; j++) {
                              allFaces[f][j] = tmpFace[n - j - 1];
                            }
                          }
                        }
                      }
                      
                      if (Work_with_2D_or_3D == 3) {
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allPolymesh_Faces.length; i++) {
                          if ((allPolymesh_Faces[i][0] <= f) && (f <= allPolymesh_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {         
                          for (int q = allPolymesh_Faces[OBJ_NUM][0]; q <= allPolymesh_Faces[OBJ_NUM][1]; q++) {                    
                            int n = allFaces[q].length;
                            
                            if (n > 2) {
                              int[] tmpFace = new int[n];
                              float[] G = {0,0,0}; 
                              for (int j = 0; j < n; j++) {
                                tmpFace[j] = allFaces[q][j];
                                G[0] += allVertices[tmpFace[j]][0] / float(n); 
                                G[1] += allVertices[tmpFace[j]][1] / float(n);
                                G[2] += allVertices[tmpFace[j]][2] / float(n);
                              }  
                              
                              int flip_face = 0;
                              if (Modify_Object_Parameters == 1) flip_face = 1;
                              else {
                                PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                                PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);
                                
                                PVector GAxGB = AG.cross(BG);
                               
                                PVector PG = new PVector(selected_Pivot_XYZ[0] - G[0], selected_Pivot_XYZ[1] - G[1], selected_Pivot_XYZ[2] - G[2]);
                               
                                float V = PG.dot(GAxGB); 
                                
                                if (Modify_Object_Parameters == 2) {
                                  if (V > 0) flip_face = 1;
                                }
                                if (Modify_Object_Parameters == 3) {
                                  if (V < 0) flip_face = 1;
                                }
                              }
    
                              if (flip_face == 1) {
                                for (int j = 0; j < n; j++) {
                                  allFaces[q][j] = tmpFace[n - j - 1];
                                }
                              }
                            }
                          }
                        }               
                      }
                    }   
                    
                    
                    if (View_Select_Create_Modify == 16) { //FaceFirstVertex
                    
                      if (Work_with_2D_or_3D == 4) {
                        
                        selectedFace_numbers = new int [2];
                        selectedFace_numbers[0] = 0;
                        selectedFace_numbers[1] = f;
                        
                        selectedFace_displayVertexCount = 1;

                        int n = allFaces[f].length;
                        
                        if (n > 2) {
                            
                          int min_num = 0;
                          float min_dist = FLOAT_undefined;
                          
                          for (int j = 0; j < n; j++) {
                            int vNo = allFaces[f][j];
                            
                            float d = dist(RxP[0], RxP[1], RxP[2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
                            
                            if (min_dist > d) {
                              min_dist = d;
                              min_num = j;
                            }
                          }
                          
                          int[] tmpFace = new int[n];
                          for (int j = 0; j < n; j++) {
                            tmpFace[j] = allFaces[f][j];
                          }  
                          
                          for (int j = 0; j < n; j++) {
                            allFaces[f][j] = tmpFace[(j + min_num + n) % n];
                          }

                        }
                      }
                    }  
                    
                  } 
                  
                  
                  
                  

                  if (Work_with_2D_or_3D == 8) { // working with sections              
                    
                    int f = int(RxP[4]);
                    
                    if (View_Select_Create_Modify == 17) { //PickStudyPlane

                      int n = allFaces[f].length;
                      
                      if (n > 2) {
                        
                        //float min_Alpha = 90;
                        float min_Beta = 360;
                        
                        for (int j = 0; j < n; j++) {
                          
                          int j_next = (j + 1) % n;
                          
                          float x1 = allVertices[allFaces[f][j]][0];
                          float y1 = allVertices[allFaces[f][j]][1];
                          float z1 = allVertices[allFaces[f][j]][2];                        
  
                          float x2 = allVertices[allFaces[f][j_next]][0];
                          float y2 = allVertices[allFaces[f][j_next]][1];
                          float z2 = allVertices[allFaces[f][j_next]][2];                        
  
                          
                          //float Alpha = asin_ang(z2 - z1);
                          float Beta = atan2_ang(y2 - y1, x2 - x1) + 90;
  
                          //if (min_Alpha > Alpha) min_Alpha = Alpha;                      
                          if (min_Beta > Beta) min_Beta = Beta;
                          
                        }
                       
                        //println("min_Alpha", min_Alpha);
                        
                        float[][] tmpVertices = new float[n][3];
                        
                        
                        for (int j = 0; j < n; j++) {
                          
                          float x1 = allVertices[allFaces[f][j]][0];
                          float y1 = allVertices[allFaces[f][j]][1];
                          float z1 = allVertices[allFaces[f][j]][2];
                          
                          float x2 = x1 * cos_ang(-min_Beta) - y1 * sin_ang(-min_Beta);
                          float y2 = x1 * sin_ang(-min_Beta) + y1 * cos_ang(-min_Beta);
                          float z2 = z1;
                          
                          tmpVertices[j][0] = x2;
                          tmpVertices[j][1] = y2;
                          tmpVertices[j][2] = z2;

                        }    

                        float min_x = FLOAT_undefined;
                        float max_x = -FLOAT_undefined;
                        float min_y = FLOAT_undefined;
                        float max_y = -FLOAT_undefined;
                        float min_z = FLOAT_undefined;
                        float max_z = -FLOAT_undefined;
                        
                        float[] G = {0,0,0}; 
                        for (int j = 0; j < n; j++) {
                          float x = tmpVertices[j][0];
                          float y = tmpVertices[j][1];
                          float z = tmpVertices[j][2];
                          
                          G[0] += x / float(n); 
                          G[1] += y / float(n);
                          G[2] += z / float(n);
                          
                          if (min_x > x) min_x = x; 
                          if (max_x < x) max_x = x; 
                          if (min_y > y) min_y = y; 
                          if (max_y < y) max_y = y; 
                          if (min_z > z) min_z = z; 
                          if (max_z < z) max_z = z;
                        }
                        
                        float Section_offset_U = SpatialImpact_offset_U[SpatialImpact_sectionType];
                        float Section_offset_V = SpatialImpact_offset_V[SpatialImpact_sectionType];
                        float Section_Elevation = SpatialImpact_Elevation[SpatialImpact_sectionType];
                        float Section_Rotation = SpatialImpact_Rotation[SpatialImpact_sectionType];
                        float Section_scale_U = SpatialImpact_scale_U[SpatialImpact_sectionType];
                        float Section_scale_V = SpatialImpact_scale_V[SpatialImpact_sectionType];
                  
                        int Section_Type = SpatialImpact_sectionType;
                        int Section_RES1 = SpatialImpact_RES1;
                        int Section_RES2 = SpatialImpact_RES2;                        
                        


                        if ((max_z - min_z < max_x - min_x) && (max_z - min_z < max_y - min_y)) {
                          Section_Type = 1;
  
                          Section_scale_U = max_x - min_x; 
                          Section_scale_V = max_y - min_y;
                          
                          Section_offset_U = G[0];
                          Section_offset_V = G[1];
                          
                          Section_Elevation = G[2];
                          
                          Section_Rotation = min_Beta;
                        }
                        else {
                          Section_Type = 2;
                          
                          Section_scale_U = max_y - min_y;
                          Section_scale_V = max_z - min_z; 
                          
                          Section_offset_U = -G[1];
                          Section_offset_V = G[2];        
                          
                          Section_Elevation = -G[0];
          
                          Section_Rotation = 90 - min_Beta;                            
                        }       

                      
                        // recalculating G...  
                        G[0] = 0;             
                        G[1] = 0;
                        G[2] = 0;
                        for (int j = 0; j < n; j++) {
                          float x = allVertices[allFaces[f][j]][0];
                          float y = allVertices[allFaces[f][j]][1];
                          float z = allVertices[allFaces[f][j]][2];
                          
                          G[0] += x / float(n); 
                          G[1] += y / float(n);
                          G[2] += z / float(n);
                        }
  
                        PVector AG = new PVector(allVertices[allFaces[f][0]][0] - G[0], allVertices[allFaces[f][0]][1] - G[1], allVertices[allFaces[f][0]][2] - G[2]);                       
                        PVector BG = new PVector(allVertices[allFaces[f][1]][0] - G[0], allVertices[allFaces[f][1]][1] - G[1], allVertices[allFaces[f][1]][2] - G[2]);
                       
                        PVector GAxGB = AG.cross(BG);
                        
                        float[] SectionCorner_A = SOLARCHVISION_getCorners_Section(0, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
                        float[] SectionCorner_B = SOLARCHVISION_getCorners_Section(1, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
                        float[] SectionCorner_C = SOLARCHVISION_getCorners_Section(2, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
                        float[] SectionCorner_D = SOLARCHVISION_getCorners_Section(3, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2); 
                        
                        float[] ImageCenter = {0,0,0};
                        for (int j = 0; j < 3; j++) {
                          ImageCenter[j] = 0.25 * (SectionCorner_A[j] + SectionCorner_B[j] + SectionCorner_C[j] + SectionCorner_D[j]);
                        }  
                        
                        PVector AG_other = new PVector(SectionCorner_A[0] - ImageCenter[0], SectionCorner_A[1] - ImageCenter[1], SectionCorner_A[2] - ImageCenter[2]);                       
                        PVector BG_other = new PVector(SectionCorner_B[0] - ImageCenter[0], SectionCorner_B[1] - ImageCenter[1], SectionCorner_B[2] - ImageCenter[2]);
                        
                        PVector GAxGB_other = AG_other.cross(BG_other);
                        
                        //println("GAxGB", GAxGB);
                        //println("GAxGB_other", GAxGB_other);

                        float V = GAxGB_other.dot(GAxGB);

                        //println("V", nf(V, 0, 6));                        

                        if (V < 0) {
                          //println("flip face!");
                          
                          Section_Rotation = 180 + Section_Rotation;
                          Section_Elevation *= -1;
                          Section_offset_U *= -1;
                        }
                        else {
                          //println("face OK!");
                        }
                        
                        
                        
                        int number_of_Section_before = allSection_UVERAB.length; 
                        
                        SOLARCHVISION_add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

                        // selecting new objetcs
                        
                        selectedSection_numbers = new int [1];
                        selectedSection_numbers[0] = 0;
                        
                        for (int o = number_of_Section_before; o < allSection_UVERAB.length; o++) {
                          
                          int[] newlyAddedSection = {o};
                          
                          selectedSection_numbers = concat(selectedSection_numbers, newlyAddedSection);
                        }  

                        SpatialImpact_offset_U[SpatialImpact_sectionType] = Section_offset_U;
                        SpatialImpact_offset_V[SpatialImpact_sectionType] = Section_offset_V;
                        SpatialImpact_Elevation[SpatialImpact_sectionType] = Section_Elevation;
                        SpatialImpact_Rotation[SpatialImpact_sectionType] = Section_Rotation;
                        SpatialImpact_scale_U[SpatialImpact_sectionType] = Section_scale_U;
                        SpatialImpact_scale_V[SpatialImpact_sectionType] = Section_scale_V;
                  
                        SpatialImpact_sectionType = Section_Type;
                        SpatialImpact_RES1 = Section_RES1;
                        SpatialImpact_RES2 = Section_RES2;    
        
                        SOLARCHVISION_calculate_SpatialImpact_selectedSections();
                       
                       
                        SolarImpact_sectionType = Section_Type;                   
                       
                        WIN3D_Update = 1; 
                        ROLLOUT_Update = 1;  
                      }
                    }          
                    
                  }
                  
                  
                  
                  
                  if (Work_with_2D_or_3D == 2) {
      
                    int OBJ_NUM = int(RxP[4]);
                    
                    int n = allObject2D_MAP[OBJ_NUM];
                    int sign_n = 1;
                    if (n < 0) sign_n = -1;
                    n = abs(n);
                    int n1 = Object2D_PEOPLE_Files_Num;
                    int n2 = Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num;
            
                    if (View_Select_Create_Modify == 4) {
                      
                      if (Modify_Object_Parameters == 1) { // Pick 
                        if (n <= n1) { // case: people 
                          Create_Mesh_Person_Type = n;
                        }
                        else { // case: trees
                          Create_Mesh_Plant_Type = n - n1;
                        }
                      } 
                      if ((Modify_Object_Parameters == 2) || (Modify_Object_Parameters == 3)) { // Assign
                        if (n <= n1) { // case: people 
                          allObject2D_MAP[OBJ_NUM] = sign_n * Create_Mesh_Person_Type;
                        }
                        else { // case: trees
                          allObject2D_MAP[OBJ_NUM] = sign_n * (Create_Mesh_Plant_Type + n1);
                        }
                      }
                    }
                  }      
                  
                  
                  if (Work_with_2D_or_3D == 1) {
      
                    int OBJ_NUM = int(RxP[4]);
                      
                    if (Modify_Object_Parameters == 1) { // Pick 
                      if (View_Select_Create_Modify == 8) Create_Fractal_Plant_DegreeMax = allFractal_DegreeMax[OBJ_NUM];
                      if (View_Select_Create_Modify == 9) {Create_Fractal_Plant_DegreeMax = allFractal_DegreeMax[OBJ_NUM]; Create_Fractal_Plant_DegreeMin = allFractal_DegreeMin[OBJ_NUM];}
                      if (View_Select_Create_Modify == 10) Create_Fractal_Plant_DegreeMin = allFractal_DegreeMin[OBJ_NUM];
                      if (View_Select_Create_Modify == 11) Create_Fractal_Plant_TrunkSize = allFractal_TrunkSize[OBJ_NUM];
                      if (View_Select_Create_Modify == 12) Create_Fractal_Plant_LeafSize = allFractal_LeafSize[OBJ_NUM];
                      if (View_Select_Create_Modify == 13) { // all properties
                        Create_Fractal_Plant_DegreeMax = allFractal_DegreeMax[OBJ_NUM];
                        Create_Fractal_Plant_DegreeMin = allFractal_DegreeMin[OBJ_NUM];
                        Create_Fractal_Plant_TrunkSize = allFractal_TrunkSize[OBJ_NUM];
                        Create_Fractal_Plant_LeafSize = allFractal_LeafSize[OBJ_NUM];
                      }                      
                    } 
                    if (Modify_Object_Parameters == 2) { //Assign
                      if (View_Select_Create_Modify == 8) allFractal_DegreeMax[OBJ_NUM] = Create_Fractal_Plant_DegreeMax;                    
                      if (View_Select_Create_Modify == 9) {allFractal_DegreeMax[OBJ_NUM] = Create_Fractal_Plant_DegreeMax; allFractal_DegreeMin[OBJ_NUM] = Create_Fractal_Plant_DegreeMin;}                 
                      if (View_Select_Create_Modify == 10) allFractal_DegreeMin[OBJ_NUM] = Create_Fractal_Plant_DegreeMin;                    
                      if (View_Select_Create_Modify == 11) allFractal_TrunkSize[OBJ_NUM] = Create_Fractal_Plant_TrunkSize;                    
                      if (View_Select_Create_Modify == 12) allFractal_LeafSize[OBJ_NUM] = Create_Fractal_Plant_LeafSize;
                      if (View_Select_Create_Modify == 13) { // all properties
                        allFractal_DegreeMax[OBJ_NUM] = Create_Fractal_Plant_DegreeMax;
                        allFractal_DegreeMin[OBJ_NUM] = Create_Fractal_Plant_DegreeMin;                    
                        allFractal_TrunkSize[OBJ_NUM] = Create_Fractal_Plant_TrunkSize;                    
                        allFractal_LeafSize[OBJ_NUM] = Create_Fractal_Plant_LeafSize;                    
                      }                      
                    }
                  }                        
               
                  WIN3D_Update = 1;                 
                  ROLLOUT_Update = 1;                  
                } 
                else if ((View_Select_Create_Modify != 0) && (View_Select_Create_Modify != 1)) { // PickSelect also if scale, rotate, modify, etc. where selected
                
                  if (addNewSelectionToPreviousSelection == 0) SOLARCHVISION_deselectAll();

                  if (Work_with_2D_or_3D == 5) {
      
                    int f = int(RxP[4]);
                    
                    int OBJ_NUM = 0;
                    float min_dist = FLOAT_undefined;  
                    
                    for (int j = 0; j < allFaces[f].length; j++) {
                      int vNo = allFaces[f][j];
          
                      float x = allVertices[vNo][0];
                      float y = allVertices[vNo][1];          
                      float z = allVertices[vNo][2];
                      
                      float now_dist = dist(x, y, z, RxP[0], RxP[1], RxP[2]);
                      
                      if (min_dist > now_dist) {
                        min_dist = now_dist;
                        OBJ_NUM = vNo;
                      } 
                    }
                    
                    if (OBJ_NUM != 0) {
                    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
        
                        for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
                          if (selectedVertex_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedVertex_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedVertex_numbers, found_at + 1);
                        
                        selectedVertex_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedVertex_numbers = (int[]) concat(selectedVertex_numbers, new_OBJ_number);
                      }
                    }
                    
                    
                    //if (pre_selectedVertex_numbers_lastItem != selectedVertex_numbers[selectedVertex_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 2");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }

                  if (Work_with_2D_or_3D == 4) {
      
                    int OBJ_NUM = int(RxP[4]);
                    
                    if (OBJ_NUM != 0) {
                    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
        
                        for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
                          if (selectedFace_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedFace_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedFace_numbers, found_at + 1);
                        
                        selectedFace_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedFace_numbers = (int[]) concat(selectedFace_numbers, new_OBJ_number);
                      }
                    }
                    
                    
                    //if (pre_selectedFace_numbers_lastItem != selectedFace_numbers[selectedFace_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 3");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }
                  
                  if (Work_with_2D_or_3D == 3) {
      
                    int f = int(RxP[4]);
                    
                    int OBJ_NUM = 0;
                    
                    for (int i = 0; i < allPolymesh_Faces.length; i++) {
                      if ((allPolymesh_Faces[i][0] <= f) && (f <= allPolymesh_Faces[i][1])) {
                        
                        OBJ_NUM = i;
                        
                        WIN3D_Update = 1;
                        break;
                      }
                    }
                    
                    if (OBJ_NUM != 0) {
                    
                      int found_at = -1;
                      
                      int use_it = 0; // 0:nothing 1:add -1:subtract
                      
                      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                      
                      if (addNewSelectionToPreviousSelection != 0) {
        
                        for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
                          if (selectedPolymesh_numbers[o] == OBJ_NUM) {
                            found_at = o;
                            if (addNewSelectionToPreviousSelection == 1) {
                              use_it = 0;
                            }
                            if (addNewSelectionToPreviousSelection == -1) {
                              use_it = -1; 
                            }
                            break;
                          } 
                        }
                      }
                      
                      if (use_it == -1) {
                        int[] startList = (int[]) subset(selectedPolymesh_numbers, 0, found_at);
                        int[] endList = (int[]) subset(selectedPolymesh_numbers, found_at + 1);
                        
                        selectedPolymesh_numbers = (int[]) concat(startList, endList);
                      }
                      
                      if (use_it == 1) {
                        int[] new_OBJ_number = {OBJ_NUM};
                        
                        selectedPolymesh_numbers = (int[]) concat(selectedPolymesh_numbers, new_OBJ_number);
                      }
                    }
                    
                    
                    //if (pre_selectedPolymesh_numbers_lastItem != selectedPolymesh_numbers[selectedPolymesh_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 4");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }
      
                  if (Work_with_2D_or_3D == 2) {
      
                    int OBJ_NUM = int(RxP[4]);
      
                    int found_at = -1;
                    
                    int use_it = 0; // 0:nothing 1:add -1:subtract
                    
                    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                    if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                    
                    if (addNewSelectionToPreviousSelection != 0) {
      
                      for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
                        if (selectedObject2D_numbers[o] == OBJ_NUM) {
                          found_at = o;
                          if (addNewSelectionToPreviousSelection == 1) {
                            use_it = 0;
                          }
                          if (addNewSelectionToPreviousSelection == -1) {
                            use_it = -1; 
                          }
                          break;
                        } 
                      }
                    }
                    
                    if (use_it == -1) {
                      int[] startList = (int[]) subset(selectedObject2D_numbers, 0, found_at);
                      int[] endList = (int[]) subset(selectedObject2D_numbers, found_at + 1);
                      
                      selectedObject2D_numbers = (int[]) concat(startList, endList);
                    }
                    
                    if (use_it == 1) {
                      int[] new_OBJ_number = {OBJ_NUM};
                      
                      selectedObject2D_numbers = (int[]) concat(selectedObject2D_numbers, new_OBJ_number);
                    }
      
                    WIN3D_Update = 1;
                    
                    //if (pre_selectedObject2D_numbers_lastItem != selectedObject2D_numbers[selectedObject2D_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 5");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }
      
                  if (Work_with_2D_or_3D == 1) {
                    
                    int OBJ_NUM = int(RxP[4]);
  
                    int found_at = -1;
                    
                    int use_it = 0; // 0:nothing 1:add -1:subtract
                    
                    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                    if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                    
                    if (addNewSelectionToPreviousSelection != 0) {
      
                      for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
                        if (selectedFractal_numbers[o] == OBJ_NUM) {
                          found_at = o;
                          if (addNewSelectionToPreviousSelection == 1) {
                            use_it = 0;
                          }
                          if (addNewSelectionToPreviousSelection == -1) {
                            use_it = -1; 
                          }
                          break;
                        } 
                      }
                    }
                    
                    if (use_it == -1) {
                      int[] startList = (int[]) subset(selectedFractal_numbers, 0, found_at);
                      int[] endList = (int[]) subset(selectedFractal_numbers, found_at + 1);
                      
                      selectedFractal_numbers = (int[]) concat(startList, endList);
                    }
                    
                    if (use_it == 1) {
                      int[] new_OBJ_number = {OBJ_NUM};
                      
                      selectedFractal_numbers = (int[]) concat(selectedFractal_numbers, new_OBJ_number);
                    }
                    
                    WIN3D_Update = 1;

                    //if (pre_selectedFractal_numbers_lastItem != selectedFractal_numbers[selectedFractal_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 6");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }

                  if (Work_with_2D_or_3D == 8) {
                    
                    int OBJ_NUM = int(RxP[4]);
  
                    int found_at = -1;
                    
                    int use_it = 0; // 0:nothing 1:add -1:subtract
                    
                    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
                    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
                    if (addNewSelectionToPreviousSelection == -1) use_it = 0;
                    
                    if (addNewSelectionToPreviousSelection != 0) {
      
                      for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
                        if (selectedSection_numbers[o] == OBJ_NUM) {
                          found_at = o;
                          if (addNewSelectionToPreviousSelection == 1) {
                            use_it = 0;
                          }
                          if (addNewSelectionToPreviousSelection == -1) {
                            use_it = -1; 
                          }
                          break;
                        } 
                      }
                    }
                    
                    if (use_it == -1) {
                      int[] startList = (int[]) subset(selectedSection_numbers, 0, found_at);
                      int[] endList = (int[]) subset(selectedSection_numbers, found_at + 1);
                      
                      selectedSection_numbers = (int[]) concat(startList, endList);
                    }
                    
                    if (use_it == 1) {
                      int[] new_OBJ_number = {OBJ_NUM};
                      
                      selectedSection_numbers = (int[]) concat(selectedSection_numbers, new_OBJ_number);
                    }
                    
                    WIN3D_Update = 1;

                    //if (pre_selectedSection_numbers_lastItem != selectedSection_numbers[selectedSection_numbers.length - 1]) {
                      println("SOLARCHVISION_calculate_selection_Pivot 6b");
                      SOLARCHVISION_calculate_selection_Pivot();
                    //}
                  }
                    
                }      
              }
              
              if (View_Select_Create_Modify == 0) { // create
    
                int keep_number_of_Polymeshes = allPolymesh_Faces.length;
                int keep_number_of_2DObjects = allObject2D_XYZS.length;
                int keep_number_of_Fractals = allFractal_XYZSRA.length;
                int keep_number_of_Sections = allSection_UVERAB.length;
                
                float x = RxP[0]; 
                float y = RxP[1]; 
                float z = RxP[2];             
  
                float rot = Create_Input_Orientation;
                if (rot == 360) rot = 15 * (int(random(24)));
      
                float rx = 0.5 * Create_Input_Length;
                if (rx < 0) rx = random(0.25 * abs(rx), abs(rx));
      
                float ry = 0.5 * Create_Input_Width;
                if (ry < 0) ry = random(0.25 * abs(ry), abs(ry));
      
                float rz = 0.5 * Create_Input_Height;
                if (rz < 0) rz = random(0.25 * abs(rz), abs(rz));
      
                
                  
                float px = Create_Input_powX; 
                float py = Create_Input_powY;
                float pz = Create_Input_powZ;
                
                if (Create_Input_powRnd == 1) {
                  px = pow(2, int(random(5)) - 1);
                  py = px;
                  pz = px;
                }
                  
                if (Create_Input_Volume != 0) {
                            
                  if ((rx != 0) && (ry != 0)) {
                    rz = Create_Input_Volume / (8 * rx * ry);
                  }
                  
                  //---------------------------------------------------
                  float A = 1; 
                  // cube volume: 8*r^3, sphere volume: 4*r^3, so maybe:
                  if (pz >= 8) A = 1;
                  else if (pz == 4) A = 0.75;
                  else if (pz == 2) A = 0.5;
                  else if (pz == 1) A = 0.25;
                  else if (pz == 0.5) A = 0.125;
                  else if (pz == 0.25) A = 0.0625;
                  
                  rx /= pow(A, (1.0 / 3.0));
                  ry /= pow(A, (1.0 / 3.0));
                  rz /= pow(A, (1.0 / 3.0));
                  //---------------------------------------------------
                }
  
                x -= rx * selection_alignX;
                y -= ry * selection_alignY;
                z -= rz * selection_alignZ;
                
                int SOLID_created = 0;
                
                if (Create_Mesh_SuperOBJ == 1) {
    
                  if ((px == CubePower) && (py == CubePower) && (pz == 2)) {
                    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                    
                    SOLARCHVISION_add_ParametricSurface(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx, ry, rz, 2, rot);
                  }
                  
                  else if ((px == 2) && (py == 2) && (pz == CubePower)) {
                    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                    
                    SOLARCHVISION_add_SuperCylinder(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx,ry,rz, Create_Cylinder_Degree, rot);
                  }                
      
                  else if ((px == CubePower) && (py == CubePower) && (pz == CubePower)) {
                    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                    
                    SOLARCHVISION_add_Box_Core(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x,y,z, rx,ry,rz, rot);
                  }
                  
                  else if ((px == 1) && (py == 1) && (pz == 1)) {
                    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                    
                    SOLARCHVISION_add_Octahedron(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x,y,z, rx,ry,rz, rot);
                  }
                  
                  else {
                    addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                    
                    SOLARCHVISION_add_SuperSphere(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x,y,z, pz,py,pz, rx,ry,rz, Create_Sphere_Degree, rot);
                  }
                  
                  
                  
                  
                  if (Create_Mesh_or_Solid == 2) {
                    SOLARCHVISION_addToSolids(1, x,y,z, px,py,pz, rx,ry,rz, 0,0,rot);
                    
                    SOLID_created = 1;
                  }                
                }
                
                 
                
                
  
                  
                if (Create_Mesh_Tri == 1) {
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; 
                  
                  SOLARCHVISION_add_Mesh3(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x-rx, y-ry, z-rz, x+rx, y-ry, z-rz, x, y, z+rz);
                  SOLARCHVISION_add_Mesh3(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x+rx, y-ry, z-rz, x+rx, y+ry, z-rz, x, y, z+rz);
                  SOLARCHVISION_add_Mesh3(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x+rx, y+ry, z-rz, x-rx, y+ry, z-rz, x, y, z+rz);
                  SOLARCHVISION_add_Mesh3(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x-rx, y+ry, z-rz, x-rx, y-ry, z-rz, x, y, z+rz);
                }
                
                if (Create_Mesh_Quad == 1) {
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; 
                  
                  SOLARCHVISION_add_Mesh4(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x-rx, y-ry, z-rz, x+rx, y-ry, z+rz, x+rx, y+ry, z-rz, x-rx, y+ry, z+rz);
                }
                
                if (Create_Mesh_Poly == 1) {
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; 
                  
                  SOLARCHVISION_add_PolygonHyper(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx, 2 * rz, Create_Poly_Degree, rot);
                }
    
                if (Create_Mesh_Extrude == 1) {       
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1;
                  
                  SOLARCHVISION_add_PolygonExtrude(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx, 2 * rz, Create_Poly_Degree, rot);
                }
    
                if (Create_Mesh_House == 1) {   
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; 
       
                  SOLARCHVISION_add_House_Core(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx, ry, rz, ry, rot);
                }
    
                if (Create_Mesh_Parametric != 0) {
                  addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; 
                  
                  SOLARCHVISION_add_ParametricSurface(Create_Default_Material, Create_Default_Tessellation,  Create_Default_Layer,  Create_Default_Visibility, Create_Default_SolarPivotType, x, y, z, rx, ry, rz, Create_Mesh_Parametric_Type, rot);
                }
    
                if (Create_Fractal_Plant != 0) {
                  //addToLastPolymesh = 0; SOLARCHVISION_beginNewObject(); addToLastPolymesh = 1; // maybe requiered if passing as solid! 
                  
                  float as_Solid = 1;
                  
                  randomSeed(millis());
                  SOLARCHVISION_add_FractalPlant(Create_Fractal_Plant_Type, x, y, z, 2 * rz, rot, Create_Fractal_Plant_DegreeMin, Create_Fractal_Plant_DegreeMax, Create_Fractal_Plant_Seed, Create_Fractal_Plant_TrunkSize, Create_Fractal_Plant_LeafSize, as_Solid);
                }      
  
                if (Create_Mesh_Plant != 0) {
                  int n = 0;
                  if (Create_Mesh_Plant_Type > 0) n = Create_Mesh_Plant_Type + Object2D_PEOPLE_Files_Num;
    
                  randomSeed(millis());
                  SOLARCHVISION_add_Object2D("TREES", n, x, y, z, 2 * rz);
                }    
    
                if (Create_Mesh_Person != 0) {
                  
                  randomSeed(millis());
                  SOLARCHVISION_add_Object2D("PEOPLE", Create_Mesh_Person_Type, x, y, z, 2.5);
                }
                
                
    
                if (keep_number_of_Polymeshes != allPolymesh_Faces.length) { // if any 3D-mesh created during the process
                  
                  selectedPolymesh_numbers = new int [2];
                  selectedPolymesh_numbers[0] = 0;
                  selectedPolymesh_numbers[1] = allPolymesh_Faces.length - 1;
                  
                  println("SOLARCHVISION_calculate_selection_Pivot 7");
                  SOLARCHVISION_calculate_selection_Pivot();
                }
                
                if (keep_number_of_2DObjects != allObject2D_XYZS.length) { // if any 2D-mesh created during the process

                  selectedObject2D_numbers = new int [2];
                  selectedObject2D_numbers[0] = 0;
                  selectedObject2D_numbers[1] = allObject2D_XYZS.length - 1;
                  
                  println("SOLARCHVISION_calculate_selection_Pivot 8");
                  SOLARCHVISION_calculate_selection_Pivot();
                }            
    
                if (keep_number_of_Fractals != allFractal_XYZSRA.length) { // if any Fractal created during the process

                  selectedFractal_numbers = new int [2];
                  selectedFractal_numbers[0] = 0;
                  selectedFractal_numbers[1] = allFractal_XYZSRA.length - 1;
                  
                  println("SOLARCHVISION_calculate_selection_Pivot 9");
                  SOLARCHVISION_calculate_selection_Pivot();
                } 
                
                if (keep_number_of_Sections != allSection_UVERAB.length) { // if any Fractal created during the process

                  selectedSection_numbers = new int [2];
                  selectedSection_numbers[0] = 0;
                  selectedSection_numbers[1] = allSection_UVERAB.length - 1;
                  
                  println("SOLARCHVISION_calculate_selection_Pivot 9b");
                  SOLARCHVISION_calculate_selection_Pivot();
                }                 
                
                if (SOLID_created != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections(); //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              
              }
              
            }          
            
            WIN3D_Update = 1;
    
          }       
        }
        
        ROLLOUT_Update = 1;
        
        redraw();
      }
    }
  } 
}
 
int isInside (float x, float y, float x1, float y1, float x2, float y2) {
  if ((x1 < x) && (x < x2) && (y1 < y) && (y < y2)) return 1;
  else return 0;
} 




class SOLARCHVISION_Spinner { 
  float x_Plot, y_Plot;
  float new_value;
  
  SOLARCHVISION_Spinner () {  
  }
  
  float update (float x, float y, int update1, int update2, int update3, String caption, float v, float min_v, float max_v, float stp_v) {
    x_Plot = x; 
    y_Plot = y;
    new_value = v;
    
    if (new_value < min_v) new_value = max_v; 
    if (new_value > max_v) new_value = min_v;    
    
    float cx, cy, cr;
    float w1, w2, h, o, t_o; 
    
    //w1 = 32.5 * ROLLOUT_S_View;
    //w2 = 142.5 * ROLLOUT_S_View;
    
    w1 = 100 * ROLLOUT_S_View;
    w2 = 200 * ROLLOUT_S_View;
    
    h = 16 * ROLLOUT_S_View;
    o = 2 * ROLLOUT_S_View;
    t_o = h * ROLLOUT_S_View / 8.0;
    
    Y_control += 25 * ROLLOUT_S_View; //(h + 2 * o) * 1.25;

    strokeWeight(0); 
    stroke(0); 
    fill(0);
    rect(x + o, y - (h / 2) - o, 0.5 * (h + 2 * o) , 0.5 * (h + 2 * o));
    rect(x + o, y - (h / 2) - o + 0.5 * (h + 2 * o), 0.5 * (h + 2 * o) , 0.5 * (h + 2 * o));
    stroke(255); 
    fill(255);
    cx = x + o + 0.25 * (h + 2 * o);
    cy = y - (h / 2) - o + 0.25 * (h + 2 * o);
    cr = 0.25 * (h + 2 * o);
    triangle(cx + cr * cos_ang(270), cy + 0.75 * cr * sin_ang(270), cx + 0.75 * cr * cos_ang(30), cy + 0.75 * cr * sin_ang(30), cx + 0.75 * cr * cos_ang(150), cy + 0.75 * cr * sin_ang(150));
    
    if (isInside(X_clicked, Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {
      if (mouseButton == LEFT) {
      
        if (stp_v < 0) {
          new_value *= abs(stp_v); 
        }
        else { 
          new_value += abs(stp_v);
        }
      }
      else if (mouseButton == RIGHT) {
        
        new_value = max_v;
      }
    }
    
    cy += 2 * cr;
    triangle(cx + cr * cos_ang(90), cy + 0.75 * cr * sin_ang(90), cx + 0.75 * cr * cos_ang(210), cy + 0.75 * cr * sin_ang(210), cx + 0.75 * cr * cos_ang(330), cy + 0.75 * cr * sin_ang(330));

    if (isInside(X_clicked, Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {
      
      if (mouseButton == LEFT) {
      
        if (stp_v < 0) {
          new_value /= abs(stp_v); 
        }
        else { 
          new_value -= abs(stp_v);
        }
      }
      else if (mouseButton == RIGHT) {
        
        new_value = min_v;
      }
    }

    if (new_value < min_v) new_value = max_v; 
    if (new_value > max_v) new_value = min_v; 
    


    strokeWeight(0); 
    stroke(191); 
    fill(191);
    rect(x - (w1 + w2) - o, y - (h / 2) - o, (w1 + w2) + 2 * o, h + 2 * o);

    stroke(255); 
    fill(255);
    rect(x - w1, y - (h / 2), w1, h);

    float q = 0;
    
    if (max_v - min_v > 0.001) {
       q = (new_value - min_v) / (max_v - min_v);
    }
      
    if (isInside(X_clicked, Y_clicked, x - w1, y - (h / 2), x, y + (h / 2)) == 1) {
      
      q = 1;

      if (max_v - min_v > 0.001) {
         q = (X_clicked - (x - w1)) / w1;
      }
      
      new_value = min_v + q * (max_v - min_v);

      if (new_value < min_v) new_value = max_v; 
      if (new_value > max_v) new_value = min_v;
     
      ROLLOUT_Update = 1; 
    }
    
    strokeWeight(0); 
    stroke(191,255,191); 
    fill(191,255,191);
    rect(x - w1, y - (h / 2), q * w1, h);          
    
    
    strokeWeight(2); 
    stroke(0); 
    noFill();
    rect(x - w1, y - (h / 2), w1, h);    

    strokeWeight(0);
    stroke(0); 
    fill(0);
    textSize(1.0 * h);
    textAlign(RIGHT, CENTER);
    if ((new_value == int(new_value)) || (new_value >= 100)) {
      text(String.valueOf(int(new_value)), x - t_o, y - t_o);
    }
    else {
      text(nf(new_value, 0, 0), x - t_o, y - t_o);
    }

    
    strokeWeight(0);
    stroke(0); 
    fill(0);
    //textSize(1.0 * h);
    textSize(0.85 * h);
    //textAlign(RIGHT, CENTER); text(caption + ":", x - w1 - t_o, y - t_o);
    textAlign(LEFT, CENTER); text(caption + ":", x - w1 - w2 + t_o, y - t_o);

    if (new_value != v) {
      if (update1 != 0) STUDY_Update = 1;
      if (update2 != 0) WIN3D_Update = 1;
      if (update3 != 0) WORLD_Update = 1;
    }

    return new_value;
  }
}



String[][] ROLLOUTS = {
                        {"Location & Data", "Point", "Weather", "Environment"}, 
                        {"Geometries & Space", "General", "Create", "Modify", "Solid", "Surface", "Living", "Viewport", "Simulation"},
                        {"Time & Scenarios", "Period", "Ranges", "Filters"}, 
                        {"Illustration Options", "2D-Layers", "2D-Colors", "3D-Solar", "3D-Spatial", "Selection"},
                        {"Post-Processing", "Interpolation", "Developed", "Impacts"}, 
                        {"Export Products", "Data", "Media", "Launch"}
                      };

int ROLLOUT_parent = 0; // 0: Location, 1: Geometry, 2: Time, etc.
int ROLLOUT_child = 1; // number of the category inside e.g. 1, 2, ...



void SOLARCHVISION_draw_ROLLOUT () {
  
  stroke(255); 
  fill(255);
  strokeWeight(0);
  rect(ROLLOUT_CX_View, ROLLOUT_CY_View, ROLLOUT_X_View, ROLLOUT_Y_View);
  

  float h = 20 * ROLLOUT_S_View;

  X_control = ROLLOUT_CX_View;
  Y_control = ROLLOUT_CY_View;
  
  X_control += 307.5 * ROLLOUT_S_View;
  Y_control += 7.5 * ROLLOUT_S_View;

  if (ROLLOUT_parent >= ROLLOUTS.length) {
    ROLLOUT_parent = ROLLOUTS.length - 1;
  }
  
  if (ROLLOUT_child >= ROLLOUTS[ROLLOUT_parent].length) {
    ROLLOUT_child = ROLLOUTS[ROLLOUT_parent].length - 1;
  }  
  
  if (ROLLOUT_parent < ROLLOUTS.length) {
    
    for (int i = 0; i < ROLLOUTS.length; i++) {

      float cx = ROLLOUT_CX_View + (150 * (i % 2) + 5) * ROLLOUT_S_View;
      float cy = Y_control;
      float cr = 6.75 * ROLLOUT_S_View;      
      
      textAlign(LEFT, CENTER);    

      if (isInside(X_clicked, Y_clicked, cx, cy - cr, cx + 150 * ROLLOUT_S_View, cy + cr) == 1) {
        ROLLOUT_parent = i;
        ROLLOUT_child = 1; // <<<<<
        
        ROLLOUT_Update = 1;
      }

      if (i == ROLLOUT_parent) {
        strokeWeight(2); 
        stroke(63); 
        fill(191);
        rect(cx - 2.5 * ROLLOUT_S_View, cy - 5 * ROLLOUT_S_View, 150 * ROLLOUT_S_View, 2 * 7.5 * ROLLOUT_S_View);
        strokeWeight(0); 
        
        stroke(0); 
        fill(0);
        textSize(15 * ROLLOUT_S_View);
      }
      else {
        stroke(127); 
        fill(127);
        textSize(15 * ROLLOUT_S_View);
      }

      text(nf(i + 1, 0) + ":" + ROLLOUTS[i][0], cx, cy);

      if (i % 2 == 1) Y_control += 15 * ROLLOUT_S_View;
    }
    
    strokeWeight(2); 
    stroke(63); 
    fill(63);
    rect(ROLLOUT_CX_View, Y_control, ROLLOUT_X_View, 17.5 * ceil((ROLLOUTS[ROLLOUT_parent].length - 1) / 3.0) * ROLLOUT_S_View);
    strokeWeight(0);    

    Y_control += 5 * ROLLOUT_S_View;
    
    for (int i = 1; i < ROLLOUTS[ROLLOUT_parent].length; i++) {

      float cx = ROLLOUT_CX_View + (100 * ((i - 1) % 3) + 10) * ROLLOUT_S_View;
      float cy = Y_control;
      float cr = 6.75 * ROLLOUT_S_View;        
      
      textAlign(LEFT, CENTER);     
      
      if (isInside(X_clicked, Y_clicked, cx, cy - cr, cx + 100 * ROLLOUT_S_View, cy + cr) == 1) {
        ROLLOUT_child = i;
        
        ROLLOUT_Update = 1;
      }      
      
      if (i == ROLLOUT_child) {
        stroke(255,127,0); 
        fill(255,127,0);
        textSize(15 * ROLLOUT_S_View);
      }
      else {
        stroke(255); 
        fill(255);
        textSize(12.5 * ROLLOUT_S_View);
      }
              
      text("[" + nf(i, 0) + "]" + ROLLOUTS[ROLLOUT_parent][i], cx, cy);
      
      if (i % 3 == 0) Y_control += 15 * ROLLOUT_S_View;
    }
    
    if (ROLLOUTS[ROLLOUT_parent].length % 3 != 1) Y_control += 15 * ROLLOUT_S_View;
    
    Y_control += 15 * ROLLOUT_S_View;
    
    
    
  }




  if (ROLLOUT_parent == 0) { // Location & data


    if (ROLLOUT_child == 1) { // Point
      //Selected_STATION = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Selected:" + DEFINED_STATIONS[Selected_STATION][0], Selected_STATION, 0, DEFINED_STATIONS.length - 1, 1), 1));
      //LOAD_STATION = int(roundTo(MySpinner.update(X_control, Y_control, 1,1,1, "LOAD_STATION", LOAD_STATION, 0, 1, 1), 1));
      //STATION_NUMBER = int(roundTo(MySpinner.update(X_control, Y_control, 1,1,1, "Loaded:" + DEFINED_STATIONS[STATION_NUMBER][0], STATION_NUMBER, 0, DEFINED_STATIONS.length - 1, 1), 1));
  

      //WORLD_VIEW_Auto = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Map Auto Fit", WORLD_VIEW_Auto, 0, 1, 1), 1));
      //WORLD_VIEW_Number = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Map Viewport", WORLD_VIEW_Number, 0, number_of_WORLD_viewports - 1, 1), 1));

      LocationLatitude = MySpinner.update(X_control, Y_control, 0,0,1, "Latitude", LocationLatitude, -85, 85, LocationLatitude_step);
      LocationLongitude = MySpinner.update(X_control, Y_control, 0,0,1, "Longitude", LocationLongitude, -180, 180, LocationLongitude_step);
      LocationElevation = MySpinner.update(X_control, Y_control, 0,0,1, "Elevation", LocationElevation, -100, 8000, LocationElevation_step);

      LocationLatitude_step = MySpinner.update(X_control, Y_control, 0,0,0, "Latitude_step", LocationLatitude_step, 0.001, 10, -2);
      LocationLongitude_step = MySpinner.update(X_control, Y_control, 0,0,0, "Longitude_step", LocationLongitude_step, 0.001, 10, -2);
      LocationElevation_step = MySpinner.update(X_control, Y_control, 0,0,0, "Elevation_step", LocationElevation_step, 0.125, 1024, -2);
      
      Display_SWOB_points = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_SWOB_points" , Display_SWOB_points, 0, 2, 1), 1));
      Display_SWOB_nearest = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_SWOB_nearest" , Display_SWOB_nearest, 0, 1, 1), 1));

      Display_NAEFS_points = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_NAEFS_points" , Display_NAEFS_points, 0, 2, 1), 1));
      Display_NAEFS_nearest = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_NAEFS_nearest" , Display_NAEFS_nearest, 0, 1, 1), 1));

      Display_CWEEDS_points = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_CWEEDS_points" , Display_CWEEDS_points, 0, 2, 1), 1));
      Display_CWEEDS_nearest = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_CWEEDS_nearest" , Display_CWEEDS_nearest, 0, 1, 1), 1));

      Display_EPW_points = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_EPW_points" , Display_EPW_points, 0, 2, 1), 1));
      Display_EPW_nearest = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Display_EPW_nearest" , Display_EPW_nearest, 0, 1, 1), 1));        
    }

    if (ROLLOUT_child == 2) { // Weather

      Load_ENSEMBLE = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Load_ENSEMBLE" , Load_ENSEMBLE, 0, 1, 1), 1));
      Load_CLIMATE_WY2 = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Load_CLIMATE_WY2" , Load_CLIMATE_WY2, 0, 1, 1), 1));
      Load_CLIMATE_EPW = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Load_CLIMATE_EPW" , Load_CLIMATE_EPW, 0, 1, 1), 1));
      Load_OBSERVED = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Load_OBSERVED" , Load_OBSERVED, 0, 1, 1), 1));
      
      STUDY_max_j_end_observations = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Days of recent observations to load" , STUDY_max_j_end_observations, 0, 31, 1), 1));
      Download_OBSERVED = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Download_OBSERVED" , Download_OBSERVED, 0, 1, 1), 1));
      Download_ENSEMBLE = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Download_ENSEMBLE" , Download_ENSEMBLE, 0, 1, 1), 1));
      
      Download_AERIAL = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Download_AERIAL" , Download_AERIAL, 0, 1, 1), 1));
      
      GRIB2_Hour_Start = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Hour_Start" , GRIB2_Hour_Start, 0, 48, 1), 1));
      GRIB2_Hour_End = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Hour_End" , GRIB2_Hour_End, 0, 48, 1), 1));
      GRIB2_Hour_Step = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Hour_Step" , GRIB2_Hour_Step, 1, 24, 1), 1));
      
      GRIB2_Layer_Start = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Layer_Start" , GRIB2_Layer_Start, 0, num_layers, 1), 1));
      GRIB2_Layer_End = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Layer_End" , GRIB2_Layer_End, 0, num_layers, 1), 1));
      GRIB2_Layer_Step = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "GRIB2_Layer_Step" , GRIB2_Layer_Step, 1, num_layers, 1), 1));
      
    }
    
    if (ROLLOUT_child == 3) { // Environment
   
      Download_LAND_MESH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Download_LAND_MESH" , Download_LAND_MESH, 0, 1, 1), 1));
      Load_LAND_MESH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Load_LAND_MESH" , Load_LAND_MESH, 0, 1, 1), 1));
      Skip_LAND_MESH_Center = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Skip_LAND_MESH_Center" , Skip_LAND_MESH_Center, 0, LAND_n_I - 1, 1), 1));
      Display_LAND_MESH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_LAND_MESH" , Display_LAND_MESH, 0, 1, 1), 1));
      Display_LAND_TEXTURE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_LAND_TEXTURE" , Display_LAND_TEXTURE, 0, 1, 1), 1));     
      Display_LAND_DEPTH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_LAND_DEPTH" , Display_LAND_DEPTH, 0, 1, 1), 1));

      Display_Trees_People = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_Trees_People" , Display_Trees_People, 0, 1, 1), 1));
      Display_FractalPlant = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_FractalPlant" , Display_FractalPlant, 0, 1, 1), 1));
      Display_Leaves = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_Leaves" , Display_Leaves, 0, 1, 1), 1));
      Display_Building_Model = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_Building_Model" , Display_Building_Model, 0, 1, 1), 1));

      Display_URBAN_MESH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_URBAN_MESH" , Display_URBAN_MESH, 0, 1, 1), 1));
      
      Display_Sections = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_Sections" , Display_Sections, 0, 1, 1), 1));



      Display_WindRose_Image = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_WindRose_Image" , Display_WindRose_Image, 0, 1, 1), 1));

      WindRose3D_scale = MySpinner.update(X_control, Y_control, 0,1,0, "WindRose3D_scale" , WindRose3D_scale, 50, 3200, -2);
      WindRose_RES = int(MySpinner.update(X_control, Y_control, 0,1,0, "WindRose3D_resolution" , WindRose_RES, 200, 600, 100));
      

      
      Display_SKY3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_SKY3D" , Display_SKY3D, 0, 1, 1), 1));
      
      Display_SUN3D_Path = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_SUN3D_Path" , Display_SUN3D_Path, 0, 1, 1), 1));
      Display_SUN3D_Pattern = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_SUN3D_Pattern" , Display_SUN3D_Pattern, 0, 1, 1), 1));
      

      Display_TROPO3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_TROPO3D" , Display_TROPO3D, 0, 1, 1), 1));
      //Display_TROPO3D_TEXTURE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_TROPO3D_TEXTURE" , Display_TROPO3D_TEXTURE, 0, 1, 1), 1));      

      Display_EARTH3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_EARTH3D" , Display_EARTH3D, 0, 1, 1), 1));
      //Display_EARTH3D_TEXTURE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_EARTH3D_TEXTURE" , Display_EARTH3D_TEXTURE, 0, 1, 1), 1));

      Display_MOON3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_MOON3D" , Display_MOON3D, 0, 1, 1), 1));
      //Display_MOON3D_TEXTURE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_MOON3D_TEXTURE" , Display_MOON3D_TEXTURE, 0, 1, 1), 1));

      Display_STAR3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_STAR3D" , Display_STAR3D, 0, 1, 1), 1));
      //Display_STAR3D_TEXTURE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_STAR3D_TEXTURE" , Display_STAR3D_TEXTURE, 0, 1, 1), 1));      
      
      planetary_magnification = MySpinner.update(X_control, Y_control, 0,1,0, "planetary_magnification" , planetary_magnification, 1, 100, 1.0);

      
    }
    

  }
  else if (ROLLOUT_parent == 1) { // Geometries & Space

    if (ROLLOUT_child == 1) { // General

      Create_Mesh_or_Solid = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Mesh_or_Solid" , Create_Mesh_or_Solid, 1, 2, 1), 1));
    
      //Work_with_2D_or_3D = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Work_with_2D_or_3D" , Work_with_2D_or_3D, 1, 8, 1), 1));
    
      //View_Select_Create_Modify = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "View_Select_Create_Modify" , View_Select_Create_Modify, -17, 17, 1), 1));
      //View_XYZ_ChangeOption = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "View_XYZ_ChangeOption" , View_XYZ_ChangeOption, 0, 6, 1), 1));
      //Modify_Object_Parameters = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Object_Parameters" , Modify_Object_Parameters, 0, 9, 1), 1));


      
      MODEL3D_TESSELLATION = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "MODEL3D_TESSELLATION" , MODEL3D_TESSELLATION, 0, 4, 1), 1));
      
      LAND_TESSELLATION = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "LAND_TESSELLATION" , LAND_TESSELLATION, 0, 5, 1), 1));
      
      SKY3D_TESSELLATION = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_TESSELLATION" , SKY3D_TESSELLATION, 0, 5, 1), 1));   
      SKY3D_scale = MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_scale" , SKY3D_scale, 0.0000001, 1000000, -2);

      OBJECTS_scale = MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_scale" , OBJECTS_scale, 0.0000001, 1000000, -2);      

      Load_URBAN_MESH = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Load_URBAN_MESH" , Load_URBAN_MESH, 0, 1, 1), 1));

      MODEL1D_ERASE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "MODEL1D_ERASE" , MODEL1D_ERASE, 0, 1, 1), 1));
    
      MODEL2D_ERASE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "MODEL2D_ERASE" , MODEL2D_ERASE, 0, 1, 1), 1));
      
      MODEL3D_ERASE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "MODEL3D_ERASE" , MODEL3D_ERASE, 0, 1, 1), 1));
      
      SECTION_ERASE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SECTION_ERASE" , SECTION_ERASE, 0, 1, 1), 1));
   
      Load_Default_Models = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Load_Default_Models" , Load_Default_Models, 0, MAX_Default_Models_Number, 1), 1));
    }
    


    if (ROLLOUT_child == 2) { // Create


      

      Create_Default_Material = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Default_Material" , Create_Default_Material, -1, 8, 1), 1));
      Create_Default_Tessellation = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Default_Tessellation" , Create_Default_Tessellation, 0, 4, 1), 1));
      Create_Default_Layer = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Default_Layer" , Create_Default_Layer, 0, 16, 1), 1));
      Create_Default_Visibility = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Default_Visibility" , Create_Default_Visibility, -1, 1, 1), 1));
      Create_Default_SolarPivotType = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Default_SolarPivotType" , Create_Default_SolarPivotType, 0, 4, 1), 1));
  
      Create_Input_Orientation = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_Orientation" , Create_Input_Orientation, 0, 360, 15);
      
      Create_Input_Length = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_Length" , Create_Input_Length, -100, 100, 1); 
      Create_Input_Width = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_Width" , Create_Input_Width, -100, 100, 1);
      Create_Input_Height = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_Height" , Create_Input_Height, -100, 100, 1);    
      
      Create_Input_Volume = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_Volume" , Create_Input_Volume, 0, 25000, 1000);    
  
    }    
    
    if (ROLLOUT_child == 3) { // Modify
    
      Modify_Input_OpenningDepth = MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_OpenningDepth" , Modify_Input_OpenningDepth, -10, 10, 0.1);
      Modify_Input_OpenningArea = MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_OpenningArea" , Modify_Input_OpenningArea, 0, 1, 0.05);
      Modify_Input_OpenningDeviation = MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_OpenningDeviation" , Modify_Input_OpenningDeviation, 0, 1, 0.05);
 
      Modify_Input_TessellateRows = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_TessellateRows" , Modify_Input_TessellateRows, 1, 100, 1), 1));
      Modify_Input_TessellateColumns = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_TessellateColumns" , Modify_Input_TessellateColumns, 1, 100, 1), 1));
      
      Modify_Input_OffsetAmount = MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_OffsetAmount" , Modify_Input_OffsetAmount, 0, 25, 0.001);
      
      Modify_Input_WeldTreshold = MySpinner.update(X_control, Y_control, 0,0,0, "Modify_Input_WeldTreshold" , Modify_Input_WeldTreshold, 0, 10, 0.001);      

      softSelection_Power = MySpinner.update(X_control, Y_control, 0,0,0, "softSelection_Power" , softSelection_Power, 0.125, 8, -2);
      softSelection_Radius = MySpinner.update(X_control, Y_control, 0,0,0, "softSelection_Radius" , softSelection_Radius, 0.01, 100, -2);
    
      selected_posVector = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_posVector" , selected_posVector, 0, 3, 1), 1));
      selected_rotVector =  int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_rotVector" , selected_rotVector, 0, 2, 1), 1));
      selected_scaleVector =  int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_scaleVector" , selected_scaleVector, 0, 3, 1), 1));
    
      selected_posValue = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_posValue" , selected_posValue, -50, 50, 1), 1));
      selected_rotValue = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_rotValue" , selected_rotValue, -180, 180, 5), 5)); 
      selected_scaleValue = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selected_scaleValue" , selected_scaleValue, -8, 8, 0.5), 0.5)); 
  
      selection_alignX = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selection_alignX" , selection_alignX, -1, 1, 1), 1));
      selection_alignY = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selection_alignY" , selection_alignY, -1, 1, 1), 1));
      selection_alignZ = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selection_alignZ" , selection_alignZ, -1, 1, 1), 1));
  
    }

    if (ROLLOUT_child == 4) { // Solid
    
      Create_Mesh_SuperOBJ = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Mesh_SuperOBJ" , Create_Mesh_SuperOBJ, 0, 1, 1), 1));

      //Create_Input_powRnd = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_powRnd" , Create_Input_powRnd, 0, 1, 1), 1));    
      Create_Input_powAll = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_powAll" , Create_Input_powAll, 0.5, CubePower, -2);
      Create_Input_powX = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_powX" , Create_Input_powX, 0.5, CubePower, -2); 
      Create_Input_powY = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_powY" , Create_Input_powY, 0.5, CubePower, -2); 
      Create_Input_powZ = MySpinner.update(X_control, Y_control, 0,0,0, "Create_Input_powZ" , Create_Input_powZ, 0.5, CubePower, -2);

    }  

    if (ROLLOUT_child == 5) { // Surface

      Create_Sphere_Degree = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Sphere_Degree" , Create_Sphere_Degree, 0, 5, 1), 1));      
      
      Create_Cylinder_Degree = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Cylinder_Degree" , Create_Cylinder_Degree, 3, 36, 1), 1));    

      Create_Poly_Degree = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Poly_Degree" , Create_Poly_Degree, 3, 36, 1), 1));

      Create_Mesh_Parametric_Type = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Mesh_Parametric_Type" , Create_Mesh_Parametric_Type, 0, 7, 1), 1));
      Create_Mesh_Person_Type = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Mesh_Person_Type" , Create_Mesh_Person_Type, 0, Object2D_PEOPLE_Files_Num, 1), 1));
      Create_Mesh_Plant_Type = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Mesh_Plant_Type" , Create_Mesh_Plant_Type, 0, Object2D_TREES_Files_Num, 1), 1));

    }

    if (ROLLOUT_child == 6) { // Living

      Create_Fractal_Plant = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant" , Create_Fractal_Plant, 0, 1, 1), 1));
      Create_Fractal_Plant_Type = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_Type" , Create_Fractal_Plant_Type, 0, 0, 1), 1));
      Create_Fractal_Plant_DegreeMin = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_DegreeMin" , Create_Fractal_Plant_DegreeMin, 1, 9, 1), 1));
      Create_Fractal_Plant_DegreeMax = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_DegreeMax" , Create_Fractal_Plant_DegreeMax, 1, 9, 1), 1));
      Create_Fractal_Plant_Seed = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_Seed" , Create_Fractal_Plant_Seed, -1, 100, 1), 1));
      Create_Fractal_Plant_TrunkSize = roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_TrunkSize" , Create_Fractal_Plant_TrunkSize, 0, 10, 0.1), 0.1);
      Create_Fractal_Plant_LeafSize = roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Create_Fractal_Plant_LeafSize" , Create_Fractal_Plant_LeafSize, 0, 10, 0.1), 0.1);    
    }    
    

    if (ROLLOUT_child == 7) { // Viewport
    
      //WIN3D_FACES_SHADE = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "WIN3D_FACES_SHADE", WIN3D_FACES_SHADE, 0, number_of_shading_options - 1, 1), 1));

      Display_MODEL3D_EDGES = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_MODEL3D_EDGES" , Display_MODEL3D_EDGES, 0, 1, 1), 1));
      Display_MODEL3D_NORMALS = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_MODEL3D_NORMALS" , Display_MODEL3D_NORMALS, 0, 1, 1), 1));
      
      CAM_clipNear = MySpinner.update(X_control, Y_control, 0,1,0, "CAM_clipNear" , CAM_clipNear, 0.0001, 1000000000, -2);
      CAM_clipFar = MySpinner.update(X_control, Y_control, 0,1,0, "CAM_clipFar" , CAM_clipFar, 0.0001, 1000000000, -2);
    }    
  

    if (ROLLOUT_child == 8) { // Simulation

      Day_of_Impact_to_Display = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Day_of_Impact_to_Display" , Day_of_Impact_to_Display, 0, STUDY_j_end - STUDY_j_start, 1), 1));

      Display_SolarImpact_Image = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_SolarImpact_Image" , Display_SolarImpact_Image, 0, 1, 1), 1));
      Display_SpatialImpact_Image = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Display_SpatialImpact_Image" , Display_SpatialImpact_Image, 0, 1, 1), 1));

      SolarImpact_sectionType = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SolarImpact_sectionType" , SolarImpact_sectionType, 0, 3, 1), 1));      
      SpatialImpact_sectionType = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_sectionType" , SpatialImpact_sectionType, 0, 3, 1), 1));


      SpatialImpact_Grade = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Grade" , SpatialImpact_Grade, 0.0001, 64.0, -2);
      SpatialImpact_Power = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Power" , SpatialImpact_Power, 0.0001, 64.0, -2);      
      SpatialImpact_Rotation[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Rotation[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_Rotation[SpatialImpact_sectionType], -360, 360, -2);
      SpatialImpact_Elevation[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Elevation[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_Elevation[SpatialImpact_sectionType], -1000, 1000, -2);
      SpatialImpact_positionStep = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_positionStep" , SpatialImpact_positionStep, 5, 80, -2);
      
      SpatialImpact_scale_U[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_scale_U[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_scale_U[SpatialImpact_sectionType], 0.125, 3200, -2);
      SpatialImpact_scale_V[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_scale_V[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_scale_V[SpatialImpact_sectionType], 0.125, 3200, -2);
      SpatialImpact_offset_U[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_offset_U[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_offset_U[SpatialImpact_sectionType], -10000, 10000, -2);
      SpatialImpact_offset_V[SpatialImpact_sectionType] = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_offset_V[" + nf(SpatialImpact_sectionType, 0) + "]" , SpatialImpact_offset_V[SpatialImpact_sectionType], -10000, 10000, -2);
      
    
      SpatialImpact_Wspd = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Wspd (m/s)" , SpatialImpact_Wspd, 1, 16, -2); 
      SpatialImpact_Wdir = MySpinner.update(X_control, Y_control, 0,1,0, "SpatialImpact_Wdir" , SpatialImpact_Wdir, 0, 360, 15);
      

      PROCESS_subdivisions = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "PROCESS_subdivisions" , PROCESS_subdivisions, 0, 3, 1), 1));

      Display_SpatialImpact_Points = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Display_SpatialImpact_Points" , Display_SpatialImpact_Points, 0, 1, 1), 1));
      Display_SpatialImpact_Lines = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Display_SpatialImpact_Lines" , Display_SpatialImpact_Lines, 0, 1, 1), 1));

      Display_windFlow = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Display_windFlow" , Display_windFlow, 0, 1, 1), 1));
      
  
    }    


    
    
  }
  else if (ROLLOUT_parent == 2) { // Time & Scenarios
    
    if (ROLLOUT_child == 1) { // Period

      STUDY_j_end = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Number of days to plot" , STUDY_j_end, 1, 61, 1), 1));
    
      BEGIN_DAY = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Plot start date" , BEGIN_DAY, 0, 364, 1), 1));
    
      //_DATE = MySpinner.update(X_control, Y_control, 1,0,0, "Solar date", _DATE, 0, 364.5, 0.5);
      _DATE = int(MySpinner.update(X_control, Y_control, 1,0,0, "Solar date", _DATE, 0, 364, 1));
      
      _DAY = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Forecast day" , _DAY, 1, 31, 1), 1));
      _MONTH = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Forecast month", _MONTH, 1, 12, 1), 1));
      _YEAR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Forecast year" , _YEAR, 1953, 2100, 1), 1));

  
    }
   
    if (ROLLOUT_child == 2) { // Ranges
      STUDY_i_start = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Start hour" , STUDY_i_start, 0, 23, 1), 1));
      STUDY_i_end = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "End hour" , STUDY_i_end, 0, 23, 1), 1));

      num_add_days = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "num_add_days" , num_add_days, 1, 64, -2), 1));
    }

    if (ROLLOUT_child == 3) { // Filters
      sky_scenario = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Sky status", sky_scenario, 1, 4, 1), 1));
      filter_type = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Hourly/daily filter", filter_type, 0, 1, 1), 1));

      H_layer_option = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Climate filter option" , H_layer_option, -1, 6, 1), 1));
      Sample_Year_start = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Start year" , Sample_Year_start, CLIMATE_WY2_start, CLIMATE_WY2_end, 1), 1));
      Sample_Year_end = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "End year" , Sample_Year_end, CLIMATE_WY2_start, CLIMATE_WY2_end, 1), 1));
    
      F_layer_option = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Forecast filter option" , F_layer_option, -1, 4, 1), 1));
      Sample_Member_start = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Start member" , Sample_Member_start, ENSEMBLE_start, ENSEMBLE_end, 1), 1));  
      Sample_Member_end = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "End member" , Sample_Member_end, ENSEMBLE_start, ENSEMBLE_end, 1), 1));
      
      O_layer_option = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Observation filter option" , O_layer_option, -1, 1, 1), 1));
      Sample_Station_start = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Start station" , Sample_Station_start, OBSERVED_start, OBSERVED_end, 1), 1));  
      Sample_Station_end = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "End station" , Sample_Station_end, OBSERVED_start, OBSERVED_end, 1), 1));      
    

    }
    
  }  
  else if (ROLLOUT_parent == 3) { // Display Options

    if (ROLLOUT_child == 1) { // 2D-Layers
      
      frame_variation = int(roundTo(MySpinner.update(X_control, Y_control, 1,1,1, "Frame layout variation", frame_variation, 0, 3, 1), 1));
    
      STUDY_setup = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Diagram setup", STUDY_setup, -2, 14, 1), 1));
      
      STUDY_Update = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Redraw scene", STUDY_Update, 0, 1, 1), 1));  
    
      STUDY_drw_Layer = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Layer", STUDY_drw_Layer, 0, (num_layers - 1), 1), 1));
      STUDY_V_scale[STUDY_drw_Layer] = MySpinner.update(X_control, Y_control, 1,0,0, "V_scale[" + nf(STUDY_drw_Layer, 2) + "]", STUDY_V_scale[STUDY_drw_Layer], 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));      

      draw_data_lines = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Draw data", draw_data_lines, 0, 1, 1), 1));
      draw_sorted = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Draw sorted", draw_sorted, 0, 1, 1), 1));
      draw_normals = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Draw statistics", draw_normals, 0, 1, 1), 1));
      draw_probs = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Draw probabilities", draw_probs, 0, 1, 1), 1));
      sum_interval = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Probabilities interval", sum_interval, 1, 24, 1), 1));
      level_pix = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Probabilities range", level_pix, 2, 32, -2), 1));    

    }
    
    if (ROLLOUT_child == 2) { // 2D-Colors
    
      //COLOR_STYLE = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Hourly color scheme", COLOR_STYLE, -1, (n_COLOR_STYLE - 1), 1), 1));
   
      STUDY_Pallet_ACTIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_ACTIVE_CLR", STUDY_Pallet_ACTIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      STUDY_Pallet_ACTIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_ACTIVE_DIR", STUDY_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      STUDY_Pallet_ACTIVE_MLT = MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_ACTIVE_MLT", STUDY_Pallet_ACTIVE_MLT, 0.125, 8, -2);
      
      STUDY_Pallet_PASSIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PASSIVE_CLR", STUDY_Pallet_PASSIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      STUDY_Pallet_PASSIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PASSIVE_DIR", STUDY_Pallet_PASSIVE_DIR, -1, 1, 2), 1));
      STUDY_Pallet_PASSIVE_MLT = MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PASSIVE_MLT", STUDY_Pallet_PASSIVE_MLT, 0.125, 8, -2);       

      STUDY_Pallet_SORT_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_SORT_CLR", STUDY_Pallet_SORT_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      STUDY_Pallet_SORT_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_SORT_DIR", STUDY_Pallet_SORT_DIR, -1, 1, 2), 1));
      STUDY_Pallet_SORT_MLT = MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_SORT_MLT", STUDY_Pallet_SORT_MLT, 0.125, 8, -2);

      STUDY_Pallet_PROB_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PROB_CLR", STUDY_Pallet_PROB_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      STUDY_Pallet_PROB_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PROB_DIR", STUDY_Pallet_PROB_DIR, -1, 1, 2), 1));
      STUDY_Pallet_PROB_MLT = MySpinner.update(X_control, Y_control, 1,0,0, "STUDY_Pallet_PROB_MLT", STUDY_Pallet_PROB_MLT, 0.125, 8, -2);
      
      STUDY_O_scale = MySpinner.update(X_control, Y_control, 1,0,0, "Windose opacity scale", STUDY_O_scale, 1, 100, -pow(2.0, (1.0 / 4.0)));
    }
    
    if (ROLLOUT_child == 3) { // 3D-Solar 
      
      OBJECTS_Pallet_ACTIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      OBJECTS_Pallet_ACTIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      OBJECTS_Pallet_ACTIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT, 0.125, 8, -2);
      
      OBJECTS_Pallet_PASSIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      OBJECTS_Pallet_PASSIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR, -1, 1, 2), 1));
      OBJECTS_Pallet_PASSIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT, 0.125, 8, -2);

      SKY3D_Pallet_ACTIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_ACTIVE_CLR", SKY3D_Pallet_ACTIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      SKY3D_Pallet_ACTIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_ACTIVE_DIR", SKY3D_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      SKY3D_Pallet_ACTIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_ACTIVE_MLT", SKY3D_Pallet_ACTIVE_MLT, 0.125, 8, -2);
      
      SKY3D_Pallet_PASSIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_PASSIVE_CLR", SKY3D_Pallet_PASSIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      SKY3D_Pallet_PASSIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_PASSIVE_DIR", SKY3D_Pallet_PASSIVE_DIR, -1, 1, 2), 1));
      SKY3D_Pallet_PASSIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "SKY3D_Pallet_PASSIVE_MLT", SKY3D_Pallet_PASSIVE_MLT, 0.125, 8, -2);
  
      SunPath3D_Pallet_ACTIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_ACTIVE_CLR", SunPath3D_Pallet_ACTIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      SunPath3D_Pallet_ACTIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_ACTIVE_DIR", SunPath3D_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      SunPath3D_Pallet_ACTIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_ACTIVE_MLT", SunPath3D_Pallet_ACTIVE_MLT, 0.125, 8, -2);
      
      SunPath3D_Pallet_PASSIVE_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_PASSIVE_CLR", SunPath3D_Pallet_PASSIVE_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      SunPath3D_Pallet_PASSIVE_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_PASSIVE_DIR", SunPath3D_Pallet_PASSIVE_DIR, -1, 1, 2), 1));
      SunPath3D_Pallet_PASSIVE_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "SunPath3D_Pallet_PASSIVE_MLT", SunPath3D_Pallet_PASSIVE_MLT, 0.125, 8, -2);

    }
    
    

    
    if (ROLLOUT_child == 4) { // 3D-Spatial   
    
      SPATIAL_Pallet_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SPATIAL_Pallet_CLR", SPATIAL_Pallet_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      SPATIAL_Pallet_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "SPATIAL_Pallet_DIR", SPATIAL_Pallet_DIR, -1, 1, 2), 1));
      SPATIAL_Pallet_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "SPATIAL_Pallet_MLT", SPATIAL_Pallet_MLT, 0.0001, 64, -2);      

      ELEVATION_Pallet_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      ELEVATION_Pallet_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR, -1, 1, 2), 1));
      ELEVATION_Pallet_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT, 0.01, 1.0, -2);   

      windFlow_Pallet_CLR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "windFlow_Pallet_CLR", windFlow_Pallet_CLR, -1, (n_COLOR_STYLE - 1), 1), 1));
      windFlow_Pallet_DIR = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "windFlow_Pallet_DIR", windFlow_Pallet_DIR, -1, 1, 2), 1));
      windFlow_Pallet_MLT = MySpinner.update(X_control, Y_control, 0,1,0, "windFlow_Pallet_MLT", windFlow_Pallet_MLT, 0.01, 1.0, -2);  
      
      
      

    }      
    
    
    if (ROLLOUT_child == 5) { // Selection
    
      selectedPolymesh_displaySolarPivots = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedPolymesh_displaySolarPivots" , selectedPolymesh_displaySolarPivots, 0, 1, 1), 1));
      selectedPolymesh_displayPivot = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedPolymesh_displayPivot" , selectedPolymesh_displayPivot, 0, 1, 1), 1));
      selectedPolymesh_displayBox = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedPolymesh_displayBox" , selectedPolymesh_displayBox, 0, 1, 1), 1));
      selectedPolymesh_displayEdges = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedPolymesh_displayEdges" , selectedPolymesh_displayEdges, 0, 1, 1), 1));
      
      selectedFace_displayEdges = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedFace_displayEdges" , selectedFace_displayEdges, 0, 1, 1), 1));
      selectedFace_displayVertexCount = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedFace_displayVertexCount" , selectedFace_displayVertexCount, 0, 1, 1), 1));
      selectedVertex_displayVertices = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedVertex_displayVertices" , selectedVertex_displayVertices, 0, 1, 1), 1));
      
      selectedObject2D_displayEdges = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedObject2D_displayEdges" , selectedObject2D_displayEdges, 0, 1, 1), 1));
      selectedFractal_displayEdges = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedFractal_displayEdges" , selectedFractal_displayEdges, 0, 1, 1), 1));
      
      selectedSection_displayEdges = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "selectedSection_displayEdges" , selectedSection_displayEdges, 0, 1, 1), 1));

    }      
  
  }
  else if (ROLLOUT_parent == 4) { // Post-Processing
  
    if (ROLLOUT_child == 1) { // Interpolation
    
      interpolation_weight = MySpinner.update(X_control, Y_control, 1,0,0, "interpolation_weight", interpolation_weight, 0, 5, 0.5);
      Climatic_solar_forecast = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Climate-based solar forecast", Climatic_solar_forecast, 0, 1, 1), 1));
      Climatic_weather_forecast = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Climate-based temperature forecast", Climatic_weather_forecast, 0, 2, 1), 1));    
    
    } 
    if (ROLLOUT_child == 2) { // Developed
      develop_option = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "develop_option" , develop_option, 0, 11, 1), 1));
      develop_per_day = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "develop_per_day" , develop_per_day, 0, 3, 1), 1));
    
      join_hour_numbers = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Trend period hours", join_hour_numbers, 1, 24 * 16, 1), 1));
      join_type = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Weighted/equal trend", join_type, -1, 1, 2), 1));

      Angle_inclination = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Inclination angle", Angle_inclination, 0, 90, 5), 1));
      Angle_orientation = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Orientation angle", Angle_orientation, 0, 360, 15), 1));    
    }
    if (ROLLOUT_child == 3) { // Impacts
      impacts_source = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Impacts Source", impacts_source, 0, 3, 1), 1));
      impact_layer = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Impact Min/50%/Max", impact_layer, 0, 8, 1), 1));
      update_impacts = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Update impacts", update_impacts, 0, 1, 1), 1));    
    }
    

  
  }   
  else if (ROLLOUT_parent == 5) { // Export Products

    if (ROLLOUT_child == 1) { // Data
    
      Export_STUDY_info_node = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Export ASCII data", Export_STUDY_info_node, 0, 1, 1), 1));
      Export_STUDY_info_norm = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Export ASCII statistics", Export_STUDY_info_norm, 0, 1, 1), 1));
      Export_STUDY_info_prob = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Export ASCII probabilities", Export_STUDY_info_prob, 0, 1, 1), 1));

      objExportPrecisionVertex = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportPrecisionVertex" , objExportPrecisionVertex, 0, 6, 1), 1));
      objExportPrecisionVtexture = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportPrecisionVtexture" , objExportPrecisionVtexture, 0, 6, 1), 1));
      objExportPolyToPoly = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportPolyToPoly" , objExportPolyToPoly, 0, 1, 1), 1));
      
      objExportMaterialLibrary = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportMaterialLibrary" , objExportMaterialLibrary, 0, 1, 1), 1));
      objExportBackSides = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportBackSides" , objExportBackSides, 0, 1, 1), 1));
      objExportCombinedMaterial = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportCombinedMaterial" , objExportCombinedMaterial, 0, 1, 1), 1));      
      objExportBakingResolution = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "objExportBakingResolution" , objExportBakingResolution, 0, 1, 1), 1));
      

      Display_Output_in_Explorer = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Display_Output_in_Explorer", Display_Output_in_Explorer, 0, 1, 1), 1));
    }  
  
    if (ROLLOUT_child == 2) { // Media

      STUDY_record_PDF = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Record Time Graph in PDF", STUDY_record_PDF, 0, 1, 1), 1));
      STUDY_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Record Time Graph in JPG", STUDY_record_JPG, 0, 1, 1), 1));

      WORLD_record_PDF = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Record Location Graph in PDF", WORLD_record_PDF, 0, 1, 1), 1));
      WORLD_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,1, "Record Location Graph in JPG", WORLD_record_JPG, 0, 1, 1), 1));

      WIN3D_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,1,0, "Record 3D-Model Graph in JPG", WIN3D_record_JPG, 0, 1, 1), 1));

      FRAME_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Screenshot in JPG", FRAME_record_JPG, 0, 1, 1), 1));
      FRAME_click_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Screenshot with click mark", FRAME_click_JPG, 0, 1, 1), 1));
      FRAME_drag_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Screenshot with drag mark", FRAME_drag_JPG, 0, 1, 1), 1));
      
      SpatialImpact_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Record SpatialImpact in JPG", SpatialImpact_record_JPG, 0, 1, 1), 1));
      SpatialImpact_record_PDF = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Record SpatialImpact in PDF", SpatialImpact_record_PDF, 0, 1, 1), 1));
      
      SolarImpact_record_JPG = int(roundTo(MySpinner.update(X_control, Y_control, 0,0,0, "Record Solar Analysis in JPG", SolarImpact_record_JPG, 0, 1, 1), 1));
    }
    
    if (ROLLOUT_child == 3) { // Launch
      
      Ensemble_Audio_Output = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Ensemble_Audio_Output", Ensemble_Audio_Output, 0, 1, 1), 1));
      Launch_External_Simulation = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Launch_External_Simulation", Launch_External_Simulation, 0, 1, 1), 1));
      Launch_External_Hardware = int(roundTo(MySpinner.update(X_control, Y_control, 1,0,0, "Launch_External_Hardware", Launch_External_Hardware, 0, 1, 1), 1));
      
    }    
    
  }    

  if (ROLLOUT_include == 1) {
    if (isInside(X_clicked, Y_clicked, ROLLOUT_CX_View, ROLLOUT_CY_View, ROLLOUT_CX_View + ROLLOUT_X_View, ROLLOUT_CY_View + ROLLOUT_Y_View) == 1) {  
      X_clicked = -1;
      Y_clicked = -1;
    }
  }
}


SOLARCHVISION_Spinner MySpinner = new SOLARCHVISION_Spinner(); 



//---------------------------------------------------------------------






void SOLARCHVISION_try_update_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {

  GRIB2_YEAR = begin_YEAR;
  GRIB2_MONTH = begin_MONTH;
  GRIB2_DAY = begin_DAY;
  GRIB2_RUN = 0; //begin_HOUR; // <<<<<<<<<<<<<<<

  

  
  AERIAL = new float [49][num_layers][AERIAL_num][Scenarios_max];
  AERIAL_Flag = new int [49][num_layers][AERIAL_num][Scenarios_max];
  AERIAL_Locations = new float [AERIAL_num][3]; // lon, lat, tgl
  AERIAL_Center_Longitude = LocationLongitude;
  AERIAL_Center_Latitude = LocationLatitude;

  for (int h = 0; h < GRIB2_TGL_number; h += 1) {
    GRIB2_TGL_Selected[h] = 0; // deselect all layers first.
  }

  for (int n = 0; n < AERIAL_num; n += 1) {
    for (int k = 0; k <= 48; k += 1) {
      for (int l = 0; l < num_layers; l++) {
        for (int o = 0; o < Scenarios_max; o += 1){   
          AERIAL[k][l][n][o] = FLOAT_undefined;
          AERIAL_Flag[k][l][n][o] = -1;        
        }
      }
    }  
    
    
    float stp_lat = 20.0 / 2224.5968; // equals to 1km <<<<<<<<
    float stp_lon = stp_lat / cos_ang(AERIAL_Center_Latitude); 
    
    
    float r1 = float(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][5]);
    float r = 0; 
    float t = 0; 
    
    int p = n / (1 + 6 + 12);
    int q = n % (1 + 6 + 12);

    if ((q > 0) && (q <= 6)) {
      r = 1 * r1;
      t = 360 * q / 6.0;
    }  

    if ((q > 6) && (q <= 18)) {
      r = 2 * r1;
      t = 360 * (q - 6) / 12.0;
    }  

    if ((q > 18) && (q <= 36)) {
      r = 3 * r1;
      t = 360 * (q - 18) / 18.0;
    }  
    
    float _tgl = 40 * p;
   
    if (_tgl == 0) _tgl = 10; // <<<<<<  
    
    AERIAL_Locations[n][0] = AERIAL_Center_Longitude + stp_lon * r * cos_ang(t);
    AERIAL_Locations[n][1] = AERIAL_Center_Latitude + stp_lat * r * sin_ang(t);
    AERIAL_Locations[n][2] = _tgl;
  
    GRIB2_TGL_Selected[p] = 1;
  }  


  String the_directory = getGrib2Folder(GRIB2_DOMAIN_SELECTION);
  {  
    String[] tmpMessage = {nf(GRIB2_YEAR, 4), nf(GRIB2_MONTH, 2), nf(GRIB2_DAY, 2), nf(GRIB2_RUN, 2)};
    // Creates two temp files to make the destination folders if they were not available.
    saveStrings(Wgrib2TempFolder + "/TempEmpty.txt", tmpMessage);
    saveStrings(the_directory + "/TempEmpty.txt", tmpMessage);
  }
  
  String[] SavedFiles = sort(getfiles(the_directory));
  
  for (int h = 0; h < GRIB2_TGL_number; h += 1) {
    
    if (GRIB2_TGL_Selected[h] != 0) {
  
      for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
        GRIB2_Layer = l;
        
        for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
          GRIB2_Hour = k;
          
          String the_filename = getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);
          
          int File_Found = 0;
    
          for (int i = SavedFiles.length - 1; i >= 0; i--) {
            String thisFile = the_directory + "/" + SavedFiles[i];
            
            if (thisFile.equals(the_directory + "/" + the_filename)) {
              File_Found = 1;
              break;
            }
          }

          String the_link = "";
          
          if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("WAVE")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][1] + "/" + nf(GRIB2_RUN, 2) + "/" + the_filename;  
          }
          if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("HRDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][1] + "/" + nf(GRIB2_RUN, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }
          if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("RDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][1] + "/" + nf(GRIB2_RUN, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }          
          if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("GDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][1] + "/" + nf(GRIB2_RUN, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }
          if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("GEPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][1] + "/" + nf(GRIB2_RUN, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }
    
          if (File_Found == 0) {
    
            String the_target = the_directory + "/" + the_filename;
    
            try {
              println("Downloading...", the_link);
              saveBytes(the_target, loadBytes(the_link));
              println("100%");
              File_Found = 1;
            } 
            catch (Exception e) {
    
            }  
          }
          
          if (File_Found == 1) {
            /*

            for (int n = 0; n < AERIAL_num; n += 1) {
    
              LocationLongitude = AERIAL_Locations[n][0];
              LocationLatitude = AERIAL_Locations[n][1];
            
              int o = 0; // now only for deterministic!
              AERIAL[GRIB2_Hour][GRIB2_Layer][n][o] = getGrib2Value(GRIB2_Hour, GRIB2_Layer, h, AERIAL_Locations[n][0], AERIAL_Locations[n][1]); 
              
            }

            */
              
            float[][] Points = {{0,0,0}};
            int Points_num = 1;
            
            for (int n = 0; n < AERIAL_num; n += 1) {
              int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
              
              if (p == h) {
              
                float[][] newPoint = {{AERIAL_Locations[n][0], AERIAL_Locations[n][1], AERIAL_Locations[n][2]}};
                Points = (float[][]) concat(Points, newPoint);
                
                Points_num += 1;
              }
            }
                          
            if (Points_num > 1) {
              
              float[][] GRIB2_values = getGrib2Value_MultiplePoints(GRIB2_Hour, GRIB2_Layer, h, Points, the_link);
              
              int nPoint = 0;
              
              for (int n = 0; n < AERIAL_num; n += 1) {
                int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
                
                if (p == h) {

                  nPoint += 1;
                  
                  for (int o = 0; o < Scenarios_max; o += 1){
                    AERIAL[GRIB2_Hour][GRIB2_Layer][n][o] = GRIB2_values[nPoint][o];
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  
  for (int n = 0; n < AERIAL_num; n += 1) {
    
    int h = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
    
    if ((LAYERS_GRIB2[_winddir][h].substring(0, 4)).equals("UGRD") && (LAYERS_GRIB2[_windspd][h].substring(0, 4)).equals("VGRD")) {

      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
      GRIB2_Hour = k;    
      
        for (int o = 0; o < Scenarios_max; o += 1){
          
          float u = AERIAL[GRIB2_Hour][_winddir][n][o]; // because U component stored in _winddir 
          float v = AERIAL[GRIB2_Hour][_windspd][n][o]; // because U component stored in _windspd
          
          if ((abs(u) < 0.9 * FLOAT_undefined) && (abs(v) < 0.9 * FLOAT_undefined)) { 
            AERIAL[GRIB2_Hour][_windspd][n][o] = 3.6 * pow((pow(u, 2) + pow(v, 2)), 0.5); // now converting from m/s >> Km/h 
            AERIAL[GRIB2_Hour][_winddir][n][o] = 180 + atan2_ang(u, v); // ???????????? range checking?
          }
          
        }
      }
    }
  }


  
  
  for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
    GRIB2_Layer = l;
    
    for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
      GRIB2_Hour = k;

      for (int n = 0; n < AERIAL_num; n += 1) {
        for (int o = 0; o < Scenarios_max; o += 1){
          if (AERIAL[GRIB2_Hour][GRIB2_Layer][n][o] < 0.9 * FLOAT_undefined) {
            AERIAL_Flag[GRIB2_Hour][GRIB2_Layer][n][o] = 1;
          }
          else AERIAL_Flag[GRIB2_Hour][GRIB2_Layer][n][o] = -1;
        }
      }          
    }
  }

  for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
    GRIB2_Layer = l;
    
    for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
      GRIB2_Hour = k;

      for (int n = 0; n < 1; n += 1) { // <<<<<<<<<<<<<<<< For now: only the first point (i.e. the center)
        for (int o = 0; o < Scenarios_max; o += 1){  

          int THE_YEAR = GRIB2_YEAR;
          int THE_MONTH = GRIB2_MONTH;
          int THE_DAY = GRIB2_DAY;
          int THE_HOUR = GRIB2_RUN;

          int now_i = int(THE_HOUR);
          int now_j = Convert2Date(THE_MONTH, THE_DAY);
          
          now_i -= int(-LocationTimeZone / 15);
          if (now_i < 0) {
            now_i += 24;
            now_j -= 1;
            if (now_j < 0) {
              now_j += 365;
            } 
          }          

          int next_i = now_i + k;
          int next_j = now_j;
          if (next_i >= 24) {
            
            next_j += int(next_i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
            }
            
            next_i = next_i % 24;
          }

          
          ENSEMBLE[next_i][next_j][l][43 + o] = AERIAL[GRIB2_Hour][GRIB2_Layer][n][o]; // <<<<<<<<<<< writing after member 43

          println(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0] + "[" + nf(o, 0) + "]:", next_i, next_j, l, ENSEMBLE[next_i][next_j][l][43 + o]);          
          println("GDPS:", next_i, next_j, l, ENSEMBLE[next_i][next_j][l][21]);
        }
      }          
    }
  }

  SOLARCHVISION_postProcess_ENSEMBLE();
  
  F_layer_option = 5;
  STUDY_Update = 1; 
}




String getGrib2Folder (int s) {
  return(Grib2ArchiveFolder + "/FORECAST_" + GRIB2_DOMAINS[s][1]);
}

String getGrib2Filename (int k, int l, int h) {
  String return_txt = "";
  
  String F_L = LAYERS_GRIB2[l][h];
  
  if (l == _winddir) {
    if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][h].equals("GEPS")) {
      F_L = F_L.replace("WDIR", "UGRD");
      LAYERS_GRIB2[l][h] = F_L;      
    }
    else {
      F_L = F_L.replace("UGRD", "WDIR");
      LAYERS_GRIB2[l][h] = F_L;  
    }
  }
  
  if (l == _windspd) {
    if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][h].equals("GEPS")) {
    
      F_L = F_L.replace("WIND", "VGRD");
      LAYERS_GRIB2[l][h] = F_L;
      LAYERS_GRIB2_MUL[l] = 1; // that is for no unit conversion!
    }
    else {
      F_L = F_L.replace("VGRD", "WIND");
      LAYERS_GRIB2[l][h] = F_L;  
      LAYERS_GRIB2_MUL[l] = 3.6; // m/s > Km/h
    }
  }

  if (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][h].equals("GEPS")) {    
    if (F_L.equals("TMP_TGL_2")) F_L += "m";
    if (F_L.equals("RH_TGL_2")) F_L += "m";
    if (F_L.equals("UGRD_TGL_10")) F_L += "m";
    if (F_L.equals("VGRD_TGL_10")) F_L += "m";
  }
    
  return_txt = GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][2] + "_" + F_L + "_" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][3] + "_" + nf(GRIB2_YEAR, 4) + nf(GRIB2_MONTH, 2) + nf(GRIB2_DAY, 2) + nf(GRIB2_RUN, 2) + "_P" + nf(k, 3) + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][4];

  return return_txt;
}


String getWgrib2Filename (int k, int l, int h, float _lon, float _lat) {
  return(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][2] + "_" + nf(GRIB2_YEAR, 4) + nf(GRIB2_MONTH, 2) + nf(GRIB2_DAY, 2) + "R" + nf(GRIB2_RUN, 2) + "P" + nf(k, 3) + "_" + LAYERS_GRIB2[l][h] + "_" + nf(_lon, 0, 4) + "X" + nf(_lat, 0, 4) + ".txt");
}

String getWgrib2Filename_MultiplePoints (int k, int l, int h, int part) {
  return(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][2] + "_" + nf(GRIB2_YEAR, 4) + nf(GRIB2_MONTH, 2) + nf(GRIB2_DAY, 2) + "R" + nf(GRIB2_RUN, 2) + "P" + nf(k, 3) + "_" + LAYERS_GRIB2[l][h] + "_" + nf(LocationLongitude, 0, 4) + "X" + nf(LocationLatitude, 0, 4) + "_part" + nf(part, 3) + ".txt");
}

float getGrib2Value (int k, int l, int h, float _lon, float _lat) {

  float theValue = FLOAT_undefined;

  String ValueFilename = getWgrib2Filename(k, l, h, _lon, _lat); 

  String ValueFile = Wgrib2TempFolder + "/" + ValueFilename;

  String[] filenames = getfiles(Wgrib2TempFolder);

  String[] file_lines = {};

  int runWgrib2 = 1;

  if (filenames != null) {
    for (int i = 0; i < filenames.length; i++) {
      if (filenames[i].equals(ValueFilename)) {

        file_lines = loadStrings(ValueFile);

        if (file_lines.length > 0) {
          //println("The previous extraction file is found:", ValueFilename);
          runWgrib2 = 0;
        }
      }
    }
  }

  if (runWgrib2 == 1) {
    String Grib2File = getGrib2Folder(GRIB2_DOMAIN_SELECTION) + "/" + getGrib2Filename(k, l, h);

    String CommandArguments[] = {
      "wgrib2", Grib2File.replace('/', char(92)), "-s", "-lon", String.valueOf(_lon), String.valueOf(_lat), ">", ValueFile
    };

    String[] the_command = {
      CommandArguments[0] + " " + CommandArguments[1] + " " + CommandArguments[2] + " " + CommandArguments[3] + " " + CommandArguments[4] + " " + CommandArguments[5] + " " + CommandArguments[6]
    };

    println(CommandArguments);
    launch(CommandArguments);
  } 

  int _stay = 1;

  while ((_stay != 0) && (_stay < 100000)) {

    //println(_stay);

    _stay += 1;

    filenames = getfiles(Wgrib2TempFolder);

    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        //println(filenames[i]);

        if (filenames[i].equals(ValueFilename)) {
          //println("The wgrib2 extraction is ready:", ValueFilename);

          file_lines = loadStrings(ValueFile);

          if (file_lines.length > 0) _stay = 0;
        }
      }
    }
  }

  if (_stay != 0) {
    println("The wgrib2 extraction is not ready:", ValueFilename);
  } else {
    //println(file_lines);

    if (file_lines.length > 0) {

      int _posX = file_lines[0].indexOf("lon=");
      int _posY = file_lines[0].indexOf("lat=");
      int _posZ = file_lines[0].indexOf("val=");

      float uX = Float.valueOf(file_lines[0].substring(_posX + 4, _posY - 1));
      float uY = Float.valueOf(file_lines[0].substring(_posY + 4, _posZ - 1));
      
      if (dist_lon_lat((uX + 360) % 360, (uY + 180) % 180, (_lon + 360) % 360, (_lat + 180) % 180) > 5) { // that means the distance should be less than 5km.
        println(uX, uY, _lat, _lat);
        println((uX + 360) % 360, (uY + 180) % 180, (_lon + 360) % 360, (_lat + 180) % 180);
        println("----------------------------------------");
      } else {
        if (_posZ > 0) {
          theValue = Float.valueOf(file_lines[0].substring(_posZ + 4));

          theValue *= LAYERS_GRIB2_MUL[l];
          theValue += LAYERS_GRIB2_ADD[l]; // e.g. Kelvin >> C
        }
      }
    }
  }

  return(theValue);
}




int MAX_GRIB2_PASS = 200;

float[][] getGrib2Value_MultiplePoints (int k, int l, int h, float[][] Points, String the_link) {
  
  // note: the first point is null
  
  float[][] theValues = new float [Points.length][Scenarios_max];
  
  for (int n = 0; n < Points.length; n += 1) {
    for (int o = 0; o < Scenarios_max; o += 1){
      theValues[n][o] = FLOAT_undefined;
    }
  }


  XML my_xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  XML newChild1 = null;
  XML newChild2 = null;
  XML newChild3 = null;
  
  int build_xml = 1;
      
  int next_YEAR = GRIB2_YEAR;
  int next_MONTH = GRIB2_MONTH;
  int next_DAY = GRIB2_DAY;
  int next_HOUR = GRIB2_RUN;
  
  next_HOUR += k;
  if (next_HOUR >= 24) {
    next_HOUR = next_HOUR % 24;
    next_DAY += int((GRIB2_RUN + k) / 24);
    
    if (next_DAY > CalendarLength[(GRIB2_MONTH - 1)]) {
      next_DAY -= CalendarLength[(GRIB2_MONTH - 1)];
      next_MONTH += 1;
      
      if (next_MONTH > 12) {
        next_MONTH = 1;
        next_YEAR += 1; 
      }
    }
  }

  if (build_xml == 1) {
  
    my_xml.setName(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0] + "_forecast");
    
    newChild1 = my_xml.addChild("header");
    
    newChild2 = newChild1.addChild("Domain");
    newChild2.setContent(GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0]);
    
    newChild2 = newChild1.addChild("valid-begin-time");
    newChild2.setContent(nf(GRIB2_YEAR, 4) + "-" + nf(GRIB2_MONTH, 2) + "-" + nf(GRIB2_DAY, 2) + "T" + nf(GRIB2_RUN, 2) + "00:00Z");
  
    newChild2 = newChild1.addChild("model_description");
    newChild3 = newChild2.addChild("model");
    //newChild3.setInt("id", 44);  // ???????????????????????????????????????????????
    newChild3.setString("model", GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0]); 
    newChild3.setString("member", nf(Scenarios_max, 0)); 
    newChild3.setString("center", "CMC"); 
    newChild3.setString("domain", GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][2]);
    newChild3.setString("data_type", "RAW"); 
    newChild3.setString("source", the_link);
    
    if (Scenarios_max == 1) {
      newChild3.setString("member_type", "deterministic");
    }
    else {
      newChild3.setString("member_type", "ensemble");
    }
  
    newChild1 = my_xml.addChild("forecast_element");
    newChild1.setString("code", LAYERS_GRIB2[l][h]); 
    newChild1.setString("unit", LAYERS_Unit[l]); 
    newChild1.setString("title_english", LAYERS_Title[l][_EN]);
    newChild1.setString("titre_francais", LAYERS_Title[l][_FR]);
    
    newChild1 = my_xml.addChild("point_description");
    
    for (int n = 1; n < Points.length; n += 1) {
      newChild2 = newChild1.addChild("point");
      newChild2.setInt("id", n);
      
      newChild2.setString("latitude", nf(Points[n][0], 0, 4).replace(",", "."));
      newChild2.setString("longitude", nf(Points[n][1], 0, 4).replace(",", "."));
      newChild2.setString("TGL", String.valueOf(Points[n][2]));    
    }
  }


  String[] filenames = getfiles(Wgrib2TempFolder);

  String[] file_lines = {};

  int NUM_ValueFiles = 1 + int((Points.length - 1) / MAX_GRIB2_PASS);
  String[] ValueFiles = new String [NUM_ValueFiles];

  for (int p = 0; p < NUM_ValueFiles; p += 1){ 

    String ValueFilename = getWgrib2Filename_MultiplePoints(k, l, h, p); 

    ValueFiles[p] = Wgrib2TempFolder + "/" + ValueFilename;    

    int runWgrib2 = 1;

    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        if (filenames[i].equals(ValueFilename)) {
  
          file_lines = loadStrings(ValueFiles[p]);
  
          if (file_lines.length > 0) {
            //println("The previous extraction file is found:", ValueFilename);
            runWgrib2 = 0;
          }
        }
      }
    }

    if (runWgrib2 == 1) {

      String Grib2File = getGrib2Folder(GRIB2_DOMAIN_SELECTION) + "/" + getGrib2Filename(k, l, h);
    
      String CommandArguments[] = {"wgrib2", Grib2File.replace('/', char(92)), "-s"};
      
      int q_max = MAX_GRIB2_PASS;
      if (p == NUM_ValueFiles - 1) {
        q_max = ((Points.length - 1) % MAX_GRIB2_PASS);
      }

      for (int q = 0; q < q_max; q += 1){
        int f = p * MAX_GRIB2_PASS + q + 1;
        
        float _lon = Points[f][0];
        float _lat = Points[f][1];
        
        //StationI = LOCATIONS_IJ[s][f][0];
        //StationJ = LOCATIONS_IJ[s][f][1];
        
        //if ((GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("GDPS")) || (GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0].equals("GEPS"))) { 
          String[] _add = {"-print", ("station=" + ""), "-lon", nf(360 + _lon, 0,4).replace(",", "."), nf(_lat, 0,4).replace(",", ".")};
          CommandArguments = concat(CommandArguments , _add);
        //}
        //else {
          //String[] _add = {"-print", ("station=" + ""), "-ijlat", String.valueOf(StationI), String.valueOf(StationJ)};
          //CommandArguments = concat(CommandArguments , _add);
        //}
        
      }
      String[] _end = {">", ValueFiles[p]};
      CommandArguments = concat(CommandArguments , _end);
      
      println(CommandArguments);
      launch(CommandArguments);
      
    }


  

    
    int _stay = 1;
  
    while ((_stay != 0) && (_stay < 100000)) {
  
      //println(_stay);
  
      _stay += 1;
  
      filenames = getfiles(Wgrib2TempFolder);
  
      if (filenames != null) {
        for (int i = 0; i < filenames.length; i++) {
          //println(filenames[i]);
  
          if (filenames[i].equals(ValueFilename)) {
            //println("The wgrib2 extraction is ready:", ValueFilename);
  
            file_lines = loadStrings(ValueFiles[p]);
  
            if (file_lines.length > 0) _stay = 0;
          }
        }
      }
    }
    

    if (_stay != 0) {
      println("The wgrib2 extraction is not ready:", ValueFilename);
    } else {
      println(file_lines);
  
      if (file_lines.length > 0) {

        for (int o = 0; o < Scenarios_max; o += 1){       

          String file_one_line_entered = file_lines[o].replace(":station=", "\n");
          String[] my_lines = split(file_one_line_entered, "\n");  
              

          //println(file_one_line_entered);
          //println("lines:", my_lines.length);
          //println("-----------------------------------------------");
              
          if (build_xml == 1) {              
            newChild1 = my_xml.addChild("scenario");
            newChild1.setInt("scenario_id", o + 1); // <<<<<<<<           
            
            newChild2 = newChild1.addChild("forecast");
            newChild2.setInt("forecast_hour", k);
            newChild2.setString("valid_time", nf(next_YEAR, 4) + nf(next_MONTH, 2) + nf(next_DAY, 2) + nf(next_HOUR, 2));
          } 
          
          
          for (int q = 1; q < my_lines.length; q += 1){
            //println(q, my_lines[q]);
    
            int _posX = my_lines[q].indexOf("lon=");
            int _posY = my_lines[q].indexOf("lat=");
            int _posZ = my_lines[q].indexOf("val=");
            
            float uX = Float.valueOf(my_lines[q].substring(_posX + 4, _posY - 1));
            float uY = Float.valueOf(my_lines[q].substring(_posY + 4, _posZ - 1));
            
            float v = FLOAT_undefined;
            
            int f = p * MAX_GRIB2_PASS + q;
            
            float _lon = Points[f][0];
            float _lat = Points[f][1];
            
            if (_lon < 0) _lon += 360; // << important!
    
            float d = dist_lon_lat(uX, uY, _lon, _lat);
            if (d > 200000) { // 200km
            
              println("out of 100km: d =", d);
              
              println(uX, uY, _lon, _lat);
              println("----------------------------------------");
            }
            else {
              if (_posZ > 0) {
                v = Float.valueOf(my_lines[q].substring(_posZ + 4));
               
                //println(v);
                

                  
                v *= LAYERS_GRIB2_MUL[l];
                v += LAYERS_GRIB2_ADD[l]; // e.g. Kelvin >> C                        
                
                if (build_xml == 1) {
                  newChild3 = newChild2.addChild("point");
                  newChild3.setInt("id", f); 
                  newChild3.setContent(nf(v,0,0)); 
                }
                  
              }
            }
            theValues[f][o] = v;
          }
        }

      }
    }
    
  } 

  if (build_xml == 1) { 

    String THE_XML_filename = ExportFolder;
    THE_XML_filename += "/XML_layers/" + GRIB2_DOMAINS[GRIB2_DOMAIN_SELECTION][0];
    THE_XML_filename += "/" + nf(GRIB2_YEAR, 4) + "_" + nf(GRIB2_MONTH, 2) + "_" + nf(GRIB2_DAY, 2) + "_run" + nf(GRIB2_RUN, 2);
    THE_XML_filename += "/" + nfp(AERIAL_Center_Latitude, 2, 3).replace(",", "_").replace(".", "_").replace("+", "N") + nfp(AERIAL_Center_Longitude, 3, 3).replace(",", "_").replace(".", "_").replace("-", "W");
    THE_XML_filename += "/fhr" + nf(k, 3);
    THE_XML_filename += "_" + LAYERS_GRIB2[l][h];
    THE_XML_filename += ".xml";
    saveXML(my_xml, THE_XML_filename);
  }

  return theValues;
}

float[] SOLARCHVISION_calculate_Perspective_Internally (float x, float y, float z) {

  float Image_X = FLOAT_undefined;
  float Image_Y = FLOAT_undefined;
  float Image_Z = -FLOAT_undefined; // negative so that it automatically illuminated by Draw function 
  

  float px, py, pz;

  x -= CAM_x;
  y -= CAM_y;
  z += CAM_z;

  pz = z;
  px = x * cos_ang(-WIN3D_RZ_coordinate) - y * sin_ang(-WIN3D_RZ_coordinate);
  py = x * sin_ang(-WIN3D_RZ_coordinate) + y * cos_ang(-WIN3D_RZ_coordinate);
  
  x = px;
  y = py;
  z = pz;    
  
  px = x;
  py = y * cos_ang(WIN3D_RX_coordinate) - z * sin_ang(WIN3D_RX_coordinate);
  pz = y * sin_ang(WIN3D_RX_coordinate) + z * cos_ang(WIN3D_RX_coordinate);
  
  x = px;
  y = py;
  z = pz;

  
  if (z > 0) {
    if (WIN3D_View_Type == 1) {
      
      Image_X = (x / z) * (0.5 * WIN3D_scale3D / tan(0.5 * CAM_fov)) * refScale;
      Image_Y = -(y / z) * (0.5 * WIN3D_scale3D / tan(0.5 * CAM_fov)) * refScale;
      Image_Z = z;
    }
    else {
      
      float ZOOM = Orthographic_Zoom();

      Image_X = (x / ZOOM) * (0.5 * WIN3D_scale3D);
      Image_Y = -(y / ZOOM) * (0.5 * WIN3D_scale3D);
      Image_Z = z;      
    }
  }
  
  float[] theValues = {Image_X, Image_Y, Image_Z};
  
  return theValues;              
}




void SOLARCHVISION_draw_Perspective_Internally () {

   if (Work_with_2D_or_3D == 8) {

    if (selectedSection_displayEdges != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(255,127,0); 
      strokeWeight(2);
    
      {
        for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
          
          int OBJ_NUM = selectedSection_numbers[o];
          
          if (OBJ_NUM != 0) {            
            
            int f = OBJ_NUM; 
    
            if ((0 < f) && (f < allSection_Faces.length)) { 
                
              beginShape();
              
              for (int j = 0; j < allSection_Faces[f].length; j++) {
                
                int vNo = allSection_Faces[f][j];
                
                float x = allSection_Vertices[vNo][0] * OBJECTS_scale;
                float y = allSection_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allSection_Vertices[vNo][2] * OBJECTS_scale;
                
                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
                
                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
                
              }
              
              endShape(CLOSE);
            }
          }
        }
      }
          
      strokeWeight(0);   
    
      popMatrix();
    }  
    
  }  
  
   if (Work_with_2D_or_3D == 1) {

    if (selectedFractal_displayEdges != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(255,127,0); 
      strokeWeight(2);
    
      {
        for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
          
          int OBJ_NUM = selectedFractal_numbers[o];
          
          if (OBJ_NUM != 0) {            
            
            int f = OBJ_NUM; 
    
            if ((0 < f) && (f < allFractal_Faces.length)) { 
                
              beginShape();
              
              for (int j = 0; j < allFractal_Faces[f].length; j++) {
                
                int vNo = allFractal_Faces[f][j];
                
                float x = allFractal_Vertices[vNo][0] * OBJECTS_scale;
                float y = allFractal_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allFractal_Vertices[vNo][2] * OBJECTS_scale;
                
                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
                
                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
                
              }
              
              endShape(CLOSE);
            }
          }
        }
      }
          
      strokeWeight(0);   
    
      popMatrix();
    }  
    
  }
  
  if (Work_with_2D_or_3D == 2) {

    if (selectedObject2D_displayEdges != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(255,127,0); 
      strokeWeight(2);
    
      {
        for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
          
          int OBJ_NUM = selectedObject2D_numbers[o];
          
          if (OBJ_NUM != 0) {            
            
            int f = OBJ_NUM; 
    
            if ((0 < f) && (f < allObject2D_Faces.length)) { 
                
              beginShape();
              
              for (int j = 0; j < allObject2D_Faces[f].length; j++) {
                
                int vNo = allObject2D_Faces[f][j];
                
                float x = allObject2D_Vertices[vNo][0] * OBJECTS_scale;
                float y = allObject2D_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allObject2D_Vertices[vNo][2] * OBJECTS_scale;
                
                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
                
                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
                
              }
              
              endShape(CLOSE);
            }
          }
        }
      }
          
      strokeWeight(0);   
    
      popMatrix();
    }  
    
  }


    
  if (Work_with_2D_or_3D == 3) {    
    
    if (selectedPolymesh_displayEdges != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(127); 
      strokeWeight(2);
      
      for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
        
        int OBJ_NUM = selectedPolymesh_numbers[o];
        
        if (OBJ_NUM != 0) {
    
          for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
            if ((0 < f) && (f < allFaces.length)) { 
        
              int Tessellation = allFaces_MTLV[f][1];
              
              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_TESSELLATION;
              }
              if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
          
              for (int n = 0; n < TotalSubNo; n++) {
                
                float[][] base_Vertices = new float [allFaces[f].length][3];
                for (int j = 0; j < allFaces[f].length; j++) {
                  int vNo = allFaces[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }
                
                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
             
                beginShape();
                
                for (int s = 0; s < subFace.length; s++) {
      
                  float x = subFace[s][0] * OBJECTS_scale;
                  float y = subFace[s][1] * OBJECTS_scale;            
                  float z = -subFace[s][2] * OBJECTS_scale;
                  
                  float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
                  
                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                  
                }
                
                endShape(CLOSE);
              }
            }
          }
        }
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }
    
    if (selectedPolymesh_displayBox != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(0,127,0,127);
      strokeWeight(2);
      
      float min_X = selection_BoundingBox[0][0];
      float min_Y = selection_BoundingBox[0][1];
      float min_Z = selection_BoundingBox[0][2];
  
      float max_X = selection_BoundingBox[2][0];
      float max_Y = selection_BoundingBox[2][1];
      float max_Z = selection_BoundingBox[2][2];
      
      float[][] BoundingBox_Vertices = {{min_X, min_Y, min_Z},
                                        {max_X, min_Y, min_Z}, 
                                        {max_X, max_Y, min_Z}, 
                                        {min_X, max_Y, min_Z}, 
                                        {min_X, min_Y, max_Z},
                                        {max_X, min_Y, max_Z}, 
                                        {max_X, max_Y, max_Z}, 
                                        {min_X, max_Y, max_Z}}; 
      
      int[][] BoundingBox_Faces = {{3,2,1,0}, {0,1,5,4}, {1,2,6,5}, {2,3,7,6}, {3,0,4,7}, {4,5,6,7}};
  
      for (int f = 0; f < BoundingBox_Faces.length; f++) {
        
        beginShape();
        
        for (int g = 0; g < BoundingBox_Faces[f].length; g++) {
    
          int vNo = BoundingBox_Faces[f][g];
    
          float x = BoundingBox_Vertices[vNo][0] * OBJECTS_scale;
          float y = BoundingBox_Vertices[vNo][1] * OBJECTS_scale;            
          float z = -BoundingBox_Vertices[vNo][2] * OBJECTS_scale;
          
          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
          
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
          }
          
        }
        endShape(CLOSE);
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }  

    
    
    
    if (selectedPolymesh_displaySolarPivots != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();
      
      stroke(255,127,0,127); 
      
      strokeWeight(5);

      for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
      
        int OBJ_NUM = selectedPolymesh_numbers[o];
        
        if (OBJ_NUM != 0) {

      
          float Pivot_X = allPolymesh_SolarPivotXYZ[OBJ_NUM][0];
          float Pivot_Y = allPolymesh_SolarPivotXYZ[OBJ_NUM][1];
          float Pivot_Z = allPolymesh_SolarPivotXYZ[OBJ_NUM][2];
          
          float[][] BoundingBox_Vertices = {{Pivot_X, Pivot_Y, Pivot_Z},
                                            {Pivot_X + 20, Pivot_Y, Pivot_Z},
                                            {Pivot_X, Pivot_Y + 20, Pivot_Z},
                                            {Pivot_X, Pivot_Y, Pivot_Z + 20}}; 
          
          int[][] BoundingBox_Lines = {{0,1}, {0,2}, {0,3}};
          
          int f_start = 0;
          int f_end = BoundingBox_Lines.length - 1;
          
          if (allPolymesh_SolarPivotType[OBJ_NUM][0] == 1) {f_start = 0; f_end = f_start;}
          if (allPolymesh_SolarPivotType[OBJ_NUM][0] == 2) {f_start = 1; f_end = f_start;}
          if (allPolymesh_SolarPivotType[OBJ_NUM][0] == 3) {f_start = 2; f_end = f_start;}
      
          for (int f = f_start; f <= f_end; f++) {
            
            int a = BoundingBox_Lines[f][0];
            int b = BoundingBox_Lines[f][1];
      
            float x1 = BoundingBox_Vertices[a][0] * OBJECTS_scale;
            float y1 = BoundingBox_Vertices[a][1] * OBJECTS_scale;            
            float z1 = -BoundingBox_Vertices[a][2] * OBJECTS_scale;
      
            float x2 = BoundingBox_Vertices[b][0] * OBJECTS_scale;
            float y2 = BoundingBox_Vertices[b][1] * OBJECTS_scale;            
            float z2 = -BoundingBox_Vertices[b][2] * OBJECTS_scale;
            
            float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1,y1,z1);            
            float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2,y2,z2);
            
            if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                  line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
                }
              }
            }
          }
        }
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }    
    
  }


  if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5) || (Work_with_2D_or_3D == 6)) {   
    if (selectedPolymesh_displayPivot != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      strokeWeight(2);
      
      float Pivot_X = selection_BoundingBox[1 + selection_alignX][0];
      float Pivot_Y = selection_BoundingBox[1 + selection_alignY][1];
      float Pivot_Z = selection_BoundingBox[1 + selection_alignZ][2];
      
      float[][] BoundingBox_Vertices = {{Pivot_X, Pivot_Y, Pivot_Z},
                                        {Pivot_X + 1, Pivot_Y, Pivot_Z},
                                        {Pivot_X, Pivot_Y + 1, Pivot_Z},
                                        {Pivot_X, Pivot_Y, Pivot_Z + 1}}; 
      
      int[][] BoundingBox_Lines = {{0,1}, {0,2}, {0,3}};
  
      for (int f = 0; f < BoundingBox_Lines.length; f++) {
        
        if (f == 0) stroke(255,0,0);
        if (f == 1) stroke(0,0,255);
        if (f == 2) stroke(127,127,0);
        
        int a = BoundingBox_Lines[f][0];
        int b = BoundingBox_Lines[f][1];
  
        float x1 = BoundingBox_Vertices[a][0] * OBJECTS_scale;
        float y1 = BoundingBox_Vertices[a][1] * OBJECTS_scale;            
        float z1 = -BoundingBox_Vertices[a][2] * OBJECTS_scale;
  
        float x2 = BoundingBox_Vertices[b][0] * OBJECTS_scale;
        float y2 = BoundingBox_Vertices[b][1] * OBJECTS_scale;            
        float z2 = -BoundingBox_Vertices[b][2] * OBJECTS_scale;
        
        float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1,y1,z1);            
        float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2,y2,z2);
        
        if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
            if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
              line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
            }
          }
        }
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }
  }  



  if (Work_with_2D_or_3D == 4) {    
    
    if (selectedFace_displayEdges != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(127,0,255); 
      strokeWeight(2);
      
      for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
        
        int f = selectedFace_numbers[o];
        
        if (f != 0) {

          int Tessellation = allFaces_MTLV[f][1];
          
          int TotalSubNo = 1;  
          if (allFaces_MTLV[f][0] == 0) {
            Tessellation += MODEL3D_TESSELLATION;
          }
          if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
      
          for (int n = 0; n < TotalSubNo; n++) {
            
            float[][] base_Vertices = new float [allFaces[f].length][3];
            for (int j = 0; j < allFaces[f].length; j++) {
              int vNo = allFaces[f][j];
              base_Vertices[j][0] = allVertices[vNo][0];
              base_Vertices[j][1] = allVertices[vNo][1];
              base_Vertices[j][2] = allVertices[vNo][2];
            }
            
            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
         
            beginShape();
            
            for (int s = 0; s < subFace.length; s++) {
  
              float x = subFace[s][0] * OBJECTS_scale;
              float y = subFace[s][1] * OBJECTS_scale;            
              float z = -subFace[s][2] * OBJECTS_scale;
              
              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
              
              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
              
            }
            
            endShape(CLOSE);
          }
        }
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }
    
    
    if (selectedFace_displayVertexCount != 0) {
      
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      fill(0);
      
      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MESSAGE_S_View);
      textAlign(CENTER, BOTTOM);
      
      for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
        
        int f = selectedFace_numbers[o];
        
        if (f != 0) {

          for (int j = 0; j < allFaces[f].length; j++) {
            int vNo = allFaces[f][j];
          
            float x = allVertices[vNo][0] * OBJECTS_scale;
            float y = allVertices[vNo][1] * OBJECTS_scale;            
            float z = -allVertices[vNo][2] * OBJECTS_scale;
            
            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
              }
            }

          }
        }
      }
      
      strokeWeight(0);   
    
      popMatrix();
    }    
  }

  
  if (Work_with_2D_or_3D == 5) {    
    
    if (selectedVertex_displayVertices != 0) {
  
      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      noFill();
      
      stroke(255,0,255,127);
      
      strokeWeight(2);
      
      ellipseMode(CENTER);
      
      float R = 10;
      
      for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
        
        int vNo = selectedVertex_numbers[o];
        
        if (vNo != 0) {        
    
          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;
          float z = -allVertices[vNo][2] * OBJECTS_scale;
    
          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
          
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View + R, -0.5 * WIN3D_Y_View + R, 0.5 * WIN3D_X_View - R, 0.5 * WIN3D_Y_View - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
    
        }    
      }
      
      strokeWeight(0);   
    
      popMatrix();    
    }
  }  
  
  
  if (Work_with_2D_or_3D == 6) {    
    
    if (selectedVertex_displayVertices != 0) {

      pushMatrix();
    
      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  
      
      strokeWeight(0);
      
      ellipseMode(CENTER);
      
      float R = 5;

      for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {
        
        int vNo = selectedVertex_softSelectionVertices[q];
        
        float _u = selectedVertex_softSelectionValues[q];    
        
        if (vNo != 0) {        
          
          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;
          float z = -allVertices[vNo][2] * OBJECTS_scale;
    
          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x,y,z);            
          
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View + R, -0.5 * WIN3D_Y_View + R, 0.5 * WIN3D_X_View - R, 0.5 * WIN3D_Y_View - R) == 1) {
              
              float[] _COL = GET_COLOR_STYLE(14, _u); // <<<<<<<<<<<<<<<<<
              fill(_COL[1], _COL[2], _COL[3], _COL[0]);
              stroke(_COL[1], _COL[2], _COL[3], _COL[0]); 

              ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
            }
          }
    
        }    
      }
      
      strokeWeight(0);   
    
      popMatrix();    

    }
    
     
  }    
  
}


 



float[] SOLARCHVISION_calculate_Click3D (float Image_X, float Image_Y) {
  
  float PNT_x = FLOAT_undefined;
  float PNT_y = FLOAT_undefined;
  float PNT_z = FLOAT_undefined;

  if (WIN3D_View_Type == 1) {
    
    PNT_z = (0.5 * refScale) / tan(0.5 * PI / 3.0); //100; // for perspective: any value the plane we need the results on!
    
    PNT_x = PNT_z * Image_X / ((0.5 * WIN3D_scale3D / tan(0.5 * CAM_fov)) * refScale);
    PNT_y = PNT_z * -Image_Y / ((0.5 * WIN3D_scale3D / tan(0.5 * CAM_fov)) * refScale);
  }
  else {
    float ZOOM = Orthographic_Zoom();

    PNT_z = (0.5 * refScale) / tan(0.5 * PI / 3.0); // for orthographic: should be this.

    PNT_x = ZOOM * Image_X / (0.5 * WIN3D_scale3D);
    PNT_y = ZOOM * -Image_Y / (0.5 * WIN3D_scale3D);
  }

  float px, py, pz;
 
  px = PNT_x;
  py = PNT_y * cos_ang(-WIN3D_RX_coordinate) - PNT_z * sin_ang(-WIN3D_RX_coordinate);
  pz = PNT_y * sin_ang(-WIN3D_RX_coordinate) + PNT_z * cos_ang(-WIN3D_RX_coordinate);
  
  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;
 
  pz = PNT_z;
  px = PNT_x * cos_ang(WIN3D_RZ_coordinate) - PNT_y * sin_ang(WIN3D_RZ_coordinate);
  py = PNT_x * sin_ang(WIN3D_RZ_coordinate) + PNT_y * cos_ang(WIN3D_RZ_coordinate);
  
  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;    
  
  PNT_x += CAM_x;
  PNT_y += CAM_y;
  PNT_z -= CAM_z;  

  float[] return_array = {PNT_x, PNT_y, -PNT_z};
  
  return return_array;
}







String NearLatitude_Stamp () {
  
  int Round_Latitude = int(roundTo(LocationLatitude, 5));
  if (Round_Latitude > 70) Round_Latitude = 70; // <<<<<<<<<<<<<<<
  if (Round_Latitude < -45) Round_Latitude = -45; // <<<<<<<<<<<<<<<
  
  String a = nf(abs(Round_Latitude), 2);
  
  if (Round_Latitude < 0) a += "S";
  else a += "N";
  
  return a;
}



String Section_Stamp () {
  
  String s = "";
 
  s += "t" + nf(SpatialImpact_sectionType, 0);
  s += "u" + nf(SolarImpact_offset_U, 0, 3);
  s += "v" + nf(SolarImpact_offset_V, 0, 3);
  s += "w" + nf(SolarImpact_Elevation, 0, 3);
  s += "r" + nf(SolarImpact_Rotation, 0, 3);  
  
  s = s.replace('.', 'p');
  s = s.replace('-', 'n');
  
  return s;
}


PGraphics SHADOW_Diagrams; // to be accessible to Fractal plants

String defaultSceneName = "Complex";
String SceneName = defaultSceneName;
                  
void SOLARCHVISION_render_Shadows_CurrentSection () {

  cursor(WAIT);  
  
  SceneName = "temp_" + Section_Stamp();
  
  
  int RES1 = SolarImpact_RES1;
  int RES2 = SolarImpact_RES2;
  
  float Shades_scaleX = RES1 / SolarImpact_scale_U;
  float Shades_scaleY = RES2 / SolarImpact_scale_V;

  float Shades_offsetX = SolarImpact_offset_U;
  float Shades_offsetY = SolarImpact_offset_V; 
  

  SHADOW_Diagrams = createGraphics(RES1, RES2, P2D); 
  
  PGraphics TREES_Diagrams = createGraphics(RES1, RES2, P2D);
  
  int keep_SolarImpact_sectionType = SolarImpact_sectionType;
  float keep_SolarImpact_Rotation = SolarImpact_Rotation;
  
  if (SolarImpact_sectionType == 3) {
    SolarImpact_sectionType = 2;
    SolarImpact_Rotation = 90 - SolarImpact_Rotation;    
  }

  {  
    int RAD_TYPE = 0;
     
    for (int DATE_ANGLE = 0; DATE_ANGLE < 360; DATE_ANGLE += 15) {
            
      //for (int i = 0; i < 24; i += 1) {
      for (int i = 4; i <= 20; i += 1) { // to make it faster. Also the images are not needed out of this period.
  
        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;
        
        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
          
          SunR_Rotated_check = 2;
        }
        else if (SolarImpact_sectionType == 3) {}
        
        for (int SHD = 0; SHD <= 1; SHD += 1) {
  
          String[] STR_SHD = {"F" , "T"};
          String File_Name = "";
          
          File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";
      
          File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
      
          File_Name += "_" +  SceneName + "_" + NearLatitude_Stamp() + "_Camera00";
          
          TREES_Diagrams.beginDraw();

          TREES_Diagrams.blendMode(REPLACE);

          TREES_Diagrams.fill(255); 
          TREES_Diagrams.stroke(255);
          TREES_Diagrams.strokeWeight(0);
          TREES_Diagrams.rectMode(CORNER);
          TREES_Diagrams.rect(0, 0, RES1, RES2);
          
          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane
  
            TREES_Diagrams.pushMatrix();
            TREES_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            
            
            TREES_Diagrams.stroke(0); 
            TREES_Diagrams.fill(0);     
    
            TREES_Diagrams.blendMode(BLEND);        
            
            if (Display_Trees_People != 0) {

              for (int f = 1; f <= allObject2D_num; f++) {

                int n = abs(allObject2D_MAP[f]);
                
                int w = Object2DImages[n].width; 
                int h = Object2DImages[n].height;

                float r = allObject2D_XYZS[f][3] * 0.5;
                
                float t = atan2(SunR[2], SunR[1]) + 0.5 * PI; 
                
                if (allObject2D_MAP[f] < 0) t += PI;         
               
                if (r > 2.5) { // to select only trees!               
                  
                  float x = 0, y = 0, z = 0;
                  
                  { // Vertical mask
                    TREES_Diagrams.beginShape();
                    
                    TREES_Diagrams.texture(Object2DImages[n]); 

                    x = allObject2D_XYZS[f][0];
                    y = allObject2D_XYZS[f][1];
                    z = allObject2D_XYZS[f][2];
                    
                    float[] TX = {0,0,0,0};
                    float[] TY = {0,0,0,0};
                    float[] TZ = {0,0,0,0};
                    float[] TU = {0,0,0,0};
                    float[] TV = {0,0,0,0};
                    
                    TX[0] = x - r * cos(t); TY[0] = y - r * sin(t); TZ[0] = z; 
                    TX[1] = x + r * cos(t); TY[1] = y + r * sin(t); TZ[1] = z; 
                    TX[2] = x + r * cos(t); TY[2] = y + r * sin(t); TZ[2] = z + 2 * r; 
                    TX[3] = x - r * cos(t); TY[3] = y - r * sin(t); TZ[3] = z + 2 * r;            
  
                    TU[0] = 0; TV[0] = h;
                    TU[1] = w; TV[1] = h;
                    TU[2] = w; TV[2] = 0;
                    TU[3] = 0; TV[3] = 0;   
                    
                    if (SolarImpact_sectionType == 2) {
                      {
                        for (int q = 0; q < 4; q++) {
                          float a = TX[q];
                          float b = -TY[q];
                          float c = TZ[q];

                          TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                          TY[q] = c;
                          TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                        }
                      } 
                      { // now that we rotated 2D we could rotate x,y,z
                          float a = x;
                          float b = -y;
                          float c = z;

                          x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                          y = c;
                          z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }                   
                    }
                    else if (SolarImpact_sectionType == 3) {}
               
                    if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {
                      
                      float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                      TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                      TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    
                      
                      if (SolarImpact_sectionType == 1) {
                        
                        TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                        TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                      }
                      else if (SolarImpact_sectionType == 2) {
                        
                        TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                        TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                      }
                      else if (SolarImpact_sectionType == 3) {}
                      
                    }
                    
                    if (TZ[2] > SolarImpact_Elevation) {
                    
                      for (int q = 0; q < 4; q++) {
                      
                        TZ[q] = TZ[q] - SolarImpact_Elevation;
                        TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                        TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   
         
                        if (SolarImpact_sectionType == 1) {
                          float px = TX[q];
                          float py = TY[q];

                          TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                          
      
                        TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                      }
                      
                      
                    }
                    
                    TREES_Diagrams.endShape(CLOSE);
                  }
                  
                  { // Horizontal mask
                    float ratio = 0.5; // put the mask at half of the height of the tree 
                  
                    for (int back_front = -1; back_front <= 1; back_front += 2) {
                      
                      float rot = back_front * PI / 2 + t;
                  
                      TREES_Diagrams.beginShape();
                      
                      TREES_Diagrams.texture(Object2DImages[n]); 
                      
                      x = allObject2D_XYZS[f][0];
                      y = allObject2D_XYZS[f][1];
                      z = allObject2D_XYZS[f][2];                      

                      float[] TX = {0,0,0,0};
                      float[] TY = {0,0,0,0};
                      float[] TZ = {0,0,0,0};
                      float[] TU = {0,0,0,0};
                      float[] TV = {0,0,0,0};
                      
                      TX[0] = x - r * cos(t); TY[0] = y - r * sin(t); TZ[0] = z + 2 * r * ratio; 
                      TX[1] = x + r * cos(t); TY[1] = y + r * sin(t); TZ[1] = z + 2 * r * ratio; 
                      TX[2] = x + r * cos(t) + r * cos(rot); TY[2] = y + r * sin(t) + r * sin(rot); TZ[2] = z + 2 * r * ratio; 
                      TX[3] = x - r * cos(t) + r * cos(rot); TY[3] = y - r * sin(t) + r * sin(rot); TZ[3] = z + 2 * r * ratio;    
    
                      TU[0] = 0; TV[0] = h * ratio;
                      TU[1] = w; TV[1] = h * ratio;
                      TU[2] = w; TV[2] = 0;
                      TU[3] = 0; TV[3] = 0;   

                      if (SolarImpact_sectionType == 1) {
    
                        if (z + 2 * r * ratio > SolarImpact_Elevation) {
                        
                          for (int q = 0; q < 4; q++) {
                          
                            TZ[q] = TZ[q] - SolarImpact_Elevation;
                            TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                            TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);  
            
                            if (SolarImpact_sectionType == 1) {
                              float px = TX[q];
                              float py = TY[q];
    
                              TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            }                            
          
                            TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                          }
                        }
                      }
                      
                      TREES_Diagrams.endShape(CLOSE);
                    }
                  }                  
                }
              }            
            }
            
            TREES_Diagrams.popMatrix();  
          }
          
          
          TREES_Diagrams.endDraw();     
     
          TREES_Diagrams.save(File_Name + "_2D.JPG");


          
          SHADOW_Diagrams.beginDraw();

          SHADOW_Diagrams.blendMode(REPLACE);
  
          float _val = 0;
          if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
          SHADOW_Diagrams.fill(255 * _val); 
          SHADOW_Diagrams.stroke(255 * _val);
          SHADOW_Diagrams.strokeWeight(0);
          SHADOW_Diagrams.rectMode(CORNER);
          SHADOW_Diagrams.rect(0, 0, RES1, RES2);
  
          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane
  
            SHADOW_Diagrams.pushMatrix();
            SHADOW_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

            SHADOW_Diagrams.stroke(0); 
            SHADOW_Diagrams.fill(0);              
            
            for (int f = 1; f < allFaces.length; f++) {
              
              int vsb = allFaces_MTLV[f][3];
        
              if (vsb > 0) {
              
                int  mt = allFaces_MTLV[f][0];
                if (Materials_Color[mt][0] > 127) {
                
                  int Tessellation = allFaces_MTLV[f][1];
                  
                  int TotalSubNo = 1;  
                  if (allFaces_MTLV[f][0] == 0) {
                    Tessellation += MODEL3D_TESSELLATION;
                  }
                  if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
                
                  for (int n = 0; n < TotalSubNo; n++) {
                    
                    float[][] base_Vertices = new float [allFaces[f].length][3];
                    for (int g = 0; g < allFaces[f].length; g++) {
                      int vNo = allFaces[f][g];
                      base_Vertices[g][0] = allVertices[vNo][0];
                      base_Vertices[g][1] = allVertices[vNo][1];
                      base_Vertices[g][2] = allVertices[vNo][2];
                    }
                    
                    float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;
                    
                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (SolarImpact_sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];
          
                        subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                        subFace_Rotated[s][1] = c;    
                        subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);      
                      }
                      else if (SolarImpact_sectionType == 3) {}
    
                    }  
                 
                    SHADOW_Diagrams.beginShape();
                    
                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      
                      float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];


    
                      if (z >= 0) {
                        
                        if (SolarImpact_sectionType == 1) {                    
                          float px = x;
                          float py = y;
                        
                          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      }
                      else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
    
                        float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
                        
                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);
                          
                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;
                          
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
                          
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 
                          
                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
    
                        float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
    
                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);
                          
                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;
                          
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
                          
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 
                          
                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }                    
                      }
                    }
                    
                    SHADOW_Diagrams.endShape(CLOSE);
                  }
                }
              }
            }
            
            //now calculating Fractal plants
            if (Display_FractalPlant != 0) {
              
              for (int f = 1; f <= allFractal_num; f++) {

                float x = allFractal_XYZSRA[f][0];
                float y = allFractal_XYZSRA[f][1];
                float z = allFractal_XYZSRA[f][2];
                
                float r = allFractal_XYZSRA[f][3] * 0.5;
                float rot = allFractal_XYZSRA[f][4];      
          
                int n = allFractal_Type[f];

                int dMin = allFractal_DegreeMin[f];
          
                int dMax = allFractal_DegreeMax[f];
          
                int s = allFractal_Seed[f];
                
                float TrunkSize = allFractal_TrunkSize[f];
                
                float LeafSize = allFractal_LeafSize[f];
                
                randomSeed(s);
          
                if (n == 0) {
                  
                  float Alpha = 0;
                  float Beta = rot; 
                
                  SOLARCHVISION_Plant_branch_SHADOW(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
                  
                }
              }
            }            
            
            SHADOW_Diagrams.popMatrix();  
          }
          

          SHADOW_Diagrams.save(File_Name + "3D_.JPG"); //just to test   

          if (Display_Trees_People != 0) {
          
            PImage img = loadImage(File_Name + "_2D.JPG");

            img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.
          
            SHADOW_Diagrams.blendMode(DARKEST); 
            
            SHADOW_Diagrams.tint(255, 255);
            
            SHADOW_Diagrams.image(img, 0, 0, RES1, RES2);
            
            SHADOW_Diagrams.noTint();        
          }  

          SHADOW_Diagrams.endDraw();        
       
       
          SHADOW_Diagrams.save(File_Name + ".PNG");   
          
        }
      
      }
    }
  }


  {
    int RAD_TYPE = 1;

    for (int SHD = 0; SHD <= 1; SHD += 1) {

      String[] STR_SHD = {"F" , "T"};
      String File_Name = "";
      
      File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";
  
      File_Name += "DIF_" + STR_SHD[SHD];

      for (int i = 1; i < skyFaces.length; i++) {

        float[] SunR= {0,0,0,0};
        
        for (int j = 0; j < skyFaces[i].length; j++) {
          SunR[1] += skyVertices[skyFaces[i][j]][0] / float(skyFaces[i].length);
          SunR[2] += skyVertices[skyFaces[i][j]][1] / float(skyFaces[i].length);
          SunR[3] += skyVertices[skyFaces[i][j]][2] / float(skyFaces[i].length);
        }
        
        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;
        
        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
          
          SunR_Rotated_check = 2;
        }
        else if (SolarImpact_sectionType == 3) {}


//------------------------------------ start of copy & paste from the direct version!
        TREES_Diagrams.beginDraw();

        TREES_Diagrams.blendMode(REPLACE);

        TREES_Diagrams.fill(255); 
        TREES_Diagrams.stroke(255);
        TREES_Diagrams.strokeWeight(0);
        TREES_Diagrams.rectMode(CORNER);
        TREES_Diagrams.rect(0, 0, RES1, RES2);
        
        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          TREES_Diagrams.pushMatrix();
          TREES_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            
          
          TREES_Diagrams.stroke(0); 
          TREES_Diagrams.fill(0);     
  
          TREES_Diagrams.blendMode(BLEND);        
          
          if (Display_Trees_People != 0) {

            for (int f = 1; f <= allObject2D_num; f++) {

              int n = abs(allObject2D_MAP[f]);
              
              int w = Object2DImages[n].width; 
              int h = Object2DImages[n].height;

              float r = allObject2D_XYZS[f][3] * 0.5;
              
              float t = atan2(SunR[2], SunR[1]) + 0.5 * PI;
              
              if (allObject2D_MAP[f] < 0) t += PI;         
             
              if (r > 2.5) { // to select only trees!               

                float x = allObject2D_XYZS[f][0];
                float y = allObject2D_XYZS[f][1];
                float z = allObject2D_XYZS[f][2];

                { // Vertical mask
                  TREES_Diagrams.beginShape();
                  
                  TREES_Diagrams.texture(Object2DImages[n]); 

                  x = allObject2D_XYZS[f][0];
                  y = allObject2D_XYZS[f][1];
                  z = allObject2D_XYZS[f][2];
                  
                  float[] TX = {0,0,0,0};
                  float[] TY = {0,0,0,0};
                  float[] TZ = {0,0,0,0};
                  float[] TU = {0,0,0,0};
                  float[] TV = {0,0,0,0};
                  
                  TX[0] = x - r * cos(t); TY[0] = y - r * sin(t); TZ[0] = z; 
                  TX[1] = x + r * cos(t); TY[1] = y + r * sin(t); TZ[1] = z; 
                  TX[2] = x + r * cos(t); TY[2] = y + r * sin(t); TZ[2] = z + 2 * r; 
                  TX[3] = x - r * cos(t); TY[3] = y - r * sin(t); TZ[3] = z + 2 * r;            

                  TU[0] = 0; TV[0] = h;
                  TU[1] = w; TV[1] = h;
                  TU[2] = w; TV[2] = 0;
                  TU[3] = 0; TV[3] = 0;   
                  
                  if (SolarImpact_sectionType == 2) {
                    {
                      for (int q = 0; q < 4; q++) {
                        float a = TX[q];
                        float b = -TY[q];
                        float c = TZ[q];

                        TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        TY[q] = c;
                        TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }
                    } 
                    { // now that we rotated 2D we could rotate x,y,z
                        float a = x;
                        float b = -y;
                        float c = z;

                        x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        y = c;
                        z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                    }                   
                  }
                  else if (SolarImpact_sectionType == 3) {}
             
                  if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {
                    
                    float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                    TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                    TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    
                    
                    if (SolarImpact_sectionType == 1) {
                      
                      TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                      TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                    }
                    else if (SolarImpact_sectionType == 2) {
                      
                      TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                      TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                    }
                    else if (SolarImpact_sectionType == 3) {}
                    
                  }
                  
                  if (TZ[2] > SolarImpact_Elevation) {
                  
                    for (int q = 0; q < 4; q++) {
                    
                      TZ[q] = TZ[q] - SolarImpact_Elevation;
                      TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                      TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   
       
                      if (SolarImpact_sectionType == 1) {
                        float px = TX[q];
                        float py = TY[q];

                        TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      }                          
    
                      TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                    }
                    
                    
                  }
                  
                  TREES_Diagrams.endShape(CLOSE);
                }
                
                { // Horizontal mask
                  float ratio = 0.5; // put the mask at half of the height of the tree 
                
                  for (int back_front = -1; back_front <= 1; back_front += 2) {
                    
                    float rot = back_front * PI / 2 + t;
                
                    TREES_Diagrams.beginShape();
                    
                    TREES_Diagrams.texture(Object2DImages[n]); 

                    float[] TX = {0,0,0,0};
                    float[] TY = {0,0,0,0};
                    float[] TZ = {0,0,0,0};
                    float[] TU = {0,0,0,0};
                    float[] TV = {0,0,0,0};
                    
                    TX[0] = x - r * cos(t); TY[0] = y - r * sin(t); TZ[0] = z + 2 * r * ratio; 
                    TX[1] = x + r * cos(t); TY[1] = y + r * sin(t); TZ[1] = z + 2 * r * ratio; 
                    TX[2] = x + r * cos(t) + r * cos(rot); TY[2] = y + r * sin(t) + r * sin(rot); TZ[2] = z + 2 * r * ratio; 
                    TX[3] = x - r * cos(t) + r * cos(rot); TY[3] = y - r * sin(t) + r * sin(rot); TZ[3] = z + 2 * r * ratio;    
  
                    TU[0] = 0; TV[0] = h * ratio;
                    TU[1] = w; TV[1] = h * ratio;
                    TU[2] = w; TV[2] = 0;
                    TU[3] = 0; TV[3] = 0;   

                    if (SolarImpact_sectionType == 1) {
                      if (z + 2 * r * ratio > SolarImpact_Elevation) {
                      
                        for (int q = 0; q < 4; q++) {
                        
                          TZ[q] = TZ[q] - SolarImpact_Elevation;
                          TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                          TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);                  
  
                          if (SolarImpact_sectionType == 1) {
                            float px = TX[q];
                            float py = TY[q];
  
                            TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }      
        
                          TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                        }
                      }
                    }
                    
                    TREES_Diagrams.endShape(CLOSE);
                  }
                }                  
              }
            }            
          }
          
          TREES_Diagrams.popMatrix();  
        }
        
        
        TREES_Diagrams.endDraw();
//------------------------------------ end of copy & paste from the direct version!
   
        TREES_Diagrams.save(File_Name + nf(i, 3) + "_2D.JPG");



        SHADOW_Diagrams.beginDraw();

        SHADOW_Diagrams.blendMode(REPLACE);

        float _val = 0;
        if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
        SHADOW_Diagrams.fill(255 * _val); 
        SHADOW_Diagrams.stroke(255 * _val);
        SHADOW_Diagrams.strokeWeight(0);
        SHADOW_Diagrams.rectMode(CORNER);
        SHADOW_Diagrams.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          SHADOW_Diagrams.pushMatrix();
          SHADOW_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

          SHADOW_Diagrams.stroke(0); 
          SHADOW_Diagrams.fill(0);
          
          for (int f = 1; f < allFaces.length; f++) {
            
            int vsb = allFaces_MTLV[f][3];
        
            if (vsb > 0) {
            
              int  mt = allFaces_MTLV[f][0];            
              if (Materials_Color[mt][0] > 127) {
              
                int Tessellation = allFaces_MTLV[f][1];
                
                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_TESSELLATION;
                }
                if (Tessellation > 0) TotalSubNo = allFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
              
                for (int n = 0; n < TotalSubNo; n++) {
                  
                  float[][] base_Vertices = new float [allFaces[f].length][3];
                  for (int g = 0; g < allFaces[f].length; g++) {
                    int vNo = allFaces[f][g];
                    base_Vertices[g][0] = allVertices[vNo][0];
                    base_Vertices[g][1] = allVertices[vNo][1];
                    base_Vertices[g][2] = allVertices[vNo][2];
                  }
                  
                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                  float[][] subFace_Rotated = subFace;
                  
                  for (int s = 0; s < subFace_Rotated.length; s++) {
                    if (SolarImpact_sectionType == 2) {
                      float a = subFace_Rotated[s][0];
                      float b = -subFace_Rotated[s][1];
                      float c = subFace_Rotated[s][2];
                      
                      subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                      subFace_Rotated[s][1] = c;      
                      subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);      
                    }
                    else if (SolarImpact_sectionType == 3) {}
    
                  }                
               
                  SHADOW_Diagrams.beginShape();
                  
                  for (int s = 0; s < subFace_Rotated.length; s++) {
                    
                    float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                    float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                    float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
                      
                    if (z >= 0) {
                      
                      if (SolarImpact_sectionType == 1) {
                        float px = x;
                        float py = y;
                      
                        x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      }                   
                      
                      SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                    }
                    else {
                      int s_next = (s + 1) % subFace_Rotated.length;
                      int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
                      
                      float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                      float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];       
                      
                      if (z_prev > 0) { 
                        float ratio = z_prev / (z_prev - z);
                        
                        float x_trim = x_prev * (1 - ratio) + x * ratio;
                        float y_trim = y_prev * (1 - ratio) + y * ratio;
                        
                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;
                        
                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                     
                        
                        SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }
    
                      float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                      float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
                      
                      if (z_next > 0) { 
                        float ratio = z_next / (z_next - z);
                        
                        float x_trim = x_next * (1 - ratio) + x * ratio;
                        float y_trim = y_next * (1 - ratio) + y * ratio;
                        
                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;
                        
                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                     
                        
                        SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }                    
                    }
                  }
                  
                  SHADOW_Diagrams.endShape(CLOSE);
                }
              }
            }
          }
          
          //now calculating Fractal plants
          if (Display_FractalPlant != 0) {
            
            for (int f = 1; f <= allFractal_num; f++) {

              float x = allFractal_XYZSRA[f][0];
              float y = allFractal_XYZSRA[f][1];
              float z = allFractal_XYZSRA[f][2];
              
              float r = allFractal_XYZSRA[f][3] * 0.5;
              float rot = allFractal_XYZSRA[f][4];      
        
              int n = allFractal_Type[f];

              int dMin = allFractal_DegreeMin[f];
        
              int dMax = allFractal_DegreeMax[f];
        
              int s = allFractal_Seed[f];
              
              float TrunkSize = allFractal_TrunkSize[f];
              
              float LeafSize = allFractal_LeafSize[f];
              
              randomSeed(s);
        
              if (n == 0) {
                
                float Alpha = 0;
                float Beta = rot; 
              
                SOLARCHVISION_Plant_branch_SHADOW(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
                
              }
            }
          }          
          
          SHADOW_Diagrams.popMatrix();  
          
        }

        SHADOW_Diagrams.save(File_Name + "3D_.JPG"); //just to test   

        if (Display_Trees_People != 0) {
        
          PImage img = loadImage(File_Name + nf(i, 3) + "_2D.JPG");

          img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.
        
          SHADOW_Diagrams.blendMode(DARKEST); 
          
          SHADOW_Diagrams.tint(255, 255);
          
          SHADOW_Diagrams.image(img, 0, 0, RES1, RES2);
          
          SHADOW_Diagrams.noTint();        
        }  

        SHADOW_Diagrams.endDraw();    
        
        SHADOW_Diagrams.save(File_Name + nf(i, 3) + ".JPG");
      }



      PGraphics DIFFUSE_Diagrams = createGraphics(RES1, RES2, P2D);    
      
      DIFFUSE_Diagrams.beginDraw();

      DIFFUSE_Diagrams.blendMode(REPLACE);

      DIFFUSE_Diagrams.fill(0); 
      DIFFUSE_Diagrams.stroke(0);
      DIFFUSE_Diagrams.strokeWeight(0);
      DIFFUSE_Diagrams.rectMode(CORNER);
      DIFFUSE_Diagrams.rect(0, 0, RES1, RES2);
      
      for (int i = 1; i < skyFaces.length; i++) {
      
        PImage img = loadImage(File_Name + nf(i, 3) + ".JPG");
     
        DIFFUSE_Diagrams.blendMode(ADD); 
        
        DIFFUSE_Diagrams.tint(255, 255 / (0.5 * float(skyFaces.length)));
        
        DIFFUSE_Diagrams.image(img, 0, 0, RES1, RES2);
        
        DIFFUSE_Diagrams.noTint();

      }
      
      DIFFUSE_Diagrams.endDraw();

      File_Name += "_" +  SceneName + "_" + NearLatitude_Stamp() + "_Camera00.PNG"; 

      DIFFUSE_Diagrams.save(File_Name);
      println (File_Name);
   
    }
  }
  
  SolarImpact_sectionType = keep_SolarImpact_sectionType;
  SolarImpact_Rotation = keep_SolarImpact_Rotation;  
  
  cursor(ARROW);
 
}












void SOLARCHVISION_draw_WindRose_Image () {
  
  if (Display_WindRose_Image != 0) {
    
    if (rebuild_WindRose_Image_array != 0) {
      SOLARCHVISION_build_WindRose_Image_array();
    }    
  
    WIN3D_Diagrams.stroke(0);
    WIN3D_Diagrams.fill(127,127,127);    

    WIN3D_Diagrams.beginShape();
    
    float WindRose_Elevation = 0.0 + SpatialImpact_Elevation[1];
    float WindRose_scale_U = WindRose3D_scale; 
    float WindRose_scale_V = WindRose3D_scale;
    
    float minU = 0;
    float maxU = Rendered_WindRose_RES;
    float minV = 0;
    float maxV = Rendered_WindRose_RES;

    //float c = HeightAboveGround * OBJECTS_scale; // <<< or zero i.e. height of the plane in 3D  // ?????????
    float c = WindRose_Elevation * OBJECTS_scale; 
    
    c += 1; // put WindRose_Image it at level 1m. // <<<<<<<<<<<

    WIN3D_Diagrams.beginShape();

    WIN3D_Diagrams.texture(WindRose_Image[Day_of_Impact_to_Display]);  
    WIN3D_Diagrams.stroke(255, 255, 255, 0);
    WIN3D_Diagrams.fill(255, 255, 255, 0);  
    
    for (int q = 0; q < 4; q++) {
      
      float qx = 0, qy = 0, u = 0, v = 0;
      
      if (q == 0)      {qx = -1; qy = -1; u = minU; v = maxV;}
      else if (q == 1) {qx = 1; qy = -1; u = maxU; v = maxV;}
      else if (q == 2) {qx = 1; qy = 1; u = maxU; v = minV;}
      else if (q == 3) {qx = -1; qy = 1; u = minU; v = minV;}    
      
      float a = qx * 0.5;
      float b = qy * 0.5;    
      
      float x = 0, y = 0, z = 0;

      x = a;
      y = b;
      z = c;         

      WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_scale3D, -y * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D, u * WindRose_scale_U, v * WindRose_scale_V);
    }   
    
    WIN3D_Diagrams.endShape(CLOSE);
  }
}


void SOLARCHVISION_add_Section (int n, float u, float v, float elev, float rot, float dU, float dV, int RES1, int RES2) {

  int[] TempSection_Type = {n}; 
  allSection_Type = concat(allSection_Type, TempSection_Type);

  int[] TempSection_RES1 = {RES1}; 
  allSection_RES1 = concat(allSection_RES1, TempSection_RES1);

  int[] TempSection_RES2 = {RES2}; 
  allSection_RES2 = concat(allSection_RES2, TempSection_RES2);
  
  PImage[] TempSection_SpatialImpact = {createImage(RES1, RES2, RGB)}; 
  allSection_SpatialImpact = (PImage[]) concat(allSection_SpatialImpact, TempSection_SpatialImpact);
  
  PImage[][] TempSection_SolarImpact = new PImage[1][(1 + STUDY_j_end - STUDY_j_start)];
  {
    int i = 0;
    for (int j = STUDY_j_start; j <= STUDY_j_end; j += 1) { 
      TempSection_SolarImpact[i][j] = createImage(2, 2, RGB);
    } 
  }
  allSection_SolarImpact = (PImage[][]) concat(allSection_SolarImpact, TempSection_SolarImpact);    

  float[][] TempSection_UVERAB = {{u, v, elev, rot, dU, dV}};
  allSection_UVERAB = (float[][]) concat(allSection_UVERAB, TempSection_UVERAB);

  allSection_num += 1;

}


float[][] allSection_Vertices;
int[][] allSection_Faces;


void SOLARCHVISION_draw_Sections () {

  allSection_Faces = new int [1 + allSection_num][4];
    
  allSection_Vertices = new float [4 * allSection_num + 1][3];
  allSection_Vertices[0][0] = 0;
  allSection_Vertices[0][1] = 0;
  allSection_Vertices[0][2] = 0;
  
  if (Display_Sections != 0) {

    for (int f = 1; f <= allSection_num; f++) {
      
      float Section_offset_U = allSection_UVERAB[f][0];
      float Section_offset_V = allSection_UVERAB[f][1];
      float Section_Elevation = allSection_UVERAB[f][2];
      float Section_Rotation = allSection_UVERAB[f][3];
      float Section_scale_U = allSection_UVERAB[f][4];
      float Section_scale_V = allSection_UVERAB[f][5];

      int Section_Type = allSection_Type[f];
      int Section_RES1 = allSection_RES1[f];
      int Section_RES2 = allSection_RES2[f];

      if (Section_Type != 0) {

        WIN3D_Diagrams.stroke(0);
        WIN3D_Diagrams.fill(127,255,127);  
        
        WIN3D_Diagrams.beginShape();
        
        if (Display_SolarImpact_Image != 0) { 
          WIN3D_Diagrams.texture(allSection_SolarImpact[f][Day_of_Impact_to_Display]);
          
          WIN3D_Diagrams.noStroke();
          WIN3D_Diagrams.noFill();
        }
        else if (Display_SpatialImpact_Image != 0){
          WIN3D_Diagrams.texture(allSection_SpatialImpact[f]);
          
          WIN3D_Diagrams.noStroke();
          WIN3D_Diagrams.noFill();
        }  
        
        for (int q = 0; q < 4; q++) {
          
          float[] ImageVertex = SOLARCHVISION_getCorners_Section(q, Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
          
          float x = ImageVertex[0];
          float y = ImageVertex[1];
          float z = ImageVertex[2];
          float u = ImageVertex[3];
          float v = ImageVertex[4];
 
          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_scale3D, -y * OBJECTS_scale * WIN3D_scale3D, z * OBJECTS_scale * WIN3D_scale3D, u * Section_RES1, v * Section_RES2);
          
          allSection_Vertices[f * 4 - q][0] = x;
          allSection_Vertices[f * 4 - q][1] = y;
          allSection_Vertices[f * 4 - q][2] = z;
          
        }        

        allSection_Faces[f][0] = f * 4 - 3;
        allSection_Faces[f][1] = f * 4 - 2;
        allSection_Faces[f][2] = f * 4 - 1;
        allSection_Faces[f][3] = f * 4 - 0;  

        WIN3D_Diagrams.endShape(CLOSE);

      }
    }
  }
}


float[] SOLARCHVISION_getCorners_Section (int q, int Section_Type, float Section_offset_U, float Section_offset_V, float Section_Elevation, float Section_Rotation, float Section_scale_U, float Section_scale_V, int Section_RES1, int Section_RES2) {
  
  float c = Section_Elevation;

    
  float qx = 0, qy = 0, u = 0, v = 0;
  
  if (q == 0)      {qx = -1; qy = -1; u = 0; v = 1;}
  else if (q == 1) {qx = 1; qy = -1; u = 1; v = 1;}
  else if (q == 2) {qx = 1; qy = 1; u = 1; v = 0;}
  else if (q == 3) {qx = -1; qy = 1; u = 0; v = 0;}    
  
  float a = qx * 0.5 * Section_scale_U + Section_offset_U;
  float b = qy * 0.5 * Section_scale_V + Section_offset_V;    

  float x = 0, y = 0, z = 0;
  
  if (Section_Type == 1) {
    x = a * cos_ang(-Section_Rotation) - -b * sin_ang(-Section_Rotation);
    y = a * sin_ang(-Section_Rotation) + -b * cos_ang(-Section_Rotation);
    z = c;         
  }
  else if (Section_Type == 2) {
    x = a * cos_ang(Section_Rotation) - c * sin_ang(Section_Rotation);
    y = a * sin_ang(Section_Rotation) + c * cos_ang(Section_Rotation);
    z = b;        
  }
  else if (Section_Type == 3) {
    x = a * cos_ang(90 - Section_Rotation) - c * sin_ang(90 - Section_Rotation);
    y = a * sin_ang(90 - Section_Rotation) + c * cos_ang(90 - Section_Rotation);
    z = b;    
  }      

  float[] ImageVertex = {x, -y, z, u, v};
  
  return ImageVertex;

}







void SOLARCHVISION_add_FractalPlant (int PlantType, float x, float y, float z, float s, float rot, int PlantDegreeMin, int PlantDegreeMax, int PlantSeed, float TrunkSize, float LeafSize, float as_Solid) {

  float[] TempFractal_TrunkSize = {TrunkSize}; 
  allFractal_TrunkSize = concat(allFractal_TrunkSize, TempFractal_TrunkSize);  
  
  float[] TempFractal_LeafSize = {LeafSize}; 
  allFractal_LeafSize = concat(allFractal_LeafSize, TempFractal_LeafSize);
  
  int[] TempFractal_Type = {PlantType}; 
  allFractal_Type = concat(allFractal_Type, TempFractal_Type);

  int[] TempFractal_DegreeMin = {PlantDegreeMin}; 
  allFractal_DegreeMin = concat(allFractal_DegreeMin, TempFractal_DegreeMin);
  
  int[] TempFractal_DegreeMax = {PlantDegreeMax}; 
  allFractal_DegreeMax = concat(allFractal_DegreeMax, TempFractal_DegreeMax);

  int q = PlantSeed;
  if (q == -1) q = int(random(0, 100));

  int[] TempFractal_Seed = {q}; 
  allFractal_Seed = concat(allFractal_Seed, TempFractal_Seed);

  float[][] TempFractal_XYZSRA = {{x, y, z, s, rot, as_Solid}};
  allFractal_XYZSRA = (float[][]) concat(allFractal_XYZSRA, TempFractal_XYZSRA);

  allFractal_num += 1;

}

float[][] allFractal_Vertices;
int[][] allFractal_Faces;


void SOLARCHVISION_draw_FractalPlants () {

  allFractal_Faces = new int [1 + allFractal_num][4];
    
  allFractal_Vertices = new float [4 * allFractal_num + 1][3];
  allFractal_Vertices[0][0] = 0;
  allFractal_Vertices[0][1] = 0;
  allFractal_Vertices[0][2] = 0;
  
  if (Display_FractalPlant != 0) {

    for (int f = 1; f <= allFractal_num; f++) {

      float x = allFractal_XYZSRA[f][0];
      float y = allFractal_XYZSRA[f][1];
      float z = allFractal_XYZSRA[f][2];
      
      float r = allFractal_XYZSRA[f][3] * 0.5;
      float rot = allFractal_XYZSRA[f][4];
      float as_Solid = allFractal_XYZSRA[f][5];

      int n = allFractal_Type[f];

      int dMin = allFractal_DegreeMin[f];

      int dMax = allFractal_DegreeMax[f];

      int s = allFractal_Seed[f];

      float TrunkSize = allFractal_TrunkSize[f];
      
      float LeafSize = allFractal_LeafSize[f];
      
      randomSeed(s);

      if (n == 0) {
        
        float Alpha = 0;
        float Beta = rot; 
      
        SOLARCHVISION_Plant_branch(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, as_Solid);
        
        if (as_Solid != 0) {
          allFractal_XYZSRA[f][5] = 0; 
        }
        
        
        // ----------------
        x *= OBJECTS_scale;
        y *= OBJECTS_scale;
        z *= OBJECTS_scale;
        r *= OBJECTS_scale;
        // ----------------        
       
        float t = WIN3D_RZ_coordinate * PI / 180.0;
        if (WIN3D_View_Type == 1) t = atan2(y - CAM_y, x - CAM_x) + 0.5 * PI; 

        {
          allFractal_Vertices[f * 4 - 3][0] = (x - r * cos(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 3][1] = (y - r * sin(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 3][2] = (z) / OBJECTS_scale;

          allFractal_Vertices[f * 4 - 2][0] = (x + r * cos(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 2][1] = (y + r * sin(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 2][2] = (z) / OBJECTS_scale;

          allFractal_Vertices[f * 4 - 1][0] = (x + r * cos(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 1][1] = (y + r * sin(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 1][2] = (z + 2 * r) / OBJECTS_scale;

          allFractal_Vertices[f * 4 - 0][0] = (x - r * cos(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 0][1] = (y - r * sin(t)) / OBJECTS_scale;
          allFractal_Vertices[f * 4 - 0][2] = (z + 2 * r) / OBJECTS_scale;

          allFractal_Faces[f][0] = f * 4 - 3;
          allFractal_Faces[f][1] = f * 4 - 2;
          allFractal_Faces[f][2] = f * 4 - 1;
          allFractal_Faces[f][3] = f * 4 - 0;
        }        
                
      }
              
    }
  }

}




void SOLARCHVISION_Plant_branch_objExport (int _turn, float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float as_Solid) {
  
  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  
      
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
             
      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
      
      //float[] COL = {255, 100 - 6 * w, 50 - 3 * w, 0};

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
      
      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_FractalPlant != 0) {
        int nSeg = 6; 
        for (int q = 0; q < nSeg; q++) {

          for (int j = 0; j < 4; j++) {
  
            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;
  
            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;
            
            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
            
            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;
  
            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
            
            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 
    

            float x = Trunk_x_new;
            float y = Trunk_y_new;
            float z = Trunk_z_new;
            float u = the_U;
            float v = the_V;
  
            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
            
            if (_turn == 1) {
              objOutput.println("v " + nf(x, 0, objExportPrecisionVertex) + " " + nf(y, 0, objExportPrecisionVertex) + " " + nf(z, 0, objExportPrecisionVertex));
            }
            
            if (_turn == 2) {
              objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
            }
  
          }

          if (_turn == 3) {
            
            num_vertices_added += 4;
            
            String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
            
            String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);               
            
            if (objExportPolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println(("g FractalPlant_Trunk_n" + nf(q, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
            }
          
            if (objExportMaterialLibrary != 0) {
              objOutput.println("usemtl FractalPlant_Trunk");
            }
            
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
          }     

        }
      }

      SOLARCHVISION_Plant_branch_objExport(_turn, x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, as_Solid);

    }
  } else {

    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int c = int(random(127));  
    
    if (Display_Leaves != 0) {
      
      float LeafVertices[][] = {{0,0,0}, {1,0,1}, {0,1,1}, {-1,0,1}, {0,-1,1}, {0,0,2}};
      int LeafFaces[][] = {{0,1,2,5}, {0,2,3,5}, {0,3,4,5}, {0,4,1,5}};
      
      for (int i = 0; i < 4; i++) { // 4: LeafFaces.length
        for (int j = 0; j < 4; j++) { // 4: LeafFaces[i].length
  
          float the_U = 0;
          if ((j == 1) || (j == 2)) the_U = 1;
  
          float the_V = 0;
          if ((j == 2) || (j == 3)) the_V = 1;


          float Leaf_x_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][0];
          float Leaf_y_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][1];
          float Leaf_z_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][2];

          float Leaf_x_rot = Leaf_z_dif * sin(rotZX) +  Leaf_x_dif * cos(rotZX);
          float Leaf_y_rot = Leaf_y_dif;
          float Leaf_z_rot = Leaf_z_dif * cos(rotZX) - Leaf_x_dif * sin(rotZX);
          
          float Leaf_x_new = x0 + Leaf_x_rot * cos(rotXY) - Leaf_y_rot * sin(rotXY);
          float Leaf_y_new = y0 + Leaf_x_rot * sin(rotXY) + Leaf_y_rot * cos(rotXY);
          float Leaf_z_new = z0 + Leaf_z_rot; 

          float x = Leaf_x_new;
          float y = Leaf_y_new;
          float z = Leaf_z_new;
          float u = the_U;
          float v = the_V;
          
          v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

          if (_turn == 1) {
            objOutput.println("v " + nf(x, 0, objExportPrecisionVertex) + " " + nf(y, 0, objExportPrecisionVertex) + " " + nf(z, 0, objExportPrecisionVertex));
          }
          
          if (_turn == 2) {
            objOutput.println("vt " + nf(u, 0, objExportPrecisionVtexture) + " " + nf(v, 0, objExportPrecisionVtexture) + " 0");
          }

        }


        if (_turn == 3) {  
          
          num_vertices_added += 4;
          
          String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
          
          String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);        
  
          if (objExportPolyToPoly == 0) {
            obj_lastGroupNumber += 1;
            objOutput.println(("g FractalPlant_Leaf_n" + nf(i, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
          }
          
          if (objExportMaterialLibrary != 0) {
            objOutput.println("usemtl FractalPlant_Leaf");
          }
          
          obj_lastFaceNumber += 1;
          objOutput.println("f " + n1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
          if (objExportBackSides != 0) {
            //obj_lastFaceNumber += 1;
            //objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
          }    
        }  
      }
    }

  }
}




float getRatio_Plant_branch (float d) {
 return (0.75 / pow(d, 0.06125));
}

void SOLARCHVISION_Plant_branch (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float as_Solid) {
  
  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  
      
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
             
      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
      
      float[] COL = {255, 100 - 6 * w, 50 - 3 * w, 0};

      WIN3D_Diagrams.strokeWeight(1);
      
      if (Display_MODEL3D_EDGES == 0) {
        WIN3D_Diagrams.noStroke();
      }      
      else {
        WIN3D_Diagrams.stroke(0);
      }

      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3]);

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
      
      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_FractalPlant != 0) {
        int nSeg = 6; 
        for (int q = 0; q < nSeg; q++) {
          WIN3D_Diagrams.beginShape();
          for (int j = 0; j < 4; j++) {
  
            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;
  
            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;
            
            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
            
            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;
  
            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
            
            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 
    
            WIN3D_Diagrams.vertex(Trunk_x_new * OBJECTS_scale * WIN3D_scale3D, -Trunk_y_new * OBJECTS_scale * WIN3D_scale3D, Trunk_z_new * OBJECTS_scale * WIN3D_scale3D);
          }
          WIN3D_Diagrams.endShape(CLOSE);
        }
      }

      SOLARCHVISION_Plant_branch(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, as_Solid);

    }
  } else {
    
    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int c = int(random(127));  
    
    if (Display_Leaves != 0) {
      
      WIN3D_Diagrams.strokeWeight(0);
  
      float[] COL = {127, 2 * c, 191 - c, 0};  // opaque!
      
      WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 
      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
  
      WIN3D_Diagrams.pushMatrix(); 
      WIN3D_Diagrams.translate(x0 * OBJECTS_scale * WIN3D_scale3D, -y0 * OBJECTS_scale * WIN3D_scale3D, z0 * OBJECTS_scale * WIN3D_scale3D);
      WIN3D_Diagrams.sphere(0.5 * LeafSize * OBJECTS_scale * WIN3D_scale3D);
      WIN3D_Diagrams.popMatrix();
   
      if (as_Solid != 0) {
        float r0 = 0.5 * LeafSize;
        SOLARCHVISION_addToSolids(as_Solid, x0,y0,z0, 2,2,2, r0,r0,r0, 0,0,0);
      }
  
    }

  }
}


void SOLARCHVISION_Plant_branch_SHADOW (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float[] SunR_Rotated, float Shades_scaleX, float Shades_scaleY, float Shades_offsetX, float Shades_offsetY) {
  
  SHADOW_Diagrams.strokeWeight(0);
  
  SHADOW_Diagrams.stroke(0);
  SHADOW_Diagrams.fill(0);
  
  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  
      
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
             
      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
      
      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_FractalPlant != 0) {
        int nSeg = 6; 
        float[][] subFace = new float [nSeg * 4][3];
        for (int q = 0; q < nSeg; q++) {
          for (int j = 0; j < 4; j++) {
  
            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;
  
            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;
            
            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
            
            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;
  
            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
            
            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 
    
            subFace[q * 4 + j][0] = Trunk_x_new;
            subFace[q * 4 + j][1] = Trunk_y_new; 
            subFace[q * 4 + j][2] = Trunk_z_new;
          }
        }
  
        float[][] subFace_Rotated = subFace;
  
        for (int s = 0; s < subFace_Rotated.length; s++) {
          if (SolarImpact_sectionType == 2) {
            float a = subFace_Rotated[s][0];
            float b = -subFace_Rotated[s][1];
            float c = subFace_Rotated[s][2];
  
            subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
            subFace_Rotated[s][1] = c;    
            subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);      
          }
          else if (SolarImpact_sectionType == 3) {}
  
        }  
  
        SHADOW_Diagrams.beginShape();
  
        for (int s = 0; s < subFace_Rotated.length; s++) {
          
          float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
          float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
          float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
          if (z >= 0) {
            
            if (SolarImpact_sectionType == 1) {                    
              float px = x;
              float py = y;
            
              x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
              y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
            } 
            
            SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY);
          }
          else {
            int s_next = (s + 1) % subFace_Rotated.length;
            int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
            float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
            float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
            float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
            
            if (z_prev > 0) { 
              float ratio = z_prev / (z_prev - z);
              
              float x_trim = x_prev * (1 - ratio) + x * ratio;
              float y_trim = y_prev * (1 - ratio) + y * ratio;
              
              if (SolarImpact_sectionType == 1) {
                float px = x_trim;
                float py = y_trim;
              
                x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
              } 
              
              SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
            }
  
            float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
            float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
            float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
            if (z_next > 0) { 
              float ratio = z_next / (z_next - z);
              
              float x_trim = x_next * (1 - ratio) + x * ratio;
              float y_trim = y_next * (1 - ratio) + y * ratio;
              
              if (SolarImpact_sectionType == 1) {
                float px = x_trim;
                float py = y_trim;
              
                x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
              } 
              
              SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
            }                    
          }
        }
  
        SHADOW_Diagrams.endShape(CLOSE);      
      }
      
      SOLARCHVISION_Plant_branch_SHADOW(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetY, Shades_offsetY);

    }
  } else {
    
    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int COL = int(random(127));      
    
    if (Display_Leaves != 0) {

      float x0_Rotated = x0;
      float y0_Rotated = y0;
      float z0_Rotated = z0;
      
      if (SolarImpact_sectionType == 2) {
        float a = x0;
        float b = -y0;
        float c = z0;

        x0_Rotated = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
        y0_Rotated = c;    
        z0_Rotated= a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);      
      }
      else if (SolarImpact_sectionType == 3) {}


      float z = z0_Rotated - SolarImpact_Elevation;
      float x = x0_Rotated - z * SunR_Rotated[1] / SunR_Rotated[3];
      float y = y0_Rotated - z * SunR_Rotated[2] / SunR_Rotated[3];

      if (z >= 0) {
        
        if (SolarImpact_sectionType == 1) {                    
          float px = x;
          float py = y;
        
          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
        } 



        SHADOW_Diagrams.ellipse((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY, LeafSize * Shades_scaleX, LeafSize * Shades_scaleY);
      }

   
    }

  }
}




int[] SOLARCHVISION_get_selectedFace_Vertices () {

  int[] FaceVertices = {0};
  
  for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
  
    int OBJ_NUM = selectedFace_numbers[o];
    
    if (OBJ_NUM != 0) {
      
      int f = OBJ_NUM;
  
      for (int j = 0; j < allFaces[f].length; j++) {
        int vNo = allFaces[f][j];
        
        int vertex_listed = 0;
        
        for (int q = 1; q < FaceVertices.length; q++) {
          if (vNo == FaceVertices[q]) {
            vertex_listed = 1;
            break;                      
          }
        }         
       
        if (vertex_listed == 0) {
          int[] newVertexListed = {vNo};
          FaceVertices = concat(FaceVertices, newVertexListed);  
        } 
      }
    }
  }
  
  return FaceVertices;
} 



int[] SOLARCHVISION_get_selectedPolymesh_Vertices () {

  int[] PolymeshVertices = {0};
  
  for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
    
    int OBJ_NUM = selectedPolymesh_numbers[o];
    
    if (OBJ_NUM != 0) {
  
      for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {

        if ((0 < f) && (f < allFaces.length)) { 
          for (int j = 0; j < allFaces[f].length; j++) {
            
            int vNo = allFaces[f][j];
            
            int vertex_listed = 0;
            
            for (int q = 1; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;                      
              }
            }         
           
            if (vertex_listed == 0) {
              int[] newVertexListed = {vNo};
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);  
            } 
          }
        }
      } 
    }
  }
  
  return PolymeshVertices;
} 





float[][] selection_BoundingBox = {{0,0,0}, {0,0,0}, {0,0,0}}; // [min|mid|max]
float[] selected_Pivot_XYZ = {0,0,0};

float[][] saved_BoundingBox = {{0,0,0}, {0,0,0}, {0,0,0}};
float[] saved_Pivot_XYZ = {0,0,0};
int saved_alignX = 0;
int saved_alignY = 0;
int saved_alignZ = 0;

void SOLARCHVISION_calculate_selection_BoundingBox () {
  
  int[] theVertices = {};
  
  if (Work_with_2D_or_3D == 8) {
    theVertices = selectedSection_numbers;
  } 

  if ((Work_with_2D_or_3D == 5) || (Work_with_2D_or_3D == 6))  {
    theVertices = selectedVertex_numbers;
  }
  if (Work_with_2D_or_3D == 4) {
    theVertices = SOLARCHVISION_get_selectedFace_Vertices();
  }  
  if (Work_with_2D_or_3D == 3) {
    theVertices = SOLARCHVISION_get_selectedPolymesh_Vertices();
  }
  if (Work_with_2D_or_3D == 2) {
    theVertices = selectedObject2D_numbers;
  }
  if (Work_with_2D_or_3D == 1) {
    theVertices = selectedFractal_numbers;
  }  
  
  for (int j = 0; j < 3; j++) {
    
    float POS_min = FLOAT_undefined;
    float POS_max = -FLOAT_undefined;

    for (int q = 1; q < theVertices.length; q++) {
   
      float POS_now = 0;
      
      if (Work_with_2D_or_3D == 8) {
        int n = theVertices[q];
        
        POS_now = allSection_UVERAB[n][j]; // <<<<<<<<<<<not correct! should pass XYZ instead of UVW 
      }  
      
      if ((Work_with_2D_or_3D == 3) || (Work_with_2D_or_3D == 4) || (Work_with_2D_or_3D == 5) || (Work_with_2D_or_3D == 6)) {
        int n = theVertices[q];
        
        POS_now = allVertices[n][j];
      }
      if (Work_with_2D_or_3D == 2) {
        int n = theVertices[q];
        
        POS_now = allObject2D_XYZS[n][j];
      }     
      if (Work_with_2D_or_3D == 1) {
        int n = theVertices[q];
        
        POS_now = allFractal_XYZSRA[n][j];
      }        
     
      if (POS_min > POS_now) POS_min = POS_now;   
      if (POS_max < POS_now) POS_max = POS_now;   

    }
    
    for (int i = 0; i < 3; i++) {
      float ratio = 0.5 * i;
      selection_BoundingBox[i][j] = (1 - ratio) * POS_min + ratio * POS_max;
    } 
  }
  
}

void SOLARCHVISION_calculate_selection_Pivot () {
  
  SOLARCHVISION_calculate_selection_BoundingBox();

  selected_Pivot_XYZ[0] = selection_BoundingBox[1 + selection_alignX][0];
  selected_Pivot_XYZ[1] = selection_BoundingBox[1 + selection_alignY][1];
  selected_Pivot_XYZ[2] = selection_BoundingBox[1 + selection_alignZ][2];

}


void SOLARCHVISION_save_selection_Pivot () {

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      saved_BoundingBox[i][j] = selection_BoundingBox[i][j];
    }
    saved_Pivot_XYZ[i] = selected_Pivot_XYZ[i];
  } 
  
  saved_alignX = selection_alignX;
  saved_alignY = selection_alignY;
  saved_alignZ = selection_alignZ;
}


void SOLARCHVISION_apply_saved_Pivot () {
  
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      selection_BoundingBox[i][j] = saved_BoundingBox[i][j];
    }
    selected_Pivot_XYZ[i] = saved_Pivot_XYZ[i];
  } 
  
  selection_alignX = saved_alignX;
  selection_alignY = saved_alignY;
  selection_alignZ = saved_alignZ;
}


void SOLARCHVISION_apply_origin_Pivot () {
  
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      selection_BoundingBox[i][j] = 0;
    }
    selected_Pivot_XYZ[i] = 0;
  } 
  
  //selection_alignX = 0;
  //selection_alignY = 0;
  //selection_alignZ = 0;
}




void SOLARCHVISION_reset_selectedRefValues () {
  
  selected_posValue = 0;  
  selected_rotValue = 0;  
  selected_scaleValue = 0; 
}

void SOLARCHVISION_move_selectedPolymeshes (float dx, float dy, float dz) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedPolymesh_Vertices();
  
  for (int q = 1; q < PolymeshVertices.length; q++) {
    
    int n = PolymeshVertices[q];
  
    allVertices[n][0] += dx; 
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }
  
 
  
  
  //println("SOLARCHVISION_calculate_selection_Pivot 10");
  //SOLARCHVISION_calculate_selection_Pivot();   
  for (int i = 0; i < 3; i++) {
    selection_BoundingBox[i][0] += dx;
    selection_BoundingBox[i][1] += dy;
    selection_BoundingBox[i][2] += dz;
  }  
  selected_Pivot_XYZ[0] += dx;
  selected_Pivot_XYZ[1] += dy;
  selected_Pivot_XYZ[2] += dz;

  
  
  int Solids_updated = 0;
  
  for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
  
    int OBJ_NUM = selectedPolymesh_numbers[o];
    
    if (OBJ_NUM != 0) {  
      
      {
        allPolymesh_SolarPivotXYZ[OBJ_NUM][0] += dx;
        allPolymesh_SolarPivotXYZ[OBJ_NUM][1] += dy;
        allPolymesh_SolarPivotXYZ[OBJ_NUM][2] += dz;
      }
      
      for (int g = allPolymesh_Solids[OBJ_NUM][0]; g <= allPolymesh_Solids[OBJ_NUM][1]; g++) {
        if ((0 <= g) && (g < SolidObjects.length)) {
          SolidObjects[g].updatePosition(SolidObjects[g].posX + dx, SolidObjects[g].posY + dy, SolidObjects[g].posZ + dz);
    
          Solids_updated = 1;  
        }
      }
  
    }
  }
  
  if (Solids_updated != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections();  
  
}

void SOLARCHVISION_rotate_selectedPolymeshes (float x0, float y0, float z0, float r, int the_Vector) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedPolymesh_Vertices();
  
  for (int q = 1; q < PolymeshVertices.length; q++) {
    
    int n = PolymeshVertices[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
    
    if (the_Vector == 2) {
      allVertices[n][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[n][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[n][2] = z0 + (z);
    }
    else if (the_Vector == 1) {
      allVertices[n][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[n][1] = y0 + (y);
      allVertices[n][2] = z0 + (z * cos(r) - x * sin(r));
    }    
    else if (the_Vector == 0) {
      allVertices[n][0] = x0 + (x); 
      allVertices[n][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[n][2] = z0 + (y * sin(r) + z * cos(r));
    }    
  }
  
  //println("SOLARCHVISION_calculate_selection_Pivot 11");
  //SOLARCHVISION_calculate_selection_Pivot(); 
  
  int Solids_updated = 0;
  
  for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
  
    int OBJ_NUM = selectedPolymesh_numbers[o];
    
    if (OBJ_NUM != 0) {  
      
      { 
        float x = allPolymesh_SolarPivotXYZ[OBJ_NUM][0] - x0; 
        float y = allPolymesh_SolarPivotXYZ[OBJ_NUM][1] - y0; 
        float z = allPolymesh_SolarPivotXYZ[OBJ_NUM][2] - z0;
        
        if (the_Vector == 2) {
          allPolymesh_SolarPivotXYZ[OBJ_NUM][0] = x0 + (x * cos(r) - y * sin(r)); 
          allPolymesh_SolarPivotXYZ[OBJ_NUM][1] = y0 + (x * sin(r) + y * cos(r));
          allPolymesh_SolarPivotXYZ[OBJ_NUM][2] = z0 + (z);
        }
        else if (the_Vector == 1) {
          allPolymesh_SolarPivotXYZ[OBJ_NUM][0] = x0 + (z * sin(r) + x * cos(r)); 
          allPolymesh_SolarPivotXYZ[OBJ_NUM][1] = y0 + (y);
          allPolymesh_SolarPivotXYZ[OBJ_NUM][2] = z0 + (z * cos(r) - x * sin(r));
        }    
        else if (the_Vector == 0) {
          allPolymesh_SolarPivotXYZ[OBJ_NUM][0] = x0 + (x); 
          allPolymesh_SolarPivotXYZ[OBJ_NUM][1] = y0 + (y * cos(r) - z * sin(r));
          allPolymesh_SolarPivotXYZ[OBJ_NUM][2] = z0 + (y * sin(r) + z * cos(r));
        }          
      }    
      
      for (int g = allPolymesh_Solids[OBJ_NUM][0]; g <= allPolymesh_Solids[OBJ_NUM][1]; g++) {
        if ((0 <= g) && (g < SolidObjects.length)) {
          
          float x = SolidObjects[g].posX - x0; 
          float y = SolidObjects[g].posY - y0; 
          float z = SolidObjects[g].posZ - z0;
          
          if (the_Vector == 2) {
            SolidObjects[g].updatePosition(x0 + (x * cos(r) - y * sin(r)), y0 + (x * sin(r) + y * cos(r)), z0 + (z));
          
            SolidObjects[g].RotateZ(r * 180 / PI);
          }
          else if (the_Vector == 1) {
            SolidObjects[g].updatePosition(x0 + (z * sin(r) + x * cos(r)), y0 + (y), z0 + (z * cos(r) - x * sin(r)));
          
            SolidObjects[g].RotateY(r * 180 / PI);
          }
          else if (the_Vector == 0) {
            SolidObjects[g].updatePosition(x0 + (x), y0 + (y * cos(r) - z * sin(r)), z0 + (y * sin(r) + z * cos(r)));
          
            SolidObjects[g].RotateX(r * 180 / PI);
          }
          
          Solids_updated = 1;  
        }
      }
    }
  }
  
  if (Solids_updated != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections();   
  
}

void SOLARCHVISION_scale_selectedPolymeshes (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedPolymesh_Vertices();
  
  for (int q = 1; q < PolymeshVertices.length; q++) {
    
    int n = PolymeshVertices[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
   
    allVertices[n][0] = x0 + sx * x; 
    allVertices[n][1] = y0 + sy * y;
    allVertices[n][2] = z0 + sz * z;
  }
  
  
  
  //println("SOLARCHVISION_calculate_selection_Pivot 12");
  //SOLARCHVISION_calculate_selection_Pivot();
  for (int i = 0; i < 3; i++) {
    float x = selection_BoundingBox[i][0] - x0; 
    float y = selection_BoundingBox[i][1] - y0; 
    float z = selection_BoundingBox[i][2] - z0;
    
    selection_BoundingBox[i][0] = x0 + sx * x; 
    selection_BoundingBox[i][1] = y0 + sy * y;
    selection_BoundingBox[i][2] = z0 + sz * z;
  }  
  
  
  
  
  int Solids_updated = 0;

  for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
  
    int OBJ_NUM = selectedPolymesh_numbers[o];
    
    if (OBJ_NUM != 0) {
      
      {
        allPolymesh_SolarPivotXYZ[OBJ_NUM][0] = x0 + sx * (allPolymesh_SolarPivotXYZ[OBJ_NUM][0] - x0);
        allPolymesh_SolarPivotXYZ[OBJ_NUM][1] = y0 + sy * (allPolymesh_SolarPivotXYZ[OBJ_NUM][1] - y0);
        allPolymesh_SolarPivotXYZ[OBJ_NUM][2] = z0 + sz * (allPolymesh_SolarPivotXYZ[OBJ_NUM][2] - z0);
      }
      
      for (int g = allPolymesh_Solids[OBJ_NUM][0]; g <= allPolymesh_Solids[OBJ_NUM][1]; g++) {
        if ((0 <= g) && (g < SolidObjects.length)) {
          SolidObjects[g].updatePosition((SolidObjects[g].posX - x0) * sx + x0, (SolidObjects[g].posY - y0) * sy + y0, (SolidObjects[g].posZ - z0) * sz + z0);
          
          SolidObjects[g].Scale(sx, sy, sz);
    
          Solids_updated = 1;  
        }
      }
    }
  }
      
  if (Solids_updated != 0) SOLARCHVISION_calculate_SpatialImpact_selectedSections();        
  
}



void SOLARCHVISION_move_selectedFaces (float dx, float dy, float dz) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();
  
  for (int q = 1; q < FaceVertices.length; q++) {
    
    int n = FaceVertices[q];
  
    allVertices[n][0] += dx; 
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }
  
}

void SOLARCHVISION_rotate_selectedFaces (float x0, float y0, float z0, float r, int the_Vector) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();
  
  for (int q = 1; q < FaceVertices.length; q++) {
    
    int n = FaceVertices[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
    
    if (the_Vector == 2) {
      allVertices[n][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[n][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[n][2] = z0 + (z);
    }
    else if (the_Vector == 1) {
      allVertices[n][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[n][1] = y0 + (y);
      allVertices[n][2] = z0 + (z * cos(r) - x * sin(r));
    }    
    else if (the_Vector == 0) {
      allVertices[n][0] = x0 + (x); 
      allVertices[n][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[n][2] = z0 + (y * sin(r) + z * cos(r));
    }    
  }
  
}

void SOLARCHVISION_scale_selectedFaces (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();
  
  for (int q = 1; q < FaceVertices.length; q++) {
    
    int n = FaceVertices[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
   
    allVertices[n][0] = x0 + sx * x; 
    allVertices[n][1] = y0 + sy * y;
    allVertices[n][2] = z0 + sz * z;
  }

}


void SOLARCHVISION_move_selectedVertices (float dx, float dy, float dz) {

  for (int q = 1; q < selectedVertex_numbers.length; q++) {
    
    int n = selectedVertex_numbers[q];
  
    allVertices[n][0] += dx; 
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }

}


void SOLARCHVISION_rotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedVertex_numbers.length; q++) {
    
    int n = selectedVertex_numbers[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
    
    if (the_Vector == 2) {
      allVertices[n][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[n][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[n][2] = z0 + (z);
    }
    else if (the_Vector == 1) {
      allVertices[n][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[n][1] = y0 + (y);
      allVertices[n][2] = z0 + (z * cos(r) - x * sin(r));
    }    
    else if (the_Vector == 0) {
      allVertices[n][0] = x0 + (x); 
      allVertices[n][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[n][2] = z0 + (y * sin(r) + z * cos(r));
    }    
  }

}


void SOLARCHVISION_scale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {
  
  for (int q = 1; q < selectedVertex_numbers.length; q++) {
    
    int n = selectedVertex_numbers[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
   
    allVertices[n][0] = x0 + sx * x; 
    allVertices[n][1] = y0 + sy * y;
    allVertices[n][2] = z0 + sz * z;
  }
  
}




float SOLARCHVISION_softVertexSelectionFunction(float d_min) {
  
  float v = 0;
  
  if (d_min < softSelection_Radius) {
    v = pow(cos_ang(90 * d_min / softSelection_Radius), softSelection_Power);
  }
  
  return v;
}

void SOLARCHVISION_softMove_selectedVertices (float dx, float dy, float dz) {
  
  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {
    
    int n = selectedVertex_softSelectionVertices[q];
    
    float v = selectedVertex_softSelectionValues[q];
  
    allVertices[n][0] += dx * v; 
    allVertices[n][1] += dy * v;
    allVertices[n][2] += dz * v;
  }
 
}


void SOLARCHVISION_softRotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {
  
  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {
    
    int n = selectedVertex_softSelectionVertices[q];
    
    float v = selectedVertex_softSelectionValues[q];

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
    
    if (the_Vector == 2) {
      allVertices[n][0] = x0 + (x * cos(r * v) - y * sin(r * v)); 
      allVertices[n][1] = y0 + (x * sin(r * v) + y * cos(r * v));
      allVertices[n][2] = z0 + (z);
    }
    else if (the_Vector == 1) {
      allVertices[n][0] = x0 + (z * sin(r * v) + x * cos(r * v)); 
      allVertices[n][1] = y0 + (y);
      allVertices[n][2] = z0 + (z * cos(r * v) - x * sin(r * v));
    }    
    else if (the_Vector == 0) {
      allVertices[n][0] = x0 + (x); 
      allVertices[n][1] = y0 + (y * cos(r * v) - z * sin(r * v));
      allVertices[n][2] = z0 + (y * sin(r * v) + z * cos(r * v));
    }    
  }
  
}





void SOLARCHVISION_softScale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {
  
  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {
    
    int n = selectedVertex_softSelectionVertices[q];
    
    float v = selectedVertex_softSelectionValues[q];    

    float x = allVertices[n][0] - x0; 
    float y = allVertices[n][1] - y0; 
    float z = allVertices[n][2] - z0;
   
    allVertices[n][0] = (x0 + sx * x) * v + (x0 + x) * (1 - v); 
    allVertices[n][1] = (y0 + sy * y) * v + (y0 + y) * (1 - v); 
    allVertices[n][2] = (z0 + sz * z) * v + (z0 + z) * (1 - v); 
  }
  
}



void SOLARCHVISION_move_selectedSection (float dx, float dy, float dz) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {
    
    int n = selectedSection_numbers[q];
    
    allSection_UVERAB[n][0] += dx;
    allSection_UVERAB[n][1] += dy;
    allSection_UVERAB[n][2] += dz;

  }

  SOLARCHVISION_calculate_SpatialImpact_selectedSections();
  
  WIN3D_Update = 1;
  ROLLOUT_Update = 1;    

}


void SOLARCHVISION_rotate_selectedSection (float r) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {
    
    int n = selectedSection_numbers[q];
    
    allSection_UVERAB[n][3] += r * 180.0 / PI; 
    
  }
  
  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
  
  WIN3D_Update = 1;
  ROLLOUT_Update = 1;       

}


void SOLARCHVISION_scale_selectedSection (float sx, float sy) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {
    
    int n = selectedSection_numbers[q];
    
    allSection_UVERAB[n][4] *= sx;
    allSection_UVERAB[n][5] *= sy;
    
  }
  
  SOLARCHVISION_calculate_SpatialImpact_selectedSections(); 
  
  WIN3D_Update = 1;
  ROLLOUT_Update = 1;      
  
}






void SOLARCHVISION_scale_Selection (float x0, float y0, float z0, float sx, float sy, float sz) {

  if (Work_with_2D_or_3D == 8) {

    SOLARCHVISION_scale_selectedSection(sx, sy);
  }   
  
  if (Work_with_2D_or_3D == 7) {

  }       
    
  if (Work_with_2D_or_3D == 6) {
    
    SOLARCHVISION_softScale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }    
  
  if (Work_with_2D_or_3D == 5) {
    
    SOLARCHVISION_scale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }  
  
  if (Work_with_2D_or_3D == 4) {
    
    SOLARCHVISION_scale_selectedFaces(x0, y0, z0, sx, sy, sz);
  }  
  
  if (Work_with_2D_or_3D == 3) {
    
    SOLARCHVISION_scale_selectedPolymeshes(x0, y0, z0, sx, sy, sz);
  }

  if (Work_with_2D_or_3D == 2) {

    int n1 = Object2D_PEOPLE_Files_Num;    
    
    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedObject2D_numbers[o];
      
      if (OBJ_NUM != 0) {      
    
        float x = allObject2D_XYZS[OBJ_NUM][0] - x0; 
        float y = allObject2D_XYZS[OBJ_NUM][1] - y0; 
        //float z = allObject2D_XYZS[OBJ_NUM][2] - z0;
       
        allObject2D_XYZS[OBJ_NUM][0] = x0 + sx * x; 
        allObject2D_XYZS[OBJ_NUM][1] = y0 + sy * y;
        //allObject2D_XYZS[OBJ_NUM][2] = z0 + sz * z;

        int n = allObject2D_MAP[OBJ_NUM];

        if (abs(n) > n1) { // does not scale poeple!    
          allObject2D_XYZS[OBJ_NUM][3] *= sz; 
        }
      }
    }
  }
  
  if (Work_with_2D_or_3D == 1) {
    
    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedFractal_numbers[o];
        
      if (OBJ_NUM != 0) {      
    
        float x = allFractal_XYZSRA[OBJ_NUM][0] - x0; 
        float y = allFractal_XYZSRA[OBJ_NUM][1] - y0; 
        //float z = allFractal_XYZSRA[OBJ_NUM][2] - z0;
        
        allFractal_XYZSRA[OBJ_NUM][0] = x0 + sx * x; 
        allFractal_XYZSRA[OBJ_NUM][1] = y0 + sy * y;
        //allFractal_XYZSRA[OBJ_NUM][2] = z0 + sz * z;

        allFractal_XYZSRA[OBJ_NUM][3] *= sz; // <<<<<<<<<<<<<<
      }
    }
  }  
}



void SOLARCHVISION_rotate_Selection (float x0, float y0, float z0, float r, int the_Vector) {

  if (Work_with_2D_or_3D == 8) {

    SOLARCHVISION_rotate_selectedSection(r);
  }   
  
  if (Work_with_2D_or_3D == 7) {

  }       
  
  if (Work_with_2D_or_3D == 6) {
    
    SOLARCHVISION_softRotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  
  
  if (Work_with_2D_or_3D == 5) {
    
    SOLARCHVISION_rotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  

  if (Work_with_2D_or_3D == 4) {
    
    SOLARCHVISION_rotate_selectedFaces(x0, y0, z0, r, the_Vector);
  }  
  
  if (Work_with_2D_or_3D == 3) {
    
    SOLARCHVISION_rotate_selectedPolymeshes(x0, y0, z0, r, the_Vector);
  }
  
  if (Work_with_2D_or_3D == 2) {
    // no rotation.
  }

  if (Work_with_2D_or_3D == 1) {

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedFractal_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        allFractal_XYZSRA[OBJ_NUM][4] += r; 
      }
    }
  }    

} 




void SOLARCHVISION_move_Selection (float dx, float dy, float dz) {

  if (Work_with_2D_or_3D == 8) {

    SOLARCHVISION_move_selectedSection(dx, dy, dz);
  }   
  
  if (Work_with_2D_or_3D == 7) {

  }      
  
  if (Work_with_2D_or_3D == 6) {

    SOLARCHVISION_softMove_selectedVertices(dx, dy, dz);
  }    
  
  if (Work_with_2D_or_3D == 5) {
    
    SOLARCHVISION_move_selectedVertices(dx, dy, dz);
  }  

  if (Work_with_2D_or_3D == 4) {
    
    SOLARCHVISION_move_selectedFaces(dx, dy, dz);
  }  
  
  if (Work_with_2D_or_3D == 3) {
    
    SOLARCHVISION_move_selectedPolymeshes(dx, dy, dz);
  }

  if (Work_with_2D_or_3D == 2) {

    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedObject2D_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        allObject2D_XYZS[OBJ_NUM][0] += dx; 
        allObject2D_XYZS[OBJ_NUM][1] += dy; 
        allObject2D_XYZS[OBJ_NUM][2] += dz;
      }
    }
  }  
  
  if (Work_with_2D_or_3D == 1) {

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedFractal_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        allFractal_XYZSRA[OBJ_NUM][0] += dx; 
        allFractal_XYZSRA[OBJ_NUM][1] += dy; 
        allFractal_XYZSRA[OBJ_NUM][2] += dz;
      }
    }
  }    
  
}

void SOLARCHVISION_changeProperties_Selection (int p) {

  if (Work_with_2D_or_3D == 4) {

    for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedFace_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        int f = OBJ_NUM;
      
        if (View_Select_Create_Modify == 4) {
          int n = allFaces_MTLV[f][0];
          n += p;
          if (n > 8) n = 0;
          if (n < 0) n = 8;
          allFaces_MTLV[f][0] = n;
        }
        
        if (View_Select_Create_Modify == 5) {
          int n = allFaces_MTLV[f][1];
          n += p;
          if (n > 4) n = 0;
          if (n < 0) n = 4;
          allFaces_MTLV[f][1] = n;              
        }   

        if (View_Select_Create_Modify == 6) {
          int n = allFaces_MTLV[f][2];
          n += p;
          if (n > 16) n = 0;
          if (n < 0) n = 16;
          allFaces_MTLV[f][2] = n;              
        }  

        if (View_Select_Create_Modify == 7) {
          int n = allFaces_MTLV[f][3];
          n += p;
          if (n > 2) n = 0;
          if (n < 0) n = 2;
          allFaces_MTLV[f][3] = n;              
        }          
      }
    } 
    
  }  
  
  if (Work_with_2D_or_3D == 3) {

    for (int o = selectedPolymesh_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedPolymesh_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        for (int f = allPolymesh_Faces[OBJ_NUM][0]; f <= allPolymesh_Faces[OBJ_NUM][1]; f++) {
          if ((0 < f) && (f < allFaces.length)) {
        
            if (View_Select_Create_Modify == 4) {
              int n = allFaces_MTLV[f][0];
              n += p;
              if (n > 8) n = 0;
              if (n < 0) n = 8;
              allFaces_MTLV[f][0] = n;
            }
            
            if (View_Select_Create_Modify == 5) {
              int n = allFaces_MTLV[f][1];
              n += p;
              if (n > 4) n = 0;
              if (n < 0) n = 4;
              allFaces_MTLV[f][1] = n;              
            }      
      
            if (View_Select_Create_Modify == 6) {
              int n = allFaces_MTLV[f][2];
              n += p;
              if (n > 16) n = 0;
              if (n < 0) n = 16;
              allFaces_MTLV[f][2] = n;              
            }  

            if (View_Select_Create_Modify == 7) {
              int n = allFaces_MTLV[f][3];
              n += p;
              if (n > 2) n = 0;
              if (n < 0) n = 2;
              allFaces_MTLV[f][3] = n;              
            }              
          }
        }
      }
    } 
    
  }
  
  if (Work_with_2D_or_3D == 2) {
    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedObject2D_numbers[o];
      
      if (OBJ_NUM != 0) {      
        
        if (View_Select_Create_Modify == 4) {
         
          int n = allObject2D_MAP[OBJ_NUM];
          int sign_n = 1;
          if (n < 0) sign_n = -1;
          
          n = abs(n);
          
          int n1 = Object2D_PEOPLE_Files_Num;
          int n2 = Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num;
          
          
          if (n <= n1) { // case: people 
  
            n += p;
            
            if (n > n1) {n = 1; sign_n *= -1;}
            if (n < 1) {n = n1; sign_n *= -1;}  
          }
          else { // case: trees
  
            n += p;
            
            if (n > n2) {n = n1 + 1; sign_n *= -1;}
            if (n < n1 + 1) {n = n2; sign_n *= -1;}            
          }
          
          n *= sign_n;
          
          allObject2D_MAP[OBJ_NUM] = n;
        } 
      }
    }    
  }

  if (Work_with_2D_or_3D == 1) {

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
      
      int OBJ_NUM = selectedFractal_numbers[o];
      
      if (OBJ_NUM != 0) {      

        if (View_Select_Create_Modify == 4) {
          
          allFractal_Seed[OBJ_NUM] += p;
          
        } 
        if (View_Select_Create_Modify == 8) {
          int q = allFractal_DegreeMax[OBJ_NUM];
          
          q += p;
          
          if (q < 0) q = 0;
          
          allFractal_DegreeMax[OBJ_NUM] = q;

          Create_Fractal_Plant_DegreeMax = q;
          ROLLOUT_Update = 1;
        }
        if (View_Select_Create_Modify == 9) {
          int q1 = allFractal_DegreeMin[OBJ_NUM];
          int q2 = allFractal_DegreeMax[OBJ_NUM];
          q1 += p;
          q2 += p;
          
          int change_them = 1; 
          
          if (q1 < 0) {q1 = 0; change_them = 0;} 
          if (q2 < 0) {q2 = 0; change_them = 0;}
          
          if (change_them == 1) {
          
            allFractal_DegreeMin[OBJ_NUM] = q1;
            allFractal_DegreeMax[OBJ_NUM] = q2;
  
            Create_Fractal_Plant_DegreeMin = q1;
            Create_Fractal_Plant_DegreeMax = q2;
            
            ROLLOUT_Update = 1;
          }
        }
        if (View_Select_Create_Modify == 10) {
          int q = allFractal_DegreeMin[OBJ_NUM];
          
          q += p;
          
          if (q < 0) q = 0;
          
          allFractal_DegreeMin[OBJ_NUM] = q;

          Create_Fractal_Plant_DegreeMin = q;
          ROLLOUT_Update = 1;
        }        
        if (View_Select_Create_Modify == 11) {
          float q = allFractal_TrunkSize[OBJ_NUM];
          
          q += 0.25 * p;
          
          if (q < 0) q = 0;
          
          allFractal_TrunkSize[OBJ_NUM] = q;
          
          Create_Fractal_Plant_TrunkSize = q;
          ROLLOUT_Update = 1;
        }
        if (View_Select_Create_Modify == 12) {
          float q = allFractal_LeafSize[OBJ_NUM];
          
          q += 0.25 * p;
          
          if (q < 0) q = 0;
          
          allFractal_LeafSize[OBJ_NUM] = q;

          Create_Fractal_Plant_LeafSize = q;
          ROLLOUT_Update = 1;
        }

      }
    }    
    
  }    

} 




void dessin_Mouse (int _type, float x, float y, float r) {

  float d = 0.4 * r;

  for (int i = 0; i < 3; i++) { 

    float dx = 0;
    float dy = 0;
    
    if (i == 0) {
      dx = 0.5 * d;
      dy = 0.5 * d;
      strokeWeight(1);
      stroke(63); 
      fill(63); 
    }
    else if (i == 1) {
      strokeWeight(3);
      stroke(0); 
      fill(0);
    }   
    else {
      strokeWeight(1);
      stroke(1);
      stroke(255); 
      fill(255);
    }          
    
    pushMatrix();
    translate(x + d + dx, y + d + dy);

    triangle(-d,-d, -d,d, d,-d); 

    if (i == 1) {
      strokeWeight(2 + d);
    }
    else { 
      strokeWeight(d);
    }
  
    line(0,0, d,d);
    
    popMatrix();
  
  }
  
  strokeWeight(0);  
}

void dessin_ClickSelect (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(255);  
  
  float d = 0.3 * r;
  triangle(-d,-d, -d,d, d,-d); 

  strokeWeight(5);
  line(0,0, d,d);

  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);}

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_WindowSelect (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(63);  
  rect(-0.5 * r, -0.5 * r, 1.25 * r, 1.25 * r);

  strokeWeight(1);
  stroke(255); 
  fill(255);  
  
  float d = 0.3 * r;
  triangle(-d,-d, -d,d, d,-d); 

  strokeWeight(5);
  line(0,0, d,d);

  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);}

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Move (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 
  
  strokeWeight(3);
  stroke(255); 
  noFill();  
  
  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);  
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
  if (_type == 4) line(-0.4 * r, -0.4 * r, 0.4 * r, 0.4 * r);
 
  noStroke();
  fill(255,0,0);
  float d = 5;
  if (_type == 1) {ellipse(-0.8 * r, 0, d, d); ellipse(0.8 * r, 0, d, d);}
  if (_type == 2) {ellipse(0.4 * r, -0.4 * r, d, d); ellipse(-0.4 * r, 0.4 * r, d, d);}    
  if (_type == 3) {ellipse(0, 0.8 * r, d, d); ellipse(0, -0.8 * r, d, d);}
  if (_type == 4) {ellipse(-0.4 * r, -0.4 * r, d, d); ellipse(0.4 * r, 0.4 * r, d, d);}  

  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}

void dessin_Scale (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  
  strokeWeight(5);
  stroke(0,255,0); 
  noFill();  
  
  if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
  if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
  if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
  if (_type == 4) {
    line(-0.4 * r, 0, 0.4 * r, 0);
    line(0, 0.4 * r, 0, -0.4 * r);
    line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
  }  

  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}

void dessin_Rotate (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 
  
  strokeWeight(3);
  stroke(255); 
  noFill();  
  
  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
 
  strokeWeight(2);
  stroke(0,127,255);
  noFill();
  float d = 0.85 * r;
  if (_type == 1) {arc(0, 0, d, d, 0.25 * PI, 1.75 * PI);}
  if (_type == 2) {arc(0, 0, d, d, (0.25 + 0.75) * PI, (1.75 + 0.75) * PI);}
  if (_type == 3) {arc(0, 0, d, d, (0.25 - 0.5) * PI, (1.75 - 0.5) * PI);}
  
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}





void dessin_Seed (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  
  
  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  
  strokeWeight(1);
  stroke(255,255,0); 
  noFill();  

  for (int i = 0; i < 360; i += 30) {
    float d = random(0.25,0.75);
    
    line(0, 0, 0.8 * r * d * cos(i), 0.8 * r * d * sin(i));
  }  

  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);}
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 4) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);}

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_Tessellation (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  float d = 1.25 * r;

  strokeWeight(2);
  stroke(255); 
  fill(63);  
  rect(-0.5 * d, -0.5 * d, d, d);

  strokeWeight(1);
  stroke(191); 
  fill(191);  

  for (int i = 1; i < 4; i++) {
    float w = (0.25 * i - 0.5) * d;
    line(-0.5 * d, w, 0.5 * d, w);  
    line(w, -0.5 * d, w, 0.5 * d);
  }

  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);}
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 4) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);}
  
  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Layer (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(2);
  stroke(255); 
  fill(0,127,255);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);
 
  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);}
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 4) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);}
  
  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Visibility (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(0);
  stroke(255); 
  fill(127,127);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);
 
  stroke(0,127,255);
  strokeWeight(3);
  if (_type == 2) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);}
  if (_type == 3) {line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);} 
  if (_type == 4) {line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);}
  
  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_FaceNormal (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  if (_type == 1) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
    
    line(0, 0.5 * d, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }

  if (_type == 2) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
  }
  

  if (_type == 3) {
    line(0, 0, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }  
    
    
  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_FaceFirstVertex (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE);
  
  stroke(255,0,0);
  ellipse(0, 0, 0.25 * d, 0.25 * d);
  
  fill(255);
  textSize(d);
  textAlign(CENTER, BOTTOM);
  text("1st", 0, 0);

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_3DViewSpace (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  noFill();

  strokeWeight(1);
  stroke(255); 
  if (_type == 1) fill(63);  
  if (_type == 2) fill(191);
  rect(-0.75 * r, -0.75 * r, 1.5 * r, 1.5 * r);

  if (_type == 1) fill(191);  
  if (_type == 2) fill(63);
  rect(-0.75 * r, -0.75 * r, 0.75 * r, 0.75 * r);
  
  strokeWeight(2);
  line(0, 0, 0.75 * r, 0.75 * r);

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}

void dessin_ProjectionType (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  fill(0);

    
  float d = 0.8 * r;

  if (_type == 1) {
    
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

  }  
  
  if (_type == 2) {

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0.75 * sin_ang(0) * d, 0.75 * -cos_ang(0) * d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(0.75 * sin_ang(120) * d, 0.75 * -cos_ang(120) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(0.75 * sin_ang(240) * d, 0.75 * -cos_ang(240) * d);
    endShape(CLOSE);
  }
  


  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Truck (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);

  
  stroke(255); 
  fill(0);

  float d = 0.625 * r;
  
  float a = 0;
  float b = 0;
  if (_type == 1) {a = cos_ang(30) * d; b = -sin_ang(30) * d;}
  if (_type == 2) {a = -cos_ang(30) * d; b = -sin_ang(30) * d;}
  if (_type == 3) {a = 0; b = d;}
  
  strokeWeight(1);
  {
    pushMatrix();
    translate(0.5 * a, 0.5 * b);
      
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    popMatrix();
  }
    


  
  strokeWeight(2);
  {
    pushMatrix();
    translate(-0.5 * a, -0.5 * b);
      
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}




void dessin_Zoom (int _type, float x, float y, float r) {
  
  pushMatrix();
  translate(x, y);
  
  {
    pushMatrix();
    translate(0.25 * r, 0.25 * r);
  
    stroke(255); 
    
    fill(0);
    strokeWeight(1);
    ellipse(-0.4 * r, -0.4 * r, 0.8 * r, 0.8 * r); 
  
    noFill();  
    strokeWeight(4);
    line(-0.1 * r, -0.1 * r, 0.3 * r, 0.3 * r);
  
    strokeWeight(2);
    stroke(255,255,0);
    if (_type == 1) {line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r); line(-0.4 * r, -0.6 * r, -0.4 * r, -0.2 * r);} 
    if (_type == 2) {line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);}
    
    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_3DModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  stroke(255); 
  fill(0);
  strokeWeight(2);
  ellipse(0,0, r,r);
  noFill();
  strokeWeight(1);
  ellipse(0,0, 1.5 * r, 1.5 * r); 
  
  strokeWeight(1);
  line(-0.75 * r, 0, -0.5 * r, 0);
  line(0, -0.75 * r, 0, -0.5 * r);
  line(0.75 * r, 0, 0.5 * r, 0);
  line(0, 0.75 * r, 0, 0.5 * r);


  strokeWeight(2);
  stroke(255,255,0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}





void dessin_AllModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);
  
  float d = 0.75 * r;

  stroke(255); 
  fill(0); 
  strokeWeight(1);
  ellipse(0,0, d,d);
  noFill();
  strokeWeight(1);
  ellipse(0,0, 2 * d, 2 * d); 
  
  strokeWeight(1);
  line(-1 * d, 0, -0.5 * d, 0);
  line(0, -1 * d, 0, -0.5 * d);
  line(1 * d, 0, 0.5 * d, 0);
  line(0, 1 * d, 0, 0.5 * d);


  strokeWeight(2);
  stroke(255,255,0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_SkydomeSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    pushMatrix();
    translate(0, 0.125 * r);

    float d = 1.0 * r;
  
    strokeWeight(1);
    stroke(255); 
    fill(0);
    arc(0,0, d,d, PI, 2 * PI); 
    arc(0,0, d,0.333 * d, 0, PI);
    
    d = 1.5 * r;
    
    strokeWeight(2);
    stroke(255); 
    noFill();  
    arc(0,0, d,d, PI, 2 * PI);
    arc(0,0, d,0.333 * d, 0, PI);
    
    popMatrix();
  }

  strokeWeight(2);
  stroke(255,255,0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Orbit (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 1.5 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0); 
  ellipse(0,0, d,d); 
  
  strokeWeight(2);
  stroke(255); 
  noFill();  
  
  if (_type == 3) arc(0,0, d,0.333 * d, 0, PI); 
  if (_type == 2) arc(0,0, 0.333 * d,d, 0.5 * PI, 1.5 * PI); 
  if (_type == 1) {arc(0,0, 0.333 * d,d, 0.5 * PI, 1.5 * PI); arc(0,0, d,0.333 * d, 0, PI);}
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_LookAtOrigin (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);
  
  strokeWeight(2);
  stroke(255);
  fill(127,63,0); 

  {
    float d = 0.8 * r;
  
    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_LookAtSelection (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);
  
  strokeWeight(2);
  stroke(255);
  fill(127,63,0); 
  
  {
    float d = 0.8 * r;
  
    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }
  
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;
    
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }    
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_CameraRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    float d = 1.5 * r;
    
    strokeWeight(1);
    stroke(255); 
    fill(0);
    ellipse(0,0, d,d); 
  }

  
  strokeWeight(1);
  stroke(255);
  fill(127,63,0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;
    
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  
  

  
  {
    float d = 1.5 * r;
    
    strokeWeight(2);
    stroke(255); 
    noFill();  
    
    if (_type == 3) arc(0,0, d,0.333 * d, 0, PI); 
    if (_type == 2) arc(0,0, 0.333 * d,d, 0.5 * PI, 1.5 * PI); 
    if (_type == 1) {arc(0,0, 0.333 * d,d, 0.5 * PI, 1.5 * PI); arc(0,0, d,0.333 * d, 0, PI);}
  }  
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_TargetRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {  
  
    float d = 1.5 * r;
    
    strokeWeight(1);
    stroke(255); 
    fill(0);  
    rect(-d/2,-d/2, d,d);   
  
    strokeWeight(2);
    stroke(255); 
    noFill();  
    
    if (_type == 3) arc(0,0, d,0.333 * d, PI, 2 * PI); 
    if (_type == 2) arc(0,0, 0.333 * d,d, -0.5 * PI, 0.5 * PI); 
    if (_type == 1) {arc(0,0, 0.333 * d,d, -0.5 * PI, 0.5 * PI); arc(0,0, d,0.333 * d, PI, 2 * PI);}
  }

  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}


void dessin_Pan (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);
  
  {
    float d = 1.0 * r;
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
    arc(0,0, d,d, 0,PI); 
  
    stroke(255); 
    noFill();  
    
    for (float i = -1.5; i <= 1.5; i++) { 
      line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);
      
      if (i < 1.5) arc(i * 0.25 * d,-0.5 * d, 0.25 * d, 0.25 * d, PI,2*PI); 
    }
  }

  strokeWeight(2);
  stroke(255); 
  noFill();  
  {
    float d = 0.75 * r;

    if (_type == 2) {
      line(-1 * d, 0, -0.5 * d, 0);
      line(1 * d, 0, 0.5 * d, 0);      
    }
    if (_type == 3) {
      line(0, -1 * d, 0, -0.5 * d);
      line(0, 1 * d, 0, 0.5 * d);
    }
  }
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_DistMouseXY (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, -0.5 * r, r, -0.5 * r);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, r, 0);
  line(-0.5 * r, -0.5 * r, -r, 0);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, 0, r);

  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_CameraDistance (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);
  
  strokeWeight(1);
  stroke(255);
  fill(127,63,0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;
    
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0,d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  
    
  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}



void dessin_DistZ (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);

  
  strokeWeight(0);
  
  popMatrix();

  BAR_b_Display_Text = 0;
}






int X_moved = -1;
int Y_moved = -1;


void mouseMoved () {

  if (frameCount > Last_initializationStep) {
  
    if (automated == 0) {
  
      if (BAR_a_selected_parent != -1) {
        
        if ((X_moved != mouseX) || (Y_moved != mouseY)) {
        
          X_moved = mouseX;
          Y_moved = mouseY;      
          
          BAR_a_Update = 1;     
         
          redraw(); 
        }
      } 
   
    }
  }
}



PImage pre_screen;

int BAR_a_Update = 1;

float BAR_a_width_parent = 4 * a_pixel;
float BAR_a_width_child = 3.5 * BAR_a_width_parent;

int BAR_a_selected_parent = -1;
int BAR_a_selected_child = 0;

String[][] BAR_a_Items = {
                        {"SOLARCHVISION-2015", "Designed & developed by", "Mojtaba Samimi", "www.solarchvision.com"},  
                        {"Project", "New", "Save", "Hold", "Fetch", "Open...", "Save As...", "Export 3D-Model", "Import 3D-Model...", "Preferences", "Quit"},
                        {"Site"}, // Locations
                        {"Data", "Typical Year (TMY)", "Long-term (CWEEDS)", "Real-time Observed (SWOB)", "Weather Forecast (NAEFS)"},
                        {"View", "Perspective", "Orthographic", "Zoom", "Zoom as default", "Look at origin", "Look at selection", "Pan", "PanX", "PanY", "Orbit", "OrbitXY", "OrbitZ", "CameraRoll", "CameraRollXY", "CameraRollZ", "TargetRoll", "TargetRollXY", "TargetRollZ", "TruckX", "TruckY", "TruckZ", "DistZ", "DistMouseXY", "CameraDistance",  "3DModelSize", "SkydomeSize", "Shrink 3DViewSpace", "Enlarge 3DViewSpace", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W."},
                        {"Display", "Display/Hide Land Mesh", "Display/Hide Land Texture", "Display/Hide Land Depth", "Display/Hide Edges", "Display/Hide Normals", "Display/Hide Leaves", "Display/Hide Living Objects", "Display/Hide Building Objects", "Display/Hide Urban", "Display/Hide Sections", "Display/Hide Sky", "Display/Hide Sun Path", "Display/Hide Sun Pattern", "Display/Hide Star", "Display/Hide Moon", "Display/Hide Troposphere", "Display/Hide Earth", "Display/Hide Shading Section", "Display/Hide Spatial Section", "Display/Hide Wind Flow", "Display/Hide Selected Sections", "Display/Hide Selected Faces", "Display/Hide Selected Faces Vertex Count", "Display/Hide Selected Vertices", "Display/Hide Selected Solar Pivots", "Display/Hide Selected 3-D Pivot", "Display/Hide Selected 3-D Edges", "Display/Hide Selected 3-D Box", "Display/Hide Selected 2½D Edges", "Display/Hide Selected ∞-D Edges", "Display/Hide SWOB points", "Display/Hide SWOB nearest", "Display/Hide NAEFS points", "Display/Hide NAEFS nearest", "Display/Hide CWEEDS points", "Display/Hide CWEEDS nearest", "Display/Hide EPW points", "Display/Hide EPW nearest"},
                        {"Shade", "Shade Surface Wire", "Shade Surface Base", "Shade Surface White", "Shade Surface Materials", "Shade Global Solar", "Shade Vertex Solar", "Shade Vertex Spatial", "Shade Vertex Elevation"},
                        {"Study", "Wind pattern (active)", "Wind pattern (passive)", "Urban solar potential (active)", "Urban solar potential (passive)", "Orientation potential (active)", "Orientation potential (passive)", "Hourly sun position (active)", "Hourly sun position (passive)", "View from sun & sky (active)", "View from sun & sky (passive)", "Annual cycle sun path (active)", "Annual cycle sun path (passive)", "Pre-bake Selected Sections", "Process Active Impact", "Process Passive Impact", "Process Spatial Impact", "Run wind 3D-model"},
                        {"Layer"}, // Parameters 
                        {"Layout", "Layout -2", "Layout -1", "Layout 0", "Layout 1", "Layout 2", "Layout 3", "Layout 4", "Layout 5", "Layout 6", "Layout 7", "Layout 8", "Layout 9", "Layout 10", "Layout 11", "Layout 12", "Layout 13", "Layout 14"}, 
                        {"Create", "Pick Study Plane", "Fractal", "Tree", "Person", "House", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Tri", "Hyper", "Poly", "Extrude", "Parametric 1", "Parametric 2", "Parametric 3", "Parametric 4", "Parametric 5", "Parametric 6", "Parametric 7"}, 
                        {"Select", "Reverse Selection", "Deselect All", "Select All", "Select Section", "Select Fractal", "Select Object2D", "Select Polymesh", "Select Face", "Select Vertex", "Soft Selection", "Polymesh >> Face", "Polymesh >> Vertex", "Vertex >> Polymesh", "Vertex >> Face", "Face >> Vertex", "Face >> Polymesh", "Click Select", "Click Select+", "Click Select-", "Window Select", "Window Select+", "Window Select-", "Select Near Vertices", "Select Isolated Vertices"},
                        {"Edit", "Duplicate Selection", "Delete Selection", "Delete All Isolated Vertices", "Delete Isolated Vertices Selection", "Separate Vertices Selection", "Reposition Vertices Selection", "Weld Objects Vertices Selection", "Weld Scene Vertices Selection", "Offset(above) Vertices", "Offset(below) Vertices", "Offset(expand) Vertices", "Offset(shrink) Vertices", "Extrude Face Edges", "Tessellation Triangular", "Tessellate Rectangular", "Tessellate Rows & Columns", "Insert Corner Opennings", "Insert Parallel Opennings", "Insert Rotated Opennings", "Insert Edge Opennings", "Reverse Visibility of All Faces", "Hide All Faces", "Hide Selected Faces", "Unhide Selected Faces", "Unhide All Faces", "Isolate Selected Faces"},
                        {"Modify", "Save Current Pivot", "Reset Saved Pivot", "Use Selection Pivot", "Use Origin Pivot", "PivotX:Minimum", "PivotX:Center", "PivotX:Maximum", "PivotY:Minimum", "PivotY:Center", "PivotY:Maximum", "PivotZ:Minimum", "PivotZ:Center", "PivotZ:Maximum", "Move", "MoveX", "MoveY", "MoveZ", "Scale", "ScaleX", "ScaleY", "ScaleZ", "Rotate", "RotateX", "RotateY", "RotateZ", "Flip FaceNormal", "Set-Out FaceNormal", "Set-In FaceNormal", "Get FaceFirstVertex", "Change Seed/Material", "Change Tessellation", "Change Layer", "Change Visibility", "Change DegreeMax", "Change DegreeDif", "Change DegreeMin", "Change TrunkSize", "Change LeafSize"},
                        {"Match", "Pick Seed/Material", "Pick Tessellation", "Pick Layer", "Pick Visibility", "Pick DegreeMax", "Pick DegreeDif", "Pick DegreeMin", "Pick TrunkSize", "Pick LeafSize", "Pick AllFractalProps", "Assign Seed/Material", "Assign Tessellation", "Assign Layer", "Assign Visibility", "Assign DegreeMax", "Assign DegreeDif", "Assign DegreeMin", "Assign TrunkSize", "Assign LeafSize", "Assign AllFractalProps", "Assign SolarPivot"},
                        {"Action", "Undo", "Redo", "JPG Time Graph", "PDF Time Graph", "JPG Location Graph", "PDF Location Graph", "JPG Spatial Graph", "Screenshot", "Screenshot+Click", "Screenshot+Drag", "REC. Time Graph", "REC. Location Graph", "REC. Spatial Graph", "REC. Screenshot", "Stop REC."}

                      };



 


int N_Site_in_Bar_a = 2; 
{
  
  BAR_a_Items[N_Site_in_Bar_a] = new String [1 + DEFINED_STATIONS.length];
  
  BAR_a_Items[N_Site_in_Bar_a][0] = "Site";
  
  for (int i = 0; i < DEFINED_STATIONS.length; i++) {
  
    BAR_a_Items[N_Site_in_Bar_a][i + 1] = DEFINED_STATIONS[i][0];
    
  }
} 

int N_Layer_in_Bar_a = 8; 
{
  
  BAR_a_Items[N_Layer_in_Bar_a] = new String [num_layers + 12];
  
  BAR_a_Items[N_Layer_in_Bar_a][0] = "Layer";
  
  for (int i = 1; i < num_layers; i++) {
  
    BAR_a_Items[N_Layer_in_Bar_a][i] = LAYERS_Title[i - 1][_EN];
  }
 
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 0] = "12h accumulated Precipitation";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 1] = "Hourly precipitation";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 2] = "Wind power";  
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 3] = "Accumulated degree day <18°C<";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 4] = "Accumulated radiation on tracker";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 5] = "Accumulated radiation on surface";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 6] = "Radiation on surface inclination";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 7] = "Radiation on solar tracker";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 8] = "Radiation on surface material";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 9] = "Normal trend of parameter";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 10] = "Passive trend of parameter";
  BAR_a_Items[N_Layer_in_Bar_a][num_layers + 11] = "Active trend of parameter";
    
   
}


void SOLARCHVISION_draw_window_BAR_a () {
  
  if (BAR_a_Update == 1) {
    
    //println("Update BAR!");
    
    BAR_a_Update = 0;
    
    fill(127);
    noStroke();
    
    rect(0, 0, width, a_pixel);
  
    X_control = 0; //0.25 * MESSAGE_S_View;
    Y_control = 0.5 * a_pixel;
    
    for (int i = 0; i < BAR_a_Items.length; i++) {
  
      float cx = X_control + i * BAR_a_width_parent;
      float cy = Y_control;
      float cr = 0.5 * a_pixel; 
  
      if (i > 0) cx += 1.5 * BAR_a_width_parent; // to include SOLARCHVISION title     
  
      if (isInside(mouseX, mouseY, cx, cy - cr, cx + BAR_a_width_parent, cy + cr) == 1) {
  
        if (BAR_a_selected_parent == -1) {
          
          pre_screen = get(0, a_pixel, width, height - a_pixel);
          
          //println("Screen GET!");
        }     
        
        BAR_a_selected_parent = i;
        
        BAR_a_selected_child = 0;

      }     
      
  
      textAlign(LEFT, CENTER);   
     
      if (BAR_a_selected_parent == i) {
        
        stroke(0); 
        fill(0);
        textSize(1.25 * MESSAGE_S_View);
      }
      else {
        stroke(255); 
        fill(255);
        textSize(1.25 * MESSAGE_S_View);
      }
              
      text(BAR_a_Items[i][0], cx + 0.5 * MESSAGE_S_View, cy - 0.2 * MESSAGE_S_View);
  
 
  
      if (BAR_a_selected_parent == i) {
        
        image(pre_screen, 0, a_pixel);

        BAR_a_selected_child = 0; 
        
        for (int j = 1; j < BAR_a_Items[BAR_a_selected_parent].length; j++) {
          
          if (isInside(X_moved,Y_moved, cx, cy - cr + j * a_pixel, cx + BAR_a_width_child, cy + cr + j * a_pixel) == 1) {

            BAR_a_selected_child = j;
            
            fill(255,127,0);
            noStroke();
            rect(cx, cy - cr + j * a_pixel, BAR_a_width_child, a_pixel);          
          }  
          else {
            
            fill(0, 223);
            noStroke();
            rect(cx, cy - cr + j * a_pixel, BAR_a_width_child, a_pixel);          
          }
          
          textAlign(LEFT, CENTER);
          
          if (BAR_a_selected_child == j) {
            
            stroke(0); 
            fill(0);
            textSize(1.25 * MESSAGE_S_View);
          }
          else {
            stroke(255); 
            fill(255);
            
            if (BAR_a_Items[i][0].equals("Display")) {
              if (BAR_a_Items[i][j].equals("Display/Hide Land Mesh")) {
                if (Display_LAND_MESH == 0) {stroke(127); fill(127);}
              }       
              if (BAR_a_Items[i][j].equals("Display/Hide Land Texture")) {
                if (Display_LAND_TEXTURE == 0) {stroke(127); fill(127);}
              }           
              if (BAR_a_Items[i][j].equals("Display/Hide Land Depth")) {
                if (Display_LAND_DEPTH == 0) {stroke(127); fill(127);}
              }          
              if (BAR_a_Items[i][j].equals("Display/Hide Edges")) {
                if (Display_MODEL3D_EDGES == 0) {stroke(127); fill(127);}
              } 
              if (BAR_a_Items[i][j].equals("Display/Hide Normals")) {
                if (Display_MODEL3D_NORMALS == 0) {stroke(127); fill(127);}
              }               
              if (BAR_a_Items[i][j].equals("Display/Hide Leaves")) {
                if (Display_Leaves == 0) {stroke(127); fill(127);}
              }                
              if (BAR_a_Items[i][j].equals("Display/Hide Living Objects")) {
                if (Display_Trees_People == 0) {stroke(127); fill(127);}
                //if (Display_FractalPlant == 0) {stroke(127); fill(127);}
                //if (Display_Leaves == 0) {stroke(127); fill(127);}
              } 
              if (BAR_a_Items[i][j].equals("Display/Hide Building Objects")) {
                if (Display_Building_Model == 0) {stroke(127); fill(127);}
              }           
              if (BAR_a_Items[i][j].equals("Display/Hide Urban")) {
                if (Display_URBAN_MESH == 0) {stroke(127); fill(127);}
              } 
              if (BAR_a_Items[i][j].equals("Display/Hide Sections")) {
                if (Display_Sections == 0) {stroke(127); fill(127);}
              }               
              if (BAR_a_Items[i][j].equals("Display/Hide Sky")) {
                if (Display_SKY3D == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide Sun Path")) {
                if (Display_SUN3D_Path == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide Sun Pattern")) {
                if (Display_SUN3D_Pattern == 0) {stroke(127); fill(127);}
              }              
              if (BAR_a_Items[i][j].equals("Display/Hide Star")) {
                if (Display_STAR3D == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide Moon")) {
                if (Display_MOON3D == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide Earth")) {
                if (Display_EARTH3D == 0) {stroke(127); fill(127);}
              }    
              if (BAR_a_Items[i][j].equals("Display/Hide Troposphere")) {
                if (Display_TROPO3D == 0) {stroke(127); fill(127);}
              }  
              if (BAR_a_Items[i][j].equals("Display/Hide Shading Section")) {
                if (Display_SolarImpact_Image == 0) {stroke(127); fill(127);}
              }  
              if (BAR_a_Items[i][j].equals("Display/Hide Spatial Section")) {
                if (Display_SpatialImpact_Image == 0) {stroke(127); fill(127);}
              } 
              if (BAR_a_Items[i][j].equals("Display/Hide Wind Flow")) {
                if (Display_windFlow == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide Selected Sections")) {
                if (selectedSection_displayEdges == 0) {stroke(127); fill(127);}
              }                
              if (BAR_a_Items[i][j].equals("Display/Hide Selected Faces")) {
                if (selectedPolymesh_displayPivot == 0) {stroke(127); fill(127);}
              }      
              if (BAR_a_Items[i][j].equals("Display/Hide Selected Faces Vertex Count")) {
                if (selectedPolymesh_displayPivot == 0) {stroke(127); fill(127);}
              }               
              if (BAR_a_Items[i][j].equals("Display/Hide Selected Vertices")) {
                if (selectedPolymesh_displayPivot == 0) {stroke(127); fill(127);}
              }      
              if (BAR_a_Items[i][j].equals("Display/Hide Selected Solar Pivots")) {
                if (selectedPolymesh_displayPivot == 0) {stroke(127); fill(127);}
              }                    
              if (BAR_a_Items[i][j].equals("Display/Hide Selected 3-D Pivot")) {
                if (selectedPolymesh_displayPivot == 0) {stroke(127); fill(127);}
              }          
              if (BAR_a_Items[i][j].equals("Display/Hide Selected 3-D Edges")) {
                if (selectedPolymesh_displayEdges == 0) {stroke(127); fill(127);}
              }    
              if (BAR_a_Items[i][j].equals("Display/Hide Selected 3-D Box")) {
                if (selectedPolymesh_displayBox == 0) {stroke(127); fill(127);}
              }    
              if (BAR_a_Items[i][j].equals("Display/Hide Selected 2½D Edges")) {
                if (selectedObject2D_displayEdges == 0) {stroke(127); fill(127);}
              }    
              if (BAR_a_Items[i][j].equals("Display/Hide Selected ∞-D Edges")) {
                if (selectedFractal_displayEdges == 0) {stroke(127); fill(127);}
              }              
              if (BAR_a_Items[i][j].equals("Display/Hide SWOB points")) {
                if (Display_SWOB_points == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide SWOB nearest")) {
                if (Display_SWOB_nearest == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide NAEFS points")) {
                if (Display_NAEFS_points == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide NAEFS nearest")) {
                if (Display_NAEFS_nearest == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide CWEEDS points")) {
                if (Display_CWEEDS_points == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide CWEEDS nearest")) {
                if (Display_CWEEDS_nearest == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide EPW points")) {
                if (Display_EPW_points == 0) {stroke(127); fill(127);}
              }
              if (BAR_a_Items[i][j].equals("Display/Hide EPW nearest")) {
                if (Display_EPW_nearest == 0) {stroke(127); fill(127);}
              }          
              
            }
                    
            textSize(1.25 * MESSAGE_S_View);
          }
  
          text(BAR_a_Items[i][j], cx + 0.5 * MESSAGE_S_View, cy - 0.2 * MESSAGE_S_View + j * a_pixel);
          
        }     
      } 
      
    }
    
    X_clicked = -1;
    Y_clicked = -1;
  }

}



int BAR_b_Update = 1;

float BAR_b_tab = b_pixel;

String[][] BAR_b_Items = {
                          {"1", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "3DViewPoint", "2.0"},
                          {"2", "AllViewsports", "Expand3DView", "3DViewSpace", "1"},
                          
                          {"2", "P<>", "P><", "ProjectionType", "1.0"},
                          {"1", "LAO", "LookAtOrigin", "1.0"},
                          {"1", "LAS", "LookAtSelection", "1.0"},
                          {"3", "CRL", "CRLz", "CRLxy", "CameraRoll", "1.0"},
                          {"1", "±CDS", "CameraDistance", "1.0"},
                          {"1", "±CDM", "DistMouseXY", "1.0"},
                          {"1", "±CDZ", "DistZ", "1.0"},
                          {"3", "DIz", "DIx", "DIy", "Truck", "1.0"},
                          {"1", "OR", "ORxy", "ORz", "Orbit", "1.0"},                          
                          {"1", "TRL", "TRLz", "TRLxy", "TargetRoll", "1.0"},
                          {"1", "Pan", "PanX", "PanY", "Pan", "1.0"},
                          {"1", "±ZM", "0ZM", "Zoom", "1.0"},
                          {"1", "±SA", "AllModelSize", "1.0"},
                          {"1", "±SZ", "3DModelSize", "1.0"},                          
                          {"1", "±SK", "SkydomeSize", "1.0"},
                         
                          {"2", "Fractal", "Tree", "Person", "LivingType", "1.5"},
                          {"1", "House", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Tri", "Hyper", "Poly", "Extrude", "Parametric", "BuildingType", "2.5"},
                          {"1", "as_Mesh", "as_Solid", "Mesh|Solid", "2.0"},  
                          
                          {"2", "∞-D", "2½D", "3-D", "Face", "Vertex", "Soft", "Solid", "Section", "LayerType", "2.0"},
                          {"1", "±CS", "+CS", "-CS", "ClickSelect", "1.0"},
                          {"1", "±WS", "+WS", "-WS", "WindowSelect", "1.0"},                          
                          {"2", "X<", "X|", "X>", "PivotX", "1.0"},
                          {"2", "Y<","Y|", "Y>", "PivotY", "1.0"},
                          {"2", "Z<","Z|", "Z>", "PivotZ", "1.0"},
                          {"3", "MVx", "MVy", "MVz", "MV³", "Move", "1.0"},
                          {"3", "SCx", "SCy", "SCz", "SC³", "Scale", "1.0"}, 
                          {"3", "RTx", "RTy", "RTz", "Rotate", "1.0"}, 
                          {"1", "Mat0", "Mat1", "Mat2", "Mat3", "Change Seed/Material", "1.0"},
                          {"1", "Tes0", "Tes1", "Tes2", "Tes3", "Change Tessellation", "1.0"},
                          {"1", "Lyr0", "Lyr1", "Lyr2", "Lyr3", "Change Layer", "1.0"},
                          {"1", "Vsb0", "Vsb1", "Vsb2", "Vsb3", "Change Visibility", "1.0"},
                          {"1", "FNorm1", "FNorm2", "FNorm3", "FaceNormal", "1.0"},
                          {"1", "F1stV", "FaceFirstVertex", "1.0"},
                          
                          //{"1", "<pvt>", ">pvt<", "|pvt|", ".pvt.", "Get/Set Pivot", "1.0"},
                          
                          //{"1", "SPvt0", "SPvt1", "SPvt2", "SolarPivot", "1.0"},
                          
                          //{"1", "dgMax0", "dgMax1", "dgMax2", "Change DegreeMax", "1.0"},
                          //{"1", "dgDif0", "dgDif1", "dgDif2", "Change DegreeDif", "1.0"},
                          //{"1", "dgMin0", "dgMin1", "dgMin2", "Change DegreeMin", "1.0"},
                          //{"1", "tsSz0", "trSz1", "trSz2", "Change TrunkSize", "1.0"},
                          //{"1", "lfSz0", "lfSz1", "lfSz2", "Change LeafSize", "1.0"},
                          //{"1", "allFP0", "allFP1", "allFP2", "AllFractalProps", "1.0"},
                          
                          //{"1", "PSP", "Pick Study Plane", "1.0"},
                        };         



int Bar_b_Selection = -1;                        


int BAR_b_Display_Text; 


void SOLARCHVISION_highlight_in_BAR_b (String s) {

  int break_loops = 0;
  
  for (int i = 0; i < BAR_b_Items.length; i++) {
    for (int j = 1; j < BAR_b_Items[i].length - 2; j++) {
      if (BAR_b_Items[i][j].equals(s)) {
        
        BAR_b_Items[i][0] = nf(j, 0);
        
        break_loops = 1; 
      }
      
      if (break_loops == 1) break;
    }
    if (break_loops == 1) break;
  }
  
}


void SOLARCHVISION_draw_window_BAR_b () {
  
  if (BAR_b_Update == 1) {
  
    BAR_b_Update = 0;
    
    fill(0);
    noStroke();
    rect(0, a_pixel, width, b_pixel);
    
    X_control = 0; //0.25 * MESSAGE_S_View;
    Y_control = a_pixel + 0.5 * b_pixel;
  
    float cx = X_control;
    float cy = Y_control;
    float cr = 0.5 * b_pixel;   
    
    for (int i = 0; i < BAR_b_Items.length; i++) {
      
      {
        String Bar_Switch = BAR_b_Items[i][BAR_b_Items[i].length - 2];
        
        if (Bar_Switch.equals("LayerType")) {
          BAR_b_Items[i][0] = nf(Work_with_2D_or_3D, 0);
        }
      }


      
      int j = int(BAR_b_Items[i][0]);
      
      float Item_width = BAR_b_tab * float(BAR_b_Items[i][BAR_b_Items[i].length - 1]);
  
      noFill();
      stroke(255);
      strokeWeight(1);
      rect(cx, cy - cr, Item_width, b_pixel);
      strokeWeight(0);
      


  
      if (isInside(X_clicked, Y_clicked, cx, cy - cr, cx + Item_width, cy + cr) == 1) {

        if (mouseButton == RIGHT) {       
          
          if (Bar_b_Selection != i) {
            Bar_b_Selection = i;
          }
          else {
            
            int n = int(BAR_b_Items[i][0]);
            
            n -= 1;
            
            if (n <= 0) n = BAR_b_Items[i].length - 3;
            
            BAR_b_Items[i][0] = nf(n, 0);
            
            j = n;
          }
        }
        
        if (mouseButton == LEFT) {

          if (Bar_b_Selection != i) {
            Bar_b_Selection = i;
          }
          else {
              
            int n = int(BAR_b_Items[i][0]);
            
            n += 1;
            
            if (n >= BAR_b_Items[i].length - 2) n = 1;
            
            BAR_b_Items[i][0] = nf(n, 0);
            
            j = n;
          }
        }               

        
        fill(255,127,0);
        noStroke();
        rect(cx, cy - cr, Item_width, b_pixel);     
       
        String Bar_Switch = BAR_b_Items[i][BAR_b_Items[i].length - 2];


        if (Bar_Switch.equals("LayerType")) {
          Work_with_2D_or_3D = j;
          
          if (Work_with_2D_or_3D == 6) {
            SOLARCHVISION_convertVertex2softSelection();
          }
          
          ROLLOUT_Update = 1;   
          WIN3D_Update = 1;     
        }
        
        if (Bar_Switch.equals("Mesh|Solid")) {
          Create_Mesh_or_Solid = j;
          
          ROLLOUT_Update = 1;          
        }        

        if ((Bar_Switch.equals("LivingType")) || (Bar_Switch.equals("BuildingType"))) {
          if ((BAR_b_Items[i][j]).equals("Fractal")) set_to_Create_Fractal();
          else if ((BAR_b_Items[i][j]).equals("Tree")) set_to_Create_Tree();
          else if ((BAR_b_Items[i][j]).equals("Person")) set_to_Create_Person();
          else if ((BAR_b_Items[i][j]).equals("Tri")) set_to_Create_Tri();
          else if ((BAR_b_Items[i][j]).equals("Poly")) set_to_Create_Poly();
          else if ((BAR_b_Items[i][j]).equals("Extrude")) set_to_Create_Extrude();
          else if ((BAR_b_Items[i][j]).equals("Hyper")) set_to_Create_Hyper();
          else if ((BAR_b_Items[i][j]).equals("House")) set_to_Create_House();
          else if ((BAR_b_Items[i][j]).equals("Box")) set_to_Create_Box();
          else if ((BAR_b_Items[i][j]).equals("Octahedron")) set_to_Create_Octahedron();
          else if ((BAR_b_Items[i][j]).equals("Sphere")) set_to_Create_Sphere();
          else if ((BAR_b_Items[i][j]).equals("Cylinder")) set_to_Create_Cylinder();
          else if ((BAR_b_Items[i][j]).equals("Cushion")) set_to_Create_Cushion();
          else if ((BAR_b_Items[i][j]).equals("Parametric")) set_to_Create_Parametric(Create_Mesh_Parametric_Type);          
        }

        if (Bar_Switch.equals("Change Seed/Material")) {
          if ((BAR_b_Items[i][j]).equals("Mat0")) set_to_Modify_Seed(0);
          if ((BAR_b_Items[i][j]).equals("Mat1")) set_to_Modify_Seed(1);
          if ((BAR_b_Items[i][j]).equals("Mat2")) set_to_Modify_Seed(2);
          if ((BAR_b_Items[i][j]).equals("Mat3")) set_to_Modify_Seed(3);
        }

        if (Bar_Switch.equals("Change Tessellation")) {
          if ((BAR_b_Items[i][j]).equals("Tes0")) set_to_Modify_Tessellation(0);
          if ((BAR_b_Items[i][j]).equals("Tes1")) set_to_Modify_Tessellation(1);
          if ((BAR_b_Items[i][j]).equals("Tes2")) set_to_Modify_Tessellation(2);
          if ((BAR_b_Items[i][j]).equals("Tes3")) set_to_Modify_Tessellation(3);
        }
        
        if (Bar_Switch.equals("Change Layer")) {
          if ((BAR_b_Items[i][j]).equals("Lyr0")) set_to_Modify_Layer(0);
          if ((BAR_b_Items[i][j]).equals("Lyr1")) set_to_Modify_Layer(1);
          if ((BAR_b_Items[i][j]).equals("Lyr2")) set_to_Modify_Layer(2);
          if ((BAR_b_Items[i][j]).equals("Lyr3")) set_to_Modify_Layer(3);
        }

        if (Bar_Switch.equals("Change Visibility")) {
          if ((BAR_b_Items[i][j]).equals("Vsb0")) set_to_Modify_Visibility(0);
          if ((BAR_b_Items[i][j]).equals("Vsb1")) set_to_Modify_Visibility(1);
          if ((BAR_b_Items[i][j]).equals("Vsb2")) set_to_Modify_Visibility(2);
          if ((BAR_b_Items[i][j]).equals("Vsb3")) set_to_Modify_Visibility(3);
        }        
        
        if (Bar_Switch.equals("FaceNormal")) {
          if ((BAR_b_Items[i][j]).equals("FNorm1")) set_to_Modify_FaceNormal(1);
          if ((BAR_b_Items[i][j]).equals("FNorm2")) set_to_Modify_FaceNormal(2);
          if ((BAR_b_Items[i][j]).equals("FNorm3")) set_to_Modify_FaceNormal(3);
        }
        
        if (Bar_Switch.equals("FaceFirstVertex")) {
          if ((BAR_b_Items[i][j]).equals("F1stV")) set_to_Modify_FaceFirstVertex(1);
        }        
        
        if (Bar_Switch.equals("Rotate")) set_to_Modify_Rotate(j - 1);
        if (Bar_Switch.equals("Scale")) set_to_Modify_Scale(j - 1);
        if (Bar_Switch.equals("Move")) set_to_Modify_Move(j - 1);

        if (Bar_Switch.equals("ProjectionType")) set_to_View_ProjectionType(j - 1);

        if (Bar_Switch.equals("ClickSelect")) set_to_View_ClickSelect(j - 1);
        if (Bar_Switch.equals("WindowSelect")) set_to_View_WindowSelect(j - 1);

        if (Bar_Switch.equals("PivotX")) set_to_View_PivotX(j - 2);
        if (Bar_Switch.equals("PivotY")) set_to_View_PivotY(j - 2);
        if (Bar_Switch.equals("PivotZ")) set_to_View_PivotZ(j - 2);

        if (Bar_Switch.equals("Orbit")) set_to_View_Orbit(j - 1);
        if (Bar_Switch.equals("CameraRoll")) set_to_View_CameraRoll(j - 1);
        if (Bar_Switch.equals("TargetRoll")) set_to_View_TargetRoll(j - 1);
        
        if (Bar_Switch.equals("LookAtOrigin")) set_to_View_LookAtOrigin(j - 1);
        if (Bar_Switch.equals("LookAtSelection")) set_to_View_LookAtSelection(j - 1);

        if (Bar_Switch.equals("Pan")) {
          
          set_to_View_Pan(j - 1);
        }  

        if (Bar_Switch.equals("Zoom")) {
          set_to_View_Zoom(j - 1);

          BAR_b_Items[i][0] = "1"; // << set it to default choice next time
        }     
        
        if (Bar_Switch.equals("CameraDistance")) set_to_View_CameraDistance(0);

        if (Bar_Switch.equals("DistMouseXY")) set_to_View_DistMouseXY(0);

        if (Bar_Switch.equals("DistZ")) set_to_View_Truck(0);
        if (Bar_Switch.equals("Truck")) set_to_View_Truck(j - 1);
        
        if (Bar_Switch.equals("3DModelSize")) set_to_View_3DModelSize();
        
        if (Bar_Switch.equals("SkydomeSize")) set_to_View_SkydomeSize();
        
        if (Bar_Switch.equals("AllModelSize")) set_to_View_AllModelSize();
      
        if (Bar_Switch.equals("3DViewSpace")) set_to_View_3DViewSpace(j - 1);

        if (Bar_Switch.equals("3DViewPoint")) set_to_View_3DViewPoint(j - 1);


      }

    
      BAR_b_Display_Text = 1;  

      { // drawing the icons where available
        
        String Bar_Switch = BAR_b_Items[i][BAR_b_Items[i].length - 2];

        if (Bar_Switch.equals("Move")) {
          dessin_Move(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("Scale")) {
          dessin_Scale(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }          
        if (Bar_Switch.equals("Rotate")) {
          dessin_Rotate(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }    
        if (Bar_Switch.equals("Change Seed/Material")) {
          dessin_Seed(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("Change Tessellation")) {
          dessin_Tessellation(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("Change Layer")) {
          dessin_Layer(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("Change Visibility")) {
          dessin_Visibility(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }        
        if (Bar_Switch.equals("FaceNormal")) {
          dessin_FaceNormal(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }           
        if (Bar_Switch.equals("FaceFirstVertex")) {
          dessin_FaceFirstVertex(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }            
       
        if (Bar_Switch.equals("ClickSelect")) {
          dessin_ClickSelect(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }       
        if (Bar_Switch.equals("WindowSelect")) {
          dessin_WindowSelect(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }   
        if (Bar_Switch.equals("ProjectionType")) {
          dessin_ProjectionType(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }          
        if (Bar_Switch.equals("Zoom")) {
          dessin_Zoom(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }   
        if (Bar_Switch.equals("Orbit")) {
          dessin_Orbit(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }     
        if (Bar_Switch.equals("CameraRoll")) {
          dessin_CameraRoll(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }             
        if (Bar_Switch.equals("TargetRoll")) {
          dessin_TargetRoll(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }      
        if (Bar_Switch.equals("CameraDistance")) {
          dessin_CameraDistance(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }           
        if (Bar_Switch.equals("LookAtOrigin")) {
          dessin_LookAtOrigin(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }        
        if (Bar_Switch.equals("LookAtSelection")) {
          dessin_LookAtSelection(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }                
        if (Bar_Switch.equals("Pan")) {
          dessin_Pan(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("DistMouseXY")) {
          dessin_DistMouseXY(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }          
        if (Bar_Switch.equals("DistZ")) {
          dessin_DistZ(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }        
        if (Bar_Switch.equals("Truck")) {
          dessin_Truck(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("3DModelSize")) {
          dessin_3DModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }      
        if (Bar_Switch.equals("SkydomeSize")) {
          dessin_SkydomeSize(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }
        if (Bar_Switch.equals("AllModelSize")) {
          dessin_AllModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }  

        if (Bar_Switch.equals("3DViewSpace")) {
          dessin_3DViewSpace(j, cx + 0.5 * Item_width, cy, 0.5 * b_pixel);
        }  
    
        
      }
  
      if (BAR_b_Display_Text == 1) { // writing titles where the icon is not available
  
        textAlign(CENTER, CENTER);   
        stroke(255); 
        fill(255);
        textSize(0.45 * b_pixel);
                
        text(BAR_b_Items[i][j], cx + 0.5 * Item_width, cy - 0.2 * MESSAGE_S_View);
      }
      
  
      cx += Item_width;    
    }
      
    
    X_clicked = -1;
    Y_clicked = -1;
  }  
}   

          



void set_to_Create_Nothing () {
  
  Create_Mesh_Poly = 0;
  Create_Mesh_Extrude = 0;
  Create_Mesh_Tri = 0;
  Create_Mesh_Quad = 0;
  Create_Mesh_House = 0; 
  Create_Mesh_Parametric = 0;
  Create_Mesh_SuperOBJ = 0;
  Create_Mesh_Person = 0;
  Create_Mesh_Plant = 0;
  Create_Fractal_Plant = 0;
  
  View_Select_Create_Modify = 0;
  
  ROLLOUT_Update = 1;    
}


void set_to_Create_Fractal () {
  set_to_Create_Nothing();
  
  Create_Fractal_Plant = 1;
  Work_with_2D_or_3D = 1;
}  


void set_to_Create_Tree () {
  set_to_Create_Nothing();
  
  Create_Mesh_Plant = 1;
  Work_with_2D_or_3D = 2;  
}

void set_to_Create_Person () {
  set_to_Create_Nothing();
  
  Create_Mesh_Person = 1;
  Work_with_2D_or_3D = 2;  
}

void set_to_Create_Parametric (int n) {
  set_to_Create_Nothing();
  
  Create_Mesh_Parametric = 1;
  Create_Mesh_Parametric_Type = n;
  
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Tri () {
  set_to_Create_Nothing();
  
  Create_Mesh_Tri = 1;
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Poly () {
  set_to_Create_Nothing();
  
  Create_Mesh_Poly = 1;
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Extrude () {
  set_to_Create_Nothing();
  
  Create_Mesh_Extrude = 1;
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Hyper () {
  set_to_Create_Nothing();
  
  Create_Mesh_Quad = 1;
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_House () {
  set_to_Create_Nothing();
  
  Create_Mesh_House = 1;
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Box () {
  set_to_Create_Nothing();
  
  Create_Mesh_SuperOBJ = 1;

  Create_Input_powX = CubePower;   
  Create_Input_powY = CubePower; 
  Create_Input_powZ = CubePower;             
  
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Octahedron () {
  set_to_Create_Nothing();
  
  Create_Mesh_SuperOBJ = 1;

  Create_Input_powX = 1;  
  Create_Input_powY = 1; 
  Create_Input_powZ = 1;            
  
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Sphere () {
  set_to_Create_Nothing();
  
  Create_Mesh_SuperOBJ = 1;

  Create_Input_powX = 2;  
  Create_Input_powY = 2; 
  Create_Input_powZ = 2;            
  
  Work_with_2D_or_3D = 3;  
}

void set_to_Create_Cylinder () {
  set_to_Create_Nothing();
  
  Create_Mesh_SuperOBJ = 1;

  Create_Input_powX = 2;  
  Create_Input_powY = 2; 
  Create_Input_powZ = CubePower;             
  
  Work_with_2D_or_3D = 3;
}

void set_to_Create_Cushion () {
  set_to_Create_Nothing();
  
  Create_Mesh_SuperOBJ = 1;

  Create_Input_powX = CubePower;   
  Create_Input_powY = CubePower;  
  Create_Input_powZ = 2;            
  
  Work_with_2D_or_3D = 3;  
}





void set_to_Modify_Move (int n) {
  View_Select_Create_Modify = 1;
  
  selected_posVector = n;
  
  ROLLOUT_Update = 1;
}

void set_to_Modify_Scale (int n) {
  View_Select_Create_Modify = 2;
  
  selected_scaleVector = n;

  ROLLOUT_Update = 1;
}


void set_to_Modify_Rotate (int n) {
  View_Select_Create_Modify = 3;
  
  selected_rotVector = n;

  ROLLOUT_Update = 1;
}
  
void set_to_Modify_Seed (int n) {
  View_Select_Create_Modify = 4;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_Tessellation (int n) {
  View_Select_Create_Modify = 5;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_Layer (int n) {
  View_Select_Create_Modify = 6;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_Visibility (int n) {
  View_Select_Create_Modify = 7;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}
 
// the same messages of View_Select_Create_Modify=6/7 for both Layer/Visibility of polymeshes and DegreeMax/DegreeDif is not good!

void set_to_Modify_DegreeMax (int n) {
  View_Select_Create_Modify = 8;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_DegreeDif (int n) {
  View_Select_Create_Modify = 9;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_DegreeMin (int n) {
  View_Select_Create_Modify = 10;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_TrunkSize (int n) {
  View_Select_Create_Modify = 11;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_LeafSize (int n) {
  View_Select_Create_Modify = 12;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_AllFractalProps (int n) {
  View_Select_Create_Modify = 13;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_SolarPivot (int n) {
  View_Select_Create_Modify = 14;
  Modify_Object_Parameters = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1; 
}

void set_to_Modify_FaceNormal (int n) {
  View_Select_Create_Modify = 15;
  Modify_Object_Parameters = n; // 1:flip normal, 2:set out from pivot, 3:set in from pivot    

  ROLLOUT_Update = 1; 
}

void set_to_Modify_FaceFirstVertex (int n) {
  View_Select_Create_Modify = 16;
  Modify_Object_Parameters = n; // 1:default
  
  Work_with_2D_or_3D = 4; // << because it only works with face sub-object
  //BAR_b_Update = 1;

  ROLLOUT_Update = 1; 
}

void set_to_Pick_Study_Plane () {
  
  Modify_Object_Parameters = 1;
  
  View_Select_Create_Modify = 17;
  
  Work_with_2D_or_3D = 8; // << because it only works with sections
  //BAR_b_Update = 1;
  
  ROLLOUT_Update = 1; 
}




void set_to_View_ProjectionType (int n) {
  WIN3D_View_Type = n;
  
  WIN3D_Update = 1; 
  ROLLOUT_Update = 1; 
}

void set_to_View_ClickSelect (int n) {

  View_Select_Create_Modify = -1;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1; 
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1; 
  }
  
  ROLLOUT_Update = 1;          
}

void set_to_View_WindowSelect (int n) {
  View_Select_Create_Modify = -2;
  
  if (n == 1) {
    addNewSelectionToPreviousSelection = 1; 
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1; 
  }
  
  ROLLOUT_Update = 1;          
}    

void set_to_View_PivotX (int n) {

  selection_alignX = n;
  
  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;          
}

void set_to_View_PivotY (int n) {

  selection_alignY = n;
  
  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;          
}

void set_to_View_PivotZ (int n) {

  selection_alignZ = n;
  
  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;          
}      


void set_to_View_Truck (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -3;
  }

  if (n == 1) {
    View_Select_Create_Modify = -6;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 0;  
  } 

  if (n == 2) {
    View_Select_Create_Modify = -6;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 1;  
  }           
  
  ROLLOUT_Update = 1;          
}  


void set_to_View_DistMouseXY (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -17;
  }

  ROLLOUT_Update = 1;          
}  



void set_to_View_CameraDistance (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -13;
  }

  ROLLOUT_Update = 1;          
}  



void set_to_View_CameraRoll (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -12;
  }

  if (n == 1) {
    View_Select_Create_Modify = -11;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 0;  
  } 

  if (n == 2) {
    View_Select_Create_Modify = -11;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 1;  
  }           
  
  ROLLOUT_Update = 1;          
}  



void set_to_View_TargetRoll (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -10;
  }

  if (n == 1) {
    View_Select_Create_Modify = -9;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 0;  
  } 

  if (n == 2) {
    View_Select_Create_Modify = -9;
    Modify_Object_Parameters = 0;            
    View_XYZ_ChangeOption = 1;  
  }           
  
  ROLLOUT_Update = 1;          
}  


void set_to_View_Orbit (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -3;
  }

  if (n == 1) {
    View_Select_Create_Modify = -6;
    Modify_Object_Parameters = 1;            
    View_XYZ_ChangeOption = 0;  
  } 

  if (n == 2) {
    View_Select_Create_Modify = -6;
    Modify_Object_Parameters = 1;            
    View_XYZ_ChangeOption = 1;  
  }           
  
  ROLLOUT_Update = 1;          
}  




void set_to_View_LookAtSelection (int n) {

  SOLARCHVISION_look_Camera_towards_Selection();

  { // automatically set another choice of ineterest
    set_to_View_CameraDistance(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDS");
    BAR_b_Update = 1;    
  }
  
  WIN3D_Update = 1;
 
  ROLLOUT_Update = 1;    
}  


void set_to_View_LookAtOrigin (int n) {

  WIN3D_X_coordinate = 0;
  WIN3D_Y_coordinate = 0;
  WIN3D_Z_coordinate = 0; 
  
  {
    // automatically set another choice of ineterest
    
    set_to_View_Truck(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDZ");
    BAR_b_Update = 1;    
  }

  WIN3D_Update = 1;
 
  ROLLOUT_Update = 1;    
}  

void set_to_View_Pan (int n) {

  if (n == 0) {
    View_Select_Create_Modify = -14;
  }

  if (n == 1) {
    View_Select_Create_Modify = -15;
  }

  if (n == 2) {
    View_Select_Create_Modify = -16;
  }

  
  ROLLOUT_Update = 1;    
}  

void set_to_View_Zoom (int n) {
  View_Select_Create_Modify = -4;

  if (n == 1) {
    WIN3D_ZOOM_coordinate = 60;
    WIN3D_Update = 1;  
    
    
  }
  
  ROLLOUT_Update = 1;     
}      

void set_to_View_3DModelSize () {

  View_Select_Create_Modify = -5;
  
  WIN3D_Update = 1;  
    
  ROLLOUT_Update = 1;          
}      

void set_to_View_SkydomeSize () {

  View_Select_Create_Modify = -7;
  
  WIN3D_Update = 1;  
    
  ROLLOUT_Update = 1;          
}   

void set_to_View_AllModelSize () {

  View_Select_Create_Modify = -8;
  
  WIN3D_Update = 1;  
    
  ROLLOUT_Update = 1;          
}   


void set_to_View_3DViewSpace (int n) {

  frame_variation = n;
  SOLARCHVISION_update_frame_layout();

  ROLLOUT_Update = 1;
}

void set_to_View_3DViewPoint (int n) {
  
  
  
  if (n == 0) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(0 - WIN3D_RX_coordinate);
    SOLARCHVISION_rotateXY_Camera_around_Selection(0 - WIN3D_RZ_coordinate);  
  }
  
  if (n == 1) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(0 - WIN3D_RZ_coordinate); 
  }          

  if (n == 2) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(-90 - WIN3D_RZ_coordinate); 
  }    

  if (n == 3) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(180 - WIN3D_RZ_coordinate); 
  }   

  if (n == 4) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(90 - WIN3D_RZ_coordinate); 
  }  
 
  if (n == 5) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(180 - WIN3D_RX_coordinate);
    SOLARCHVISION_rotateXY_Camera_around_Selection(0 - WIN3D_RZ_coordinate);  
  }             

  if (n == 6) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(-45 - WIN3D_RZ_coordinate); 
  }             
  
  if (n == 7) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(45 - WIN3D_RZ_coordinate); 
  }     

  if (n == 8) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(135 - WIN3D_RZ_coordinate); 
  }

  if (n == 9) {
    SOLARCHVISION_rotateZ_Camera_around_Selection(90 - WIN3D_RX_coordinate); 
    SOLARCHVISION_rotateXY_Camera_around_Selection(-135 - WIN3D_RZ_coordinate); 
  }
  
  WIN3D_Update = 1;   
  
  //ROLLOUT_Update = 1;   
} 




int BAR_d_Update = 1;

float BAR_d_tab;

String[][] BAR_d_Items = {
                          
                          {"Day"},
                          {"Year"},
                          {"Scenario"}
                             
                        };         



void SOLARCHVISION_draw_window_BAR_d () {
  
  if (BAR_d_Update == 1) {
  
    BAR_d_Update = 0;
    
    BAR_d_tab = d_pixel / float(BAR_d_Items.length);
    
    fill(191);
    noStroke();
    rect(0, a_pixel + b_pixel + 2 * h_pixel, width, d_pixel);



    float displayBarHeight = MESSAGE_S_View;
    float displayBarWidth = 2 * w_pixel; 

    X_control = 0.5 * displayBarWidth;
    Y_control = a_pixel + b_pixel + 2 * h_pixel + 0.5 * BAR_d_tab;
    
    for (int i = 0; i < BAR_d_Items.length; i++) {
      
      float x1 = X_control - 0.3666 * displayBarWidth;
      float x2 = X_control + 0.4875 * displayBarWidth;
      float y1 = Y_control - 0.45 * displayBarHeight;
      float y2 = Y_control + 0.45 * displayBarHeight;
      
      fill(127);
      noStroke();      
      rect(x1, y1, x2 - x1, y2 - y1);      
      
      textAlign(RIGHT, CENTER);   
      stroke(0); 
      fill(0);
      textSize(1.25 * MESSAGE_S_View);
              
      text(BAR_d_Items[i][0] + ": ", x1, Y_control - 0.2 * MESSAGE_S_View);

      if (BAR_d_Items[i][0].equals("Day")) {

        if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
  
          if (mouseButton == LEFT) {
            STUDY_i_start = int(roundTo(24.0 * (X_clicked - x1) / (x2 - x1) - 0.5, 1));

            ROLLOUT_Update = 1;
            STUDY_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }
          
          if (mouseButton == RIGHT) {
            STUDY_i_end = int(roundTo(24.0 * (X_clicked - x1) / (x2 - x1) - 0.5, 1));
            
            ROLLOUT_Update = 1;
            STUDY_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }        
        }        
        
        float x_start = x1 + (x2 - x1) * (STUDY_i_start) / 24.0;  
        float x_end = x1 + (x2 - x1) * (STUDY_i_end + 1) / 24.0;
        
        fill(0,191,0,191);
        noStroke();
        
        if (STUDY_i_start <= STUDY_i_end) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        }
        else {
          rect(x1, y1, x_end - x1, y2 - y1);
          rect(x_start, y1, x2 - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MESSAGE_S_View);
        
        for (int j = 0; j < 24; j += 1) {
          text(nf(j, 0), x1 + (x2 - x1) * (j + 0.5) / 24.0, Y_control - 0.2 * MESSAGE_S_View);
        }        
      }
      
      if (BAR_d_Items[i][0].equals("Year")) {

        if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
  
          if (mouseButton == LEFT) {
            float keep_DATE = _DATE;
            _DATE = (int(roundTo(365.0 * (X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
            SOLARCHVISION_update_date(); 
            BEGIN_DAY = int(BEGIN_DAY + (_DATE - keep_DATE) + 365) % 365;
            SOLARCHVISION_try_update_ENSEMBLE(_YEAR, _MONTH, _DAY, _HOUR);
            
            update_DevelopDATA = 1;
          
            ROLLOUT_Update = 1;
            STUDY_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }
          
          if (mouseButton == RIGHT) {
            
            float _DATE2 = (int(roundTo(365.0 * (X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;

            if (_DATE > _DATE2) _DATE2 += 365;
            
            per_day = int(roundTo((_DATE2 - _DATE) / float(STUDY_j_end - STUDY_j_start - 1), 1));
            
            if (per_day < 0) per_day = 1;
            
            update_DevelopDATA = 1;
            
            STUDY_Update = 1; 
            ROLLOUT_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }        
        }        

        float keep_per_day = per_day;
        int keep_num_add_days = num_add_days;
        if ((impacts_source == databaseNumber_ENSEMBLE) || (impacts_source == databaseNumber_OBSERVED)) {
          per_day = 1;
          num_add_days = 1;
        }

        for (int j = STUDY_j_start; j < STUDY_j_end; j += 1) { 
          
          for (int j_ADD = 0; j_ADD < num_add_days; j_ADD += 1) {    
            
            int now_j = int(j * per_day + (j_ADD - int(roundTo(0.5 * num_add_days, 1))) + BEGIN_DAY + 365) % 365;

            if (now_j >= 365) {
             now_j = now_j % 365; 
            }
            if (now_j < 0) {
             now_j = (now_j + 365) % 365; 
            }
        
            float x_start = x1 + (x2 - x1) * ((now_j) % 365) / 365.0;  
            float x_end = x1 + (x2 - x1) * ((now_j + 1) % 365) / 365.0;
            
            fill(191,0,0,191);
            noStroke();
            
            if (x_start <= x_end) { 
              rect(x_start, y1, x_end - x_start, y2 - y1);
            }
            else {
              rect(x1, y1, x_end - x1, y2 - y1);
              rect(x_start, y1, x2 - x_start, y2 - y1);
            }            
            
          }

        }
        
        {
          textAlign(CENTER, CENTER);   
          stroke(0); 
          fill(0);
          textSize(1.25 * MESSAGE_S_View);
          
          for (int j = 0; j < 12; j += 1) {
            text(CalendarMonth[j][_LAN], x1 + (x2 - x1) * (j + 0.5) / 12.0, Y_control - 0.2 * MESSAGE_S_View);
          }                  
        }        
        
        per_day = keep_per_day;
        num_add_days = keep_num_add_days;
        
      }

        
      if (BAR_d_Items[i][0].equals("Scenario")) {
        
        int n1 = 0;
        int n2 = 1;

        if (impacts_source == databaseNumber_CLIMATE_WY2) {
          n1 = 1950;
          n2 = 2050;
        }
        if (impacts_source == databaseNumber_CLIMATE_EPW) {
          n1 = 1950;
          n2 = 2050;
        }        
        if (impacts_source == databaseNumber_ENSEMBLE) {
          n1 = ENSEMBLE_start;
          n2 = ENSEMBLE_end;
        }        
        if (impacts_source == databaseNumber_OBSERVED) {
          n1 = OBSERVED_start;
          n2 = OBSERVED_end;
        }  

        if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {
  
          if (mouseButton == LEFT) {
            
            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (X_clicked - x1) / (x2 - x1) - 0.5, 1));
            
            if (impacts_source == databaseNumber_CLIMATE_WY2) {
              Sample_Year_start = V_selection;
              
              if (Sample_Year_start > Sample_Year_end) {
                int swap_tmp = Sample_Year_start;
                Sample_Year_start = Sample_Year_end;
                Sample_Year_end = swap_tmp;
              }
              
              H_layer_option = -1; 
            }
            
            if (impacts_source == databaseNumber_ENSEMBLE) {
              Sample_Member_start = V_selection;
              
              if (Sample_Member_start > Sample_Member_end) {
                int swap_tmp = Sample_Member_start;
                Sample_Member_start = Sample_Member_end;
                Sample_Member_end = swap_tmp;
              }
              
              F_layer_option = -1; 
            }            

            if (impacts_source == databaseNumber_OBSERVED) {
              Sample_Station_start = V_selection;
              
              if (Sample_Station_start > Sample_Station_end) {
                int swap_tmp = Sample_Station_start;
                Sample_Station_start = Sample_Station_end;
                Sample_Station_end = swap_tmp;
              }
              
              O_layer_option = -1; 
            }       
            
            //update_DevelopDATA = 1;
            
            ROLLOUT_Update = 1;
            STUDY_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }
          
          if (mouseButton == RIGHT) {
            
            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (X_clicked - x1) / (x2 - x1) - 0.5, 1));
            
            if (impacts_source == databaseNumber_CLIMATE_WY2) {
              Sample_Year_end = V_selection;
  
              if (Sample_Year_start > Sample_Year_end) {
                int swap_tmp = Sample_Year_start;
                Sample_Year_start = Sample_Year_end;
                Sample_Year_end = swap_tmp;
              }
              
              H_layer_option = -1; 
            }

            if (impacts_source == databaseNumber_ENSEMBLE) {
              Sample_Member_end = V_selection;
              
              if (Sample_Member_start > Sample_Member_end) {
                int swap_tmp = Sample_Member_start;
                Sample_Member_start = Sample_Member_end;
                Sample_Member_end = swap_tmp;
              }
              
              F_layer_option = -1; 
            }
            
            if (impacts_source == databaseNumber_OBSERVED) {
              Sample_Station_end = V_selection;
              
              if (Sample_Station_start > Sample_Station_end) {
                int swap_tmp = Sample_Station_start;
                Sample_Station_start = Sample_Station_end;
                Sample_Station_end = swap_tmp;
              }
              
              O_layer_option = -1; 
            }                
            
            //update_DevelopDATA = 1;
            
            ROLLOUT_Update = 1;
            STUDY_Update = 1;
            
            SOLARCHVISION_check_for_WIN3D_update();
          }        
        }        
        
        float V_start = 0;  
        float V_end = 0;        
        
        if (impacts_source == databaseNumber_CLIMATE_WY2) {
          V_start = Sample_Year_start;
          V_end = Sample_Year_end;
        }
        if (impacts_source == databaseNumber_ENSEMBLE) {
          V_start = Sample_Member_start;
          V_end = Sample_Member_end;
        }
        if (impacts_source == databaseNumber_OBSERVED) {
          V_start = Sample_Station_start;
          V_end = Sample_Station_end;
        }        
        
        float x_start = x1 + (x2 - x1) * (V_start - n1) / float(n2 - n1 + 1);  
        float x_end = x1 + (x2 - x1) * (V_end - n1 + 1) / float(n2 - n1 + 1);
        
        fill(0,0,191,191);
        noStroke();
        
        if (x_start <= x_end) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MESSAGE_S_View);
        
        for (int j = 0; j < n2 - n1 + 1; j += 1) {
          
          String txt = ".";
          
          if (j % 5 == 0) {
            txt = "|"; 
          }          
          
          if (impacts_source == databaseNumber_CLIMATE_WY2) {
            if ((j % 10 == 5)) {
              txt = nf(j - 5 + n1, 0) + "s";
            }
          }
          if (impacts_source == databaseNumber_ENSEMBLE) {
            //if ((j % 1 == 0)) {
              txt = nf(j + n1, 0);
            //}
          }
          if (impacts_source == databaseNumber_OBSERVED) {
            //if ((j % 1 == 0)) {
              txt = STATION_SWOB_INFO[nearest_Station_OBSERVED[j]][6];
            //}
          }                 

          text(txt, x1 + (x2 - x1) * (j + 0.5) / float(n2 - n1 + 1), Y_control - 0.2 * MESSAGE_S_View);
          
        }        
      }        



      
      Y_control += BAR_d_tab;
    }


    displayBarWidth = ROLLOUT_X_View; // <<<<<<<<<
    displayBarHeight = 4.5 * MESSAGE_S_View;

    float temp_offsetX = ROLLOUT_CX_View + 0.5 * displayBarWidth;
    float temp_offsetY = a_pixel + b_pixel + 2 * h_pixel + 0.5 * displayBarHeight;
    
    for (int n = 0; n < 9; n++) {
      
      int i = 2 - n / 3;
      int j = 2 - n % 3;
      
      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;
      
      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (isInside(X_clicked, Y_clicked, x1, y1, x2, y2) == 1) {

        impact_layer = n;

        ROLLOUT_Update = 1;
        STUDY_Update = 1;
        
        SOLARCHVISION_check_for_WIN3D_update();

      }
    }
   
    for (int n = 0; n < 9; n++) {
      
      int i = 2 - n / 3;
      int j = 2 - n % 3;
      
      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;

      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (n == impact_layer) { 
        fill(255,127,0);
        noStroke();
      }
      else if (n / 3 == impact_layer / 3) {
        fill(127,63,0);
        noStroke();        
      }
      else {
        fill(127);
        noStroke();        
      }  
      rect(x1, y1, x2 - x1, y2 - y1);      
      
      textAlign(CENTER, CENTER);   
      if (n == impact_layer) { 
        stroke(0); 
        fill(0); 
      }
      else if (n / 3 == impact_layer / 3) {
        stroke(191); 
        fill(191);        
      }      
      else {
        stroke(255); 
        fill(255); 
      }        

      if (n == impact_layer) { 
        textSize(1.25 * MESSAGE_S_View);
      }
      else {
        textSize(1.125 * MESSAGE_S_View);
      }
              
      text(N_Title[n], 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.2 * MESSAGE_S_View);
    }    

    X_clicked = -1;
    Y_clicked = -1;
  }  
}   





void SOALRCHVISION_refreshDateTabs () {
  if ((impacts_source == databaseNumber_CLIMATE_WY2) || (impacts_source == databaseNumber_CLIMATE_EPW)) { 
    if (per_day == 1) { 
      per_day = int(365 / float(STUDY_j_end - STUDY_j_start));
    }
    else {
      per_day = 1;
    }
    } 
    if (impacts_source == databaseNumber_ENSEMBLE) {
    per_day = 1;
    }           
    if (impacts_source == databaseNumber_OBSERVED) {
    if (per_day == 1) { 
      per_day = int(STUDY_max_j_end_observations / float(STUDY_j_end - STUDY_j_start));
    }
    else {
      per_day = 1;
    }
  }
}  



int isInHourlyRange (float i) {
  int q = -1;
  if (STUDY_i_start <= STUDY_i_end) {
    q = 0;
    if ((STUDY_i_start <= i) && (i <= (STUDY_i_end + 24) % 24)) q = 1;
  }
  else {
    q = 1;
    if ((STUDY_i_start > i) && (i > (STUDY_i_end + 24) % 24)) q = 0;
  }
  return q;
}


int[] get_startZ_endZ (int data_source) {
  int[] a = new int [3];

  int start_z = -1;
  int end_z = -1; 
  int layers_count = -1;

  if (data_source == databaseNumber_CLIMATE_WY2) {
    
    // case -1 :
    start_z = Sample_Year_start;
    end_z = Sample_Year_end; 
    
    switch(H_layer_option) {
      case 0 : start_z = CLIMATE_WY2_start; end_z = CLIMATE_WY2_end; break;
      case 1 : start_z = 1953; end_z = 1959; break;
      case 2 : start_z = 1960; end_z = 1969; break;
      case 3 : start_z = 1970; end_z = 1979; break;
      case 4 : start_z = 1980; end_z = 1989; break;
      case 5 : start_z = 1990; end_z = 1999; break;
      case 6 : start_z = 2000; end_z = 2005; break;
    }
    
    if (start_z < CLIMATE_WY2_start) start_z = CLIMATE_WY2_start;
    if (end_z > CLIMATE_WY2_end) end_z = CLIMATE_WY2_end;

    start_z -= CLIMATE_WY2_start - 1;
    end_z -= CLIMATE_WY2_start - 1;
  }
  if (data_source == databaseNumber_ENSEMBLE) {

    // case -1 :
    start_z = Sample_Member_start;
    end_z = Sample_Member_end;
    
    switch(F_layer_option) {
      case 0 : start_z = ENSEMBLE_start; end_z = ENSEMBLE_end; break; //ALL: xml + grib2
      case 1 : start_z = 23; end_z = 43; break; //xml: US
      case 2 : start_z = 1; end_z = 22; break; //xml: GEPS + GDPS
      case 3: start_z = 44; end_z = ENSEMBLE_end; break; // additional GRIB2 domains
      case 4: start_z = 1; end_z = 43; break; //xml: NAEFS
      
      
    }

  }    
  if (data_source == databaseNumber_OBSERVED) {

    // case -1 :
    start_z =  Sample_Station_start;
    end_z =  Sample_Station_end;
    
    switch(O_layer_option) {
      case 0 : start_z = OBSERVED_start; end_z = OBSERVED_end; break;
      case 1 : start_z = 1; end_z = 1; break;
    }

  }   
  if (data_source == databaseNumber_CLIMATE_EPW) {

    start_z = 1;
    end_z = 1;
    
  }   



  if (impacts_source == databaseNumber_CLIMATE_WY2) layers_count = (1 + CLIMATE_WY2_end - CLIMATE_WY2_start);
  if (impacts_source == databaseNumber_ENSEMBLE) layers_count = (1 + ENSEMBLE_end - ENSEMBLE_start); 
  if (impacts_source == databaseNumber_OBSERVED) layers_count = (1 + OBSERVED_end - OBSERVED_start);
  if (impacts_source == databaseNumber_CLIMATE_EPW) layers_count = 1;
  
  a[0] = start_z;
  a[1] = end_z;
  a[2] = layers_count;
  
  return  a;
}



void SOLARCHVISION_explore_output (String outputFile) {

  if ((Display_Output_in_Explorer == 1)  && (STUDY_record_AUTO == 0) && (WORLD_record_AUTO == 0) && (WIN3D_record_AUTO == 0) && (FRAME_record_AUTO == 0)) {
    //launch("explorer /select," + outputFile.replace('/', char(92)));
  }
  
}

void SOLARCHVISION_check_for_WIN3D_update () {

  if (WIN3D_FACES_SHADE == Shade_Global_Solar) {
    rebuild_SolarProjection_array = 1;
    WIN3D_Update = 1;
  }
  if (Display_SolarImpact_Image != 0) {
    rebuild_SolarImpact_Image_array = 1;
    WIN3D_Update = 1;
  }     
  if (Display_WindRose_Image != 0) {
    rebuild_WindRose_Image_array = 1;
    WIN3D_Update = 1;
  }      
 

  if (Display_SUN3D_Path != 0) {
    WIN3D_Update = 1;
  }    
  if (Display_SUN3D_Pattern != 0) {
    WIN3D_Update = 1;
  }      
}  




void SOLARCHVISION_save_project (String myFile, int explore_output) {
  
  myFile = myFile.replace(char(92), '/');
 
  XML my_xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  XML newChild1 = null;
  XML newChild2 = null;
  XML newChild3 = null;
  
  
  my_xml.setName("SOLARCHVISION_2015_project");
  
  newChild1 = my_xml.addChild("SOLARCHVISION_variables");

  newChild1.setString("LocationName", LocationName);
  newChild1.setString("LocationProvince", LocationProvince);
  newChild1.setFloat("LocationLatitude", LocationLatitude);
  newChild1.setFloat("LocationLongitude", LocationLongitude);
  newChild1.setFloat("LocationElevation", LocationElevation);
  newChild1.setFloat("LocationTimeZone", LocationTimeZone);
  newChild1.setFloat("Delta_NOON", Delta_NOON);

  newChild1.setInt("Display_Output_in_Explorer", Display_Output_in_Explorer);
  newChild1.setInt("Display_Building_Model", Display_Building_Model);
  newChild1.setInt("Display_Trees_People", Display_Trees_People);
  newChild1.setInt("Display_FractalPlant", Display_FractalPlant);
  newChild1.setInt("Display_Leaves", Display_Leaves);
  
  newChild1.setInt("Display_Sections", Display_Sections);

  newChild1.setInt("Create_Default_Material", Create_Default_Material);  
  newChild1.setInt("Create_Default_Tessellation", Create_Default_Tessellation);
  newChild1.setInt("Create_Default_Layer", Create_Default_Layer);
  newChild1.setInt("Create_Default_Visibility", Create_Default_Visibility);
  newChild1.setInt("Create_Default_SolarPivotType", Create_Default_SolarPivotType);
  
  newChild1.setFloat("Modify_Input_WeldTreshold", Modify_Input_WeldTreshold);
  
  newChild1.setFloat("Modify_Input_OffsetAmount", Modify_Input_OffsetAmount);
  
  newChild1.setInt("Modify_Input_TessellateRows", Modify_Input_TessellateRows);
  newChild1.setInt("Modify_Input_TessellateColumns", Modify_Input_TessellateColumns);
  
  newChild1.setFloat("Modify_Input_OpenningDepth", Modify_Input_OpenningDepth);
  newChild1.setFloat("Modify_Input_OpenningArea", Modify_Input_OpenningArea);
  newChild1.setFloat("Modify_Input_OpenningDeviation", Modify_Input_OpenningDeviation);
  newChild1.setFloat("Create_Input_Length", Create_Input_Length);
  newChild1.setFloat("Create_Input_Width", Create_Input_Width);
  newChild1.setFloat("Create_Input_Height", Create_Input_Height);
  newChild1.setFloat("Create_Input_Volume", Create_Input_Volume);
  newChild1.setFloat("Create_Input_Orientation", Create_Input_Orientation);
  newChild1.setFloat("Create_Input_powX", Create_Input_powX);
  newChild1.setFloat("Create_Input_powY", Create_Input_powY);
  newChild1.setFloat("Create_Input_powZ", Create_Input_powZ);
  newChild1.setFloat("Create_Input_powAll", Create_Input_powAll);
  newChild1.setInt("Create_Input_powRnd", Create_Input_powRnd);
  newChild1.setInt("Create_Sphere_Degree", Create_Sphere_Degree);
  newChild1.setInt("Create_Cylinder_Degree", Create_Cylinder_Degree);
  newChild1.setInt("Create_Poly_Degree", Create_Poly_Degree);
  newChild1.setInt("Create_Mesh_Parametric_Type", Create_Mesh_Parametric_Type);
  newChild1.setInt("Create_Mesh_Person_Type", Create_Mesh_Person_Type);
  newChild1.setInt("Create_Mesh_Plant_Type", Create_Mesh_Plant_Type);
  newChild1.setInt("Create_Fractal_Plant_Type", Create_Fractal_Plant_Type);
  newChild1.setInt("Create_Fractal_Plant_DegreeMin", Create_Fractal_Plant_DegreeMin);
  newChild1.setInt("Create_Fractal_Plant_DegreeMax", Create_Fractal_Plant_DegreeMax);
  newChild1.setInt("Create_Fractal_Plant_Seed", Create_Fractal_Plant_Seed);
  newChild1.setFloat("Create_Fractal_Plant_TrunkSize", Create_Fractal_Plant_TrunkSize);
  newChild1.setFloat("Create_Fractal_Plant_LeafSize", Create_Fractal_Plant_LeafSize);
  newChild1.setInt("Work_with_2D_or_3D", Work_with_2D_or_3D);
  newChild1.setInt("Create_Mesh_or_Solid", Create_Mesh_or_Solid);
  newChild1.setInt("View_Select_Create_Modify", View_Select_Create_Modify);
  newChild1.setInt("View_XYZ_ChangeOption", View_XYZ_ChangeOption);
  newChild1.setInt("Modify_Object_Parameters", Modify_Object_Parameters);  

  newChild1.setInt("Display_SWOB_points", Display_SWOB_points);
  newChild1.setInt("Display_SWOB_nearest", Display_SWOB_nearest);
  newChild1.setInt("Display_NAEFS_points", Display_NAEFS_points);
  newChild1.setInt("Display_NAEFS_nearest", Display_NAEFS_nearest);
  newChild1.setInt("Display_CWEEDS_points", Display_CWEEDS_points);
  newChild1.setInt("Display_CWEEDS_nearest", Display_CWEEDS_nearest);
  newChild1.setInt("Display_EPW_points", Display_EPW_points);
  newChild1.setInt("Display_EPW_nearest", Display_EPW_nearest);
  newChild1.setInt("FRAME_record_AUTO", FRAME_record_AUTO);
  newChild1.setInt("FRAME_record_JPG", FRAME_record_JPG);
  newChild1.setInt("FRAME_click_JPG", FRAME_click_JPG);
  newChild1.setInt("FRAME_drag_JPG", FRAME_drag_JPG);
  newChild1.setInt("SpatialImpact_record_PDF", SpatialImpact_record_PDF);
  newChild1.setInt("SpatialImpact_record_JPG", SpatialImpact_record_JPG);
  newChild1.setInt("SolarImpact_record_JPG", SolarImpact_record_JPG);

  newChild1.setInt("Ensemble_Audio_Output", Ensemble_Audio_Output);
  newChild1.setInt("Launch_External_Simulation", Launch_External_Simulation);
  newChild1.setInt("Launch_External_Hardware", Launch_External_Hardware);

  newChild1.setFloat("SpatialImpact_Wspd", SpatialImpact_Wspd); 
  newChild1.setFloat("SpatialImpact_Wdir", SpatialImpact_Wdir);
  newChild1.setFloat("SpatialImpact_Power", SpatialImpact_Power);
  newChild1.setFloat("GlobalAlbedo", GlobalAlbedo);
  newChild1.setFloat("MAX_SHADING_DIST", MAX_SHADING_DIST);
  newChild1.setFloat("interpolation_weight", interpolation_weight);
  newChild1.setFloat("GlobeRES", GlobeRES);
  newChild1.setInt("Climatic_solar_forecast", Climatic_solar_forecast);
  newChild1.setInt("Climatic_weather_forecast", Climatic_weather_forecast);
  newChild1.setInt("automated", automated);
  
  newChild1.setInt("MODEL_RUN", MODEL_RUN);
  newChild1.setInt("_YEAR", _YEAR);
  newChild1.setInt("_MONTH", _MONTH);
  newChild1.setInt("_DAY", _DAY); 
  newChild1.setInt("_HOUR", _HOUR); 
  newChild1.setInt("BEGIN_DAY", BEGIN_DAY);
  newChild1.setFloat("_DATE", _DATE);
  
  newChild1.setFloat("LocationLatitude_step", LocationLatitude_step);
  newChild1.setFloat("LocationLongitude_step", LocationLongitude_step);
  newChild1.setFloat("LocationElevation_step", LocationElevation_step);
  
  
  newChild1.setInt("STUDY_record_JPG", STUDY_record_JPG);
  newChild1.setInt("STUDY_record_PDF", STUDY_record_PDF);
  newChild1.setInt("STUDY_record_AUTO", STUDY_record_AUTO);
  newChild1.setInt("WORLD_record_JPG", WORLD_record_JPG);
  newChild1.setInt("WORLD_record_PDF", WORLD_record_PDF);
  newChild1.setInt("WORLD_record_AUTO", WORLD_record_AUTO);
  newChild1.setInt("WIN3D_record_JPG", WIN3D_record_JPG);
  newChild1.setInt("WIN3D_record_AUTO", WIN3D_record_AUTO);
  newChild1.setInt("STUDY_i_start", STUDY_i_start);
  newChild1.setInt("STUDY_i_end", STUDY_i_end);
  //newChild1.setInt("STUDY_j_start", STUDY_j_start);
  newChild1.setInt("STUDY_j_end", STUDY_j_end);
  newChild1.setInt("STUDY_max_j_end_parameters", STUDY_max_j_end_parameters);
  newChild1.setInt("STUDY_max_j_end_observations", STUDY_max_j_end_observations);
  newChild1.setFloat("per_day", per_day);
  newChild1.setInt("num_add_days", num_add_days);
  newChild1.setInt("CLIMATE_EPW_start", CLIMATE_EPW_start);
  newChild1.setInt("CLIMATE_EPW_end", CLIMATE_EPW_end);
  newChild1.setInt("CLIMATE_WY2_start", CLIMATE_WY2_start);
  newChild1.setInt("CLIMATE_WY2_end", CLIMATE_WY2_end);
  newChild1.setInt("ENSEMBLE_start", ENSEMBLE_start);
  newChild1.setInt("ENSEMBLE_end", ENSEMBLE_end);
  newChild1.setInt("numberOfNearestStations_ENSEMBLE", numberOfNearestStations_ENSEMBLE);
  newChild1.setInt("numberOfNearestStations_OBSERVED", numberOfNearestStations_OBSERVED);
  newChild1.setInt("OBSERVED_start", OBSERVED_start);
  newChild1.setInt("OBSERVED_end", OBSERVED_end);
  newChild1.setInt("Sample_Year_start", Sample_Year_start);
  newChild1.setInt("Sample_Year_end", Sample_Year_end);
  newChild1.setInt("Sample_Member_start", Sample_Member_start);
  newChild1.setInt("Sample_Member_end", Sample_Member_end);
  newChild1.setInt("Sample_Station_start", Sample_Station_start);
  newChild1.setInt("Sample_Station_end", Sample_Station_end);
  newChild1.setInt("Load_CLIMATE_EPW", Load_CLIMATE_EPW);
  newChild1.setInt("Load_CLIMATE_WY2", Load_CLIMATE_WY2);
  newChild1.setInt("Load_ENSEMBLE", Load_ENSEMBLE);
  newChild1.setInt("Load_OBSERVED", Load_OBSERVED);
  newChild1.setInt("Download_OBSERVED", Download_OBSERVED);
  newChild1.setInt("Download_ENSEMBLE", Download_ENSEMBLE);
  newChild1.setInt("Download_AERIAL", Download_AERIAL);
  newChild1.setInt("GRIB2_MONTH", GRIB2_MONTH);
  newChild1.setInt("GRIB2_DAY", GRIB2_DAY);
  newChild1.setInt("GRIB2_RUN", GRIB2_RUN);
  newChild1.setInt("AERIAL_num", AERIAL_num);
  newChild1.setFloat("AERIAL_Center_Longitude", AERIAL_Center_Longitude);
  newChild1.setFloat("AERIAL_Center_Latitude", AERIAL_Center_Latitude);
  newChild1.setInt("GRIB2_Hour_Start", GRIB2_Hour_Start);
  newChild1.setInt("GRIB2_Hour_End", GRIB2_Hour_End);
  newChild1.setInt("GRIB2_Hour_Step", GRIB2_Hour_Step);
  newChild1.setInt("GRIB2_Layer_Start", GRIB2_Layer_Start);
  newChild1.setInt("GRIB2_Layer_End", GRIB2_Layer_End);
  newChild1.setInt("GRIB2_Layer_Step", GRIB2_Layer_Step);
  newChild1.setInt("GRIB2_Hour", GRIB2_Hour);
  newChild1.setInt("GRIB2_Layer", GRIB2_Layer);
  newChild1.setInt("GRIB2_DOMAIN_SELECTION", GRIB2_DOMAIN_SELECTION);
  newChild1.setInt("GRIB2_TGL_number", GRIB2_TGL_number);
  newChild1.setInt("AERIAL_graphOption", AERIAL_graphOption);
  newChild1.setInt("H_layer_option", H_layer_option);
  newChild1.setInt("F_layer_option", F_layer_option);
  newChild1.setInt("O_layer_option", O_layer_option);
  newChild1.setInt("develop_option", develop_option);
  newChild1.setInt("develop_per_day", develop_per_day);
  newChild1.setInt("update_DevelopDATA", update_DevelopDATA);
  newChild1.setInt("num_layers", num_layers);
  newChild1.setInt("_windspd200hPa", _windspd200hPa);
  newChild1.setInt("_thicknesses_1000_500", _thicknesses_1000_500);
  newChild1.setInt("_heightp500hPa", _heightp500hPa);
  newChild1.setInt("_ceilingsky", _ceilingsky);
  newChild1.setInt("_cloudcover", _cloudcover);
  newChild1.setInt("_winddir", _winddir);
  newChild1.setInt("_windspd", _windspd);
  newChild1.setInt("_pressure", _pressure);
  newChild1.setInt("_drybulb", _drybulb);
  newChild1.setInt("_relhum", _relhum);
  newChild1.setInt("_dirnorrad", _dirnorrad);
  newChild1.setInt("_difhorrad", _difhorrad);
  newChild1.setInt("_glohorrad", _glohorrad);
  newChild1.setInt("_direffect", _direffect);
  newChild1.setInt("_difeffect", _difeffect);
  newChild1.setInt("A_precipitation", A_precipitation);
  newChild1.setInt("_developed", _developed);
  newChild1.setFloat("Angle_inclination", Angle_inclination);
  newChild1.setFloat("Angle_orientation", Angle_orientation);
  newChild1.setInt("STUDY_drw_Layer", STUDY_drw_Layer);
  newChild1.setInt("develop_Layer", develop_Layer);
  newChild1.setInt("STUDY_print_title", STUDY_print_title);
  newChild1.setFloat("STUDY_T_scale", STUDY_T_scale);
  newChild1.setFloat("STUDY_U_scale", STUDY_U_scale);
  newChild1.setInt("sky_scenario", sky_scenario);
  newChild1.setInt("_hourly", _hourly);
  newChild1.setInt("_daily", _daily);
  newChild1.setInt("filter_type", filter_type);
  newChild1.setInt("join_hour_numbers", join_hour_numbers);
  newChild1.setInt("join_type", join_type);
  newChild1.setInt("dT", dT);
  newChild1.setInt("Export_STUDY_info_node", Export_STUDY_info_node);
  newChild1.setInt("Export_STUDY_info_norm", Export_STUDY_info_norm);
  newChild1.setInt("Export_STUDY_info_prob", Export_STUDY_info_prob);
  newChild1.setInt("STUDY_Pallet_SORT_CLR", STUDY_Pallet_SORT_CLR);
  newChild1.setInt("STUDY_Pallet_SORT_DIR", STUDY_Pallet_SORT_DIR);
  newChild1.setFloat("STUDY_Pallet_SORT_MLT", STUDY_Pallet_SORT_MLT);
  newChild1.setInt("STUDY_Pallet_PROB_CLR", STUDY_Pallet_PROB_CLR);
  newChild1.setInt("STUDY_Pallet_PROB_DIR", STUDY_Pallet_PROB_DIR);
  newChild1.setFloat("STUDY_Pallet_PROB_MLT", STUDY_Pallet_PROB_MLT);
  newChild1.setInt("STUDY_Pallet_ACTIVE_CLR", STUDY_Pallet_ACTIVE_CLR);
  newChild1.setInt("STUDY_Pallet_ACTIVE_DIR", STUDY_Pallet_ACTIVE_DIR);
  newChild1.setFloat("STUDY_Pallet_ACTIVE_MLT", STUDY_Pallet_ACTIVE_MLT);
  newChild1.setInt("STUDY_Pallet_PASSIVE_CLR", STUDY_Pallet_PASSIVE_CLR);
  newChild1.setInt("STUDY_Pallet_PASSIVE_DIR", STUDY_Pallet_PASSIVE_DIR);
  newChild1.setFloat("STUDY_Pallet_PASSIVE_MLT", STUDY_Pallet_PASSIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT);
  newChild1.setInt("SunPath3D_Pallet_ACTIVE_CLR", SunPath3D_Pallet_ACTIVE_CLR);
  newChild1.setInt("SunPath3D_Pallet_ACTIVE_DIR", SunPath3D_Pallet_ACTIVE_DIR);
  newChild1.setFloat("SunPath3D_Pallet_ACTIVE_MLT", SunPath3D_Pallet_ACTIVE_MLT);
  newChild1.setInt("SunPath3D_Pallet_PASSIVE_CLR", SunPath3D_Pallet_PASSIVE_CLR);
  newChild1.setInt("SunPath3D_Pallet_PASSIVE_DIR", SunPath3D_Pallet_PASSIVE_DIR);
  newChild1.setFloat("SunPath3D_Pallet_PASSIVE_MLT", SunPath3D_Pallet_PASSIVE_MLT);
  newChild1.setInt("SKY3D_Pallet_ACTIVE_CLR", SKY3D_Pallet_ACTIVE_CLR);
  newChild1.setInt("SKY3D_Pallet_ACTIVE_DIR", SKY3D_Pallet_ACTIVE_DIR);
  newChild1.setFloat("SKY3D_Pallet_ACTIVE_MLT", SKY3D_Pallet_ACTIVE_MLT);
  newChild1.setInt("SKY3D_Pallet_PASSIVE_CLR", SKY3D_Pallet_PASSIVE_CLR);
  newChild1.setInt("SKY3D_Pallet_PASSIVE_DIR", SKY3D_Pallet_PASSIVE_DIR);
  newChild1.setFloat("SKY3D_Pallet_PASSIVE_MLT", SKY3D_Pallet_PASSIVE_MLT);
  newChild1.setInt("ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR);
  newChild1.setInt("ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR);
  newChild1.setFloat("ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT);
  newChild1.setInt("SPATIAL_Pallet_CLR", SPATIAL_Pallet_CLR);
  newChild1.setInt("SPATIAL_Pallet_DIR", SPATIAL_Pallet_DIR);
  newChild1.setFloat("SPATIAL_Pallet_MLT", SPATIAL_Pallet_MLT);
  newChild1.setInt("windFlow_Pallet_CLR", windFlow_Pallet_CLR);
  newChild1.setInt("windFlow_Pallet_DIR", windFlow_Pallet_DIR);
  newChild1.setFloat("windFlow_Pallet_MLT", windFlow_Pallet_MLT);
  newChild1.setInt("Impact_ACTIVE", Impact_ACTIVE);
  newChild1.setInt("Impact_PASSIVE", Impact_PASSIVE);
  newChild1.setInt("Impact_SPD_DIR", Impact_SPD_DIR);
  newChild1.setInt("Impact_SPD_DIR_TMP", Impact_SPD_DIR_TMP);
  newChild1.setInt("Impact_TYPE", Impact_TYPE);
  newChild1.setFloat("STUDY_O_scale", STUDY_O_scale);
  newChild1.setFloat("STUDY_W_scale", STUDY_W_scale);
  newChild1.setInt("COLOR_STYLE", COLOR_STYLE);
  newChild1.setInt("n_COLOR_STYLE", n_COLOR_STYLE);
  newChild1.setFloat("obj_scale", obj_scale);
  newChild1.setFloat("obj_offset_x", obj_offset_x);
  newChild1.setInt("databaseNumber_OBSERVED", databaseNumber_OBSERVED);
  newChild1.setInt("databaseNumber_ENSEMBLE", databaseNumber_ENSEMBLE);
  newChild1.setInt("databaseNumber_CLIMATE_WY2", databaseNumber_CLIMATE_WY2);
  newChild1.setInt("databaseNumber_CLIMATE_EPW", databaseNumber_CLIMATE_EPW);
  newChild1.setInt("impacts_source", impacts_source);
  newChild1.setInt("draw_impact_summary", draw_impact_summary);
  newChild1.setInt("impact_layer", impact_layer);
  newChild1.setInt("plot_impacts", plot_impacts);
  newChild1.setInt("update_impacts", update_impacts);
  newChild1.setInt("draw_frame", draw_frame);
  newChild1.setInt("MODEL1D_ERASE", MODEL1D_ERASE);
  newChild1.setInt("MODEL2D_ERASE", MODEL2D_ERASE);
  newChild1.setInt("MODEL3D_ERASE", MODEL3D_ERASE);
  newChild1.setInt("SECTION_ERASE", SECTION_ERASE);
  newChild1.setInt("LAND_TESSELLATION", LAND_TESSELLATION);
  newChild1.setInt("MODEL3D_TESSELLATION", MODEL3D_TESSELLATION);
  newChild1.setInt("SKY3D_TESSELLATION", SKY3D_TESSELLATION);
  newChild1.setFloat("SKY3D_scale", SKY3D_scale);
  newChild1.setFloat("WindRose3D_scale", WindRose3D_scale);

  newChild1.setFloat("planetary_magnification", planetary_magnification);
  newChild1.setInt("Display_SolarRotation", Display_SolarRotation);
  newChild1.setInt("Display_SUN3D_Path", Display_SUN3D_Path);
  newChild1.setInt("Display_SUN3D_Pattern", Display_SUN3D_Pattern);
  newChild1.setInt("Display_SKY3D", Display_SKY3D);
  newChild1.setInt("Display_STAR3D", Display_STAR3D);
  newChild1.setInt("Display_STAR3D_TEXTURE", Display_STAR3D_TEXTURE);
  newChild1.setInt("Display_MOON3D", Display_MOON3D);
  newChild1.setInt("Display_MOON3D_TEXTURE", Display_MOON3D_TEXTURE);
  newChild1.setInt("Display_TROPO3D", Display_TROPO3D);
  newChild1.setInt("Display_TROPO3D_TEXTURE", Display_TROPO3D_TEXTURE);
  newChild1.setInt("Display_EARTH3D", Display_EARTH3D);
  newChild1.setInt("Display_EARTH3D_TEXTURE", Display_EARTH3D_TEXTURE);
  newChild1.setInt("Download_LAND_MESH", Download_LAND_MESH);
  newChild1.setInt("Load_LAND_MESH", Load_LAND_MESH);
  newChild1.setInt("Display_LAND_MESH", Display_LAND_MESH);
  newChild1.setInt("Display_LAND_TEXTURE", Display_LAND_TEXTURE);
  newChild1.setInt("Display_LAND_DEPTH", Display_LAND_DEPTH);
  newChild1.setInt("Skip_LAND_MESH_Center", Skip_LAND_MESH_Center);
  newChild1.setInt("Load_URBAN_MESH", Load_URBAN_MESH);
  newChild1.setInt("Display_URBAN_MESH", Display_URBAN_MESH);
  newChild1.setInt("Display_SpatialImpact_Points", Display_SpatialImpact_Points);
  newChild1.setInt("Display_SpatialImpact_Lines", Display_SpatialImpact_Lines);
  newChild1.setInt("Display_MODEL3D_EDGES", Display_MODEL3D_EDGES);
  newChild1.setInt("Display_MODEL3D_NORMALS", Display_MODEL3D_NORMALS);
  newChild1.setInt("Display_windFlow", Display_windFlow);
  newChild1.setInt("camera_variation", camera_variation);
  newChild1.setInt("draw_data_lines", draw_data_lines);
  newChild1.setInt("draw_sorted", draw_sorted);
  newChild1.setInt("draw_normals", draw_normals);
  newChild1.setInt("draw_probs", draw_probs);
  newChild1.setInt("sum_interval", sum_interval);
  newChild1.setFloat("level_pix", level_pix);
  newChild1.setFloat("_pix", _pix);
  newChild1.setInt("STUDY_setup", STUDY_setup);
  newChild1.setInt("Materials_Selection", Materials_Selection);
  newChild1.setInt("Shade_Surface_Wire", Shade_Surface_Wire);
  newChild1.setInt("Shade_Surface_Base", Shade_Surface_Base);
  newChild1.setInt("Shade_Surface_White", Shade_Surface_White);
  newChild1.setInt("Shade_Surface_Materials", Shade_Surface_Materials);
  newChild1.setInt("Shade_Global_Solar", Shade_Global_Solar);
  newChild1.setInt("Shade_Vertex_Solar", Shade_Vertex_Solar);
  newChild1.setInt("Shade_Vertex_Spatial", Shade_Vertex_Spatial);
  newChild1.setInt("Shade_Vertex_Elevation", Shade_Vertex_Elevation);
  newChild1.setFloat("CAM_x", CAM_x);
  newChild1.setFloat("CAM_y", CAM_y);
  newChild1.setFloat("CAM_z", CAM_z);
  newChild1.setFloat("CAM_fov", CAM_fov);
  newChild1.setFloat("CAM_dist", CAM_dist);
  newChild1.setFloat("CAM_clipNear", CAM_clipNear);
  newChild1.setFloat("CAM_clipFar", CAM_clipFar);
  newChild1.setFloat("OBJECTS_scale", OBJECTS_scale);
  newChild1.setFloat("refScale", refScale);
  newChild1.setFloat("WIN3D_Y_coordinate", WIN3D_Y_coordinate);
  newChild1.setFloat("WIN3D_Z_coordinate", WIN3D_Z_coordinate);
  newChild1.setFloat("WIN3D_S_coordinate", WIN3D_S_coordinate);
  newChild1.setFloat("WIN3D_RX_coordinate", WIN3D_RX_coordinate);
  newChild1.setFloat("WIN3D_RY_coordinate", WIN3D_RY_coordinate);
  newChild1.setFloat("WIN3D_RZ_coordinate", WIN3D_RZ_coordinate);
  newChild1.setFloat("WIN3D_RS_coordinate", WIN3D_RS_coordinate);
  newChild1.setFloat("WIN3D_ZOOM_coordinate", WIN3D_ZOOM_coordinate);
  newChild1.setInt("WIN3D_View_Type", WIN3D_View_Type);
  newChild1.setInt("WIN3D_FACES_SHADE", WIN3D_FACES_SHADE);
  newChild1.setInt("selected_posVector", selected_posVector);
  newChild1.setInt("selected_rotVector", selected_rotVector);
  newChild1.setInt("selected_scaleVector", selected_scaleVector);
  newChild1.setFloat("selected_posValue", selected_posValue);
  newChild1.setFloat("selected_rotValue", selected_rotValue);
  newChild1.setFloat("selected_scaleValue", selected_scaleValue);
  newChild1.setInt("selection_alignX", selection_alignX);
  newChild1.setInt("selection_alignY", selection_alignY);
  newChild1.setInt("selection_alignZ", selection_alignZ);

  newChild1.setInt("selectedFace_displayEdges", selectedFace_displayEdges);
  newChild1.setInt("selectedFace_displayVertexCount", selectedFace_displayVertexCount);
  newChild1.setInt("selectedVertex_displayVertices", selectedVertex_displayVertices);
  newChild1.setInt("selectedPolymesh_displaySolarPivots", selectedPolymesh_displaySolarPivots);  
  newChild1.setInt("selectedPolymesh_displayPivot", selectedPolymesh_displayPivot);
  newChild1.setInt("selectedPolymesh_displayEdges", selectedPolymesh_displayEdges);
  newChild1.setInt("selectedPolymesh_displayBox", selectedPolymesh_displayBox);
  newChild1.setInt("selectedObject2D_displayEdges", selectedObject2D_displayEdges);
  newChild1.setInt("selectedFractal_displayEdges", selectedFractal_displayEdges);
  newChild1.setInt("selectedSection_displayEdges", selectedSection_displayEdges);
  
  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius);
  
  newChild1.setInt("WORLD_viewport_ZOOM", WORLD_viewport_ZOOM);
  newChild1.setInt("frame_variation", frame_variation);
  newChild1.setInt("_LAN", _LAN);
  newChild1.setFloat("LAND_TEXTURE_scale_U", LAND_TEXTURE_scale_U);
  newChild1.setFloat("LAND_TEXTURE_scale_V", LAND_TEXTURE_scale_V);
  newChild1.setInt("LAND_n_I_base", LAND_n_I_base);
  newChild1.setInt("LAND_n_J_base", LAND_n_J_base);
  newChild1.setInt("LAND_n_I", LAND_n_I);
  newChild1.setInt("LAND_n_J", LAND_n_J);
  newChild1.setInt("Day_of_Impact_to_Display", Day_of_Impact_to_Display);
  newChild1.setInt("Display_WindRose_Image", Display_WindRose_Image);
  newChild1.setInt("WindRose_RES", WindRose_RES);
  newChild1.setInt("Rendered_WindRose_RES", Rendered_WindRose_RES);
  newChild1.setInt("Display_SolarImpact_Image", Display_SolarImpact_Image);
  newChild1.setInt("SolarImpact_sectionType", SolarImpact_sectionType);
  newChild1.setFloat("SolarImpact_Rotation", SolarImpact_Rotation);
  newChild1.setFloat("SolarImpact_scale_U", SolarImpact_scale_U);
  newChild1.setFloat("SolarImpact_scale_V", SolarImpact_scale_V);
  newChild1.setFloat("SolarImpact_offset_U", SolarImpact_offset_U);
  newChild1.setFloat("SolarImpact_offset_V", SolarImpact_offset_V);  
  newChild1.setInt("SolarImpact_RES1", SolarImpact_RES1);
  newChild1.setInt("SolarImpact_RES2", SolarImpact_RES2);
  newChild1.setFloat("SolarImpact_Elevation", SolarImpact_Elevation);
  newChild1.setInt("SpatialImpact_RES1", SpatialImpact_RES1);
  newChild1.setInt("SpatialImpact_RES2", SpatialImpact_RES2);
  newChild1.setFloat("SpatialImpact_Grade", SpatialImpact_Grade);
  newChild1.setInt("Display_SpatialImpact_Image", Display_SpatialImpact_Image);
  newChild1.setInt("SpatialImpact_sectionType", SpatialImpact_sectionType);
  newChild1.setFloat("SpatialImpact_positionStep", SpatialImpact_positionStep);
  newChild1.setInt("PROCESS_subdivisions", PROCESS_subdivisions);
  newChild1.setFloat("deltaSpatialImpact", deltaSpatialImpact);
  newChild1.setFloat("deltaSpatialImpactLines", deltaSpatialImpactLines);
  newChild1.setFloat("MinimumDistance_traceU", MinimumDistance_traceU);
  newChild1.setFloat("MinimumDistance_traceV", MinimumDistance_traceV);
  newChild1.setFloat("stp_slp", stp_slp);
  newChild1.setFloat("stp_dir", stp_dir);
  newChild1.setInt("n_slp", n_slp);
  newChild1.setInt("n_dir", n_dir);
  newChild1.setInt("LAND_n_I_base", LAND_n_I_base);
  newChild1.setInt("LAND_n_J_base", LAND_n_J_base);
  newChild1.setInt("LAND_n_I", LAND_n_I);
  newChild1.setInt("LAND_n_J", LAND_n_J);
  newChild1.setString("LAND_mid_lat", Double.toString(LAND_mid_lat));
  newChild1.setString("LAND_mid_lon", Double.toString(LAND_mid_lon));
  newChild1.setString("Default_Font", Default_Font);
  newChild1.setInt("Object2D_PEOPLE_Files_Num", Object2D_PEOPLE_Files_Num);
  newChild1.setInt("Object2D_TREES_Files_Num", Object2D_TREES_Files_Num); 
   
  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius); 
  
  newChild1.setInt("objExportPrecisionVertex", objExportPrecisionVertex);
  newChild1.setInt("objExportPrecisionVtexture", objExportPrecisionVtexture);
  newChild1.setInt("objExportPolyToPoly", objExportPolyToPoly);
  newChild1.setInt("objExportMaterialLibrary", objExportMaterialLibrary);
  newChild1.setInt("objExportBackSides", objExportBackSides);
  newChild1.setInt("objExportCombinedMaterial", objExportCombinedMaterial);
  newChild1.setInt("objExportBakingResolution", objExportBakingResolution);
    
  {
    int TEXTURE_copied = 0;

    String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder
  
    String the_filename = "";
    if (LAND_TEXTURE_ImagePath.equals("")) {
    }  
    else {
      the_filename = LAND_TEXTURE_ImagePath.substring(LAND_TEXTURE_ImagePath.lastIndexOf("/") + 1); // image name

      String new_TEXTURE_path = the_dir + "/Textures/" +  the_filename;
      
      //println("pre_LAND_TEXTURE_ImagePath", LAND_TEXTURE_ImagePath);
      //println("new_TEXTURE_path", new_TEXTURE_path);
  
      if (LAND_TEXTURE_ImagePath.toUpperCase().equals(new_TEXTURE_path.toUpperCase())) {
        TEXTURE_copied = -1;
      }
      else {
        if (LAND_TEXTURE_ImagePath.equals("")) {
        }  
        else {
          println("Copying texture:", LAND_TEXTURE_ImagePath, ">", new_TEXTURE_path);
          saveBytes(new_TEXTURE_path, loadBytes(LAND_TEXTURE_ImagePath));
          LAND_TEXTURE_ImagePath = new_TEXTURE_path;
          
          TEXTURE_copied = 1;
        }      
      }
      
      //if (TEXTURE_copied == 0) {
      //  println("Saving texture from the scene.");
      //  LAND_TEXTURE.save(new_TEXTURE_path);
      //}    
    }
    
    newChild1.setString("LAND_TEXTURE_ImagePath", LAND_TEXTURE_ImagePath);    
  }

  {
    newChild1 = my_xml.addChild("Object2D_ImagePath");
    int ni = Object2D_ImagePath.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      
      int TEXTURE_copied = 0;
      
      String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder

      String the_filename = "";
      if (Object2D_ImagePath[i].equals("")) {
      }  
      else {
        the_filename = Object2D_ImagePath[i].substring(Object2D_ImagePath[i].lastIndexOf("/") + 1); // image name

      
        String new_TEXTURE_path = the_dir + "/Textures/" + the_filename;
        
        //println("pre_Object2D_ImagePath", Object2D_ImagePath[i]);
        //println("new_Object2D_ImagePath", new_Object2D_ImagePath[i]);
          
        if (Object2D_ImagePath[i].toUpperCase().equals(new_TEXTURE_path.toUpperCase())) {
          TEXTURE_copied = -1;
        }
        else {
          if (Object2D_ImagePath[i].equals("")) {
          }  
          else {
            println("Copying texture:", Object2D_ImagePath[i], ">", new_TEXTURE_path);
            saveBytes(new_TEXTURE_path, loadBytes(Object2D_ImagePath[i]));
            Object2D_ImagePath[i] = new_TEXTURE_path;
            
            TEXTURE_copied = 1;
          }      
        }
  
        //if (TEXTURE_copied == 0) {
        //  println("Saving texture from the scene.");
        //  Object2DImages[i].save(new_TEXTURE_path);
        //}    
      }

      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(Object2D_ImagePath[i]);
      
    }
  }


  {
    newChild1 = my_xml.addChild("allSection_SpatialImpact");
    int ni = allSection_SpatialImpact.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
        
      String the_filename = "SpatialImpact_" + nf(i, 0) + ".bmp";
  
      String TEXTURE_path = ProjectsFolder + "/Textures/" + the_filename;
  
      println("Saving texture:", TEXTURE_path);
      allSection_SpatialImpact[i].save(TEXTURE_path);
  
      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(TEXTURE_path);
    }
  }

  {
    newChild1 = my_xml.addChild("allSection_SolarImpact");
    int ni = allSection_SolarImpact.length;
    int nj = allSection_SolarImpact[0].length;
    newChild1.setInt("ni", ni);
    newChild1.setInt("nj", nj);
    
    println("ni",ni);
    println("nj",nj);
    
    for (int i = 0; i < ni; i++) {
      for (int j = 0; j < nj; j++) {
        
        String the_filename = "SolarImpact_" + nf(i * nj + j, 0) + ".bmp";
    
        String TEXTURE_path = ProjectsFolder + "/Textures/" + the_filename;
    
        println("Saving texture:", TEXTURE_path);
        allSection_SolarImpact[i][j].save(TEXTURE_path);
    
        newChild2 = newChild1.addChild("Path");
        newChild2.setInt("id", i * nj + j); 
        newChild2.setContent(TEXTURE_path);
      }
    }
  }
  

  newChild1 = my_xml.addChild("DEFINED_STATION");
  newChild1.setInt("ni", DEFINED_STATIONS[STATION_NUMBER].length);
  for (int i = 0; i < DEFINED_STATIONS[STATION_NUMBER].length; i++) {
    newChild2 = newChild1.addChild("Property");
    newChild2.setInt("id", i);
    newChild2.setContent(DEFINED_STATIONS[STATION_NUMBER][i]);
  } 
  
  {
    newChild1 = my_xml.addChild("LAND_MESH");
    int vNo = 0;
    for (int i = 0; i < LAND_MESH.length; i++) {
      for (int j = 0; j < LAND_MESH[i].length; j++) {
        newChild2 = newChild1.addChild("Vertice");
        newChild2.setInt("id", vNo);
        String lineSTR = "";
        //for (int k = 0; k < LAND_MESH[i][j].length; k++) {
        for (int k = 0; k < 3; k++) { // x, y, z 
          lineSTR += nf(LAND_MESH[i][j][k], 0, 4).replace(",", "."); // <<<<
          if (k < LAND_MESH[i][j].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
        vNo += 1;
      }
    } 
  }  

  {
    newChild1 = my_xml.addChild("allSection");
    int ni = 1 + allSection_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Section");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allSection_UVERAB[i].length; j++) {
      for (int j = 0; j < 6; j++) { // u, v, e, r, a, b
        lineSTR += nf(allSection_UVERAB[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(allSection_Type[i], 0);
      lineSTR += ",";
      lineSTR += nf(allSection_RES1[i], 0);
      lineSTR += ",";
      lineSTR += nf(allSection_RES2[i], 0);
      
      newChild2.setContent(lineSTR);
    } 
  }

  {
    newChild1 = my_xml.addChild("allFractal");
    int ni = 1 + allFractal_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Fractal");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allFractal_XYZSRA[i].length; j++) {
      for (int j = 0; j < 6; j++) { // x, y, z, s, rot, as_mesh/as_solid 
        lineSTR += nf(allFractal_XYZSRA[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(allFractal_Type[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractal_DegreeMin[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractal_DegreeMax[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractal_Seed[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractal_TrunkSize[i], 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(allFractal_LeafSize[i], 0, 4).replace(",", "."); // <<<<
      
      newChild2.setContent(lineSTR);
    } 
  }
  
  {
    newChild1 = my_xml.addChild("allObject2D");
    int ni = 1 + allObject2D_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Object2D");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allObject2D_XYZS[i].length; j++) {
      for (int j = 0; j < 4; j++) { // x, y, z, s 
        lineSTR += nf(allObject2D_XYZS[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += allObject2D_MAP[i];
      
      newChild2.setContent(lineSTR);
    } 
  }
  
  
  {
    newChild1 = my_xml.addChild("allPolymesh_SolarPivotXYZ");
    int ni = allPolymesh_SolarPivotXYZ.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("SolarPivotXYZ");
      newChild2.setInt("id", i);
      String lineSTR = "";
      for (int j = 0; j < allPolymesh_SolarPivotXYZ[i].length; j++) {
        lineSTR += nf(allPolymesh_SolarPivotXYZ[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 < allPolymesh_SolarPivotXYZ[i].length) lineSTR += ",";
      }
      newChild2.setContent(lineSTR);
    } 
  }  

  {
    newChild1 = my_xml.addChild("allPolymesh_SolarPivotType");
    int ni = allPolymesh_SolarPivotType.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("SolarPivotType");
      newChild2.setInt("id", i);
      String lineSTR = "";
      for (int j = 0; j < allPolymesh_SolarPivotType[i].length; j++) {
        lineSTR += nf(allPolymesh_SolarPivotType[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 < allPolymesh_SolarPivotType[i].length) lineSTR += ",";
      }
      newChild2.setContent(lineSTR);
    } 
  }    
  

  newChild1 = my_xml.addChild("allVertices");
  newChild1.setInt("ni", allVertices.length);
  for (int i = 0; i < allVertices.length; i++) {
    newChild2 = newChild1.addChild("Vertice");
    newChild2.setInt("id", i);
    String lineSTR = "";
    //for (int j = 0; j < allVertices[i].length; j++) {
    for (int j = 0; j < 3; j++) { // x, y, z 
      lineSTR += nf(allVertices[i][j], 0, 4).replace(",", "."); // <<<<
      if (j < allVertices[i].length - 1) lineSTR += ",";
    }
    newChild2.setContent(lineSTR);
  } 

  newChild1 = my_xml.addChild("allFaces");
  newChild1.setInt("ni", allFaces.length);
  for (int i = 0; i < allFaces.length; i++) {
    newChild2 = newChild1.addChild("Face");
    newChild2.setInt("id", i);
    String lineSTR = "";
    for (int j = 0; j < allFaces[i].length; j++) {
      lineSTR += nf(allFaces[i][j], 0);
      if (j < allFaces[i].length - 1) lineSTR += ",";
    }
    newChild2.setContent(lineSTR);
  } 
  
  newChild1 = my_xml.addChild("allFaces_MTLV");
  newChild1.setInt("ni", allFaces_MTLV.length);
  for (int i = 0; i < allFaces_MTLV.length; i++) {
    newChild2 = newChild1.addChild("Face_MTLV");
    newChild2.setInt("id", i);
    String lineSTR = "";
    for (int j = 0; j < allFaces_MTLV[i].length; j++) {
      lineSTR += nf(allFaces_MTLV[i][j], 0);
      if (j < allFaces_MTLV[i].length - 1) lineSTR += ",";
    }
    newChild2.setContent(lineSTR);
  }   

  newChild1 = my_xml.addChild("allPolymesh_Faces");
  newChild1.setInt("ni", allPolymesh_Faces.length);
  for (int i = 0; i < allPolymesh_Faces.length; i++) {
    newChild2 = newChild1.addChild("Faces");
    newChild2.setInt("id", i);
    String lineSTR = "";
    //for (int j = 0; j < allPolymesh_Faces[i].length; j++) {
    for (int j = 0; j < 2; j++) { // start, end
      lineSTR += nf(allPolymesh_Faces[i][j], 0);
      if (j < allPolymesh_Faces[i].length - 1) lineSTR += ",";
    }
    newChild2.setContent(lineSTR);
  } 
    
  newChild1 = my_xml.addChild("allPolymesh_Solids");
  newChild1.setInt("ni", allPolymesh_Solids.length);
  for (int i = 0; i < allPolymesh_Solids.length; i++) {
    newChild2 = newChild1.addChild("Solids");
    newChild2.setInt("id", i);
    String lineSTR = "";
    //for (int j = 0; j < allPolymesh_Solids[i].length; j++) {
    for (int j = 0; j < 2; j++) { // start, end
      lineSTR += nf(allPolymesh_Solids[i][j], 0);
      if (j < allPolymesh_Solids[i].length - 1) lineSTR += ",";
    }
    newChild2.setContent(lineSTR);
  }   

  newChild1 = my_xml.addChild("SolidObjects");
  newChild1.setInt("ni", SolidObjects.length);
  for (int i = 0; i < SolidObjects.length; i++) {
    newChild2 = newChild1.addChild("Solid");
    newChild2.setInt("id", i);
    String lineSTR = "";
    lineSTR += nf(SolidObjects[i].value, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].posX, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].posY, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].posZ, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].powX, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].powY, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].powZ, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].scaleX, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].scaleY, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].scaleZ, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].rotX, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].rotY, 0, 4).replace(",", "."); // <<<<
    lineSTR += ",";
    lineSTR += nf(SolidObjects[i].rotZ, 0, 4).replace(",", "."); // <<<<

    newChild2.setContent(lineSTR);
  } 

  {
    newChild1 = my_xml.addChild("selectedFractal_numbers");
    int ni = selectedFractal_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedFractal_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }
  
  {
    newChild1 = my_xml.addChild("selectedObject2D_numbers");
    int ni = selectedObject2D_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedObject2D_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedPolymesh_numbers");
    int ni = selectedPolymesh_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedPolymesh_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("selectedFace_numbers");
    int ni = selectedFace_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedFace_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_numbers");
    int ni = selectedVertex_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionVertices");
    int ni = selectedVertex_softSelectionVertices.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_softSelectionVertices[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionValues");
    int ni = selectedVertex_softSelectionValues.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(selectedVertex_softSelectionValues[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }
  

  {
    newChild1 = my_xml.addChild("selectedSection_numbers");
    int ni = selectedSection_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedSection_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("SpatialImpact_Elevation");
    int ni = SpatialImpact_Elevation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_Elevation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }
  
  {
    newChild1 = my_xml.addChild("SpatialImpact_Rotation");
    int ni = SpatialImpact_Rotation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_Rotation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  
  
  {
    newChild1 = my_xml.addChild("SpatialImpact_scale_U");
    int ni = SpatialImpact_scale_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_scale_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    
  
  {
    newChild1 = my_xml.addChild("SpatialImpact_scale_V");
    int ni = SpatialImpact_scale_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_scale_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SpatialImpact_offset_U");
    int ni = SpatialImpact_offset_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_offset_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    
  
  {
    newChild1 = my_xml.addChild("SpatialImpact_offset_V");
    int ni = SpatialImpact_offset_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SpatialImpact_offset_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    
  

  {
    newChild1 = my_xml.addChild("STUDY_V_scale");
    int ni = STUDY_V_scale.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_scale[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  
  
  {
    newChild1 = my_xml.addChild("STUDY_V_offset");
    int ni = STUDY_V_offset.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_offset[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("STUDY_V_belowLine");
    int ni = STUDY_V_belowLine.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_belowLine[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  


  {
    newChild1 = my_xml.addChild("LAYERS_Unit");
    int ni = LAYERS_Unit.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += LAYERS_Unit[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_ENSEMBLE");
    int ni = LAYERS_ENSEMBLE.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += LAYERS_ENSEMBLE[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_GRIB2_MUL");
    int ni = LAYERS_GRIB2_MUL.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAYERS_GRIB2_MUL[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_GRIB2_ADD");
    int ni = LAYERS_GRIB2_ADD.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAYERS_GRIB2_ADD[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("GRIB2_TGL_Selected");
    int ni = GRIB2_TGL_Selected.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += GRIB2_TGL_Selected[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  
  saveXML(my_xml, myFile);    

  println("End of saving project.");
  
  if (explore_output != 0) SOLARCHVISION_explore_output(myFile);
}


void SOLARCHVISION_load_project (String myFile) {
  
  myFile = myFile.replace(char(92), '/');
  

  int continue_process = 1;
  
  XML FileAll = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  
  try {
    FileAll = loadXML(myFile);
  }
  catch (Exception e) {
    println("Can't read:", myFile);
    continue_process = 0;
  }
  
  if (continue_process == 1) { 
  
    XML[] children0 = FileAll.getChildren("SOLARCHVISION_variables");

    for (int L = 0; L < children0.length; L++) {

      LocationName = children0[L].getString("LocationName");
      LocationProvince = children0[L].getString("LocationProvince");     
      LocationLatitude = children0[L].getFloat("LocationLatitude");
      LocationLongitude = children0[L].getFloat("LocationLongitude");
      LocationElevation = children0[L].getFloat("LocationElevation");
      LocationTimeZone = children0[L].getFloat("LocationTimeZone");
      Delta_NOON = children0[L].getFloat("Delta_NOON");
      
      Display_Output_in_Explorer = children0[L].getInt("Display_Output_in_Explorer");
      Display_Building_Model = children0[L].getInt("Display_Building_Model");
      Display_Trees_People = children0[L].getInt("Display_Trees_People");
      Display_FractalPlant = children0[L].getInt("Display_FractalPlant");
      Display_Leaves = children0[L].getInt("Display_Leaves");
      
      Display_Sections = children0[L].getInt("Display_Sections");
      
      Create_Default_Material = children0[L].getInt("Create_Default_Material");
      Create_Default_Tessellation = children0[L].getInt("Create_Default_Tessellation");
      Create_Default_Layer = children0[L].getInt("Create_Default_Layer");
      Create_Default_Visibility = children0[L].getInt("Create_Default_Visibility");
      Create_Default_SolarPivotType = children0[L].getInt("Create_Default_SolarPivotType");
      
      Modify_Input_WeldTreshold = children0[L].getFloat("Modify_Input_WeldTreshold");
      
      Modify_Input_OffsetAmount = children0[L].getFloat("Modify_Input_OffsetAmount");
      
      Modify_Input_TessellateRows = children0[L].getInt("Modify_Input_TessellateRows");
      Modify_Input_TessellateColumns = children0[L].getInt("Modify_Input_TessellateColumns");
      
      Modify_Input_OpenningDepth = children0[L].getFloat("Modify_Input_OpenningDepth");
      Modify_Input_OpenningArea = children0[L].getFloat("Modify_Input_OpenningArea");
      Modify_Input_OpenningDeviation = children0[L].getFloat("Modify_Input_OpenningDeviation");
      Create_Input_Length = children0[L].getFloat("Create_Input_Length");
      Create_Input_Width = children0[L].getFloat("Create_Input_Width");
      Create_Input_Height = children0[L].getFloat("Create_Input_Height");
      Create_Input_Volume = children0[L].getFloat("Create_Input_Volume");
      Create_Input_Orientation = children0[L].getFloat("Create_Input_Orientation");
      Create_Input_powX = children0[L].getFloat("Create_Input_powX");
      Create_Input_powY = children0[L].getFloat("Create_Input_powY");
      Create_Input_powZ = children0[L].getFloat("Create_Input_powZ");
      Create_Input_powAll = children0[L].getFloat("Create_Input_powAll");
      Create_Input_powRnd = children0[L].getInt("Create_Input_powRnd");
      Create_Sphere_Degree = children0[L].getInt("Create_Sphere_Degree");
      Create_Cylinder_Degree = children0[L].getInt("Create_Cylinder_Degree");
      Create_Poly_Degree = children0[L].getInt("Create_Poly_Degree");
      Create_Mesh_Parametric_Type = children0[L].getInt("Create_Mesh_Parametric_Type");
      Create_Mesh_Person_Type = children0[L].getInt("Create_Mesh_Person_Type");
      Create_Mesh_Plant_Type = children0[L].getInt("Create_Mesh_Plant_Type");
      Create_Fractal_Plant_Type = children0[L].getInt("Create_Fractal_Plant_Type");
      Create_Fractal_Plant_DegreeMin = children0[L].getInt("Create_Fractal_Plant_DegreeMin");
      Create_Fractal_Plant_DegreeMax = children0[L].getInt("Create_Fractal_Plant_DegreeMax");
      Create_Fractal_Plant_Seed = children0[L].getInt("Create_Fractal_Plant_Seed");
      Create_Fractal_Plant_TrunkSize = children0[L].getFloat("Create_Fractal_Plant_TrunkSize");
      Create_Fractal_Plant_LeafSize = children0[L].getFloat("Create_Fractal_Plant_LeafSize");
      Work_with_2D_or_3D = children0[L].getInt("Work_with_2D_or_3D");
      Create_Mesh_or_Solid = children0[L].getInt("Create_Mesh_or_Solid");
      View_Select_Create_Modify = children0[L].getInt("View_Select_Create_Modify");
      View_XYZ_ChangeOption = children0[L].getInt("View_XYZ_ChangeOption");
      Modify_Object_Parameters = children0[L].getInt("Modify_Object_Parameters");      

      Display_SWOB_points = children0[L].getInt("Display_SWOB_points");
      Display_SWOB_nearest = children0[L].getInt("Display_SWOB_nearest");
      Display_NAEFS_points = children0[L].getInt("Display_NAEFS_points");
      Display_NAEFS_nearest = children0[L].getInt("Display_NAEFS_nearest");
      Display_CWEEDS_points = children0[L].getInt("Display_CWEEDS_points");
      Display_CWEEDS_nearest = children0[L].getInt("Display_CWEEDS_nearest");
      Display_EPW_points = children0[L].getInt("Display_EPW_points");
      Display_EPW_nearest = children0[L].getInt("Display_EPW_nearest");
      FRAME_record_AUTO = children0[L].getInt("FRAME_record_AUTO");
      FRAME_record_JPG = children0[L].getInt("FRAME_record_JPG");
      FRAME_click_JPG = children0[L].getInt("FRAME_click_JPG");
      FRAME_drag_JPG = children0[L].getInt("FRAME_drag_JPG");
      SpatialImpact_record_PDF = children0[L].getInt("SpatialImpact_record_PDF");
      SpatialImpact_record_JPG = children0[L].getInt("SpatialImpact_record_JPG");
      SolarImpact_record_JPG = children0[L].getInt("SolarImpact_record_JPG");

      Ensemble_Audio_Output = children0[L].getInt("Ensemble_Audio_Output");
      Launch_External_Simulation = children0[L].getInt("Launch_External_Simulation");
      Launch_External_Hardware = children0[L].getInt("Launch_External_Hardware");

      SpatialImpact_Wspd = children0[L].getFloat("SpatialImpact_Wspd"); 
      SpatialImpact_Wdir = children0[L].getFloat("SpatialImpact_Wdir");
      SpatialImpact_Power = children0[L].getFloat("SpatialImpact_Power");
      GlobalAlbedo = children0[L].getFloat("GlobalAlbedo");
      MAX_SHADING_DIST = children0[L].getFloat("MAX_SHADING_DIST");
      interpolation_weight = children0[L].getFloat("interpolation_weight");
      GlobeRES = children0[L].getFloat("GlobeRES");
      Climatic_solar_forecast = children0[L].getInt("Climatic_solar_forecast");
      Climatic_weather_forecast = children0[L].getInt("Climatic_weather_forecast");
      automated = children0[L].getInt("automated");
      
      MODEL_RUN = children0[L].getInt("MODEL_RUN"); 
      _YEAR = children0[L].getInt("_YEAR");
      _MONTH = children0[L].getInt("_MONTH");
      _DAY = children0[L].getInt("_DAY"); 
      _HOUR = children0[L].getInt("_HOUR"); 
      BEGIN_DAY = children0[L].getInt("BEGIN_DAY");
      _DATE = children0[L].getFloat("_DATE");
      
      LocationLatitude_step = children0[L].getFloat("LocationLatitude_step");
      LocationLongitude_step = children0[L].getFloat("LocationLongitude_step");
      LocationElevation_step = children0[L].getFloat("LocationElevation_step");
      
      
      STUDY_record_JPG = children0[L].getInt("STUDY_record_JPG");
      STUDY_record_PDF = children0[L].getInt("STUDY_record_PDF");
      STUDY_record_AUTO = children0[L].getInt("STUDY_record_AUTO");
      WORLD_record_JPG = children0[L].getInt("WORLD_record_JPG");
      WORLD_record_PDF = children0[L].getInt("WORLD_record_PDF");
      WORLD_record_AUTO = children0[L].getInt("WORLD_record_AUTO");
      WIN3D_record_JPG = children0[L].getInt("WIN3D_record_JPG");
      WIN3D_record_AUTO = children0[L].getInt("WIN3D_record_AUTO");
      STUDY_i_start = children0[L].getInt("STUDY_i_start");
      STUDY_i_end = children0[L].getInt("STUDY_i_end");
      //STUDY_j_start = children0[L].getInt("STUDY_j_start");
      STUDY_j_end = children0[L].getInt("STUDY_j_end");
      STUDY_max_j_end_parameters = children0[L].getInt("STUDY_max_j_end_parameters");
      STUDY_max_j_end_observations = children0[L].getInt("STUDY_max_j_end_observations");
      per_day = children0[L].getFloat("per_day");
      num_add_days = children0[L].getInt("num_add_days");
      CLIMATE_EPW_start = children0[L].getInt("CLIMATE_EPW_start");
      CLIMATE_EPW_end = children0[L].getInt("CLIMATE_EPW_end");
      CLIMATE_WY2_start = children0[L].getInt("CLIMATE_WY2_start");
      CLIMATE_WY2_end = children0[L].getInt("CLIMATE_WY2_end");
      ENSEMBLE_start = children0[L].getInt("ENSEMBLE_start");
      ENSEMBLE_end = children0[L].getInt("ENSEMBLE_end");
      numberOfNearestStations_ENSEMBLE = children0[L].getInt("numberOfNearestStations_ENSEMBLE");
      numberOfNearestStations_OBSERVED = children0[L].getInt("numberOfNearestStations_OBSERVED");
      OBSERVED_start = children0[L].getInt("OBSERVED_start");
      OBSERVED_end = children0[L].getInt("OBSERVED_end");
      Sample_Year_start = children0[L].getInt("Sample_Year_start");
      Sample_Year_end = children0[L].getInt("Sample_Year_end");
      Sample_Member_start = children0[L].getInt("Sample_Member_start");
      Sample_Member_end = children0[L].getInt("Sample_Member_end");
      Sample_Station_start = children0[L].getInt("Sample_Station_start");
      Sample_Station_end = children0[L].getInt("Sample_Station_end");
      Load_CLIMATE_EPW = children0[L].getInt("Load_CLIMATE_EPW");
      Load_CLIMATE_WY2 = children0[L].getInt("Load_CLIMATE_WY2");
      Load_ENSEMBLE = children0[L].getInt("Load_ENSEMBLE");
      Load_OBSERVED = children0[L].getInt("Load_OBSERVED");
      Download_OBSERVED = children0[L].getInt("Download_OBSERVED");
      Download_ENSEMBLE = children0[L].getInt("Download_ENSEMBLE");
      Download_AERIAL = children0[L].getInt("Download_AERIAL");
      GRIB2_MONTH = children0[L].getInt("GRIB2_MONTH");
      GRIB2_DAY = children0[L].getInt("GRIB2_DAY");
      GRIB2_RUN = children0[L].getInt("GRIB2_RUN");
      AERIAL_num = children0[L].getInt("AERIAL_num");
      AERIAL_Center_Longitude = children0[L].getFloat("AERIAL_Center_Longitude");
      AERIAL_Center_Latitude = children0[L].getFloat("AERIAL_Center_Latitude");
      GRIB2_Hour_Start = children0[L].getInt("GRIB2_Hour_Start");
      GRIB2_Hour_End = children0[L].getInt("GRIB2_Hour_End");
      GRIB2_Hour_Step = children0[L].getInt("GRIB2_Hour_Step");
      GRIB2_Layer_Start = children0[L].getInt("GRIB2_Layer_Start");
      GRIB2_Layer_End = children0[L].getInt("GRIB2_Layer_End");
      GRIB2_Layer_Step = children0[L].getInt("GRIB2_Layer_Step");
      GRIB2_Hour = children0[L].getInt("GRIB2_Hour");
      GRIB2_Layer = children0[L].getInt("GRIB2_Layer");
      GRIB2_DOMAIN_SELECTION = children0[L].getInt("GRIB2_DOMAIN_SELECTION");
      GRIB2_TGL_number = children0[L].getInt("GRIB2_TGL_number");
      AERIAL_graphOption = children0[L].getInt("AERIAL_graphOption");
      H_layer_option = children0[L].getInt("H_layer_option");
      F_layer_option = children0[L].getInt("F_layer_option");
      O_layer_option = children0[L].getInt("O_layer_option");
      develop_option = children0[L].getInt("develop_option");
      develop_per_day = children0[L].getInt("develop_per_day");
      update_DevelopDATA = children0[L].getInt("update_DevelopDATA");
      num_layers = children0[L].getInt("num_layers");
      _windspd200hPa = children0[L].getInt("_windspd200hPa");
      _thicknesses_1000_500 = children0[L].getInt("_thicknesses_1000_500");
      _heightp500hPa = children0[L].getInt("_heightp500hPa");
      _ceilingsky = children0[L].getInt("_ceilingsky");
      _cloudcover = children0[L].getInt("_cloudcover");
      _winddir = children0[L].getInt("_winddir");
      _windspd = children0[L].getInt("_windspd");
      _pressure = children0[L].getInt("_pressure");
      _drybulb = children0[L].getInt("_drybulb");
      _relhum = children0[L].getInt("_relhum");
      _dirnorrad = children0[L].getInt("_dirnorrad");
      _difhorrad = children0[L].getInt("_difhorrad");
      _glohorrad = children0[L].getInt("_glohorrad");
      _direffect = children0[L].getInt("_direffect");
      _difeffect = children0[L].getInt("_difeffect");
      A_precipitation = children0[L].getInt("A_precipitation");
      _developed = children0[L].getInt("_developed");
      Angle_inclination = children0[L].getFloat("Angle_inclination");
      Angle_orientation = children0[L].getFloat("Angle_orientation");
      STUDY_drw_Layer = children0[L].getInt("STUDY_drw_Layer");
      develop_Layer = children0[L].getInt("develop_Layer");
      STUDY_print_title = children0[L].getInt("STUDY_print_title");
      STUDY_T_scale = children0[L].getFloat("STUDY_T_scale");
      STUDY_U_scale = children0[L].getFloat("STUDY_U_scale");
      sky_scenario = children0[L].getInt("sky_scenario");
      _hourly = children0[L].getInt("_hourly");
      _daily = children0[L].getInt("_daily");
      filter_type = children0[L].getInt("filter_type");
      join_hour_numbers = children0[L].getInt("join_hour_numbers");
      join_type = children0[L].getInt("join_type");
      dT = children0[L].getInt("dT");
      Export_STUDY_info_node = children0[L].getInt("Export_STUDY_info_node");
      Export_STUDY_info_norm = children0[L].getInt("Export_STUDY_info_norm");
      Export_STUDY_info_prob = children0[L].getInt("Export_STUDY_info_prob");
      STUDY_Pallet_SORT_CLR = children0[L].getInt("STUDY_Pallet_SORT_CLR");
      STUDY_Pallet_SORT_DIR = children0[L].getInt("STUDY_Pallet_SORT_DIR");
      STUDY_Pallet_SORT_MLT = children0[L].getFloat("STUDY_Pallet_SORT_MLT");
      STUDY_Pallet_PROB_CLR = children0[L].getInt("STUDY_Pallet_PROB_CLR");
      STUDY_Pallet_PROB_DIR = children0[L].getInt("STUDY_Pallet_PROB_DIR");
      STUDY_Pallet_PROB_MLT = children0[L].getFloat("STUDY_Pallet_PROB_MLT");
      STUDY_Pallet_ACTIVE_CLR = children0[L].getInt("STUDY_Pallet_ACTIVE_CLR");
      STUDY_Pallet_ACTIVE_DIR = children0[L].getInt("STUDY_Pallet_ACTIVE_DIR");
      STUDY_Pallet_ACTIVE_MLT = children0[L].getFloat("STUDY_Pallet_ACTIVE_MLT");
      STUDY_Pallet_PASSIVE_CLR = children0[L].getInt("STUDY_Pallet_PASSIVE_CLR");
      STUDY_Pallet_PASSIVE_DIR = children0[L].getInt("STUDY_Pallet_PASSIVE_DIR");
      STUDY_Pallet_PASSIVE_MLT = children0[L].getFloat("STUDY_Pallet_PASSIVE_MLT");
      OBJECTS_Pallet_ACTIVE_CLR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_CLR");
      OBJECTS_Pallet_ACTIVE_DIR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_DIR");
      OBJECTS_Pallet_ACTIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_ACTIVE_MLT");
      OBJECTS_Pallet_PASSIVE_CLR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_CLR");
      OBJECTS_Pallet_PASSIVE_DIR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_DIR");
      OBJECTS_Pallet_PASSIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_PASSIVE_MLT");
      SunPath3D_Pallet_ACTIVE_CLR = children0[L].getInt("SunPath3D_Pallet_ACTIVE_CLR");
      SunPath3D_Pallet_ACTIVE_DIR = children0[L].getInt("SunPath3D_Pallet_ACTIVE_DIR");
      SunPath3D_Pallet_ACTIVE_MLT = children0[L].getFloat("SunPath3D_Pallet_ACTIVE_MLT");
      SunPath3D_Pallet_PASSIVE_CLR = children0[L].getInt("SunPath3D_Pallet_PASSIVE_CLR");
      SunPath3D_Pallet_PASSIVE_DIR = children0[L].getInt("SunPath3D_Pallet_PASSIVE_DIR");
      SunPath3D_Pallet_PASSIVE_MLT = children0[L].getFloat("SunPath3D_Pallet_PASSIVE_MLT");
      SKY3D_Pallet_ACTIVE_CLR = children0[L].getInt("SKY3D_Pallet_ACTIVE_CLR");
      SKY3D_Pallet_ACTIVE_DIR = children0[L].getInt("SKY3D_Pallet_ACTIVE_DIR");
      SKY3D_Pallet_ACTIVE_MLT = children0[L].getFloat("SKY3D_Pallet_ACTIVE_MLT");
      SKY3D_Pallet_PASSIVE_CLR = children0[L].getInt("SKY3D_Pallet_PASSIVE_CLR");
      SKY3D_Pallet_PASSIVE_DIR = children0[L].getInt("SKY3D_Pallet_PASSIVE_DIR");
      SKY3D_Pallet_PASSIVE_MLT = children0[L].getFloat("SKY3D_Pallet_PASSIVE_MLT");
      ELEVATION_Pallet_CLR = children0[L].getInt("ELEVATION_Pallet_CLR");
      ELEVATION_Pallet_DIR = children0[L].getInt("ELEVATION_Pallet_DIR");
      ELEVATION_Pallet_MLT = children0[L].getFloat("ELEVATION_Pallet_MLT");
      SPATIAL_Pallet_CLR = children0[L].getInt("SPATIAL_Pallet_CLR");
      SPATIAL_Pallet_DIR = children0[L].getInt("SPATIAL_Pallet_DIR");
      SPATIAL_Pallet_MLT = children0[L].getFloat("SPATIAL_Pallet_MLT");
      windFlow_Pallet_CLR = children0[L].getInt("windFlow_Pallet_CLR");
      windFlow_Pallet_DIR = children0[L].getInt("windFlow_Pallet_DIR");
      windFlow_Pallet_MLT = children0[L].getFloat("windFlow_Pallet_MLT");
      Impact_ACTIVE = children0[L].getInt("Impact_ACTIVE");
      Impact_PASSIVE = children0[L].getInt("Impact_PASSIVE");
      Impact_SPD_DIR = children0[L].getInt("Impact_SPD_DIR");
      Impact_SPD_DIR_TMP = children0[L].getInt("Impact_SPD_DIR_TMP");
      Impact_TYPE = children0[L].getInt("Impact_TYPE");
      STUDY_O_scale = children0[L].getFloat("STUDY_O_scale");
      STUDY_W_scale = children0[L].getFloat("STUDY_W_scale");
      COLOR_STYLE = children0[L].getInt("COLOR_STYLE");
      n_COLOR_STYLE = children0[L].getInt("n_COLOR_STYLE");
      obj_scale = children0[L].getFloat("obj_scale");
      obj_offset_x = children0[L].getFloat("obj_offset_x");
      databaseNumber_OBSERVED = children0[L].getInt("databaseNumber_OBSERVED");
      databaseNumber_ENSEMBLE = children0[L].getInt("databaseNumber_ENSEMBLE");
      databaseNumber_CLIMATE_WY2 = children0[L].getInt("databaseNumber_CLIMATE_WY2");
      databaseNumber_CLIMATE_EPW = children0[L].getInt("databaseNumber_CLIMATE_EPW");
      impacts_source = children0[L].getInt("impacts_source");
      draw_impact_summary = children0[L].getInt("draw_impact_summary");
      impact_layer = children0[L].getInt("impact_layer");
      plot_impacts = children0[L].getInt("plot_impacts");
      update_impacts = children0[L].getInt("update_impacts");
      draw_frame = children0[L].getInt("draw_frame");
      MODEL1D_ERASE = children0[L].getInt("MODEL1D_ERASE");
      MODEL2D_ERASE = children0[L].getInt("MODEL2D_ERASE");
      MODEL3D_ERASE = children0[L].getInt("MODEL3D_ERASE");
      SECTION_ERASE = children0[L].getInt("SECTION_ERASE");
      LAND_TESSELLATION = children0[L].getInt("LAND_TESSELLATION");
      MODEL3D_TESSELLATION = children0[L].getInt("MODEL3D_TESSELLATION");
      SKY3D_TESSELLATION = children0[L].getInt("SKY3D_TESSELLATION");
      SKY3D_scale = children0[L].getFloat("SKY3D_scale");
      WindRose3D_scale = children0[L].getFloat("WindRose3D_scale");

      planetary_magnification = children0[L].getFloat("planetary_magnification");
      Display_SolarRotation = children0[L].getInt("Display_SolarRotation");      
      Display_SUN3D_Path = children0[L].getInt("Display_SUN3D_Path");
      Display_SUN3D_Pattern = children0[L].getInt("Display_SUN3D_Pattern");
      Display_SKY3D = children0[L].getInt("Display_SKY3D");
      Display_STAR3D = children0[L].getInt("Display_STAR3D");
      Display_STAR3D_TEXTURE = children0[L].getInt("Display_STAR3D_TEXTURE");            
      Display_MOON3D = children0[L].getInt("Display_MOON3D");
      Display_MOON3D_TEXTURE = children0[L].getInt("Display_MOON3D_TEXTURE");
      Display_TROPO3D = children0[L].getInt("Display_TROPO3D");
      Display_TROPO3D_TEXTURE = children0[L].getInt("Display_TROPO3D_TEXTURE");
      Display_EARTH3D = children0[L].getInt("Display_EARTH3D");
      Display_EARTH3D_TEXTURE = children0[L].getInt("Display_EARTH3D_TEXTURE");
      Download_LAND_MESH = children0[L].getInt("Download_LAND_MESH");
      Load_LAND_MESH = children0[L].getInt("Load_LAND_MESH");
      Display_LAND_MESH = children0[L].getInt("Display_LAND_MESH");
      Display_LAND_TEXTURE = children0[L].getInt("Display_LAND_TEXTURE");
      Display_LAND_DEPTH = children0[L].getInt("Display_LAND_DEPTH");
      Skip_LAND_MESH_Center = children0[L].getInt("Skip_LAND_MESH_Center");
      Load_URBAN_MESH = children0[L].getInt("Load_URBAN_MESH");
      Display_URBAN_MESH = children0[L].getInt("Display_URBAN_MESH");
      Display_SpatialImpact_Points = children0[L].getInt("Display_SpatialImpact_Points");
      Display_SpatialImpact_Lines = children0[L].getInt("Display_SpatialImpact_Lines");
      Display_MODEL3D_EDGES = children0[L].getInt("Display_MODEL3D_EDGES");
      Display_MODEL3D_NORMALS = children0[L].getInt("Display_MODEL3D_NORMALS");
      Display_windFlow = children0[L].getInt("Display_windFlow");
      camera_variation = children0[L].getInt("camera_variation");
      draw_data_lines = children0[L].getInt("draw_data_lines");
      draw_sorted = children0[L].getInt("draw_sorted");
      draw_normals = children0[L].getInt("draw_normals");
      draw_probs = children0[L].getInt("draw_probs");
      sum_interval = children0[L].getInt("sum_interval");
      level_pix = children0[L].getFloat("level_pix");
      _pix = children0[L].getFloat("_pix");
      STUDY_setup = children0[L].getInt("STUDY_setup");
      Materials_Selection = children0[L].getInt("Materials_Selection");
      Shade_Surface_Wire = children0[L].getInt("Shade_Surface_Wire");
      Shade_Surface_Base = children0[L].getInt("Shade_Surface_Base");
      Shade_Surface_White = children0[L].getInt("Shade_Surface_White");
      Shade_Surface_Materials = children0[L].getInt("Shade_Surface_Materials");
      Shade_Global_Solar = children0[L].getInt("Shade_Global_Solar");
      Shade_Vertex_Solar = children0[L].getInt("Shade_Vertex_Solar");
      Shade_Vertex_Spatial = children0[L].getInt("Shade_Vertex_Spatial");
      Shade_Vertex_Elevation = children0[L].getInt("Shade_Vertex_Elevation");
      CAM_x = children0[L].getFloat("CAM_x");
      CAM_y = children0[L].getFloat("CAM_y");
      CAM_z = children0[L].getFloat("CAM_z");
      CAM_fov = children0[L].getFloat("CAM_fov");
      CAM_dist = children0[L].getFloat("CAM_dist");
      CAM_clipNear = children0[L].getFloat("CAM_clipNear");
      CAM_clipFar = children0[L].getFloat("CAM_clipFar");
      OBJECTS_scale = children0[L].getFloat("OBJECTS_scale");
      refScale = children0[L].getFloat("refScale");
      WIN3D_Y_coordinate = children0[L].getFloat("WIN3D_Y_coordinate");
      WIN3D_Z_coordinate = children0[L].getFloat("WIN3D_Z_coordinate");
      WIN3D_S_coordinate = children0[L].getFloat("WIN3D_S_coordinate");
      WIN3D_RX_coordinate = children0[L].getFloat("WIN3D_RX_coordinate");
      WIN3D_RY_coordinate = children0[L].getFloat("WIN3D_RY_coordinate");
      WIN3D_RZ_coordinate = children0[L].getFloat("WIN3D_RZ_coordinate");
      WIN3D_RS_coordinate = children0[L].getFloat("WIN3D_RS_coordinate");
      WIN3D_ZOOM_coordinate = children0[L].getFloat("WIN3D_ZOOM_coordinate");
      WIN3D_View_Type = children0[L].getInt("WIN3D_View_Type");
      WIN3D_FACES_SHADE = children0[L].getInt("WIN3D_FACES_SHADE");

      selected_posVector = children0[L].getInt("selected_posVector");
      selected_rotVector = children0[L].getInt("selected_rotVector");
      selected_scaleVector = children0[L].getInt("selected_scaleVector");
      selected_posValue = children0[L].getFloat("selected_posValue");
      selected_rotValue = children0[L].getFloat("selected_rotValue");
      selected_scaleValue = children0[L].getFloat("selected_scaleValue");
      selection_alignX = children0[L].getInt("selection_alignX");
      selection_alignY = children0[L].getInt("selection_alignY");
      selection_alignZ = children0[L].getInt("selection_alignZ");

      selectedPolymesh_displaySolarPivots = children0[L].getInt("selectedPolymesh_displaySolarPivots");
      selectedPolymesh_displayPivot = children0[L].getInt("selectedPolymesh_displayPivot");
      selectedPolymesh_displayEdges = children0[L].getInt("selectedPolymesh_displayEdges");
      selectedPolymesh_displayBox = children0[L].getInt("selectedPolymesh_displayBox");
      selectedFace_displayEdges = children0[L].getInt("selectedFace_displayEdges");
      selectedFace_displayVertexCount = children0[L].getInt("selectedFace_displayVertexCount");
      selectedVertex_displayVertices = children0[L].getInt("selectedVertex_displayVertices");      
      selectedObject2D_displayEdges = children0[L].getInt("selectedObject2D_displayEdges");
      selectedFractal_displayEdges = children0[L].getInt("selectedFractal_displayEdges");
      selectedSection_displayEdges = children0[L].getInt("selectedSection_displayEdges");
      
      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");
      
      WORLD_viewport_ZOOM = children0[L].getInt("WORLD_viewport_ZOOM");
      frame_variation = children0[L].getInt("frame_variation");
      _LAN = children0[L].getInt("_LAN");
      LAND_TEXTURE_scale_U = children0[L].getFloat("LAND_TEXTURE_scale_U");
      LAND_TEXTURE_scale_V = children0[L].getFloat("LAND_TEXTURE_scale_V");
      LAND_n_I_base = children0[L].getInt("LAND_n_I_base");
      LAND_n_J_base = children0[L].getInt("LAND_n_J_base");
      LAND_n_I = children0[L].getInt("LAND_n_I");
      LAND_n_J = children0[L].getInt("LAND_n_J");
      Day_of_Impact_to_Display = children0[L].getInt("Day_of_Impact_to_Display");
      Display_WindRose_Image = children0[L].getInt("Display_WindRose_Image");
      WindRose_RES = children0[L].getInt("WindRose_RES");
      Rendered_WindRose_RES = children0[L].getInt("Rendered_WindRose_RES");
      Display_SolarImpact_Image = children0[L].getInt("Display_SolarImpact_Image");
      SolarImpact_sectionType = children0[L].getInt("SolarImpact_sectionType");
      SolarImpact_Rotation = children0[L].getFloat("SolarImpact_Rotation");
      SolarImpact_scale_U = children0[L].getFloat("SolarImpact_scale_U");
      SolarImpact_scale_V = children0[L].getFloat("SolarImpact_scale_V");
      SolarImpact_offset_U = children0[L].getFloat("SolarImpact_offset_U");
      SolarImpact_offset_V = children0[L].getFloat("SolarImpact_offset_V");      
      SolarImpact_RES1 = children0[L].getInt("SolarImpact_RES1");
      SolarImpact_RES2 = children0[L].getInt("SolarImpact_RES2");
      SolarImpact_Elevation = children0[L].getFloat("SolarImpact_Elevation");
      SpatialImpact_RES1 = children0[L].getInt("SpatialImpact_RES1");
      SpatialImpact_RES2 = children0[L].getInt("SpatialImpact_RES2");
      SpatialImpact_Grade = children0[L].getFloat("SpatialImpact_Grade");
      Display_SpatialImpact_Image = children0[L].getInt("Display_SpatialImpact_Image");
      SpatialImpact_sectionType = children0[L].getInt("SpatialImpact_sectionType");
      SpatialImpact_positionStep = children0[L].getFloat("SpatialImpact_positionStep");
      PROCESS_subdivisions = children0[L].getInt("PROCESS_subdivisions");
      deltaSpatialImpact = children0[L].getFloat("deltaSpatialImpact");
      deltaSpatialImpactLines = children0[L].getFloat("deltaSpatialImpactLines");
      MinimumDistance_traceU = children0[L].getFloat("MinimumDistance_traceU");
      MinimumDistance_traceV = children0[L].getFloat("MinimumDistance_traceV");
      stp_slp = children0[L].getFloat("stp_slp");
      stp_dir = children0[L].getFloat("stp_dir");
      n_slp = children0[L].getInt("n_slp");
      n_dir = children0[L].getInt("n_dir");
      LAND_n_I_base = children0[L].getInt("LAND_n_I_base");
      LAND_n_J_base = children0[L].getInt("LAND_n_J_base");
      LAND_n_I = children0[L].getInt("LAND_n_I");
      LAND_n_J = children0[L].getInt("LAND_n_J");
      LAND_mid_lat = Double.parseDouble(children0[L].getString("LAND_mid_lat"));
      LAND_mid_lon = Double.parseDouble(children0[L].getString("LAND_mid_lon"));
      Object2D_PEOPLE_Files_Num = children0[L].getInt("Object2D_PEOPLE_Files_Num");
      Object2D_TREES_Files_Num = children0[L].getInt("Object2D_TREES_Files_Num");
      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");

      objExportPrecisionVertex = children0[L].getInt("objExportPrecisionVertex");
      objExportPrecisionVtexture = children0[L].getInt("objExportPrecisionVtexture");
      objExportPolyToPoly = children0[L].getInt("objExportPolyToPoly");
      objExportMaterialLibrary  = children0[L].getInt("objExportMaterialLibrary ");
      objExportBackSides = children0[L].getInt("objExportBackSides");
      objExportCombinedMaterial = children0[L].getInt("objExportCombinedMaterial");      
      objExportBakingResolution = children0[L].getInt("objExportBakingResolution");


      {
        String new_Default_Font = children0[L].getString("Default_Font");
        if (Default_Font.equals(new_Default_Font)) {
        }
        else {
          Default_Font = new_Default_Font;        
          LoadDefaultFontStyle();
        }
      } 
      
      {
        String new_TEXTURE_path = children0[L].getString("LAND_TEXTURE_ImagePath");
        if (LAND_TEXTURE_ImagePath.toUpperCase().equals(new_TEXTURE_path.toUpperCase())) {
        }
        else {
          LAND_TEXTURE_ImagePath = new_TEXTURE_path;
          LAND_TEXTURE = createImage(2, 2, RGB);
          if (LAND_TEXTURE_ImagePath.equals("")) {
          }
          else {
            println("Loading texture:", LAND_TEXTURE_ImagePath);
            LAND_TEXTURE = loadImage(LAND_TEXTURE_ImagePath);
          }
                    
        }
      }

    }

    {
      children0 = FileAll.getChildren("Object2D_ImagePath");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        
        int reload_All_textures = 0;
        
        if (Object2D_ImagePath.length != ni) {
          Object2DImages = new PImage [ni];
          Object2DImageRatios = new float [ni];
          
          reload_All_textures = 1;
        }
        
        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      
      
          String new_TEXTURE_path = children1[i].getContent();
          if ((reload_All_textures == 0) && (Object2D_ImagePath[i].toUpperCase().equals(new_TEXTURE_path.toUpperCase()))) {
          }
          else {
            Object2D_ImagePath[i] = new_TEXTURE_path;
            Object2DImages[i] = createImage(2, 2, RGB);
            if (Object2D_ImagePath[i].equals("")) {
            }
            else {
              println("Loading texture(" + i + "):", Object2D_ImagePath[i]);
              Object2DImages[i] = loadImage(Object2D_ImagePath[i]);
              println("loaded!");
              
              if (Object2DImages[i].height != 0) {
                Object2DImageRatios[i] = float(Object2DImages[i].width) / float(Object2DImages[i].height);
              }
              else {
                Object2DImageRatios[i] = 1;
              }              
            }
          }
        }
      }
    }
    

    {
      children0 = FileAll.getChildren("allSection_SpatialImpact");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        
        allSection_SpatialImpact = new PImage [ni];
        
        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      
          
          String TEXTURE_path = children1[i].getContent();

          allSection_SpatialImpact[i] = createImage(2, 2, RGB);

          println("Loading texture(" + i + "):", TEXTURE_path);
          allSection_SpatialImpact[i] = loadImage(TEXTURE_path);
          println("loaded!");
          
        }
      }
    }

    {
      children0 = FileAll.getChildren("allSection_SolarImpact");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        int nj = children0[L].getInt("nj");
        
        allSection_SolarImpact = new PImage [ni][nj]; 
        
        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      
          for (int j = 0; j < nj; j++) {
          
            String TEXTURE_path = children1[i * nj + j].getContent();
  
            allSection_SolarImpact[i][j] = createImage(2, 2, RGB);
  
            println("Loading texture(" + i + "," + j + "):", TEXTURE_path);
            allSection_SolarImpact[i][j] = loadImage(TEXTURE_path);
            println("loaded!");
          }
        }
      }
    }
    
    children0 = FileAll.getChildren("DEFINED_STATION");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      XML[] children1 = children0[L].getChildren("Property");         
      
      STATION_NUMBER = 0; // <<<<<<<<<< overwrite station 0
      
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        
        DEFINED_STATIONS[STATION_NUMBER][i] = lineSTR;  
      }
      
      BAR_a_Items[N_Site_in_Bar_a][1] = DEFINED_STATIONS[STATION_NUMBER][0]; // <<<<<<<<      
    }


    LAND_MESH = new float [LAND_n_I][LAND_n_J][3];
    children0 = FileAll.getChildren("LAND_MESH");
    for (int L = 0; L < children0.length; L++) {
      XML[] children1 = children0[L].getChildren("Vertice");         
      for (int i = 0; i < LAND_n_I * LAND_n_J; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          LAND_MESH[(i / LAND_n_J)][(i % LAND_n_J)][j] = float(parts[j]); 
        }
      }
    }

    children0 = FileAll.getChildren("allSection");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      
      allSection_UVERAB = new float [ni][6];
      allSection_Type = new int [ni];
      allSection_RES1 = new int [ni];
      allSection_RES2 = new int [ni];
      allSection_num = ni - 1;
      
      XML[] children1 = children0[L].getChildren("Section");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 6; j++) {
          allSection_UVERAB[i][j] = float(parts[j]);
        }

        allSection_Type[i] = int(parts[6]);
        allSection_RES1[i] = int(parts[7]);
        allSection_RES2[i] = int(parts[8]);
      }
    } 

 
    children0 = FileAll.getChildren("allFractal");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      
      allFractal_XYZSRA = new float [ni][6];
      allFractal_Type = new int [ni];
      allFractal_DegreeMin = new int [ni];
      allFractal_DegreeMax = new int [ni];
      allFractal_Seed = new int [ni];
      allFractal_TrunkSize = new float [ni];
      allFractal_LeafSize = new float [ni];
      allFractal_num = ni - 1;
      
      XML[] children1 = children0[L].getChildren("Fractal");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 6; j++) {
          allFractal_XYZSRA[i][j] = float(parts[j]);
        }

        allFractal_Type[i] = int(parts[6]);
        allFractal_DegreeMin[i] = int(parts[7]);
        allFractal_DegreeMax[i] = int(parts[8]);
        allFractal_Seed[i] = int(parts[9]);
        allFractal_TrunkSize[i] = float(parts[10]);
        allFractal_LeafSize[i] = float(parts[11]);
      }
    }       

    children0 = FileAll.getChildren("allObject2D");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      
      allObject2D_XYZS = new float [ni][4];
      allObject2D_MAP = new int [ni];
      allObject2D_num = ni - 1;
      
      XML[] children1 = children0[L].getChildren("Object2D");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 4; j++) {
          allObject2D_XYZS[i][j] = float(parts[j]);
        }
        allObject2D_MAP[i] = int(parts[4]);
      }
    }      

    children0 = FileAll.getChildren("allPolymesh_SolarPivotXYZ");
    for (int L = 0; L < children0.length; L++) {
      
      int ni = children0[L].getInt("ni");
      
      allPolymesh_SolarPivotXYZ = new float [ni][3];
      
      XML[] children1 = children0[L].getChildren("SolarPivotXYZ");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 3; j++) {
          allPolymesh_SolarPivotXYZ[i][j] = float(parts[j]);
        }
      }
    }  

    children0 = FileAll.getChildren("allPolymesh_SolarPivotType");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      
      allPolymesh_SolarPivotType = new int [ni][1];
      
      XML[] children1 = children0[L].getChildren("SolarPivotType");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 1; j++) {
          allPolymesh_SolarPivotType[i][j] = int(parts[j]);
        }
      }
    }          
 
    children0 = FileAll.getChildren("allVertices");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allVertices = new float [ni][3];
      XML[] children1 = children0[L].getChildren("Vertice");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allVertices[i][j] = float(parts[j]); 
        }
      }
    }  
    
    children0 = FileAll.getChildren("allFaces");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allFaces = new int [0][0];
      XML[] children1 = children0[L].getChildren("Face");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        int nj = parts.length;
        int[][] newFace = new int [1][nj];
        for (int j = 0; j < nj; j++) {
          newFace[0][j] = int(parts[j]); 
        }
        allFaces = (int[][]) concat(allFaces, newFace);
      }
    }   

    children0 = FileAll.getChildren("allFaces_MTLV");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allFaces_MTLV = new int [ni][4];
      XML[] children1 = children0[L].getChildren("Face_MTLV"); 
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allFaces_MTLV[i][j] = int(parts[j]); 
        }
      }
    }    
    
    children0 = FileAll.getChildren("allPolymesh_Faces");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allPolymesh_Faces = new int [ni][2];
      XML[] children1 = children0[L].getChildren("Faces");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allPolymesh_Faces[i][j] = int(parts[j]); 
        }
      }
    }     

    children0 = FileAll.getChildren("allPolymesh_Solids");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allPolymesh_Solids = new int [ni][2];
      XML[] children1 = children0[L].getChildren("Solids");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allPolymesh_Solids[i][j] = int(parts[j]); 
        }
      }
    } 
    
    children0 = FileAll.getChildren("SolidObjects");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SOLARCHVISION_remove_ParametricGeometries();
      XML[] children1 = children0[L].getChildren("Solid");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        float v = float(parts[0]);
        float x = float(parts[1]);
        float y = float(parts[2]);
        float z = float(parts[3]);
        float px = float(parts[4]);
        float py = float(parts[5]);
        float pz = float(parts[6]);
        float sx = float(parts[7]);
        float sy = float(parts[8]);
        float sz = float(parts[9]);
        float tx = float(parts[10]);
        float ty = float(parts[11]);
        float tz = float(parts[12]);
        ParametricGeometry[] newSolidObject = {new ParametricGeometry(v, x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz)};         
        SolidObjects = (ParametricGeometry[]) concat(SolidObjects, newSolidObject);          
      }
    }  

    children0 = FileAll.getChildren("selectedFractal_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedFractal_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedFractal_numbers[i] = int(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("selectedObject2D_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedObject2D_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedObject2D_numbers[i] = int(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("selectedPolymesh_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedPolymesh_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedPolymesh_numbers[i] = int(parts[i]);
      }
    } 
    
    children0 = FileAll.getChildren("selectedFace_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedFace_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedFace_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedVertex_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_numbers[i] = int(parts[i]);
      }
    }
    
    children0 = FileAll.getChildren("selectedVertex_softSelectionVertices");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_softSelectionVertices = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionVertices[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedVertex_softSelectionValues");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_softSelectionValues = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionValues[i] = float(parts[i]);
      }
    }
    

    children0 = FileAll.getChildren("selectedSection_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedSection_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedSection_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("SpatialImpact_Elevation");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_Elevation = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_Elevation[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SpatialImpact_Rotation");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_Rotation = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_Rotation[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SpatialImpact_scale_U");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_scale_U = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_scale_U[i] = float(parts[i]);
      }
    } 
    
    children0 = FileAll.getChildren("SpatialImpact_scale_V");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_scale_V = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_scale_V[i] = float(parts[i]);
      }
    }     
    
    children0 = FileAll.getChildren("SpatialImpact_offset_U");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_offset_U = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_offset_U[i] = float(parts[i]);
      }
    } 
    
    children0 = FileAll.getChildren("SpatialImpact_offset_V");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SpatialImpact_offset_V = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SpatialImpact_offset_V[i] = float(parts[i]);
      }
    }         
    
    children0 = FileAll.getChildren("STUDY_V_scale");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_scale = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_scale[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("STUDY_V_offset");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_offset = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_offset[i] = float(parts[i]);
      }
    }     

    children0 = FileAll.getChildren("STUDY_V_belowLine");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_belowLine = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_belowLine[i] = float(parts[i]);
      }
    } 


    children0 = FileAll.getChildren("LAYERS_Unit");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_Unit = new String [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_Unit[i] = parts[i];
      }
    }

    children0 = FileAll.getChildren("LAYERS_ENSEMBLE");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_ENSEMBLE = new String [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_ENSEMBLE[i] = parts[i];
      }
    }

    children0 = FileAll.getChildren("LAYERS_GRIB2_MUL");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_GRIB2_MUL = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_GRIB2_MUL[i] = float(parts[i]);
      }
    }

    children0 = FileAll.getChildren("LAYERS_GRIB2_ADD");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_GRIB2_ADD = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_GRIB2_ADD[i] = float(parts[i]);
      }
    }

    children0 = FileAll.getChildren("GRIB2_TGL_Selected");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      GRIB2_TGL_Selected = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        GRIB2_TGL_Selected[i] = int(parts[i]);
      }
    }
    
    



    
  }
  println("End of loading project.");
  
  
  // loading only weather data // 
  SOLARCHVISION_update_station(2); 
  SOLARCHVISION_update_station(3);
  SOLARCHVISION_update_station(4);
  SOLARCHVISION_update_station(5);
  ///////////////////////////////
  
  addNewSelectionToPreviousSelection = 0;
  
  addToLastPolymesh = 0;
  
  set_to_Create_Nothing();
  
  WORLD_VIEW_Auto = 1;
  
  WORLD_VIEW_Number = FindGoodViewport(LocationLongitude, LocationLatitude);
  
  SOLARCHVISION_update_frame_layout();
  
  ROLLOUT_Update = 1;
  WORLD_Update = 1;
  WIN3D_Update = 1; 
  STUDY_Update = 1;     
  BAR_a_Update = 1; 
  BAR_b_Update = 1;
  BAR_d_Update = 1;
  
  rebuild_SolarProjection_array = 1;
  rebuild_SolarImpact_Image_array = 1;
  rebuild_WindRose_Image_array = 1; 
  
  SOLARCHVISION_calculate_SpatialImpact_selectedSections();

}





/* 

bug: delete because scrolling selection+ could add duplicate of the same objects to the list!
solution: I remarked wheel option for pickSelect for now.

*/




