

// please define station elevation data for CWEEDS points!

  

 












String SOLARCHVISION_version = "2017"; 
String BaseFolder = "C:/SOLARCHVISION_" + SOLARCHVISION_version; 

String SceneName = "Complex";


String CLIMATE_TMYEPW_directory;
String CLIMATE_CWEEDS_directory;
String CLIMATE_CLMREC_directory;
String ENSEMBLE_OBSERVED_directory;
String ENSEMBLE_FORECAST_directory;
String GRIB2_directory;
String GEOMET_directory;

String[] CLIMATE_TMYEPW_Files;
String[] CLIMATE_CWEEDS_Files;
String[] CLIMATE_CLMREC_Files;
String[] ENSEMBLE_OBSERVED_Files;
String[] ENSEMBLE_FORECAST_Files;





String Wgrib2TempFolder;

String BackgroundFolder;
String CoordinateFolder;


String LandFolder;
String allModel2DsFolder_PEOPLE;
String allModel2DsFolder_TREES;
String ExportFolder;
String ProjectFolder;
String graphicsFolder;
String allModel3DsFolder;
String ViewsFromSkyFolder;
String ScreenShotFolder;
String ShadingFolder;



String RunStamp = nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
String ProjectName = "Revision_" + RunStamp;
String HoldStamp = ""; 

void SOLARCHVISION_update_folders () {
  
  ProjectFolder = BaseFolder + "/Projects/Roodbar";    
  
  Wgrib2TempFolder = ProjectFolder + "/Temp";

  GEOMET_directory = ProjectFolder + "/Data/GEOMET" + "/" + RunStamp;
  GRIB2_directory = ProjectFolder + "/Data/GRIB2";
  
  ENSEMBLE_FORECAST_directory = ProjectFolder + "/Data/FORECAST_NAEFS";
  ENSEMBLE_OBSERVED_directory = ProjectFolder + "/Data/OBSERVATION_SWOB";

  CLIMATE_CLMREC_directory = BaseFolder + "/Input/Climate/CLIMATE_CLMREC";
  CLIMATE_TMYEPW_directory = BaseFolder + "/Input/Climate/CLIMATE_EPW_WORLD";
  CLIMATE_CWEEDS_directory = BaseFolder + "/Input/Climate/CLIMATE_CWEED";
  
  CLIMATE_CLMREC_Files = SOLARCHVISION_getfiles(CLIMATE_CLMREC_directory);
  CLIMATE_TMYEPW_Files = SOLARCHVISION_getfiles(CLIMATE_TMYEPW_directory);
  CLIMATE_CWEEDS_Files = SOLARCHVISION_getfiles(CLIMATE_CWEEDS_directory);
  
  ENSEMBLE_OBSERVED_Files = SOLARCHVISION_getfiles(ENSEMBLE_OBSERVED_directory);
  ENSEMBLE_FORECAST_Files = SOLARCHVISION_getfiles(ENSEMBLE_FORECAST_directory);  

  BackgroundFolder      = BaseFolder + "/Input/BackgroundImages/Standard/Other";
  CoordinateFolder      = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  WORLD.ViewFolder      = BaseFolder + "/Input/BackgroundImages/Standard/World";
  
  allModel2DsFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People";
  allModel2DsFolder_TREES  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees";
  
  ShadingFolder = ProjectFolder + "/ShadingAnalysis";
  
  LandFolder            = ProjectFolder + "/Land/USE";
  
  ExportFolder          = ProjectFolder + "/Export";
  graphicsFolder        = ExportFolder + "/graphics" + "/" + RunStamp;
  allModel3DsFolder         = ExportFolder + "/allModel3Ds" + "/" + RunStamp;
  ViewsFromSkyFolder    = ExportFolder + "/ViewsFromSky" + "/" + RunStamp;
  ScreenShotFolder      = ExportFolder + "/ScreenShots" + "/" + RunStamp;

  String[] filenames = SOLARCHVISION_getfiles(ScreenShotFolder);
  if (filenames != null) SavedScreenShots = filenames.length;
  
}















int SOLARCHVISION_H_Pixel = 275; //300; 
int SOLARCHVISION_W_Pixel = int(SOLARCHVISION_H_Pixel * 1.75); 

float MessageSize = (2 * SOLARCHVISION_W_Pixel + SOLARCHVISION_H_Pixel) / 120.0; // screen width 

int SOLARCHVISION_A_Pixel = int(1.5 * MessageSize); // menu bar
int SOLARCHVISION_B_Pixel = int(2.75 * MessageSize); // 3D tool bar
int SOLARCHVISION_C_Pixel = int(3.0 * MessageSize); // command bar
int SOLARCHVISION_D_Pixel = int(4.5 * MessageSize); // time bar




String[] skyScenario_Title = {
  "", "", "[66% < Total Cloud Cover]", "[33% < Total Cloud Cover < 66%]", "[Total Cloud Cover < 33%]"
};
String[] skyScenario_FileTXT = {
  "", "", "Overcast sky", "Scattered sky", "Clear sky"
};

int FILTER_Hourly = 0;
int FILTER_Daily = 1;

final int numberOfLanguages = 2;
final int Language_EN = 0;
final int Language_FR = 1;
int Language_Active = Language_EN;


final float FLOAT_huge = 1000000000;
final float FLOAT_tiny = 0.05; // don't use very tiny values that could result is shading problems at the intersection of faces

final String STRING_undefined = "N/A";
final float FLOAT_undefined = 2000000000; // it must be a positive big number that is not included in any data
final float FLOAT_max_defined = 0.95 * FLOAT_undefined;

boolean is_undefined_FLOAT (float a) {
  boolean b = false;
  if (a > FLOAT_max_defined) {
    b = true; 
  }
  return b;
}


int numberOfLayers = 0;

class solarchvision_LAYER {
  
  private final static String CLASS_STAMP = "LAYER";
  
  public int id;  
  
  public String unit = "";
  public String name = "";
  public String[] descriptions = new String [numberOfLanguages];

  public float V_scale = 1;
  public float V_offset = 0;
  public float V_belowLine = 0;  
  
  solarchvision_LAYER (float V_scale, float V_offset, float V_belowLine, String unit, String description_EN, String description_FR, String name) {
    
    this.V_scale = V_scale;
    this.V_offset = V_offset;
    this.V_belowLine = V_belowLine;
    this.unit = unit;
    this.name = name;
    this.descriptions[Language_EN] = description_EN;
    this.descriptions[Language_FR] = description_FR;
    
    this.id = numberOfLayers;
    numberOfLayers++; 
  }
  
}

solarchvision_LAYER LAYER_windspd200hPa = new solarchvision_LAYER(
  0.5,
  0,
  0,
  "knots",
  "Wind Speed at 200 hPa",
  "Vitesse du vent à 200 hPa",  
  "WIND-200HPA"
);

solarchvision_LAYER LAYER_thicknesses_1000_500 = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotentiel Difference",
  "Différence de géopotentiel",
  "PARAMETERS-1000-500HPA"
);


solarchvision_LAYER LAYER_heightp500hPa = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotential at 500 hPa",
  "Géopotentiel à 500 hPa",
  "HGT-500HPA"
); 

solarchvision_LAYER LAYER_ceilingsky = new solarchvision_LAYER(
  0.01,
  0,
  0,
  "m",
  "Ceiling height",
  "Hauteur sous plafond",  
  ""
);


solarchvision_LAYER LAYER_cloudcover = new solarchvision_LAYER(
  10.0,
  0,
  0,
  "tenth",
  "Total Cloud Cover",
  "Couvert nuageux total",
  "TCDC"
); 

solarchvision_LAYER LAYER_winddir = new solarchvision_LAYER(
  100.0 / 360.0,
  0,
  0,
  "°",
  "Surface Wind Direction",
  "Direction du vent à la surface",
  "WDIR-SFC"
); 

solarchvision_LAYER LAYER_windspd = new solarchvision_LAYER(
  2.0,
  0,
  0,
  "km/h",
  "Surface Wind Speed",
  "Vitesse du vent à la surface",
  "WIND-SFC"
); 

solarchvision_LAYER LAYER_pressure = new solarchvision_LAYER(
  2.0,
  -1000,
  1,
  "hPa",
  "Mean Sea level Pressure",
  "Pression moyenne au niveau de la mer",
  "MSLP"
); 

solarchvision_LAYER LAYER_drybulb = new solarchvision_LAYER(
  2.5 * pow(2, 0.5),
  0,
  1,
  "°C",
  "Surface Air Temperature",
  "Température de l'air à la surface",
  "TMP-SFC"
); 

solarchvision_LAYER LAYER_relhum = new solarchvision_LAYER(
  1.0,
  0,
  0,
  "%",
  "Surface Relative Humidity",
  "Humidité relative à la surface",
  "RELH-SFC"
); 

solarchvision_LAYER LAYER_dirnorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Direct normal radiation",
  "Rayonnement direct normal",
  ""
);

solarchvision_LAYER LAYER_difhorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Diffuse horizontal radiation",
  "Diffus rayonnement horizontal",
  ""
); 

solarchvision_LAYER LAYER_glohorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Global horizontal radiation",
  "Rayonnement global horizontal",
  ""
); 

solarchvision_LAYER LAYER_direffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Direct normal effect <18°C<",
  "Effet direct normal <18°C<",
  ""
); 

solarchvision_LAYER LAYER_difeffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Diffuse normal effect <18°C<",
  "Effet diffus normal <18°C<",
  ""
); 

solarchvision_LAYER LAYER_precipitation = new solarchvision_LAYER(
  4.0,
  0,
  0,
  "mm",
  "Surface Accumulated Precipitation",
  "Précipitations accumulées à la surface",
  "APCP-SFC"
); 

solarchvision_LAYER LAYER_developed = new solarchvision_LAYER(
  1,
  0,
  0,
  "",
  "",
  "",
  ""
); 




solarchvision_LAYER[] allLayers = { 
  LAYER_windspd200hPa,
  LAYER_thicknesses_1000_500,
  LAYER_heightp500hPa,
  LAYER_ceilingsky,
  LAYER_cloudcover,
  LAYER_winddir,
  LAYER_windspd,
  LAYER_pressure,
  LAYER_drybulb,
  LAYER_relhum,
  LAYER_dirnorrad,
  LAYER_difhorrad,
  LAYER_glohorrad,
  LAYER_direffect,
  LAYER_difeffect,
  LAYER_precipitation,
  LAYER_developed
};


int DevelopLayer_id = 0;
int CurrentLayer_id = 0;
String CurrentLayer_unit = allLayers[0].unit;
String CurrentLayer_name = allLayers[0].name;
String[] CurrentLayer_descriptions = {allLayers[0].descriptions[Language_EN], 
                                      allLayers[0].descriptions[Language_FR]};

void changeCurrentLayerTo (int new_id) {
 
  int pre_id = CurrentLayer_id;

  allLayers[pre_id].V_scale = STUDY.V_scale;
  allLayers[pre_id].V_offset = STUDY.V_offset;
  allLayers[pre_id].V_belowLine = STUDY.V_belowLine;
  
  STUDY.V_scale = allLayers[new_id].V_scale;
  STUDY.V_offset = allLayers[new_id].V_offset;
  STUDY.V_belowLine = allLayers[new_id].V_belowLine;

  DevelopLayer_id = new_id;
  CurrentLayer_id = new_id;
  
  CurrentLayer_unit = allLayers[new_id].unit; 
  CurrentLayer_name = allLayers[new_id].name;
  CurrentLayer_descriptions[Language_EN] = allLayers[new_id].descriptions[Language_EN];
  CurrentLayer_descriptions[Language_FR] = allLayers[new_id].descriptions[Language_FR];
  
}


















int ENSEMBLE_FORECAST_maxDays = 16; // Constant
int ENSEMBLE_OBSERVED_maxDays = 3; // Variable


int CLIMATE_TMYEPW_start = 1; 
int CLIMATE_TMYEPW_end = 1;

int CLIMATE_CWEEDS_start = 1953;
int CLIMATE_CWEEDS_end = 2005;

int CLIMATE_CLMREC_start = 2000;
int CLIMATE_CLMREC_end = 2017;

int ENSEMBLE_FORECAST_start = 1; 
int ENSEMBLE_FORECAST_end = 43; // NAEFS:1-43, Note we will append REPS/HRDPS or other scenarions at the end  of this list

int ENSEMBLE_OBSERVED_numNearest = 3;  // <<<<<<<<

int ENSEMBLE_OBSERVED_start = 1; 
int ENSEMBLE_OBSERVED_end = ENSEMBLE_OBSERVED_numNearest;

int[] nearest_Station_ENSEMBLE_OBSERVED_id = new int [ENSEMBLE_OBSERVED_numNearest];
float[] nearest_Station_ENSEMBLE_OBSERVED_dist = new float [ENSEMBLE_OBSERVED_numNearest];

int nearest_Station_CLMREC_id = -1;
float nearest_Station_CLMREC_dist = FLOAT_undefined;



int SampleYear_Start = 1980; 
int SampleYear_End = year(); 

int SampleMember_Start = 1;
int SampleMember_End = 43;

int SampleStation_Start = 1; 
int SampleStation_End = ENSEMBLE_OBSERVED_numNearest;

float[][][][] CLIMATE_TMYEPW_values;
boolean[][][][] CLIMATE_TMYEPW_flags;

float[][][][] CLIMATE_CWEEDS_values;
boolean[][][][] CLIMATE_CWEEDS_flags;

float[][][][] CLIMATE_CLMREC_values;
boolean[][][][] CLIMATE_CLMREC_flags;

float[][][][] ENSEMBLE_FORECAST_values;
boolean[][][][] ENSEMBLE_FORECAST_flags;

float[][][][] ENSEMBLE_OBSERVED_values;
boolean[][][][] ENSEMBLE_OBSERVED_flags;




boolean CLIMATE_TMYEPW_load = true;
boolean CLIMATE_CWEEDS_load = false;
boolean CLIMATE_CLMREC_load = false;
boolean ENSEMBLE_FORECAST_load = false;
boolean ENSEMBLE_OBSERVED_load = false;


int GRIB2_Year; 
int GRIB2_Month; 
int GRIB2_Day; 
int GRIB2_ModelRun;

int AERIAL_num = 4 * (1 + 6 + 12); // the number of nearest points on the path we want to extract the data 

float AERIAL_Center_Longitude = FLOAT_undefined;
float AERIAL_Center_Latitude = FLOAT_undefined;

float[][] AERIAL_Locations;

float[][][][] AERIAL_Data;
int[][][][] AERIAL_Flags;

int GRIB2_Hour_Start = 0;
int GRIB2_Hour_End = 30; //48;
int GRIB2_Hour_Step = 1; //1;

int GRIB2_Layer_Start = 4; //_cloudcover;
int GRIB2_Layer_End = 8; //_drybulb;
int GRIB2_Layer_Step = 1;

int GRIB2_Hour;
int GRIB2_Layer;




String[][] GRIB2_Domains = {
  {
    "GEPS", "ensemble/naefs/grib2/raw", "CMC_naefs-geps-raw", "latlon1p0x1p0", "_allmbrs.grib2", "100"
  }
  , {
    "REPS", "ensemble/reps/15km/grib2/raw", "CMC-reps-srpe-raw", "ps15km", "_allmbrs.grib2", "15"
  }
  , {
    "GDPS", "model_gem_global/25km/grib2/lat_lon", "CMC_glb", "latlon.24x.24", ".grib2", "20"
  }
  , {
    "RDPS", "model_gem_regional/10km/grib2", "CMC_reg", "ps10km", ".grib2", "10"
  }
  , {
    "HRDPS", "model_hrdps/east/grib2", "CMC_hrdps_east", "ps2.5km", "-00.grib2", "2.5"
  } 
  , {
    "RDWPS", "model_wave/great_lakes/superior/grib2", "CMC_rdwps_lake-superior", "latlon0.05x0.08", ".grib2", "5"
  }
};


//int GRIB2_DomainSelection = 0; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!   
//int GRIB2_DomainSelection = 1; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!
//int GRIB2_DomainSelection = 2; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 3; int GRIB2_maxScenarios = 1;
int GRIB2_DomainSelection = 4; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 5; int GRIB2_maxScenarios = 1; // not working now!

{
  ENSEMBLE_FORECAST_end += GRIB2_maxScenarios;
}


int AERIAL_graphOption = 0; 




final int DEV_OP_00 = 8;
final int DEV_OP_01 = 6;
final int DEV_OP_02 = 5;
final int DEV_OP_03 = 7;
final int DEV_OP_04 = 4;
final int DEV_OP_05 = 3;
final int DEV_OP_06 = 10;
final int DEV_OP_07 = 9;
final int DEV_OP_08 = 11;
final int DEV_OP_09 = 0;
final int DEV_OP_10 = 1;
final int DEV_OP_11 = 2;

int Develop_Option = DEV_OP_06; //between 0 - 11...
int Develop_DayHour = 0; //0:accumulative 1:daily(24h) 2:per12h 3:per6h <should be zero to work well with current menues> 

boolean DevelopData_update = true;












float Develop_AngleInclination = 45; // 90 = horizontal surface, 0 = Vertical surface 
float Develop_AngleOrientation = 0; // 0 = South, 90 = East



























class solarchvision_STATION {

  private final static String CLASS_STAMP = "STATION";
  
  private float elevation = 0;
  private float latitude = 0;
  private float longitude = 0;
  private float timelong = 0;
  private String code = "";  
  private String city = "";
  private String province = "";
  private String country = "";
  private String filename_NAEFS = "";
  private String filename_CWEEDS = "";
  private String filename_TMYEPW = "";


  public float getElevation () { return this.elevation; } 
  public float getLatitude () { return this.latitude; }
  public float getLongitude () { return this.longitude; } 
  public float getTimelong () { return this.timelong; }
  public String getCode () { return this.code; }  
  public String getCity () { return this.city; } 
  public String getProvince () { return this.province; } 
  public String getCountry () { return this.country; }
  public String getFilename_NAEFS () { return this.filename_NAEFS; }
  public String getFilename_CWEEDS () { return this.filename_CWEEDS; }
  public String getFilename_TMYEPW () { return this.filename_TMYEPW; } 

  
  public void setElevation (float elevation) {
    this.elevation = elevation;
  }
  public void setLatitude (float latitude) {
    this.latitude = latitude;
  }
  public void setLongitude (float longitude) {
    this.longitude = longitude;
  }
  public void setTimelong (float timelong) {
    this.timelong = timelong;
  }
  public void setCode (String code) {
    this.code = code;
  }  
  public void setCity (String city) {
    this.city = city;
  }
  public void setProvince (String province) {
    this.province = province;
  }
  public void setCountry (String country) {
    this.country = country;
  }
  public void setFilename_NAEFS (String filename_NAEFS) {
    this.filename_NAEFS = filename_NAEFS;
  }
  public void setFilename_CWEEDS (String filename_CWEEDS) {
    this.filename_CWEEDS = filename_CWEEDS;
  }
  public void setFilename_TMYEPW (String filename_TMYEPW) {
    this.filename_TMYEPW = filename_TMYEPW;
  }  

  public solarchvision_STATION () {
    
  }  
  
  public solarchvision_STATION (String code, String city, String province, String Country, 
                         float latitude, float longitude, float timelong, float elevation, 
                         String filename_NAEFS, String filename_CWEEDS, String filename_TMYEPW) {
  
    this.code = code;
    this.city = city;
    this.province = province;
    this.country = country;
    
    this.filename_NAEFS = filename_NAEFS;
    this.filename_CWEEDS = filename_CWEEDS;
    this.filename_TMYEPW = filename_TMYEPW;
    
    this.elevation = elevation;
    this.latitude = latitude;
    this.longitude = longitude;
    this.timelong = timelong;
  }
  
  
  public void to_XML (XML xml) {
    
    XML child = xml.addChild(this.CLASS_STAMP);
    
    child.setString("code", this.getCode());
    child.setString("city", this.getCity());
    child.setString("province", this.getProvince());
    child.setString("country", this.getCountry());

    child.setFloat("elevation", this.getElevation());
    child.setFloat("latitude", this.getLatitude());
    child.setFloat("longitude", this.getLongitude());
    child.setFloat("timelong", this.getTimelong());
    
    child.setString("filename_NAEFS", this.getFilename_NAEFS());
    child.setString("filename_CWEEDS", this.getFilename_CWEEDS());
    child.setString("filename_TMYEPW", this.getFilename_TMYEPW());
  }
  
  
  public void from_XML (XML xml) {
    
    XML child = xml.getChild(this.CLASS_STAMP);
    
    this.setCode(child.getString("code"));
    this.setCity(child.getString("city"));
    this.setProvince(child.getString("province"));
    this.setCountry(child.getString("country"));

    this.setElevation(child.getFloat("elevation"));
    this.setLatitude(child.getFloat("latitude"));
    this.setLongitude(child.getFloat("longitude"));
    this.setTimelong(child.getFloat("timelong"));
    
    this.setFilename_NAEFS(child.getString("filename_NAEFS"));
    this.setFilename_CWEEDS(child.getString("filename_CWEEDS"));
    this.setFilename_TMYEPW(child.getString("filename_TMYEPW"));    
  }  
}

solarchvision_STATION STATION = new solarchvision_STATION(

  "", "Roodbar", "XX", "IR", 36.826, 49.426, 52.5, 194, "", "", "IRN_Rasht_YY_IR"
  
);
  









solarchvision_STATION[] TMYEPW_Coordinates;

void inputCoordinates_TMYEPW () {

  String[] FileALL = loadStrings(CoordinateFolder + "/EPW_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  TMYEPW_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, ',');
    
    TMYEPW_Coordinates[f] = new solarchvision_STATION(); 

    TMYEPW_Coordinates[f].setCity(parts[1]);
    TMYEPW_Coordinates[f].setProvince(parts[2]);
    TMYEPW_Coordinates[f].setCountry(parts[3]);
    TMYEPW_Coordinates[f].setLatitude(float(parts[6]));
    TMYEPW_Coordinates[f].setLongitude(float(parts[7]));
    TMYEPW_Coordinates[f].setTimelong(float(parts[8]) * 15);
    TMYEPW_Coordinates[f].setElevation(float(parts[9]));
    TMYEPW_Coordinates[f].setFilename_TMYEPW(parts[10]);
  }
}


  
  
solarchvision_STATION[] CWEEDS_Coordinates;

void inputCoordinates_CWEEDS () {

  String[] FileALL = loadStrings(CoordinateFolder + "/CWEEDS_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  CWEEDS_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '_');

    float latitude = float(parts[2]) * 0.01;
    float longitude = float(parts[3]) * -0.01;
    
    CWEEDS_Coordinates[f] = new solarchvision_STATION(); 

    CWEEDS_Coordinates[f].setCity(parts[1]);
    CWEEDS_Coordinates[f].setProvince(parts[0]);
    CWEEDS_Coordinates[f].setCountry("CA");
    CWEEDS_Coordinates[f].setLatitude(latitude);
    CWEEDS_Coordinates[f].setLongitude(longitude);
    CWEEDS_Coordinates[f].setTimelong(roundTo(longitude, 15));
    CWEEDS_Coordinates[f].setElevation(0); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ??
    CWEEDS_Coordinates[f].setFilename_CWEEDS(lineSTR);
  }
}






solarchvision_STATION[] CLMREC_Coordinates;

void inputCoordinates_CLMREC () {

  String[] FileALL = loadStrings(CoordinateFolder + "/CLMREC_UTF8_EN.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  CLMREC_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, ',');
    
    CLMREC_Coordinates[f] = new solarchvision_STATION(); 

    float latitude = float(parts[6]);
    float longitude = float(parts[7]);

    CLMREC_Coordinates[f].setCity(parts[0].replace('/', '_'));
    CLMREC_Coordinates[f].setProvince(parts[1]);
    CLMREC_Coordinates[f].setCountry("CA");
    CLMREC_Coordinates[f].setLatitude(latitude);
    CLMREC_Coordinates[f].setLongitude(longitude);
    CLMREC_Coordinates[f].setTimelong(roundTo(longitude, 15));
    CLMREC_Coordinates[f].setElevation(float(parts[10]));
    //CLMREC_Coordinates[f].setFilename_CLMREC(?);
  }
}




solarchvision_STATION[] SWOB_Coordinates;

void inputCoordinates_SWOB () {

  String[] FileALL = loadStrings(CoordinateFolder + "/SWOB_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  SWOB_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '\t');
    
    float latitude = float(parts[5]);
    float longitude = float(parts[6]);    
    
    SWOB_Coordinates[f] = new solarchvision_STATION(); 

    String code = parts[8];
    if (parts[4].equals("Manned")) code += "-MAN";
    if (parts[4].equals("Auto")) code += "-AUTO";

    SWOB_Coordinates[f].setCode(code);
    SWOB_Coordinates[f].setCity(parts[2]);
    SWOB_Coordinates[f].setProvince(parts[3]);
    SWOB_Coordinates[f].setCountry("CA");
    SWOB_Coordinates[f].setLatitude(latitude);
    SWOB_Coordinates[f].setLongitude(longitude);
    SWOB_Coordinates[f].setTimelong(roundTo(longitude, 15));
    SWOB_Coordinates[f].setElevation(float(parts[7]));
    //SWOB_Coordinates[f].setFilename_SWOB(?);
    
  }
}








solarchvision_STATION[] NAEFS_Coordinates;

void inputCoordinates_NAEFS () {

  String[] FileALL = loadStrings(CoordinateFolder + "/NAEFS_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  NAEFS_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '\t');

    String filename = parts[0];

    String city = split(filename, '_')[0];
    String province = split(filename, '_')[1];
    String country = split(filename, '_')[2];

    float latitude = 0;
    float longitude = 0;
    float elevation = 0;

    int l = 0;

    l = parts[1].length();
    if (((parts[1].substring(l - 1, l)).equals("N")) || ((parts[1].substring(l - 1, l)).equals("S"))) {
      String[] the_parts = split(parts[1], ':');
      latitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[1].substring(l - 1, l)).equals("S")) latitude *= -1;
    } else {
      latitude = float(parts[1]);
    }

    l = parts[2].length();
    if (((parts[2].substring(l - 1, l)).equals("E")) || ((parts[2].substring(l - 1, l)).equals("W"))) {
      String[] the_parts = split(parts[2], ':');
      longitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[2].substring(l - 1, l)).equals("W")) longitude *= -1;
    } else {
      longitude = float(parts[2]);
    }

    l = parts[3].length();
    elevation = float(parts[3].substring(0, l - 1));
    
    
    NAEFS_Coordinates[f] = new solarchvision_STATION(); 

    NAEFS_Coordinates[f].setCity(city);
    NAEFS_Coordinates[f].setProvince(province);
    NAEFS_Coordinates[f].setCountry(country);
    NAEFS_Coordinates[f].setLatitude(latitude);
    NAEFS_Coordinates[f].setLongitude(longitude);
    NAEFS_Coordinates[f].setTimelong(roundTo(longitude, 15));
    NAEFS_Coordinates[f].setElevation(elevation);
    NAEFS_Coordinates[f].setFilename_NAEFS(filename);
  }
}



void download_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  boolean new_files_downloaded = false;
  
  for (int f = 0; f < numberOfLayers; f++) {
    if (allLayers[f].name.equals("")) {
    } else {
      String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";
      
      String the_target = ENSEMBLE_FORECAST_directory + "/" + FN;
      
      File dir = new File(the_target);
      if (!dir.isFile()) {
        
        String the_directory = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + nf(THE_HOUR, 2) + "/" + allLayers[f].name + "/raw";
        String the_link = "http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/xml/" + the_directory + "/" + FN + ".bz2";
        the_target = the_target + ".bz2";
    
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
    
          new_files_downloaded = true;
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }
  }



  if (new_files_downloaded) {
    
    String folder_inout = ENSEMBLE_FORECAST_directory.replace('/', char(92));
    
    {
      String Command1 = "cmd /c \"\"C:\\Program Files (x86)\\7-Zip\\7z.exe\"\" e " + folder_inout + "\\*.bz2 -o" + folder_inout + " -y";
      println(Command1);
      String Command2 = "del " + folder_inout + "\\*.bz2 /q";
      println(Command2);
      launch(Command1 + " & " + Command2);
    }
    
    ENSEMBLE_FORECAST_Files = SOLARCHVISION_getfiles(ENSEMBLE_FORECAST_directory);  
    
    ENSEMBLE_FORECAST_load = true;
    update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);    
  }
}


void update_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  ENSEMBLE_FORECAST_Files = SOLARCHVISION_getfiles(ENSEMBLE_FORECAST_directory); // slow <<<<<<<<<<<< this line didn't work well below... but it is rather slow here! 

  ENSEMBLE_FORECAST_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)];
  ENSEMBLE_FORECAST_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
          ENSEMBLE_FORECAST_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_FORECAST_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_FORECAST_load) {

    for (int f = 0; f < numberOfLayers; f++) {
      if (allLayers[f].name.equals("")) {
      } else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";

        String the_source = ENSEMBLE_FORECAST_directory + "/" + FN;

        File dir = new File(the_source);
        if (dir.isFile()) load_ENSEMBLE_FORECAST(the_source, f);
        else println("FILE NOT FOUND:", the_source);
      }
    }

    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);
    
    Display_NAEFS_Points = 1;
    Display_NAEFS_Nearest = true;     
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;    
  
  SampleMember_Start = ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;
}







void load_ENSEMBLE_FORECAST (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  int continue_process = 1;

  XML FileALL = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileALL = loadXML(FileName);
  }
  catch (Exception e) {
    println("Can't read:", FileName);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    //println(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

    XML[] children0 = FileALL.getChildren("forecast");

    for (int Li = 0; Li < children0.length; Li++) {

      int _a1 = children0[Li].getInt("forecast_hour");
      String _a2 = children0[Li].getString("valid_time");

      //println("Li=", Li, "hour =", _a1, "date:", _a2);

      if (Li >= 0) {

        int THE_YEAR = int(_a2.substring(0, 4));
        int THE_MONTH = int(_a2.substring(4, 6));
        int THE_DAY = int(_a2.substring(6, 8));
        int THE_HOUR = int(_a2.substring(8));

        //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

        int now_i = int(THE_HOUR);
        int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

        //println(now_i, now_j);

        now_i -= int(-STATION.getTimelong() / 15);
        if (now_i < 0) {
          now_i += 24;
          now_j -= 1;
          if (now_j < 0) {
            now_j += 365;
          }
        }

        //println(now_i, now_j);
        //println("-------------");

        XML[] _c = children0[Li].getChildren("model");
        //println("number of members:", _c.length);

        for (int Lk = 0; Lk < _c.length; Lk++) {
          int k = _c[Lk].getInt("id") - 1;

          if (k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)) {

            ENSEMBLE_FORECAST_values[now_i][now_j][Load_Layer][k] = Float.valueOf(_c[Lk].getContent());
          }
        }
      }
    }
  }
}




void update_CLIMATE_CWEEDS () {

  CLIMATE_CWEEDS_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)];
  CLIMATE_CWEEDS_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k++) {
          CLIMATE_CWEEDS_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CWEEDS_flags[i][j][l][k] = false;
        }
      }
    }
  }


  if (CLIMATE_CWEEDS_load) {

    String FN = STATION.getFilename_CWEEDS() + ".wy2";
    
    String the_source = CLIMATE_CWEEDS_directory + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_CWEEDS(the_source);
    else println("FILE NOT FOUND:", the_source);

  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;   
  
  SampleYear_Start = CLIMATE_CWEEDS_start;
  SampleYear_End = CLIMATE_CWEEDS_end;     
}


void load_CLIMATE_CWEEDS (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    int CLIMATE_YEAR = int(lineSTR.substring(6, 10));
    int CLIMATE_MONTH = int(lineSTR.substring(10, 12));
    int CLIMATE_DAY = int(lineSTR.substring(12, 14));
    int CLIMATE_HOUR = int(lineSTR.substring(14, 16));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CWEEDS_start);

    //println(i);

    CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = float(lineSTR.substring(85, 90)); // 10 times in Pa
    CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = float(lineSTR.substring(91, 95)); // 10 times in °C
    //CLIMATE_CWEEDS_values[i][j][LAYER_relhum.id][k] = 50; // Relative Humidity is not presented in DCLIMATE files!
    CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = float(lineSTR.substring(20, 24)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = float(lineSTR.substring(26, 30)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = float(lineSTR.substring(32, 36)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = float(lineSTR.substring(105, 109)); // 10 times in m/s
    CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = float(lineSTR.substring(101, 104)); // °
    CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = float(lineSTR.substring(113, 115)); // 0.1 times in %
    CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = float(lineSTR.substring(61, 65)); // 0.1 times in m

    if (CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] == 99999) CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = 0.1 * 3.6 * CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 7777) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000; // <<<<<<<<<

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 10 * CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k];
  }
  
  SOLARCHVISION_setDataFlags(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_CWEEDS);
  
  Display_CWEEDS_Points = 1;
  Display_CWEEDS_Nearest = true;  

}







void download_CLIMATE_CLMREC () {
  
  if (nearest_Station_CLMREC_id != -1) {

    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {
      
        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;
    
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";
          
        String the_target = CLIMATE_CLMREC_directory + "/" + FN;
          
        File dir = new File(the_target);
        if (!dir.isFile()) {          
          
          String the_link = "http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&stationID=" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCode() + "&Year=" + nf(THE_YEAR, 4) + "&Month=" + nf(THE_MONTH, 2) + "&timeframe=1";
          
          println("Try downloading: " + the_link);
    
          try {
            saveBytes(the_target, loadBytes(the_link));
          } 
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }
    
    CLIMATE_CLMREC_Files = SOLARCHVISION_getfiles(CLIMATE_CLMREC_directory);
    
    CLIMATE_CLMREC_load = true;
    update_CLIMATE_CLMREC();
  }
}


void update_CLIMATE_CLMREC () {

  CLIMATE_CLMREC_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)];
  CLIMATE_CLMREC_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
          CLIMATE_CLMREC_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CLMREC_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_CLMREC_load) {

    nearest_Station_CLMREC_id = -1;
    nearest_Station_CLMREC_dist = FLOAT_undefined;
    
    for (int f = 0; f < CLMREC_Coordinates.length; f++) {
      
      //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016) 
      { // only use stations with this condition

        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_Station_CLMREC_dist > d) {
  
          nearest_Station_CLMREC_dist = d;
          nearest_Station_CLMREC_id = f;
        }
      }
    }


    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {
      
        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;
    
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";
        
        String the_source = CLIMATE_CLMREC_directory + "/" + FN;
        
        File dir = new File(the_source);
        if (dir.isFile()) load_CLIMATE_CLMREC(the_source);
        else println("FILE NOT FOUND:", the_source);

      }
    }

    SOLARCHVISION_setDataFlags(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_fillGaps(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CLMREC);
    
    Display_CLMREC_Points = 1;
    Display_CLMREC_Nearest = true;       
  
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true; 

  SampleYear_Start = CLIMATE_CLMREC_start;
  SampleYear_End = CLIMATE_CLMREC_end;  
}


void load_CLIMATE_CLMREC (String FileName) {

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  println("lines = ", FileALL.length);

  for (int f = 18; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);
    
    lineSTR = lineSTR.replace("\"", ""); 
    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[1]);
    int CLIMATE_MONTH = int(parts[2]);
    int CLIMATE_DAY = int(parts[3]);
    int CLIMATE_HOUR = int(parts[4].substring(0, 2));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR);
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CLMREC_start);

    //println(i);
    
    if (parts.length > 24) {
      
      String str = "";
      
      str = parts[24];
      
      //println(str);
       
      if (str.equals("NA")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;
      else if (str.equals("Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 0;
      else if (str.equals("Mainly Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 2.5;
      else if (str.equals("Mostly Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 5;
      else if (str.equals("Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 7.5;
      else CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 10;
      
      //println(CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k]);
    
      str = parts[6];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_drybulb.id][k] = float(str); // °C

      str = parts[10];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_relhum.id][k] = float(str); // %

      str = parts[12];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_winddir.id][k] = float(str) * 10; // °

      str = parts[14];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_windspd.id][k] = float(str); // km/h

      str = parts[18];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_pressure.id][k] = float(str) * 10; // hPa


    }
  }
  
}









void update_CLIMATE_TMYEPW () {

  CLIMATE_TMYEPW_values = new float [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)];
  CLIMATE_TMYEPW_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k++) {
          CLIMATE_TMYEPW_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_TMYEPW_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_TMYEPW_load) {

    String FN = STATION.getFilename_TMYEPW() + ".epw";

    String the_source = CLIMATE_TMYEPW_directory + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_TMYEPW(the_source);
    else println("FILE NOT FOUND:", the_source);

    Display_TMYEPW_Points = 1;
    Display_TMYEPW_Nearest = true; 

  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;    

}




void load_CLIMATE_TMYEPW (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  //println("lines = ", FileALL.length);

  for (int f = 8; f < FileALL.length; f++) {

    lineSTR = FileALL[f];

    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[0]);
    int CLIMATE_MONTH = int(parts[1]);
    int CLIMATE_DAY = int(parts[2]);
    int CLIMATE_HOUR = int(parts[3]);

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = 0; // on TMYEPW:TMY files we have only one year 

    //println(i);

    CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = float(parts[9]) * 0.01; // 10 times in Pa
    CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = float(parts[6]); // in °C
    CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = float(parts[8]); // 0 - 110%
    CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = float(parts[13]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = float(parts[14]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = float(parts[15]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = float(parts[21]); // in m/s
    CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = float(parts[20]); // ° 
    CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = float(parts[23]); // 0.1 times in % ... there is also total_sky_cover on[22]
    CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = float(parts[25]); // in m


    if (CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] == 999999) CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] == 99.9) CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = 3.6 * CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 77777) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 88888) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000; 

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 99999) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
  }
  
  SOLARCHVISION_setDataFlags(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_TMYEPW);
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;  
  
}



void download_ENSEMBLE_OBSERVED () {
  
  // this line tries to update the most recent files! << 
  int THE_YEAR = year(); 
  int THE_MONTH = month();
  int THE_DAY = day();
  int THE_HOUR = hour(); 


  float THE_DATE = TIME_Date;

  int now_i = int(THE_HOUR);
  int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

  now_i += int(-STATION.getTimelong() / 15);
  if (now_i > 23) {
    now_i -= 24;
    now_j += 1;
    if (now_j > 364) {
      now_j -= 365;
      THE_YEAR += 1;
    }
    THE_DATE += 1;
    if (THE_DATE > 364) THE_DATE -= 365;
  }         
  THE_HOUR = now_i;

  for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

    THE_MONTH = CalendarDate[int(THE_DATE)][0]; 
    THE_DAY = CalendarDate[int(THE_DATE)][1];

    for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

      int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

      if (f != -1) {

        String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

        String the_target = ENSEMBLE_OBSERVED_directory + "/" + FN;

        File dir = new File(the_target);
        if (!dir.isFile()) {       

          String the_link = "http://dd.weatheroffice.gc.ca/observations/swob-ml/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + split(SWOB_Coordinates[f].getCode(),'-')[0] + "/" + FN;
  
          println("Try downloading: " + the_link);
  
          try {
            saveBytes(the_target, loadBytes(the_link));
          } 
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }

    now_i -= 1;
    if (now_i < 0) {
      now_i += 24;
      now_j -= 1;
      if (now_j < 0) {
        now_j += 365;
        THE_YEAR -= 1;
      }
      THE_DATE -= 1;
      if (THE_DATE < 0) THE_DATE += 364;
    }
    THE_HOUR = now_i;
  }
  

  ENSEMBLE_OBSERVED_Files = SOLARCHVISION_getfiles(ENSEMBLE_OBSERVED_directory);
  
  ENSEMBLE_OBSERVED_load = true; 
  SOLARCHVISION_update_ENSEMBLE_OBSERVED();
}

void SOLARCHVISION_update_ENSEMBLE_OBSERVED () {

  ENSEMBLE_OBSERVED_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)];
  ENSEMBLE_OBSERVED_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start); k++) {
          ENSEMBLE_OBSERVED_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_OBSERVED_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_OBSERVED_load) {

    // this line tries to update the most recent files! << 
    int THE_YEAR = year(); 
    int THE_MONTH = month();
    int THE_DAY = day();
    int THE_HOUR = hour(); 


    float THE_DATE = TIME_Date;

    int now_i = int(THE_HOUR);
    int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

    now_i += int(-STATION.getTimelong() / 15);
    if (now_i > 23) {
      now_i -= 24;
      now_j += 1;
      if (now_j > 364) {
        now_j -= 365;
        THE_YEAR += 1;
      }
      THE_DATE += 1;
      if (THE_DATE > 364) THE_DATE -= 365;
    }         
    THE_HOUR = now_i;

    for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

      THE_MONTH = CalendarDate[int(THE_DATE)][0]; 
      THE_DAY = CalendarDate[int(THE_DATE)][1];

      for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

        int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

        if (f != -1) {

          String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

          String the_source = ENSEMBLE_OBSERVED_directory + "/" + FN;
      
          File dir = new File(the_source);
          if (dir.isFile()) load_ENSEMBLE_OBSERVED(the_source, q);
          else println("FILE NOT FOUND:", the_source);

        }
      }

      now_i -= 1;
      if (now_i < 0) {
        now_i += 24;
        now_j -= 1;
        if (now_j < 0) {
          now_j += 365;
          THE_YEAR -= 1;
        }
        THE_DATE -= 1;
        if (THE_DATE < 0) THE_DATE += 364;
      }
      THE_HOUR = now_i;
    }
    
    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_OBSERVED); // <<<<<<<<<<<<
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_OBSERVED);
    
    Display_SWOB_Points = 1;
    Display_SWOB_Nearest = true;   
  }

  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;      
  
  SampleStation_Start = ENSEMBLE_OBSERVED_start;
  SampleStation_End = ENSEMBLE_OBSERVED_end;
}


void load_ENSEMBLE_OBSERVED (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  XML FileALL = loadXML(FileName);

  XML[] children0 = FileALL.getChildren("om:member");
  XML[] children1 = children0[0].getChildren("om:Observation");
  XML[] children2 = children1[0].getChildren("om:samplingTime");
  XML[] children3 = children2[0].getChildren("gml:TimeInstant");
  XML[] children4 = children3[0].getChildren("gml:timePosition");
  String _TimeInstant = String.valueOf(children4[0].getContent());
  //println(_TimeInstant);

  int THE_YEAR = int(_TimeInstant.substring(0, 4));
  int THE_MONTH = int(_TimeInstant.substring(5, 7));
  int THE_DAY = int(_TimeInstant.substring(8, 10));
  int THE_HOUR = int(_TimeInstant.substring(11, 13));

  //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

  int now_i = int(THE_HOUR);
  int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

  //println(now_i, now_j);

  now_i -= int(-STATION.getTimelong() / 15);

  if (now_i < 0) {
    now_i += 24;
    now_j -= 1;
    if (now_j < 0) {
      now_j += 365;
    }
  }

  //println(now_i, now_j);
  //println("-------------");

  children2 = children1[0].getChildren("om:result");
  children3 = children2[0].getChildren("elements");
  children4 = children3[0].getChildren("element");

  for (int Li = 0; Li < children4.length; Li++) {

    String _a1 = children4[Li].getString("name");
    String _a2 = children4[Li].getString("value");
    String _a3 = children4[Li].getString("uom");

    //println("Li=", Li, _a1, _a2, _a3);

    if (_a2.toUpperCase().equals("MSNG")) { // missing values
      _a2 = String.valueOf(FLOAT_undefined);
    }

    if (_a1.equals("stn_pres")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_pressure.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("air_temp")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_drybulb.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("rel_hum")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_relhum.id][Load_Layer] = Float.valueOf(_a2);
    } 

    if (_a1.equals("tot_cld_amt")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_cloudcover.id][Load_Layer] = 0.1 * Float.valueOf(_a2);
    }    

    if (_a1.equals("avg_wnd_dir_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_winddir.id][Load_Layer] = Float.valueOf(_a2);
    }    

    if (_a1.equals("avg_wnd_spd_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_windspd.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("pcpn_amt_pst6hrs")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_precipitation.id][Load_Layer] = Float.valueOf(_a2); // past 6 hours!
    }

    if (_a1.equals("avg_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("W/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = 1000 * Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }

    if (_a1.equals("tot_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("kJ/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }
    
  }
  
}












class solarchvision_UITASK {
  
  private final static String CLASS_STAMP = "UITASK";
 
  private final static int LandOrbit_Pan_TargetRollZ = -19;
  private final static int LookAtDirection = -18;
  private final static int DistMouseXY_TargetRollXY_TargetRollZ = -17; 
  private final static int PanY_TargetRollXY_TargetRollZ = -16; 
  private final static int PanX_TargetRollXY_TargetRollZ = -15; 
  private final static int Pan_TargetRoll = -14; 
  private final static int CameraDistance_TargetRollXY_TargetRollZ = -13; 
  private final static int CameraRoll_Pan = -12; 
  private final static int CameraRollXY_CameraRollZ = -11; 
  private final static int TargetRoll_Pan = -10; 
  private final static int TargetRollXY_TargetRollZ = -9; 
  private final static int AllModelSize = -8; 
  private final static int SkydomeSize = -7; 
  private final static int Truck_Orbit = -6; 
  private final static int ModelSize_Pan_TargetRoll = -5; 
  private final static int Pan_Height = -4; 
  private final static int Zoom_Orbit_Pan = -3; 
  private final static int RectSelect = -2; 
  private final static int PickSelect = -1; 
  private final static int Create = 0; 
  private final static int Move = 1; 
  private final static int Scale = 2; 
  private final static int Rotate = 3; 
  private final static int Seed_Material = 4; 
  private final static int Tessellation = 5; 
  private final static int Layer = 6; 
  private final static int Visibility = 7; 
  private final static int Weight = 8; 
  private final static int DegreeMax = 9; 
  private final static int DegreeDif = 10; 
  private final static int DegreeMin = 11; 
  private final static int TrunkSize = 12; 
  private final static int LeafSize = 13; 
  private final static int AllallModel1DsProps = 14; 
  private final static int Pivot = 15; 
  private final static int Normal = 16; 
  private final static int FirstVertex = 17; 
  private final static int Drop = 18; 
  private final static int GetLength = 19; 
  private final static int PowerX = 20; 
  private final static int PowerY = 21; 
  private final static int PowerZ = 22; 
  private final static int PowerAll = 23;  
  
}

solarchvision_UITASK UITASK = new solarchvision_UITASK();




class solarchvision_CREATE {
  
  private final static String CLASS_STAMP = "CREATE";

  private final static int Nothing    = 0;
  private final static int Plane      = 1;
  private final static int Poly       = 2;
  private final static int Extrude    = 3;
  private final static int Tri        = 4;
  private final static int Hyper      = 5;
  private final static int House1     = 6; 
  private final static int House2     = 7;
  private final static int SuperOBJ   = 8;
  private final static int Parametric = 9;
  private final static int Person     = 10;
  private final static int Plant      = 11;
  private final static int allModel1Ds    = 12;
  private final static int Face       = 13;
  private final static int Vertex     = 14;
  private final static int Curve      = 15;
  private final static int Solid      = 16;
  private final static int Section    = 17;
  private final static int Camera     = 18;
  
}

solarchvision_CREATE CREATE = new solarchvision_CREATE();




class solarchvision_OBJECTTYPE {
  
  private final static String CLASS_STAMP = "OBJECTTYPE";
  
  private final static int LANDPOINT = 0; 
  private final static int MODEL1D = 1; 
  private final static int MODEL2D = 2; 
  private final static int GROUP = 3;
  private final static int FACE = 4; 
  private final static int VERTEX = 5;
  private final static int SOFTVERTEX = 6;
  private final static int SOLID = 7;
  private final static int SECTION = 8;
  private final static int CAMERA = 9;
  private final static int CURVE = 10;
  
}

solarchvision_OBJECTTYPE ObjectCategory = new solarchvision_OBJECTTYPE(); 


class solarchvision_WINDOWTYPE {
  
  private final static String CLASS_STAMP = "WINDOWTYPE";
  
  private final static int SKY2D    = -2;
  private final static int LandGap  = -1;
  private final static int LandMesh = 0;
  private final static int STUDY    = 1;
  private final static int WORLD    = 2;
  private final static int WIN3D    = 3;
  private final static int OBJ      = 4;
  private final static int RAD      = 5;
  private final static int HTML     = 6;
  
}

solarchvision_WINDOWTYPE TypeWindow = new solarchvision_WINDOWTYPE(); 


class solarchvision_DATATYPE {
  
  private final static String CLASS_STAMP = "DATATYPE";
  
  private final static int SATELLITE_GOES = 0;
  private final static int FORECAST_HRDPS = 1;
  private final static int FORECAST_RDPS  = 2;
  private final static int FORECAST_GDPS  = 3;
  
}

solarchvision_DATATYPE DataType = new solarchvision_DATATYPE();


class solarchvision_SHADE {
  
  private final static String CLASS_STAMP = "SHADE";

  private final static int Surface_Wire = -1;
  private final static int Surface_Base = 0;
  private final static int Surface_White = 1;
  private final static int Surface_Materials = 2;
  private final static int Global_Solar = 3;
  private final static int Vertex_Solar = 4;
  private final static int Vertex_Solid = 5;
  private final static int Vertex_Elevation = 6;
  
  private final static int Options_num = 7;
  
  
  
  float[] vertexRender_Surface_White (int c) {  
  
    float[] COL = {
      c, c, c, c
    };
  
    return COL;
  }
  
  float[] vertexRender_Surface_Materials (int mt) {  
  
    float[] COL = {
      Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]
    };
  
    return COL;
  }
  
  
  float[] vertexRender_Vertex_Solar (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float _u = this.vertexU_Vertex_Solar(VERTEX_now, PAL_TYPE, PAL_DIR, PAL_Multiplier);
  
    float[] COL = {0,0,0,0}; // default color for undefined values 
  
    if (is_undefined_FLOAT(_u) == false) {   
      COL = PAINT.getColorStyle(PAL_TYPE, _u);
    }
  
    return COL;
  }
  
  
  float vertexU_Vertex_Solar (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float val = this.get_SolarImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);
  
    float _u = FLOAT_undefined;
  
    if (is_undefined_FLOAT(val) == false) { 
  
      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * val);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * val);  
    
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
    }
  
    return _u;
  }
  
  
  float get_SolarImpact_atXYZ (float x, float y, float z) {
  
    float v = FLOAT_undefined;
    
    int q = this.findID_SolarImpact_atXYZ(x, y, z);
    
    if (q >= 0) {
      v = VertexSolar_amounts[Impact_TYPE][IMPACTS_DisplayDay][q];
    }
  
    return v;
  }
  
  
  int findID_SolarImpact_atXYZ (float x, float y, float z) {
  
    int n = -1;
  
    for (int q = 0; q < VertexSolar_XYZ.length; q++) {
      
      if (x == VertexSolar_XYZ[q][0]) {
      if (y == VertexSolar_XYZ[q][1]) {
      if (z == VertexSolar_XYZ[q][2]) {
        n = q;
        break;
      }
      }
      }
    }
  
    return n;
  }
  
  
  
  
  
  float[] vertexRender_Vertex_Solid (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float _u = this.vertexU_Vertex_Solid(VERTEX_now, PAL_TYPE, PAL_DIR, PAL_Multiplier);
  
    float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);     
  
    return COL;
  }
  
  
  float vertexU_Vertex_Solid (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    SolidImpactType = 0;
    float val = SOLARCHVISION_get_SolidImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);
  
    float _u = 0.5 + 0.5 * (PAL_Multiplier * val);
  
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
  
    return _u;
  }
  
  
  float[] vertexRender_Vertex_Elevation (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float _u = this.vertexU_Vertex_Elevation(VERTEX_now, PAL_TYPE, PAL_DIR, PAL_Multiplier);
  
    float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  
  
    return COL;
  }
  
  float vertexU_Vertex_Elevation (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float _u = 0.5 + 0.5 * (PAL_Multiplier * VERTEX_now[2]);
  
    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
  
    return _u;
  }
  
  
  float[] vertexRender_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    float _u = this.vertexU_Global_Solar(VERTEX_now, VERTEX_prev, VERTEX_next, PAL_TYPE, PAL_DIR, PAL_Multiplier);
  
    float[] COL = {63,63,63,127}; // default color for undefined values 
  
    if (is_undefined_FLOAT(_u) == false) { 
      COL = PAINT.getColorStyle(PAL_TYPE, _u);
    }
  
    return COL;
  }
  
  float vertexU_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {
  
    PVector U = new PVector(VERTEX_next[0] - VERTEX_now[0], VERTEX_next[1] - VERTEX_now[1], VERTEX_next[2] - VERTEX_now[2]);
    PVector V = new PVector(VERTEX_prev[0] - VERTEX_now[0], VERTEX_prev[1] - VERTEX_now[1], VERTEX_prev[2] - VERTEX_now[2]);
    PVector UV = U.cross(V);
    float[] W = {
      UV.x, UV.y, UV.z
    };
    W = SOLARCHVISION_fn_normalize(W);
  
    float Alpha = asin_ang(W[2]);
    float Beta = atan2_ang(W[1], W[0]) + 90;       
  
    int a = int((Alpha + 90) / SOLARCHVISION_GLOBE_stp_slp);
    int b = int(Beta / SOLARCHVISION_GLOBE_stp_dir);
  
    if (a < 0) a += int(180 / SOLARCHVISION_GLOBE_stp_slp);
    if (b < 0) b += int(360 / SOLARCHVISION_GLOBE_stp_dir);
    if (a > int(180 / SOLARCHVISION_GLOBE_stp_slp)) a -= int(180 / SOLARCHVISION_GLOBE_stp_slp);
    if (b > int(360 / SOLARCHVISION_GLOBE_stp_dir)) b -= int(360 / SOLARCHVISION_GLOBE_stp_dir);
  
    float _valuesSUM = GlobalSolar[Impact_TYPE][IMPACTS_DisplayDay][a][b];
  
    float _u = FLOAT_undefined;
  
    if (is_undefined_FLOAT(_valuesSUM) == false) {
  
      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
  
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
    }
  
    return _u;
  }
  
  
  
  int get_PAL_TYPE () {
  
    int PAL_TYPE = 0; 
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR;
    }          
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_TYPE = SOLID_Pallet_CLR;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_TYPE = ELEVATION_Pallet_CLR;
    }  
  
    return PAL_TYPE;
  }
  
  
  int get_PAL_DIR () {
  
    int PAL_DIR = 1;
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
    }              
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_DIR = SOLID_Pallet_DIR;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_DIR = ELEVATION_Pallet_DIR;
    }  
  
    return PAL_DIR;
  }
  
  
  float get_PAL_Multiplier () {
  
    float PAL_Multiplier = 1; 
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
      if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
    }              
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_Multiplier = SOLID_Pallet_MLT;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_Multiplier = ELEVATION_Pallet_MLT;
    }
  
    return PAL_Multiplier;
  }

  
}  

solarchvision_SHADE SHADE = new solarchvision_SHADE();






class solarchvision_WIN3D {
  
  private final static String CLASS_STAMP = "WIN3D";
  // scales
  float scale; 
  // (top-left) corner
  int cX = 0;
  int cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
  // width and height
  int dX = int(1.5 * SOLARCHVISION_H_Pixel);
  int dY = SOLARCHVISION_H_Pixel;
  float R_View = float(dY) / float(dX);
  
  float X_Coordinate = 0;
  float Y_Coordinate = 0; //10;
  float Z_Coordinate = 0; //50; 
  float S_Coordinate = 1;
  
  float RX_Coordinate = 0; //75; 
  float RY_Coordinate = 0;
  float RZ_Coordinate = 0; //180; //0; //180; //135;
  float RS_Coordinate = 5.0;
  
  float Zoom = 60; // / (SOLARCHVISION_H_Pixel / 300.0);
  
  int ViewType = 1; // 0: Ortho 1: Perspective
  
  boolean update = true;
  boolean include = true;


  boolean record_JPG = false;
  boolean record_AUTO = false;  
  
  float ImageScale = 1.0;
  
  float CAM_x;
  float CAM_y;
  float CAM_z;
  float CAM_fov;
  float CAM_dist;
  
  float CAM_clipNear = 0.01;
  float CAM_clipFar = 2000000000.0;  
  
  float refScale = 100; // it improves displaying the shaded scene! 
  
  int CurrentCamera = 0; // 0 = Free Viewport | etc.= Saved Viewport
  
  int UI_CurrentTask = UITASK.Zoom_Orbit_Pan; 
  int UI_OptionXorY = 0; // 0-1
  int UI_TaskModifyParameter = 0; //to modify objects with several parameters e.g. allModel1Ds  


  int FacesShade = SHADE.Surface_Materials; //Shade_Surface_White; // <<<<<
  

  PGraphics graphics;
  
  

  void drawView () {
    
    if (this.update) {
  
      if (this.record_JPG) this.ImageScale = 2; //3;
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;
      //////////////////////////////////
  
      if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P3D);
      }  
  
      this.graphics.beginDraw();  
  
      this.scale = this.dY / this.refScale; // fits field of view to window's height
  
      this.graphics.background(233);
  
      this.graphics.fill(127);
      this.graphics.strokeWeight(0);
  
      this.graphics.pushMatrix();
  
      this.graphics.hint(ENABLE_DEPTH_TEST);
  
      WIN3D.record_last3DViewport();
  
      WIN3D.transform_3DViewport();
  
      WIN3D.put_3DViewport();
  
      Sky3D.draw();
  
      SOLARCHVISION_draw_SunPattern3D(0, 0, 0, 0.975 * Sky3D.scale);
  
      SOLARCHVISION_draw_SunPath3D(0, 0, 0, 0.975 * Sky3D.scale);
  
      SOLARCHVISION_draw_SolarRotation(0, 0, 0, (150000.0 * 1000000) * OBJECTS_scale);
  
      Star3D.draw();
  
      Moon3D.draw();
      
      Earth3D.draw(TypeWindow.WIN3D);
  
      Land3D.draw(TypeWindow.WIN3D);
      
      Tropo3D.draw(TypeWindow.WIN3D, STUDY.i_Start, STUDY.i_End);
  
      allModel3Ds.draw_Faces();
  
      allModel3Ds.draw_Curves();
      
      allModel3Ds.draw_Vertices();
  
      allModel1Ds.draw();
  
      SOLARCHVISION_draw_WindRoseImage();
  
      allSections.draw(TypeWindow.WIN3D);
  
      allCameras.draw();
  
      allSolids.draw();
  
      SOLARCHVISION_draw_SolidImpact_lines();
  
      SOLARCHVISION_draw_SolidImpact_points();
  
      allModel2Ds.draw(TypeWindow.WIN3D);  
  
      SOLARCHVISION_draw_WindFlow();
  
  
      this.graphics.sphereDetail(6, 4);
  
      for (int n = 0; n < AERIAL_num; n++) {
  
        if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {
  
          float _tgl = AERIAL_Locations[n][2];
          float _lat = AERIAL_Locations[n][1];
          float _lon = AERIAL_Locations[n][0]; 
          if (_lon > 180) _lon -= 360; // << important!
  
          double du = ((_lon - AERIAL_Center_Longitude) / 180.0) * (PI * DOUBLE_r_Earth);
          double dv = ((_lat - AERIAL_Center_Latitude) / 180.0) * (PI * DOUBLE_r_Earth);
  
          float x = 0.1 * (float) du * cos_ang((float) AERIAL_Center_Latitude); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
          float y = 0.1 * (float) dv;                                           // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
          float z = _tgl - HeightAboveGround;
  
          if (AERIAL_graphOption == 0) {
            //-----------------------------
            int PAL_TYPE = 6; //12; 
            int PAL_DIR = -1;
            float PAL_Multiplier = 1.0 / 30.0;
            //-----------------------------
  
            for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
              float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
  
              if (is_undefined_FLOAT(_val) == false) {
  
                float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                if (PAL_DIR == -1) _u = 1 - _u;
                if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_DIR == 2) _u =  0.5 * _u;
  
                float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);             
  
                this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
                //this.graphics.noFill();
  
                this.graphics.strokeWeight(0); // 2; <<<<<<<<<
  
                float R = 5;
                /*         
                 this.graphics.beginShape();
                 for (float teta = 0; teta < 360; teta += 360.0 / 6.0) {
                 this.graphics.vertex((x + R * cos_ang(teta)) * OBJECTS_scale * this.scale, (y + R * sin_ang(teta)) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                 }
                 this.graphics.endShape(CLOSE);
                 */
                this.graphics.pushMatrix();
                this.graphics.translate(x * OBJECTS_scale * this.scale, y * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                this.graphics.sphere(R);
                this.graphics.popMatrix();
              }
            }
          }
  
          if (AERIAL_graphOption == 1) {
  
            //-----------------------------
            int PAL_TYPE = 1;//12; 
            int PAL_DIR = 1;//-1;
            float PAL_Multiplier = 0.1;//1.0 / 30.0;
            //-----------------------------
  
            for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
              //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
              float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
              if (is_undefined_FLOAT(_val) == false) {
  
                float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
                float D_teta = 15; 
                float R = 5.0 * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
                float R_in = 0.0 * R; 
                float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta)));
                float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta)));
                float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta)));
                float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta)));                      
  
                float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta)));
                float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta)));
                float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta)));
                float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta)));          
  
                //float ox = -0.5 * (R * cos_ang(90 - teta));
                //float oy = -0.5 * (R * -sin_ang(90 - teta));
                //float ox = -1 * (R * cos_ang(90 - teta));
                //float oy = -1 * (R * -sin_ang(90 - teta));
                float ox = -2 * (R * cos_ang(90 - teta)) / 3.0;
                float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0;            
  
                float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                if (PAL_DIR == -1) _u = 1 - _u;
                if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_DIR == 2) _u =  0.5 * _u;
  
                float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);             
  
                this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                //this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
                this.graphics.noFill();
  
                this.graphics.strokeWeight(2); // 0; <<<<<<<<<
  
                this.graphics.beginShape();
                this.graphics.vertex((x + x1 + ox) * OBJECTS_scale * this.scale, (y + y1 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                this.graphics.vertex((x + x2 + ox) * OBJECTS_scale * this.scale, (y + y2 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                this.graphics.vertex((x + x3 + ox) * OBJECTS_scale * this.scale, (y + y3 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                this.graphics.vertex((x + x4 + ox) * OBJECTS_scale * this.scale, (y + y4 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
                this.graphics.endShape(CLOSE);
              }
            }
          }
        }
      }   
  
      this.graphics.hint(DISABLE_DEPTH_TEST);
  
      SOLARCHVISION_draw_referencePivot();
  
      this.graphics.popMatrix();
  
  
      this.drawPallet();  
  
      this.graphics.endDraw();
  
      if ((this.record_JPG) || (this.record_AUTO)) {
        String myFile = MAKE_Filename(CreateStamp(1) + "this.") + ".jpg";
        this.graphics.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }
  
      imageMode(CORNER);
      image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
  
  
  
      if ((this.record_JPG) || (this.record_AUTO == false)) this.record_JPG = false;  
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;  
      //////////////////////////////////
  
      if (this.ImageScale != 1) {
        this.graphics = createGraphics(this.dX, this.dY, P3D);
        this.update = false; //true;
      } else {
        this.update = false;
  
        SOLARCHVISION_draw_Perspective_Internally();
      }
    }
  }
  
  

  
  void keyPressed (KeyEvent e) {
  
    if (e.isAltDown()) {
      if (key == CODED) { 
        switch(keyCode) {
  
        case RIGHT :
          SolidImpact_Rotation[SolidImpact_sectionType] = (SolidImpact_Rotation[SolidImpact_sectionType] + 15) % 360; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case LEFT :
          SolidImpact_Rotation[SolidImpact_sectionType] = (SolidImpact_Rotation[SolidImpact_sectionType] + 360 - 15) % 360; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;           
  
        case UP   :
          SolidImpact_Elevation[SolidImpact_sectionType] += SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;        
        case DOWN :
          SolidImpact_Elevation[SolidImpact_sectionType] -= SolidImpact_positionStep; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true; 
          ROLLOUT.update = true;  
          break; 
  
        case 33 :
          SolidImpact_Elevation[SolidImpact_sectionType] += 4 * SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;        
        case 34 :
          SolidImpact_Elevation[SolidImpact_sectionType] -= 4 * SolidImpact_positionStep; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break; 
  
        case 35 :
          SolidImpact_scale_U[SolidImpact_sectionType] *= pow(2.0, 0.5); 
          SolidImpact_scale_V[SolidImpact_sectionType] *= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 36 :
          SolidImpact_scale_U[SolidImpact_sectionType] /= pow(2.0, 0.5); 
          SolidImpact_scale_V[SolidImpact_sectionType] /= pow(2.0, 0.5);                   
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        }
      } else {
        switch(key) {
  
        case 'U' :
          SolidImpact_offset_U[SolidImpact_sectionType] += SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 'u' :
          SolidImpact_offset_U[SolidImpact_sectionType] -= SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;        
        case 'V' :
          SolidImpact_offset_V[SolidImpact_sectionType] += SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 'v' :
          SolidImpact_offset_V[SolidImpact_sectionType] -= SolidImpact_positionStep;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;  
  
        case ']' :
          SolidImpact_sectionType = (SolidImpact_sectionType + 1) % 4;
          SolarImpact_sectionType = SolidImpact_sectionType; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case '[' :
          SolidImpact_sectionType = (SolidImpact_sectionType + 4 - 1) % 4;
          SolarImpact_sectionType = SolidImpact_sectionType;
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;        
  
        case '0' :
          SolidImpact_Elevation[SolidImpact_sectionType] = 0; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '.' :
          SolidImpact_Rotation[SolidImpact_sectionType] = 0; 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections();
          this.update = true;
          ROLLOUT.update = true;                   
          break;                  
  
        case '/' :
          SolidImpact_Power *= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '*' :
          SolidImpact_Power /= pow(2.0, 0.5);  
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '+' :
          SolidImpact_Grade *= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '-' :
          SolidImpact_Grade /= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '>' :
          SolidImpact_Grade /= pow(2.0, 0.25); 
          SolidImpact_Power /= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '<' :
          SolidImpact_Grade *= pow(2.0, 0.25); 
          SolidImpact_Power *= pow(2.0, 0.5); 
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
  
  
        case ENTER :
          SOLARCHVISION_calculate_WindFlow(); 
          this.update = true; 
          break;
        }
      }
    } else if (e.isControlDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      } else {
        switch(key) {
  
        case '*': 
          allModel3Ds.select_All();
          this.update = true;
          ROLLOUT.update = true;
          break;             
  
        case '.' :
          this.X_Coordinate = 0;
          this.Y_Coordinate = 0;
          //this.Zoom = 60;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '-' :
          this.RX_Coordinate = 90; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
  
        case '+' :
          this.RX_Coordinate = 0;
          this.RY_Coordinate = 0;
          this.RZ_Coordinate = 0; 
  
          this.X_Coordinate = 0;
          this.Y_Coordinate = 0;
          this.Z_Coordinate = -100;   
  
          this.S_Coordinate = 1;
  
          this.Zoom = 60;        
  
          this.CurrentCamera = 0;
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '0' :
          Land3D.Display_Surface = !Land3D.Display_Surface;
          if (Land3D.Display_Surface) {
            Current_ObjectCategory = ObjectCategory.LANDPOINT;
            UI_BAR_b_update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '1' :
          Display_allModel1Ds = !Display_allModel1Ds;
          if (Display_allModel1Ds) {
            Current_ObjectCategory = ObjectCategory.MODEL1D;
            UI_BAR_b_update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '2' :
          Display_allModel2Ds = !Display_allModel2Ds;
          if (Display_allModel2Ds) {
            Current_ObjectCategory = ObjectCategory.MODEL2D;
            UI_BAR_b_update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '3' :
          Display_allModel3Ds = !Display_allModel3Ds;
          if (Display_allModel3Ds) {
            Current_ObjectCategory = ObjectCategory.GROUP;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '4' :
          Display_allModel3Ds = !Display_allModel3Ds;
          if (Display_allModel3Ds) {
            Current_ObjectCategory = ObjectCategory.FACE;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                  
  
        case '5' :
          Display_allModel3Ds = !Display_allModel3Ds;
          if (Display_allModel3Ds) {
            Current_ObjectCategory = ObjectCategory.VERTEX;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
        case '6' :
          Display_allModel3Ds = !Display_allModel3Ds;
          if (Display_allModel3Ds) {
            Current_ObjectCategory = ObjectCategory.CURVE;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                       
  
        case '7' :
          Display_allSolids = !Display_allSolids;
          if (Display_allSolids) {
            Current_ObjectCategory = ObjectCategory.SOLID;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '8' :
          Display_allSections = !Display_allSections;
          if (Display_allSections) {
            Current_ObjectCategory = ObjectCategory.SECTION;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '9' :
          Display_allCameras = !Display_allCameras;
          if (Display_allCameras) {
            Current_ObjectCategory = ObjectCategory.CAMERA;
            UI_BAR_b_update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
  
  
  
        case ' ' :
          SOLARCHVISION_render_Shadows_selectedallSections(); 
          this.update = true;
          break;
  
        case ENTER :
          SOLARCHVISION_calculate_SolarImpact_selectedallSections();
          this.update = true;
          break;
        }
      }
    }
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
  
      if (key == CODED) { 
        switch(keyCode) {
  
        case DOWN :
          WIN3D.rotateZ_3DViewport_around_Selection(this.RS_Coordinate);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case LEFT :
          WIN3D.rotateXY_3DViewport_around_Selection(-this.RS_Coordinate);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case RIGHT :
          WIN3D.rotateXY_3DViewport_around_Selection(this.RS_Coordinate);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case UP :
          WIN3D.rotateZ_3DViewport_around_Selection(-this.RS_Coordinate);
          this.update = true; 
          ROLLOUT.update = true; 
          break;     
  
        case 33: 
          this.CurrentCamera += 1;
          if (this.CurrentCamera > allCameras.num - 1) this.CurrentCamera = 0;
          WIN3D.apply_currentCamera();
  
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 34: 
          this.CurrentCamera -= 1;
          if (this.CurrentCamera < 0) this.CurrentCamera = allCameras.num - 1;
          WIN3D.apply_currentCamera();
  
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 35: 
  
          break;  
  
        case 36: 
  
          break;          
  
  
  
        case 155: // INSERT 
          allModel3Ds.deselect_All();
  
          this.update = true;
          ROLLOUT.update = true;
          break;
        }
      } else {
        switch(key) {
  
        case DELETE: 
          allModel3Ds.delete_Selection();
  
          this.update = true;
          ROLLOUT.update = true; 
  
          break;        
  
        case ',' :
          if (this.ViewType == 1) {
            this.Z_Coordinate += this.S_Coordinate * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom /= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '.' :
          if (this.ViewType == 1) {
            this.Z_Coordinate -= this.S_Coordinate * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom *= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '0' :
          if (this.ViewType == 1) {
            this.Z_Coordinate += this.S_Coordinate * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom /= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '5' :
          WIN3D.look_3DViewport_towards_Selection(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '4' :
          this.RZ_Coordinate += this.RS_Coordinate; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '6' :
          this.RZ_Coordinate -= this.RS_Coordinate; 
          WIN3D.reverseTransform_3DViewport();
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '2' :
          this.RX_Coordinate -= this.RS_Coordinate; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '8' :
          this.RX_Coordinate += this.RS_Coordinate; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '1' :
          this.X_Coordinate += this.S_Coordinate * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '3' :
          this.X_Coordinate -= this.S_Coordinate * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case '9' :
          this.Y_Coordinate += this.S_Coordinate * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '7' :
          this.Y_Coordinate -= this.S_Coordinate * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                  
  
  
        case '*' : 
          WIN3D.move_3DViewport_towards_Selection(2.0);
          this.update = true; 
          ROLLOUT.update = true; 
          break;        
        case '/' :
          WIN3D.move_3DViewport_towards_Selection(0.5); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
  
        case '+' :
          this.Zoom = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * this.Zoom)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '-' :
          this.Zoom = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * this.Zoom)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case 'O' :
          this.ViewType = 0; 
          this.update = true; 
          ROLLOUT.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'o' :
          this.ViewType = 0; 
          this.update = true; 
          ROLLOUT.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'P' ://this.Zoom = 60;
          this.ViewType = 1; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'p' ://this.Zoom = 60;
          this.ViewType = 1; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
  
        case ']' :
          IMPACTS_DisplayDay += 1;
          if (IMPACTS_DisplayDay > STUDY.j_End) IMPACTS_DisplayDay = 0;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case '[' :
          IMPACTS_DisplayDay -= 1;
          if (IMPACTS_DisplayDay < 0) IMPACTS_DisplayDay = STUDY.j_End;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
        case ENTER: 
          if (this.FacesShade == SHADE.Global_Solar) rebuild_GlobalSolar_array = 1;   
          if (this.FacesShade == SHADE.Vertex_Solar) rebuild_VertexSolar_array = 1;
          this.update = true;
          ROLLOUT.update = true;  
          break;                  
  
        case ' ': 
          SOLARCHVISION_RecordFrame();
          ROLLOUT.update = true; 
          break;       
         
        }
  
      }
    }
  }
  
  
  float Orthographic_ZOOM () {
  
    float ZOOM = 0.5 * this.Zoom * PI / 180;
    
    ZOOM *= pow(pow(this.X_Coordinate, 2) + pow(this.Y_Coordinate, 2) + pow(this.Z_Coordinate, 2), 0.5); 
  
    ZOOM /= this.refScale;
  
    return ZOOM;
  }
  
  
  
  void look_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    WIN3D.lookXY_3DViewport_towards_Direction(Image_X, Image_Y);
    WIN3D.lookZ_3DViewport_towards_Direction(Image_X, Image_Y);
  }
  
  void lookXY_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);  
  
    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;  
  
  
    this.RZ_Coordinate += atan2_ang((yB - yO), (xB - xO)) - atan2_ang((yA - yO), (xA - xO));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void lookZ_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);  
  
    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;  
  
    this.RX_Coordinate += atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void look_3DViewport_towards_Selection () {
  
    WIN3D.lookXY_3DViewport_towards_Selection();
    WIN3D.lookZ_3DViewport_towards_Selection();
  }
  
  void lookXY_3DViewport_towards_Selection () {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_getPivot();
  
    float xB = P[0];
    float yB = P[1];
    float zB = P[2];  
  
  
    this.RZ_Coordinate += atan2_ang((yB - yO), (xB - xO)) - atan2_ang((yA - yO), (xA - xO));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void lookZ_3DViewport_towards_Selection () {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_getPivot();
  
    float xB = P[0];
    float yB = P[1];
    float zB = P[2];  
  
    this.RX_Coordinate += atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  void move_3DViewport_towards_Mouse (float t) {
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float Image_X = mouseX - (this.cX + 0.5 * this.dX);
    float Image_Y = mouseY - (this.cY + 0.5 * this.dY);
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);  
    float xO = ray_end[0] / OBJECTS_scale;
    float yO = ray_end[1] / OBJECTS_scale;
    float zO = ray_end[2] / OBJECTS_scale;
  
    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;
  
    float xB = xO + t * dx; 
    float yB = yO + t * dy;
    float zB = zO + t * dz;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;     
  
    WIN3D.reverseTransform_3DViewport();
  
  
    //this.S_Coordinate *= t; // just to adjust panning better
  }
  
  void move_3DViewport_towards_Selection (float t) {
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];         
  
    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;
  
    float xB = xO + t * dx; 
    float yB = yO + t * dy;
    float zB = zO + t * dz;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;     
  
    WIN3D.reverseTransform_3DViewport();
  
  
    //this.S_Coordinate *= t; // just to adjust panning better
  }
  
  void rotateZ_3DViewport_around_Selection (float t) {
  
    this.RX_Coordinate += t;
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];         
  
    float xB = xA - xO;
    float yB = yA - yO;
    float zB = zA - zO;
  
    // rotate to make it on yz plane
  
    float xC = xB * cos_ang(-this.RZ_Coordinate) - yB * sin_ang(-this.RZ_Coordinate); 
    float yC = xB * sin_ang(-this.RZ_Coordinate) + yB * cos_ang(-this.RZ_Coordinate);
    float zC = zB;
  
    // rotate it on yz plane
  
    float xD = xC;
    float yD = yC * cos_ang(t) - zC * sin_ang(t);
    float zD = yC * sin_ang(t) + zC * cos_ang(t);
  
    // rotate to back from yz plane
  
    float xE = xD * cos_ang(this.RZ_Coordinate) - yD * sin_ang(this.RZ_Coordinate); 
    float yE = xD * sin_ang(this.RZ_Coordinate) + yD * cos_ang(this.RZ_Coordinate);
    float zE = zD;
  
    float xF = xE + xO;
    float yF = yE + yO;
    float zF = zE + zO;
  
    this.CAM_x = xF * OBJECTS_scale;           
    this.CAM_y = yF * OBJECTS_scale;
    this.CAM_z = zF * OBJECTS_scale; 
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void rotateXY_3DViewport_around_Selection (float t) {
  
    this.RZ_Coordinate += t;
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = SOLARCHVISION_getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];             
  
    float dx = xA - xO;
    float dy = yA - yO;
  
    float xB = xO + dx * cos_ang(t) - dy * sin_ang(t); 
    float yB = yO + dx * sin_ang(t) + dy * cos_ang(t);
    float zB = zA;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;   
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void rotateXY_3DViewport_around_LandIntersection (float t) {
  
    float Image_X = SOLARCHVISION_X_click1 - (this.cX + 0.5 * this.dX);
    float Image_Y = SOLARCHVISION_Y_click1 - (this.cY + 0.5 * this.dY);
  
    float[] ray_direction = new float [3];
  
    float[] ray_start = {
      this.CAM_x, this.CAM_y, this.CAM_z
    };
  
    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);
  
    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          
  
    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;
  
    if (this.ViewType == 0) {
      float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);
  
      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;
  
      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }
  
    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];  
    
    
    float[] RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
  
    if (RxP[0] >= 0) {  
  
      float xO = RxP[1] / OBJECTS_scale;
      float yO = RxP[2] / OBJECTS_scale;
      float zO = RxP[3] / OBJECTS_scale;             
  
      float xA = ray_start[0];
      float yA = ray_start[1];
      float zA = ray_start[2];
  
      float dx = xA - xO;
      float dy = yA - yO;
    
      this.RZ_Coordinate += t;
    
      float xB = xO + dx * cos_ang(t) - dy * sin_ang(t); 
      float yB = yO + dx * sin_ang(t) + dy * cos_ang(t);
      float zB = zA;
    
      this.CAM_x = xB * OBJECTS_scale;           
      this.CAM_y = yB * OBJECTS_scale;
      this.CAM_z = zB * OBJECTS_scale;   
    
      WIN3D.reverseTransform_3DViewport();
    }
  }
  
  
  void reverseTransform_3DViewport () { // computing this.X_Coordinate, this.Y_Coordinate and this.Z_Coordinate from new set of camera start and end points.
  
    float px, py, pz;
  
    px = this.CAM_x;
    py = this.CAM_y;
    pz = this.CAM_z;  
  
    float CAM_x1, CAM_y1, CAM_z1;
  
    CAM_z1 = pz;
    CAM_x1 = px * cos_ang(-this.RZ_Coordinate) - py * sin_ang(-this.RZ_Coordinate);
    CAM_y1 = px * sin_ang(-this.RZ_Coordinate) + py * cos_ang(-this.RZ_Coordinate);  
  
    px = CAM_x1;
    py = CAM_y1;
    pz = CAM_z1;  
  
    CAM_x1 = px;
    CAM_y1 = py * cos_ang(-this.RX_Coordinate) - pz * sin_ang(-this.RX_Coordinate);
    CAM_z1 = py * sin_ang(-this.RX_Coordinate) + pz * cos_ang(-this.RX_Coordinate);    
  
  
    float CAM_x2, CAM_y2, CAM_z2;
  
    this.CAM_fov = this.Zoom * PI / 180;
  
    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
    CAM_x2 = 0;
    CAM_y2 = 0;
    CAM_z2 = this.CAM_dist;
  
    CAM_x2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_y2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_z2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);  
  
  
    this.X_Coordinate = CAM_x2 - CAM_x1; 
    this.Y_Coordinate = -(CAM_y2 - CAM_y1); 
    this.Z_Coordinate = CAM_z2 - CAM_z1;
  }
  
  
  void record_last3DViewport () {
  
    allCameras.PPPSRRRF[this.CurrentCamera][0] = this.X_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][1] = this.Y_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][2] = this.Z_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][3] = this.S_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][4] = this.RX_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][5] = this.RY_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][6] = this.RZ_Coordinate;
    allCameras.PPPSRRRF[this.CurrentCamera][7] = this.Zoom;
  
    allCameras.Type[this.CurrentCamera] = this.ViewType;
  }  
  
  
  void apply_currentCamera () {
  
    this.X_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][0];
    this.Y_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][1];
    this.Z_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][2];
    this.S_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][3];
    this.RX_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][4];
    this.RY_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][5];
    this.RZ_Coordinate = allCameras.PPPSRRRF[this.CurrentCamera][6];
    this.Zoom = allCameras.PPPSRRRF[this.CurrentCamera][7];
  
    this.ViewType = allCameras.Type[this.CurrentCamera];
  }  
  
  
  void transform_3DViewport () {
  
    this.CAM_fov = this.Zoom * PI / 180;
  
    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
    this.CAM_x = 0;
    this.CAM_y = 0;
    this.CAM_z = this.CAM_dist;
  
  
    this.CAM_x *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_y *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_z *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
  
    this.CAM_x -= this.X_Coordinate;
    this.CAM_y += this.Y_Coordinate;
    this.CAM_z -= this.Z_Coordinate;
  
    float px, py, pz;
  
    px = this.CAM_x;
    py = this.CAM_y * cos_ang(this.RX_Coordinate) - this.CAM_z * sin_ang(this.RX_Coordinate);
    pz = this.CAM_y * sin_ang(this.RX_Coordinate) + this.CAM_z * cos_ang(this.RX_Coordinate);
  
    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;
  
    pz = this.CAM_z;
    px = this.CAM_x * cos_ang(this.RZ_Coordinate) - this.CAM_y * sin_ang(this.RZ_Coordinate);
    py = this.CAM_x * sin_ang(this.RZ_Coordinate) + this.CAM_y * cos_ang(this.RZ_Coordinate);
  
    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;   
  
    //println("Camera:", nf(this.CAM_x,0,4), nf(this.CAM_y,0,4), nf(this.CAM_z,0,4));
  }
  
  
  
  void put_3DViewport () {  
  
    if (this.ViewType == 1) {
  
      float aspect = 1.0 / this.R_View;
  
      float zFar = this.CAM_dist * this.CAM_clipFar;
      float zNear = this.CAM_dist * this.CAM_clipNear;
  
      this.graphics.perspective(this.CAM_fov, aspect, zNear, zFar);
  
      this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
    } else {
  
      float ZOOM = WIN3D.Orthographic_ZOOM();
  
      this.graphics.ortho(ZOOM * this.dX * -1, ZOOM * this.dX * 1, ZOOM  * this.dY * -1, ZOOM  * this.dY * 1, 0.00001, 100000);
  
      this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
    }
  
    this.graphics.translate(this.X_Coordinate * this.scale, this.Y_Coordinate * this.scale, this.Z_Coordinate * this.scale);
  
    this.graphics.rotateX(this.RX_Coordinate * PI / 180); 
    this.graphics.rotateZ(this.RZ_Coordinate * PI / 180);
  }
  
  
  
  void drawPallet () {
  
    int draw_pal = 0;
  
    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    float PAL_Multiplier = 1; 
  
    if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
  
      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR; 
        PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
        PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
      }   
  
      draw_pal = 1;
    }
  
    if (this.FacesShade == SHADE.Vertex_Elevation) {
  
      PAL_TYPE = ELEVATION_Pallet_CLR; 
      PAL_DIR = ELEVATION_Pallet_DIR; 
      PAL_Multiplier = ELEVATION_Pallet_MLT; 
  
      draw_pal = 1;
    }
  
    if (this.FacesShade == SHADE.Vertex_Solid) {
  
      PAL_TYPE = SOLID_Pallet_CLR; 
      PAL_DIR = SOLID_Pallet_DIR;
      PAL_Multiplier = SOLID_Pallet_MLT;
  
      draw_pal = 1;
    }          
  
  
  
  
    if (draw_pal != 0) {
  
      float the_scale = 1;
  
      if (this.ViewType == 1) {
        the_scale *= (0.5 / tan(0.5 * this.CAM_fov));
      } else {
        float ZOOM = WIN3D.Orthographic_ZOOM();
        the_scale *= (0.5 / ZOOM);
      }  
  
      this.graphics.pushMatrix();
  
      this.CAM_fov = this.Zoom * PI / 180;
  
      this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
      if (this.ViewType == 1) {
  
        float aspect = 1.0 / this.R_View;
  
        float zFar = this.CAM_dist * 1000;
        float zNear = this.CAM_dist * 0.001;
  
        this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
      } else {
  
        float ZOOM = WIN3D.Orthographic_ZOOM();
  
        this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
      }
  
  
  
  
  
  
  
  
  
      float pal_length = 1 * SOLARCHVISION_H_Pixel * this.ImageScale / the_scale;
  
      float y1 = -0.2 * (pal_length / 11.0) + (0.4 * this.dY / the_scale);
      float y2 = y1 + 0.4 * (pal_length / 11.0);
  
      float txtSize = y2 - y1;
  
      for (int q = 0; q < 11; q++) {
        
        float x1 = -0.5 * pal_length + q * (pal_length / 11.0); 
        float x2 = x1 + (pal_length / 11.0);      
  
        float _u = 0.2 * q - 0.5;
  
        if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
          if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
        }
  
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;
  
        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u); 
  
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
        this.graphics.strokeWeight(0);
  
        this.graphics.beginShape();
        this.graphics.vertex(x1, y1, 0);
        this.graphics.vertex(x1, y2, 0);
        this.graphics.vertex(x2, y2, 0);
        this.graphics.vertex(x2, y1, 0);
        this.graphics.endShape(CLOSE);    
  
        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }  
  
        this.graphics.textSize(txtSize);
        this.graphics.textAlign(CENTER, CENTER);
  
        if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
          if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
          if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
  
        if (this.FacesShade == SHADE.Vertex_Elevation) {
          this.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
  
        if (this.FacesShade == SHADE.Vertex_Solid) {
          this.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
      }
  
      this.graphics.textAlign(LEFT, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) this.graphics.text("kW/m²", 0.5 * pal_length, 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      if (Impact_TYPE == Impact_PASSIVE) this.graphics.text("%kW°C/m²", 0.5 * pal_length, 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
  
      this.graphics.popMatrix();
    }
  }  
}



class solarchvision_WORLD {

  private final static String CLASS_STAMP = "WORLD";
  // scales
  float sX = 1;
  float sY = 1;  
  // offsets
  float oX = 0;
  float oY = 0;
  // (top-left) corner
  int cX = int(1.5 * SOLARCHVISION_H_Pixel);
  int cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
  // width and height
  int dX = int(2.0 * SOLARCHVISION_H_Pixel);
  int dY = SOLARCHVISION_H_Pixel;
  
  boolean update = true;
  boolean include = true;
  
  
  int Viewports_num;
  int Viewport_ZOOM = 1; //1:A 2:B 3:C 4:D 5:E and 6:L <<<

  int AutoView = 1;
  
  boolean record_JPG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;  

  float ImageScale = 1.0;

  String ViewFolder;
  
  PImage ViewImage;
  
  PGraphics graphics;

  int VIEW_id = 0;


  
  String[][] VIEW_Name;
  float[][] VIEW_BoundariesX;
  float[][] VIEW_BoundariesY; 
  int[] VIEW_GridDisplay;
  String[] VIEW_Filenames;  
  
  void listAllImages () {
  
    this.VIEW_Filenames = sort(SOLARCHVISION_getfiles(this.ViewFolder));
  
    this.Viewports_num = this.VIEW_Filenames.length;
  
    this.VIEW_Name = new String [this.Viewports_num][2];
  
    this.VIEW_BoundariesX = new float [this.Viewports_num][2];
    this.VIEW_BoundariesY = new float [this.Viewports_num][2];
  
    this.VIEW_GridDisplay = new int [this.Viewports_num];
  
    for (int i = 0; i < this.Viewports_num; i++) {
      String MapFilename = this.ViewFolder + "/" + this.VIEW_Filenames[i];
  
      String[] Parts = split(this.VIEW_Filenames[i], '_');
  
      this.VIEW_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.VIEW_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.VIEW_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.VIEW_BoundariesY[i][1] =  float(Parts[4]) * 0.001;
  
      this.VIEW_Name[i][0] = Parts[5];
      this.VIEW_Name[i][1] = Parts[6];
  
      float a = (this.VIEW_BoundariesY[i][1] - this.VIEW_BoundariesY[i][0]) / 2;
      if (a < 1) a = 1;
      this.VIEW_GridDisplay[i] = int(a);
    }
  }  
  
  
  int FindGoodViewport (float pointLongitude, float pointLatitude) {
  
    int return_VIEWPORT = this.VIEW_id;
  
    if (this.AutoView == 1) {
  
      float d1 = FLOAT_undefined;
      float d2 = FLOAT_undefined;
  
      for (int i = 0; i < this.Viewports_num; i++) {
  
        int check_it = 0; 
  
        String started_with = this.VIEW_Filenames[i].substring(0, 1);
  
        if (this.Viewport_ZOOM == 1) {
          if (started_with.equals("A")) check_it = 1;
        } else if (this.Viewport_ZOOM == 2) {
          if (started_with.equals("B")) check_it = 1;
        } else if (this.Viewport_ZOOM == 3) {
          if (started_with.equals("C")) check_it = 1;
        } else if (this.Viewport_ZOOM == 4) {
          if (started_with.equals("D")) check_it = 1;
        } else if (this.Viewport_ZOOM == 5) {
          if (started_with.equals("E")) check_it = 1;
        } else {
          check_it = 1;
        }
  
        if (check_it == 1) {  
  
          if (isInside(pointLongitude, pointLatitude, this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1]) == 1) {
            float d_Center = dist(pointLongitude, pointLatitude, 0.5 * (this.VIEW_BoundariesX[i][0] + this.VIEW_BoundariesX[i][1]), 0.5 * (this.VIEW_BoundariesY[i][0] + this.VIEW_BoundariesY[i][1]));
            float d_Size = dist(this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1]);
  
            if (d2 > 0.95 * d_Size) {
              if (d1 > d_Center) {
                d1 = d_Center;
                d2 = d_Size;
  
                return_VIEWPORT = i;
              }
            }
          }
        }
      }
    }
  
    if (return_VIEWPORT != this.VIEW_id) {
      this.loadImages(return_VIEWPORT);
  
      if (Earth3D.Display_Surface) WIN3D.update = true;
    }
  
    return (return_VIEWPORT);
  }
  
  
  void loadImages (int n) {

    println("Loading:", this.ViewFolder + "/" + this.VIEW_Filenames[n]);
  
    this.ViewImage = loadImage(this.ViewFolder + "/" + this.VIEW_Filenames[n]);
  }
  

  void drawView () {
  
    if (this.update) {
  
      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_JPG) this.ImageScale = 2;
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;  
      //////////////////////////////////  
  
      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(CreateStamp(1) + "this.") + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }
  
      this.graphics.background(0, 0, 0);
  
      this.graphics.image(this.ViewImage, 0, 0, this.dX, this.dY);
  
      this.oX = this.VIEW_BoundariesX[this.VIEW_id][0] + 180;
      this.oY = this.VIEW_BoundariesY[this.VIEW_id][1] - 90;
  
      this.sX = (this.VIEW_BoundariesX[this.VIEW_id][1] - this.VIEW_BoundariesX[this.VIEW_id][0]) / 360.0;
      this.sY = (this.VIEW_BoundariesY[this.VIEW_id][1] - this.VIEW_BoundariesY[this.VIEW_id][0]) / 180.0;    
  
      float _lon1 = this.VIEW_BoundariesX[this.VIEW_id][0];
      float _lon2 = this.VIEW_BoundariesX[this.VIEW_id][1];
      float _lat1 = this.VIEW_BoundariesY[this.VIEW_id][0];
      float _lat2 = this.VIEW_BoundariesY[this.VIEW_id][1];
  
      int x_point1 = int(this.dX * (( 1 * (_lon1 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point1 = int(this.dY * ((-1 * (_lat1 - this.oY) / 180.0) + 0.5) / this.sY);
      int x_point2 = int(this.dX * (( 1 * (_lon2 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point2 = int(this.dY * ((-1 * (_lat2 - this.oY) / 180.0) + 0.5) / this.sY); 
  
  
  
      Tropo3D.draw(TypeWindow.WORLD, STUDY.i_Start, STUDY.i_End);
  
  
      float R_station = 2 * this.ImageScale;
      if (this.VIEW_GridDisplay[this.VIEW_id] == 1) R_station = 5; 
  
      this.graphics.ellipseMode(CENTER);
  
      for (int n = 0; n < AERIAL_num; n++) {
  
        //try {
  
        if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {
  
          float _lat = AERIAL_Locations[n][1];
          float _lon = AERIAL_Locations[n][0]; 
          if (_lon > 180) _lon -= 360; // << important!
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY; 
  
          this.graphics.pushMatrix();
          this.graphics.translate(x_point, y_point);
  
          if (AERIAL_graphOption == 0) {
            //-----------------------------
            int PAL_TYPE = 6; //12; 
            int PAL_DIR = -1;
            float PAL_Multiplier = 1.0 / 30.0;
            //-----------------------------
  
            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
                float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
  
                if (is_undefined_FLOAT(_val) == false) {
  
                  float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
  
                  float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);             
  
                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
  
                    this.graphics.strokeWeight(0);
                    this.graphics.ellipse(0, 0, R_station, R_station);
                  }
  
                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);
  
                    _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
  
                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }              
                    if (is_undefined_FLOAT(_val) == false) this.graphics.text(nf(int(roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }  
  
          if (AERIAL_graphOption == 1) {
  
            //-----------------------------
            int PAL_TYPE = 1;//12; 
            int PAL_DIR = 1;//-1;
            float PAL_Multiplier = 0.1;//1.0 / 30.0;
            //-----------------------------
  
            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
                //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
                float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
                if (is_undefined_FLOAT(_val) == false) {              
  
                  float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
                  float D_teta = 15; 
                  float R = 0.25 * R_station * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
                  float R_in = 0.0 * R; 
                  float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;                      
  
                  float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;          
  
                  //float ox = -0.5 * (R * cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -0.5 * (R * -sin_ang(90 - teta)) * this.ImageScale;
                  //float ox = -1 * (R * cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -1 * (R * -sin_ang(90 - teta)) * this.ImageScale;
                  float ox = -2 * (R * cos_ang(90 - teta)) / 3.0 * this.ImageScale;
                  float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0 * this.ImageScale;            
  
                  float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;
  
                  float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);             
  
                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
  
                    this.graphics.strokeWeight(0);
                    //this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    this.graphics.quad(x1 + ox, y1 + oy, x2 + ox, y2 + oy, x3 + ox, y3 + oy, x4 + ox, y4 + oy);
                  }
  
                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);
  
                    _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
  
                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }              
                    if (is_undefined_FLOAT(_val) == false) this.graphics.text(nf(int(roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }
  
          this.graphics.popMatrix();
        }
        //}
        //catch (Exception e) {
        //}
      }   
  
  
  
  
      {
        float _lat = STATION.getLatitude();
        float _lon = STATION.getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY; 
  
        this.graphics.strokeWeight(3 * this.ImageScale);
        this.graphics.stroke(0, 0, 127, 255);
        this.graphics.noFill();
  
        this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
      }   
  
      for ( int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {
  
        nearest_Station_ENSEMBLE_OBSERVED_id[q] = -1;
        nearest_Station_ENSEMBLE_OBSERVED_dist[q] = FLOAT_undefined;
    
        for (int f = 0; f < SWOB_Coordinates.length; f++) {
          boolean draw_info = false;
    
          if (Display_SWOB_Points != 0) draw_info = true;
    
          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude(); 
          if (_lon > 180) _lon -= 360; // << important!
    
          if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
          if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
          if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
          if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
    
          if (draw_info) {
    
            float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
            float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
    
            this.graphics.strokeWeight(0);
            this.graphics.stroke(191, 0, 0, 191);
            this.graphics.fill(191, 0, 0, 191);      
            this.graphics.ellipse(x_point, y_point, R_station, R_station);
    
            if (Display_SWOB_Points > 1) {
              this.graphics.strokeWeight(0);
              this.graphics.stroke(0);
              this.graphics.fill(0);      
              this.graphics.textAlign(RIGHT, CENTER); 
              this.graphics.textSize(MessageSize * this.ImageScale);
              this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
            }
          }
    
          float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
    
          if (nearest_Station_ENSEMBLE_OBSERVED_dist[q] > d) {
  
            int added_before = 0;
  
            for (int p = 0; p < q; p++) {
              if (nearest_Station_ENSEMBLE_OBSERVED_id[p] == f) added_before = 1;
            }
  
            if (added_before == 0) {
              nearest_Station_ENSEMBLE_OBSERVED_dist[q] = d;
              nearest_Station_ENSEMBLE_OBSERVED_id[q] = f;
            }
          }        
          
        }    
  
        if (Display_SWOB_Nearest) {   
          int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];
    
          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude(); 
          if (_lon > 180) _lon -= 360; // << important!
    
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
    
          this.graphics.strokeWeight(0);
          this.graphics.stroke(0);
          this.graphics.fill(0);      
          this.graphics.textAlign(RIGHT, CENTER);
          this.graphics.textSize(MessageSize * this.ImageScale);
          this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
          //println(SWOB_Coordinates[f].getCode());
        }  
        
      }
  
  
  
      int nearest_WORLD_NAEFS = -1;
      float nearest_WORLD_NAEFS_dist = FLOAT_undefined;
  
      for (int f = 0; f < NAEFS_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (Display_NAEFS_Points != 0) draw_info = true;
  
        float _lat = NAEFS_Coordinates[f].getLatitude();
        float _lon = NAEFS_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(0);
          this.graphics.stroke(0, 63, 0, 127);
          this.graphics.fill(0, 63, 0, 127);
  
          this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
  
          if (Display_NAEFS_Points > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(NAEFS_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_NAEFS_dist > d) {
          nearest_WORLD_NAEFS_dist = d;
          nearest_WORLD_NAEFS = f;
        }
      }
  
      if (Display_NAEFS_Nearest) {   
        int f = nearest_WORLD_NAEFS;
  
        float _lat = NAEFS_Coordinates[f].getLatitude();
        float _lon = NAEFS_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(NAEFS_Coordinates[f].getCity(), x_point, y_point);
        //println(NAEFS_Coordinates[f].getCity());
      }
  
  
      int nearest_WORLD_CWEEDS = -1;
      float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;
  
      for (int f = 0; f < CWEEDS_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (Display_CWEEDS_Points != 0) draw_info = true;
  
        float _lat = CWEEDS_Coordinates[f].getLatitude();
        float _lon = CWEEDS_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
          if (Display_CWEEDS_Points > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(CWEEDS_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_CWEEDS_dist > d) {
          nearest_WORLD_CWEEDS_dist = d;
          nearest_WORLD_CWEEDS = f;
        }
      } 
  
      if (Display_CWEEDS_Nearest) {   
        int f = nearest_WORLD_CWEEDS;
  
        float _lat = CWEEDS_Coordinates[f].getLatitude();
        float _lon = CWEEDS_Coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CWEEDS_Coordinates[f].getCity(), x_point, y_point);
        //println(CWEEDS_Coordinates[f].getCity());
      }
  
  
      int nearest_WORLD_CLMREC = -1;
      float nearest_WORLD_CLMREC_dist = FLOAT_undefined;
  
      for (int f = 0; f < CLMREC_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (Display_CLMREC_Points != 0) draw_info = true;
        
        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(1 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 0.5 * R_station, 0.5 * R_station);
  
          if (Display_CLMREC_Points > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(0.5 * MessageSize * this.ImageScale);
            this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_CLMREC_dist > d) {
          nearest_WORLD_CLMREC_dist = d;
          nearest_WORLD_CLMREC = f;
        }
      } 
  
      if (Display_CLMREC_Nearest) {   
        int f = nearest_WORLD_CLMREC;
  
        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
        //println(CLMREC_Coordinates[f].getCity());
      }
  
      int nearest_WORLD_TMYEPW = -1;
      float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;
  
      for (int f = 0; f < TMYEPW_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (Display_TMYEPW_Points != 0) draw_info = true;
  
        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(255, 0, 0, 127);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
          if (Display_TMYEPW_Points > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_TMYEPW_dist > d) {
          nearest_WORLD_TMYEPW_dist = d;
          nearest_WORLD_TMYEPW = f;
        }
      } 
  
      if (Display_TMYEPW_Nearest) {   
        int f = nearest_WORLD_TMYEPW;
  
        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
        //println(TMYEPW_Coordinates[f].getCity());
      }
  
  
      this.graphics.strokeWeight(0);
  
  
      if (this.record_PDF) {
        endRecord();
  
        String myFile = MAKE_Filename(CreateStamp(0) + "this.") + ".pdf";
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();
  
        if ((this.record_JPG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(CreateStamp(1) + "this.") + ".jpg";
          this.graphics.save(myFile);
          SOLARCHVISION_explore_output(myFile);
          println("File created:" + myFile);
        }
  
        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }
  
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;  
      //////////////////////////////////
  
      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.update = false; //1;
      } else {
        this.update = false;
      }
  
  
      if ((this.record_JPG) || (this.record_AUTO == false)) this.record_JPG = false;
    }
  }
    
}




class solarchvision_STUDY {
  
  private final static String CLASS_STAMP = "STUDY";

  int cX = 0;
  int cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_H_Pixel;
  int dX = 2 * SOLARCHVISION_W_Pixel;
  int dY = 1 * SOLARCHVISION_H_Pixel;
  float R_View = float(dY) / float(dX);
  float S_View;
  
  boolean update = true;
  boolean include = true;

  boolean record_JPG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;   
  

  int i_Start = 0;
  int i_End = 23;
  
  int j_Start = 0; // constant
  int j_End = 8; //6; //2; //16; // Variable  

  float PerDays = 45; //61; //1; //45; //61; //30.5;
  int JoinDays = 1; //30;//PerDays; // it should be set up to 1 in order to plot only one day  
  
  boolean PrintTtitle = true;
  
  float T_scale = 0.5;
  float U_scale = 18.0 / float(j_End - j_Start);
  
  float V_scale;
  float V_offset;
  float V_belowLine;

  int skyScenario = 1; // 1: all scenarios, 2: Total Cloud Cover < 0.33, 3: middle range, 4: Total Cloud Cover > 0.66
  int filter = FILTER_Daily;
  
  int TrendJoinHours = 24; //48;
  int TrendJoinType = -1; // -1: increasing weights, +1: equal weights
  
  boolean Export_info_node = false;
  boolean Export_info_norm = false;
  boolean Export_info_prob = false;
  
  int Pallet_SORT_CLR = -1;
  int Pallet_SORT_DIR = -1;
  float Pallet_SORT_MLT = 2;
  
  int Pallet_PROB_CLR = -1;
  int Pallet_PROB_DIR = 1;
  float Pallet_PROB_MLT = 0.5;
  
  int Pallet_ACTIVE_CLR = 19; //15; //14; 
  int Pallet_ACTIVE_DIR = 1;
  float Pallet_ACTIVE_MLT = 1; //2;
  
  int Pallet_PASSIVE_CLR = 1; 
  int Pallet_PASSIVE_DIR = 1;
  float Pallet_PASSIVE_MLT = 1; 
  
  float X_control;
  float Y_control;
  
  
  float X_Coordinate = 0;
  float Y_Coordinate = 0;
  
  float O_scale = 50.0;
  float W_scale = 3.0;
  
  float rect_scale = 0.005;
  float rect_offset_x = 0.5;
  
  boolean impact_summary = false;
  
  int ImpactLayer = 1; // 4 = Median
  int PlotImpacts = 4; //-2/-1:wind 0/1:urban 2/3:globe 4/5:sun-path 6/7:view-from-sun 8/9:two-cycles
  boolean Impacts_update = true; 
  
  boolean DisplayRaws = false;
  boolean DisplaySorted = true;
  boolean DisplayNormals = true;
  boolean DisplayProbs = false;
  
  int SumInterval = 2;
  float LevelPix = 8;
  
  float Pix = 0; 
  
  color color_data_raws = color(0, 0, 0);
  
  int plotSetup = 14; //4; //12; //13;
  
  float ImageScale = 1.0;
  
  PGraphics graphics;
  
  
  
  
  
  int isInHourlyRange (float i) {
    int q = -1;
    if (i_Start <= i_End) {
      q = 0;
      if ((i_Start <= i) && (i <= (i_End + 24) % 24)) q = 1;
    } else {
      q = 1;
      if ((i_Start > i) && (i > (i_End + 24) % 24)) q = 0;
    }
    return q;
  }  
  
  
  void keyPressed (KeyEvent e) {
  
    if (e.isAltDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      } else {
        switch(key) {
        case '0' : 
          Camera_Variation = 0; 
          this.update = true; 
          break;
        case '1' : 
          Camera_Variation = 1; 
          this.update = true; 
          break;
        case '2' : 
          Camera_Variation = 2; 
          this.update = true; 
          break;
        case '3' : 
          Camera_Variation = 3; 
          this.update = true; 
          break;
        case '4' : 
          Camera_Variation = 4; 
          this.update = true; 
          break;
        case '5' : 
          Camera_Variation = 5; 
          this.update = true; 
          break;
        case '6' : 
          Camera_Variation = 6; 
          this.update = true; 
          break;
          //case '7' : Camera_Variation = 7; this.update = true; break;
          //case '8' : Camera_Variation = 8; this.update = true; break;
          //case '9' : Camera_Variation = 9; this.update = true; break;
        }
      }
    } else if (e.isControlDown()) {
      if (key == CODED) { 
        switch(keyCode) {
          
        }
      } else {
        switch(key) {
  
        case 'r' : 
          this.record_AUTO = !this.record_AUTO; 
          this.update = false; 
          ROLLOUT.update = true; 
          break;
        case 'R' : 
          this.record_AUTO = !this.record_AUTO; 
          this.update = false; 
          ROLLOUT.update = true; 
          break;
  
        }
      }
    } else if (e.isShiftDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      }
    }
  
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
  
      if (key == CODED) { 
        switch(keyCode) {
  
        case 112 : //F1
          this.PlotImpacts = -2; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 113 : //F2
          this.PlotImpacts = -1; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 114 : //F3
          this.PlotImpacts = 4; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 115 : //F4
          this.PlotImpacts = 5; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;          
        case 116 : //F5
          this.PlotImpacts = 2; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 117 : //F6
          this.PlotImpacts = 3; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;                   
        case 118 : //F7
          this.PlotImpacts = 0; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;           
        case 119 : //F8
          this.PlotImpacts = 1; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        }
      }
    }
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
  
      if (key != CODED) { 
        switch(key) {
  
        case '|' :
          if (TIME_Date == 1.0 * int(TIME_Date)) TIME_Date += 0.5;
          else TIME_Date -= 0.5;
          SOLARCHVISION_update_date(); 
          update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
          break;
  
        case ';': 
          this.impact_summary = !(this.impact_summary);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '?' :
          SOALRCHVISION_refreshDateTabs();                   
          DevelopData_update = true;
          UI_BAR_d_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '}' :
          this.j_End += 1; 
          if (this.j_End > this.j_Start + 61) this.j_End -= 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
           this.PerDays = int(365 / float(this.j_End - this.j_Start));
           } 
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.PerDays = 1;
           }
           */
          DevelopData_update = true;
  
          rebuild_VertexSolar_array = 1;
          rebuild_GlobalSolar_array = 1;
          rebuild_SolarImpactImage_array = 1;
          rebuild_WindRoseImage_array = 1;
          allSections.resize_SolarImpact_array();
  
          UI_BAR_d_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '{' :
          this.j_End -= 1; 
          if (this.j_End <= this.j_Start) this.j_End += 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
           this.PerDays = int(365 / float(this.j_End - this.j_Start));
           } 
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.PerDays = 1;
           }                  
           */
          DevelopData_update = true;
  
          rebuild_VertexSolar_array = 1; 
          rebuild_GlobalSolar_array = 1;
          rebuild_SolarImpactImage_array = 1;
          rebuild_WindRoseImage_array = 1;   
          allSections.resize_SolarImpact_array();
  
          UI_BAR_d_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'a'  :
          Develop_AngleInclination -= 5;
          if (Develop_AngleInclination < -90) Develop_AngleInclination = -90;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'A'  :
          Develop_AngleInclination += 5;
          if (Develop_AngleInclination > 90) Develop_AngleInclination = 90;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'z' :
          Develop_AngleOrientation = (Develop_AngleOrientation - 5 + 360) % 360;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'Z' :
          Develop_AngleOrientation = (Develop_AngleOrientation + 5) % 360;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case 'd' :
          Develop_DayHour = (Develop_DayHour + 1) % 4;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'D' :
          Develop_DayHour = (Develop_DayHour - 1 + 4) % 4;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '>' :
          if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) {
            this.O_scale *= pow(2.0, (1.0 / 4.0));
          } else {
            this.ImpactLayer = (this.ImpactLayer + 1) % 9;
          }
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case '<' :
          if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) {
            this.O_scale *= pow(0.5, (1.0 / 4.0));
          } else {
            this.ImpactLayer = (this.ImpactLayer + 9 - 1) % 9;
          }
          this.update = true;
          ROLLOUT.update = true; 
          break;
  
  
  
  
          //case 'g' :this.filter = (this.filter + 1) % 2; DevelopData_update = true; this.update = true; ROLLOUT.update = true; break;
          //case 'G' :this.filter = (this.filter + 2 - 1) % 2; DevelopData_update = true; this.update = true; ROLLOUT.update = true; break;
  
        case '=' :
          this.V_scale *= pow(2.0, (1.0 / 2.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '_' :
          this.V_scale *= pow(0.5, (1.0 / 2.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'c' :
          COLOR_STYLE_Current = (COLOR_STYLE_Current + 1) % COLOR_STYLE_Number; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'C' :
          COLOR_STYLE_Current = (COLOR_STYLE_Current - 1 + COLOR_STYLE_Number) % COLOR_STYLE_Number; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'V' :
          this.DisplayRaws = !this.DisplayRaws; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'v' :
          this.DisplayRaws = !this.DisplayRaws; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '`' :
          this.JoinDays += 2;
          if (this.JoinDays > 365) this.JoinDays = 365;
          DevelopData_update = true; 
          UI_BAR_d_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '~' :
          this.JoinDays -= 2;
          if (this.JoinDays < 1) this.JoinDays = 1;
          DevelopData_update = true; 
          UI_BAR_d_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'l' :
          Materials_Selection += 1;
          Materials_Selection %= Materials_Number; 
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'L' :
          Materials_Selection += Materials_Number - 1;
          Materials_Selection %= Materials_Number;
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
        case 'm' :
          this.DisplaySorted = !this.DisplaySorted; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'M' :
          this.DisplaySorted = !this.DisplaySorted; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'n' :
          this.DisplayNormals = !this.DisplayNormals; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'N' :
          this.DisplayNormals = !this.DisplayNormals; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'b' :
          this.DisplayProbs = !this.DisplayProbs; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'B' :
          this.DisplayProbs = !this.DisplayProbs; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'j' :
          if (this.LevelPix < 32) this.LevelPix *= pow(2.0, (1.0 / 1.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'J' :
          if (this.LevelPix > 2) this.LevelPix *= pow(0.5, (1.0 / 1.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'i' :
          if (this.SumInterval > 24) this.SumInterval -= 24;
          if (this.SumInterval > 6) this.SumInterval -= 6; 
          else if (this.SumInterval > 1) this.SumInterval -= 1;
          if (this.SumInterval == 5) this.SumInterval = 4;
          println("this.SumInterval =", this.SumInterval);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'I' :
          if (this.SumInterval < 6) this.SumInterval += 1;
          else if (this.SumInterval < 24) this.SumInterval += 6;
          else this.SumInterval += 24;
          if (this.SumInterval == 5) this.SumInterval = 6;
          println("this.SumInterval =", this.SumInterval);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '!' :
          this.skyScenario = 1; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '@' :
          this.skyScenario = 2; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '#' :
          this.skyScenario = 3; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '$' :
          this.skyScenario = 4; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 's' : 
          this.record_JPG = true; 
          this.record_PDF = false; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'S' : 
          this.record_PDF = true; 
          this.record_JPG = false; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        }
      }
    }
  }
  


  void drawTimeGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    this.graphics.strokeWeight(this.T_scale * 1);
  
    float Shift_DOWN = 0;
    if (this.V_belowLine != 0) Shift_DOWN = -100;
  
    for (int i = 100; i >= Shift_DOWN; i -= 25) {
      if (-this.V_offset + roundTo(i / this.V_scale, 0.1) != 0) {
        this.graphics.stroke(0, 63);
        this.graphics.fill(0, 63);
      } else {
        this.graphics.stroke(0);
        this.graphics.fill(0);
      }
      this.graphics.line(this.j_Start * sx_Plot, -i * this.S_View, this.j_End * sx_Plot, -i * this.S_View); 
  
      if ((i >= 0) || (this.V_belowLine != 0)) {  
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.text(((nf(-this.V_offset + roundTo(i / this.V_scale, 0.1), 0, 1)) + CurrentLayer_unit), -5, -i * this.S_View);
        //this.graphics.text(((String.valueOf(int(-this.V_offset + roundTo(i / this.V_scale, 0.1)))) + CurrentLayer_unit), -5, -i * this.S_View);
      }
    }
  
    this.graphics.stroke(0, 63);
    this.graphics.fill(0, 63); 
    for (int i = this.j_Start; i <= this.j_End; i++) {
      if (i < this.j_End) {
        int j_step = 3;
        for (int j = j_step; j <= 24; j += j_step) {
          if (j != 24) {
            this.graphics.line((i + j / 24.0) * sx_Plot, -5 * this.S_View, (i + j / 24.0) * sx_Plot, 5 * this.S_View);
          } else {
            this.graphics.line((i + j / 24.0) * sx_Plot, -105 * this.S_View, (i + j / 24.0) * sx_Plot, (5 - Shift_DOWN) * this.S_View);
          }
        }
      }
    }
  
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER); 
  
    for (int i = this.j_Start; i < this.j_End; i++) {
      if (this.U_scale >= 0.75) {
        this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
        this.graphics.text("12:00", (i - ((0 - 12) / 24.0)) * sx_Plot, 0.1 * sx_Plot / this.U_scale);
      }
    }
  
    this.drawInfo(sx_Plot, this.V_belowLine);
  }  
  
  
  
  void drawPositionGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int fill_back) {
    this.graphics.strokeWeight(this.T_scale * 1);
  
    if (fill_back != 0) {
      for (int i = this.j_Start; i < this.j_End; i++) {
  
        this.graphics.stroke(223);
        this.graphics.fill(223);
        this.graphics.ellipse((i + this.rect_offset_x) * sx_Plot, 0, 2 * 90 * this.rect_scale * sx_Plot, 2 * 90 * this.rect_scale * sx_Plot);
      }
    }
  
    for (int i = this.j_Start; i < this.j_End; i++) {
      for (int t = 0; t < 360; t += 15) {
  
        if ((t % 45) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.fill(0, 63);
        } else {
  
          this.graphics.stroke(0);
          this.graphics.fill(0);
        }
        int r = 0;
        if ((t % 45) != 0) r = 15;
  
        this.graphics.line((i + this.rect_offset_x + r * this.rect_scale * (cos_ang(t))) * sx_Plot, -(r * this.rect_scale * (sin_ang(t))) * sx_Plot, (i + this.rect_offset_x + 90 * this.rect_scale * (cos_ang(t))) * sx_Plot, -(90 * this.rect_scale * (sin_ang(t))) * sx_Plot); 
  
        if (((t + 45) % 90) == 0) {
          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);
  
          String ORI = "";
          switch((360 + 90 - t) % 360) {
          case 0 : 
            ORI = "N"; 
            break;
          case 45 : 
            ORI = "NE"; 
            break;
          case 90 : 
            ORI = "E"; 
            break;
          case 135 : 
            ORI = "SE"; 
            break;
          case 180 : 
            ORI = "S"; 
            break;
          case 225 : 
            ORI = "SW"; 
            break;
          case 270 : 
            ORI = "W"; 
            break;
          case 315 : 
            ORI = "NW"; 
            break;
          }
  
          this.graphics.text(ORI, (i + this.rect_offset_x + 110 * this.rect_scale * (cos_ang(t))) * sx_Plot, -(110 * this.rect_scale * (sin_ang(t))) * sx_Plot);
          //this.graphics.text(String.valueOf((360 + 90 - t) % 360), (i + this.rect_offset_x + 110 * this.rect_scale * (cos_ang(t))) * sx_Plot, -(110 * this.rect_scale * (sin_ang(t))) * sx_Plot);
        }
      }
  
      float impact_scale = 1;
      if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) impact_scale = LAYER_windspd.V_scale * 45 / 50.0;
  
      for (int r = 90; r > 0; r -= 15) {
        if ((r % 90) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.noFill();
        } else {
          this.graphics.stroke(0);
          this.graphics.noFill();
        }
  
        this.graphics.ellipse((i + this.rect_offset_x) * sx_Plot, 0, 2 * r * this.rect_scale * sx_Plot, 2 * r * this.rect_scale * sx_Plot);
  
        int t = 90;
        if (t == 90) {
          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);
          this.graphics.text(nf(int(r / impact_scale), 1), (i + this.rect_offset_x + r * this.rect_scale * (cos_ang(t))) * sx_Plot, -(r * this.rect_scale * (sin_ang(t))) * sx_Plot);
        }
      }
    }
  }  
  
  
  void drawDailyGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER); 
  
    for (int i = this.j_Start; i < this.j_End; i++) {
      if ((this.U_scale >= 0.75) || (((i - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
        this.graphics.text(CalendarDay[int((365 + i * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (i - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / this.U_scale);
        if (this.JoinDays > 1) {
          //this.graphics.text(("±" + int(this.JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + i - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
        }
      }
    }
  
    this.drawInfo(sx_Plot, 1);
  }
  
  
  void drawInfo (float sx_Plot, float V_belowLine) {
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
    this.graphics.textAlign(LEFT, TOP);
  
    if (CurrentDataSource == dataID_CLIMATE_TMYEPW) this.graphics.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + STATION.getCity() + "\n"), -1.5 * sx_Plot / this.U_scale, (1.0 + V_belowLine) * sx_Plot / this.U_scale);
    if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + STATION.getCity() + "\n("), -1.5 * sx_Plot / this.U_scale, (1.0 + V_belowLine) * sx_Plot / this.U_scale);
    if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + STATION.getCity() + "\n("), -1.5 * sx_Plot / this.U_scale, (1.0 + V_belowLine) * sx_Plot / this.U_scale);  
    if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + STATION.getCity() + "\n(" + nf(TIME_Year, 4) + "_" + nf(TIME_Month, 2) + "_" + nf(TIME_Day, 2) + "_" + nf(TIME_Hour, 2) + ")"), -1.5 * sx_Plot / this.U_scale, (1.0 + V_belowLine) * sx_Plot / this.U_scale);
    if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) this.graphics.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + STATION.getCity() + "\n(" + nf(TIME_Year, 4) + "_" + nf(TIME_Month, 2) + "_" + nf(TIME_Day, 2) + "_" + nf(TIME_Hour, 2) + ")"), -1.5 * sx_Plot / this.U_scale, (1.0 + V_belowLine) * sx_Plot / this.U_scale);
  
    switch(this.skyScenario) {
    case 1 : 
      this.graphics.stroke(0, 0, 0); 
      this.graphics.fill(0, 0, 0); 
      break;
    case 2 : 
      this.graphics.stroke(0, 0, 255); 
      this.graphics.fill(0, 0, 255); 
      break;
    case 3 : 
      this.graphics.stroke(0, 127, 0); 
      this.graphics.fill(0, 127, 0); 
      break;
    case 4 : 
      this.graphics.stroke(255, 0, 0); 
      this.graphics.fill(255, 0, 0); 
      break;
    }
  
    this.graphics.textAlign(RIGHT, TOP);
  
    this.graphics.text(skyScenario_Title[this.skyScenario], (this.j_End - this.j_Start - 0.05) * sx_Plot, (0.3 + V_belowLine) * sx_Plot / this.U_scale);
  }  
  
  
  
  void drawData (float[] Ax_LINES, float[] Ay_LINES, float[] Az_LINES, float[] Bx_LINES, float[] By_LINES, float[] Bz_LINES) {
    //this.graphics.stroke(this.color_data_raws);
    //this.graphics.fill(this.color_data_raws);
    //this.graphics.strokeWeight(this.T_scale * 1);
  
    this.graphics.stroke(0, SOLARCHVISION_getOpacity(this.O_scale));
    this.graphics.fill(0, SOLARCHVISION_getOpacity(this.O_scale));
    this.graphics.strokeWeight(this.T_scale * 0.5);
  
    for (int i = 0; i < Ax_LINES.length; i++) {
      this.graphics.line(Ax_LINES[i], Ay_LINES[i], Bx_LINES[i], By_LINES[i]);
    }
  }
  
  
  void drawProbs (int i, int j, float[] _valuesSUM, float[] _valuesNUM, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    int PAL_TYPE = this.Pallet_PROB_CLR; 
    int PAL_DIR = this.Pallet_PROB_DIR;  
    float PAL_Multiplier = this.Pallet_PROB_MLT;
  
    float txt_max_width = (this.SumInterval * this.S_View * 100 / 24.0) * this.U_scale;
    float txt_max_height = this.Pix;
    if (txt_max_height > txt_max_width) this.graphics.textSize(0.9 * txt_max_width);
    else this.graphics.textSize(0.9 * txt_max_height);
  
    this.graphics.textAlign(CENTER, CENTER);
  
    this.graphics.strokeWeight(this.T_scale * 0);
  
    float min_v = tan_ang(89.99);
    float max_v = tan_ang(-89.99);
  
    for (int k = 0; k < _valuesSUM.length; k++) {
      if (is_undefined_FLOAT(_valuesSUM[k]) == false) {
        if (min_v > _valuesSUM[k]) min_v = _valuesSUM[k];
        if (max_v < _valuesSUM[k]) max_v = _valuesSUM[k];
      }
    } 
  
    if ((min_v != tan_ang(89.99)) && (max_v != tan_ang(-89.99))) {    
      min_v = roundTo((min_v * abs(sy_Plot)), this.Pix) / this.Pix;
      max_v = roundTo((max_v * abs(sy_Plot)), this.Pix) / this.Pix;
  
      if (CurrentLayer_id == LAYER_winddir.id) min_v = 0;
  
      int[] _probs;
      int total_probs = 0;
  
      _probs = new int [int((1 + max_v - min_v))];
  
      for (int k = 0; k < _valuesSUM.length; k++) {
        if (is_undefined_FLOAT(_valuesSUM[k]) == false) {
          float the_value = _valuesSUM[k];
  
          if (CurrentLayer_id == LAYER_winddir.id) {
            if (roundTo((the_value * abs(sy_Plot)), this.Pix) >= (360 * abs(sy_Plot))) the_value -= 360;
          }
  
          int h = int(roundTo((roundTo((the_value * abs(sy_Plot)), this.Pix) / this.Pix) - min_v, 1));
          _probs[h] += 1;
          total_probs += 1;
        }
      }
  
      if (total_probs != 0) {
        for (int n = 0; n < _probs.length; n++) {
          float prob_V = 1.0 * _probs[n] / total_probs;
  
          //if (int(roundTo(100 * prob_V, 1)) > 0) {
          if ((100 * prob_V) > 0) {
  
            float _u = PAL_Multiplier * prob_V;
  
            if (PAL_DIR == -1) _u = 1 - _u;
            if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_DIR == 2) _u =  0.5 * _u;
  
            float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
  
            this.graphics.strokeWeight(this.T_scale * 0); 
            this.graphics.rect((j + ((i + 1) / 24.0)) * sx_Plot, -((min_v + n) * this.Pix) - 0.5 * this.Pix, -(this.SumInterval * this.S_View * 100 / 24.0) * this.U_scale, this.Pix); 
  
            if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
              this.graphics.stroke(127);
              this.graphics.fill(127);
              this.graphics.strokeWeight(0);
            } else {
              this.graphics.stroke(255);
              this.graphics.fill(255);
              this.graphics.strokeWeight(2);
            }   
            this.graphics.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (j + ((i + 1) / 24.0)) * sx_Plot - 0.5 * (this.SumInterval * this.S_View * 100 / 24.0) * this.U_scale, -((min_v + n) * this.Pix) - 0.05 * txt_max_height);
  
            if ((this.Export_info_prob) && (this.DisplayProbs)) {
              FILE_outputProbs[(j - this.j_Start)].print(nfs((min_v + n) * this.Pix / abs(sy_Plot) - this.V_offset, 5, 5) + ":\t" + nf(100 * prob_V, 3, 3) + "\t");
            }
          }
        }  
  
        if ((this.Export_info_prob) && (this.DisplayProbs)) {
          FILE_outputProbs[(j - this.j_Start)].println("");
        }
      }
    }
  
    float pal_length = 400;
    for (int q = 0; q < 11; q++) {
      float prob_V = 10 * q / 100.0;
  
      float _u = PAL_Multiplier * prob_V;
  
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);     
  
      this.graphics.strokeWeight(0); 
  
      float Y_OFFSET = (0.25 + this.V_belowLine) * sx_Plot / this.U_scale;
  
      //this.graphics.rect((700 + q * (pal_length / 11.0)) * this.S_View, 125 * this.S_View, (pal_length / 11.0) * this.S_View, 20 * this.S_View); 
      this.graphics.rect((700 + q * (pal_length / 11.0)) * this.S_View, Y_OFFSET, (pal_length / 11.0) * this.S_View, 20 * this.S_View);
  
      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }   
  
      this.graphics.textSize(15.0 * this.S_View);
      this.graphics.textAlign(CENTER, CENTER);
      //this.graphics.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * this.S_View, (10 + 125 - 0.05 * 20) * this.S_View);
      this.graphics.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * this.S_View, Y_OFFSET + (10 - 0.05 * 20) * this.S_View);
    }
  }
  
  
  void drawSorted (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    int PAL_TYPE = this.Pallet_SORT_CLR; 
    int PAL_DIR = this.Pallet_SORT_DIR;  
    float PAL_Multiplier = this.Pallet_SORT_MLT;
  
    float[] sorted_valuesA = sort(_valuesA);
    int num_sorted_valuesA = 0;
    for (int l = 0; l < sorted_valuesA.length; l++) {
      if (is_undefined_FLOAT(sorted_valuesA[l]) == false) {
        num_sorted_valuesA += 1;
      } else break;
    }
  
    float[] sorted_valuesB = sort(_valuesB);
    int num_sorted_valuesB = 0;
    for (int l = 0; l < sorted_valuesB.length; l++) {
      if (is_undefined_FLOAT(sorted_valuesB[l]) == false) {
        num_sorted_valuesB += 1;
      } else break;
    }
  
    int num_sorted_valuesAB = min(num_sorted_valuesA, num_sorted_valuesB);
  
    for (int l = 0; l < (num_sorted_valuesAB - 1); l++) {
      float sort_V = 1.1 * (0.5 - ((num_sorted_valuesAB - (l + 1)) / float(num_sorted_valuesAB)));
  
      float _u = 0.5 + 0.5 * (PAL_Multiplier * sort_V);
  
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);    
  
      this.graphics.strokeWeight(this.T_scale * 0.0); 
      //this.graphics.rect((j + ((i + 1) / 24.0)) * sx_Plot, sorted_valuesA[l] * sy_Plot, -(1 * 100 / 24.0) * this.U_scale, (sorted_valuesA[(l + 1)] - sorted_valuesA[l]) * sy_Plot);
  
      float P1x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P2x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P3x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
      float P4x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
  
      float P1y = sorted_valuesA[l] * sy_Plot;
      float P2y = sorted_valuesA[(l + 1)] * sy_Plot;
      float P3y = sorted_valuesB[(l + 1)] * sy_Plot;
      float P4y = sorted_valuesB[l] * sy_Plot; 
  
      this.graphics.quad(P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y);
      /*
      this.graphics.stroke(255);
       this.graphics.strokeWeight(this.T_scale * 0.5); 
       this.graphics.line(P1x, P1y, P4x, P4y); 
       this.graphics.line(P2x, P2y, P3x, P3y);
       */
    }
  
    String[] _txt = {
      "MIN", "", "25%", "", "MED", "", "75%", "", "MAX"
    }; 
    float pal_length = 400;
    for (int q = 0; q < 9; q++) {
      float sort_V = 1.1 * (q - 4) / 8.0;
  
      float _u = 0.5 + 0.5 * (PAL_Multiplier * sort_V);
  
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);     
  
      float Y_OFFSET = (0.25 + this.V_belowLine) * sx_Plot / this.U_scale;
  
      //this.graphics.strokeWeight(0.0);
      this.graphics.stroke(255); 
      this.graphics.strokeWeight(0.5); 
      //this.graphics.rect((700 + q * (pal_length / 9.0)) * this.S_View, 125 * this.S_View, (pal_length / 9.0) * this.S_View, 20 * this.S_View);
      this.graphics.rect((700 + q * (pal_length / 9.0)) * this.S_View, Y_OFFSET, (pal_length / 9.0) * this.S_View, 20 * this.S_View);
  
      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }   
  
      this.graphics.textSize(15.0 * this.S_View);
      this.graphics.textAlign(CENTER, CENTER);
      //this.graphics.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * this.S_View, (10 + 125 - 0.05 * 20) * this.S_View);
      this.graphics.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * this.S_View, Y_OFFSET + (10 - 0.05 * 20) * this.S_View);
    }
  }
  
  
  void drawNormals (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    float[] NormalsA = SOLARCHVISION_NORMAL(_valuesA);
    float[] NormalsB = SOLARCHVISION_NORMAL(_valuesB);
  
    if (CurrentLayer_id == LAYER_winddir.id) {
      float[] X_valuesA;
      float[] Y_valuesA;
      X_valuesA = new float [_valuesA.length];
      Y_valuesA = new float [_valuesA.length];
  
      for (int l = 0; l < _valuesA.length; l++) {
        if (is_undefined_FLOAT(_valuesA[l]) == false) {
          X_valuesA[l] = cos_ang(90 - _valuesA[l]); 
          Y_valuesA[l] = sin_ang(90 - _valuesA[l]);
        } else {
          X_valuesA[l] = FLOAT_undefined; 
          Y_valuesA[l] = FLOAT_undefined;
        }
      }
  
      float[] X_NormalsA = SOLARCHVISION_NORMAL(X_valuesA);
      float[] Y_NormalsA = SOLARCHVISION_NORMAL(Y_valuesA);
  
      for (int l = 0; l < NormalsA.length; l++) {
        if (is_undefined_FLOAT(NormalsA[l]) == false) {
          NormalsA[l] = 90 - atan2_ang(Y_NormalsA[l], X_NormalsA[l]);
          if (NormalsA[l] < 0) NormalsA[l] += 360;
        }
  
        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsA[l] = FLOAT_undefined;
        }
      }
  
      float[] X_valuesB;
      float[] Y_valuesB;
      X_valuesB = new float [_valuesB.length];
      Y_valuesB = new float [_valuesB.length];
  
      for (int l = 0; l < _valuesB.length; l++) {
        if (is_undefined_FLOAT(_valuesB[l]) == false) {
          X_valuesB[l] = cos_ang(90 - _valuesB[l]); 
          Y_valuesB[l] = sin_ang(90 - _valuesB[l]);
        } else {
          X_valuesB[l] = FLOAT_undefined; 
          Y_valuesB[l] = FLOAT_undefined;
        }
      }
  
      float[] X_NormalsB = SOLARCHVISION_NORMAL(X_valuesB);
      float[] Y_NormalsB = SOLARCHVISION_NORMAL(Y_valuesB);
  
      for (int l = 0; l < NormalsB.length; l++) {
        if (is_undefined_FLOAT(NormalsB[l]) == false) {
          NormalsB[l] = 90 - atan2_ang(Y_NormalsB[l], X_NormalsB[l]);
          if (NormalsB[l] < 0) NormalsB[l] += 360;
        }
  
        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsB[l] = FLOAT_undefined;
        }
      }
    }
    int _OPACITY = 191;
  
    for (int l = 0; l < 9; l++) {
      //for (int l = 0; l < 3; l++) {
      //for (int l = 3; l < 9; l++) {
  
      //for (int p = 0; p < 3; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      //for (int p = 0; p < 1; p++) { 
      //int l = this.ImpactLayer;
  
  
      if (l == STAT_N_Middle) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 191, 0);
        this.graphics.fill(0, 191, 0);
      } else if (l == STAT_N_MidHigh) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(191, 0, 0);
        this.graphics.fill(191, 0, 0);
      } else if (l == STAT_N_MidLow) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 191);
        this.graphics.fill(0, 0, 191);
      } else if (l == STAT_N_Max) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(255, 127, 127);
        this.graphics.fill(255, 127, 127);
      } else if (l == STAT_N_Min) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 127, 255);
        this.graphics.fill(127, 127, 255);
      } else if (l == STAT_N_M50) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 127, 0);
        this.graphics.fill(0, 127, 0);
      } else if (l == STAT_N_M75) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 0, 0);
        this.graphics.fill(127, 0, 0);
      } else if (l == STAT_N_M25) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 127);
        this.graphics.fill(0, 0, 127);
      } else {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 0);
        this.graphics.fill(0, 0, 0);
      }
  
  
      
      if (l == this.ImpactLayer) {
       this.graphics.strokeWeight(this.T_scale * 4);
       this.graphics.stroke(127, 127, 127, _OPACITY);
       this.graphics.fill(127, 127, 127, _OPACITY);
      }
      
  
  
  
      float z_l = 60; //l;
      if (l == STAT_N_M75) z_l = 61;
      if (l == STAT_N_M50) z_l = 61;
      if (l == STAT_N_M25) z_l = 61;
      if (l == STAT_N_Ave) z_l = 62;
  
      if ((is_undefined_FLOAT(NormalsA[l]) == false) && (is_undefined_FLOAT(NormalsB[l]) == false)) {
        this.graphics.line((j + ((i + 0.5) / 24.0)) * sx_Plot, NormalsA[l] * sy_Plot, (j + ((i + 0.5 + TIME_Interval) / 24.0)) * sx_Plot, NormalsB[l] * sy_Plot);
      } 
  
      if ((this.Export_info_norm) && (this.DisplayNormals)) {
        if (is_undefined_FLOAT(NormalsA[l]) == false) FILE_outputNorms[(j - this.j_Start)].print(nfs(NormalsA[l] - this.V_offset, 5, 5) + "\t"); 
        else FILE_outputNorms[(j - this.j_Start)].print("[undefined]\t");
      }
    }
    if ((this.Export_info_norm) && (this.DisplayNormals)) FILE_outputNorms[(j - this.j_Start)].println();
  }  


 
  void plotHourly (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    
    int DATA_start = getStart_CurrentDataSource();
    int DATA_end = getEnd_CurrentDataSource();
    String DATA_reference = getReference_CurrentDataSource();
  
    this.Pix = (100.0 * this.S_View / this.LevelPix);
  
    this.graphics.pushMatrix();
    this.graphics.translate(x_Plot, y_Plot);
  
    this.color_data_raws = color(0, 0, 63, SOLARCHVISION_getOpacity(this.O_scale));
  
    this.drawTimeGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  
    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;
    
  
    if (this.PrintTtitle) {
  
      this.graphics.stroke(0); 
      this.graphics.fill(0);
      this.graphics.strokeWeight(this.T_scale * 0);
  
      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER); 
  
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, (0.5 + this.V_belowLine) * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, (0.5 + this.V_belowLine) * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, (0.5 + this.V_belowLine) * sx_Plot / this.U_scale);
  
  
      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(LEFT, CENTER); 
      this.graphics.text((CurrentLayer_descriptions[Language_Active]), 0, (0.5 + this.V_belowLine) * sx_Plot / this.U_scale);
    }

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
  
    float[] _valuesA;
    float[] _valuesB; 
    _valuesA = new float [count_k * this.JoinDays];
    _valuesB = new float [count_k * this.JoinDays]; 
  
    float[] _valuesSUM; 
    float[] _valuesNUM;
    int _interval = 0;
    _valuesSUM = new float [count_k * this.JoinDays];
    _valuesNUM = new float [count_k * this.JoinDays];
    
    for (int k = 0; k < count_k; k++) {
      for (int j_ADD = 0; j_ADD < this.JoinDays; j_ADD++) {
        _valuesA[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
        _valuesB[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
        _valuesSUM[(k * this.JoinDays + j_ADD)] = 0; // Note: must be initialized to zero; not undefined.
        _valuesNUM[(k * this.JoinDays + j_ADD)] = 0;
      }  
    }
  
    float[] Ax_LINES = new float [0];
    float[] Ay_LINES = new float [0];
    float[] Az_LINES = new float [0];
    float[] Bx_LINES = new float [0];
    float[] By_LINES = new float [0];
    float[] Bz_LINES = new float [0];
  
    FILE_outputRaw = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputNorms = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputProbs = new PrintWriter [(this.j_End - this.j_Start)];
  
    String Main_name = MAKE_MainName();
  
    for (int j = this.j_Start; j < this.j_End; j++) { 
  
      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.textAlign(CENTER, CENTER); 
  
      if ((this.U_scale >= 0.75) || (((j - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
        this.graphics.text(CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / this.U_scale);
        if (this.JoinDays > 1) {
          this.graphics.text(("±" + int(this.JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
        }
      }
  
      String _FilenamesAdd = "";
      if (this.JoinDays > 1) {
        _FilenamesAdd = ("±" + int(this.JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
      }
      if ((this.Export_info_node) && (this.DisplayRaws)) {
        FILE_outputRaw[(j - this.j_Start)] = createWriter(ExportFolder + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_node_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
        FILE_outputRaw[(j - this.j_Start)].println(CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly data");
  
        FILE_outputRaw[(j - this.j_Start)].print("Hour\t");
        for (int k = 0; k < count_k; k++) {   
          FILE_outputRaw[(j - this.j_Start)].print(nf(k, 4) + "        \t");
        }
        FILE_outputRaw[(j - this.j_Start)].println("");
      }
      if ((this.Export_info_norm) && (this.DisplayNormals)) {
        FILE_outputNorms[(j - this.j_Start)] = createWriter(ExportFolder + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_norm_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
        FILE_outputNorms[(j - this.j_Start)].println(CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly normal");
        FILE_outputNorms[(j - this.j_Start)].print("Hour\t");
        for (int l = 0; l < 9; l++) {
          FILE_outputNorms[(j - this.j_Start)].print(STAT_N_Title[l] + "\t");
        }
        FILE_outputNorms[(j - this.j_Start)].println("");
      }
      if ((this.Export_info_prob) && (this.DisplayProbs)) {
        FILE_outputProbs[(j - this.j_Start)] = createWriter(ExportFolder + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_prob_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
        FILE_outputProbs[(j - this.j_Start)].println(CalendarDay[int((365 + j * this.PerDays + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly probabilities");
  
        FILE_outputProbs[(j - this.j_Start)].print("Hour:\t");
        FILE_outputProbs[(j - this.j_Start)].println("");
      }
  
      for (int i = 0; i < 24; i++) {
        if ((this.Export_info_node) && (this.DisplayRaws)) FILE_outputRaw[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.Export_info_norm) && (this.DisplayNormals)) FILE_outputNorms[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.Export_info_prob) && (this.DisplayProbs)) FILE_outputProbs[(j - this.j_Start)].print(nf(i, 2) + "\t");
  
        for (int k = 0; k < count_k; k++) {   
          for (int j_ADD = 0; j_ADD < this.JoinDays; j_ADD++) {
  
            _valuesA[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
            _valuesB[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
            _valuesSUM[(k * this.JoinDays + j_ADD)] = 0;
            _valuesNUM[(k * this.JoinDays + j_ADD)] = 1;
  
            float[] COL = PAINT.getColorStyle(COLOR_STYLE_Current, (1.0 * k / (1 + DATA_end - DATA_start)));
            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
  
  
            int now_k = k + start_k;
            int now_i = i;
            int now_j = int(j * this.PerDays + (j_ADD - int(roundTo(0.5 * this.JoinDays, 1))) + TIME_BeginDay + 365) % 365;
  
  
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }
  
            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, CurrentLayer_id); 
          
            if (is_undefined_FLOAT(Pa)) {
              _valuesA[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
  
              if ((this.Export_info_node) && (this.DisplayRaws)) FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
            } else {
              int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
  
              if (memberCount == 1) {
                _valuesA[(k * this.JoinDays + j_ADD)] = Pa;
                _valuesA[(k * this.JoinDays + j_ADD)] += this.V_offset;
  
                _valuesSUM[(k * this.JoinDays + j_ADD)] += _valuesA[(k * this.JoinDays + j_ADD)];
                _valuesNUM[(k * this.JoinDays + j_ADD)] += 1;
  
                if ((this.Export_info_node) && (this.DisplayRaws)) {
                  if (is_undefined_FLOAT(_valuesA[(k * this.JoinDays + j_ADD)]) == false) FILE_outputRaw[(j - this.j_Start)].print(nfs(_valuesA[(k * this.JoinDays + j_ADD)] - this.V_offset, 5, 5) + "\t"); 
                  else FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
                }
  
                if (next_k < (1 + DATA_end - DATA_start)) {
  
                  Pb = getValue_CurrentDataSource(next_i, next_j, next_k, CurrentLayer_id);                 
                  
                  if (is_undefined_FLOAT(Pb)) {
                    _valuesB[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    _valuesB[(k * this.JoinDays + j_ADD)] = Pb;
                    _valuesB[(k * this.JoinDays + j_ADD)] += this.V_offset;
  
                    if (this.DisplayRaws) {
                      if ((CurrentLayer_id == LAYER_winddir.id) && (abs(_valuesB[(k * this.JoinDays + j_ADD)] - _valuesA[(k * this.JoinDays + j_ADD)]) > 180)) {
                      } else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * this.JoinDays + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * this.W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * this.JoinDays + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * this.W_scale);
                      }
                    }
                  }
                }
              } else {
                if ((this.Export_info_node) && (this.DisplayRaws)) FILE_outputRaw[(j - this.j_Start)].print("not_the_case\t");
              }
            }
          }
        }
        
  
        if ((this.Export_info_node) && (this.DisplayRaws)) FILE_outputRaw[(j - this.j_Start)].println();
  
  
        _interval += 1; 
        if ((_interval % this.SumInterval) == 0) {
          for (int k = 0; k < count_k; k++) {
            for (int j_ADD = 0; j_ADD < this.JoinDays; j_ADD++) {
              _valuesSUM[(k * this.JoinDays + j_ADD)] += _valuesA[(k * this.JoinDays + j_ADD)];
              _valuesNUM[(k * this.JoinDays + j_ADD)] += 1;
  
              if (_valuesNUM[(k * this.JoinDays + j_ADD)] != 0) {
                _valuesSUM[(k * this.JoinDays + j_ADD)] /= _valuesNUM[(k * this.JoinDays + j_ADD)];
              }
              else {
                _valuesSUM[(k * this.JoinDays + j_ADD)] = FLOAT_undefined;
              }
            }
          }        
          if (this.DisplayProbs) {
            this.drawProbs(i, j, _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
          }
          for (int k = 0; k < count_k; k++) {
            for (int j_ADD = 0; j_ADD < this.JoinDays; j_ADD++) {
              _valuesSUM[(k * this.JoinDays + j_ADD)] = 0;
              _valuesNUM[(k * this.JoinDays + j_ADD)] = 0;
            }
          }
        }      
  
        if (this.DisplaySorted) {
          this.drawSorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
  
        if (this.DisplayNormals) {
          this.drawNormals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
      }
      
      if ((this.Export_info_node) && (this.DisplayRaws)) {
        FILE_outputRaw[(j - this.j_Start)].flush(); 
        FILE_outputRaw[(j - this.j_Start)].close();
      }
  
      if ((this.Export_info_norm) && (this.DisplayNormals)) {
        FILE_outputNorms[(j - this.j_Start)].flush(); 
        FILE_outputNorms[(j - this.j_Start)].close();
      }
  
      if ((this.Export_info_prob) && (this.DisplayProbs)) {
        FILE_outputProbs[(j - this.j_Start)].flush(); 
        FILE_outputProbs[(j - this.j_Start)].close();
      }
      
  
    }
  
    if (this.DisplayRaws) {
      this.drawData(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
    }    
  
    this.graphics.popMatrix();
  } 
  
  
  void plotSetup () {
  
    if (this.plotSetup == 14) {
  
      if (FrameVariation == 2) {
  
        for (int p = 0; p < 3; p++) { 
          this.ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3) + p;
  
          SOLARCHVISION_PlotIMPACT(0, (175 - p * 350) * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
        }
        this.ImpactLayer = pre_STUDY_ImpactLayer;
  
        this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
      } else {
  
        if ((this.PlotImpacts == 8) || (this.PlotImpacts == 9)) {
  
          int keep_TIME_BeginDay = TIME_BeginDay;
          float keep_STUDY_PerDays = this.PerDays;
          int keep_STUDY_j_End = this.j_End;
          float keep_STUDY_U_scale = this.U_scale;
  
          TIME_BeginDay = 183; //0; // 183: to put the summer diagram on the left similar to the YC book
          this.PerDays = 183;
          this.j_End = 2;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
  
          SOLARCHVISION_PlotIMPACT(0, 0 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
          TIME_BeginDay = keep_TIME_BeginDay;
          this.PerDays = keep_STUDY_PerDays;
          this.j_End = keep_STUDY_j_End;
          this.U_scale = keep_STUDY_U_scale;
        } else {
          SOLARCHVISION_PlotIMPACT(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
          this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
        }
      }
    }  
  
    // -----------------------------------------------
  
    if (this.plotSetup == -2) {
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
        pre_TIME_Date = TIME_Date;
        int keep_TIME_BeginDay = TIME_BeginDay;
        int delta = 4;
  
        this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        TIME_Date -= delta;
        SOLARCHVISION_update_date();
        TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
        update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        TIME_BeginDay = (TIME_BeginDay + delta) % 365;
        this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        TIME_Date -= delta;
        SOLARCHVISION_update_date();
        TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
        update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        TIME_BeginDay = (TIME_BeginDay + 2 * delta) % 365;
        this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        TIME_Date -= delta;
        SOLARCHVISION_update_date();
        TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
        update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        TIME_BeginDay = (TIME_BeginDay + 3 * delta) % 365;
        this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        TIME_Date = pre_TIME_Date;
        SOLARCHVISION_update_date();
        TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
        update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        TIME_BeginDay = keep_TIME_BeginDay;
      }
    }
  
  
    if (this.plotSetup == -1) {
      pre_CurrentDataSource = CurrentDataSource;
  
      CurrentDataSource = dataID_ENSEMBLE_FORECAST; 
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false; 
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      CurrentDataSource = dataID_CLIMATE_CWEEDS;
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
  
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false; 
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      CurrentDataSource = pre_CurrentDataSource;
    }
  
  
    if (this.plotSetup == 0) {
  
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
    }
  
  
    if (this.plotSetup == 1) {
  
      DevelopLayer_id = CurrentLayer_id;
      changeCurrentLayerTo(LAYER_developed.id); 
  
      Develop_Option = DEV_OP_01;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      Develop_Option = DEV_OP_02;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      Develop_Option = DEV_OP_03;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      Develop_Option = DEV_OP_04;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      Develop_Option = pre_Develop_Option;
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }  
  
  
    if (this.plotSetup == 2) {
      if (CurrentLayer_id != LAYER_developed.id) {
  
  
        this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        DevelopLayer_id = CurrentLayer_id;
        changeCurrentLayerTo(LAYER_developed.id);
  
        Develop_Option = DEV_OP_06; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        Develop_Option = DEV_OP_07; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        Develop_Option = DEV_OP_08; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
        changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
      }
    }  
  
  
    if (this.plotSetup == 3) {
  
      changeCurrentLayerTo(LAYER_windspd200hPa.id);
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_pressure.id);
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_heightp500hPa.id);
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_thicknesses_1000_500.id);
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }
  
  
    if (this.plotSetup == 4) {
  
      changeCurrentLayerTo(LAYER_windspd.id);
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_precipitation.id);
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_relhum.id);
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_drybulb.id);
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }  
  
  
    if (this.plotSetup == 5) {
  
      changeCurrentLayerTo(LAYER_dirnorrad.id);
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_difhorrad.id);
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_developed.id);
      Develop_Option = DEV_OP_01; 
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_developed.id);
      Develop_Option = DEV_OP_03; 
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
      Develop_Option = pre_Develop_Option;
    }
  
  
    if (this.plotSetup == 6) {
  
      this.skyScenario = 4;
      this.plotHourly(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.skyScenario = 3;
      this.plotHourly(0, -175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.skyScenario = 2;
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.skyScenario = 1;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.skyScenario = pre_STUDY_SkyScenario;
    }  
  
  
    if (this.plotSetup == 7) {
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true; 
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false;
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = -2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = -1;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts;
    }
  
  
    if (this.plotSetup == 8) {    
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false; 
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 3;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
  
    if (this.plotSetup == 9) {
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false; 
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts;
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
    if (this.plotSetup == 10) {
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false;
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 4;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
    if (this.plotSetup == 11) {
  
      this.DisplaySorted = false;
      this.DisplayNormals = false;
      this.DisplayRaws = true;
      this.DisplayProbs = true;
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.DisplaySorted = true;
      this.DisplayNormals = true;
      this.DisplayRaws = false;
      this.DisplayProbs = false;
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 5;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }  
  
    if (this.plotSetup == 12) {
  
      if (SOLARCHVISION_automated != 0) {
        this.DisplaySorted = false;
        this.DisplayNormals = true;
        this.DisplayRaws = false;
        this.DisplayProbs = true;
      }
  
      changeCurrentLayerTo(LAYER_windspd.id); 
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      //changeCurrentLayerTo(LAYER_precipitation.id); 
      //DevelopLayer_id = CurrentLayer_id);
      //changeCurrentLayerTo(LAYER_developed.id); 
      //Develop_Option = DEV_OP_09;
      //SOLARCHVISION_postProcess_developDATA(CurrentDataSource); 
      //this.plotHourly(0, 325 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_drybulb.id); 
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 1;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = -2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
    }
  
    if (this.plotSetup == 13) {
  
      if (SOLARCHVISION_automated != 0) {
        this.DisplaySorted = true;
        this.DisplayNormals = true;
        this.DisplayRaws = false;
        this.DisplayProbs = false;
      }
  
      changeCurrentLayerTo(LAYER_dirnorrad.id); 
      this.plotHourly(0, 175 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View); 
  
      //changeCurrentLayerTo(LAYER_glohorrad.id; //LAYER_difhorrad.id; // <<<<<<<<<<<<<< 
      //this.plotHourly(0, 325 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      changeCurrentLayerTo(LAYER_cloudcover.id);
      this.plotHourly(0, 525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 0;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
      this.PlotImpacts = 2; //4;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.S_View, 0, (100.0 * this.U_scale * this.S_View), (-1.0 * this.V_scale * this.S_View), 1.0 * this.S_View);
  
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  }  
 

  void drawView () {
  
    cursor(WAIT);
  
  
    if (this.update) {
  
      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_JPG) this.ImageScale = 2;
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;  
      this.T_scale *= this.ImageScale;
      //////////////////////////////////  
  
      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(CreateStamp(1) + "this.") + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }  
  
      DrawnFrame += 1;
      println("frame:", DrawnFrame);    
  
      if (DevelopData_update) {
        if (CurrentLayer_id == LAYER_developed.id) {
          SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
    
        }
      }     
  
  
      this.S_View = (this.dX / 2100.0);
      this.U_scale = 18.0 / float(this.j_End - this.j_Start);
  
  
      this.X_Coordinate = -0.333 * this.dX;      
  
      this.Y_Coordinate = 1.0 * this.dY;
  
  
      this.graphics.background(255);
  
      this.graphics.blendMode(BLEND);
  
      this.graphics.strokeJoin(ROUND); 
  
      this.graphics.textFont(SOLARCHVISION_font);
  
      this.graphics.strokeWeight(0);
  
      //this.graphics.translate(this.X_Coordinate * -0.25, this.Y_Coordinate * 0.5); 
      this.graphics.translate(this.X_Coordinate * -0.425, this.Y_Coordinate * 0.5);
  
      this.plotSetup();
  
      //this.graphics.translate(this.X_Coordinate * 0.25, this.Y_Coordinate * 0.5);
      this.graphics.translate(this.X_Coordinate * 0.425, this.Y_Coordinate * 0.5);
  
      this.graphics.strokeWeight(this.T_scale * 1);
  
      this.graphics.stroke(63);
      this.graphics.fill(63);
      this.graphics.textAlign(CENTER, CENTER);
  
      String _text = "SOLARCHVISION post-processing";
  
      if (CurrentDataSource == dataID_CLIMATE_TMYEPW) _text += " based on typical-year data for Building Energy Simulation";  //"(TMYEPW - U.S. Department of Energy)";
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) _text += " based on long-term Canadian Weather Energy and Engineering Datasets (CWEEDS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) _text += " based on Environment and Climate Change Canada's Climate website";
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) _text += " based on the North American Ensemble Forecast System (NAEFS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) _text += " based on real-time Surface Weather Observation (SWOB - Environment and Climate Change Canada)";
  
      //_text += ", www.solarchvision.com";
  
      this.graphics.textSize(this.dX * 0.01);
      ///this.graphics.text(_text, this.dX * 0.55, this.dY * -0.1666 / this.R_View, 0);
  
      if (this.record_PDF) {
        endRecord();
  
        String myFile = MAKE_Filename(CreateStamp(0) + "this.") + ".pdf";
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();
  
        if ((this.record_JPG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(CreateStamp(1) + "this.") + ".jpg";
          this.graphics.save(myFile);
          SOLARCHVISION_explore_output(myFile);
          println("File created:" + myFile);
        }
  
        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;
      this.T_scale /= this.ImageScale;
      //////////////////////////////////
  
      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.update = false; //1;
      } else {
        this.update = false;
      }
  
  
      if ((this.record_JPG) || (this.record_AUTO == false)) this.record_JPG = false;
    }
  
    this.Export_info_node = false;
    this.Export_info_norm = false;
    this.Export_info_prob = false;
  
    cursor(ARROW);
  }
  
  

 
}






float SOLARCHVISION_Spinner (float x, float y, int update1, int update2, int update3, String caption, float v, float min_v, float max_v, float stp_v) {

  float new_value = v;

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v;    

  float cx, cy, cr;
  float w1, w2, h, o, t_o; 

  //w1 = 32.5 * ROLLOUT.S_View;
  //w2 = 142.5 * ROLLOUT.S_View;

  w1 = 100 * ROLLOUT.S_View;
  w2 = 200 * ROLLOUT.S_View;

  h = 16 * ROLLOUT.S_View;
  o = 2 * ROLLOUT.S_View;
  t_o = h * ROLLOUT.S_View / 8.0;

  STUDY.Y_control += 25 * ROLLOUT.S_View; //(h + 2 * o) * 1.25;

  strokeWeight(0); 
  stroke(0); 
  fill(0);
  rect(x + o, y - (h / 2) - o, 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  rect(x + o, y - (h / 2) - o + 0.5 * (h + 2 * o), 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  stroke(255); 
  fill(255);
  cx = x + o + 0.25 * (h + 2 * o);
  cy = y - (h / 2) - o + 0.25 * (h + 2 * o);
  cr = 0.25 * (h + 2 * o);
  triangle(cx + cr * cos_ang(270), cy + 0.75 * cr * sin_ang(270), cx + 0.75 * cr * cos_ang(30), cy + 0.75 * cr * sin_ang(30), cx + 0.75 * cr * cos_ang(150), cy + 0.75 * cr * sin_ang(150));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {
    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value *= abs(stp_v);
      } else { 
        new_value += abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = max_v;
    }
  }

  cy += 2 * cr;
  triangle(cx + cr * cos_ang(90), cy + 0.75 * cr * sin_ang(90), cx + 0.75 * cr * cos_ang(210), cy + 0.75 * cr * sin_ang(210), cx + 0.75 * cr * cos_ang(330), cy + 0.75 * cr * sin_ang(330));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {

    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value /= abs(stp_v);
      } else { 
        new_value -= abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = min_v;
    }
  }

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v; 



  strokeWeight(0); 
  stroke(191); 
  fill(191);
  rect(x - (w1 + w2) - o, y - (h / 2) - o, (w1 + w2) + 2 * o, h + 2 * o);

  stroke(255); 
  fill(255);
  rect(x - w1, y - (h / 2), w1, h);

  float q = 0;

  if (max_v - min_v > 0.001) {
    q = (new_value - min_v) / (max_v - min_v);
  }

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x - w1, y - (h / 2), x, y + (h / 2)) == 1) {

    q = 1;

    if (max_v - min_v > 0.001) {
      q = (SOLARCHVISION_X_clicked - (x - w1)) / w1;
    }

    new_value = min_v + q * (max_v - min_v);

    if (new_value < min_v) new_value = max_v; 
    if (new_value > max_v) new_value = min_v;

    ROLLOUT.update = true;
  }

  strokeWeight(0); 
  stroke(191, 255, 191); 
  fill(191, 255, 191);
  rect(x - w1, y - (h / 2), q * w1, h);          


  strokeWeight(2); 
  stroke(0); 
  noFill();
  rect(x - w1, y - (h / 2), w1, h);    

  strokeWeight(0);
  stroke(0); 
  fill(0);
  textSize(1.0 * h);
  textAlign(RIGHT, CENTER);
  if ((new_value == int(new_value)) || (new_value >= 100)) {
    text(String.valueOf(int(new_value)), x - t_o, y - t_o);
  } else {
    text(nf(new_value, 0, 0), x - t_o, y - t_o);
  }


  strokeWeight(0);
  stroke(0); 
  fill(0);
  //textSize(1.0 * h);
  textSize(0.85 * h);
  //textAlign(RIGHT, CENTER); text(caption + ":", x - w1 - t_o, y - t_o);
  textAlign(LEFT, CENTER); 
  text(caption + ":", x - w1 - w2 + t_o, y - t_o);

  if (new_value != v) {
    if (update1 != 0) STUDY.update = true;
    if (update2 != 0) WIN3D.update = true;
    if (update3 != 0) WORLD.update = true;
  }

  return new_value;
}



String[][] allRollouts = {
  {
    "Location & Data", "Point", "Weather", "Space"
  }
  , 
  {
    "Geometries & Space", "General", "Create", "Modify", "Solid", "Surface", "allModel2Ds", "Environment", "Viewport", "Simulation"
  }
  , 
  {
    "Period & Scenarios", "Time", "Ranges", "Filters"
  }
  , 
  {
    "Illustration Options", "2D-Layers", "2D-Colors", "3D-Solar", "3D-Spatial", "Selection"
  }
  , 
  {
    "Post-Processing", "Interpolation", "Developed", "Impacts"
  }
  , 
  {
    "Export Products", "Data", "Media"
  }
};


class solarchvision_ROLLOUT {
  
  private final static String CLASS_STAMP = "ROLLOUT";
  
  int cX = 2 * SOLARCHVISION_W_Pixel;
  int cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
  int dX = 1 * SOLARCHVISION_H_Pixel;
  int dY = 2 * SOLARCHVISION_H_Pixel;
  float R_View = float(dY) / float(dX);
  float S_View = SOLARCHVISION_H_Pixel / 325.0; //1; //0.75; // ?????
  
  boolean update = true;
  boolean include = true;
  
  int parent = 0; // 0: Location, 1: Geometry, 2: Time, etc.
  int child = 1; // number of the category inside e.g. 1, 2, ...


  void drawView () {
  
    stroke(255); 
    fill(255);
    strokeWeight(0);
    rect(this.cX, this.cY, this.dX, this.dY);
  
  
    float h = 20 * this.S_View;
  
    STUDY.X_control = this.cX;
    STUDY.Y_control = this.cY;
  
    STUDY.X_control += 307.5 * this.S_View;
    STUDY.Y_control += 7.5 * this.S_View;
  
    if (this.parent >= allRollouts.length) {
      this.parent = allRollouts.length - 1;
    }
  
    if (this.child >= allRollouts[this.parent].length) {
      this.child = allRollouts[this.parent].length - 1;
    }  
  
    if (this.parent < allRollouts.length) {
  
      for (int i = 0; i < allRollouts.length; i++) {
  
        float cx = this.cX + (150 * (i % 2) + 5) * this.S_View;
        float cy = STUDY.Y_control;
        float cr = 6.75 * this.S_View;      
  
        textAlign(LEFT, CENTER);    
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 150 * this.S_View, cy + cr) == 1) {
          this.parent = i;
          this.child = 1; // <<<<<
  
          this.update = true;
        }
  
        if (i == this.parent) {
          strokeWeight(2); 
          stroke(63); 
          fill(191);
          rect(cx - 2.5 * this.S_View, cy - 5 * this.S_View, 150 * this.S_View, 2 * 7.5 * this.S_View);
          strokeWeight(0); 
  
          stroke(0); 
          fill(0);
          textSize(15 * this.S_View);
        } else {
          stroke(127); 
          fill(127);
          textSize(15 * this.S_View);
        }
  
        text(nf(i + 1, 0) + ":" + allRollouts[i][0], cx, cy);
  
        if (i % 2 == 1) STUDY.Y_control += 15 * this.S_View;
      }
  
      strokeWeight(2); 
      stroke(63); 
      fill(63);
      rect(this.cX, STUDY.Y_control, this.dX, 17.5 * ceil((allRollouts[this.parent].length - 1) / 3.0) * this.S_View);
      strokeWeight(0);    
  
      STUDY.Y_control += 5 * this.S_View;
  
      for (int i = 1; i < allRollouts[this.parent].length; i++) {
  
        float cx = this.cX + (100 * ((i - 1) % 3) + 10) * this.S_View;
        float cy = STUDY.Y_control;
        float cr = 6.75 * this.S_View;        
  
        textAlign(LEFT, CENTER);     
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 100 * this.S_View, cy + cr) == 1) {
          this.child = i;
  
          this.update = true;
        }      
  
        if (i == this.child) {
          stroke(255, 127, 0); 
          fill(255, 127, 0);
          textSize(15 * this.S_View);
        } else {
          stroke(255); 
          fill(255);
          textSize(12.5 * this.S_View);
        }
  
        text("[" + nf(i, 0) + "]" + allRollouts[this.parent][i], cx, cy);
  
        if (i % 3 == 0) STUDY.Y_control += 15 * this.S_View;
      }
  
      if (allRollouts[this.parent].length % 3 != 1) STUDY.Y_control += 15 * this.S_View;
  
      STUDY.Y_control += 15 * this.S_View;
    }
  
  
  
  
    if (this.parent == 0) { // Location & data
  
  
      if (this.child == 1) { // Point
  
        //WORLD.AutoView = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Auto Fit", WORLD.AutoView, 0, 1, 1), 1));
        //WORLD.VIEW_id = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Viewport", WORLD.VIEW_id, 0, WORLD.Viewports_num - 1, 1), 1));
  
        LocationLAT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Latitude", LocationLAT, -85, 85, LocationLAT_step);
        LocationLON = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Longitude", LocationLON, -180, 180, LocationLON_step);
        //LocationELE = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Elevation", LocationELE, -100, 8000, LocationELE_step);
  
        LocationLAT_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Latitude_step", LocationLAT_step, 0.001, 10, -2);
        LocationLON_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Longitude_step", LocationLON_step, 0.001, 10, -2);
        //LocationELE_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Elevation_step", LocationELE_step, 0.125, 1024, -2);
  
      }
  
      if (this.child == 2) { // Weather
  
        Display_TMYEPW_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_TMYEPW_Points", Display_TMYEPW_Points, 0, 2, 1), 1));
        //Display_TMYEPW_Nearest = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_TMYEPW_Nearest", Display_TMYEPW_Nearest, 0, 1, 1), 1));
  
        Display_CWEEDS_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_CWEEDS_Points", Display_CWEEDS_Points, 0, 2, 1), 1));
        //Display_CWEEDS_Nearest = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_CWEEDS_Nearest", Display_CWEEDS_Nearest, 0, 1, 1), 1));
  
        Display_CLMREC_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_CLMREC_Points", Display_CLMREC_Points, 0, 2, 1), 1));
        //Display_CLMREC_Nearest = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_CLMREC_Nearest", Display_CLMREC_Nearest, 0, 1, 1), 1));
  
        Display_SWOB_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_SWOB_Points", Display_SWOB_Points, 0, 2, 1), 1));
        //Display_SWOB_Nearest = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_SWOB_Nearest", Display_SWOB_Nearest, 0, 1, 1), 1));
  
        Display_NAEFS_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_NAEFS_Points", Display_NAEFS_Points, 0, 2, 1), 1));
        //Display_NAEFS_Nearest = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Display_NAEFS_Nearest", Display_NAEFS_Nearest, 0, 1, 1), 1));
  
        
        //ENSEMBLE_FORECAST_load = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_FORECAST_load", ENSEMBLE_FORECAST_load, 0, 1, 1), 1));
        //ENSEMBLE_OBSERVED_load = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_OBSERVED_load", ENSEMBLE_OBSERVED_load, 0, 1, 1), 1));
        //CLIMATE_CLMREC_load = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CLMREC_load", CLIMATE_CLMREC_load, 0, 1, 1), 1));
        //CLIMATE_CWEEDS_load = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CWEEDS_load", CLIMATE_CWEEDS_load, 0, 1, 1), 1));
        //CLIMATE_TMYEPW_load = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_TMYEPW_load", CLIMATE_TMYEPW_load, 0, 1, 1), 1));
  
        GRIB2_Hour_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Start", GRIB2_Hour_Start, 0, 48, 1), 1));
        GRIB2_Hour_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_End", GRIB2_Hour_End, 0, 48, 1), 1));
        GRIB2_Hour_Step = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Step", GRIB2_Hour_Step, 1, 24, 1), 1));
  
        GRIB2_Layer_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Start", GRIB2_Layer_Start, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_End", GRIB2_Layer_End, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_Step = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Step", GRIB2_Layer_Step, 1, numberOfLayers, 1), 1));
      }
  
      if (this.child == 3) { // Space
  
        //Tropo3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.Display_Surface", Tropo3D.Display_Surface, 0, 1, 1), 1));
        //Tropo3D.Display_Texture = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.Display_Texture", Tropo3D.Display_Texture, 0, 1, 1), 1));      
  
        //Earth3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.Display_Surface", Earth3D.Display_Surface, 0, 1, 1), 1));
        //Earth3D.Display_Texture = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.Display_Texture", Earth3D.Display_Texture, 0, 1, 1), 1));
  
        //Moon3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.Display_Surface", Moon3D.Display_Surface, 0, 1, 1), 1));
        //Moon3D.Display_Texture = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.Display_Texture", Moon3D.Display_Texture, 0, 1, 1), 1));
  
        //Star3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Star3D.Display_Surface", Star3D.Display_Surface, 0, 1, 1), 1));
        //Star3D.Display_Texture = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Star3D.Display_Texture", Star3D.Display_Texture, 0, 1, 1), 1));      
  
        Planetary_Magnification = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Planetary_Magnification", Planetary_Magnification, 1, 100, 1.0);
      }
    } else if (this.parent == 1) { // Geometries & Space
  
      if (this.child == 1) { // General
  
        CreateInput_MeshOrSolid = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_MeshOrSolid", CreateInput_MeshOrSolid, 0, 1, 1), 1));
  
        allModel3Ds.Tessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel3Ds.Tessellation", allModel3Ds.Tessellation, 0, 4, 1), 1));
  
        Land3D.Tessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Tessellation", Land3D.Tessellation, 0, 4, 1), 1));
  
        Sky3D.Tessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Tessellation", Sky3D.Tessellation, 0, 4, 1), 1));   
        Sky3D.scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.scale", Sky3D.scale, 0.0000001, 1000000, -2);
  
        BIOSPHERE_drawResolution = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "BIOSPHERE_drawResolution", BIOSPHERE_drawResolution, 1, 10, 1), 1);
  
        OBJECTS_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_scale", OBJECTS_scale, 0.0000001, 1000000, -2);      
  
        Load_DefaultModels = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Load_DefaultModels", Load_DefaultModels, 0, allModel3Ds.maximum_default_models, 1), 1));
      }
  
  
  
      if (this.child == 2) { // Create
  
        addToLastGroup = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "addToLastGroup", addToLastGroup, 0, 1, 1), 1));
  
        DEFAULT_CreateMaterial = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "DEFAULT_CreateMaterial", DEFAULT_CreateMaterial, -1, 8, 1), 1));
        DEFAULT_CreateTessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "DEFAULT_CreateTessellation", DEFAULT_CreateTessellation, 0, 6, 1), 1));
        DEFAULT_CreateLayer = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "DEFAULT_CreateLayer", DEFAULT_CreateLayer, 0, 16, 1), 1));
        DEFAULT_CreateVisibility = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "DEFAULT_CreateVisibility", DEFAULT_CreateVisibility, -1, 1, 1), 1));
        DEFAULT_CreateWeight = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "DEFAULT_CreateWeight" , DEFAULT_CreateWeight, -20, 20, 1), 1));
        DEFAULT_CreateClose = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "DEFAULT_CreateClose" , DEFAULT_CreateClose, 0, 1, 1), 1));
  
        DEFAULT_CreatePivotType = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "DEFAULT_CreatePivotType", DEFAULT_CreatePivotType, 0, 4, 1), 1));
  
        CreateInput_Orientation = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Orientation", CreateInput_Orientation, 0, 360, 15);
  
        CreateInput_Length = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Length", CreateInput_Length, -50, 150, -2), 0.5); 
        CreateInput_Width = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Width", CreateInput_Width, -50, 150, -2), 0.5); 
        CreateInput_Height = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Height", CreateInput_Height, -50, 150, -2), 0.5);     
  
        CreateInput_Volume = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Volume", CreateInput_Volume, 0, 25000, 1000);
        
        CreateInput_Snap = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_Snap", CreateInput_Snap, 0, 1, 1), 1));
      }    
  
      if (this.child == 3) { // Modify
  
        ModifyInput_OpenningDepth = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_OpenningDepth", ModifyInput_OpenningDepth, -10, 10, 0.1);
        ModifyInput_OpenningArea = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_OpenningArea", ModifyInput_OpenningArea, 0, 1, 0.05);
        ModifyInput_OpenningDeviation = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_OpenningDeviation", ModifyInput_OpenningDeviation, 0, 1, 0.05);
  
        ModifyInput_TessellateRows = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_TessellateRows", ModifyInput_TessellateRows, 1, 100, 1), 1));
        ModifyInput_TessellateColumns = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_TessellateColumns", ModifyInput_TessellateColumns, 1, 100, 1), 1));
  
        ModifyInput_OffsetAmount = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_OffsetAmount", ModifyInput_OffsetAmount, 0, 25, 0.001);
  
        ModifyInput_WeldTreshold = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "ModifyInput_WeldTreshold", ModifyInput_WeldTreshold, 0, 10, 0.001);      
  
        softSelection_Power = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "softSelection_Power", softSelection_Power, 0.125, 8, -2);
        softSelection_Radius = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "softSelection_Radius", softSelection_Radius, 0.01, 100, -2);
  
        selected_posVector = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_posVector", selected_posVector, 0, 3, 1), 1));
        selected_rotVector =  int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_rotVector", selected_rotVector, 0, 2, 1), 1));
        selected_scaleVector =  int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_scaleVector", selected_scaleVector, 0, 3, 1), 1));
  
        selected_posValue = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_posValue", selected_posValue, -50, 50, 1), 1));
        selected_rotValue = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_rotValue", selected_rotValue, -180, 180, 5), 5)); 
        selected_scaleValue = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_scaleValue", selected_scaleValue, -8, 8, 0.5), 0.5)); 
  
        selection_alignX = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selection_alignX", selection_alignX, -1, 1, 1), 1));
        selection_alignY = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selection_alignY", selection_alignY, -1, 1, 1), 1));
        selection_alignZ = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selection_alignZ", selection_alignZ, -1, 1, 1), 1));
      }
  
      if (this.child == 4) { // Solid
  
        //CreateInput_powRnd = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "CreateInput_powRnd" , CreateInput_powRnd, 0, 1, 1), 1));    
        CreateInput_powAll = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_powAll", CreateInput_powAll, 0.5, CubePower, -2);
        CreateInput_powX = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_powX", CreateInput_powX, 0.5, CubePower, -2); 
        CreateInput_powY = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_powY", CreateInput_powY, 0.5, CubePower, -2); 
        CreateInput_powZ = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_powZ", CreateInput_powZ, 0.5, CubePower, -2);
      }  
  
      if (this.child == 5) { // Surface
  
        CreateInput_SphereDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_SphereDegree", CreateInput_SphereDegree, 0, 5, 1), 1));      
  
        CreateInput_CylinderDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_CylinderDegree", CreateInput_CylinderDegree, 3, 36, 1), 1));    
  
        CreateInput_PolyDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateInput_PolyDegree", CreateInput_PolyDegree, 3, 36, 1), 1));
  
        CreateParametric_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateParametric_Type", CreateParametric_Type, 0, 7, 1), 1));
        CreatePerson_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreatePerson_Type", CreatePerson_Type, 0, allModel2Ds.PEOPLE_Files_Num, 1), 1));
        CreatePlant_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreatePlant_Type", CreatePlant_Type, 0, allModel2Ds.TREES_Files_Num, 1), 1));
      }
  
      if (this.child == 6) { // allModel2Ds
  
        CreateallModel1Ds_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_Type", CreateallModel1Ds_Type, 0, 0, 1), 1));
        CreateallModel1Ds_DegreeMin = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_DegreeMin", CreateallModel1Ds_DegreeMin, 1, 9, 1), 1));
        CreateallModel1Ds_DegreeMax = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_DegreeMax", CreateallModel1Ds_DegreeMax, 1, 9, 1), 1));
        CreateallModel1Ds_Seed = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_Seed", CreateallModel1Ds_Seed, -1, 32767, 1), 1));
        CreateallModel1Ds_TrunkSize = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_TrunkSize", CreateallModel1Ds_TrunkSize, 0, 10, 0.1), 0.1);
        CreateallModel1Ds_LeafSize = roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "CreateallModel1Ds_LeafSize", CreateallModel1Ds_LeafSize, 0, 10, 0.1), 0.1);
      }    
  
      if (this.child == 7) { // Environment
  
        //Land3D.Load_Textures = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Load_Textures", Land3D.Load_Textures, 0, 1, 1), 1));
        //Land3D.Load_Mesh = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Load_Mesh", Land3D.Load_Mesh, 0, 1, 1), 1));
        //Land3D.Surface_SkipStart = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Surface_SkipStart", Land3D.Surface_SkipStart, 0, Land3D.n_I - 1, 1), 1));
        //Land3D.Surface_SkipEnd = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Surface_SkipEnd", Land3D.Surface_SkipEnd, 0, Land3D.n_I - 1, 1), 1));
        //Land3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Display_Surface", Land3D.Display_Surface, 0, 1, 1), 1));
        //Land3D.Display_Textures = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Display_Textures", Land3D.Display_Textures, 0, 1, 1), 1));
        //Land3D.Display_Points = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Display_Points", Land3D.Display_Points, 0, 1, 1), 1));     
        //Land3D.Display_Depth = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Display_Depth", Land3D.Display_Depth, 0, 1, 1), 1));
  
        //Display_allModel2Ds = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allModel2Ds", Display_allModel2Ds, 0, 1, 1), 1));
        //Display_allModel1Ds = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allModel1Ds", Display_allModel1Ds, 0, 1, 1), 1));
        //Display_Leaves = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_Leaves", Display_Leaves, 0, 1, 1), 1));
        //Display_allModel3Ds = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allModel3Ds", Display_allModel3Ds, 0, 1, 1), 1));
  
        //Display_allSolids = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allSolids", Display_allSolids, 0, 1, 1), 1));
  
        //Display_allSections = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allSections", Display_allSections, 0, 1, 1), 1));
  
  
  
  
        //Display_WindRoseImage = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_WindRoseImage", Display_WindRoseImage, 0, 1, 1), 1));
  
        WindRose_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WindRose_scale", WindRose_scale, 50, 3200, -2);
        WindRose_RES = int(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WindRose_resolution", WindRose_RES, 200, 600, 100));
  
  
  
        //Sky3D.Display_Surface = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Display_Surface", Sky3D.Display_Surface, 0, 1, 1), 1));
  
        //Display_SUN_Path = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_SUN_Path", Display_SUN_Path, 0, 1, 1), 1));
        //Display_SUN_Pattern = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_SUN_Pattern", Display_SUN_Pattern, 0, 1, 1), 1));
      }
  
  
      if (this.child == 8) { // Viewport
  
        WIN3D.CurrentCamera = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.CurrentCamera", WIN3D.CurrentCamera, 0, allCameras.num, 1), 1));
  
        WIN3D.CAM_clipNear = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.CAM_clipNear", WIN3D.CAM_clipNear, 0.01, 100, -2);
        WIN3D.CAM_clipFar = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.CAM_clipFar", WIN3D.CAM_clipFar, 1000, 2000000000, -2);
  
        //WIN3D.FacesShade = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,1,0, "WIN3D.FacesShade", WIN3D.FacesShade, 0, SHADE.Options_num - 1, 1), 1));
  
        //allModel3Ds.DisplayVertices = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel3Ds.DisplayVertices", allModel3Ds.DisplayVertices, 0, 1, 1), 1));
        //allModel3Ds.DisplayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel3Ds.DisplayEdges", allModel3Ds.DisplayEdges, 0, 1, 1), 1));
        //allModel3Ds.DisplayNormals = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel3Ds.DisplayNormals", allModel3Ds.DisplayNormals, 0, 1, 1), 1));
  
        //Display_allCameras = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_allCameras", Display_allCameras, 0, 1, 1), 1));
      }    
  
  
      if (this.child == 9) { // Simulation
  
        IMPACTS_DisplayDay = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "IMPACTS_DisplayDay", IMPACTS_DisplayDay, 0, STUDY.j_End - STUDY.j_Start, 1), 1));
  
        //Display_SolarImpactImage = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_SolarImpactImage", Display_SolarImpactImage, 0, 1, 1), 1));
        //Display_SolidImpactImage = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Display_SolidImpactImage", Display_SolidImpactImage, 0, 1, 1), 1));
  
        SolarImpact_sectionType = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolarImpact_sectionType", SolarImpact_sectionType, 0, 3, 1), 1));      
        SolidImpact_sectionType = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_sectionType", SolidImpact_sectionType, 0, 3, 1), 1));
  
  
        SolidImpact_Grade = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_Grade", SolidImpact_Grade, 0.0001, 64.0, -2);
        SolidImpact_Power = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_Power", SolidImpact_Power, 0.0001, 64.0, -2);      
        SolidImpact_Rotation[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_Rotation[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_Rotation[SolidImpact_sectionType], -360, 360, -2);
        SolidImpact_Elevation[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_Elevation[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_Elevation[SolidImpact_sectionType], -1000, 1000, -2);
        SolidImpact_positionStep = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_positionStep", SolidImpact_positionStep, 5, 80, -2);
  
        SolidImpact_scale_U[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_scale_U[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_scale_U[SolidImpact_sectionType], 0.125, 3200, -2);
        SolidImpact_scale_V[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_scale_V[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_scale_V[SolidImpact_sectionType], 0.125, 3200, -2);
        SolidImpact_offset_U[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_offset_U[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_offset_U[SolidImpact_sectionType], -10000, 10000, -2);
        SolidImpact_offset_V[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_offset_V[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_offset_V[SolidImpact_sectionType], -10000, 10000, -2);
  
  
        SolidImpact_WindSpeed = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_WindSpeed (m/s)", SolidImpact_WindSpeed, 1, 16, -2); 
        SolidImpact_WindDirection = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SolidImpact_WindDirection", SolidImpact_WindDirection, 0, 360, 15);
  
  
        Process_subDivisions = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Process_subDivisions", Process_subDivisions, 0, 3, 1), 1));
  
        //Display_SolidImpact_Points = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Display_SolidImpact_Points", Display_SolidImpact_Points, 0, 1, 1), 1));
        //Display_SolidImpact_Lines = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Display_SolidImpact_Lines", Display_SolidImpact_Lines, 0, 1, 1), 1));
  
        //Display_WindFlow = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Display_WindFlow", Display_WindFlow, 0, 1, 1), 1));
      }
    } else if (this.parent == 2) { // Period & Scenarios
  
      if (this.child == 1) { // Time
  
        //TIME_Date = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Solar date", TIME_Date, 0, 364.5, 0.5);
        TIME_Date = int(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Solar date", TIME_Date, 0, 364, 1));
  
        TIME_Day = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast day", TIME_Day, 1, 31, 1), 1));
        TIME_Month = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast month", TIME_Month, 1, 12, 1), 1));
        TIME_Year = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast year", TIME_Year, 1953, 2100, 1), 1));
  
        TIME_BeginDay = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Plot start date", TIME_BeginDay, 0, 364, 1), 1));
  
        STUDY.j_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Number of days to plot", STUDY.j_End, 1, 61, 1), 1));
  
        ENSEMBLE_OBSERVED_maxDays = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "ENSEMBLE_OBSERVED_maxDays", ENSEMBLE_OBSERVED_maxDays, 0, 31, 1), 1));
            
      }
  
      if (this.child == 2) { // Ranges
        STUDY.i_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start hour", STUDY.i_Start, 0, 23, 1), 1));
        STUDY.i_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End hour", STUDY.i_End, 0, 23, 1), 1));
  
        STUDY.JoinDays = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.JoinDays", STUDY.JoinDays, 1, 64, -2), 1));
        
  //??????
        SampleYear_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start year", SampleYear_Start, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
        SampleYear_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End year", SampleYear_End, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
  //??????
  
        SampleMember_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start member", SampleMember_Start, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));  
        SampleMember_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End member", SampleMember_End, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));
  
        SampleStation_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start station", SampleStation_Start, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));  
        SampleStation_End = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End station", SampleStation_End, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));
  
  
      }
  
      if (this.child == 3) { // Filters
      
        STUDY.skyScenario = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Sky status", STUDY.skyScenario, 1, 4, 1), 1));
        STUDY.filter = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Hourly/daily filter", STUDY.filter, 0, 1, 1), 1));
      }
    } else if (this.parent == 3) { // Display Options
  
      if (this.child == 1) { // 2D-Layers
  
        FrameVariation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 1, 1, "Frame layout variation", FrameVariation, 0, 3, 1), 1));
  
        STUDY.plotSetup = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Diagram setup", STUDY.plotSetup, -2, 14, 1), 1));
  
        //STUDY.update = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Redraw scene", STUDY.update, 0, 1, 1), 1));  
  
        changeCurrentLayerTo(int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Layer", CurrentLayer_id, 0, (numberOfLayers - 1), 1), 1)));
        
        STUDY.V_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "V_scale[" + nf(CurrentLayer_id, 2) + "]", STUDY.V_scale, 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));      
  
        //STUDY.DisplayRaws = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw data", STUDY.DisplayRaws, 0, 1, 1), 1));
        //STUDY.DisplaySorted = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw sorted", STUDY.DisplaySorted, 0, 1, 1), 1));
        //STUDY.DisplayNormals = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw statistics", STUDY.DisplayNormals, 0, 1, 1), 1));
        //STUDY.DisplayProbs = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw probabilities", STUDY.DisplayProbs, 0, 1, 1), 1));
        STUDY.SumInterval = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities interval", STUDY.SumInterval, 1, 24, 1), 1));
        STUDY.LevelPix = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities range", STUDY.LevelPix, 2, 32, -2), 1));
      }
  
      if (this.child == 2) { // 2D-Colors
  
        //COLOR_STYLE_Current = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Hourly color scheme", COLOR_STYLE_Current, -1, (COLOR_STYLE_Number - 1), 1), 1));
  
        STUDY.Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_ACTIVE_CLR", STUDY.Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_ACTIVE_DIR", STUDY.Pallet_ACTIVE_DIR, -2, 2, 1), 1));
        STUDY.Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_ACTIVE_MLT", STUDY.Pallet_ACTIVE_MLT, 0.125, 8, -2);
  
        STUDY.Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PASSIVE_CLR", STUDY.Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PASSIVE_DIR", STUDY.Pallet_PASSIVE_DIR, -2, 2, 2), 1));
        STUDY.Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PASSIVE_MLT", STUDY.Pallet_PASSIVE_MLT, 0.125, 8, -2);       
  
        STUDY.Pallet_SORT_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_SORT_CLR", STUDY.Pallet_SORT_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.Pallet_SORT_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_SORT_DIR", STUDY.Pallet_SORT_DIR, -2, 2, 2), 1));
        STUDY.Pallet_SORT_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_SORT_MLT", STUDY.Pallet_SORT_MLT, 0.125, 8, -2);
  
        STUDY.Pallet_PROB_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PROB_CLR", STUDY.Pallet_PROB_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.Pallet_PROB_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PROB_DIR", STUDY.Pallet_PROB_DIR, -2, 2, 2), 1));
        STUDY.Pallet_PROB_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.Pallet_PROB_MLT", STUDY.Pallet_PROB_MLT, 0.125, 8, -2);
  
        STUDY.O_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Windose opacity scale", STUDY.O_scale, 1, 100, -pow(2.0, (1.0 / 4.0)));
      }
  
      if (this.child == 3) { // 3D-Solar 
  
        OBJECTS_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        OBJECTS_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
        OBJECTS_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT, 0.125, 8, -2);
  
        OBJECTS_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        OBJECTS_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
        OBJECTS_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT, 0.125, 8, -2);
  
        Sky3D.Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_ACTIVE_CLR", Sky3D.Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_ACTIVE_DIR", Sky3D.Pallet_ACTIVE_DIR, -2, 2, 1), 1));
        Sky3D.Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_ACTIVE_MLT", Sky3D.Pallet_ACTIVE_MLT, 0.125, 8, -2);
  
        Sky3D.Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_PASSIVE_CLR", Sky3D.Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_PASSIVE_DIR", Sky3D.Pallet_PASSIVE_DIR, -2, 2, 2), 1));
        Sky3D.Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.Pallet_PASSIVE_MLT", Sky3D.Pallet_PASSIVE_MLT, 0.125, 8, -2);
  
        SunPath_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_ACTIVE_CLR", SunPath_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        SunPath_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_ACTIVE_DIR", SunPath_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
        SunPath_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_ACTIVE_MLT", SunPath_Pallet_ACTIVE_MLT, 0.125, 8, -2);
  
        SunPath_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_PASSIVE_CLR", SunPath_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        SunPath_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_PASSIVE_DIR", SunPath_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
        SunPath_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SunPath_Pallet_PASSIVE_MLT", SunPath_Pallet_PASSIVE_MLT, 0.125, 8, -2);
      }
  
  
  
  
      if (this.child == 4) { // 3D-Solid   
  
        SOLID_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SOLID_Pallet_CLR", SOLID_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        SOLID_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SOLID_Pallet_DIR", SOLID_Pallet_DIR, -2, 2, 2), 1));
        SOLID_Pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "SOLID_Pallet_MLT", SOLID_Pallet_MLT, 0.0001, 64, -2);      
  
        ELEVATION_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        ELEVATION_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR, -2, 2, 2), 1));
        ELEVATION_Pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT, 0.001, 0.5, -2);   
  
        WindFlow_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WindFlow_Pallet_CLR", WindFlow_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        WindFlow_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WindFlow_Pallet_DIR", WindFlow_Pallet_DIR, -2, 2, 2), 1));
        WindFlow_Pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WindFlow_Pallet_MLT", WindFlow_Pallet_MLT, 0.01, 1.0, -2);
      }      
  
  
      if (this.child == 5) { // Selection
  
        //selectedGroup_displayPivot = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedGroup_displayPivot", selectedGroup_displayPivot, 0, 1, 1), 1));
        //selected_displayReferencePivot = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selected_displayReferencePivot", selected_displayReferencePivot, 0, 1, 1), 1));
        //selectedGroup_displayBox = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedGroup_displayBox", selectedGroup_displayBox, 0, 1, 1), 1));
        //selectedGroup_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedGroup_displayEdges", selectedGroup_displayEdges, 0, 1, 1), 1));
  
        //selectedFace_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedFace_displayEdges", selectedFace_displayEdges, 0, 1, 1), 1));
        //selectedFace_displayVertexCount = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedFace_displayVertexCount", selectedFace_displayVertexCount, 0, 1, 1), 1));
        //selectedCurve_displayVertexCount = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedCurve_displayVertexCount", selectedCurve_displayVertexCount, 0, 1, 1), 1));
        //selectedVertex_displayVertices = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedVertex_displayVertices", selectedVertex_displayVertices, 0, 1, 1), 1));
        //selectedCurve_displayVertices = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedCurve_displayVertices", selectedCurve_displayVertices, 0, 1, 1), 1));
  
        //selectedallModel2Ds_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedallModel2Ds_displayEdges", selectedallModel2Ds_displayEdges, 0, 1, 1), 1));
        //selectedallModel1Ds_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedallModel1Ds_displayEdges", selectedallModel1Ds_displayEdges, 0, 1, 1), 1));
  
        //selectedSolid_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedSolid_displayEdges", selectedSolid_displayEdges, 0, 1, 1), 1));
  
        //selectedSection_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedSection_displayEdges", selectedSection_displayEdges, 0, 1, 1), 1));
  
        //selectedCamera_displayEdges = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedCamera_displayEdges", selectedCamera_displayEdges, 0, 1, 1), 1));
  
        //selectedLandPoint_displayPoints = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "selectedLandPoint_displayPoints", selectedLandPoint_displayPoints, 0, 1, 1), 1));
      }
    } else if (this.parent == 4) { // Post-Processing
  
      if (this.child == 1) { // Interpolation
  
        Interpolation_Weight = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Interpolation_Weight", Interpolation_Weight, 0, 5, 0.5);
        CLIMATIC_SolarForecast = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based solar forecast", CLIMATIC_SolarForecast, 0, 1, 1), 1));
        CLIMATIC_WeatherForecast = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based temperature forecast", CLIMATIC_WeatherForecast, 0, 2, 1), 1));
      } 
      if (this.child == 2) { // Developed
        Develop_Option = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_Option", Develop_Option, 0, 11, 1), 1));
        Develop_DayHour = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_DayHour", Develop_DayHour, 0, 3, 1), 1));
  
        STUDY.TrendJoinHours = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Trend period hours", STUDY.TrendJoinHours, 1, 24 * 16, 1), 1));
        STUDY.TrendJoinType = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Weighted/equal trend", STUDY.TrendJoinType, -1, 1, 2), 1));
  
        Develop_AngleInclination = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Inclination angle", Develop_AngleInclination, 0, 90, 5), 1));
        Develop_AngleOrientation = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Orientation angle", Develop_AngleOrientation, 0, 360, 15), 1));
      }
      if (this.child == 3) { // Impacts
        CurrentDataSource = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impacts Source", CurrentDataSource, 0, 3, 1), 1));
        STUDY.ImpactLayer = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impact Min/50%/Max", STUDY.ImpactLayer, 0, 8, 1), 1));
        //STUDY.Impacts_update = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "update impacts", STUDY.Impacts_update, 0, 1, 1), 1));
      }
    } else if (this.parent == 5) { // Export Products
  
      if (this.child == 1) { // Data
  
        //STUDY.Export_info_node = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII data", STUDY.Export_info_node, 0, 1, 1), 1));
        //STUDY.Export_info_norm = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII statistics", STUDY.Export_info_norm, 0, 1, 1), 1));
        //STUDY.Export_info_prob = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII probabilities", STUDY.Export_info_prob, 0, 1, 1), 1));
  
  
        Export_Scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_Scale", Export_Scale, .001, 1000, -0.1);
        Export_FlipZYaxis = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_FlipZYaxis", Export_FlipZYaxis, 0, 1, 1), 1));
  
        Export_PrecisionVertex = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_PrecisionVertex", Export_PrecisionVertex, 0, 6, 1), 1));
        Export_PrecisionVtexture = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_PrecisionVtexture", Export_PrecisionVtexture, 0, 6, 1), 1));
        Export_PolyToPoly = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_PolyToPoly", Export_PolyToPoly, 0, 1, 1), 1));
  
        //Export_MaterialLibrary = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_MaterialLibrary", Export_MaterialLibrary, 0, 1, 1), 1));
        //Export_BackSides = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_BackSides", Export_BackSides, 0, 1, 1), 1));
        //Export_PalletResolution = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Export_PalletResolution", Export_PalletResolution, 32, 2048, -2), 1));
  
  
        //Display_Output_in_Explorer = boolean(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Display_Output_in_Explorer", Display_Output_in_Explorer, 0, 1, 1), 1));
      }  
  
      if (this.child == 2) { // Media
  
        SolidImpact_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in JPG", SolidImpact_record_JPG, 0, 1, 1), 1));
        SolidImpact_record_PDF = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in PDF", SolidImpact_record_PDF, 0, 1, 1), 1));
  
        SolarImpact_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record Solar Analysis in JPG", SolarImpact_record_JPG, 0, 1, 1), 1));
      }
  
    }    
  
    if (this.include) {
      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, this.cX, this.cY, this.cX + this.dX, this.cY + this.dY) == 1) {  
        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      }
    }
  }
  
}


class solarchvision_MESSAGE {
  
  private final static String CLASS_STAMP = "MESSAGE";
  
  int cX = 0;
  int cY = int(1 * SOLARCHVISION_H_Pixel - 0.75 * MessageSize + 0.5 * (SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_C_Pixel + SOLARCHVISION_D_Pixel));
  int dX = 2 * SOLARCHVISION_W_Pixel + ROLLOUT.dX;
  int dY = int(1.5 * MessageSize);
}

solarchvision_ROLLOUT ROLLOUT = new solarchvision_ROLLOUT();
solarchvision_MESSAGE MESSAGE = new solarchvision_MESSAGE();
solarchvision_WORLD WORLD = new solarchvision_WORLD();
solarchvision_WIN3D WIN3D = new solarchvision_WIN3D();
solarchvision_STUDY STUDY = new solarchvision_STUDY();





int WMS_type = DataType.FORECAST_GDPS; // <<<<<<<<<<<<<

// note we used .... float r = FLOAT_r_Earth + 10000; for clouds

final int TROPO_deltaTime = 1; 
final int TROPO_timeSteps = 24;







// Tropo3D.draw --- we only use the first image!

// should define subroutines to perfome this not inside draw! if ((STUDY.PlotImpacts == 6) || (STUDY.PlotImpacts == 7)) {


// bug using small STUDY.LevelPix 


// pick select LandPoint is not written. 


// diffuse model used in render is simple see note "adding approximate diffuse radiation effect anyway!" 


// snap for Curve objects is not developed yet.

// don't know if multiple allModel2Ds.Images[n].get(Image_X, Image_Y) in allModel2Ds selection can produce performance problems? 


// note: code for SOLARCHVISION_intersect_allSolids might run a bit slow. But it is OK for now.


// should see where else could add snap3D :)


// drop functions only works for allModel2Ds objects and not at Group level

// could add join/explode groups ?


// export and import of curves
// converting curves to faces e.g. Surface, Extrude, Connect

// Modify Normal at Curve level is not complete...

// allModel3Ds.autoNormalCurve_Selection

// writing export to rad completed for meshes and land - not allModel1Ds and 2Ds yet!

// colud record Climate data flags later.

// exporting shaded land is not written. 

// void SOLARCHVISION_rotate_selectedallGroups 
// serach for SOLARCHVISION_rotate_Selection ( need to make them all correct for local pivots!
// local pivot


// solid rotations inside groups should be translated to locals to avoid problems!

// some rotations are not in degrees e.g. solids, allModel1Ds??, what else?


import processing.pdf.*;

void launch (String s) {
  open(s);
}
void launch (String[] s) {
  open(s);
}















float[][]   VertexSolar_XYZ; 
float[][][] VertexSolar_amounts; 

int rebuild_VertexSolar_array = 1;
int rebuild_GlobalSolar_array = 1;
int rebuild_SolarImpactImage_array = 1;
int rebuild_WindRoseImage_array = 1; 

float SOLARCHVISION_GLOBE_stp_slp;
float SOLARCHVISION_GLOBE_stp_dir;
int SOLARCHVISION_GLOBE_n_slp;  
int SOLARCHVISION_GLOBE_n_dir;

float[][][][] GlobalSolar;








float pre_TIME_Date;
int pre_TIME_Hour;
int pre_TIME_Day;
int pre_TIME_Month;
int pre_TIME_Year;

int pre_SampleYear_Start; 
int pre_SampleYear_End; 
int pre_SampleMember_Start;
int pre_SampleMember_End;
int pre_SampleStation_Start; 
int pre_SampleStation_End;

int pre_STUDY_JoinDays;
int pre_STUDY_i_Start;
int pre_STUDY_i_End;
int pre_STUDY_j_End;
int pre_STUDY_Setup;

int pre_IMPACTS_DisplayDay;
int pre_CurrentDataSource;

int pre_CLIMATIC_SolarForecast;
int pre_CLIMATIC_WeatherForecast;

boolean pre_CLIMATE_TMYEPW_load;
boolean pre_CLIMATE_CWEEDS_load;
boolean pre_CLIMATE_CLMREC_load;
boolean pre_ENSEMBLE_FORECAST_load;
boolean pre_ENSEMBLE_OBSERVED_load;    

boolean pre_Land3D_Load_Mesh;
boolean pre_Land3D_Load_Textures;

float pre_LocationLAT;
float pre_LocationLON;

int pre_WORLD_AutoView;

boolean pre_selectedallModel1Ds_displayEdges;
boolean pre_selectedallModel2Ds_displayEdges;

boolean pre_selectedSolid_displayEdges;
boolean pre_selectedSection_displayEdges;
boolean pre_selectedCamera_displayEdges;

boolean pre_selectedLandPoint_displayPoints;



float pre_softSelection_Power;
float pre_softSelection_Radius;

float pre_selected_posValue;
float pre_selected_rotValue;
float pre_selected_scaleValue;

int pre_selection_alignX;
int pre_selection_alignY;
int pre_selection_alignZ;

boolean pre_selected_displayReferencePivot;

boolean pre_selectedGroup_displayPivot;
boolean pre_selectedGroup_displayEdges;
boolean pre_selectedGroup_displayBox;      

boolean pre_selectedFace_displayEdges;
boolean pre_selectedFace_displayVertexCount;
boolean pre_selectedCurve_displayVertexCount;
boolean pre_selectedVertex_displayVertices;
boolean pre_selectedCurve_displayVertices;

int pre_Load_DefaultModels;


int pre_WIN3D_CurrentCamera;

int pre_WIN3D_FacesShade;

int pre_allModel3Ds_Tessellation;

boolean pre_allModel3Ds_DisplayVertices;
boolean pre_allModel3Ds_DisplayEdges;
boolean pre_allModel3Ds_DisplayNormals;





int pre_Develop_Option;

int pre_STUDY_ImpactLayer;
int pre_STUDY_CurrentLayer_id;

int pre_STUDY_SkyScenario;
int pre_STUDY_PlotImpacts;

int pre_SOLID_Pallet_CLR;
int pre_SOLID_Pallet_DIR; 
float pre_SOLID_Pallet_MLT; 





float pre_SolidImpact_Grade;
float pre_SolidImpact_Power;
float[] pre_SolidImpact_Rotation = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_Elevation = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_scale_U = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_scale_V = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_offset_U = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_offset_V = {
  0, 0, 0, 0
};

float pre_SolidImpact_Wspd; 
float pre_SolidImpact_Wdir;

boolean pre_Display_SolidImpact_Points;
boolean pre_Display_SolidImpact_Lines;

int pre_Process_subDivisions;

boolean pre_Display_WindFlow;

float pre_CreateInput_powAll;









int SavedScreenShots = 0;

float Interpolation_Weight = 0.5;// 0 = linear distance interpolation, 1 = square distance interpolation, 5 = nearest




final int Impact_ACTIVE = 0; // internal
final int Impact_PASSIVE = 1; // internal
final int numberOfImpactVariations = 2; // internal

int Impact_TYPE;






float CubePower = 16; //8; 
float StarPower = 0.25; 


final double DOUBLE_r_Earth = 6367470.0; //6373000.0;
final float FLOAT_r_Earth = (float) DOUBLE_r_Earth;


float CrustDepth = 100; // 100 = 100m .The actual crust ranges from 5–70 km

float EyeLevel = 1.5; // 1.5 abouve ground - applied for setting cameras - intreanl!




float GlobalAlbedo = 0; // 0-100

float GLOBE_calculatedResolution = 2.5; //1, 2.5, 5

float BIOSPHERE_drawResolution = 5.0; //2.5; // 5: 5 degrees

float Export_Scale = 1.0; //0.001; // 0.001: 1km --> 1
int Export_FlipZYaxis = 1; //1; // 1: to fit in Unity3D

int Export_PrecisionVertex = 6; 
int Export_PrecisionVtexture = 4;
int Export_PolyToPoly = 1; // 0: Exports each group3D to different individual faces, 1: Exports group3D to group3D 

boolean Export_MaterialLibrary = true; 
boolean Export_BackSides = true; 
int Export_PalletResolution = 256;







float Planetary_Magnification = 2.5; // <<<<<<<<<<














boolean Display_Output_in_Explorer = true;

boolean Display_allModel3Ds = true;
boolean Display_allModel2Ds = true;
boolean Display_allModel1Ds = true;
boolean Display_Leaves = true;

boolean Display_allSolids = true;
boolean Display_allSections = true;
boolean Display_allCameras = true;


int defaultMaterial = 7;
int defaultTessellation = 0;
int defaultLayer = 0;
int defaultVisibility = 1;
int defaultWeight = 0; 
int defaultClose = 0;

int defaultPivotType = 0; // for allGroups




int DEFAULT_CreateMaterial = 7; //0;
int DEFAULT_CreateTessellation = 0;
int DEFAULT_CreateLayer = 0;
int DEFAULT_CreateVisibility = 1; // 1: view 0: hide -1:freeze 
int DEFAULT_CreateWeight = 0; 
int DEFAULT_CreateClose = 0; 

int DEFAULT_CreatePivotType = 0;

float ModifyInput_WeldTreshold = 0.1; 

int ModifyInput_TessellateRows = 6;
int ModifyInput_TessellateColumns = 30;

float ModifyInput_OffsetAmount = 1.0; // 1 = 1m

float ModifyInput_OpenningDepth = 1; // 1 = 1m 
float ModifyInput_OpenningArea = 0.25; //0-1, 0.25: 25% of the face area (i.e. for parallel openings) 
float ModifyInput_OpenningDeviation = 0.5; //0-1, 0.5: middle of the face edge (could be applied in rotated openning)


float CreateInput_Length = 10;
float CreateInput_Width = 10;
float CreateInput_Height = 10;


float CreateInput_Volume = 0; //3000;

float CreateInput_Orientation = 360; //0; // 360: random




float CreateInput_powX = CubePower; 
float CreateInput_powY = CubePower; 
float CreateInput_powZ = CubePower; 

float CreateInput_powAll = 8;
int CreateInput_powRnd = 0;

int CreateInput_SphereDegree = 2; //4;

int CreateInput_CylinderDegree = 24; 



int CreateInput_PolyDegree = 6;

int CreateInput_Snap = 0;



int CreateObject = CREATE.Nothing;

int CreateParametric_Type = 0;
int CreatePerson_Type = 0;
int CreatePlant_Type = 0;
int CreateallModel1Ds_Type = 0;
int CreateallModel1Ds_DegreeMin = 1; //2; 
int CreateallModel1Ds_DegreeMax = 6; //5; //8;
int CreateallModel1Ds_Seed = -1; // -1:random, 0-99 choice
float CreateallModel1Ds_TrunkSize = 1; //0.5;
float CreateallModel1Ds_LeafSize = 1; //1; 





int Current_ObjectCategory = ObjectCategory.GROUP; 

int CreateInput_MeshOrSolid = 0; // 0:Mesh 1:Solid









int     Display_SWOB_Points = 0; // 0-2
boolean Display_SWOB_Nearest = false;

int     Display_NAEFS_Points = 0; // 0-2
boolean Display_NAEFS_Nearest = false;

int     Display_CWEEDS_Points = 0; // 0-2
boolean Display_CWEEDS_Nearest = false;

int     Display_CLMREC_Points = 0; // 0-2
boolean Display_CLMREC_Nearest = false;

int     Display_TMYEPW_Points = 1; // 0-2
boolean Display_TMYEPW_Nearest = false;

boolean FRAME_record_AUTO = false;
boolean FRAME_record_JPG = false;
boolean FRAME_click_JPG = false;
boolean FRAME_drag_JPG = false;

int SolidImpact_record_PDF = 0;
int SolidImpact_record_JPG = 0;

int SolarImpact_record_JPG = 0;  




//-------------------------------

float SolidImpact_WindSpeed = 5; // (5m/s = 18 km/h) 
float SolidImpact_WindDirection = 180.0;

float SolidImpact_Power = 1.0; //2.0; //3.0; // 1/2/3 
float SolidImpact_Grade = 0.02; //1.0; //0.1; //10.0; //contour lines 



int CLIMATIC_SolarForecast = 0; //                                   Used for solar radiation only
int CLIMATIC_WeatherForecast = 0; // 0:linear 1:average 2:sky-based. Used for some parameters namely: air temperature, humidity

int SOLARCHVISION_automated = 0; //0: User interface, 1: Automatic


 





int TIME_ModelRun = 0; //12; 

int TIME_Hour = TIME_ModelRun; //hour(); 
int TIME_Year = year(); 
int TIME_Month = month();
int TIME_Day = day(); 

int TIME_BeginDay;
float TIME_Date;

void SOLARCHVISION_RecordFrame () {

  saveFrame(ScreenShotFolder + "/" + CreateStamp(1) + "Screen.jpg");
}

String CreateStamp (int _add) {

  SavedScreenShots += _add; 

  return nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + nf(hour(), 2) + "_IMG" + nf(SavedScreenShots, 4);
}







String MAKE_Filename (String beginName) {

  String My_Filenames = ScreenShotFolder + "/" + beginName;  

  return My_Filenames;
}



String MAKE_MainName () {

  String s = "";

  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) s = nf(TIME_Year, 2) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + "_" + nf(STUDY.j_End, 0) + "dayFORECAST_";

  return s;
}

String getFilename_SolidImpact () {

  return graphicsFolder + "/" + nf(TIME_Year, 2) + "-" + nf(TIME_Month, 2) + "-" + nf(TIME_Day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/SolidImpact" + nf(SolidImpact_sectionType, 0) + "h" + nf(int(roundTo(SolidImpact_Elevation[SolidImpact_sectionType], 1)), 4) + "r" + nf(int(roundTo(SolidImpact_Rotation[SolidImpact_sectionType], 1)), 3) + "p" + nf(SolidImpact_Power, 2, 2).replace(".", "_") + "m" + nf(SolidImpact_Grade, 2, 2).replace(".", "_");
}

String getFilename_SolarImpact () {

  return graphicsFolder + "/" + nf(TIME_Year, 2) + "-" + nf(TIME_Month, 2) + "-" + nf(TIME_Day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/SolarImpact" + nf(SolarImpact_sectionType, 0) + "h" + nf(int(roundTo(SolarImpact_Elevation, 1)), 4) + "r" + nf(int(roundTo(SolarImpact_Rotation, 1)), 3);
}






float HeightAboveGround = 0; //2.5; // <<<<<<<<<



float LocationLAT = 0.0;
float LocationLON = 0.0;
float LocationELE = 0.0;

float LocationLAT_step = 0.1;
float LocationLON_step = 0.1;
float LocationELE_step = 1.0;

int save_frame_number = 0;









final int TIME_Interval = 1; //dT



int OBJECTS_Pallet_ACTIVE_CLR = 19; //15; //14;
int OBJECTS_Pallet_ACTIVE_DIR = 1;
float OBJECTS_Pallet_ACTIVE_MLT = 1; //2; 

int OBJECTS_Pallet_PASSIVE_CLR = 1; 
int OBJECTS_Pallet_PASSIVE_DIR = 1;  
float OBJECTS_Pallet_PASSIVE_MLT = 1; 

int SunPath_Pallet_ACTIVE_CLR = 15;
int SunPath_Pallet_ACTIVE_DIR = 1;
float SunPath_Pallet_ACTIVE_MLT = 1;

int SunPath_Pallet_PASSIVE_CLR = 18; 
int SunPath_Pallet_PASSIVE_DIR = -1;  
float SunPath_Pallet_PASSIVE_MLT = 1; //1;



int ELEVATION_Pallet_CLR = 1; 
int ELEVATION_Pallet_DIR = -1; 
float ELEVATION_Pallet_MLT = 0.05; 

int SOLID_Pallet_CLR = 17; //1; 
int SOLID_Pallet_DIR = -1; 
float SOLID_Pallet_MLT = 0.01; //1; 

int WindFlow_Pallet_CLR = 18; 
int WindFlow_Pallet_DIR = -1;  
float WindFlow_Pallet_MLT = 1;







final String[][] SOLARCHVISION_WORDS = {
  {
    "", ""
  }
  , 
  {
    "at hour", "à l'heure"
  }
  , 
  {
    "day", "jour"
  }
  , 
  {
    "month", "mois"
  }
  , 
  {
    "year", "année"
  }
  , 
  {
    "date", "date"
  }
}; 

final String[][] CalendarMonth = {
  {
    "January", "janvier"
  }
  , 
  {
    "February", "février"
  }
  , 
  {
    "March", "mars"
  }
  , 
  {
    "April", "avril"
  }
  , 
  {
    "May", "mai"
  }
  , 
  {
    "June", "juin"
  }
  , 
  {
    "July", "juillet"
  }
  , 
  {
    "August", "août"
  }
  , 
  {
    "September", "septembre"
  }
  , 
  {
    "October", "octobre"
  }
  , 
  {
    "November", "novembre"
  }
  , 
  {
    "December", "décembre"
  }
};

final int[] CalendarLength = {
  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
String[][] CalendarDay;
String[][] CalendarMM;
String[][] CalendarDD;
int[][] CalendarDate;





int COLOR_STYLE_Current = 0;
int COLOR_STYLE_Number = 20; //6;



final int dataID_ENSEMBLE_OBSERVED = 0;
final int dataID_ENSEMBLE_FORECAST = 1; // also used for Aerial
final int dataID_CLIMATE_CWEEDS = 2;
final int dataID_CLIMATE_CLMREC = 3;
final int dataID_CLIMATE_TMYEPW = 4;

int CurrentDataSource = dataID_CLIMATE_TMYEPW; 

final String[] databaseString = {
  "SWOB", "NAEFS", "CWEEDS", "CLMREC", "TMY"
};







int DrawnFrame = 0;

int SOLARCHVISION_X_clicked = -1;
int SOLARCHVISION_Y_clicked = -1;

int SOLARCHVISION_X_click1 = -1;
int SOLARCHVISION_Y_click1 = -1;
int SOLARCHVISION_X_click2 = -1;
int SOLARCHVISION_Y_click2 = -1;










float WindRose_scale = 400;


boolean Display_SUN_Path = true;
boolean Display_SUN_Pattern = false;





boolean Display_SolidImpact_Points = false;
boolean Display_SolidImpact_Lines = true;

boolean Display_WindFlow = false;







int Camera_Variation = 0; // 1;





















int Materials_Number = 11; //256; // 0, 1, 2, ... , 10

int Materials_Selection = 1; //2; // yellow

float[][][] Materials_DirectArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DirectArea_Flags = new int [24][365];

float[][][] Materials_DiffuseArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DiffuseArea_Flags = new int [24][365];

int[][] Materials_Color = new int [Materials_Number][4]; // ARGB                            
{
  {
    int[] COL = {
      255, 255, 127, 0
    };    
    Materials_Color[0] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 0
    };    
    Materials_Color[1] = COL;
  }  
  {
    int[] COL = {
      255, 255, 255, 0
    };    
    Materials_Color[2] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 0
    };    
    Materials_Color[3] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 255
    };    
    Materials_Color[4] = COL;
  }
  {
    int[] COL = {
      255, 0, 0, 255
    };    
    Materials_Color[5] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 255
    };    
    Materials_Color[6] = COL;
  }
  {
    int[] COL = {
      255, 255, 255, 255
    };    
    Materials_Color[7] = COL;
  }
  {
    //int[] COL = {255, 63, 63, 63};    
    int[] COL = {
      63, 63, 63, 63
    };
    Materials_Color[8] = COL;
  }
  {
    //int[] COL = {255, 127, 127, 127};    
    int[] COL = {
      127, 127, 127, 127
    };
    Materials_Color[9] = COL;
  }
  {
    //int[] COL = {255, 191, 191, 191};    
    int[] COL = {
      191, 191, 191, 191
    };
    Materials_Color[10] = COL;
  }

  {
    for (int mt = 11; mt < Materials_Number; mt++) {
      int[] COL = {
        255, int(random(256)), int(random(256)), int(random(256))
      };
      Materials_Color[mt] = COL;
    }
  }
}

void SOLARCHVISION_empty_Materials_DirectArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 365; j++) {
        Materials_DirectArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DirectArea_Flags[i][j] = -1;
      }
    }
  }
}

void SOLARCHVISION_empty_Materials_DiffuseArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 365; j++) {
        Materials_DiffuseArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DiffuseArea_Flags[i][j] = -1;
      }
    }
  }
}















float[][] allVertices = new float[0][3];


class solarchvision_Faces {
  
  private final static String CLASS_STAMP = "Faces";
  
  int[][] nodes = new int[0][0];
  
  int[][] options = new int[0][6]; // 0:material, 1:tessellation, 2:layer, 3:visibility, 4:weight, 5:close
  
  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }  
  
  int getVisibility (int n) {
    return this.options[n][3];
  }   
  
  int getWeight (int n) {
    return this.options[n][4];
  }    
  
  int getClose (int n) {
    return this.options[n][5];
  }   
  
  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }  
  
  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }   
  
  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }    
  
  void setClose (int n, int close) {
    this.options[n][5] = close;
  }    
 
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".nodes");
      parent.setInt("ni", this.nodes.length);
      for (int i = 0; i < this.nodes.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.nodes[i].length; j++) {
          lineSTR += nf(this.nodes[i][j], 0);
          if (j < this.nodes[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".options");
      parent.setInt("ni", this.options.length);
      for (int i = 0; i < this.options.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.options[i].length; j++) {
          lineSTR += nf(this.options[i][j], 0);
          if (j < this.options[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".nodes");
      int ni = parent.getInt("ni");
      this.nodes = new int [0][0];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        int nj = parts.length;
        int[][] newFace = new int [1][nj];
        for (int j = 0; j < nj; j++) {
          newFace[0][j] = int(parts[j]);
        }
        this.nodes = (int[][]) concat(this.nodes, newFace);
      }
    }
    
    { 
      XML parent = xml.getChild(this.CLASS_STAMP + ".options");
      int ni = parent.getInt("ni");
      this.options = new int [ni][6];
      XML[] children = parent.getChildren("item"); 
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.options[i][j] = int(parts[j]);
        }
      }
    }
  }    
  
}

solarchvision_Faces allFaces = new solarchvision_Faces(); 

class solarchvision_Curves {
  
  private final static String CLASS_STAMP = "Curves";

  int[][] nodes = new int[0][0];
  
  int[][] options = new int[0][6]; // 0:material, 1:tessellation, 2:layer, 3:visibility, 4:weight, 5:close
  
  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }  
  
  int getVisibility (int n) {
    return this.options[n][3];
  }   
  
  int getWeight (int n) {
    return this.options[n][4];
  }    
  
  int getClose (int n) {
    return this.options[n][5];
  }   
  
  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }  
  
  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }   
  
  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }    
  
  void setClose (int n, int close) {
    this.options[n][5] = close;
  }       
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".nodes");
      parent.setInt("ni", this.nodes.length);
      for (int i = 0; i < this.nodes.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.nodes[i].length; j++) {
          lineSTR += nf(this.nodes[i][j], 0);
          if (j < this.nodes[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".options");
      parent.setInt("ni", this.options.length);
      for (int i = 0; i < this.options.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.options[i].length; j++) {
          lineSTR += nf(this.options[i][j], 0);
          if (j < this.options[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".nodes");
      int ni = parent.getInt("ni");
      this.nodes = new int [0][0];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        int nj = parts.length;
        int[][] newFace = new int [1][nj];
        for (int j = 0; j < nj; j++) {
          newFace[0][j] = int(parts[j]);
        }
        this.nodes = (int[][]) concat(this.nodes, newFace);
      }
    }
    
    { 
      XML parent = xml.getChild(this.CLASS_STAMP + ".options");
      int ni = parent.getInt("ni");
      this.options = new int [ni][6];
      XML[] children = parent.getChildren("item"); 
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.options[i][j] = int(parts[j]);
        }
      }
    }
  }    
  
}

solarchvision_Curves allCurves = new solarchvision_Curves(); 


class solarchvision_Groups {
  
  private final static String CLASS_STAMP = "Groups";

  int[][] Curves = new int[0][2]; // start curve - end curve
  int[][] Faces = new int[0][2]; // start face - end face
  int[][] allSolids = new int[0][2]; // start solid - end solid
  int[][] allModel2Ds = new int[0][2]; // start object2D - end object2D
  int[][] allModel1Ds = new int[0][2]; // start allModel1Ds - end allModel1Ds
  int num = 0; 
  
  float[][] PivotXYZ = new float[0][9];
  int[][] PivotType = new int[0][1]; // 0: no solar rotation, 1: allow X-axis solar rotation, 2: allow X-axis solar rotation, 3: allow Z-axis solar rotation 4: free solar rotation (double axis tracking)
  
}

solarchvision_Groups allGroups = new solarchvision_Groups();   










int selected_posVector = 2; // 0:X, 1:Y, 2:Z, 3: All
int selected_rotVector = 2; // 0:X, 1:Y, 2:Z
int selected_scaleVector = 2; // 0:X, 1:Y, 2:Z, 3:All

float selected_posValue = 0;
float selected_rotValue = 0;  
float selected_scaleValue = 0; 

int selection_alignX = 0;
int selection_alignY = 0;
int selection_alignZ = 0;


boolean selected_displayReferencePivot = true;

boolean selectedGroup_displayPivot = true;
boolean selectedGroup_displayEdges = true; // false; 
boolean selectedGroup_displayBox = true;

boolean selectedFace_displayEdges = true;
boolean selectedFace_displayVertexCount = false;
boolean selectedCurve_displayVertexCount = false;
boolean selectedVertex_displayVertices = true;
boolean selectedCurve_displayVertices = true;


boolean selectedallModel2Ds_displayEdges = true;
boolean selectedallModel1Ds_displayEdges = true;
boolean selectedSolid_displayEdges = true;
boolean selectedSection_displayEdges = true;
boolean selectedCamera_displayEdges = true;
boolean selectedLandPoint_displayPoints = true;

int[] selectedLandPoint_ids = new int[0];
int[] selectedCamera_ids = new int[0];
int[] selectedSection_ids = new int[0];
int[] selectedSolid_ids = new int[0];
int[] selectedallModel1Ds_ids = new int[0];
int[] selectedallModel2Ds_ids = new int[0];
int[] selectedGroup_ids = new int[0];
int[] selectedFace_ids = new int[0];
int[] selectedVertex_ids = new int[0];
int[] selectedCurve_ids = new int[0];

int[] selectedVertex_softSelectionVertices = new int[0]; 
float[] selectedVertex_softSelectionValues = new float[0];

float softSelection_Power = 1;
float softSelection_Radius = 2; // 2 = 2m


int addToLastGroup = 0;


int Load_DefaultModels = 0; // internal

int addNewSelectionToPreviousSelection = 0; // internal



int[] GRIB2_TGL_Selected = {
  1, 0, 0, 0
}; // for levels above ground level 
int GRIB2_TGL_number = GRIB2_TGL_Selected.length;


















PrintWriter[] FILE_outputRaw;
PrintWriter[] FILE_outputNorms;
PrintWriter[] FILE_outputProbs;



void setup () {

  //size(1200, 696, P2D);
  size(2 * SOLARCHVISION_W_Pixel + ROLLOUT.dX, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel + SOLARCHVISION_D_Pixel, P2D);


  SOLARCHVISION_draw_frameIcon();

  TIME_Date = (286 + SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day)) % 365; // 0 presents March 21, 286 presents Jan.01, 345 presents March.01
  //if (TIME_Hour >= 12) TIME_Date += 0.5;   

  SOLARCHVISION_empty_Materials_DirectArea();
  SOLARCHVISION_empty_Materials_DiffuseArea();

  SOLARCHVISION_resize_VertexSolar_array(); 
  SOLARCHVISION_resize_GlobalSolar_array();
  
  Tropo3D.resize_images();
  
  Earth3D.resize_images();

  Star3D.load_images();
  Moon3D.load_images();

  WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

  WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);  

  STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  
  SKY2D_graphics = createGraphics(SKY2D_X_View, SKY2D_Y_View, P3D);

  SOLARCHVISION_loadDefaultFontStyle();  

  changeCurrentLayerTo(8); // pointing to air temperature variable i.e. on the list of allLayers 

  frameRate(24);

  loop();
}

void SOLARCHVISION_draw_frameIcon () {
  int frame_icon_size = 64;

  PGraphics frame_icon = createGraphics(frame_icon_size, frame_icon_size);  

  frame_icon.beginDraw();

  //frame_icon.image(loadImage(BaseFolder + "/Input/BackgroundImages/Standard/Maps/Icon/s-icon.png"), 0, 0 );

  frame_icon.background(0);
  //frame_icon.background(63,63,255,255);

  //frame_icon.fill(255,127);
  frame_icon.fill(255, 255, 0, 127);

  frame_icon.textAlign(CENTER, CENTER);
  frame_icon.textSize(1.0 * frame_icon_size);
  frame_icon.text("S", 0.20 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("A", 0.50 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("V", 0.80 * frame_icon_size, 0.4 * frame_icon_size);

  frame_icon.endDraw();
  frame.setIconImage(frame_icon.image);  

  frame.setTitle("SOLARCHVISION-2017");
}



void SOLARCHVISION_update_station (int Step) {

  if ((Step == 0) || (Step == 1)) {

    rebuild_VertexSolar_array = 1;
    rebuild_GlobalSolar_array = 1;
    rebuild_SolarImpactImage_array = 1;
    rebuild_WindRoseImage_array = 1;    

    WORLD.update = true;
    WIN3D.update = true; 
    STUDY.update = true;

    LocationLAT = STATION.getLatitude();
    LocationLON = STATION.getLongitude();

    WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
    
    TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
  }

  if ((Step == 0) || (Step == 2)) update_CLIMATE_TMYEPW();

  if ((Step == 0) || (Step == 3)) update_CLIMATE_CWEEDS();  
  
  if ((Step == 0) || (Step == 4)) update_CLIMATE_CLMREC();

  if ((Step == 0) || (Step == 5)) SOLARCHVISION_update_ENSEMBLE_OBSERVED();

  if ((Step == 0) || (Step == 6)) update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

  if ((Step == 0) || (Step == 7)) Land3D.update_mesh();

  //if ((Step == 0) || (Step == 8)) allModel1Ds.delete();

  if ((Step == 0) || (Step == 9)) allModel2Ds.delete();

  if ((Step == 0) || (Step == 10)) {

    allModel2Ds.add_onLand(1); // 1 = people

    allModel2Ds.add_onLand(2); // 2 = 2D trees
  }
}

void SOLARCHVISION_update_models (int Step) {

  if ((Step == 0) || (Step == 1)) allModel3Ds.delete_allGroups(); //not deleting all
  if ((Step == 0) || (Step == 2)) allModel3Ds.add_Model_Main();
}


int Last_initializationStep = 1000;
int InitializationStep = 0;





 

void draw () {

  //println("frameCount:", frameCount);

  Impact_TYPE = STUDY.PlotImpacts % 2; // <<<<<<<<<<<

  
  
  if (frameCount == 1) {

    background(223);

    SOLARCHVISION_update_folders();

    float cr;

    cr = SOLARCHVISION_W_Pixel / 4.0;
    PImage SOLARCHVISION_logo = loadImage(BackgroundFolder + "/" + "SOLARCHVISION.jpg");
    imageMode(CENTER);
    image(SOLARCHVISION_logo, 0.5 * width, 0.5 * height - 0.75 * MessageSize - cr + (0.075 * cr), 3.05 * cr, 3.05 * cr);
    imageMode(CORNER);

    strokeWeight(1);
    stroke(0);
    noFill();


    ellipseMode(CENTER);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);
    strokeWeight(1);
    stroke(255);
    noFill();    
    SOLARCHVISION_draw_logo(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(1);
    stroke(127);
    noFill();  
    //SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 0);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);    
    strokeWeight(1);
    stroke(255);
    noFill();  
    SOLARCHVISION_draw_logo(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, -1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);

    stroke(255);
    fill(255);
    textAlign(CENTER, CENTER); 
    textSize(3 * MessageSize);
    text("SOLARCHVISION model integrations 2017", 0.5 * width, 0.05 * height); 

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER); 
    textSize(1.5 * MessageSize);
    text("Raz, Mehr, Mehraz solarch studio\n1998-2017\nAuthor: Mojtaba Samimi\nwww.solarchvision.com", 0.5 * width, 0.75 * height);

    textAlign(CENTER, CENTER); 
    textSize(MessageSize);
  } else if (frameCount == 2) {
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("WORLD.listAllImages", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 3) {
    WORLD.listAllImages();
    WORLD.loadImages(WORLD.VIEW_id); // to load the globe image into memory

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("allModel2Ds.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 4) {
    allModel2Ds.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("SOLARCHVISION_Calendar", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 5) {
    SOLARCHVISION_Calendar(); 

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_SWOB", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 6) {
    inputCoordinates_SWOB(); 

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_NAEFS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 7) {
    inputCoordinates_NAEFS(); 
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 8) {
    inputCoordinates_CWEEDS();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 9) {
    inputCoordinates_CLMREC();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 10) {
    inputCoordinates_TMYEPW();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("SOLARCHVISION_update_date", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 11) {
    SOLARCHVISION_update_date();
    
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("SOLARCHVISION_update_station(start)", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 12) {
    SOLARCHVISION_update_station(1);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 13) {
    SOLARCHVISION_update_station(2);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 14) {
    SOLARCHVISION_update_station(3);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 15) {
    SOLARCHVISION_update_station(4);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("SOLARCHVISION_update_ENSEMBLE_OBSERVED", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 16) {
    SOLARCHVISION_update_station(5);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_ENSEMBLE_FORECAST", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 17) {
    SOLARCHVISION_update_station(6);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Land3D.update_mesh", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 18) {
    SOLARCHVISION_update_station(7);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("allModel1Ds.delete", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 19) {
    SOLARCHVISION_update_station(8);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("allModel2Ds.delete", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 20) {
    SOLARCHVISION_update_station(9);

    stroke(0); fill(0);
    rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255);
    text("allModel2Ds.add_onLand", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 21) {
    SOLARCHVISION_update_station(10);

    stroke(0); fill(0);
    rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("allModel3Ds.delete_allGroups", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 22) {
    SOLARCHVISION_update_models(1);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("allModel3Ds.add_Model_Main", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 23) {
    SOLARCHVISION_update_models(2);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Earth3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 24) {
    Earth3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);    
    
    stroke(255); fill(255); text("Tropo3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 25) {
    Tropo3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);    
 
    stroke(255); fill(255); text("SOLARCHVISION_build_SkySphere", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 26) {
    
    SOLARCHVISION_build_SkySphere(1); //1 - 3
    SOLARCHVISION_resize_GlobalSolar_array();    
    SOLARCHVISION_resize_VertexSolar_array();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Please wait while integrating the models.", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);

    MESSAGE.dX = 2 * SOLARCHVISION_W_Pixel;

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
    
    UI_BAR_a_update = true;
    UI_BAR_b_update = true;
    UI_BAR_c_update = true;
    UI_BAR_d_update = true;

    InitializationStep = frameCount; 
    Last_initializationStep = frameCount;
  } else {
    
    if (ROLLOUT.include) {
      if (ROLLOUT.update) {
        ROLLOUT.update = false;

        pre_SampleYear_Start = SampleYear_Start;
        pre_SampleYear_End = SampleYear_End;
        pre_SampleMember_Start = SampleMember_Start;
        pre_SampleMember_End = SampleMember_End;
        pre_SampleStation_Start = SampleStation_Start; 
        pre_SampleStation_End = SampleStation_End;
        pre_STUDY_JoinDays = STUDY.JoinDays;
        pre_STUDY_i_Start = STUDY.i_Start;
        pre_STUDY_i_End = STUDY.i_End;        
        pre_STUDY_j_End = STUDY.j_End;
        pre_IMPACTS_DisplayDay = IMPACTS_DisplayDay;
        pre_STUDY_Setup = STUDY.plotSetup;
        pre_CurrentDataSource = CurrentDataSource;
        pre_TIME_Year = TIME_Year;
        pre_TIME_Month = TIME_Month;
        pre_TIME_Day = TIME_Day;
        pre_TIME_Date = TIME_Date;
        pre_TIME_Hour = TIME_Hour;
        pre_CLIMATIC_SolarForecast = CLIMATIC_SolarForecast;
        pre_CLIMATIC_WeatherForecast = CLIMATIC_WeatherForecast;

        pre_CLIMATE_TMYEPW_load = CLIMATE_TMYEPW_load;
        pre_CLIMATE_CWEEDS_load = CLIMATE_CWEEDS_load;
        pre_CLIMATE_CLMREC_load = CLIMATE_CLMREC_load;
        pre_ENSEMBLE_FORECAST_load = ENSEMBLE_FORECAST_load;
        pre_ENSEMBLE_OBSERVED_load = ENSEMBLE_OBSERVED_load;       

        pre_LocationLAT = LocationLAT;
        pre_LocationLON = LocationLON;

        pre_WORLD_AutoView = WORLD.AutoView;

        pre_Land3D_Load_Mesh = Land3D.Load_Mesh;
        pre_Land3D_Load_Textures = Land3D.Load_Textures;

        pre_SOLID_Pallet_CLR = SOLID_Pallet_CLR;
        pre_SOLID_Pallet_DIR = SOLID_Pallet_DIR; 
        pre_SOLID_Pallet_MLT = SOLID_Pallet_MLT;         

        pre_CreateInput_powAll = CreateInput_powAll;

        pre_SolidImpact_scale_U = SolidImpact_scale_U;
        pre_SolidImpact_scale_V = SolidImpact_scale_V;

        pre_SolidImpact_offset_U = SolidImpact_offset_U;
        pre_SolidImpact_offset_V = SolidImpact_offset_V;

        pre_SolidImpact_Grade = SolidImpact_Grade;
        pre_SolidImpact_Power = SolidImpact_Power;
        pre_SolidImpact_Rotation[SolidImpact_sectionType] = SolidImpact_Rotation[SolidImpact_sectionType];
        pre_SolidImpact_Elevation[SolidImpact_sectionType] = SolidImpact_Elevation[SolidImpact_sectionType];

        pre_SolidImpact_Wspd = SolidImpact_WindSpeed; 
        pre_SolidImpact_Wdir = SolidImpact_WindDirection;

        pre_Process_subDivisions = Process_subDivisions;

        pre_Display_SolidImpact_Points = Display_SolidImpact_Points;
        pre_Display_SolidImpact_Lines = Display_SolidImpact_Lines;

        pre_Display_WindFlow = Display_WindFlow;



        pre_selectedSolid_displayEdges = selectedSolid_displayEdges;

        pre_selectedSection_displayEdges = selectedSection_displayEdges;

        pre_selectedCamera_displayEdges = selectedCamera_displayEdges;

        pre_selectedLandPoint_displayPoints = selectedLandPoint_displayPoints;

        pre_selectedallModel1Ds_displayEdges = selectedallModel1Ds_displayEdges;
        pre_selectedallModel2Ds_displayEdges = selectedallModel2Ds_displayEdges;
        pre_allModel3Ds_DisplayVertices = allModel3Ds.DisplayVertices;
        pre_allModel3Ds_DisplayEdges = allModel3Ds.DisplayEdges;
        pre_allModel3Ds_DisplayNormals = allModel3Ds.DisplayNormals;

        pre_softSelection_Power = softSelection_Power;
        pre_softSelection_Radius = softSelection_Radius;


        pre_selected_posValue = selected_posValue;
        pre_selected_rotValue = selected_rotValue;
        pre_selected_scaleValue = selected_scaleValue;        

        pre_selection_alignX = selection_alignX;
        pre_selection_alignY = selection_alignY;
        pre_selection_alignZ = selection_alignZ;

        pre_selected_displayReferencePivot = selected_displayReferencePivot;

        pre_selectedGroup_displayPivot = selectedGroup_displayPivot;
        pre_selectedGroup_displayEdges = selectedGroup_displayEdges;
        pre_selectedGroup_displayBox = selectedGroup_displayBox;        

        pre_selectedFace_displayEdges = selectedFace_displayEdges;
        pre_selectedFace_displayVertexCount = selectedFace_displayVertexCount;
        pre_selectedCurve_displayVertexCount = selectedCurve_displayVertexCount;
        pre_selectedVertex_displayVertices = selectedVertex_displayVertices;
        pre_selectedCurve_displayVertices = selectedCurve_displayVertices;

        pre_WIN3D_CurrentCamera = WIN3D.CurrentCamera; 

        pre_WIN3D_FacesShade = WIN3D.FacesShade;

        pre_allModel3Ds_Tessellation = allModel3Ds.Tessellation;


        pre_Load_DefaultModels = Load_DefaultModels;

        pre_STUDY_ImpactLayer = STUDY.ImpactLayer;

        pre_Develop_Option = Develop_Option;

        pre_STUDY_CurrentLayer_id = CurrentLayer_id;

        pre_STUDY_SkyScenario = STUDY.skyScenario;

        pre_STUDY_PlotImpacts = STUDY.PlotImpacts;

        ROLLOUT.drawView();

        if (pre_STUDY_PlotImpacts != STUDY.PlotImpacts) {
          WIN3D.update = true;
          STUDY.update = true;
        }

        if (pre_SampleYear_Start != SampleYear_Start) {
          UI_BAR_d_update = true;
        }            
        if (pre_SampleYear_End != SampleYear_End) {
          UI_BAR_d_update = true;
        }            

        if (pre_SampleMember_Start != SampleMember_Start) {
          UI_BAR_d_update = true;
        }  

        if (pre_SampleMember_End != SampleMember_End) {
          UI_BAR_d_update = true;
        }  

        if (pre_SampleStation_Start != SampleStation_Start) {
          UI_BAR_d_update = true;
        }  

        if (pre_SampleStation_End != SampleStation_End) {
          UI_BAR_d_update = true;
        }  

        if (pre_STUDY_JoinDays != STUDY.JoinDays) {
          UI_BAR_d_update = true;
        }            

        if (pre_STUDY_i_Start != STUDY.i_Start) {
          UI_BAR_d_update = true;
        }      

        if (pre_STUDY_i_End != STUDY.i_End) {
          UI_BAR_d_update = true;
        }      


        if (pre_STUDY_j_End != STUDY.j_End) {
          UI_BAR_d_update = true;

          rebuild_VertexSolar_array = 1;
          rebuild_GlobalSolar_array = 1;
          rebuild_SolarImpactImage_array = 1;
          rebuild_WindRoseImage_array = 1;      

          allSections.resize_SolarImpact_array();
        }

        if (pre_IMPACTS_DisplayDay != IMPACTS_DisplayDay) {
          UI_BAR_d_update = true;
        }

        if (pre_TIME_Date != TIME_Date) {
          UI_BAR_d_update = true;

          SOLARCHVISION_update_date();
          ROLLOUT.drawView();
        }

        if ((pre_TIME_Year != TIME_Year) || (pre_TIME_Month != TIME_Month) || (pre_TIME_Day != TIME_Day) || (pre_TIME_Hour != TIME_Hour) || (pre_CLIMATIC_SolarForecast != CLIMATIC_SolarForecast) || (pre_CLIMATIC_WeatherForecast != CLIMATIC_WeatherForecast)) {
          UI_BAR_d_update = true;

          TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
          TIME_Hour = int(24 * (TIME_Date - int(TIME_Date)));
          TIME_Date = (TIME_Hour / 24.0) + (286 + SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day)) % 365;
          println("DATE:", TIME_Date, "\tHOUR:", TIME_Hour);
          update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

          ROLLOUT.drawView();
        }

        

        if (pre_CLIMATE_TMYEPW_load != CLIMATE_TMYEPW_load) update_CLIMATE_TMYEPW();
        if (pre_CLIMATE_CWEEDS_load != CLIMATE_CWEEDS_load) update_CLIMATE_CWEEDS();
        if (pre_CLIMATE_CLMREC_load != CLIMATE_CLMREC_load) update_CLIMATE_CLMREC();
        if (pre_ENSEMBLE_OBSERVED_load != ENSEMBLE_OBSERVED_load) SOLARCHVISION_update_ENSEMBLE_OBSERVED();
        if (pre_ENSEMBLE_FORECAST_load != ENSEMBLE_FORECAST_load) update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

        if (pre_WORLD_AutoView != WORLD.AutoView) {
          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
        }



        if ((pre_LocationLAT != LocationLAT) || (pre_LocationLON != LocationLON)) {

          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
          WORLD.update = true;
        }




        if (pre_Land3D_Load_Mesh != Land3D.Load_Mesh) {
          Land3D.update_mesh();
          WIN3D.update = true;
        }

        if (pre_Land3D_Load_Textures != Land3D.Load_Textures) {
          Land3D.update_textures();
          WIN3D.update = true;
        }



        if (pre_selectedCamera_displayEdges != selectedCamera_displayEdges) {
          WIN3D.update = true;
        }

        if (pre_selectedSection_displayEdges != selectedSection_displayEdges) {
          WIN3D.update = true;
        }         

        if (pre_selectedSolid_displayEdges != selectedSolid_displayEdges) {
          WIN3D.update = true;
        }  

        if (pre_selectedLandPoint_displayPoints != selectedLandPoint_displayPoints) {
          WIN3D.update = true;
        }          


        if (pre_selectedallModel1Ds_displayEdges != selectedallModel1Ds_displayEdges) {
          WIN3D.update = true;
        }     

        if (pre_selectedallModel2Ds_displayEdges != selectedallModel2Ds_displayEdges) {
          WIN3D.update = true;
        }     


        if (pre_softSelection_Power != softSelection_Power) {    
          allModel3Ds.convert_Vertex_to_softSelection();
          WIN3D.update = true;
        }  

        if (pre_softSelection_Radius != softSelection_Radius) {
          allModel3Ds.convert_Vertex_to_softSelection();
          WIN3D.update = true;
        }  


        if (pre_selection_alignX != selection_alignX) {    
          println("SOLARCHVISION_calculate_selection_BoundingBox 24");    
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D.update = true;
        }        

        if (pre_selection_alignY != selection_alignY) {   
          println("SOLARCHVISION_calculate_selection_BoundingBox 25");     
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D.update = true;
        }      

        if (pre_selection_alignZ != selection_alignZ) {        
          println("SOLARCHVISION_calculate_selection_BoundingBox 26");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D.update = true;
        }      

        if (pre_selected_posValue != selected_posValue) {

          float d = selected_posValue - pre_selected_posValue;

          float dx = d;
          float dy = d;
          float dz = d;

          int the_Vector = selected_posVector;

          if (the_Vector == 0) {
            dy = 0; 
            dz = 0;
          }  
          if (the_Vector == 1) {
            dz = 0; 
            dx = 0;
          }  
          if (the_Vector == 2) {
            dx = 0; 
            dy = 0;
          }            

          SOLARCHVISION_move_Selection(dx, dy, dz);
          WIN3D.update = true;
        }
        if (pre_selected_rotValue != selected_rotValue) {

          float[] P = SOLARCHVISION_getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float r = selected_rotValue - pre_selected_rotValue;

          int the_Vector = selected_rotVector;

          SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);
          WIN3D.update = true;
        }
        if (pre_selected_scaleValue != selected_scaleValue) {

          float[] P = SOLARCHVISION_getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float s = pow(2.0, selected_scaleValue - pre_selected_scaleValue);

          float sx = s;
          float sy = s;
          float sz = s;

          int the_Vector = selected_scaleVector;

          if (the_Vector == 0) {
            sy = 1; 
            sz = 1;
          }  
          if (the_Vector == 1) {
            sz = 1; 
            sx = 1;
          }  
          if (the_Vector == 2) {
            sx = 1; 
            sy = 1;
          }           

          SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);
          WIN3D.update = true;
        }        


        if (pre_selected_displayReferencePivot != selected_displayReferencePivot) {
          WIN3D.update = true;
        }

        if (pre_selectedGroup_displayPivot != selectedGroup_displayPivot) {
          WIN3D.update = true;
        }             

        if (pre_selectedGroup_displayEdges != selectedGroup_displayEdges) {
          WIN3D.update = true;
        }

        if (pre_selectedGroup_displayBox != selectedGroup_displayBox) {
          WIN3D.update = true;
        }     

        if (pre_selectedFace_displayEdges != selectedFace_displayEdges) {
          WIN3D.update = true;
        }     

        if (pre_selectedFace_displayVertexCount != selectedFace_displayVertexCount) {
          WIN3D.update = true;
        }     
        
        if (pre_selectedCurve_displayVertexCount != selectedCurve_displayVertexCount) {
          WIN3D.update = true;
        }           

        if (pre_selectedVertex_displayVertices != selectedVertex_displayVertices) {
          WIN3D.update = true;
        }     

        if (pre_selectedCurve_displayVertices != selectedCurve_displayVertices) {
          WIN3D.update = true;
        }     


        if (pre_WIN3D_CurrentCamera != WIN3D.CurrentCamera) {
          WIN3D.apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();
          WIN3D.update = true;
        }


        if (pre_WIN3D_FacesShade != WIN3D.FacesShade) {
          WIN3D.update = true;
        }             

        if (pre_allModel3Ds_Tessellation != allModel3Ds.Tessellation) {
          //rebuild_VertexSolar_array = 1;
        }




        if (pre_Load_DefaultModels != Load_DefaultModels) {

          SOLARCHVISION_delete_All();

          allModel3Ds.add_DefaultModel(Load_DefaultModels);

          SOLARCHVISION_calculate_SolidImpact_selectedallSections();

          WIN3D.update = true;

          ROLLOUT.update = true;
        }


        if (pre_CreateInput_powAll != CreateInput_powAll) {
          CreateInput_powX = CreateInput_powAll;
          CreateInput_powY = CreateInput_powAll;
          CreateInput_powZ = CreateInput_powAll;

          ROLLOUT.update = true;
        }


        if (pre_SOLID_Pallet_CLR != SOLID_Pallet_CLR) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SOLID_Pallet_DIR != SOLID_Pallet_DIR) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SOLID_Pallet_MLT != SOLID_Pallet_MLT) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }

        if (pre_SolidImpact_Grade != SolidImpact_Grade) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_Power != SolidImpact_Power) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_Rotation[SolidImpact_sectionType] != SolidImpact_Rotation[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_Elevation[SolidImpact_sectionType] != SolidImpact_Elevation[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }

        if (pre_SolidImpact_scale_U[SolidImpact_sectionType] != SolidImpact_scale_U[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_scale_V[SolidImpact_sectionType] != SolidImpact_scale_V[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }

        if (pre_SolidImpact_offset_U[SolidImpact_sectionType] != SolidImpact_offset_U[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_offset_V[SolidImpact_sectionType] != SolidImpact_offset_V[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }


        if (pre_SolidImpact_Wspd != SolidImpact_WindSpeed) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }
        if (pre_SolidImpact_Wdir != SolidImpact_WindDirection) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }


        if (pre_Process_subDivisions != Process_subDivisions) {
          SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 
          WIN3D.update = true;
        }

        if (pre_Display_SolidImpact_Points != Display_SolidImpact_Points) WIN3D.update = true;
        if (pre_Display_SolidImpact_Lines != Display_SolidImpact_Lines) WIN3D.update = true;

        if (pre_allModel3Ds_DisplayVertices != allModel3Ds.DisplayVertices) WIN3D.update = true;
        if (pre_allModel3Ds_DisplayEdges != allModel3Ds.DisplayEdges) WIN3D.update = true;
        if (pre_allModel3Ds_DisplayNormals != allModel3Ds.DisplayNormals) WIN3D.update = true;

        if (pre_Display_WindFlow != Display_WindFlow) WIN3D.update = true;


        if (STUDY.plotSetup != pre_STUDY_Setup) {
          STUDY.Impacts_update = true;
          UI_BAR_d_update = false;
        }

        if (CurrentDataSource != pre_CurrentDataSource) {
          STUDY.Impacts_update = true;
          UI_BAR_d_update = false;
        }
      }
    }



    if (FRAME_record_AUTO) {
      if (STUDY.update) FRAME_record_JPG = true;
      if (WIN3D.update) FRAME_record_JPG = true;
      if (WORLD.update) FRAME_record_JPG = true;
      //if (UI_BAR_a_update) FRAME_record_JPG = true;
      //if (UI_BAR_b_update) FRAME_record_JPG = true;
      //if (UI_BAR_d_update) FRAME_record_JPG = true;
    }




    int Illustrations_Animate = 0;

    //if ((STUDY.update == false) && (WIN3D.update == false)) {
    if (STUDY.update == false) {
      //Illustrations_Animate = 1;
    }

    if (STUDY.include) {
      if (STUDY.update) {

        STUDY.drawView();
      }
    }
    STUDY.update = false;

    if (STUDY.record_PDF == false) {
      /*      
       if (Illustrations_Animate != 0) {
       GRIB2_Layer = GRIB2_Layer_Start;
       
       GRIB2_Hour = GRIB2_Hour_Start;
       
       int d = (GRIB2_Hour_End - GRIB2_Hour_Start) / GRIB2_Hour_Step;      
       
       if (d > 1) {
       
       GRIB2_Hour += GRIB2_Hour_Step * (frameCount % d);
       
       if (GRIB2_Hour > GRIB2_Hour_End) GRIB2_Hour = GRIB2_Hour_Start;
       
       WORLD.update = true;
       WIN3D.update = true; // <<<<<<<<<<<
       }
       }
       */

      if (WORLD.include) {
        if (WORLD.update) {

          WORLD.drawView();
        }
      }

      if (WORLD.record_PDF == false) {      
        if (WIN3D.include) {
          if (WIN3D.update) {
            
            SOLARCHVISION_regenerate_desired_bakings();

            WIN3D.drawView();
          }
        }

        if (UI_BAR_a_update) {
          SOLARCHVISION_draw_window_BAR_a();
        }

        if (UI_BAR_b_update) {
          SOLARCHVISION_draw_window_BAR_b();
        }

        if (UI_BAR_c_update) {
          SOLARCHVISION_draw_window_BAR_c();
        }  

        if (UI_BAR_d_update) {
          SOLARCHVISION_draw_window_BAR_d();
        }    



        if (FRAME_record_JPG) {
          SOLARCHVISION_RecordFrame();
          FRAME_record_JPG = false;
        }
      } else {
        WORLD.record_PDF = false;
      }
    } else {
      STUDY.record_PDF = false;
    }


    //WIN3D.update = false;
    //WORLD.update = false;
    //STUDY.update = false;

    //noLoop(); // <<<<<<<<<<<<
    
    
    
  }
} 








void SOLARCHVISION_find_which_bakings_to_regenerate () {

  if (WIN3D.FacesShade == SHADE.Global_Solar) {
    rebuild_GlobalSolar_array = 1;
  }
  if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
    rebuild_VertexSolar_array = 1;
  }  
  if (Display_SolarImpactImage) {
    rebuild_SolarImpactImage_array = 1;
  }     
  if (Display_WindRoseImage) {
    rebuild_WindRoseImage_array = 1;
  }      
}  



void SOLARCHVISION_regenerate_desired_bakings () {
  
  if (rebuild_VertexSolar_array != 0) {
    SOLARCHVISION_calculate_VertexSolar_array();
  }
  
  if (rebuild_GlobalSolar_array != 0) {
    SOLARCHVISION_calculate_GlobalSolar_array();
  }
  
}




















 
















String[] SOLARCHVISION_getfiles (String _Folder) {
  
  //println(_Folder);
  
  String[] filenames = new String[0];
  
  File dir = new File(_Folder);
  
  if (dir.exists() && dir.isDirectory()) {
    
    filenames = concat(filenames, dir.list());
  
    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        //println(filenames[i]);
      }
    }
  }
  
  return filenames;
}



int SOLARCHVISION_getOpacity (float O_scale) {
  int k = int(O_scale * 0.01 * 256);
  if (k > 255) k = 255;
  if (k < 0) k = 0;

  return k;
}


float asin_ang (float a) {
  return ((asin(a)) * 180/PI);
}

float acos_ang (float a) {
  return ((acos(a)) * 180/PI);
}

float atan_ang (float a) {
  return ((atan(a)) * 180/PI);
}

float atan2_ang (float a, float b) {
  return ((atan2(a, b)) * 180/PI);
}


float sin_ang (float a) {
  return sin(a * PI / 180);
}

float cos_ang (float a) {
  return cos(a * PI / 180);
}

float tan_ang (float a) {
  return tan(a * PI / 180);
}




float roundTo (float a, float b) {
  float a_floor = (floor (a / (1.0 * b))) * b;
  float a_ceil =  (ceil (a / (1.0 * b))) * b;
  float c;
  if ((a - a_floor) > (a_ceil - a)) {
    c = a_ceil;
  } else {
    c = a_floor;
  }
  return c;
}

float dist_lon_lat (double lon1, double lat1, double lon2, double lat2) {

  float dLon = (float) (lon2 - lon1); 
  float dLat = (float) (lat2 - lat1);

  float a = sin_ang(dLon / 2.0);
  float b = sin_ang(dLat / 2.0) * sin_ang(dLat / 2.0) + cos_ang((float) lat1) * cos_ang((float) lat2) * a * a;
  float d = 2 * atan2(sqrt(b), sqrt(1 - b)) * (float) DOUBLE_r_Earth; 

  return(d);
}

float SOLARCHVISION_fn_dist (float[] a, float[] b) {

  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(b[i] - a[i], 2);
  }
  d = pow(d, 0.5);

  return d;
}

float[] SOLARCHVISION_fn_G (float[][] a) {

  float[] b = a[0]; // initializing to the first node

  // adding other nodes
  for (int i = 1; i < a.length; i++) {
    for (int j = 0; j < b.length; j++) {
      b[j] += a[i][j];
    }
  }

  // dividing to the number of nodes
  for (int j = 0; j < b.length; j++) {
    b[j] /= float(a.length);
  }

  return b;
}

float[] SOLARCHVISION_fn_normalize (float[] a) {
  float[] b = a;
  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(a[i], 2);
  }
  d = pow(d, 0.5);

  for (int i = 0; i < a.length; i++) {
    if (d != 0) b[i] = a[i]/d;
    else b[i] = 0;
  } 
  return b;
}

float SOLARCHVISION_fn_dot (float[] a, float b[]) {
  float d = 0;
  for (int i = 0; i < min (a.length, b.length); i++) {
    d += a[i] * b[i];
  }
  return d;
}

float SOLARCHVISION_3xDot (float[] a, float b[]) {
  
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

float[] SOLARCHVISION_3xCross (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[1] * b[2] - a[2] * b[1];
  c[1] = a[2] * b[0] - a[0] * b[2];
  c[2] = a[0] * b[1] - a[1] * b[0];
  
  return c;
  
}


float[] SOLARCHVISION_3xSub (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[0] - b[0];
  c[1] = a[1] - b[1];
  c[2] = a[2] - b[2];
  
  return c;
  
}


float[] SOLARCHVISION_3xSum (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[0] + b[0];
  c[1] = a[1] + b[1];
  c[2] = a[2] + b[2];
  
  return c;
  
}


float SOLARCHVISION_Bilinear (float f_00, float f_10, float f_11, float f_01, float x, float y) {

  float f_xy = f_00 * (1 - x) * (1 - y) + f_10 * x * (1 - y) + f_01 * (1 - x) * y + f_11 * x * y;

  return f_xy;
}


boolean SOLARCHVISION_isInside_Triangle (float[] P, float[] A, float[] B, float[] C) {

  float pX = P[0] - C[0];
  float pY = P[1] - C[1];
  float pZ = P[2] - C[2];
    
  float aX = A[0] - C[0];
  float aY = A[1] - C[1];
  float aZ = A[2] - C[2];

  float bX = B[0] - C[0];
  float bY = B[1] - C[1];
  float bZ = B[2] - C[2];

  float AA = aX * aX + aY * aY + aZ * aZ; // SOLARCHVISION_3xDot(a, a);
  float AB = aX * bX + aY * bY + aZ * bZ; // SOLARCHVISION_3xDot(a, b);
  float AP = aX * pX + aY * pY + aZ * pZ; // SOLARCHVISION_3xDot(a, p);
  float BB = bX * bX + bY * bY + bZ * bZ; // SOLARCHVISION_3xDot(b, b);
  float BP = bX * pX + bY * pY + bZ * pZ; // SOLARCHVISION_3xDot(b, p);
  
  float r = (AA * BB - AB * AB);
  float u = (BB * AP - AB * BP) / r;
  float v = (AA * BP - AB * AP) / r;
  
  return ((u >= 0) && (v >= 0) && (u + v <= 1));
}


boolean SOLARCHVISION_isInside_Quadrangle (float[] P, float[] A, float[] B, float[] C, float[] D) {  

  float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]), 0.25 * (A[1] + B[1] + C[1] + D[1]), 0.25 * (A[2] + B[2] + C[2] + D[2])};

  float pX = P[0] - G[0];
  float pY = P[1] - G[1];
  float pZ = P[2] - G[2];

  float aX = A[0] - G[0];
  float aY = A[1] - G[1];
  float aZ = A[2] - G[2];

  float bX = B[0] - G[0];
  float bY = B[1] - G[1];
  float bZ = B[2] - G[2];
  
  float AA = aX * aX + aY * aY + aZ * aZ; // SOLARCHVISION_3xDot(a, a);
  float AB = aX * bX + aY * bY + aZ * bZ; // SOLARCHVISION_3xDot(a, b);
  float AP = aX * pX + aY * pY + aZ * pZ; // SOLARCHVISION_3xDot(a, p);
  float BB = bX * bX + bY * bY + bZ * bZ; // SOLARCHVISION_3xDot(b, b);
  float BP = bX * pX + bY * pY + bZ * pZ; // SOLARCHVISION_3xDot(b, p);

  float r = (AA * BB - AB * AB);
  float u = (BB * AP - AB * BP) / r;
  float v = (AA * BP - AB * AP) / r;
 
  boolean result = ((u >= 0) && (v >= 0) && (u + v <= 1));
  
  if (result == false) {

    float cX = C[0] - G[0];
    float cY = C[1] - G[1];
    float cZ = C[2] - G[2];

    float CC = cX * cX + cY * cY + cZ * cZ; // SOLARCHVISION_3xDot(c, c);
    float CP = cX * pX + cY * pY + cZ * pZ; // SOLARCHVISION_3xDot(c, p);
    float BC = bX * cX + bY * cY + bZ * cZ; // SOLARCHVISION_3xDot(b, c);
  
    r = (BB * CC - BC * BC);
    u = (CC * BP - BC * CP) / r;
    v = (BB * CP - BC * BP) / r;  
    
    result = ((u >= 0) && (v >= 0) && (u + v <= 1));
    
    if (result == false) {

      float dX = D[0] - G[0];
      float dY = D[1] - G[1];
      float dZ = D[2] - G[2];
      
      float CD = cX * dX + cY * dY + cZ * dZ; // SOLARCHVISION_3xDot(c, d);
      float DD = dX * dX + dY * dY + dZ * dZ; // SOLARCHVISION_3xDot(d, d);
      float DP = dX * pX + dY * pY + dZ * pZ; // SOLARCHVISION_3xDot(d, p);
    
      r = (CC * DD - CD * CD);
      u = (DD * CP - CD * DP) / r;
      v = (CC * DP - CD * CP) / r;
      
      result = ((u >= 0) && (v >= 0) && (u + v <= 1));
      
      if (result == false) {
        
        float DA = dX * aX + dY * aY + dZ * aZ; // SOLARCHVISION_3xDot(d, a);  
        
        r = (DD * AA - DA * DA);
        u = (AA * DP - DA * AP) / r;
        v = (DD * AP - DA * DP) / r;
        
        result = ((u >= 0) && (v >= 0) && (u + v <= 1));
      }  
    }
  }
  
  return result;
}

boolean SOLARCHVISION_isInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // good for rectangular surfaces namely for selecting allModel2Ds, etc.  

  float pX = P[0] - O[0];
  float pY = P[1] - O[1];
  float pZ = P[2] - O[2];
    
  float aX = A[0] - O[0];
  float aY = A[1] - O[1];
  float aZ = A[2] - O[2];

  float bX = B[0] - O[0];
  float bY = B[1] - O[1];
  float bZ = B[2] - O[2];

  float AA = aX * aX + aY * aY + aZ * aZ; // SOLARCHVISION_3xDot(a, a);
  float AB = aX * bX + aY * bY + aZ * bZ; // SOLARCHVISION_3xDot(a, b);
  float AP = aX * pX + aY * pY + aZ * pZ; // SOLARCHVISION_3xDot(a, p);
  float BB = bX * bX + bY * bY + bZ * bZ; // SOLARCHVISION_3xDot(b, b);
  float BP = bX * pX + bY * pY + bZ * pZ; // SOLARCHVISION_3xDot(b, p);
  
  float r = (AA * BB - AB * AB);
  float u = (BB * AP - AB * BP) / r;
  float v = (AA * BP - AB * AP) / r;
  
  return ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1));
}

float[] SOLARCHVISION_uvInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // copy of the function above but it returns u and v

  float pX = P[0] - O[0];
  float pY = P[1] - O[1];
  float pZ = P[2] - O[2];
    
  float aX = A[0] - O[0];
  float aY = A[1] - O[1];
  float aZ = A[2] - O[2];

  float bX = B[0] - O[0];
  float bY = B[1] - O[1];
  float bZ = B[2] - O[2];

  float AA = aX * aX + aY * aY + aZ * aZ; // SOLARCHVISION_3xDot(a, a);
  float AB = aX * bX + aY * bY + aZ * bZ; // SOLARCHVISION_3xDot(a, b);
  float AP = aX * pX + aY * pY + aZ * pZ; // SOLARCHVISION_3xDot(a, p);
  float BB = bX * bX + bY * bY + bZ * bZ; // SOLARCHVISION_3xDot(b, b);
  float BP = bX * pX + bY * pY + bZ * pZ; // SOLARCHVISION_3xDot(b, p);
  
  float r = (AA * BB - AB * AB);
  float u = (BB * AP - AB * BP) / r;
  float v = (AA * BP - AB * AP) / r;
  
  float[] result = {u, v};
  
  return result;
}





class solarchvision_PAINT {

  float[] WBGRW (float _variable) {
    _variable *= 600.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
  
    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = v;
      COL[3] = v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
  
  float[] BGR (float _variable) {
    _variable *= 400.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
  
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DBGR (float _variable) {
    _variable *= 500.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DWBGR (float _variable) {
    _variable *= 600.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DWYR (float _variable) {
    _variable *= 400.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255 - 0.5 * v;
      COL[2] = 0;
      COL[3] = 0;
    } else {
      COL[1] = 127;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  
  float[] VDWBGR (float _variable) {
    _variable *= 700.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable - 0) * 2.55);
      COL[1] = (255 - v);
      COL[2] = 0;
      COL[3] = (255 - v);
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 700) {
      v = ((_variable - 600) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DRYWCBD (float _variable) {
  
    _variable *= 1.5;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable <= -2.75) {
      COL[1] = 63;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else if (_variable < 1) {
      v = (_variable * 255);
      COL[1] = 255 - v;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 2) {
      v = ((_variable - 1) * 255);
      COL[1] = 0;
      COL[2] = 255 - v;
      COL[3] = 255;
    } else if (_variable < 2.75) {
      v = ((_variable - 2) * 255);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255 - v;
    } else {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 63;
    }
  
    return COL;
  }
  
  
  float[] DBCW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    float r, g, b;
    r = COL[3]; 
    g = COL[2];
    b = COL[1];
    COL[1] = r;
    COL[2] = g;
    COL[3] = b;
  
    return COL;
  }
  
  float[] DRYW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
  
  float[] WYRD (float _variable) {
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
    
    
  float[] getColorStyle (int COLOR_STYLE_Current, float j) {
    float[] c = {
      255, 0, 0, 0
    };
  
    if (COLOR_STYLE_Current == 0) {
      c[0] = SOLARCHVISION_getOpacity(STUDY.O_scale);
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == 19) {
      float[] COL = this.DWYR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 18) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 17) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    } else if (COLOR_STYLE_Current == 16) {
      float[] COL = this.DBCW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 15) {
      float[] COL = this.DRYW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 14) {
      float[] COL = this.DBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 13) {
      float[] COL = this.DWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 12) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 11) {
      float[] COL = this.BGR(j);
      c[0] = 127;
      c[1] = 255 - 0.5 * COL[1];
      c[2] = 255 - 0.5 * COL[2];
      c[3] = 255 - 0.5 * COL[3];
    } else if (COLOR_STYLE_Current == 10) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 9) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 8) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 7) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 6) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 4) {
      float[] COL = this.VDWBGR(j);
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 3) {
      float[] COL = this.VDWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 2) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 5) {
      c[0] = 255;
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == -1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    } 
  
  
    return c;
  }    
}

solarchvision_PAINT PAINT = new solarchvision_PAINT();





void SOLARCHVISION_Calendar () {
  CalendarMM = new String [365][2];
  CalendarDD = new String [365][2];
  CalendarDay = new String [365][2];

  CalendarDate = new int [365][2];

  int k = 285;
  for (int l = 0; l < 2; l++) {
    for (int i = 0; i < 12; i++) {
      for (int j = 0; j < CalendarLength[i]; j++) {
        k += 1;
        if (k == 365) k = 0; 
        CalendarMM[k][l] = CalendarMonth[i][l];
        CalendarDD[k][l] = String.valueOf(j + 1);
        CalendarDay[k][l] = CalendarDD[k][l] + " " + CalendarMM[k][l];

        CalendarDate[k][0] = i + 1;
        CalendarDate[k][1] = j + 1;
      }
    }
  }
}

int SOLARCHVISION_Convert2Day (int Date_Angle) {
  int DAY = (Date_Angle + 360) % 360;
  if (DAY >=  31) DAY += 1;
  if (DAY >=  62) DAY += 1;
  if (DAY >=  93) DAY += 1;
  if (DAY >= 124) DAY += 1;
  if (DAY >= 155) DAY += 1;
  DAY = DAY % 365;
  return DAY;
}

int SOLARCHVISION_Convert2Date (int TIME_Month, int TIME_Day) {
  int k = 0;
  for (int i = 0; i < (TIME_Month - 1); i++) {
    for (int j = 0; j < CalendarLength[i]; j++) {
      k += 1;
      if (k == 365) k = 0;
    }
  }
  k += TIME_Day - 1;

  k = k % 365;
  return k;
}

void SOLARCHVISION_update_date () {
  TIME_Month = CalendarDate[int(TIME_Date)][0]; 
  TIME_Day = CalendarDate[int(TIME_Date)][1];
  TIME_Hour = int(24 * (TIME_Date - int(TIME_Date)));
}
















int STAT_N_MidLow = 0;
int STAT_N_Middle = 1;
int STAT_N_MidHigh = 2;

int STAT_N_M25 = 3;
int STAT_N_M50 = 4;
int STAT_N_M75 = 5;

int STAT_N_Min = 6;
int STAT_N_Ave = 7;
int STAT_N_Max = 8;

String[] STAT_N_Title = {
  "Mid-LOW*       ", 
  "MIDDLE*        ", 
  "Mid-HIGH*      ", 

  "25th Percentile", 
  "50th P.(Median)", 
  "75th Percentile", 

  "MINIMUM        ", 
  "AVERAGE        ", 
  "MAXIMUM        "
};

int[] STAT_reverse_N;
{
  STAT_reverse_N = new int [9];
  STAT_reverse_N[STAT_N_MidLow] = STAT_N_MidHigh;
  STAT_reverse_N[STAT_N_Middle] = STAT_N_Middle;
  STAT_reverse_N[STAT_N_MidHigh] = STAT_N_MidLow;
  STAT_reverse_N[STAT_N_M25] = STAT_N_M75;
  STAT_reverse_N[STAT_N_M50] = STAT_N_M50;
  STAT_reverse_N[STAT_N_M75] = STAT_N_M25;
  STAT_reverse_N[STAT_N_Min] = STAT_N_Max;
  STAT_reverse_N[STAT_N_Ave] = STAT_N_Ave;
  STAT_reverse_N[STAT_N_Max] = STAT_N_Min;
}

float[] SOLARCHVISION_NORMAL (float[] _values) {

  float[] weight_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  float[] return_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };

  int NV = 0; // the number of values without counting undefined values
  float _weight = 0; 

  _values = sort(_values);
  for (int i = 0; i < _values.length; i++) {
    if (is_undefined_FLOAT(_values[i]) == false) NV += 1;
  }

  if (NV > 0) {
    for (int i = 0; i < NV; i++) {
      if (is_undefined_FLOAT(_values[i]) == false) {
        _weight = 1;
        weight_array[STAT_N_Ave] += _weight;
        return_array[STAT_N_Ave] += _values[i];

        _weight = (0.5 * (NV + 1)) - abs((0.5 * (NV + 1)) - (i + 1));
        weight_array[STAT_N_Middle] += _weight;
        return_array[STAT_N_Middle] += _values[i] * _weight;

        _weight = (i + 1);
        weight_array[STAT_N_MidHigh] += _weight;
        return_array[STAT_N_MidHigh] += _values[i] * _weight;

        _weight = (NV + 1 - i);
        weight_array[STAT_N_MidLow] += _weight;
        return_array[STAT_N_MidLow] += _values[i] * _weight;
      }
    }

    return_array[STAT_N_Ave] /= weight_array[STAT_N_Ave];
    return_array[STAT_N_Middle] /= weight_array[STAT_N_Middle];
    return_array[STAT_N_MidHigh] /= weight_array[STAT_N_MidHigh];
    return_array[STAT_N_MidLow] /= weight_array[STAT_N_MidLow];

    return_array[STAT_N_Max] = _values[(NV - 1)];
    return_array[STAT_N_Min] = _values[0];

    if ((NV % 2) == 1) {

      return_array[STAT_N_M50] = _values[(floor(NV / 2))];
    } else {

      return_array[STAT_N_M50] = 0.5 * (_values[(floor(NV / 2))] + _values[(floor(NV / 2) - 1)]);
    }

    int q;

    q = int(roundTo((NV * 0.75), 1));
    if (q > NV - 1) q = NV - 1;
    return_array[STAT_N_M75] = _values[q];

    q = int(roundTo((NV * 0.25), 1));
    if (q < 0) q = 0;
    return_array[STAT_N_M25] = _values[q];
  } else {
    for (int i = 0; i < return_array.length; i++) {
      return_array[i] = FLOAT_undefined;
    }
  }

  return return_array;
}



int SOLARCHVISION_filter (int dataID, int cloudCover_id, int type_of_filter, int scenario_of_sky, int now_i, int now_j, int now_k) {

  float total_sky = 0;
  int num_sky = 0;

  int start_q = now_i;
  int end_q = now_i;

  if (type_of_filter == FILTER_Daily) {
    start_q = 0;
    end_q = 23;
  }

  for (int q = start_q; q <= end_q; q++) {
    float _sky = FLOAT_undefined;
    if (dataID == dataID_ENSEMBLE_OBSERVED)      _sky = ENSEMBLE_OBSERVED_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_ENSEMBLE_FORECAST) _sky = ENSEMBLE_FORECAST_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CWEEDS)    _sky = CLIMATE_CWEEDS_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CLMREC)    _sky = CLIMATE_CLMREC_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_TMYEPW)    _sky = CLIMATE_TMYEPW_values   [q][now_j][cloudCover_id][now_k];
    else {
      println("ERROR: This dataID is not declared:", dataID);
    }

    if (is_undefined_FLOAT(_sky)) {
    } else {
      total_sky += _sky;
      num_sky += 1;
    }
  }


  int _return = 0;

  if (num_sky != 0) {
    total_sky /= num_sky;

    if (scenario_of_sky == 1) _return = 1;
    else if ((scenario_of_sky == 4) && (total_sky <= 3.33)) _return = 1;
    else if ((scenario_of_sky == 3) && (total_sky > 3.33) && (total_sky <= 6.66)) _return = 1; 
    else if ((scenario_of_sky == 2) && (total_sky > 6.66)) _return = 1;
  }

  return _return;
}


int[] SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS (float[] _values) {

  float[] _normals = SOLARCHVISION_NORMAL(_values);

  int[] return_array = new int [9];

  for (int l = 0; l < 9; l++) {
    return_array[l] = -1;
    if (is_undefined_FLOAT(_normals[l]) == false) {

      float _dist = FLOAT_undefined;

      for (int i = 0; i < _values.length; i++) {
        if (_dist > abs(_normals[l] - _values[i])) {
          _dist = abs(_normals[l] - _values[i]);
          return_array[l] = i;
        }
      }
    } else return_array[l] = -1;
  }

  return return_array;
}


int[] SOLARCHVISION_PROCESS_DAILY_SCENARIOS (int start_k, int end_k, int j, float DATE_ANGLE) {
  
  int count_k = 1 + end_k - start_k;
  if (count_k < 0) count_k = 0;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  float[] _valuesSUM_RAD; 
  float[] _valuesSUM_EFF;
  float[] _valuesNUM;
  _valuesSUM_RAD = new float [(count_k * STUDY.JoinDays)];
  _valuesSUM_EFF = new float [(count_k * STUDY.JoinDays)];
  _valuesNUM = new float [(count_k * STUDY.JoinDays)];

  for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {
    for (int k = 0; k < count_k; k++) { 
      _valuesSUM_RAD[(k * STUDY.JoinDays + j_ADD)] = FLOAT_undefined;
      _valuesSUM_EFF[(k * STUDY.JoinDays + j_ADD)] = FLOAT_undefined;
      _valuesNUM[(k * STUDY.JoinDays + j_ADD)] = 0;
    }
  }

  for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {

    for (int k = 0; k < count_k; k++) {

      for (int i = 0; i < 24; i++) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

        int now_k = k + start_k;
        int now_i = i;
        int now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
        Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
        Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
        Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

        if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
        } else {

          int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k); 

          if (memberCount == 1) {
            _values_R_dir = 0.001 * Pa;
            _values_R_dif = 0.001 * Pb;
            _values_E_dir = 0.0001 * Pc;
            _values_E_dif = 0; //0.0001 * Pd;

            if (is_undefined_FLOAT(_valuesSUM_RAD[(k * STUDY.JoinDays + j_ADD)])) {
              _valuesSUM_RAD[(k * STUDY.JoinDays + j_ADD)] = 0;
              _valuesSUM_EFF[(k * STUDY.JoinDays + j_ADD)] = 0;
              _valuesNUM[(k * STUDY.JoinDays + j_ADD)] = 0;
            }                  

            _valuesSUM_RAD[(k * STUDY.JoinDays + j_ADD)] += ((_values_R_dir * SunR[3]) + (_values_R_dif)); // calculates total horizontal radiation
            _valuesSUM_EFF[(k * STUDY.JoinDays + j_ADD)] += ((_values_E_dir * SunR[3]) + (_values_E_dif)); // calculates total horizontal effects
            _valuesNUM[(k * STUDY.JoinDays + j_ADD)] += 1;
          }
        }
      }
    }
  }

  if (Impact_TYPE == Impact_PASSIVE) 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_EFF);
  else 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_RAD);
}


void SOLARCHVISION_PlotIMPACT (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY.graphics.pushMatrix();
  STUDY.graphics.translate(x_Plot, y_Plot);

  float keep_STUDY_PerDays = STUDY.PerDays;
  int keep_STUDY_JoinDays = STUDY.JoinDays;

  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.PerDays = 1;
    STUDY.JoinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;


  if ((STUDY.PlotImpacts == -2) || (STUDY.PlotImpacts == -1)) {

    SOLARCHVISION_resize_WindRose_Image_array(); 

    int RES = WindRose_RES;

    Rendered_WindRose_RES = RES;

    if (STUDY.PlotImpacts == -2) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY.PlotImpacts == -1) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;

    float[] _values_w_dir;
    float[] _values_w_spd; 
    float[] _values_w_tmp; 
    _values_w_dir = new float [count_k];
    _values_w_spd = new float [count_k]; 
    _values_w_tmp = new float [count_k]; 

    for (int k = 0; k < count_k; k++) { 
      _values_w_dir[k] = FLOAT_undefined;
      _values_w_spd[k] = FLOAT_undefined;
      _values_w_tmp[k] = FLOAT_undefined;
    }

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      //PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
      PAL_TYPE = 12; 
      PAL_DIR = -1;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 1.0 / 30.0;

    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 

      PGraphics WIND_graphics = createGraphics(RES, RES); 
      WIND_graphics.beginDraw();
      //WIND_graphics.background(255);
      WIND_graphics.translate(0.5 * RES, 0.5 * RES);

      for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {    
        for (int i = 0; i < 24; i++) {
          if (STUDY.isInHourlyRange(i) == 1) {

            for (int k = 0; k < count_k; k++) {

              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;

              int _plot = 1;

              if (_plot == 1) {

                int now_k = k + start_k;
                int now_i = i;
                int now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);

                if (is_undefined_FLOAT(Pa) || is_undefined_FLOAT(Pb) || is_undefined_FLOAT(Pc)) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                } else {
                  int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);

                  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;

                  if (memberCount == 1) {

                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;

                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (_values_w_spd[k] / 50.0);

                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 

                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) {

                      float _s = (STUDY.O_scale / 100) * 255 / (0.333 * count_k); 

                      if (STUDY.skyScenario > 1) _s *= 3; // to improve visibility of those cases.

                      _s /= float(STUDY.JoinDays);

                      if (_s < 10) _s = 10;

                      WIND_graphics.stroke(0, _s);
                      WIND_graphics.fill(0, _s); 

                      WIND_graphics.strokeWeight(STUDY.T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_PASSIVE) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);

                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;

                      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);

                      WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

                      WIND_graphics.strokeWeight(STUDY.T_scale * 2);
                      WIND_graphics.noFill();
                    }

                    WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  }
                }
              }
            }
          }
        }
      }
      WIND_graphics.endDraw();
      WindRose_Image[j + 1] = WIND_graphics;
    }




    PGraphics total_WIND_graphics = createGraphics(RES, RES); 
    total_WIND_graphics.beginDraw();
    //total_WIND_graphics.background(255);
    total_WIND_graphics.translate(0.5 * RES, 0.5 * RES);

    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 
      for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {    
        for (int i = 0; i < 24; i++) {
          if (STUDY.isInHourlyRange(i) == 1) {

            for (int k = 0; k < count_k; k++) {

              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;

              int _plot = 1;

              if (_plot == 1) {

                int now_k = k + start_k;
                int now_i = i;
                int now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);

                if (is_undefined_FLOAT(Pa) || is_undefined_FLOAT(Pb) || is_undefined_FLOAT(Pc)) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                } else {
                  int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                  
                  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;

                  if (memberCount == 1) {

                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;

                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (_values_w_spd[k] / 50.0);

                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 

                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) {

                      float _s = (STUDY.O_scale / 100) * 255 / (0.333 * count_k) / (STUDY.j_End - STUDY.j_Start);

                      if (STUDY.skyScenario > 1) _s *= 3; // to improve visibility of those cases.

                      _s /= float(STUDY.JoinDays);

                      if (_s < 10) _s = 10;

                      total_WIND_graphics.stroke(0, _s);
                      total_WIND_graphics.fill(0, _s); 

                      total_WIND_graphics.strokeWeight(STUDY.T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_PASSIVE) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);

                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;

                      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
                      total_WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

                      total_WIND_graphics.strokeWeight(STUDY.T_scale * 2);
                      total_WIND_graphics.noFill();
                    }

                    total_WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  }
                }
              }
            }
          }
        }
      }
    }
    total_WIND_graphics.endDraw();
    WindRose_Image[0] = total_WIND_graphics;          

    for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) {
      if ((j != -1) || (STUDY.impact_summary)) {
        STUDY.graphics.strokeWeight(STUDY.T_scale * 0);
        STUDY.graphics.stroke(223);
        STUDY.graphics.fill(223); 
        STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

        STUDY.graphics.strokeWeight(STUDY.T_scale * 2);
        STUDY.graphics.stroke(255);
        STUDY.graphics.noFill(); 
        STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

        STUDY.graphics.imageMode(CENTER); 
        STUDY.graphics.image(WindRose_Image[j + 1], (j + 100 * STUDY.rect_scale) * sx_Plot, 0, int((180 * STUDY.rect_scale) * sx_Plot), int((180 * STUDY.rect_scale) * sx_Plot));
      }
    }   

    STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

    if (STUDY.impact_summary) {
      int j = -1; // << to put the summary graph before the daily graphs

      int keep_STUDY_j_Start = STUDY.j_Start;
      int keep_STUDY_j_End = STUDY.j_End;
      STUDY.j_Start = j;
      STUDY.j_End = j + 1;
      STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
      STUDY.j_Start = keep_STUDY_j_Start;
      STUDY.j_End = keep_STUDY_j_End;

      STUDY.graphics.strokeWeight(STUDY.T_scale * 2);
      STUDY.graphics.stroke(0);
      STUDY.graphics.noFill(); 
      STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);
    }

    if (Impact_TYPE != Impact_ACTIVE) { 

      float pal_length = 400;
      for (int q = 0; q < 11; q++) {
        float _u = 0;

        if (Impact_TYPE == Impact_PASSIVE) _u = 0.1 * q;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
        STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);         

        STUDY.graphics.strokeWeight(0);
        STUDY.graphics.rect((700 + q * (pal_length / 11.0)) * STUDY.S_View, 175 * STUDY.S_View, (pal_length / 11.0) * STUDY.S_View, 20 * STUDY.S_View); 

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          STUDY.graphics.stroke(127);
          STUDY.graphics.fill(127);
          STUDY.graphics.strokeWeight(0);
        } else {
          STUDY.graphics.stroke(255);
          STUDY.graphics.fill(255);
          STUDY.graphics.strokeWeight(2);
        }  

        STUDY.graphics.textSize(15.0 * STUDY.S_View);
        STUDY.graphics.textAlign(CENTER, CENTER);

        if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(0.2 * (q - 5) / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
      }
    }         


    if (STUDY.PrintTtitle) {

      STUDY.graphics.stroke(0); 
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, TOP); 
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) STUDY.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(("Wind direction and speed"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(("Wind direction and speed with air temperature"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
    }

    if (Display_WindRoseImage) WIN3D.update = true;
  } 





  if ((STUDY.PlotImpacts == 0) || (STUDY.PlotImpacts == 1)) {

    if (STUDY.Impacts_update) {

      SOLARCHVISION_calculate_SolarImpact_CurrentPreBaked();

      int RES1 = SolarImpact_RES1;
      int RES2 = SolarImpact_RES2;

      if (STUDY.PlotImpacts == 0) Impact_TYPE = Impact_ACTIVE; 
      if (STUDY.PlotImpacts == 1) Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float _values_R_dir;
      float _values_R_dif;

      float _values_E_dir;
      float _values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      int PAL_TYPE = 0; 
      int PAL_DIR = 1;
      float PAL_Multiplier = 1; 

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
        PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
        PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
      }        

      for (int p = 0; p < 1; p++) { 
        int l = STUDY.ImpactLayer;

        for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

          now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }


          STUDY.graphics.strokeWeight(STUDY.T_scale * 0);
          STUDY.graphics.stroke(223);
          STUDY.graphics.fill(223); 
          STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY.U_scale), (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

          STUDY.graphics.strokeWeight(STUDY.T_scale * 2);
          STUDY.graphics.stroke(255);
          STUDY.graphics.noFill(); 
          STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY.U_scale), (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

          STUDY.graphics.imageMode(CENTER); 
          STUDY.graphics.image(SolarImpact_Image[Impact_TYPE][j + 1], (j + 100 * STUDY.rect_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY.U_scale), int((180 * STUDY.rect_scale) * sx_Plot), int((180 * STUDY.rect_scale) * sx_Plot));

          STUDY.graphics.stroke(0);
          STUDY.graphics.fill(0);
          STUDY.graphics.textAlign(CENTER, CENTER); 
          STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);

          String scenario_text = "";
          //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
          //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
          //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          STUDY.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY.U_scale);
        }
        
        ////////////////////////////
        STUDY.impact_summary = true; 
        ////////////////////////////
        
        if (STUDY.impact_summary) { 
          int j = -1; // << to put the summary graph before the daily graphs

          STUDY.graphics.strokeWeight(STUDY.T_scale * 0);
          STUDY.graphics.stroke(223);
          STUDY.graphics.fill(223); 
          //STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY.U_scale), (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

          STUDY.graphics.strokeWeight(STUDY.T_scale * 2);
          STUDY.graphics.stroke(0);
          STUDY.graphics.noFill(); 
          //STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY.U_scale), (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);

          STUDY.graphics.imageMode(CENTER); 
          //STUDY.graphics.image(SolarImpact_Image[Impact_TYPE][j + 1], (j + 100 * STUDY.rect_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY.U_scale), int((180 * STUDY.rect_scale) * sx_Plot), int((180 * STUDY.rect_scale) * sx_Plot));

          STUDY.graphics.stroke(0);
          STUDY.graphics.fill(0);
          STUDY.graphics.textAlign(CENTER, CENTER); 
          STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
        }

        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY.graphics.text(scenario_text, ((STUDY.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY.U_scale);

        STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
        STUDY.graphics.textAlign(RIGHT, CENTER); 
        STUDY.graphics.stroke(0);
        STUDY.graphics.fill(0);
        STUDY.graphics.strokeWeight(0); 

        STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
        STUDY.graphics.textAlign(RIGHT, CENTER); 
        STUDY.graphics.stroke(0);
        STUDY.graphics.fill(0);
        STUDY.graphics.strokeWeight(0); 

        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY.U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY.U_scale));
        }            
        //?? French
      }

      float pal_length = 400;
      for (int q = 0; q < 11; q++) {
        float _u = 0;

        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
        STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);         

        STUDY.graphics.strokeWeight(0);
        STUDY.graphics.rect((700 + q * (pal_length / 11.0)) * STUDY.S_View, 175 * STUDY.S_View, (pal_length / 11.0) * STUDY.S_View, 20 * STUDY.S_View); 

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          STUDY.graphics.stroke(127);
          STUDY.graphics.fill(127);
          STUDY.graphics.strokeWeight(0);
        } else {
          STUDY.graphics.stroke(255);
          STUDY.graphics.fill(255);
          STUDY.graphics.strokeWeight(2);
        }  

        STUDY.graphics.textSize(15.0 * STUDY.S_View);
        STUDY.graphics.textAlign(CENTER, CENTER);
        if (Impact_TYPE == Impact_ACTIVE) STUDY.graphics.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
        if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
      }

      if (STUDY.PrintTtitle) {

        STUDY.graphics.stroke(0); 
        STUDY.graphics.fill(0);
        STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

        STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
        STUDY.graphics.textAlign(RIGHT, TOP); 
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) STUDY.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);


        String Model_Description = "";


        STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
        STUDY.graphics.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY.graphics.text((Model_Description + "Analysis of Active Potentials (kW/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY.graphics.text((Model_Description + "Analysis of Passive Potentials (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
          //?? French
        }
      }
    }

    if (Display_SolarImpactImage) WIN3D.update = true;
  }





  if ((STUDY.PlotImpacts == 2) || (STUDY.PlotImpacts == 3)) {

    if (rebuild_GlobalSolar_array != 0) {
      SOLARCHVISION_resize_GlobalSolar_array();
    }

    if (STUDY.PlotImpacts == 2) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY.PlotImpacts == 3) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY.Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY.Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY.Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY.Pallet_PASSIVE_MLT; 

    //for (int p = 0; p < 3; p++) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p++) { 
      int l = STUDY.ImpactLayer;

    //for (int p = 0; p < 1; p++) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + 1; //STUDY.ImpactLayer;    

      float[][] TOTAL_valuesSUM_RAD = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      int[][] TOTAL_valuesNUM = new int [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];

      for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
        for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
          TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
          TOTAL_valuesNUM[a][b] = 0;
        }
      }

      for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

        now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / STUDY.JoinDays);
            int j_ADD = nk % STUDY.JoinDays; 

            for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
              float Alpha = a * SOLARCHVISION_GLOBE_stp_slp;
              for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
                float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

                float _valuesSUM_RAD = 0;
                float _valuesSUM_EFF_P = 0;
                float _valuesSUM_EFF_N = 0;
                int _valuesNUM = 0; 


                for (int i = 0; i < 24; i++) {
                  if (STUDY.isInHourlyRange(i) == 1) {              
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                    if (SunR[3] > 0) {

                      now_k = k + start_k;
                      now_i = i;
                      now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }

                      Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                      Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                      Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                      Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                      if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                        _values_R_dir = FLOAT_undefined;
                        _values_R_dif = FLOAT_undefined;
                        _values_E_dir = FLOAT_undefined;
                        _values_E_dif = FLOAT_undefined;
                      } else {

                        int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                        
                        if (memberCount == 1) {
                          _values_R_dir = 0.001 * Pa;
                          _values_R_dif = 0.001 * Pb;
                          _values_E_dir = 0.001 * Pc;
                          _values_E_dif = 0.001 * Pd;

                          if (is_undefined_FLOAT(_valuesSUM_RAD)) {
                            _valuesSUM_RAD = 0;
                            _valuesSUM_EFF_P = 0;
                            _valuesSUM_EFF_N = 0;
                            _valuesNUM = 0;
                          } else {

                            if (_values_E_dir < 0) {
                              _valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                            } else {
                              _valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                            }

                            _valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 

                            _valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }


                if (_valuesNUM != 0) {
                  //float _valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * _valuesNUM);  
                  //float _valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * _valuesNUM);
                  float _valuesMUL = roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * _valuesNUM);

                  _valuesSUM_RAD *= _valuesMUL;
                  _valuesSUM_EFF_P *= _valuesMUL;
                  _valuesSUM_EFF_N *= _valuesMUL;

                  if (TOTAL_valuesNUM[a][b] == 0) {
                    TOTAL_valuesSUM_RAD[a][b] = 0;
                    TOTAL_valuesSUM_EFF_P[a][b] = 0;
                    TOTAL_valuesSUM_EFF_N[a][b] = 0;
                  }

                  TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
                  TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
                  TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
                  TOTAL_valuesNUM[a][b] += 1;
                } else {
                  _valuesSUM_RAD = FLOAT_undefined;
                  _valuesSUM_EFF_P = FLOAT_undefined;
                  _valuesSUM_EFF_N = FLOAT_undefined;
                }


                float AVERAGE, PERCENTAGE, COMPARISON;

                AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
                if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


                float _valuesSUM = FLOAT_undefined;
                if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

                //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> _valuesSUM_RAD:", _valuesSUM_RAD, "COMPARISON:", COMPARISON);  

                if (is_undefined_FLOAT(_valuesSUM) == false) {

                  float _u = 0;

                  if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;

                  //float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
                  float[] COL = PAINT.getColorStyle(PAL_TYPE, roundTo(_u, 0.1));
                  STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                  STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 


                  STUDY.graphics.strokeWeight(0);

                  float x1 = (j + STUDY.rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y1 = (                         -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float x2 = (j + STUDY.rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y2 = (                         -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

                  float x3 = (j + STUDY.rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y3 = (                         -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 
                  float x4 = (j + STUDY.rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y4 = (                         -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

                  STUDY.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                }
              }
            }

            STUDY.graphics.stroke(0);
            STUDY.graphics.fill(0);
            STUDY.graphics.textAlign(CENTER, CENTER); 
            STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);

            String scenario_text = "";
            //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY.U_scale);
          }
        }
      }



      if (STUDY.impact_summary) { 

        int j = -1; // << to put the summary graph before the daily graphs

        for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
          float Alpha = a * SOLARCHVISION_GLOBE_stp_slp;
          for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
            float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

            if (TOTAL_valuesNUM[a][b] != 0) {
              TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
            } else {
              TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
            if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD[a][b];
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

            //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> (TOTAL) _valuesSUM_RAD:", TOTAL_valuesSUM_RAD[a][b], "COMPARISON:", COMPARISON);  

            if (is_undefined_FLOAT(_valuesSUM) == false) {

              float _u = 0;

              if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
              if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;

              //float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
              float[] COL = PAINT.getColorStyle(PAL_TYPE, roundTo(_u, 0.1));
              STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
              STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);               

              STUDY.graphics.strokeWeight(0);

              float x1 = (j + STUDY.rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y1 = (                         -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float x2 = (j + STUDY.rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y2 = (                         -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

              float x3 = (j + STUDY.rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y3 = (                         -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 
              float x4 = (j + STUDY.rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y4 = (                         -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY.rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

              STUDY.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
            }
          }
        }

        STUDY.graphics.strokeWeight(STUDY.T_scale * 2);
        STUDY.graphics.stroke(0);
        STUDY.graphics.noFill(); 
        STUDY.graphics.rect((j + STUDY.rect_offset_x - 100 * STUDY.rect_scale) * sx_Plot, (-100 * STUDY.rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY.U_scale), (200 * STUDY.rect_scale) * sx_Plot, (200 * STUDY.rect_scale) * sx_Plot);


        STUDY.graphics.stroke(0);
        STUDY.graphics.fill(0);
        STUDY.graphics.textAlign(CENTER, CENTER); 
        STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);

        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY.U_scale);

        int keep_STUDY_j_Start = STUDY.j_Start;
        int keep_STUDY_j_End = STUDY.j_End;
        STUDY.j_Start = j;
        STUDY.j_End = j + 1;
        STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
        STUDY.j_Start = keep_STUDY_j_Start;
        STUDY.j_End = keep_STUDY_j_End;
      }


      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY.graphics.text(scenario_text, ((STUDY.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY.U_scale);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, CENTER); 
      STUDY.graphics.stroke(0);
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }            
      //?? French
    }

    float pal_length = 400;
    for (int q = 0; q < 11; q++) {
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
      STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY.graphics.strokeWeight(0);
      STUDY.graphics.rect((700 + q * (pal_length / 11.0)) * STUDY.S_View, 175 * STUDY.S_View, (pal_length / 11.0) * STUDY.S_View, 20 * STUDY.S_View); 

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY.graphics.stroke(127);
        STUDY.graphics.fill(127);
        STUDY.graphics.strokeWeight(0);
      } else {
        STUDY.graphics.stroke(255);
        STUDY.graphics.fill(255);
        STUDY.graphics.strokeWeight(2);
      }   

      STUDY.graphics.textSize(15.0 * STUDY.S_View);
      STUDY.graphics.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY.graphics.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
    }


    if (STUDY.PrintTtitle) {

      STUDY.graphics.stroke(0); 
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, TOP); 
      
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) STUDY.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(("Solar radiation on hemisphere (kW/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(("Solar effects on hemisphere (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
    }

    STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  } 



  if ((STUDY.PlotImpacts == 4) || (STUDY.PlotImpacts == 5)) {
    if (STUDY.PlotImpacts == 4) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY.PlotImpacts == 5) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY.Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY.Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY.Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY.Pallet_PASSIVE_MLT;

    STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

    //for (int p = 0; p < 3; p++) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p++) { 
      int l = STUDY.ImpactLayer;

      //for (int p = 0; p < 1; p++) { 
      //int l = 3 * int(STUDY.ImpactLayer / 3) + 1; //STUDY.ImpactLayer;    

      for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

        now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / STUDY.JoinDays);
            int j_ADD = nk % STUDY.JoinDays; 

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i++) {
              if (STUDY.isInHourlyRange(i) == 1) {
                if ((i > _sunrise) && (i < _sunset)) {

                  float HOUR_ANGLE = i; 
                  float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                  float Alpha = 90 - acos_ang(SunR[3]);
                  float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                  if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                    
                    if (memberCount == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      if (is_undefined_FLOAT(_valuesSUM_RAD)) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF = 0;
                        _valuesNUM = 0;
                      } else {
                        _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                        _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                        _valuesNUM = 1;
                      }
                    }
                  }

                  float _valuesSUM = FLOAT_undefined;
                  if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 

                  if (is_undefined_FLOAT(_valuesSUM) == false) {

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * _valuesSUM);

                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;

                    float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
                    STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);                     

                    STUDY.graphics.strokeWeight(0);

                    STUDY.graphics.ellipse((j + STUDY.rect_offset_x + (90 - Alpha) * STUDY.rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY.rect_scale * (sin_ang(Beta - 90))) * sx_Plot, 0.075 * sx_Plot, 0.075 * sx_Plot);

                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      STUDY.graphics.stroke(127);
                      STUDY.graphics.fill(127);
                      STUDY.graphics.strokeWeight(0);
                    } else {
                      STUDY.graphics.stroke(255);
                      STUDY.graphics.fill(255);
                      STUDY.graphics.strokeWeight(2);
                    }   

                    STUDY.graphics.textSize(STUDY.S_View * 4.0 * STUDY.U_scale);

                    STUDY.graphics.textAlign(CENTER, CENTER);
                    if (Impact_TYPE == Impact_ACTIVE) STUDY.graphics.text(nf(_valuesSUM, 1, 1), (j + STUDY.rect_offset_x + (90 - Alpha) * STUDY.rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY.rect_scale * (sin_ang(Beta - 90))) * sx_Plot);
                    if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(int(_valuesSUM), 1), (j + STUDY.rect_offset_x + (90 - Alpha) * STUDY.rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY.rect_scale * (sin_ang(Beta - 90))) * sx_Plot);
                  }
                }
              }
            }

            STUDY.graphics.stroke(0);
            STUDY.graphics.fill(0);
            STUDY.graphics.textAlign(CENTER, CENTER); 
            STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);

            String scenario_text = "";
            //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95  * sx_Plot / STUDY.U_scale);
          }
        }
      }

      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY.graphics.text(scenario_text, ((STUDY.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY.U_scale);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, CENTER); 
      STUDY.graphics.stroke(0);
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }            
      //?? French
    }

    float pal_length = 400;
    for (int q = 0; q < 11; q++) {
      
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
      STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY.graphics.strokeWeight(0);
      STUDY.graphics.rect((700 + q * (pal_length / 11.0)) * STUDY.S_View, 175 * STUDY.S_View, (pal_length / 11.0) * STUDY.S_View, 20 * STUDY.S_View); 

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY.graphics.stroke(127);
        STUDY.graphics.fill(127);
        STUDY.graphics.strokeWeight(0);
      } else {
        STUDY.graphics.stroke(255);
        STUDY.graphics.fill(255);
        STUDY.graphics.strokeWeight(2);
      }   

      STUDY.graphics.textSize(15.0 * STUDY.S_View);
      STUDY.graphics.textAlign(CENTER, CENTER);

      if (Impact_TYPE == Impact_ACTIVE) STUDY.graphics.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 + 175 - 0.05 * 20) * STUDY.S_View);
    } 


    if (STUDY.PrintTtitle) {

      STUDY.graphics.stroke(0); 
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, TOP); 

      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) STUDY.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);


      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(("Direct solar radiation (kWh/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(("Direct solar effects (kWh°C/m²)"), 0, 1.4 * sx_Plot / STUDY.U_scale);
        //?? French
      }
    }

  } 



  if ((STUDY.PlotImpacts == 6) || (STUDY.PlotImpacts == 7)) {
    
    if (STUDY.PlotImpacts == 6) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY.PlotImpacts == 7) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY.Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY.Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY.Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY.Pallet_PASSIVE_MLT;

    STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);


    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

      now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

      if (now_j >= 365) {
        now_j = now_j % 365;
      }
      if (now_j < 0) {
        now_j = (now_j + 365) % 365;
      }

      float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

      float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
      float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

      int[] Normals_COL_N;
      Normals_COL_N = new int [9];
      Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

      for (int i = 0; i < 24; i++) {
        //for (int i = 10; i <= 14; i += 2) {
        //for (int i = 12; i <= 12; i += 2) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

        float Alpha = 90 - acos_ang(SunR[3]);
        float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

        now_i = i;
        now_j = int(j * STUDY.PerDays + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }


        int RES1 = SKY2D_X_View;
        int RES2 = SKY2D_Y_View;
        
        
        { // Direct
        
          STUDY.graphics.endDraw(); 
          ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
          PImage Image_RGBA = SKY2D_graphics.get();
          STUDY.graphics.beginDraw();

          
          Image_RGBA.save(ViewsFromSkyFolder + "/" + "Direct" + nf(j,2) + nf(i,2) + ".png");


          STUDY.graphics.imageMode(CENTER); 
          STUDY.graphics.image(Image_RGBA, (j + STUDY.rect_offset_x + (90 - Alpha) * STUDY.rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY.rect_scale * (sin_ang(Beta - 90))) * sx_Plot, RES1, RES2);
          STUDY.graphics.imageMode(CORNER);
          /*
          if (Materials_DirectArea_Flags[now_i][now_j] == -1) {

            Materials_DirectArea_Flags[now_i][now_j] = 1; 

            for (int mt = 0; mt < Materials_Number; mt++) {                 
              Materials_DirectArea_Data[mt][now_i][now_j] = 0;
            }   

            if ((i > _sunrise) && (i < _sunset)) {

              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;

                color COL = Image_RGBA.get(Image_X, Image_Y);

                int COL_A = COL >> 24 & 0xFF;

                if (COL_A != 0) {
                  int COL_R = COL >> 16 & 0xFF; 
                  int COL_G = COL >> 8 & 0xFF; 
                  int COL_B = COL & 0xFF;

                  for (int mt = 0; mt < Materials_Number; mt++) {  

                    if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                      Materials_DirectArea_Data[mt][now_i][now_j] += 1;
                    }
                  }
                }
              }  

              for (int mt = 0; mt < Materials_Number; mt++) {                 
                Materials_DirectArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2) ; //???

                if (Materials_Selection == mt) println("Direct:", mt, now_i, now_j, Materials_DirectArea_Data[mt][now_i][now_j]);
              }

              
            }
          }
          */
        }

         /*
         { // Diffuse
            STUDY.graphics.endDraw(); 
            ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
            PImage Image_RGBA = SKY2D_graphics.get();
            STUDY.graphics.beginDraw();
           
           if (Materials_DiffuseArea_Flags[now_i][now_j] == -1) {
             
             Materials_DiffuseArea_Flags[now_i][now_j] = 1; 
             
             for (int mt = 0; mt < Materials_Number; mt++) {                 
               Materials_DiffuseArea_Data[mt][now_i][now_j] = 0;
             }                 
             
             int num_diffuse_views = 0;
             
             for (int vNo = 0; vNo < skyVertices.length; vNo++) {
               
               float skyAngle_Alpha = asin_ang(skyVertices[vNo][2]);
               float skyAngle_Beta = atan2_ang(skyVertices[vNo][1], skyVertices[vNo][0]) + 90;
               
               if (skyAngle_Alpha >= 0) {
                 
                 num_diffuse_views += 1;
                 
                 PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-skyAngle_Alpha,0,skyAngle_Beta);
                 
                 //STUDY.graphics.imageMode(CENTER); 
                 //STUDY.graphics.image(Image_RGBA, (j + STUDY.rect_offset_x + (90 - skyAngle_Alpha) * STUDY.rect_scale * (cos_ang(skyAngle_Beta - 90))) * sx_Plot, -((90 - skyAngle_Alpha) * STUDY.rect_scale * (sin_ang(skyAngle_Beta - 90))) * sx_Plot, RES1, RES2);
                 //STUDY.graphics.imageMode(CORNER);
                 
                 for (int np = 0; np < (RES1 * RES2); np++) {
                   int Image_X = np % RES1;
                   int Image_Y = np / RES1;
                   
                   color COL = Image_RGBA.get(Image_X, Image_Y);
                   
                   int COL_A = COL >> 24 & 0xFF;
                   
                   if (COL_A != 0) {
                     int COL_R = COL >> 16 & 0xFF; 
                     int COL_G = COL >> 8 & 0xFF; 
                     int COL_B = COL & 0xFF;
                     
                     for (int mt = 0; mt < Materials_Number; mt++) {  
                       
                       if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                         Materials_DiffuseArea_Data[mt][now_i][now_j] += 1;
                       }
                     }
                   }
                 }  
                 
               }
             }
             for (int mt = 0; mt < Materials_Number; mt++) {                 
               Materials_DiffuseArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2); //???
               Materials_DiffuseArea_Data[mt][now_i][now_j] *= 2.0 / float(num_diffuse_views); // note: multiply by 2 to have a area equal to roof!
               
               if (Materials_Selection == mt) println("Diffuse:", mt, now_i, now_j, Materials_DiffuseArea_Data[mt][now_i][now_j]); 
             }
             
             //---------------------------------------------
             // applying calculated diffuse model at this time for the rest of year.
             for (int mt = 0; mt < Materials_Number; mt++) {
               for (int loop_i = 0; loop_i < 24; loop_i++) {
                 for (int loop_j = 0; loop_j < 365; loop_j++) {
                   Materials_DiffuseArea_Data[mt][loop_i][loop_j] = Materials_DiffuseArea_Data[mt][now_i][now_j];
                   Materials_DiffuseArea_Flags[loop_i][loop_j] = 1;
                 }
               }  
             }
             //---------------------------------------------                          
           }
         }
         */
         

      }
      
    }
    
    if (STUDY.PrintTtitle) {

      STUDY.graphics.stroke(0); 
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(LEFT, TOP); 

      STUDY.graphics.text(("Solar perspectives"), 0, 1.4 * sx_Plot / STUDY.U_scale);
    }
  } 


  if ((STUDY.PlotImpacts == 8) || (STUDY.PlotImpacts == 9)) {

    //for (int p = 0; p < 3; p++) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY.ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p++) { 
      int l = STUDY.ImpactLayer;

      //for (int p = 0; p < 1; p++) { 
      //int l = 3 * int(STUDY.ImpactLayer / 3) + 1; //STUDY.ImpactLayer;    

      int target_window = TypeWindow.STUDY;
      SOLARCHVISION_draw_SunPathCycles(x_Plot, y_Plot - (1 * p * sx_Plot / STUDY.U_scale), z_Plot, sx_Plot, sy_Plot, sz_Plot, l, target_window);

      STUDY.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY.graphics.text(scenario_text, ((STUDY.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY.U_scale);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, CENTER); 
      STUDY.graphics.stroke(0);
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY.U_scale));
      }            
      //?? French
    }    


    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY.Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY.Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY.Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY.Pallet_PASSIVE_MLT;

    float pal_length = 400;

    float pal_offsetY = 175;    
    if (STUDY.j_End == 2) {
      pal_offsetY = 325;
    }

    for (int q = 0; q < 11; q++) {
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);
      STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY.graphics.strokeWeight(0);
      STUDY.graphics.rect((700 + q * (pal_length / 11.0)) * STUDY.S_View, -pal_offsetY * STUDY.S_View, (pal_length / 11.0) * STUDY.S_View, 20 * STUDY.S_View);

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY.graphics.stroke(127);
        STUDY.graphics.fill(127);
        STUDY.graphics.strokeWeight(0);
      } else {
        STUDY.graphics.stroke(255);
        STUDY.graphics.fill(255);
        STUDY.graphics.strokeWeight(2);
      }   

      STUDY.graphics.textSize(15.0 * STUDY.S_View);
      STUDY.graphics.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY.graphics.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY.S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY.graphics.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY.S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY.S_View);
    } 


    if (STUDY.PrintTtitle) {

      STUDY.graphics.stroke(0); 
      STUDY.graphics.fill(0);
      STUDY.graphics.strokeWeight(STUDY.T_scale * 0);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(RIGHT, TOP); 

      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) STUDY.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) STUDY.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.4 * sx_Plot / STUDY.U_scale);

      STUDY.graphics.textSize(sx_Plot * 0.250 / STUDY.U_scale);
      STUDY.graphics.textAlign(CENTER, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY.graphics.text(("Direct solar radiation (kWh/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY.S_View + (pal_length / 11.0) * STUDY.S_View, -pal_offsetY * STUDY.S_View + 20 * STUDY.S_View);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY.graphics.text(("Direct solar effects (kWh°C/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY.S_View + (pal_length / 11.0) * STUDY.S_View, -pal_offsetY * STUDY.S_View + 20 * STUDY.S_View);
        //?? French
      }
    }
  } 





  if ((STUDY.PlotImpacts == 8) || (STUDY.PlotImpacts == 9)) {
  } else {
    STUDY.drawDailyGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  }

  keep_STUDY_PerDays = STUDY.PerDays;
  STUDY.JoinDays = keep_STUDY_JoinDays;


  

  STUDY.graphics.popMatrix();
} 



void SOLARCHVISION_draw_SunPathCycles (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int l, int target_window) {

  // target_window: 1:STUDY, 2:WORLD, 3:WIN3D 4:OBJ-export

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;



  int TES_hour = 1; //4; // 1 = every 1 hour, 4 = every 15 minutes

  if (STUDY.PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE;
  else Impact_TYPE = Impact_PASSIVE;

  float Pa1 = FLOAT_undefined;
  float Pb1 = FLOAT_undefined;
  float Pc1 = FLOAT_undefined;
  float Pd1 = FLOAT_undefined;

  float Pa2 = FLOAT_undefined;
  float Pb2 = FLOAT_undefined;
  float Pc2 = FLOAT_undefined;
  float Pd2 = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  int now_k = 0;
  int now_i1 = 0;
  int now_i2 = 0;
  int now_j = 0;

  int PAL_TYPE = 0; 
  int PAL_DIR = 1;

  float PAL_Multiplier = 1; 
  if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY.Pallet_ACTIVE_MLT;
  if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY.Pallet_PASSIVE_MLT;

  if ((target_window == TypeWindow.WIN3D) || (target_window == TypeWindow.OBJ)) {

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath_Pallet_ACTIVE_CLR; 
      PAL_DIR = SunPath_Pallet_ACTIVE_DIR;
      PAL_Multiplier = SunPath_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath_Pallet_PASSIVE_CLR; 
      PAL_DIR = SunPath_Pallet_PASSIVE_DIR;
      PAL_Multiplier = SunPath_Pallet_PASSIVE_MLT;
    }
  } else {

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY.Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY.Pallet_ACTIVE_DIR;
      PAL_Multiplier = STUDY.Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY.Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY.Pallet_PASSIVE_DIR;
      PAL_Multiplier = STUDY.Pallet_PASSIVE_MLT;
    }
  }  




  String the_filename = "";
  String TEXTURE_path = "";

  if (target_window == TypeWindow.OBJ) {

    num_vertices_added = 0;

    if (Export_MaterialLibrary) {

      the_filename = "sunPatternPallet.bmp";

      TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;

      println("Saving texture:", TEXTURE_path);

      int RES1 = Export_PalletResolution; 
      int RES2 = Export_PalletResolution / 16;      

      PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


      Pallet_Texture.loadPixels();

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;

        float _val = (Image_X / (0.5 * RES1)) - 1; 

        float _u = 0.5 + _val;

        if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  

        Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
      }

      Pallet_Texture.updatePixels();   

      Pallet_Texture.save(TEXTURE_path);      


      mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
      mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map
    }
  }  



  num_vertices_added = 0;

  int end_turn = 1;
  if (target_window == TypeWindow.OBJ) end_turn = 3;
  for (int _turn = 1; _turn <= end_turn; _turn++) {


    if (target_window == TypeWindow.OBJ) {

      if (_turn == 3) {

        obj_lastGroupNumber += 1;
        objOutput.println("g sunPattern");

        if (Export_MaterialLibrary) {      
          objOutput.println("usemtl " +  the_filename.replace('.', '_'));
        }
      }
    }    



    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

      float[][][] SunPathMesh = new float [24 * TES_hour][1 + int(STUDY.PerDays / STUDY.JoinDays)][3];        

      for (int more_J = 0; more_J < STUDY.PerDays; more_J += STUDY.JoinDays) {

        now_j = (more_J + j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        {
          int keep_filter_type = STUDY.filter;
          STUDY.filter = FILTER_Hourly;

          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, more_J + j, DATE_ANGLE);

          STUDY.filter = keep_filter_type;
        }

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / STUDY.JoinDays);
            int j_ADD = nk % STUDY.JoinDays; 

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF = 0;
            int _valuesNUM = 0; 

            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

              float HOUR_ANGLE = i; 
              float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

              float Alpha = 90 - acos_ang(SunR[3]);
              float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

              //-------------- to extend graph to the horizon ---------------
              if (Alpha < 0) {              

                if (SunR[1] > 0) { 
                  float[] SunR_rise = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, _sunrise);

                  Alpha = 0;
                  Beta = 180 - atan2_ang(SunR_rise[1], SunR_rise[2]);
                } else {
                  float[] SunR_set = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, _sunset);

                  Alpha = 0;
                  Beta = 180 - atan2_ang(SunR_set[1], SunR_set[2]);
                }
              }
              //-----------------------------------------------------------

              now_k = k + start_k;

              now_i1 = floor(i);
              now_i2 = (1 + now_i1) % 24;
              float i_ratio = i - now_i1; 

              now_j = int(more_J + j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }

              Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
              Pb1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difhorrad.id);
              Pc1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
              Pd1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difeffect.id);

              Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);
              Pb2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difhorrad.id);
              Pc2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);
              Pd2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difeffect.id);
              
              if ((is_undefined_FLOAT(Pa1)) || (is_undefined_FLOAT(Pb1)) || (is_undefined_FLOAT(Pc1)) || (is_undefined_FLOAT(Pd1))
                || (is_undefined_FLOAT(Pa2)) || (is_undefined_FLOAT(Pb2)) || (is_undefined_FLOAT(Pc2)) || (is_undefined_FLOAT(Pd2))) {
                _values_R_dir = FLOAT_undefined;
                _values_R_dif = FLOAT_undefined;
                _values_E_dir = FLOAT_undefined;
                _values_E_dif = FLOAT_undefined;
              } else {

                int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i1, now_j, now_k);
                
                if (memberCount == 1) {
                  _values_R_dir = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                  _values_R_dif = 0.001 * (Pb1 * (1 - i_ratio) + Pb2 * i_ratio);
                  _values_E_dir = 0.001 * (Pc1 * (1 - i_ratio) + Pc2 * i_ratio);
                  _values_E_dif = 0.001 * (Pd1 * (1 - i_ratio) + Pd2 * i_ratio);

                  if (is_undefined_FLOAT(_valuesSUM_RAD)) {
                    _valuesSUM_RAD = 0;
                    _valuesSUM_EFF = 0;
                    _valuesNUM = 0;
                  } else {
                    _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                    _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                    _valuesNUM = 1;
                  }
                }
              }

              float _valuesSUM = FLOAT_undefined;
              if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
              if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 

              int row_J = more_J / STUDY.JoinDays;

              SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
              SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
              SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;
            }
          } else {
            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

              float _valuesSUM = FLOAT_undefined; 

              float HOUR_ANGLE = i; 
              float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

              float Alpha = 90 - acos_ang(SunR[3]);
              float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

              int row_J = more_J / STUDY.JoinDays;

              SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
              SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
              SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;
            }
          }
        }
      }



      for (int more_J = 0; more_J < STUDY.PerDays - STUDY.JoinDays; more_J += STUDY.JoinDays) { //count one less!

        now_j = (more_J + j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {  
          if (STUDY.isInHourlyRange(i) == 1) {
            if ((i > _sunrise - 1.0 / float(TES_hour)) && (i < _sunset + 1.0 / float(TES_hour))) {              

              if (target_window == TypeWindow.OBJ) {
              } else if (target_window == TypeWindow.WIN3D) {
                WIN3D.graphics.beginShape();
                WIN3D.graphics.noStroke();
              } else if (target_window == TypeWindow.WORLD) {
                WORLD.graphics.beginShape();
                WORLD.graphics.noStroke();
              } else if (target_window == TypeWindow.STUDY) {
                STUDY.graphics.beginShape();
                STUDY.graphics.noStroke();
              }  

              for (int s = 0; s < 4; s++) {

                int a = int(i * TES_hour);
                int b = more_J / STUDY.JoinDays;

                if ((s == 1) || (s == 2)) {
                  a += 1;
                }

                if ((s == 2) || (s == 3)) {
                  b += 1;
                }

                if (a > (24 * TES_hour - 1)) a = a % (24 * TES_hour);

                float Alpha = SunPathMesh[a][b][0];
                float Beta = SunPathMesh[a][b][1];
                float _valuesSUM = SunPathMesh[a][b][2];

                if (Alpha >= 0) {

                  if (is_undefined_FLOAT(_valuesSUM) == false) {

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * _valuesSUM);

                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;

                    float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);

                    float r = sx_Plot;

                    if (target_window == TypeWindow.OBJ) {

                      float x = cos_ang(Alpha) * (cos_ang(Beta - 90)) * WIN3D.scale * r + x_Plot;
                      float y = cos_ang(Alpha) * (sin_ang(Beta - 90)) * WIN3D.scale * r + y_Plot;
                      float z = sin_ang(Alpha) * WIN3D.scale * sz_Plot + z_Plot;

                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(x, y, z);
                      }

                      if (_turn == 2) { 
                        float u1 = 0.5 * (_u + 0.5);

                        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                          if (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                        }

                        if (u1 > 0.999) u1 = 0.999;
                        if (u1 < 0.001) u1 = 0.001;

                        SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
                      }

                      if (_turn == 3) {
                        num_vertices_added += 1;
                      }
                    } else if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);

                      float x = cos_ang(Alpha) * (cos_ang(Beta - 90)) * WIN3D.scale * r + x_Plot;
                      float y = cos_ang(Alpha) * (sin_ang(Beta - 90)) * WIN3D.scale * r + y_Plot;
                      float z = sin_ang(Alpha) * WIN3D.scale * sz_Plot + z_Plot;

                      WIN3D.graphics.vertex(x, -y, z);
                    } else if (target_window == TypeWindow.WORLD) {
                      // ??????????????????????????
                    } else if (target_window == TypeWindow.STUDY) {

                      STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                      float x = (90 - Alpha) * (cos_ang(Beta - 90)) * STUDY.rect_scale * r + x_Plot * STUDY.rect_scale;
                      float y = (90 - Alpha) * (sin_ang(Beta - 90)) * STUDY.rect_scale * r + y_Plot * STUDY.rect_scale;

                      float ox = (j + STUDY.rect_offset_x) * sx_Plot;

                      STUDY.graphics.vertex(ox + x, -y);
                    }
                  }
                }
              }

              if (target_window == TypeWindow.OBJ) {

                if (_turn == 3) {

                  String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                  String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                  String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                  String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                  String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                  String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                  String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                  String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                }
              } else if (target_window == TypeWindow.WIN3D) {
                WIN3D.graphics.endShape(CLOSE);
              } else if (target_window == TypeWindow.WORLD) {
                WORLD.graphics.endShape(CLOSE);
              } else if (target_window == TypeWindow.STUDY) {
                STUDY.graphics.endShape(CLOSE);
              }
            }
          }
        }
      }
    }


    if (target_window == TypeWindow.OBJ) {
      obj_lastVertexNumber += num_vertices_added;
      obj_lastVtextureNumber += num_vertices_added;
    }
  }  





  if (target_window == TypeWindow.WIN3D) {
    WIN3D.graphics.strokeWeight(1);
    WIN3D.graphics.stroke(127);
  } else if (target_window == TypeWindow.WORLD) {
    WORLD.graphics.strokeWeight(1);
    WORLD.graphics.stroke(127);
  } else if (target_window == TypeWindow.STUDY) {
    STUDY.graphics.strokeWeight(1);
    STUDY.graphics.stroke(127);
  }

  for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {    

    int max_j_to_draw_grid = STUDY.j_End;
    if ((target_window == TypeWindow.WIN3D) || (target_window == TypeWindow.OBJ)) {
      max_j_to_draw_grid = 1; // draw it just once!
    }
    if (j < max_j_to_draw_grid) {


      float s_SunPath = sx_Plot;

      for (int myDATE = 90; myDATE <= 270; myDATE += 30) {

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), myDATE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), myDATE);        

        float myHOUR_step = 1.0 / float(TES_hour);

        for (float myHOUR = 0; myHOUR < 24; myHOUR += myHOUR_step) {



          float HourA = myHOUR;
          float HourB = myHOUR + myHOUR_step;

          float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, HourA);
          float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, HourB);

          if ((SunA[3] < 0) && (SunB[3] > 0)) {
            SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, _sunrise);
            SunA[3] = 0;
          }
          if ((SunA[3] > 0) && (SunB[3] < 0)) {
            SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, _sunset);
            SunB[3] = 0;
          }



          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == TypeWindow.WIN3D) {

              float x1 = SunA[1] * WIN3D.scale * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D.scale * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D.scale * s_SunPath + z_Plot;

              float x2 = SunB[1] * WIN3D.scale * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D.scale * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D.scale * s_SunPath + z_Plot;

              WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
            } else if (target_window == TypeWindow.WORLD) {
              // ??????????????????????????
            } else if (target_window == TypeWindow.STUDY) {

              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          

              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          

              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;

              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;

              float ox = (j + STUDY.rect_offset_x) * sx_Plot;

              STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
            }
          }
        }
      }

      for (float myHOUR = 0; myHOUR < 24; myHOUR++) {

        int myDATE_step = STUDY.JoinDays;

        int myDATE_start = 0;
        int myDATE_end = 360; 

        if (target_window != 3) {
          if (STUDY.j_End == 2) {
            if (j == 0) {
              myDATE_start = 90;
              myDATE_end = 270;
            }
            if (j == 1) {
              myDATE_start = 270;
              myDATE_end = 450;
            }
          }
        }

        for (int myDATE = myDATE_start; myDATE <= myDATE_end; myDATE += myDATE_step) {
          float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, myHOUR);
          float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), (myDATE + myDATE_step), myHOUR);
          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == TypeWindow.WIN3D) {        

              float x1 = SunA[1] * WIN3D.scale * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D.scale * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D.scale * s_SunPath + z_Plot;

              float x2 = SunB[1] * WIN3D.scale * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D.scale * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D.scale * s_SunPath + z_Plot;

              float ox = (j + STUDY.rect_offset_x) * sx_Plot;

              WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
            } else if (target_window == TypeWindow.WORLD) {
              // ??????????????????????????
            } else if (target_window == TypeWindow.STUDY) {

              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          

              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          

              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;

              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;

              float ox = (j + STUDY.rect_offset_x) * sx_Plot;

              STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
            }
          }
        }
      }



      if (target_window == TypeWindow.WIN3D) {  
        WIN3D.graphics.stroke(0);
        WIN3D.graphics.fill(0);
        WIN3D.graphics.textAlign(CENTER, CENTER);
      } else if (target_window == TypeWindow.WORLD) {  
        WORLD.graphics.stroke(0);
        WORLD.graphics.fill(0);
        WORLD.graphics.textAlign(CENTER, CENTER);
      } else if (target_window == TypeWindow.STUDY) {  
        STUDY.graphics.stroke(0);
        STUDY.graphics.fill(0);
        STUDY.graphics.textAlign(CENTER, CENTER);
      }      

      for (int i = 0; i < 360; i++) {
        if (target_window == TypeWindow.WIN3D) {  

          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = s_SunPath * cos((i + 5) * PI / 180) * WIN3D.scale + x_Plot;
          float y2 = s_SunPath * sin((i + 5) * PI / 180) * WIN3D.scale + y_Plot;
          float z2 = 0 + z_Plot;

          WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
        } else if (target_window == TypeWindow.WORLD) {
          // ??????????????????????????
        } else if (target_window == TypeWindow.STUDY) {
          // no nead for a circle here in this case!
        }
      }

      for (int i = 0; i < 360; i += 5) {
        if (target_window == TypeWindow.WIN3D) {  

          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = 1.05 * s_SunPath * cos((i) * PI / 180) * WIN3D.scale + x_Plot;
          float y2 = 1.05 * s_SunPath * sin((i) * PI / 180) * WIN3D.scale + y_Plot;
          float z2 = 0 + z_Plot;

          WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
        } else if (target_window == TypeWindow.WORLD) {
          // ??????????????????????????
        } else if (target_window == TypeWindow.STUDY) {

          float x1 = 90 * s_SunPath * cos(i * PI / 180) * STUDY.rect_scale + x_Plot * STUDY.rect_scale;
          float y1 = 90 * s_SunPath * sin(i * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;

          float x2 = 90 * 1.05 * s_SunPath * cos((i) * PI / 180) * STUDY.rect_scale + x_Plot * STUDY.rect_scale;
          float y2 = 90 * 1.05 * s_SunPath * sin((i) * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;

          float ox = (j + STUDY.rect_offset_x) * sx_Plot;

          STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
        }
      }

/*
      for (int i = 0; i < 360; i += 15) {

        String txt = nf((90 - i + 360) % 360, 0);
        if (i == 0) {
          txt = "E";
        } else if (i == 90) {
          txt = "N";
        } else if (i == 180) {
          txt = "W";
        } else if (i == 270) {
          txt = "S";
        }

        float txtSize = 0.1;
        if (txt.length() > 1) txtSize *= 0.75;

        if (target_window == TypeWindow.WIN3D) {

          float x = 1.10 * s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
          float y = 1.10 * s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
          float z = 0 + z_Plot;

          WIN3D.graphics.textSize(txtSize * WIN3D.scale * s_SunPath);
          WIN3D.graphics.text(txt, x, -y, z);
        } else if (target_window == TypeWindow.WORLD) {
          // ??????????????????????????
        } else if (target_window == TypeWindow.STUDY) {
          float x = 90 * 1.10 * s_SunPath * cos(i * PI / 180) * STUDY.rect_scale+ x_Plot * STUDY.rect_scale;
          float y = 90 * 1.10 * s_SunPath * sin(i * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;

          float ox = (j + STUDY.rect_offset_x) * sx_Plot;

          STUDY.graphics.textSize(txtSize * 0.4 * s_SunPath);
          STUDY.graphics.text(txt, ox + x, -y);
        }
      }
*/
    }
  }
}








void SOLARCHVISION_draw_SunPattern3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 

  if (Display_SUN_Pattern) {

    float keep_STUDY_PerDays = STUDY.PerDays;
    int keep_STUDY_JoinDays = STUDY.JoinDays;
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      STUDY.PerDays = 1;
      STUDY.JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;

    SOLARCHVISION_draw_SunPathCycles(x_SunPath, x_SunPath, x_SunPath, s_SunPath, s_SunPath, s_SunPath, STUDY.ImpactLayer, 3);

    STUDY.PerDays = keep_STUDY_PerDays;
    STUDY.JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }
}

void SOLARCHVISION_draw_SunPath3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 

  if (Display_SUN_Path) {

    float keep_STUDY_PerDays = STUDY.PerDays;
    int keep_STUDY_JoinDays = STUDY.JoinDays;
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      STUDY.PerDays = 1;
      STUDY.JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;




    int TES_hour = 4; // 1 = every 1 hour, 4 = every 15 minutes

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath_Pallet_ACTIVE_CLR; 
      PAL_DIR = SunPath_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath_Pallet_PASSIVE_CLR; 
      PAL_DIR = SunPath_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * SunPath_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * SunPath_Pallet_PASSIVE_MLT;



    WIN3D.graphics.pushMatrix();
    WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);

    WIN3D.graphics.strokeWeight(0); 
    WIN3D.graphics.stroke(0, 0, 0);
    WIN3D.graphics.fill(0, 0, 0);

    WIN3D.graphics.line(-1 * s_SunPath, 0, 0, 1 * s_SunPath, 0, 0); 
    WIN3D.graphics.line(0, -1 * s_SunPath, 0, 0, 1 * s_SunPath, 0);

    WIN3D.graphics.stroke(255, 255, 0);



    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;

    for (int p = 0; p < 1; p++) { 

      int l = STUDY.ImpactLayer;

      int DATE_step = 1;

      int J_START = STUDY.j_Start;
      int J_END = STUDY.j_End;

      if (IMPACTS_DisplayDay > 0) {
        J_START = IMPACTS_DisplayDay - 1;
        J_END = IMPACTS_DisplayDay;
      }

      for (int j = J_START; j < J_END; j += DATE_step) {

        int now_k = 0;
        int now_i1 = 0;
        int now_i2 = 0;
        int now_j = 0;

        now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        //println(j, now_j, DATE_ANGLE);

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / STUDY.JoinDays);
            int j_ADD = nk % STUDY.JoinDays; 

            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
              if (STUDY.isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                now_k = k + start_k;

                now_i1 = floor(i);
                now_i2 = (1 + now_i1) % 24;
                float i_ratio = i - now_i1;

                now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                float Pa1 = FLOAT_undefined;
                float Pa2 = FLOAT_undefined;

                if (Impact_TYPE == Impact_ACTIVE) {
                  
                  Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
                  Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);                  

                } 

                if (Impact_TYPE == Impact_PASSIVE) {
                  
                  Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
                  Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);  
                  
                }                  

                if ((is_undefined_FLOAT(Pa1)) && (is_undefined_FLOAT(Pa2))) {
                } else {

                  float sun_V = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);

                  float _u = 0;

                  if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * sun_V);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * sun_V);

                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;

                  float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);    

                  WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                  WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                  WIN3D.graphics.strokeWeight(4);

                  float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE - 0.5 * (1.0 / float(TES_hour)));
                  float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE + 0.5 * (1.0 / float(TES_hour)));

                  float x1 = SunA[1] * WIN3D.scale * s_SunPath;
                  float y1 = SunA[2] * WIN3D.scale * s_SunPath;
                  float z1 = SunA[3] * WIN3D.scale * s_SunPath;

                  float x2 = SunB[1] * WIN3D.scale * s_SunPath;
                  float y2 = SunB[2] * WIN3D.scale * s_SunPath;
                  float z2 = SunB[3] * WIN3D.scale * s_SunPath;

                  WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
                }
              }
            }
          }
        }
      }
    }  

    WIN3D.graphics.popMatrix();



    STUDY.PerDays = keep_STUDY_PerDays;
    STUDY.JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }
} 


boolean Display_SolarRotation = false;

void SOLARCHVISION_draw_SolarRotation (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 

  if (Display_SolarRotation) {

    WIN3D.graphics.pushMatrix();
    WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);

    WIN3D.graphics.strokeWeight(1);
    WIN3D.graphics.stroke(0);

    for (int j = 90; j <= 270; j += 30) {
      float HOUR_step = 1;
      for (float HOUR = 0; HOUR <= 24; HOUR += HOUR_step) {
        float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, (HOUR + HOUR_step));
        WIN3D.graphics.line(s_SunPath * SunA[1] * WIN3D.scale, -s_SunPath * SunA[2] * WIN3D.scale, s_SunPath * SunA[3] * WIN3D.scale, s_SunPath * SunB[1] * WIN3D.scale, -s_SunPath * SunB[2] * WIN3D.scale, s_SunPath * SunB[3] * WIN3D.scale);
      }
    }

    for (int HOUR = 0; HOUR <= 24; HOUR++) {
      float DATE_step = 1;
      for (int j = 0; j <= 360; j += DATE_step) {
        float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), (j + DATE_step), HOUR);
        WIN3D.graphics.line(s_SunPath * SunA[1] * WIN3D.scale, -s_SunPath * SunA[2] * WIN3D.scale, s_SunPath * SunA[3] * WIN3D.scale, s_SunPath * SunB[1] * WIN3D.scale, -s_SunPath * SunB[2] * WIN3D.scale, s_SunPath * SunB[3] * WIN3D.scale);
      }
    }

    WIN3D.graphics.popMatrix();
  }
} 









int FrameVariation = 0;

void SOLARCHVISION_update_frame_layout () {

  if (FrameVariation == 0) {

    STUDY.include = true;
    WIN3D.include = true;
    WORLD.include = true;

    WIN3D.cX = 0;
    WIN3D.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WIN3D.dX = int(1.5 * SOLARCHVISION_H_Pixel);
    WIN3D.dY = SOLARCHVISION_H_Pixel;
    WIN3D.R_View = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

    WORLD.cX = int(1.5 * SOLARCHVISION_H_Pixel);
    WORLD.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WORLD.dX = int(2.0 * SOLARCHVISION_H_Pixel);
    WORLD.dY = SOLARCHVISION_H_Pixel;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_H_Pixel;
    STUDY.dX = 2 * SOLARCHVISION_W_Pixel;
    STUDY.dY = 1 * SOLARCHVISION_H_Pixel;
    STUDY.R_View = float(STUDY.dY) / float(STUDY.dX);   
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 1) {

    STUDY.include = false;
    WIN3D.include = true;
    WORLD.include = false;

    WIN3D.cX = 0;
    WIN3D.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WIN3D.dX = 2 * SOLARCHVISION_W_Pixel;
    WIN3D.dY = 2 * SOLARCHVISION_H_Pixel;
    WIN3D.R_View = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);
  } else if (FrameVariation == 2) {

    STUDY.include = true;
    WIN3D.include = false;
    WORLD.include = false;

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    STUDY.dX = 2 * SOLARCHVISION_W_Pixel;
    STUDY.dY = 2 * SOLARCHVISION_H_Pixel;
    STUDY.R_View = float(STUDY.dY) / float(STUDY.dX);   
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 3) {

    STUDY.include = false;
    WIN3D.include = false;
    WORLD.include = true;

    WORLD.cX = 0;
    WORLD.cY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WORLD.dX = 2 * SOLARCHVISION_W_Pixel;
    WORLD.dY = 2 * SOLARCHVISION_H_Pixel;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);
  } 

  WORLD.update = true;
  WIN3D.update = true; 
  STUDY.update = true;
}




void keyPressed (KeyEvent e) {

  //println("key: " + key);
  //println("keyCode: " + keyCode);  
  
  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;

      if ((UI_BAR_a_selected_parent != -1) || (UI_BAR_a_selected_child != 0)) {

        UI_BAR_a_selected_parent = -1;
        UI_BAR_a_selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);
      }

      addNewSelectionToPreviousSelection = 0;


      if (typeUserCommand == 0) {

        UI_BAR_c_update = false;
        
        STUDY.keyPressed(e);
  
        WIN3D.keyPressed(e);
      }
      else {
        
        UI_BAR_c_update = true;
        
        COMIN_keyPressed(e);
      }
      

      if (e.isAltDown()) {

        if (key == CODED) { 
          switch(keyCode) {
          }
        } else {
          switch(key) {
          case 'l' : 
            FrameVariation = (FrameVariation + 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT.update = true; 
            break;
          case 'L' : 
            FrameVariation = (FrameVariation + 4 - 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT.update = true; 
            break;
          }
        }
      } else if (e.isControlDown()) {

        addNewSelectionToPreviousSelection = 1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : //F1
            ROLLOUT.parent = 0; 
            ROLLOUT.update = true; 
            break;
          case 113 : //F2
            ROLLOUT.parent = 1; 
            ROLLOUT.update = true; 
            break;
          case 114 : //F3
            ROLLOUT.parent = 2; 
            ROLLOUT.update = true; 
            break;
          case 115 : //F4
            ROLLOUT.parent = 3; 
            ROLLOUT.update = true; 
            break;
          case 116 : //F5
            ROLLOUT.parent = 4; 
            ROLLOUT.update = true; 
            break;
          case 117 : //F6
            ROLLOUT.parent = 5; 
            ROLLOUT.update = true; 
            break;
          case 118 : //F7
            ROLLOUT.parent = 6; 
            ROLLOUT.update = true; 
            break;
          case 119 : //F8
            ROLLOUT.parent = 7; 
            ROLLOUT.update = true; 
            break;
          }
        } else {
          switch(key) {

          case 'f' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD.update = true;
            WIN3D.update = true; 
            STUDY.update = true;
            ROLLOUT.update = true; 
            break;

          case 'F' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD.update = true;
            WIN3D.update = true; 
            STUDY.update = true;
            ROLLOUT.update = true; 
            break;
          }
        }
      } else if (e.isShiftDown()) {

        addNewSelectionToPreviousSelection = -1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : //F1
            ROLLOUT.child = 1; 
            ROLLOUT.update = true; 
            break;
          case 113 : //F2
            ROLLOUT.child = 2; 
            ROLLOUT.update = true; 
            break;
          case 114 : //F3
            ROLLOUT.child = 3; 
            ROLLOUT.update = true; 
            break;
          case 115 : //F4
            ROLLOUT.child = 4; 
            ROLLOUT.update = true; 
            break;
          case 116 : //F5
            ROLLOUT.child = 5; 
            ROLLOUT.update = true; 
            break;
          case 117 : //F6
            ROLLOUT.child = 6; 
            ROLLOUT.update = true; 
            break;
          case 118 : //F7
            ROLLOUT.child = 7; 
            ROLLOUT.update = true; 
            break;
          case 119 : //F8
            ROLLOUT.child = 8; 
            ROLLOUT.update = true; 
            break;
          }
        }
      }


      if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
        if (key == CODED) { 
          switch(key) {
          }
        }
      }

      if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

        if (key != CODED) { 
          switch(key) {

            case TAB: 
              typeUserCommand = (typeUserCommand + 1) % 2;
              UI_BAR_c_update = true;
              break; 
          }

        }
      }      

      if ((STUDY.update) || (WORLD.update) || (WIN3D.update) || (ROLLOUT.update)) redraw();
    }
  }
}

void keyReleased () {   

  addNewSelectionToPreviousSelection = 0;
}


float EquationOfTime (float DateAngle) {
  float b = DateAngle;

  return 0.01  * (9.87 * sin_ang(2 * b) - 7.53 * cos_ang(b) - 1.5 * sin_ang(b));
}

float FLOAT_e = 2.7182818284;

float[] SOLARCHVISION_SunPositionRadiation (float DateAngle, float HourAngleOrigin, float CloudCover) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle); 

  float Declination = 23.45 * sin_ang(DateAngle - 180.0);

  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngleOrigin);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngleOrigin);

  float x = c; 
  float y = -(a * cos_ang(STATION.getLatitude()) + b * sin_ang(STATION.getLatitude()));
  float z = -a * sin_ang(STATION.getLatitude()) + b * cos_ang(STATION.getLatitude());

  float Io = 1367.0; // W/m²
  Io = Io * (1.0 - (0.0334 * sin_ang(DateAngle)));

  float ALT_ = (asin_ang(z)) * PI / 180; 
  float ALT_true = ALT_ + 0.061359 * (0.1594 + 1.1230 * ALT_ + 0.065656 * ALT_ * ALT_) / (1 + 28.9344 * ALT_ + 277.3971 * ALT_ * ALT_);

  float PPo = pow(FLOAT_e, (-STATION.getElevation() / 8435.2));
  float Bb = ((sin_ang (ALT_true * 180 / PI)) + (0.50572 * pow((57.29578 * ALT_true + 6.07995), -1.6364)));
  float m = PPo / Bb;

  float StationTurbidity;

  StationTurbidity = (2.0 - 0.2) * (0.1 * CloudCover) + 0.2;

  float AtmosphereRatio;
  if (z < 0.01) AtmosphereRatio = 0.0; 
  else AtmosphereRatio = pow(FLOAT_e, (-m * StationTurbidity));

  float Idirect = Io * AtmosphereRatio; // Optical air mass: global Meteorological Database for Engineers, Planners and Education; Version 5.00 - Edition 2003

  float Idiffuse;
  if (z < 0.01) Idiffuse = 0.0;
  else Idiffuse = ((0.5 + 0.5 * (0.1 * CloudCover)) * z * (Io - Idirect)) / (1.0 - 1.4 * z * log(Idirect / Io));

  float[] return_array = {
    0, x, y, z, Idirect, Idiffuse
  }; 
  return return_array;
}

float[] SOLARCHVISION_SunPosition (float Latitude, float DateAngle, float HourAngleOrigin) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle);

  float Declination = 23.45 * sin_ang(DateAngle - 180.0);

  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngle);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngle);

  float x = c; 
  float y = -(a * cos_ang(Latitude) + b * sin_ang(Latitude));
  float z = -a * sin_ang(Latitude) + b * cos_ang(Latitude);

  float[] return_array = {
    0, x, y, z
  }; 
  return return_array;
}

float SOLARCHVISION_Sunrise (float Latitude, float DateAngle) {

  float a = 0;

  float Declination = 23.5 * sin_ang(DateAngle - 180.0);

  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  } else if (q < -1.0) {
    a = 24.0;
  } else a = acos_ang(q) / 15.0;

  //return (a - EquationOfTime(DateAngle));
  return a;
}

float SOLARCHVISION_Sunset (float Latitude, float DateAngle) {

  float a = 0;

  float Declination = 23.5 * sin_ang(DateAngle - 180.0);

  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  } else if (q < -1.0) {
    a = 24.0;
  } else a = acos_ang(q) / 15.0;


  //return ((24 - a) - EquationOfTime(DateAngle));
  return (24 - a);
}

float SOLARCHVISION_DayTime (float Latitude, float DateAngle) {
  return abs((SOLARCHVISION_Sunset(Latitude, DateAngle)) -(SOLARCHVISION_Sunrise(Latitude, DateAngle)));
}

String Default_Font = "MS Sans Serif";

/*
"MS Sans Serif"
 "Microsoft Sans Serif"
 "Arial Narrow"
 "Arial"
 "Times New Roman"
 "Calibri"
 "Cambria"
 "Georgia"
 "Courier New"
 "Franklin Gothic Medium"
 "BankGothic Md BT"
 */

PFont SOLARCHVISION_font;

void SOLARCHVISION_loadDefaultFontStyle () {

  println("Loading font:", Default_Font);

  SOLARCHVISION_font = createFont(Default_Font, 36, true);

  SOLARCHVISION_ResetFontStyle();
}

void SOLARCHVISION_ResetFontStyle () {

  textFont(SOLARCHVISION_font);
  WORLD.graphics.textFont(SOLARCHVISION_font);
  WIN3D.graphics.textFont(SOLARCHVISION_font);
  STUDY.graphics.textFont(SOLARCHVISION_font);
}





























void SOLARCHVISION_export_objects_SCR () {
  
  String fileBasename = ProjectName;

  String scrFilename = allModel3DsFolder + "/" + fileBasename + ".scr";  

  PrintWriter scrOutput = createWriter(scrFilename);

  scrOutput.println("-osnap off");

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if ((allFaces.nodes[f].length == 3) || (allFaces.nodes[f].length == 4)) {

      scrOutput.println("3dface");

      for (int j = 0; j < allFaces.nodes[f].length; j++) {

        float x = allVertices[allFaces.nodes[f][j]][0];
        float y = allVertices[allFaces.nodes[f][j]][1];
        float z = allVertices[allFaces.nodes[f][j]][2];

        scrOutput.println(nf(x, 0, Export_PrecisionVertex) + "," + nf(y, 0, Export_PrecisionVertex) + "," + nf(z, 0, Export_PrecisionVertex));
      }
      scrOutput.println();
      scrOutput.println();
    }
  }
  
  for (int f = 0; f < allCurves.nodes.length; f++) {

    scrOutput.println("line");

    for (int j = 0; j < allCurves.nodes[f].length; j++) {

      float x = allVertices[allCurves.nodes[f][j]][0];
      float y = allVertices[allCurves.nodes[f][j]][1];
      float z = allVertices[allCurves.nodes[f][j]][2];

      scrOutput.println(nf(x, 0, Export_PrecisionVertex) + "," + nf(y, 0, Export_PrecisionVertex) + "," + nf(z, 0, Export_PrecisionVertex));
    }
    
    if (allCurves.getMaterial(f) == 1) {
      scrOutput.println("c");
    }
    else {
      scrOutput.println();
    }
  }  

  scrOutput.println("zoom e");

  scrOutput.flush(); 
  scrOutput.close();   

  println("End of scripting lines and meshes."); 

  SOLARCHVISION_explore_output(scrFilename);
  println("File created:" + scrFilename);
}


PrintWriter radOutput;

void SOLARCHVISION_export_objects_RAD () {

  String fileBasename = ProjectName;

  String radFilename = allModel3DsFolder + "/" + fileBasename + ".rad";  

  radOutput = createWriter(radFilename);

  radOutput.println("#SOLARCHVISION");
  radOutput.println();



  Land3D.draw(TypeWindow.RAD);

  if (Display_allModel3Ds) {

    int[] Materials_Used = new int [Materials_Number];

    for (int i = 0; i < Materials_Used.length; i++) {
      Materials_Used[i] = 0;
    }

    for (int f = 0; f < allFaces.nodes.length; f++) {

      int mt = allFaces.getMaterial(f);

      Materials_Used[mt] += 1;
    }    

    for (int mt = 0; mt < Materials_Number; mt++) {

      if (Materials_Used[mt] != 0) {

        float a = Materials_Color[mt][0] / 255.0; 
        float r = Materials_Color[mt][1] / 255.0; 
        float g = Materials_Color[mt][2] / 255.0; 
        float b = Materials_Color[mt][3] / 255.0; 

        radOutput.println("void plastic " + "SurfaceMaterial" + nf(mt, 0));
        radOutput.println("0");
        radOutput.println("0");
        radOutput.println("5 " + nf(r, 0, Export_PrecisionVtexture) + " " + nf(g, 0, Export_PrecisionVtexture) + " " + nf(b, 0, Export_PrecisionVtexture) + " 0 0");

      }
    }
  
    for (int f = 0; f < allFaces.nodes.length; f++) {
  
      if (allFaces.nodes[f].length > 2) {

        int mt = allFaces.getMaterial(f);

        int Tessellation = allFaces.getTessellation(f);

        int TotalSubNo = 1;  
        if (allFaces.getMaterial(f) == 0) {
          Tessellation += allModel3Ds.Tessellation;
        }

        if ((allFaces.nodes[f].length > 4) && (Tessellation == 0)) { // don't need it for triangles
          Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
        }

        if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

        float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];
          base_Vertices[j][0] = allVertices[vNo][0];
          base_Vertices[j][1] = allVertices[vNo][1];
          base_Vertices[j][2] = allVertices[vNo][2];
        }

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
          
          for (int back_or_front = 1 - int(Export_BackSides); back_or_front <= 1; back_or_front++) {

            if (back_or_front == 1) {

              radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
              radOutput.println("0");
              radOutput.println("0");
              radOutput.println("9");      
              
              radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));                
              radOutput.println(" " + nf(subFace[1][0], 0, Export_PrecisionVertex) + " " + nf(subFace[1][1], 0, Export_PrecisionVertex) + " " + nf(subFace[1][2], 0, Export_PrecisionVertex));
              radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));
              
              if (subFace.length == 4) {

                radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                radOutput.println("0");
                radOutput.println("0");
                radOutput.println("9");      
                
                radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));                
                radOutput.println(" " + nf(subFace[3][0], 0, Export_PrecisionVertex) + " " + nf(subFace[3][1], 0, Export_PrecisionVertex) + " " + nf(subFace[3][2], 0, Export_PrecisionVertex));
                radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));
              }
              
              
            } else {

              radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
              radOutput.println("0");
              radOutput.println("0");
              radOutput.println("9");    
              
              radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));                
              radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));
              radOutput.println(" " + nf(subFace[1][0], 0, Export_PrecisionVertex) + " " + nf(subFace[1][1], 0, Export_PrecisionVertex) + " " + nf(subFace[1][2], 0, Export_PrecisionVertex));
              
              if (subFace.length == 4) { 
                
                radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                radOutput.println("0");
                radOutput.println("0");
                radOutput.println("9");                   
                
                radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));                
                radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));
                radOutput.println(" " + nf(subFace[3][0], 0, Export_PrecisionVertex) + " " + nf(subFace[3][1], 0, Export_PrecisionVertex) + " " + nf(subFace[3][2], 0, Export_PrecisionVertex));
              }
            }
          }
        }
          
        radOutput.println();
      }
    }
  }
  
  for (int i = 15; i < 180; i += 15) {
    radOutput.println("!gensky -ang " + nf(i, 0) + " 45 +s -trb 4.0");
  }   
  
  radOutput.flush(); 
  radOutput.close();   

  println("End of creating rad file."); 

  SOLARCHVISION_explore_output(radFilename);
  println("File created:" + radFilename);
  
  
  String batFilename = radFilename.replace(".rad", ".bat");
  PrintWriter batOutput = createWriter(batFilename);

  String Command1 = "oconv " + radFilename;
  String octFilename = radFilename.replace(".rad", ".oct");
  Command1 += " > " + octFilename;
  batOutput.println(Command1);
  
  String Command2 = "rvu";

  //Command2 += " -vtl"; //parallel
  Command2 += " -vtv"; //perspective
  //Command2 += " -vth"; //hemispherical
  //Command2 += " -vtc"; //cylindrical
  //Command2 += " -vta"; //angular
  //Command2 += " -vts"; //stereographic 
  
  Command2 += " -vv " + nf(WIN3D.Zoom, 0, 0);
  Command2 += " -vh " + nf(2 * atan_ang((WIN3D.dX / float(WIN3D.dY)) * tan_ang(0.5 * WIN3D.Zoom)), 0, 0);  

  Command2 += " -vp " + nf(WIN3D.CAM_x / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_y / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_z / OBJECTS_scale, 0, 0);

  float dx = cos_ang(90 - WIN3D.RX_Coordinate) * cos_ang(90 - WIN3D.RZ_Coordinate);
  float dy = cos_ang(90 - WIN3D.RX_Coordinate) * sin_ang(90 - WIN3D.RZ_Coordinate);
  float dz = sin_ang(90 - WIN3D.RX_Coordinate);
  
  Command2 += " -vd " + nf(-dx , 0, 0) + " " + nf(dy, 0, 0) + " " + nf(-dz, 0, 0);

  float ux = 0;
  float uy = 0;
  float uz = 1;
  if (abs(dz) > 0.99) {
    ux = cos_ang(90 + WIN3D.RZ_Coordinate);
    uy = sin_ang(90 + WIN3D.RZ_Coordinate);
    uz = 0; 
  }
  Command2 += " -vu " + nf(ux, 0, 0) + " " + nf(uy, 0, 0) + " " + nf(uz, 0, 0);



  

 
  
  Command2 += " -av 0.5 0.5 0.5";
  Command2 += " -pe 0.001";
  Command2 += " -ab 1";
  Command2 += " " + octFilename.replace('/', char(92));
  batOutput.println(Command2);
  
  batOutput.println("cmd /k"); // leave command prompt open

  batOutput.flush(); 
  batOutput.close();   


}



PrintWriter htmlOutput;

void SOLARCHVISION_export_objects_HTML () {

  String fileBasename = ProjectName;

  String htmlFilename = allModel3DsFolder + "/" + fileBasename + ".html";  

  htmlOutput = createWriter(htmlFilename);

  htmlOutput.println("<html>");
  htmlOutput.println("\t<head>");
  htmlOutput.println("\t\t<title>" + ProjectName + "</title>");   
  htmlOutput.println("\t\t<script type='text/javascript' src='http://www.x3dom.org/download/x3dom.js'></script>");
  htmlOutput.println("\t\t<link rel='stylesheet' type='text/css' href='http://www.x3dom.org/download/x3dom.css'></link>");
  htmlOutput.println("\t</head>"); 
  htmlOutput.println("\t<body>"); 
  htmlOutput.println("\t\t<x3d width='900px' height='600px'>");  
  htmlOutput.println("\t\t\t<scene>"); 

  htmlOutput.println("\t\t\t\t<viewpoint position='0 0 100'></Viewpoint>");
/*
{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM00'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RX_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RY_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RZ_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM01'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RY_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RZ_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RX_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM02'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RZ_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RX_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RY_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM03'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RZ_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RY_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RX_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM04'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RX_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RZ_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RY_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  
  
  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM05'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = cos_ang(WIN3D.RY_Coordinate * 0.5);
  float s1 = sin_ang(WIN3D.RY_Coordinate * 0.5);
  float c2 = cos_ang(WIN3D.RX_Coordinate * 0.5);
  float s2 = sin_ang(WIN3D.RX_Coordinate * 0.5);
  float c3 = cos_ang(WIN3D.RZ_Coordinate * 0.5);
  float s3 = sin_ang(WIN3D.RZ_Coordinate * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}
*/


  Earth3D.draw(TypeWindow.HTML);

  Land3D.draw(TypeWindow.HTML);

  Tropo3D.draw(TypeWindow.HTML, STUDY.i_Start, STUDY.i_End);
  
  allSections.draw(TypeWindow.HTML);
  
  allModel2Ds.draw(TypeWindow.HTML);

  if (Display_allModel3Ds) {

    int Create_Face_Texture = 0;

    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solid) || (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {
      Create_Face_Texture = 1;
    }    
    
    int PAL_TYPE = SHADE.get_PAL_TYPE(); 
    int PAL_DIR = SHADE.get_PAL_DIR();
    float PAL_Multiplier = SHADE.get_PAL_Multiplier(); 

    String the_filename = "";
    String TEXTURE_path = "";        

    if (Export_MaterialLibrary) {
      
      if (Create_Face_Texture == 0) {
        
        int[] Materials_Used = new int [Materials_Number];

        for (int i = 0; i < Materials_Used.length; i++) {
          Materials_Used[i] = 0;
        }

        for (int f = 0; f < allFaces.nodes.length; f++) {

          int mt = allFaces.getMaterial(f);

          Materials_Used[mt] += 1;
        }    

        for (int mt = 0; mt < Materials_Number; mt++) {

          if (Materials_Used[mt] != 0) {        

            htmlOutput.println("\t\t\t\t<Appearance DEF='SurfaceMaterial" + nf(mt, 0) + "'>");
            htmlOutput.print  ("\t\t\t\t\t<Material");
            htmlOutput.print  (" transparency='" + nf(1 - Materials_Color[mt][0] / 255.0, 0, 3) + "'");
            htmlOutput.print  (" diffuseColor='" + nf(Materials_Color[mt][1] / 255.0, 0, 3) + " " + nf(Materials_Color[mt][2] / 255.0, 0, 3) + " " + nf(Materials_Color[mt][3] / 255.0, 0, 3) + "'");
            htmlOutput.println("></Material>");
            htmlOutput.println("\t\t\t\t</Appearance>");
            
          }
        }

      } else {
        
        the_filename = "shadePallet.bmp";
        
        TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
        
        htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
        htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
        htmlOutput.println("\t\t\t\t</Appearance>");

        println("Saving texture:", TEXTURE_path);

        int RES1 = Export_PalletResolution; 
        int RES2 = Export_PalletResolution / 16;      

        PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       

        Pallet_Texture.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float _val = (Image_X / (0.5 * RES1)) - 1; 

          float _u = 0.5 + _val;

          if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
            if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
          }            

          float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  

          Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }

        Pallet_Texture.updatePixels();   

        Pallet_Texture.save(TEXTURE_path);  

      } 
    }


    for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {

      if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {

        htmlOutput.println("\t\t\t\t<group>");
        
        for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
      
          if (allFaces.nodes[f].length > 2) {
            
            int mt = allFaces.getMaterial(f);
    
            int Tessellation = allFaces.getTessellation(f);
    
            int TotalSubNo = 1;  
            if (allFaces.getMaterial(f) == 0) {
              Tessellation += allModel3Ds.Tessellation;
            }
    
            if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
    
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allVertices[vNo][0];
              base_Vertices[j][1] = allVertices[vNo][1];
              base_Vertices[j][2] = allVertices[vNo][2];
            }
    
            for (int n = 0; n < TotalSubNo; n++) {
    
              float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
              
              for (int back_or_front = 1 - int(Export_BackSides); back_or_front <= 1; back_or_front++) {
    
                htmlOutput.println("\t\t\t\t\t<shape>");
    
                if (Create_Face_Texture == 0) {
                  htmlOutput.println("\t\t\t\t\t\t<Appearance USE='SurfaceMaterial" + nf(mt, 0) + "'></Appearance>");
                }
                else {
                  htmlOutput.println("\t\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");
                }              
    
                
                htmlOutput.print  ("\t\t\t\t\t\t<IndexedFaceSet");
                
                htmlOutput.print  (" coordIndex='");
                for (int q = 0; q < subFace.length; q++) {
                  if (q > 0) {
                    htmlOutput.print(" ");
                  }         
                  htmlOutput.print(nf(q, 0));          
                }
                htmlOutput.println(" -1'>");
                
                htmlOutput.print  ("\t\t\t\t\t\t\t<Coordinate point='");
                for (int q = 0; q < subFace.length; q++) {
                  if (q > 0) {
                    htmlOutput.print(",");
                  }                  
                  int s = q;
                  if (back_or_front == 0) {
                    s = subFace.length - 1 - q;
                  }
                  
                  htmlOutput.print(nf(subFace[s][0], 0, Export_PrecisionVertex) + " " + nf(subFace[s][1], 0, Export_PrecisionVertex) + " " + nf(subFace[s][2], 0, Export_PrecisionVertex));
                }                
                htmlOutput.println("'></Coordinate>");
    
    
    
    
    
    
                if (Create_Face_Texture == 1) {
     
                  htmlOutput.print  ("\t\t\t\t\t\t\t<TextureCoordinate point='");
                  for (int q = 0; q < subFace.length; q++) {
                    if (q > 0) {
                      htmlOutput.print(",");
                    }                  
                    int s = q;
                    if (back_or_front == 0) {
                      s = subFace.length - 1 - q;
                    }
                    
                    float _u = 0;
      
        
                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;
        
                      if (back_or_front == 0) {
                        int s_temp = s_next;
                        s_next = s_prev;
                        s_prev = s_temp;
                      }
        
                      _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }
        
                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
                      
                      _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }                            
        
                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
        
                      _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }                  
        
                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
        
                      _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }
        
        
                    float u0 = 0.5 * (_u + 0.5);
        
                    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                      if (Impact_TYPE == Impact_ACTIVE) {
                        u0 = _u;
                      }
                    }
        
                    if (u0 > 1) u0 = 1;
                    if (u0 < 0) u0 = 0;
      
                    SOLARCHVISION_HTMLprintVtexture(u0, 0.5);
                  }                
                  
                  htmlOutput.println("'></TextureCoordinate>");           
                }
                
        
                htmlOutput.println("\t\t\t\t\t\t</IndexedFaceSet>");
               
                htmlOutput.println("\t\t\t\t\t</shape>");
                
              }
            }
          }
        }
        htmlOutput.println("\t\t\t\t</group>");
      }
    }
  }
  
  
  
  
  
  htmlOutput.println("\t\t\t</scene>"); 
  htmlOutput.println("\t\t</x3d>"); 
  
/*  
  htmlOutput.println("\t\t<div id='camera_buttons' style='display: block;'>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM00').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM00<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM01').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM01<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM02').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM02<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM03').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM03<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM04').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM04<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM05').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM05<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t</div>");
*/

  htmlOutput.println("\t</body>"); 
  htmlOutput.println("</html>");
  
  htmlOutput.flush(); 
  htmlOutput.close();   

  println("End of creating html file."); 

  SOLARCHVISION_explore_output(htmlFilename);
  println("File created:" + htmlFilename);

}



void SOLARCHVISION_export_objects_OBJ_timeSeries () {

  int keep_STUDY_i_Start = STUDY.i_Start;
  
  for (int i = 0; i < 24; i++) {

    STUDY.i_Start = i;
    
    SOLARCHVISION_find_which_bakings_to_regenerate();
    SOLARCHVISION_regenerate_desired_bakings();
      
    
    SOLARCHVISION_export_objects_OBJ("_" + nf(i, 2));
  
  }
  
  STUDY.i_Start = keep_STUDY_i_Start;
}



void SOLARCHVISION_export_objects_OBJ_dateSeries () {

  int keep_IMPACTS_DisplayDay = IMPACTS_DisplayDay;
  
  for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {

    IMPACTS_DisplayDay = j;
    
    SOLARCHVISION_export_objects_OBJ("_" + nf(j, 3));
  
  }
  
  IMPACTS_DisplayDay = keep_IMPACTS_DisplayDay;
}


String Export_MapsSubfolder = "maps/";

PrintWriter mtlOutput;
PrintWriter objOutput;


int obj_lastVertexNumber;
int obj_lastVtextureNumber;
int obj_lastFaceNumber;
int obj_lastGroupNumber;



int num_vertices_added = 0;

void SOLARCHVISION_export_objects_OBJ (String suffix) {

  String fileBasename = ProjectName + suffix;

  String objFilename = allModel3DsFolder + "/" + fileBasename + ".obj";
  String mtlFilename = allModel3DsFolder + "/" + fileBasename + ".mtl";


  if (Export_MaterialLibrary) {
    mtlOutput = createWriter(mtlFilename);
    mtlOutput.println("#SOLARCHVISION");
  }

  objOutput = createWriter(objFilename);
  objOutput.println("#SOLARCHVISION");
  if (Export_MaterialLibrary) {
    objOutput.println("mtllib " + fileBasename + ".mtl");
  }

  obj_lastVertexNumber = 0; 
  obj_lastVtextureNumber = 0; 
  obj_lastFaceNumber = 0;
  obj_lastGroupNumber = 0;






  Earth3D.draw(TypeWindow.OBJ);

  Land3D.draw(TypeWindow.OBJ);

  Tropo3D.draw(TypeWindow.OBJ, STUDY.i_Start, STUDY.i_End);  
  
  allSections.draw(TypeWindow.OBJ);
  
  allModel2Ds.draw(TypeWindow.OBJ);




  if (Display_allModel3Ds) {



    int Create_Face_Texture = 0;

    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solid) || (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {
      Create_Face_Texture = 1;
    }

    if (Create_Face_Texture == 0) {

      if (Export_MaterialLibrary) {

        int[] Materials_Used = new int [Materials_Number];

        for (int i = 0; i < Materials_Used.length; i++) {
          Materials_Used[i] = 0;
        }

        for (int f = 0; f < allFaces.nodes.length; f++) {

          int mt = allFaces.getMaterial(f);

          Materials_Used[mt] += 1;
        }    

        for (int mt = 0; mt < Materials_Number; mt++) {

          if (Materials_Used[mt] != 0) {

            float a = Materials_Color[mt][0] / 255.0; 
            float r = Materials_Color[mt][1] / 255.0; 
            float g = Materials_Color[mt][2] / 255.0; 
            float b = Materials_Color[mt][3] / 255.0; 

            mtlOutput.println("newmtl SurfaceMaterial" + nf(mt, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // ambient
            mtlOutput.println("\tKd " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td " + nf(a, 0, 3)); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr " + nf(a, 0, 3)); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
        }
      }


      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {

        if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {

          for (int back_or_front = 1 - int(Export_BackSides); back_or_front <= 1; back_or_front++) {

            num_vertices_added = 0;

            for (int _turn = 1; _turn < 4; _turn++) {

              if (_turn == 3) {
                if (Export_PolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }
              }  

              int prev_mt = -1;

              for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {

                if (_turn == 3) {
                  if (Export_MaterialLibrary) {
                    int mt = allFaces.getMaterial(f);
                    if (prev_mt != mt) {
                      objOutput.println("usemtl SurfaceMaterial" + nf(mt, 0));
                      prev_mt = mt;
                    }
                  }
                }                  

                int Tessellation = allFaces.getTessellation(f);

                int TotalSubNo = 1;  
                if (allFaces.getMaterial(f) == 0) {
                  Tessellation += allModel3Ds.Tessellation;
                }

                if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                for (int j = 0; j < allFaces.nodes[f].length; j++) {
                  int vNo = allFaces.nodes[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }

                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                  for (int s = 0; s < subFace.length; s++) {

                    if (_turn == 1) {
                      SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                    }

                    if (_turn == 2) {

                      float t = PI / float(subFace.length);

                      float u = 0.5 * cos((2 * s + 1) * t) / cos(t) + 0.5;
                      float v = 0.5 * sin((2 * s + 1) * t) / cos(t) + 0.5;

                      SOLARCHVISION_OBJprintVtexture(u, v, 0);
                    }
                  }


                  if (_turn == 3) {

                    num_vertices_added += subFace.length;

                    if (Export_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }                    

                    obj_lastFaceNumber += 1;

                    objOutput.print("f ");
                    if (back_or_front == 1) {
                      for (int s = 0; s < subFace.length; s++) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s < subFace.length - 1) {
                          objOutput.print(" ");
                        }
                      }
                    } else {
                      for (int s = subFace.length - 1; s >= 0; s--) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s > 0) {
                          objOutput.print(" ");
                        }
                      }
                    }
                    objOutput.println("");
                  }
                }
              }
            }

            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;
          }
        }
      }
    } else {

      int PAL_TYPE = SHADE.get_PAL_TYPE(); 
      int PAL_DIR = SHADE.get_PAL_DIR();
      float PAL_Multiplier = SHADE.get_PAL_Multiplier(); 

      String the_filename = "";
      String TEXTURE_path = "";

      if (Export_MaterialLibrary) {

        the_filename = "shadePallet.bmp";

        TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;

        println("Saving texture:", TEXTURE_path);

        int RES1 = Export_PalletResolution; 
        int RES2 = Export_PalletResolution / 16;      

        PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


        Pallet_Texture.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float _val = (Image_X / (0.5 * RES1)) - 1; 

          float _u = 0.5 + _val;

          if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
            if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
          }            

          float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  

          Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }

        Pallet_Texture.updatePixels();   

        Pallet_Texture.save(TEXTURE_path);



        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

        //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map
     
      }


      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {

        if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {

          for (int back_or_front = 1 - int(Export_BackSides); back_or_front <= 1; back_or_front++) {

            num_vertices_added = 0;

            for (int _turn = 1; _turn < 4; _turn++) {

              int CurrentFaceTextureNumber = -1;

              if (_turn == 3) {

                if (Export_PolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }

                if (Export_MaterialLibrary) {

                  objOutput.println("usemtl " +  the_filename.replace('.', '_'));

                }
              }  

              for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {

                int Tessellation = allFaces.getTessellation(f);

                int TotalSubNo = 1;  
                if (allFaces.getMaterial(f) == 0) {
                  Tessellation += allModel3Ds.Tessellation;
                }

                if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                float x3 = 0;
                float y3 = 0;
                float z3 = 0;

                float x4 = 0;
                float y4 = 0;
                float z4 = 0;

                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                for (int j = 0; j < allFaces.nodes[f].length; j++) {
                  int vNo = allFaces.nodes[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }

                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                  CurrentFaceTextureNumber += 1;

                  if (_turn == 1) {   

                    if (Export_MaterialLibrary) {

                      for (int s = 0; s < subFace.length; s++) {

                        float[] COL = {
                          255, 255, 255, 255
                        };

                        if (s == 0) {
                          x1 = subFace[s][0];
                          y1 = subFace[s][1];
                          z1 = subFace[s][2];
                        }
                        if (s == 1) {
                          x2 = subFace[s][0];
                          y2 = subFace[s][1];
                          z2 = subFace[s][2];
                        }            
                        if (s == 2) { 
                          x3 = subFace[s][0];
                          y3 = subFace[s][1];
                          z3 = subFace[s][2];
                        }          
                        if (s == 3) {
                          x4 = subFace[s][0];
                          y4 = subFace[s][1];
                          z4 = subFace[s][2];
                        }
                      }

                    }

                    SOLARCHVISION_OBJprintVertex(x1, y1, z1);
                    SOLARCHVISION_OBJprintVertex(x2, y2, z2);
                    SOLARCHVISION_OBJprintVertex(x3, y3, z3);
                    SOLARCHVISION_OBJprintVertex(x4, y4, z4);
                  }

                  if (_turn == 2) {

                    for (int s = 0; s < subFace.length; s++) {

                      float _u = 0;

                      if (WIN3D.FacesShade == SHADE.Global_Solar) {
                        int s_next = (s + 1) % subFace.length;
                        int s_prev = (s + subFace.length - 1) % subFace.length;

                        if (back_or_front == 0) {
                          int s_temp = s_next;
                          s_next = s_prev;
                          s_prev = s_temp;
                        }

                        _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                      }
        
                      if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
                        
                        _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                      }                            

                      if (WIN3D.FacesShade == SHADE.Vertex_Solid) {

                        _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                      }                  

                      if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {

                        _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                      }


                      float u0 = 0.5 * (_u + 0.5);

                      if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                        if (Impact_TYPE == Impact_ACTIVE) {
                          u0 = _u;
                        }
                      }

                      if (u0 > 1) u0 = 1;
                      if (u0 < 0) u0 = 0;
                      
                      SOLARCHVISION_OBJprintVtexture(u0, 0.5, 0);
                    }

                    
                  }

                  if (_turn == 3) {

                    num_vertices_added += 4;

                    if (Export_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }

                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

                    obj_lastFaceNumber += 1;
                    if (back_or_front == 1) {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    } else {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }
              }
            }

            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;
          }
        }
      }
    }
  }




  if (Display_allModel1Ds) {

    if (Export_MaterialLibrary) {

      if (allModel1Ds.num != 0) {

        mtlOutput.println("newmtl " + "allModel1Ds_Trunk");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 0.750 0.500"); // ambient
        mtlOutput.println("\tKd 1.000 0.750 0.500"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter


        mtlOutput.println("newmtl " + "allModel1Ds_Leaf");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 0.500 0.750 0.250"); // ambient
        mtlOutput.println("\tKd 0.500 0.750 0.250"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      }
    }


    for (int f = 0; f < allModel1Ds.num; f++) {

      float x = allModel1Ds.getX(f);
      float y = allModel1Ds.getY(f);
      float z = allModel1Ds.getZ(f);

      float r = allModel1Ds.getS(f) * 0.5;
      float rot = allModel1Ds.getR(f);

      int n = allModel1Ds.getType(f);

      int dMin = allModel1Ds.getDegreeMin(f);

      int dMax = allModel1Ds.getDegreeMax(f);

      int s = allModel1Ds.getSeed(f);

      float TrunkSize = allModel1Ds.getTrunkSize(f);

      float LeafSize = allModel1Ds.getLeafSize(f);

      randomSeed(s);

      if (n == 0) {

        num_vertices_added = 0;

        if (Export_PolyToPoly == 1) {
          obj_lastGroupNumber += 1;
          objOutput.println("g allModel1Ds_" + nf(f, 0));
        }    

        float Alpha = 0;
        float Beta = rot; 

        for (int _turn = 1; _turn < 4; _turn++) {
          allModel1Ds.branch_export(_turn, x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);
        }

        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }
    }
  }  



  if (Display_WindFlow) {  

    int PAL_TYPE = WindFlow_Pallet_CLR; 
    int PAL_DIR = WindFlow_Pallet_DIR; 
    float PAL_Multiplier = WindFlow_Pallet_MLT;

    String the_filename = "";

    if (Export_MaterialLibrary) {

      the_filename = "WindFlowPallet.bmp";

      String TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;

      println("Saving texture:", TEXTURE_path);

      int RES1 = Export_PalletResolution; 
      int RES2 = Export_PalletResolution / 16;       

      PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


      Pallet_Texture.loadPixels();

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;

        float _val = (Image_X / (0.5 * RES1)) - 1; 

        float _u = 0.5 + 0.5 * _val;

        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  

        Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
      }

      Pallet_Texture.updatePixels();   

      Pallet_Texture.save(TEXTURE_path);      


      mtlOutput.println("newmtl " + "WindFlow");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
      mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map
    }    

    num_vertices_added = 0;

    for (int _turn = 1; _turn < 4; _turn++) {    

      if (_turn == 3) {
        obj_lastGroupNumber += 1;
        objOutput.println("g WindFlow");

        if (Export_MaterialLibrary) {
          objOutput.println("usemtl WindFlow");
        }
      }        

      for (int q = 0; q < WindFlow_Lines.length; q++) {

        int n1 = WindFlow_Lines[q][0];
        int n2 = WindFlow_Lines[q][1];

        float x1 = WindFlow_Vertices[n1][0];
        float y1 = WindFlow_Vertices[n1][1];
        float z1 = WindFlow_Vertices[n1][2];

        float x2 = WindFlow_Vertices[n2][0];
        float y2 = WindFlow_Vertices[n2][1];
        float z2 = WindFlow_Vertices[n2][2];


        float _val = WindFlow_Pallet_MLT * WindFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

        float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float the_dist = dist(x1, y1, z1, x2, y2, z2);

        float[] W = {
          x2 - x1, y2 - y1, z2 - z1
        };
        W = SOLARCHVISION_fn_normalize(W);

        float Alpha = asin_ang(W[2]);
        float Beta = atan2_ang(W[1], W[0]) + 90;   


        if (_turn == 1) {

          SOLARCHVISION_OBJprintVertex(x1, y1, z1);
          SOLARCHVISION_OBJprintVertex(x2, y2, z2);

          for (int i = 0; i < 4; i++) {

            float px = 0.1 * the_dist * cos(i * HALF_PI);
            float py = 0;
            float pz = 0.1 * the_dist * sin(i * HALF_PI); 

            float pz_rot = pz;
            float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
            float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  

            px = px_rot;
            py = py_rot;
            pz = pz_rot;

            px_rot = px;
            py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
            pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);

            px = px_rot;
            py = py_rot;
            pz = pz_rot;    

            SOLARCHVISION_OBJprintVertex(x1 + px, y1 + py, z1 + pz);
          }
        }


        if (_turn == 2) {
          for (int i = 0; i < 6; i++) {

            float u1 = 0.5 * (_u + 0.5);

            if (u1 > 0.999) u1 = 0.999;
            if (u1 < 0.001) u1 = 0.001;

            SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
          }
        }

        if (_turn == 3) {
          num_vertices_added += 6;

          String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 5, 0); 
          String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 4, 0);
          String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
          String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
          String n5_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
          String n6_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

          String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 5, 0); 
          String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 4, 0);
          String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
          String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
          String m5_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
          String m6_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n4_txt + "/" + m4_txt + " " + n5_txt + "/" + m5_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n5_txt + "/" + m5_txt + " " + n6_txt + "/" + m6_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n6_txt + "/" + m6_txt + " " + n3_txt + "/" + m3_txt);

          obj_lastFaceNumber += 4;
        }
      }
    }

    obj_lastVertexNumber += num_vertices_added;
    obj_lastVtextureNumber += num_vertices_added;
  }


  if (Sky3D.Display_Surface) {

    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

      int PAL_TYPE = 0; 
      int PAL_DIR = 1;
      float PAL_Multiplier = 1; 

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = Sky3D.Pallet_ACTIVE_CLR; 
        PAL_DIR = Sky3D.Pallet_ACTIVE_DIR;  
        PAL_Multiplier = 1.0 * Sky3D.Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_TYPE = Sky3D.Pallet_PASSIVE_CLR; 
        PAL_DIR = Sky3D.Pallet_PASSIVE_DIR;  
        PAL_Multiplier = 0.05 * Sky3D.Pallet_PASSIVE_MLT;
      }             



      String the_filename = "";
      String TEXTURE_path = "";  

      if (Export_MaterialLibrary) {

        the_filename = "skyPatternPallet.bmp";

        TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;

        println("Saving texture:", TEXTURE_path);

        int RES1 = Export_PalletResolution; 
        int RES2 = Export_PalletResolution / 16;      

        PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


        Pallet_Texture.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float _val = (Image_X / (0.5 * RES1)) - 1; 

          float _u = 0.5 + _val;

          if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

          float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);  

          Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }

        Pallet_Texture.updatePixels();   

        Pallet_Texture.save(TEXTURE_path);      


        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

        //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map
      }      

      obj_lastGroupNumber += 1;
      objOutput.println("g skyPattern");

      if (Export_MaterialLibrary) {      
        objOutput.println("usemtl " +  the_filename.replace('.', '_'));
      }      

      num_vertices_added = 0;

      for (int _turn = 1; _turn < 4; _turn++) {

        for (int f = 0; f < skyFaces.length; f++) {

          int Tessellation = 0;

          int TotalSubNo = 1;  
          Tessellation = Sky3D.Tessellation;
          if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

          float[][] base_Vertices = new float [skyFaces[f].length][3];
          for (int j = 0; j < skyFaces[f].length; j++) {
            int vNo = skyFaces[f][j];
            base_Vertices[j][0] = skyVertices[vNo][0];
            base_Vertices[j][1] = skyVertices[vNo][1];
            base_Vertices[j][2] = skyVertices[vNo][2];
          }

          for (int n = 0; n < TotalSubNo; n++) {

            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

            for (int j = 0; j < subFace.length; j++) {
              subFace[j] = SOLARCHVISION_fn_normalize(subFace[j]);
            }



            for (int s = 0; s < subFace.length; s++) {

              int s_next = (s + 1) % subFace.length;
              int s_prev = (s + subFace.length - 1) % subFace.length;

              float x = subFace[s][0] * Sky3D.scale * WIN3D.scale;
              float y = subFace[s][1] * Sky3D.scale * WIN3D.scale;
              float z = subFace[s][2] * Sky3D.scale * WIN3D.scale;

              float _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);


              if (_turn == 1) {

                SOLARCHVISION_OBJprintVertex(x, y, z);
              }

              if (_turn == 2) { 
                float u1 = 0.5 * (_u + 0.5);

                if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) { 
                  if  (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                }

                if (u1 > 0.999) u1 = 0.999;
                if (u1 < 0.001) u1 = 0.001;

                SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
              }

              if (_turn == 3) {
                num_vertices_added += 1;
              }
            }

            if (_turn == 3) {
              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);  
              if (Export_BackSides) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              }
            }
          }
        }
      }

      obj_lastVertexNumber += num_vertices_added;
      obj_lastVtextureNumber += num_vertices_added;
    }
  }


  if (Display_SUN_Pattern) {

    float keep_STUDY_PerDays = STUDY.PerDays;
    int keep_STUDY_JoinDays = STUDY.JoinDays;
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      STUDY.PerDays = 1;
      STUDY.JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;

    SOLARCHVISION_draw_SunPathCycles(0, 0, 0, 0.975 * Sky3D.scale, 0.975 * Sky3D.scale, 0.975 * Sky3D.scale, STUDY.ImpactLayer, 4);

    STUDY.PerDays = keep_STUDY_PerDays;
    STUDY.JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }

  if (Export_MaterialLibrary) {
    mtlOutput.flush(); 
    mtlOutput.close();
  }

  objOutput.flush(); 
  objOutput.close();   


  println("End of exporting the mesh."); 

  SOLARCHVISION_explore_output(objFilename);
  println("File created:" + objFilename);
}

void SOLARCHVISION_OBJprintVertex (float x, float y, float z) {

  float a = x * Export_Scale;
  float b = y * Export_Scale;
  float c = z * Export_Scale;

  if (Export_FlipZYaxis == 0) {

    objOutput.println("v " + nf(a, 0, Export_PrecisionVertex) + " " +  nf(b, 0, Export_PrecisionVertex) + " " +  nf(c, 0, Export_PrecisionVertex));
  } else {

    objOutput.println("v " + nf(-a, 0, Export_PrecisionVertex) + " " +  nf(c, 0, Export_PrecisionVertex) + " " +  nf(b, 0, Export_PrecisionVertex));
  }
}



void SOLARCHVISION_OBJprintVtexture (float u, float v, float w) {

  objOutput.println("vt " + nf(u, 0, Export_PrecisionVtexture) + " " + nf(v, 0, Export_PrecisionVtexture) + " " + nf(w, 0, Export_PrecisionVtexture));
}  


void SOLARCHVISION_HTMLprintVtexture (float u, float v) {

  htmlOutput.print(nf(u, 0, Export_PrecisionVtexture) + " " + nf(v, 0, Export_PrecisionVtexture));
}  




void SOLARCHVISION_import_objects_OBJ (String FileName, int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz) {

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  int[] importVerticeNumber = {
    0
  };

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  float Progress = 0;

  for (int f = 0; f < FileALL.length; f++) {

    if (1 + Progress < 100 * f / float(FileALL.length)) { 
      Progress = 100 * f / float(FileALL.length);
      println("Progress:", int(Progress), "%");
    }

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("g")) {
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % 8);

      if (addToLastGroup == 0) allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      int[] v = {
        allModel3Ds.add_Vertex(x, y, z)
      };

      importVerticeNumber = concat(importVerticeNumber, v);
    }

    if (parts[0].toLowerCase().equals("f")) {

      //println(parts);

      int FaceDegree = parts.length - 1; // if we don't have space at the end of the line.

      if (parts[FaceDegree].equals("")) {  // if we have 1 space at the end of the line.
        FaceDegree -= 1;
      }

      int[] newFace = new int [FaceDegree]; 

      for (int n = 0; n < newFace.length; n++) {

        String[] the_numbers = split(parts[n + 1], '/');

        int vertexNumber = int(the_numbers[0]);

        if (vertexNumber > 0) {
          newFace[n] = importVerticeNumber[vertexNumber];
        } else if (vertexNumber < 0) { // for negative numbering
          newFace[n] = allVertices.length - abs(vertexNumber);
        } else { // case 0
        }
      }

      //println(newFace);

      allModel3Ds.add_Face(newFace);
    }
  }

  println("Progress: 100 %");
}  


float SOLARCHVISION_import_objects_asParametricBox_OBJ (String FileName, int m, float cx, float cy, float cz, float sx, float sy, float sz) {

  float[][] importVertices = {
    {
    }
  };

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      float[][] v = {
        {
          x, y, z
        }
      };

      importVertices = (float[][]) concat(importVertices, v);
    }
  }

  float min_X = FLOAT_undefined;
  float max_X = -FLOAT_undefined;
  float min_Y = FLOAT_undefined;
  float max_Y = -FLOAT_undefined;
  float min_Z = FLOAT_undefined;
  float max_Z = -FLOAT_undefined;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    if (min_X > x) min_X = x;
    if (max_X < x) max_X = x;
    if (min_Y > y) min_Y = y;
    if (max_Y < y) max_Y = y;
    if (min_Z > z) min_Z = z;
    if (max_Z < z) max_Z = z;
  }

  float cen_X = 0.5 * (min_X + max_X);
  float cen_Y = 0.5 * (min_Y + max_Y);
  float cen_Z = 0.5 * (min_Z + max_Z);

  float R_out = 0;
  float X_out = 0;
  float Y_out = 0;
  float Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    float r = dist(cen_X, cen_Y, cen_Z, x, y, z);

    if (R_out < r) {
      R_out = r;

      X_out = x;
      Y_out = y;
      Z_out = z;
    }
  }  

  float T_out = atan2_ang(Y_out, X_out);

  X_out = 0;
  Y_out = 0;
  Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = (importVertices[vNo][0] - cen_X) * cos_ang(-T_out) - (importVertices[vNo][1] - cen_Y) * sin_ang(-T_out);
    float y = (importVertices[vNo][0] - cen_X) * sin_ang(-T_out) + (importVertices[vNo][1] - cen_Y) * cos_ang(-T_out);
    float z = importVertices[vNo][2];

    if (X_out < abs(x)) X_out = abs(x);
    if (Y_out < abs(y)) Y_out = abs(y);
    if (Z_out < abs(z)) Z_out = abs(z);
  }  

  //allModel3Ds.add_Box_Core(m, cen_X,cen_Y,cen_Z, X_out,Y_out,Z_out, T_out);
  allModel3Ds.add_Solid(cen_X, cen_Y, cen_Z, CubePower, CubePower, CubePower, X_out, Y_out, Z_out, 0, 0, T_out, 1);

  return min_Z;
}  












void SOLARCHVISION_delete_All () {
  
  allModel1Ds.delete();
  allModel2Ds.delete();

  allModel3Ds.delete_Faces();
  allModel3Ds.delete_Curves();
  allModel3Ds.delete_Vertices();

  allModel3Ds.delete_allSolids();
  allModel3Ds.delete_allSections();
  allModel3Ds.delete_allCameras();

  allModel3Ds.delete_allGroups(); 

  WIN3D.update = true;
}


























  






float OBJECTS_scale = 1.0;  


int SKY2D_X_View = 50;
int SKY2D_Y_View = 50;
float SKY2D_ZOOM = 5;
PGraphics SKY2D_graphics;


void ViewFromTheSky (float SKY2D_X_Coordinate, float SKY2D_Y_Coordinate, float SKY2D_Z_Coordinate, float SKY2D_RX_Coordinate, float SKY2D_RY_Coordinate, float SKY2D_RZ_Coordinate) {

  SKY2D_graphics.beginDraw();

  SKY2D_graphics.background(233);

  SKY2D_graphics.ortho(SKY2D_X_View / -SKY2D_ZOOM, SKY2D_X_View / SKY2D_ZOOM, SKY2D_Y_View / -SKY2D_ZOOM, SKY2D_Y_View / SKY2D_ZOOM, 0.00001, 100000);

  SKY2D_graphics.translate(0, 1.0 * SKY2D_Y_View, 0); // << IMPORTANT! 

  SKY2D_graphics.translate(SKY2D_X_Coordinate, SKY2D_Y_Coordinate, SKY2D_Z_Coordinate);
  SKY2D_graphics.rotateX(SKY2D_RX_Coordinate * PI / 180); 
  SKY2D_graphics.rotateY(SKY2D_RY_Coordinate * PI / 180);
  SKY2D_graphics.rotateZ(SKY2D_RZ_Coordinate * PI / 180); 

  SKY2D_graphics.hint(ENABLE_DEPTH_TEST);
  
  Land3D.draw(TypeWindow.SKY2D);

  for (int f = 0; f < allFaces.nodes.length; f++) {

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      color c = color(0, 0, 0);

      int mt = allFaces.getMaterial(f);
      c = color(Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3], Materials_Color[mt][0]);

      SKY2D_graphics.stroke(c);
      SKY2D_graphics.fill(c);

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allModel3Ds.Tessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allVertices[vNo][0];
        base_Vertices[j][1] = allVertices[vNo][1];
        base_Vertices[j][2] = allVertices[vNo][2];
      }

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

        SKY2D_graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {

          SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
        }

        SKY2D_graphics.endShape(CLOSE);
      }
    }
  }
  
  SKY2D_graphics.endDraw();
}
















void SOLARCHVISION_draw_WindFlow () {

  if (Display_WindFlow) {  

    int PAL_TYPE = WindFlow_Pallet_CLR; 
    int PAL_DIR = WindFlow_Pallet_DIR; 
    float PAL_Multiplier = WindFlow_Pallet_MLT;



    for (int q = 0; q < WindFlow_Lines.length; q++) {

      int n1 = WindFlow_Lines[q][0];
      int n2 = WindFlow_Lines[q][1];

      float x1 = WindFlow_Vertices[n1][0];
      float y1 = WindFlow_Vertices[n1][1];
      float z1 = WindFlow_Vertices[n1][2];

      float x2 = WindFlow_Vertices[n2][0];
      float y2 = WindFlow_Vertices[n2][1];
      float z2 = WindFlow_Vertices[n2][2];


      float _val = WindFlow_Pallet_MLT * WindFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

      float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);      

      /*    
       WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
       WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
       
       WIN3D.graphics.strokeWeight(1);
       WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
       
       WIN3D.graphics.strokeWeight(4);      
       WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, 0.5 * (x2 + x1) * OBJECTS_scale * WIN3D.scale, -0.5 * (y2 + y1) * OBJECTS_scale * WIN3D.scale, 0.5 * (z2 + z1) * OBJECTS_scale * WIN3D.scale);
       */


      float the_dist = dist(x1, y1, z1, x2, y2, z2);

      float[] W = {
        x2 - x1, y2 - y1, z2 - z1
      };
      W = SOLARCHVISION_fn_normalize(W);

      float Alpha = asin_ang(W[2]);
      float Beta = atan2_ang(W[1], W[0]) + 90;   

      WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);
      WIN3D.graphics.noStroke();

      for (int i = 0; i < 4; i++) {

        WIN3D.graphics.beginShape();

        WIN3D.graphics.vertex(x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);  

        for (int j = 0; j < 2; j++) {

          float px = 0.1 * the_dist * cos((i + j) * HALF_PI);
          float py = 0;
          float pz = 0.1 * the_dist * sin((i + j) * HALF_PI); 

          float pz_rot = pz;
          float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
          float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  

          px = px_rot;
          py = py_rot;
          pz = pz_rot;

          px_rot = px;
          py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
          pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);

          px = px_rot;
          py = py_rot;
          pz = pz_rot;          

          WIN3D.graphics.vertex((x1 + px) * OBJECTS_scale * WIN3D.scale, -(y1 + py) * OBJECTS_scale * WIN3D.scale, (z1 + pz) * OBJECTS_scale * WIN3D.scale);
        }

        WIN3D.graphics.endShape(CLOSE);
      }
    }


    WIN3D.graphics.strokeWeight(0);
  }
}





int getLoactationTimeZone () {
  return int(roundTo(STATION.getLongitude() / 15, 15)); 
}


int[] getNow_inUTC () {
  
  int LoactationTimeZone = getLoactationTimeZone();
  
  int CurrentYear = year();
  int CurrentMonth = month();
  int CurrentDay = day();
  int CurrentHour = hour();

   
  // converting from local time to global time 
  
  if (LoactationTimeZone > 0) {
    CurrentHour -= LoactationTimeZone;
    
    if (CurrentHour < 0) {
      CurrentHour += 24;
      CurrentDay -= 1;

      if (CurrentDay < 1) { 
        
        CurrentMonth -= 1;
        
        if (CurrentMonth < 1) {
          CurrentMonth = 12;
          CurrentYear -= 1;
        }
        
        CurrentDay = CalendarLength[CurrentMonth - 1];
      }
    }
  }
  else if (LoactationTimeZone < 0) {
    CurrentHour += abs(LoactationTimeZone);
    
    if (CurrentHour > 23) {
      CurrentHour -= 24;
      CurrentDay += 1;

      if (CurrentDay > CalendarLength[CurrentMonth - 1]) { 
        CurrentDay = 1;
        CurrentMonth += 1;
        
        if (CurrentMonth > 12) {
          CurrentMonth = 1;
          CurrentYear += 1;
        }
      }
    }
  }  

  int[] return_array = {CurrentYear, CurrentMonth, CurrentDay, CurrentHour};
  
  return return_array;
}





class solarchvision_Tropo3D {
  
  private final static String CLASS_STAMP = "Tropo3D";

  
  boolean Display_Surface = false;
  boolean Display_Texture = true;  
  
  String[] Filenames;
  PImage[] Map;
  
  float[][] BoundariesX;
  float[][] BoundariesY;
  
  
  void resize_images () {
    
    this.Filenames = new String [TROPO_timeSteps];
    this.Map = new PImage [TROPO_timeSteps];
    
    this.BoundariesX = new float[TROPO_timeSteps][2];
    this.BoundariesY = new float[TROPO_timeSteps][2];
    
    for (int i = 0; i < TROPO_timeSteps; i++) {
  
      this.Filenames[i] = "";
      this.Map[i] = createImage(2, 2, RGB); // empty and small
      
      this.BoundariesX[i][0] = 0;
      this.BoundariesX[i][1] = 0;
      this.BoundariesY[i][0] = 0;
      this.BoundariesY[i][1] = 0;
      
    }
  }
  
  
  void load_images () {
    
    String[] allFilenames = sort(SOLARCHVISION_getfiles(GEOMET_directory));
    
  
    
    int LoactationTimeZone = getLoactationTimeZone();
    
    int[] rightNow = getNow_inUTC();
    
    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];
   
    for (int i = 0; i < TROPO_timeSteps; i++) {
      
      CurrentHour += 1;
      
      if (CurrentHour > 23) {
        CurrentHour -= 24;
        CurrentDay += 1;
  
        if (CurrentDay > CalendarLength[CurrentMonth - 1]) { 
          CurrentDay = 1;
          CurrentMonth += 1;
          
          if (CurrentMonth > 12) {
            CurrentMonth = 1;
            CurrentYear += 1;
          }
        }
      }
      
      
      
      for (int q = 0; q < allFilenames.length; q++) {
        
        String[] Parts = split(allFilenames[q], '_');
        
        //if (Parts[0].equals(nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2))) {
        if (Parts[0].equals(nf((CurrentHour + LoactationTimeZone) % 24, 2))) {
          
          this.Filenames[i] = allFilenames[q];
          
          this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
          this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
          this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
          this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;
          
          println("Loading:", GEOMET_directory + "/" + this.Filenames[i]);
  
          this.Map[i] = loadImage(GEOMET_directory + "/" + this.Filenames[i]);
  
          break;        
        }
      }
  
    }
    
    WIN3D.update = true;
  }
  
  
  void download_images () {
  
    int LoactationTimeZone = getLoactationTimeZone();
    
    int[] rightNow = getNow_inUTC();
    
    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];
   
    for (int i = 0; i < TROPO_timeSteps; i++) {
      
      if (WMS_type == DataType.SATELLITE_GOES) {
        
        CurrentHour -= 1;
        
        if (CurrentHour < 0) {
          CurrentHour += 24;
          CurrentDay -= 1;
    
          if (CurrentDay < 0) { 
            
            CurrentMonth -= 1;
  
            if (CurrentMonth < 0) {
              CurrentMonth = 12;
              CurrentYear -= 1;
            }
            
            CurrentDay = CalendarLength[CurrentMonth - 1];
          }
        }
            
      }
      else {
      
        CurrentHour += 1;
        
        if (CurrentHour > 23) {
          CurrentHour -= 24;
          CurrentDay += 1;
    
          if (CurrentDay > CalendarLength[CurrentMonth - 1]) { 
            CurrentDay = 1;
            CurrentMonth += 1;
            
            if (CurrentMonth > 12) {
              CurrentMonth = 1;
              CurrentYear += 1;
            }
          }
        }
      
      }
      String the_service = "";
      
      if (WMS_type == DataType.SATELLITE_GOES) {
        the_service = "http://mesonet.agron.iastate.edu/cgi-bin/wms/goes/east_vis.cgi";
      }
      else {
        the_service = "http://geo.weather.gc.ca/geomet/";
      } 
  
  
      String the_link = the_service + "?SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&FORMAT=image%2Fpng&TRANSPARENT=true";
      
      
      String ParameterStamp = ""; 
  
      if (WMS_type == DataType.SATELLITE_GOES) {
        ParameterStamp = ""; 
      }
      else {
        ParameterStamp = "_NT&STYLES=CLOUD"; // Cloud cover
        //ParameterStamp = "_GZ&STYLES=DEFAULT"; // Geopotential height (Value range mapping)
        //ParameterStamp = "_UU&STYLES=WINDSPEED"; // Windspeed in knots
        //ParameterStamp = "_UU&STYLES=WINDSPEEDKMH"; // Windspeed in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROWKMH"; // Wind arrows in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROW"; // Wind arrows in knots
        //ParameterStamp = "_TT&STYLES=TEMPERATURE"; // Air temperature
        //ParameterStamp = "_TT&STYLES=TEMPSUMMER"; // Air temperaturesummer range
        //ParameterStamp = "_TT&STYLES=TEMPWINTER"; // Air temperaturewinter range
        //ParameterStamp = "_ES&STYLES=DEWPOINTDEP"; // Dew point depression
        //ParameterStamp = "_P0&STYLES=PRESSURE"; // Surface pressure
        //ParameterStamp = "_PN&STYLES=PRESSURE4_LINE"; // Sea level pressure contour 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURE4"; // Sea level pressure 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURESEAHIGH"; // Sea level pressure high range
        //ParameterStamp = "_PN&STYLES=PRESSURESEALOW"; // Sea level pressure low range
        //ParameterStamp = "_PR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_PR&STYLES=CAPA24"; // Precipitations in millimeters (CaPA24)
        //ParameterStamp = "_RT&STYLES=PRECIPRTMMH"; // Rate of precipitations in millimeters per hour
        //ParameterStamp = "_RN&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_FR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_SN&STYLES=PRECIPSNOW"; // Precipitations in centimeters
        //ParameterStamp = "_I0&STYLES=TEMPSOIL"; // Soil Temperature
        //ParameterStamp = "_I1&STYLES=WATERCONTENT"; // Water content
        //ParameterStamp = "_I2&STYLES=ICECONTENT"; // Soil volumetric ice content
        //ParameterStamp = "_I3&STYLES=WATERRETAINED"; // Water retained on the vegetation 
        //ParameterStamp = "_I4&STYLES=WATERRETAINED"; // Water retained in the snow pack
        //ParameterStamp = "_I5&STYLES=SNOWMASS"; // Snow mass
        //ParameterStamp = "_I8&STYLES=ICETHICK"; // Sea ice thickness
        
        //ParameterStamp = "_WGE&STYLES=MS2KTSGUST"; // Windgust estimate intervals in knots
        //ParameterStamp = "_WGE&STYLES=MS2KTS"; // Windspeed estimate in knots
        //ParameterStamp = "_WGE&STYLES=MS2KMH"; // Windspeed estimate in km/h
        
        //ParameterStamp = "_WGN&STYLES=MS2KTSGUST"; // Windgust minimum intervals in knots
        //ParameterStamp = "_WGN&STYLES=MS2KTS"; // Windspeed minimum in knots
        //ParameterStamp = "_WGN&STYLES=MS2KMH"; // Windspeed minimum in km/h
        
        //ParameterStamp = "_WGX&STYLES=MS2KTSGUST"; // Windgust maximum intervals in knots
        //ParameterStamp = "_WGX&STYLES=MS2KTS"; // Windspeed maximum in knots
        //ParameterStamp = "_WGX&STYLES=MS2KMH"; // Windspeed maximum in km/h
      }
      
     
      
      String DomainStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        DomainStamp = "east_vis_1km";
      }
      else if (WMS_type == DataType.FORECAST_HRDPS) {
        DomainStamp = "HRDPS.CONTINENTAL";
      }
      else if (WMS_type == DataType.FORECAST_RDPS) {
        DomainStamp = "RDPS.ETA";
      } 
      else if (WMS_type == DataType.FORECAST_GDPS) {
        DomainStamp = "GDPS.ETA";
      }
      
      this.BoundariesX[i][0] = STATION.getLongitude() - 15;
      this.BoundariesX[i][1] = STATION.getLongitude() + 15;
      this.BoundariesY[i][0] = STATION.getLatitude() - 15 * cos_ang(STATION.getLatitude());
      this.BoundariesY[i][1] = STATION.getLatitude() + 15 * cos_ang(STATION.getLatitude());
  
      
      
      int RES1 = 1200; // 1800;
      int RES2 = 600; // 900;
   
  
      the_link += "&LAYERS=" + DomainStamp + ParameterStamp + "&WIDTH=" + nf(RES1, 0) + "&HEIGHT=" + nf(RES2, 0);
      the_link += "&SRS=EPSG%3A4326&BBOX=";
      the_link += nf(this.BoundariesX[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesX[i][1], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][1], 0, 3);
      
      int the_hour = i * TROPO_deltaTime; 
  
      String timeStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        timeStamp = "&date=" + nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "&time=" + nf(CurrentHour, 2) + ":00";
      }
      else {
        timeStamp = nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "T" + nf(CurrentHour, 2);
      }
      
      //the_link += "%26time%3D" + timeStamp +"%3A22%3A00Z";
      the_link += "%26time%3D" + timeStamp +"%3A00Z";
      
      this.Map[i] = createImage(2, 2, RGB); // empty and small
      
      //String FN = nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2) + "_";
      String FN = nf((CurrentHour + LoactationTimeZone) % 24, 2) + "_";
      FN += nf(int(roundTo(-1000 * this.BoundariesX[i][0], 1)), 6) + "_";
      FN += nf(int(roundTo( 1000 * this.BoundariesY[i][0], 1)), 6) + "_";
      FN += nf(int(roundTo(-1000 * this.BoundariesX[i][1], 1)), 6) + "_";
      FN += nf(int(roundTo( 1000 * this.BoundariesY[i][1], 1)), 6) + "_";
      FN += ".png";
  
      String the_target = GEOMET_directory + "/" + FN;
  
      File dir = new File(the_target);
      if (!dir.isFile()) {
        
        boolean new_file_downloaded = false;
  
        println("Try downloading: " + the_link);
  
        try {
          saveBytes(the_target, loadBytes(the_link));
          
          new_file_downloaded = true;
        }
        
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
       
        if (new_file_downloaded) {
          
          if (ParameterStamp.equals("_NT&STYLES=CLOUD")) {
            println("image processing cloud layer");
            
            PImage img = loadImage(the_target);
            img.loadPixels();        
                
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
            
              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              
              float COL_A = (COL >> 24 & 0xFF);
              
              if (COL_A == 0) {
                img.pixels[np] = color(0,0);
              }
              else {
                float COL_V = (COL >> 16 & 0xFF);
                img.pixels[np] = color(255 - 0.125 * COL_V, COL_V);
              }        
            }
            img.updatePixels();
            img.save(the_target);
          }
  
  
  
  
          if (WMS_type == DataType.SATELLITE_GOES) {
            println("image processing cloud layer");
  
            PImage img = loadImage(the_target);
            
            img.loadPixels();        
                
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
            
              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              
              float COL_V = (COL >> 16 & 0xFF);
              
              float N = 3; //3.5; //4; 
              
              if (COL_V < 255 / N) {
                img.pixels[np] = color(191,191,255,255); //color(0,0);
              }
              else {
                img.pixels[np] = color((255 - COL_V) * N / (N - 1), 255);
              }
            }
            img.updatePixels();
            img.save(the_target);
          }
          
        }      
  
      }
    }
  
    Tropo3D.load_images();
  }  
    
  
  
  
  
  
  void draw (int target_window, int start_hour, int end_hour) {
    
    ///////////////////////////////// for now we only use the first image
    end_hour = start_hour;
    /////////////////////////////////
  
  
    boolean proceed = true;
  
    if ((Display_Surface == false) || (Display_Texture == false)) {
      proceed = false;
    }
  
    if (target_window == TypeWindow.STUDY) {  
      proceed = false;
    }
  
    if (proceed) {    
  
      for (int n_Map = start_hour; n_Map <= end_hour; n_Map++) {
          
        if (this.Filenames[n_Map].equals("")) { // not to display empty images 
          } else {
          
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
            
            if (Export_MaterialLibrary) {
      
              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='TropoSphere" + nf(n_Map, 0) + "'>");
              }            
              
              if (target_window == TypeWindow.OBJ) {
              
                mtlOutput.println("newmtl TropoSphere" + nf(n_Map, 0));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
        
                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
              }
  
              if (Tropo3D.Display_Texture) {
      
                String old_Texture_path = GEOMET_directory + "/" + this.Filenames[n_Map];
      
                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
      
                String new_Texture_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
      
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
      
                if (target_window == TypeWindow.OBJ) {
      
                  //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Export_MapsSubfolder + the_filename); // diffuse map
                }
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
                }                    
                    
              }
            }
  
            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t</Appearance>");
            } 
          
            if (target_window == TypeWindow.OBJ) {
          
              if (Export_PolyToPoly == 1) {
                obj_lastGroupNumber += 1;  
                objOutput.println("g TropoSphere" + nf(n_Map, 0));
              }
        
              if (Export_MaterialLibrary) {
                objOutput.println("usemtl TropoSphere" + nf(n_Map, 0));
              }     
            }
       
          }     
            
    
          float OffsetX = this.BoundariesX[n_Map][0] + 180;
          float OffsetY = this.BoundariesY[n_Map][1] - 90;
    
          float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
          float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;
    
          float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
          float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);
    
          float delta_Alpha = -BIOSPHERE_drawResolution;
          float delta_Beta = -BIOSPHERE_drawResolution;
    
          float r = FLOAT_r_Earth + 10000;
          
          
          num_vertices_added = 0;
          
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
  
            int f = 0;
            for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
              for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
                f += 1;
      
                float[][] subFace = new float [4][7];
      
                for (int s = 0; s < 4; s++) {
      
                  float a = Alpha;
                  float b = Beta;
      
                  if ((s == 2) || (s == 3)) {
                    a += delta_Alpha;
                  }
      
                  if ((s == 1) || (s == 2)) {
                    b += delta_Beta;
                  }
      
                  float x0 = r * cos_ang(b - 90) * cos_ang(a); 
                  float y0 = r * sin_ang(b - 90) * cos_ang(a);
                  float z0 = r * sin_ang(a);
      
                  float _lon = b - CEN_lon;
                  float _lat = a - CEN_lat;
      
                  if (Tropo3D.Display_Texture) {
                    // calculating u and v
                    subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
                    subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
                  }         
      
                  // rotating to location coordinates 
                  float tb = -STATION.getLongitude();
                  float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
                  float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
                  float z1 = z0;
      
                  float ta = 90 - STATION.getLatitude();
                  float x2 = x1;
                  float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
                  float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
      
                  // move it down!
                  z2 -= FLOAT_r_Earth;
      
                  subFace[s][0] = x2;
                  subFace[s][1] = y2;
                  subFace[s][2] = z2;
                  
                  subFace[s][5] = a;
                  subFace[s][6] = b;
                }
                
                boolean UVs_OK = true;
                
                for (int s = 0; s < subFace.length; s++) {
                  if (subFace[s][3] < 0) UVs_OK = false;
                  if (subFace[s][3] > 1) UVs_OK = false;
                  if (subFace[s][4] < 0) UVs_OK = false;
                  if (subFace[s][4] > 1) UVs_OK = false;
                }
                
                if (UVs_OK) {
                
                  if (target_window == TypeWindow.WORLD) {
                    WORLD.graphics.beginShape();
                    WORLD.graphics.noStroke();
                    if (Tropo3D.Display_Texture) {
                      WORLD.graphics.texture(this.Map[n_Map]);
                    }
          
                    for (int s = 0; s < subFace.length; s++) {
                      
                      float _lat = subFace[s][5];
                      float _lon = subFace[s][6];
                      if (_lon > 180) _lon -= 360; // << important!
              
                      float x_point = WORLD.dX * (( 1 * (_lon - WORLD.oX) / 360.0) + 0.5) / WORLD.sX;
                      float y_point = WORLD.dY * ((-1 * (_lat - WORLD.oY) / 180.0) + 0.5) / WORLD.sY; 
    
                      WORLD.graphics.vertex(x_point, y_point, subFace[s][3] * this.Map[n_Map].width, subFace[s][4] * this.Map[n_Map].height);
                    }
          
                    WORLD.graphics.endShape(CLOSE);
                    
                  }
  
  
                  if (target_window == TypeWindow.HTML) {
        
                    htmlOutput.println("\t\t\t\t<shape>");
        
                    if (n_Map != -1) {   
                      htmlOutput.println("\t\t\t\t\t<Appearance USE='TropoSphere" + nf(n_Map, 0) + "'></Appearance>");
                    }      
                    
                    htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
                    
                    htmlOutput.print  (" coordIndex='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(" ");
                      }         
                      htmlOutput.print(nf(s, 0));          
                    }
                    htmlOutput.println(" -1'>");
                    
                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(",");
                      }                  
                      
                      htmlOutput.print(nf(subFace[s][0], 0, Export_PrecisionVertex) + " " + nf(subFace[s][1], 0, Export_PrecisionVertex) + " " + nf(subFace[s][2], 0, Export_PrecisionVertex));
                    }                
                    htmlOutput.println("'></Coordinate>");
                    
                  }
                
                  if (target_window == TypeWindow.WIN3D) {
                    
                    WIN3D.graphics.strokeWeight(1);
                    
                    WIN3D.graphics.beginShape();
                    WIN3D.graphics.noStroke();
                    if (Tropo3D.Display_Texture) {
                      WIN3D.graphics.texture(this.Map[n_Map]);
                    }
                  }    
                 
                  
                  for (int s = 0; s < subFace.length; s++) {
                    
                    float x = subFace[s][0];
                    float y = subFace[s][1];
                    float z = subFace[s][2];
                    float u = subFace[s][3];
                    float v = subFace[s][4];
  
                    if (u > 1) u = 1;
                    if (u < 0) u = 0;
                    if (v > 1) v = 1;
                    if (v < 0) v = 0;                     
  
  
                  
                    if (target_window == TypeWindow.WIN3D) {
  
                      WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * this.Map[n_Map].width, v * this.Map[n_Map].height);
                    }                    
                  
                    if (target_window == TypeWindow.OBJ) {
        
                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(x, y, z);
                      }
        
                      if (_turn == 2) {
  
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
        
                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }
        
                      if (_turn == 3) {
                        obj_lastVertexNumber += 1;
                        obj_lastVtextureNumber += 1;
                      }
                    }
                    
                    if (target_window == TypeWindow.HTML) {
                      
                      if (n_Map != -1) {   
                      
                        if (s == 0) {
                          htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                        }
                        if (s > 0) {
                          htmlOutput.print(",");
                        }                  
        
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                        SOLARCHVISION_HTMLprintVtexture(u, v);
                        
                        if (s == subFace.length - 1) {
                          htmlOutput.println("'></TextureCoordinate>");
                        }       
                      }              
         
                    }                  
                    
                  }
                  
                  
                  if (target_window == TypeWindow.HTML) {
        
                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                    
                    htmlOutput.println("\t\t\t\t</shape>");
        
                  }                 
                  
                  if (target_window == TypeWindow.WIN3D) {
  
                    WIN3D.graphics.endShape(CLOSE);
                  }    
   
                  if (target_window == TypeWindow.OBJ) {
      
                    String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
                    String n2_txt = nf(obj_lastVertexNumber - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber - 0, 0);
        
                    String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
        
                    if (Export_PolyToPoly == 0) {
                      if (_turn == 3) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g TropoSphere" + nf(n_Map, 0) + "_" + nf(f, 0));
                      }
                    } 
        
                    if (_turn == 3) {
                      obj_lastFaceNumber += 1;            
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (Export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }
                  }               
                }
                
              }
            }
          }
        }
      }
    }
  }
}

solarchvision_Tropo3D Tropo3D = new solarchvision_Tropo3D();



class solarchvision_Sky3D {
  
  private final static String CLASS_STAMP = "Sky3D";
  
  boolean Display_Surface = true;
  int Tessellation = 3; //3;
  float scale = 1000000; //25000; //10000; //10km:Troposphere 25km:Ozone layer 100km:Karman line.


  int Pallet_ACTIVE_CLR = 18; //-1; //7; //8;
  int Pallet_ACTIVE_DIR = 1; //-1;
  float Pallet_ACTIVE_MLT = 0.5; //1; //0.25;
  
  int Pallet_PASSIVE_CLR = 18; 
  int Pallet_PASSIVE_DIR = -1;  
  float Pallet_PASSIVE_MLT = 1; //2;

  
  void draw () {
  
    if (this.Display_Surface) {
  
      if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
  
        int PAL_TYPE = 0; 
        int PAL_DIR = 1;
        float PAL_Multiplier = 1; 
  
        if (Impact_TYPE == Impact_ACTIVE) {
          PAL_TYPE = this.Pallet_ACTIVE_CLR; 
          PAL_DIR = this.Pallet_ACTIVE_DIR;  
          PAL_Multiplier = 1.0 * this.Pallet_ACTIVE_MLT;
        }
        if (Impact_TYPE == Impact_PASSIVE) {
          PAL_TYPE = this.Pallet_PASSIVE_CLR; 
          PAL_DIR = this.Pallet_PASSIVE_DIR;  
          PAL_Multiplier = 0.05 * this.Pallet_PASSIVE_MLT;
        }             
        
        for (int f = 0; f < skyFaces.length; f++) {      
    
          int Tessellation = 0;
    
          int TotalSubNo = 1;  
          Tessellation = this.Tessellation;
          if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
    
          float[][] base_Vertices = new float [skyFaces[f].length][3];
          for (int j = 0; j < skyFaces[f].length; j++) {
            int vNo = skyFaces[f][j];
            base_Vertices[j][0] = skyVertices[vNo][0];
            base_Vertices[j][1] = skyVertices[vNo][1];
            base_Vertices[j][2] = skyVertices[vNo][2];
          }
    
          for (int n = 0; n < TotalSubNo; n++) {
    
            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
    
            for (int j = 0; j < subFace.length; j++) {
              subFace[j] = SOLARCHVISION_fn_normalize(subFace[j]);
            }
    
            WIN3D.graphics.beginShape();
    
            for (int s = 0; s < subFace.length; s++) {
    
              int s_next = (s + 1) % subFace.length;
              int s_prev = (s + subFace.length - 1) % subFace.length;
    
              float[] COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
    
              WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
    
              WIN3D.graphics.vertex(subFace[s][0] * this.scale * WIN3D.scale, -(subFace[s][1] * this.scale * WIN3D.scale), subFace[s][2] * this.scale * WIN3D.scale);
            }
    
            WIN3D.graphics.endShape(CLOSE);
          }
        }
      } else {
  
        color c = color(191, 191, 255);
  
        WIN3D.graphics.noStroke();
  
        if (WIN3D.FacesShade == SHADE.Surface_Materials) {
          WIN3D.graphics.fill(c);
          //WIN3D.graphics.noFill();
        } else {
          WIN3D.graphics.fill(c);
        }    
        
        for (int f = 0; f < skyFaces.length; f++) {
  
          WIN3D.graphics.beginShape();
    
          for (int j = 0; j < skyFaces[f].length; j++) {
            int vNo = skyFaces[f][j];
            WIN3D.graphics.vertex(skyVertices[vNo][0] * this.scale * WIN3D.scale, -(skyVertices[vNo][1] * this.scale * WIN3D.scale), skyVertices[vNo][2] * this.scale * WIN3D.scale);
          }    
    
          WIN3D.graphics.endShape(CLOSE);
        }
      }
  
    }
  }
}


solarchvision_Sky3D Sky3D = new solarchvision_Sky3D();



class solarchvision_Star3D {
  
  private final static String CLASS_STAMP = "Star3D";
  
  boolean Display_Surface = false;
  boolean Display_Texture = true;
 
  String Filename = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Sun/Sun.jpg";
  
  PImage Map;
  
  void load_images () {
    Map = loadImage(Filename);
  }
  
  void draw () {
    if (Star3D.Display_Surface) {
  
      WIN3D.graphics.strokeWeight(1);

      float OffsetX = 0; 
      float OffsetY = 0; 
    
      float ScaleX = 1; 
      float ScaleY = 1;   

      float CEN_lon = 0; 
      float CEN_lat = 0; 
  
      float delta_Alpha = -5;
      float delta_Beta = -10;
  
      float r = 696.0 * Planetary_Magnification; // * 1000000; // multiply this later
      float d = 150000.0; // * 1000000; // multiply this later 
  
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s++) {
  
            float a = Alpha;
            float b = Beta;
  
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);
  
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
  
            if (Star3D.Display_Texture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }         
  
            // rotating to location coordinates
  
            float tb = 0;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;
  
            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
  
            // scale it here!
            x2 *= 1000000.0;
            y2 *= 1000000.0;
            z2 *= 1000000.0;
  
            // move it to scale here!
            y2 += 1000000.0 * d * sin_ang(-STATION.getLatitude());      
            z2 += 1000000.0 * d * cos_ang(-STATION.getLatitude());
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }
  
          WIN3D.graphics.beginShape();
  
          WIN3D.graphics.noStroke();
  
          if (Star3D.Display_Texture) {
  
            WIN3D.graphics.texture(this.Map);
          }
  
          for (int s = 0; s < subFace.length; s++) {
  
            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, subFace[s][3] * this.Map.width, subFace[s][4] * this.Map.height);
          }
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }
}

solarchvision_Star3D Star3D = new solarchvision_Star3D();


class solarchvision_Moon3D {
  
  private final static String CLASS_STAMP = "Moon3D";
  
  boolean Display_Surface = false;
  boolean Display_Texture = true;
  
  String Filename = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Moon/Moon.jpg";

  PImage Map; 
  
  void load_images () {
    Map = loadImage(Filename);
  }  
  
  void draw () {
    if (Moon3D.Display_Surface) {
  
      WIN3D.graphics.strokeWeight(1);
  
      float OffsetX = 0; 
      float OffsetY = 0; 
  
      float ScaleX = 1; 
      float ScaleY = 1; 
  
      float CEN_lon = 0; 
      float CEN_lat = 0; 
  
      float delta_Alpha = -5;
      float delta_Beta = -10;
  
      float r = 1737000.0 * Planetary_Magnification;
      float d = 384400000.0 - FLOAT_r_Earth;
  
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s++) {
  
            float a = Alpha;
            float b = Beta;
  
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);
  
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
  
            if (Moon3D.Display_Texture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }         
  
            // rotating to location coordinates
  
  
            float tb = 0;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;
  
            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
  
            // move it up here!
            y2 += d * sin_ang(-STATION.getLatitude());      
            z2 += d * cos_ang(-STATION.getLatitude());
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }
  
          WIN3D.graphics.beginShape();
  
          WIN3D.graphics.noStroke();
  
          if (Moon3D.Display_Texture) {
  
            WIN3D.graphics.texture(this.Map);
          }
  
          for (int s = 0; s < subFace.length; s++) {
  
            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, subFace[s][3] * this.Map.width, subFace[s][4] * this.Map.height);
          }
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }
}

solarchvision_Moon3D Moon3D = new solarchvision_Moon3D();






class solarchvision_Earth3D {
  
  private final static String CLASS_STAMP = "Earth3D";
    
  boolean Display_Surface = false;
  boolean Display_Texture = true;
  
  PImage[] Map;
  
  float[][] BoundariesX;
  float[][] BoundariesY;
  
  String Path = BaseFolder + "/Input/BackgroundImages/Standard/Maps/EarthSurface";
  
  String[] Filenames = sort(SOLARCHVISION_getfiles(this.Path));
  
  
  void resize_images () {
  
    int n = this.Filenames.length;
  
    this.Map = new PImage [n];
  
    this.BoundariesX = new float [n][2];
    this.BoundariesY = new float [n][2];
    
  }
  
  
  void load_images () {
  
    for (int i = 0; i < this.Filenames.length; i++) {
  
      String MapFilename = this.Path + "/" + this.Filenames[i];
  
      String[] Parts = split(this.Filenames[i], '_');
  
      this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;
  
      println("Loading:", MapFilename);
  
      this.Map[i] = loadImage(MapFilename);
    }
  }
  
  
  
  void draw (int target_window) {
  
    boolean proceed = true;
  
    if ((Earth3D.Display_Surface == false) || (Earth3D.Display_Texture == false)) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
  
    if (proceed) {
  
      int n_Map = 0;
      if (IMPACTS_DisplayDay < this.Map.length) n_Map = IMPACTS_DisplayDay;
  
      float OffsetX = this.BoundariesX[n_Map][0] + 180;
      float OffsetY = this.BoundariesY[n_Map][1] - 90;
  
      float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
      float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;
  
      float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
      float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);
  
      float delta_Alpha = -BIOSPHERE_drawResolution;
      float delta_Beta = -BIOSPHERE_drawResolution;
  
      float r = FLOAT_r_Earth;
      
  
      if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
      
        if (Export_MaterialLibrary) {
  
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='EarthSphere" + nf(n_Map, 0) + "'>");
          }
          
          if (target_window == TypeWindow.OBJ) {
    
            mtlOutput.println("newmtl EarthSphere");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
    
          if (Earth3D.Display_Texture) {
    
            String old_Texture_path = this.Path + "/" + this.Filenames[n_Map];
    
            String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
            String new_Texture_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
    
            println("Copying texture:", old_Texture_path, ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
            if (target_window == TypeWindow.OBJ) {
    
              //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
              mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map        
              mtlOutput.println("\tmap_d " + Export_MapsSubfolder + the_filename); // diffuse map
            }
            
            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
            }                
  
          }
        }
        
        if (target_window == TypeWindow.HTML) {
          htmlOutput.println("\t\t\t\t</Appearance>");
        }              
    
        if (target_window == TypeWindow.OBJ) {
          if (Export_PolyToPoly == 1) {
            obj_lastGroupNumber += 1;  
            objOutput.println("g EarthSphere");
          }
      
          if (Export_MaterialLibrary) {
            objOutput.println("usemtl EarthSphere");
          }
        }
        
      }
  
      
      num_vertices_added = 0;
  
      int end_turn = 1;
      if (target_window == TypeWindow.OBJ) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {
  
        int f = 0;
        for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
          for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
            f += 1;
    
            float[][] subFace = new float [4][5];
    
            for (int s = 0; s < 4; s++) {
    
              float a = Alpha;
              float b = Beta;
    
              if ((s == 2) || (s == 3)) {
                a += delta_Alpha;
              }
    
              if ((s == 1) || (s == 2)) {
                b += delta_Beta;
              }
    
              float x0 = r * cos_ang(b - 90) * cos_ang(a); 
              float y0 = r * sin_ang(b - 90) * cos_ang(a);
              float z0 = r * sin_ang(a);
    
              float _lon = b - CEN_lon;
              float _lat = a - CEN_lat;
    
              if (Earth3D.Display_Texture) {
                // calculating u and v
                subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
                subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
              }         
    
              // rotating to location coordinates 
              float tb = -STATION.getLongitude();
              float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
              float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
              float z1 = z0;
    
              float ta = 90 - STATION.getLatitude();
              float x2 = x1;
              float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
              float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);
    
              // move it down!
              z2 -= FLOAT_r_Earth;
    
              subFace[s][0] = x2;
              subFace[s][1] = y2;
              subFace[s][2] = z2;
            }
    
  
            if (target_window == TypeWindow.HTML) {
  
              htmlOutput.println("\t\t\t\t<shape>");
  
              if (n_Map != -1) {   
                htmlOutput.println("\t\t\t\t\t<Appearance USE='EarthSphere" + nf(n_Map, 0) + "'></Appearance>");
              }      
              
              htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
              
              htmlOutput.print  (" coordIndex='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(" ");
                }         
                htmlOutput.print(nf(s, 0));          
              }
              htmlOutput.println(" -1'>");
              
              htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(",");
                }                  
                
                htmlOutput.print(nf(subFace[s][0], 0, Export_PrecisionVertex) + " " + nf(subFace[s][1], 0, Export_PrecisionVertex) + " " + nf(subFace[s][2], 0, Export_PrecisionVertex));
              }                
              htmlOutput.println("'></Coordinate>");
              
            }
  
            if (target_window == TypeWindow.WIN3D) {
              
              WIN3D.graphics.strokeWeight(1);
              
              WIN3D.graphics.beginShape();
      
              WIN3D.graphics.noStroke();
              
              if (Earth3D.Display_Texture) {
      
                WIN3D.graphics.texture(this.Map[n_Map]);
              }            
            }
            
            
    
            for (int s = 0; s < subFace.length; s++) {
  
              float x = subFace[s][0];
              float y = subFace[s][1];
              float z = subFace[s][2];
              float u = subFace[s][3];
              float v = subFace[s][4];
              
              if (u > 1) u = 1;
              if (u < 0) u = 0;
              if (v > 1) v = 1;
              if (v < 0) v = 0;            
    
              if (target_window == TypeWindow.WIN3D) {
        
                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * this.Map[n_Map].width, v * this.Map[n_Map].height);
              }
  
              
              if (target_window == TypeWindow.OBJ) {
                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }
    
                if (_turn == 2) {
  
                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }
    
                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }    
              }
             
              if (target_window == TypeWindow.HTML) {
                
                if (n_Map != -1) {   
                
                  if (s == 0) {
                    htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                  }
                  if (s > 0) {
                    htmlOutput.print(",");
                  }                  
  
                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                  SOLARCHVISION_HTMLprintVtexture(u, v);
                  
                  if (s == subFace.length - 1) {
                    htmlOutput.println("'></TextureCoordinate>");
                  }       
                }              
   
              }
              
            }
            
            if (target_window == TypeWindow.HTML) {
  
              htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
              
              htmlOutput.println("\t\t\t\t</shape>");
  
            }          
            
            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }
            
            if (target_window == TypeWindow.OBJ) {
              String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
              String n2_txt = nf(obj_lastVertexNumber - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber - 0, 0);
    
              String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
              String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
              String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
    
              if (Export_PolyToPoly == 0) {
                if (_turn == 3) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g EarthSphere_" + nf(f, 0));
                }
              } 
    
              if (_turn == 3) {
                obj_lastFaceNumber += 1;            
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                if (Export_BackSides) {
                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                }
              }          
            }
          }
        }
      }
    }
  }
}

solarchvision_Earth3D Earth3D = new solarchvision_Earth3D(); 



class solarchvision_Land3D {
  
  private final static String CLASS_STAMP = "Land3D";
  
  boolean Load_Mesh = true; 
  boolean Load_Textures = true;
  
  boolean Display_Surface = true; 
  boolean Display_Points = false;
  boolean Display_Textures = true;
  boolean Display_Depth = false;  
  
  float[][][] Mesh;
  
  float[] Textures_scale_U;
  float[] Textures_scale_V;
  PImage[] Textures_Map;
  String[] Textures_ImagePath;
  int Textures_num = 0;
  
  
  //Polar
  int n_I = 24;  
  int n_J = 48 + 1;  
  
  int Surface_SkipStart = 0; 
  int Surface_SkipEnd = 6; 
  
  int Tessellation = 1; //0; //2;  

  
  void update_textures () {
  
    this.Textures_scale_U = new float [0];
    this.Textures_scale_V = new float [0];
    this.Textures_Map = new PImage [0];
    this.Textures_ImagePath = new String [0];
    this.Textures_num = 0;
  
    this.Display_Textures = false;
  
    if (this.Load_Textures) {
  
      try {     
    
        String[] filenames = sort(SOLARCHVISION_getfiles(LandFolder)); // important to sort
    
        if (filenames != null) {
          for (int i = 0; i < filenames.length; i++) {
            println(filenames[i]);
    
            int _L = filenames[i].length();
            String _Extention = filenames[i].substring(_L - 4, _L);
            //println(_Extention);
            if (_Extention.toLowerCase().equals(".jpg")) {
    
              String[] Parts = split(filenames[i], '_');
    
              if (Parts[0].toUpperCase().equals("ELEV")) {
    
                if (Parts.length > 1) {
    
                  String dir = LandFolder + "/" + filenames[i];
    
                  {
                    String[] new_item = {
                      dir
                    };
    
                    this.Textures_ImagePath = (String[]) concat(this.Textures_ImagePath, new_item);
                  }
    
                  float u = float(Parts[1]);
                  float v = u;
    
                  {
                    PImage[] new_item = {
                      loadImage(dir)
                    };
    
                    this.Textures_Map = (PImage[]) concat(this.Textures_Map, new_item);
                    
                    int w = new_item[0].width;
                    int h = new_item[0].height;
                    
                    if (w < h) {
                      if (h != 0) {
                        u *= w / (1.0 * h);
                      } 
                    }
                    
                    if (w > h) {
                      if (w != 0) {
                        v *= h / (1.0 * w);
                      } 
                    }
                    
                  }
    
    
    
                  {
                    float[] new_item = {
                      u
                    };
    
                    this.Textures_scale_U = (float[]) concat(this.Textures_scale_U, new_item);
                  }  
    
                  {
                    float[] new_item = {
                      v
                    };
    
                    this.Textures_scale_V = (float[]) concat(this.Textures_scale_V, new_item);
                  }
    
                  this.Textures_num += 1;
    
    
                  this.Display_Textures = true;
                }
              }
            }
          }
        }
      }
      catch (Exception e) {
        println("ERROR loading this.Textures_Map!");
      }
    }
    
    WIN3D.update = true;
  }
  
  
  
  
  void update_mesh () {
  
    this.Mesh = new float [this.n_I][this.n_J][3];
  
    for (int i = 0; i < this.n_I; i++) {
      for (int j = 0; j < this.n_J; j++) {
        this.Mesh[i][j][0] = FLOAT_undefined;
        this.Mesh[i][j][1] = FLOAT_undefined;
        this.Mesh[i][j][2] = FLOAT_undefined;
      }
    }
  
    try { 
  
      if (this.Load_Mesh) {
        
        for (int i = 0; i < this.n_I; i++) {
  
          XML FileALL = loadXML(LandFolder + "/" + nf(i, 0) + ".xml");
  
          XML[] children0 = FileALL.getChildren("result");
  
          for (int j = 0; j < this.n_J; j++) {
  
            String txt_elevation = children0[j].getChild("elevation").getContent();
  
            XML[] children1 = children0[j].getChildren("location");
  
            String txt_latitude = children1[0].getChild("lat").getContent();
            String txt_longitude = children1[0].getChild("lng").getContent();
  
            //println(txt_longitude, txt_latitude, txt_elevation);
  
            double _lon = Double.parseDouble(txt_longitude); 
            double _lat = Double.parseDouble(txt_latitude); 
  
            float[] XY = convert_lonlat2XY(_lon, _lat);
  
            float x = XY[0];
            float y = XY[1]; 
            float z = float(txt_elevation);
  
            this.Mesh[i][j][0] = x;      
            this.Mesh[i][j][1] = y;      
            this.Mesh[i][j][2] = z;
          }
        }
  
        float h = this.Mesh[0][0][2];
  
        h += HeightAboveGround;
  
        for (int i = 0; i < this.n_I; i++) {
          for (int j = 0; j < this.n_J; j++) {
  
            this.Mesh[i][j][2] -= h;
          }
        }
        
        /*
        // this is to modify the surronding ponits and set them at the same elevation of the the central point 
        for (int j = 0; j < 2; j++) {
          if (j < this.n_J) {
            for (int i = 0; i < this.n_I; i++) {
              this.Mesh[i][j][2] = this.Mesh[0][0][2];
            }
          }
        }
        */
        
      }
    }
  
    catch (Exception e) {
      println("ERROR loading this.Mesh!");
    }
  
  
    Land3D.update_textures();
  }
  
  
  
  void flat_mesh () {
  
    this.Mesh = new float [this.n_I][this.n_J][3];
  
    for (int i = 0; i < this.n_I; i++) {
      
     
      for (int j = 0; j < this.n_J; j++) {
  
       
        double[] LON_LAT = getLandGrid(i,j);
        
        double _lon = LON_LAT[0];
        double _lat = LON_LAT[1]; 
  
        float[] XY = convert_lonlat2XY(_lon, _lat);
  
        this.Mesh[i][j][0] = XY[0];      
        this.Mesh[i][j][1] = XY[1];      
        this.Mesh[i][j][2] = 0; 
  
      }
  
    }
  
    this.Load_Mesh = true;
    Land3D.update_mesh();
  
  }
  
  
  
  void download_mesh () {
  
    this.Mesh = new float [this.n_I][this.n_J][3];
  
    for (int i = 0; i < this.n_I; i++) {
      
      String the_target = LandFolder + "/" + nf(i, 0) + ".xml";
      
      File dir = new File(the_target);
      if (!dir.isFile()) {
  
        String the_link = "";
        
        for (int j = 0; j < this.n_J; j++) {
    
          if (the_link.equals("")) the_link = "https://maps.googleapis.com/maps/api/elevation/xml?locations=";
          else the_link += "%7C"; //"|";
          
          double[] LON_LAT = getLandGrid(i,j);
  
          String txt_latitude = nf((float) LON_LAT[1], 0, 5);
          String txt_longitude = nf((float) LON_LAT[0], 0, 5);            
    
          the_link += txt_latitude + "," + txt_longitude;
        }
    
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
  
    }
    
    this.Load_Mesh = true;
    Land3D.update_mesh();
  
  }
  
  
  void download_textures () {
    
    float[] ratios = { 
      1128.497220,
      2256.994440,
      4513.988880,
      9027.977761,
      18055.95552,
      36111.91104,
      72223.82209,
      144447.6442,
      288895.2884,
      577790.5767,
      1155581.153,
      2311162.307,
      4622324.614,
      9244649.227,
      18489298.45,
      36978596.91,
      73957193.82,
      147914387.6,
      295828775.3,
      591657550.5
    };
    
    for (int i = 0; i <= 15; i++) {
  
      String the_target = LandFolder + "/ELEV_" + nf(int(0.05 * ratios[i]), 7) + "_.jpg";
      
      File dir = new File(the_target);
      if (!dir.isFile()) {    
      
        String the_link = "https://maps.googleapis.com/maps/api/staticmap?center=" + nf(STATION.getLatitude(), 0, 5) + "," + nf(STATION.getLongitude(), 0, 5) + "&zoom=" + nf(20 - i, 0) + "&size=640x640&maptype=satellite&format=jpg";
       
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }
    
    this.Load_Textures = true;
    Land3D.update_textures();
  
  }
  
  
  
  
  void draw (int target_window) {
  
    boolean proceed = true;
  
    if ((this.Display_Surface == false) || (this.Load_Mesh == false)) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {  
      proceed = true;
    }
    
    if (proceed) {
  
      int PAL_TYPE = SHADE.get_PAL_TYPE(); 
      int PAL_DIR = SHADE.get_PAL_DIR();
      float PAL_Multiplier = SHADE.get_PAL_Multiplier(); 
  
      if (Export_MaterialLibrary) {
  
        for (int n_Map = 0; n_Map < this.Textures_num; n_Map++) {
  
          if (target_window == TypeWindow.RAD) {
  
            radOutput.println("void plastic " + "LandMap" + nf(n_Map, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 0 0 0 0 0");
            
          }
  
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='LandMap" + nf(n_Map, 0) + "'>");
          }
          
          if (target_window == TypeWindow.OBJ) {
          
            mtlOutput.println("newmtl LandMap" + nf(n_Map, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
            
          }
  
  
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
  
            if (this.Display_Textures) {
              if (n_Map != -1) {
    
                String old_Texture_path = this.Textures_ImagePath[n_Map]; 
    
                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
                String new_Texture_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
    
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
    
                if (target_window == TypeWindow.OBJ) {
                    
                  //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Export_MapsSubfolder + the_filename); // diffuse map
                }
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
                }                 
    
              }
            }
          }
          
          
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t</Appearance>");
          }        
          
        }
  
      }
      
      if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {
        
        defaultMaterial = DEFAULT_CreateMaterial;
        defaultTessellation = DEFAULT_CreateTessellation;
        defaultLayer = DEFAULT_CreateLayer;
        defaultVisibility = DEFAULT_CreateVisibility;
        defaultWeight = DEFAULT_CreateWeight;
        defaultClose = DEFAULT_CreateClose;            
        
        allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        
      }
  
  
      num_vertices_added = 0;
  
      int end_turn = 1;
      if (target_window == TypeWindow.OBJ) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {
  
  
        if (target_window == TypeWindow.OBJ) {
  
          if (_turn == 3) {
            
            if (this.Display_Textures) {   
  
              obj_lastGroupNumber += 1;
              objOutput.println("g LandMap");
            
            }
          }
        }    
  
  
  
        int Tessellation = this.Tessellation;
        if (WIN3D.FacesShade == SHADE.Surface_Base) {
          Tessellation = 0;
        }
  
        if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {
          Tessellation = 0;
        }
  
        int TotalSubNo = 1;  
        if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
  
        int i_start = this.Surface_SkipStart;
        int i_end = this.n_I - 1 - this.Surface_SkipEnd;
  
        if (target_window == TypeWindow.LandGap) {
          i_start = 0;
          i_end = this.Surface_SkipStart;
          
          target_window = TypeWindow.LandMesh; // because the rest is simillar to that
        }
  
         
        for (int i = i_start; i < i_end; i++) {
          
          for (int j = 0; j < this.n_J - 1; j++) {
  
            float[][] base_Vertices = new float [4][3];
  
            base_Vertices[0][0] = this.Mesh[i][j][0];
            base_Vertices[0][1] = this.Mesh[i][j][1];
            base_Vertices[0][2] = this.Mesh[i][j][2];
  
            base_Vertices[1][0] = this.Mesh[i+1][j][0];
            base_Vertices[1][1] = this.Mesh[i+1][j][1];
            base_Vertices[1][2] = this.Mesh[i+1][j][2];
  
            base_Vertices[2][0] = this.Mesh[i+1][j+1][0];
            base_Vertices[2][1] = this.Mesh[i+1][j+1][1];
            base_Vertices[2][2] = this.Mesh[i+1][j+1][2];
  
            base_Vertices[3][0] = this.Mesh[i][j+1][0];
            base_Vertices[3][1] = this.Mesh[i][j+1][1];
            base_Vertices[3][2] = this.Mesh[i][j+1][2];        
  
            for (int n = 0; n < TotalSubNo; n++) {
  
              float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
  
              int n_Map = -1; 
              if (this.Display_Textures) { 
  
                for (int q = 0; q < this.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map
  
                  n_Map = q; 
  
                  for (int s = 0; s < subFace.length; s++) {
  
                    float u = (subFace[s][0] / this.Textures_scale_U[q] + 0.5);
                    float v = (-subFace[s][1] / this.Textures_scale_V[q] + 0.5);
  
                    //if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {
                    if ((0.05 > u) || (u > 0.95) || (0.05 > v) || (v > 0.95)) { // simply not to include the legends printed at the margin
  
                      n_Map = -1;
  
                      break;
                    }
                  }
  
                  if (n_Map == q) break;
                }
              }
              
              if (target_window == TypeWindow.SKY2D) {
                
                SKY2D_graphics.beginShape();
                SKY2D_graphics.fill(255);
                SKY2D_graphics.noStroke();
               
              }
  
              if (target_window == TypeWindow.WIN3D) {
  
                WIN3D.graphics.beginShape();
  
                WIN3D.graphics.strokeWeight(1);
                WIN3D.graphics.stroke(0, 0, 0);
                if (allModel3Ds.DisplayEdges == false) WIN3D.graphics.noStroke();
                if (this.Display_Textures) WIN3D.graphics.noStroke();
  
                if (this.Display_Textures) {
                  if (n_Map != -1) {
                    WIN3D.graphics.texture(this.Textures_Map[n_Map]);
                  } else {
                    WIN3D.graphics.noFill();   
                    WIN3D.graphics.strokeWeight(1);
                    WIN3D.graphics.stroke(0, 0, 0);
                  }
                }
              }
  
              if (target_window == TypeWindow.OBJ) {
  
                if (_turn == 3) {
  
                  if (this.Display_Textures) {
  
                    if (Export_MaterialLibrary) {
                      if (n_Map != -1) {    
                        objOutput.println("usemtl LandMap" + nf(n_Map, 0));
                      }
                    }
                  }
                }
              }    
              
              if (target_window == TypeWindow.HTML) {
  
                htmlOutput.println("\t\t\t\t<shape>");
    
                if (n_Map != -1) {   
                  htmlOutput.println("\t\t\t\t\t<Appearance USE='LandMap" + nf(n_Map, 0) + "'></Appearance>");
                }      
                
                htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
                
                htmlOutput.print  (" coordIndex='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(" ");
                  }         
                  htmlOutput.print(nf(s, 0));          
                }
                htmlOutput.println(" -1'>");
                
                htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(",");
                  }                  
                  
                  htmlOutput.print(nf(subFace[s][0], 0, Export_PrecisionVertex) + " " + nf(subFace[s][1], 0, Export_PrecisionVertex) + " " + nf(subFace[s][2], 0, Export_PrecisionVertex));
                }                
                htmlOutput.println("'></Coordinate>");
                
              }
              
  
              
              
              
              for (int s = 0; s < subFace.length; s++) {
                
                if (target_window == TypeWindow.SKY2D) {
                  SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
                }           
  
                if (this.Display_Textures == false) {
  
                  if (WIN3D.FacesShade != SHADE.Surface_Wire) {
  
                    float[] COL = {
                      255, 255, 255, 255
                    };
  
                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;
  
                      COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }
  
                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
  
                      COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }  
                    
                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
  
                      COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }      
        
                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
  
                      COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }   
  
                    if (WIN3D.FacesShade == SHADE.Surface_White) {
                      COL = SHADE.vertexRender_Surface_White(255);
                    }                   
  
                    if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                      //COL = SHADE.vertexRender_Surface_Materials(mt);
                      COL = SHADE.vertexRender_Surface_White(223);
                    }    
  
            
                     
  
                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    }
                  } else {
  
                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.noFill();
                    }
                  }
  
                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                  }
                  
                  if (target_window == TypeWindow.RAD) {
  
                    if (this.Display_Textures) {   
                    
                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");      
                      
                      radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));                
                      radOutput.println(" " + nf(subFace[1][0], 0, Export_PrecisionVertex) + " " + nf(subFace[1][1], 0, Export_PrecisionVertex) + " " + nf(subFace[1][2], 0, Export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));
                      
                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");      
                      
                      radOutput.println(" " + nf(subFace[2][0], 0, Export_PrecisionVertex) + " " + nf(subFace[2][1], 0, Export_PrecisionVertex) + " " + nf(subFace[2][2], 0, Export_PrecisionVertex));                
                      radOutput.println(" " + nf(subFace[3][0], 0, Export_PrecisionVertex) + " " + nf(subFace[3][1], 0, Export_PrecisionVertex) + " " + nf(subFace[3][2], 0, Export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[0][0], 0, Export_PrecisionVertex) + " " + nf(subFace[0][1], 0, Export_PrecisionVertex) + " " + nf(subFace[0][2], 0, Export_PrecisionVertex));
  
                    }
                  }
                                  
  
                  
                } else {       
                  
                  float u = 0;
                  float v = 0;
                  if (n_Map != -1) {
                    u = (subFace[s][0] / this.Textures_scale_U[n_Map] + 0.5);
                    v = (-subFace[s][1] / this.Textures_scale_V[n_Map] + 0.5);
                  }
  
                  if (target_window == TypeWindow.WIN3D) {
                    if (n_Map != -1) {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                    }
                    else {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);                    
                    }
                  }
  
                  if (target_window == TypeWindow.OBJ) {
                    
                    if (this.Display_Textures) {   
                    
                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                      }
                      if (_turn == 2) { 
    
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
    
                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }
                      if (_turn == 3) {
                        num_vertices_added += 1;
                      }
                    }
                  }
                  
                  if (target_window == TypeWindow.LandMesh) {
                    if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center
                      allModel3Ds.add_Vertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                    }
                  }
                  
                  
                  if (target_window == TypeWindow.HTML) {
                    
                    if (n_Map != -1) {   
                    
                      if (s == 0) {
                        htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                      }
                      if (s > 0) {
                        htmlOutput.print(",");
                      }                  
  
                      v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                      SOLARCHVISION_HTMLprintVtexture(u, v);
                      
                      if (s == subFace.length - 1) {
                        htmlOutput.println("'></TextureCoordinate>");
                      }       
                    }              
     
                  }                
               
                }
              }
  
  
              if (target_window == TypeWindow.HTML) {
  
                htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                
                htmlOutput.println("\t\t\t\t</shape>");
  
              }
              
  
              if (target_window == TypeWindow.SKY2D) {
                SKY2D_graphics.endShape(CLOSE);
              }
  
              if (target_window == TypeWindow.WIN3D) {
                WIN3D.graphics.endShape(CLOSE);
              }
  
              if (target_window == TypeWindow.OBJ) {
  
                if (_turn == 3) {
                  
                  if (this.Display_Textures) {   
  
                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
    
                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
    
                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
                    if (Export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }
              }
              
              if (target_window == TypeWindow.LandMesh) {
                if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center 
                  int[] newFace = new int[4];
                  newFace[0] = allVertices.length - 4;
                  newFace[1] = allVertices.length - 3;
                  newFace[2] = allVertices.length - 2;
                  newFace[3] = allVertices.length - 1;
                  allModel3Ds.add_Face(newFace);
                }
              }
              
  
  
              if (this.Display_Textures) {
  
                if (this.Display_Depth) {
  
  
                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.fill(223, 223, 223);
                    WIN3D.graphics.noStroke();
                  }
  
                  for (int s = 0; s < subFace.length; s++) {
  
                    int s_next = (s + 1) % subFace.length;
                    
                    float u = 0;
                    float v = 0;
                    if (n_Map != -1) {
                      u = (subFace[s][0] / this.Textures_scale_U[n_Map] + 0.5);
                      v = (-subFace[s][1] / this.Textures_scale_V[n_Map] + 0.5);
                    }
  
                    float u_next = (subFace[s_next][0] / this.Textures_scale_U[n_Map] + 0.5);
                    float v_next = (-subFace[s_next][1] / this.Textures_scale_V[n_Map] + 0.5);
  
                    if (target_window == TypeWindow.WIN3D) {
  
                      WIN3D.graphics.beginShape();
                      
                      if (n_Map != -1) {
                        WIN3D.graphics.texture(this.Textures_Map[n_Map]);                  
    
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_Map[n_Map].width, v_next * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_Map[n_Map].width, v_next * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                      }
                      else {
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                      }
  
                      WIN3D.graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }
          }
          
          
          
          if (target_window == TypeWindow.LandMesh) {
            // This is to create a polygon around the center
            if (i == 0) {
              
              int[] newFace = new int[this.n_J - 1];
              for (int j = 0; j < newFace.length; j++) {
                newFace[j] = allModel3Ds.add_Vertex(this.Mesh[i + 1][j][0], this.Mesh[i + 1][j][1], this.Mesh[i + 1][j][2]);
              }
              allModel3Ds.add_Face(newFace);
            }
          }
        }
      }
  
      if (target_window == TypeWindow.OBJ) {
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }    
  
      if (target_window == TypeWindow.WIN3D) {
        if (this.Display_Points) {
  
          WIN3D.graphics.fill(191, 191, 0); 
          WIN3D.graphics.noStroke();
  
          WIN3D.graphics.sphereDetail(6, 4);
  
          for (int i = 0; i < this.n_I; i++) {
            for (int j = 0; j < this.n_J; j++) {
  
              float x = this.Mesh[i][j][0];
              float y = this.Mesh[i][j][1];
              float z = this.Mesh[i][j][2];
  
              float R = 2.0 * OBJECTS_scale; // <<<<<<<<<<
  
              WIN3D.graphics.pushMatrix();
              WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
              WIN3D.graphics.sphere(R);
              WIN3D.graphics.popMatrix();
            }
          }
        }
      }
      
      if (target_window == TypeWindow.LandMesh) {
        selectedGroup_ids = new int [1];
        selectedGroup_ids[0] = allGroups.num - 1;
        
        allModel3Ds.weldObjectsVertices_Selection(0);
        
      }    
      
    }
  }
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP + ".Mesh");
    
    XML parent = xml.addChild(this.CLASS_STAMP + ".Mesh");
    int vNo = 0;
    for (int i = 0; i < this.Mesh.length; i++) {
      for (int j = 0; j < this.Mesh[i].length; j++) {
        XML child = parent.addChild("Vertice");
        child.setInt("id", vNo);
        String lineSTR = "";
        //for (int k = 0; k < this.Mesh[i][j].length; k++) {
        for (int k = 0; k < 3; k++) { // x, y, z 
          lineSTR += nf(this.Mesh[i][j][k], 0, 4).replace(",", "."); // <<<<
          if (k < this.Mesh[i][j].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
        vNo += 1;
      }
    }  
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP + ".Mesh");
    
    this.Mesh = new float [this.n_I][this.n_J][3];
    XML parent = xml.getChild(this.CLASS_STAMP + ".Mesh");
    XML[] children = parent.getChildren("Vertice");         
    for (int i = 0; i < this.n_I * this.n_J; i++) {
      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < parts.length; j++) {
        this.Mesh[(i / this.n_J)][(i % this.n_J)][j] = float(parts[j]);
      }
    }
  }    
  
  
}

solarchvision_Land3D Land3D = new solarchvision_Land3D();





class solarchvision_Model2Ds {
  
  private final static String CLASS_STAMP = "Model2Ds";

  float[][] XYZS = new float[0][4];
  
  float getX (int n) {
    return this.XYZS[n][0]; 
  }

  float getY (int n) {
    return this.XYZS[n][1]; 
  }

  float getZ (int n) {
    return this.XYZS[n][2]; 
  }

  float getS (int n) {
    return this.XYZS[n][3]; 
  }

  void setX (int n, float x) {
    this.XYZS[n][0] = x;  
  }

  void setY (int n, float y) {
    this.XYZS[n][1] = y;  
  }

  void setZ (int n, float z) {
    this.XYZS[n][2] = z;  
  }

  void setS (int n, float s) {
    this.XYZS[n][3] = s;  
  }  
  
  int[] MAP = new int[0];
  int num = 0; 
  
  String[] ImagePath;
  int PEOPLE_Files_Num = 0;
  int TREES_Files_Num = 0; 

  int numDisplayFaces = 3; // internal - number of faces: Vertical, Horizontal Front, Horizontal Back
 
  String[] Filenames_PEOPLE;
  String[] Filenames_TREES; 
 
  PImage[] Images;
  float[] ImageRatios;
  
  float[][] Vertices;
  int[][] Faces;  
  
  void load_images () {
  
    this.ImagePath = new String [1];
    this.ImagePath[0] = "";
  
    this.Filenames_PEOPLE = sort(SOLARCHVISION_getfiles(allModel2DsFolder_PEOPLE));
    this.Filenames_TREES = sort(SOLARCHVISION_getfiles(allModel2DsFolder_TREES));  
  
    this.ImagePath = concat(this.ImagePath, this.Filenames_PEOPLE);
    this.ImagePath = concat(this.ImagePath, this.Filenames_TREES);
  
    this.PEOPLE_Files_Num = this.Filenames_PEOPLE.length;
    this.TREES_Files_Num = this.Filenames_TREES.length;
  
  
    int n = this.ImagePath.length;
  
    this.Images = new PImage [n + 1];
    this.ImageRatios = new float [n + 1];
  
    for (int i = 1; i < n; i++) { // leaving [0] null  
  
      if (i <= this.PEOPLE_Files_Num) {
        this.ImagePath[i] = allModel2DsFolder_PEOPLE + "/" + this.ImagePath[i];
      } else {
        this.ImagePath[i] = allModel2DsFolder_TREES + "/" + this.ImagePath[i];
      }
    }
  
    for (int i = 1; i < n; i++) {
      //println(this.ImagePath[i]);
      this.Images[i] = loadImage(this.ImagePath[i]);
  
      if (this.Images[i].height != 0) {
        this.ImageRatios[i] = float(this.Images[i].width) / float(this.Images[i].height);
      } else {
        this.ImageRatios[i] = 1;
      }
    }
  } 
  
  
  void draw (int target_window) {
  
    this.Faces = new int [this.num * this.numDisplayFaces][4];
  
    this.Vertices = new float [4 * this.num * this.numDisplayFaces][5]; // note we are keeping u & v at 3rd and 4th members
    
    
    boolean proceed = true;
  
    if (Display_allModel2Ds == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if (proceed) {  
  
      if (Export_MaterialLibrary) {
      
        if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {  
    
          int[] ImageUsed = new int [this.ImagePath.length];
    
          for (int i = 0; i < ImageUsed.length; i++) {
            ImageUsed[i] = 0;
          }
    
          for (int f = 0; f < this.num; f++) {
    
            int n = abs(this.MAP[f]);
    
            ImageUsed[n] += 1;
          }
    
          for (int i = 1; i < this.ImagePath.length; i++) {
    
            if (ImageUsed[i] != 0) {
    
              String old_Texture_path = this.ImagePath[i];
    
              String new_Texture_path = "";
    
              String opacity_Texture_path = "";
    
              String the_filename = "";
    
              if (this.ImagePath[i].equals("")) {
              } else {
    
                the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
                new_Texture_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
                opacity_Texture_path = allModel3DsFolder + "/" + Export_MapsSubfolder + "opacity_" + the_filename;
    
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
                println("Making opacity texture:", new_Texture_path);
    
                int RES1 = this.Images[i].width;
                int RES2 = this.Images[i].height;
    
                PImage Opacity_Texture = createImage(RES1, RES2, ARGB);
    
                Opacity_Texture.loadPixels();
    
                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;
    
                  color COL = this.Images[i].get(Image_X, Image_Y);
                  //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
    
                  float COL_V = (COL >> 24 & 0xFF);
    
                  Opacity_Texture.pixels[np] = color(COL_V, COL_V, COL_V, COL_V);
                }
    
                Opacity_Texture.updatePixels();
    
                Opacity_Texture.save(opacity_Texture_path);
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t<Appearance DEF='this." + the_filename + "'>");
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
                  htmlOutput.println("\t\t\t\t</Appearance>");
                }
    
                if (target_window == TypeWindow.OBJ) { 
      
                  mtlOutput.println("newmtl " + "this." + the_filename);
                  mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                  mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                  mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                  mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                  mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                  mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
                  mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                  mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                  mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      
                  //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Export_MapsSubfolder + "opacity_" + the_filename); // diffuse map
                }
              }
            }
          }
        }    
      }
      
      
      
      
  
      float[] DistZ = new float [this.num];
  
      for (int f = 0; f < this.num; f++) {
        float x = this.XYZS[f][0] * OBJECTS_scale;
        float y = this.XYZS[f][1] * OBJECTS_scale;
        float z = this.XYZS[f][2] * OBJECTS_scale;
  
        DistZ[f] = dist(x, y, z, WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z);
      }
  
      for (int g = 0; g < this.num; g++) {
  
        int f = -1;
        float max_dist = -1;
  
        for (int q = 0; q < this.num; q++) {
          if (max_dist < DistZ[q]) {
            max_dist = DistZ[q];
            f = q;
          }
        }
  
        DistZ[f] = -1;
  
  
  
        if (f != -1) {
          
          int n = abs(this.MAP[f]);
  
          int w = this.Images[n].width; 
          int h = this.Images[n].height;
  
          float x = this.XYZS[f][0] * OBJECTS_scale;
          float y = this.XYZS[f][1] * OBJECTS_scale;
          float z = this.XYZS[f][2] * OBJECTS_scale;
  
          float rh = this.XYZS[f][3] * 0.5 * OBJECTS_scale;
          float rw = rh * this.ImageRatios[n];
  
          float t = PI + WIN3D.RZ_Coordinate * PI / 180.0;
          if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI;
         
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
            t = 0;
          }     
  
          if (this.MAP[f] < 0) t += PI;     
      
  
          float dx = rw * cos(t);
          float dy = rw * sin(t);
          
          float x1 = x - dx;
          float y1 = y - dy;
  
          float x2 = x + dx;
          float y2 = y + dy;
  
          if (target_window == TypeWindow.OBJ) { 
  
            if (Export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;  
              objOutput.println("g this." + nf(f, 0) + "_type" + nf(n, 0));
            }
      
            if (Export_MaterialLibrary) {
              objOutput.println("usemtl this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1).replace('.', '_'));
            }
          }
    
          num_vertices_added = 0;
    
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
            
            for (int back_front = -1; back_front <= 1; back_front++) {
              
              if (back_front == 0) {
                
                if (target_window == TypeWindow.WIN3D) { 
    
                  WIN3D.graphics.beginShape();
          
                  WIN3D.graphics.texture(this.Images[n]);    
                  WIN3D.graphics.stroke(255, 255, 255, 0);
                  WIN3D.graphics.fill(255, 255, 255, 0);        
          
                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, z * WIN3D.scale, 0, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, z * WIN3D.scale, w, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, w, 0);
                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, 0, 0);
          
                  WIN3D.graphics.endShape(CLOSE);        
                }
                
                if (target_window == TypeWindow.OBJ) { 
                  if (_turn == 1) {
    
                    SOLARCHVISION_OBJprintVertex(x1, y1, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh));
                    SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh));
        
                    num_vertices_added += 4;
                  }              
                  
                  if (_turn == 2) {
                    htmlOutput.println("\t\t\t\t\t\t<TextureCoordinate point='1 0,0 0,0 1,1 1'></TextureCoordinate>");
                  }     
                  
                  if (_turn == 3) {
                    obj_lastVertexNumber += num_vertices_added;
                    obj_lastVtextureNumber += num_vertices_added;
        
                    String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 1, 0); 
                    String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 3, 0);
                    String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4, 0);
        
                    String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 1, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 3, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4, 0);      
        
                    if (Export_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g this." + nf(f, 0) + "_ver");
                    } 
        
                    obj_lastFaceNumber += 1;            
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    if (Export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }         
                }   
            
            
                if (target_window == TypeWindow.HTML) {
                  
                  htmlOutput.println("\t\t\t\t<shape>");
        
                  htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");
        
                  htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
                  
                  htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                  htmlOutput.print  (      nf(x1, 0, Export_PrecisionVertex) + " " + nf(y1, 0, Export_PrecisionVertex) + " " + nf(z, 0, Export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, Export_PrecisionVertex) + " " + nf(y2, 0, Export_PrecisionVertex) + " " + nf(z, 0, Export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, Export_PrecisionVertex) + " " + nf(y2, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, Export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x1, 0, Export_PrecisionVertex) + " " + nf(y1, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, Export_PrecisionVertex));
                  htmlOutput.println("'></Coordinate>");          
                  
                  htmlOutput.println("\t\t\t\t\t\t<TextureCoordinate point='1 0,0 0,0 1,1 1'></TextureCoordinate>");
          
                  htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                 
                  htmlOutput.println("\t\t\t\t</shape>");          
                }              
    
                int nv = f * this.numDisplayFaces * 4;
                int nf = f * this.numDisplayFaces;
                
                this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 0][3] = 0;
                this.Vertices[nv + 0][4] = 1;
      
                this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 1][3] = 1;
                this.Vertices[nv + 1][4] = 1;
      
                this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 2][3] = 1;
                this.Vertices[nv + 2][4] = 0;
      
                this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 3][3] = 0;
                this.Vertices[nv + 3][4] = 0;
      
                this.Faces[nf][0] = nv + 0;
                this.Faces[nf][1] = nv + 1;
                this.Faces[nf][2] = nv + 2;
                this.Faces[nf][3] = nv + 3;
              }     
              else {
                
                int nv = f * this.numDisplayFaces * 4;
                int nf = f * this.numDisplayFaces;  
                
                if (back_front == -1) {
                  nv += 4;
                  nf += 1;
                }
                else {
                  nv += 8;
                  nf += 2;
                }            
                
                if (n > this.PEOPLE_Files_Num) { // case: trees   
    
                  float ratio = 0.5;
                  
                  float rot = back_front * PI / 2 + t;
      
                  dx = rw * cos(rot);
                  dy = rw * sin(rot);
                  
                  float x3 = x2 + dx;
                  float y3 = y2 + dy;
      
                  float x4 = x1 + dx;
                  float y4 = y1 + dy;
                  
                  if (target_window == TypeWindow.WIN3D) {
      
                    WIN3D.graphics.beginShape();
        
                    WIN3D.graphics.texture(this.Images[n]);    
                    WIN3D.graphics.stroke(255, 255, 255, 0);
                    WIN3D.graphics.fill(255, 255, 255, 0);
        
                    WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, h * ratio);
                    WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, h * ratio);
                    WIN3D.graphics.vertex(x3 * WIN3D.scale, -y3 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, 0);
                    WIN3D.graphics.vertex(x4 * WIN3D.scale, -y4 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, 0);
        
                    WIN3D.graphics.endShape(CLOSE);
                  }
                  
                  if (target_window == TypeWindow.OBJ) {
                    if (_turn == 1) {
        
                      SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x3, y3, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x4, y4, (z + 2 * rh * ratio));
        
                      num_vertices_added += 4;
                    }
        
                    if (_turn == 2) {
        
                      SOLARCHVISION_OBJprintVtexture(1, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1, 0);
                      SOLARCHVISION_OBJprintVtexture(1, 1, 0);
                    }
        
                    if (_turn == 3) {
        
                      int q = (back_front + 1) / 2;
        
                      String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
                      String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 4, 0);
        
                      String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
                      String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 4, 0);      
        
                      if (Export_PolyToPoly == 0) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g this." + nf(f, 0) + "_hor" + nf(q, 0));
                      } 
        
                      obj_lastFaceNumber += 1;            
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (Export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }                    
                  }
                  
                  if (target_window == TypeWindow.HTML) {
                    
                    htmlOutput.println("\t\t\t\t<shape>");
          
                    htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");
          
                    htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
                    
                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    htmlOutput.print  (      nf(x1, 0, Export_PrecisionVertex) + " " + nf(y1, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, Export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x2, 0, Export_PrecisionVertex) + " " + nf(y2, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, Export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x3, 0, Export_PrecisionVertex) + " " + nf(y3, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, Export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x4, 0, Export_PrecisionVertex) + " " + nf(y4, 0, Export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, Export_PrecisionVertex));
                    htmlOutput.println("'></Coordinate>");          
                    
                    htmlOutput.print ("\t\t\t\t\t\t<TextureCoordinate point='");
                    
                    SOLARCHVISION_HTMLprintVtexture(1, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(1, 1);                  
                    htmlOutput.println("'></TextureCoordinate>");
            
                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                   
                    htmlOutput.println("\t\t\t\t</shape>");          
                  }                              
    
                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = ratio;
              
                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = ratio;
              
                  this.Vertices[nv + 2][0] = x3 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y3 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;
                  
                  this.Vertices[nv + 3][0] = x4 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y4 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;      
              
                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;
                }
                else { // case: people
                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = 1;
        
                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = 1;
        
                  this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;
        
                  this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;
        
                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;              
                }
              }
            }
          }
        }
      }
    }
  }
  
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][6];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
      hitPoint[f][4] = FLOAT_undefined;
      hitPoint[f][5] = FLOAT_undefined;    
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
      
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      //boolean InPoly = false;
      float[] UV = {FLOAT_undefined, FLOAT_undefined};
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          UV = SOLARCHVISION_uvInside_Rectangle(P, A, B, C);
        }
      }
      
      float u = UV[0];
      float v = UV[1];
      
      if ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1)) {
    
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
        // converting rom face UV to image UV
        hitPoint[f][4] = (1 - u) * B[3] + u * A[3];
        hitPoint[f][5] = (1 - v) * B[4] + v * C[4];
  
      }
    }
  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
      
      int OBJ_NUM = f / this.numDisplayFaces;
  
      if (pre_dist > hitPoint[f][3]) {
        
        float u = hitPoint[f][4];
        float v = hitPoint[f][5];
  
        int n = abs(this.MAP[OBJ_NUM]);
       
        int RES1 = this.Images[n].width; 
        int RES2 = this.Images[n].height;    
     
        this.Images[n].loadPixels();
        
        if (n < 0) u = 1 - u;
        
        println("uv,n", u, v, n);
        
        int Image_X = int(u * RES1); 
        int Image_Y = int(v * RES2);
    
        color COL = this.Images[n].get(Image_X, Image_Y);
        //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
    
        float COL_V = (COL >> 24 & 0xFF);
        
        if (COL_V > 0) {
  
          pre_dist = hitPoint[f][3];
    
          return_point[0] = OBJ_NUM;
          return_point[1] = hitPoint[f][0];
          return_point[2] = hitPoint[f][1];
          return_point[3] = hitPoint[f][2];
          return_point[4] = hitPoint[f][3];
        }
      }
  
    }
  
    return return_point;
  }

  void add_onLand (int people_or_trees) {

    println("this.add_onLand");
  
    randomSeed(0);
  
    float[][] treesXYZS = {
      {
        0, 0, 0, 0
      }
    };
  
    int Tessellation = Land3D.Tessellation;
    if (WIN3D.FacesShade == SHADE.Surface_Base) {
      Tessellation = 0;
    }
  
    int TotalSubNo = 1;  
    if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
  
  
  
    if ((Land3D.Display_Textures) && (people_or_trees != 1)) { // using another algorithm for people << i.e. no image processing from green colors of the map!
  
      for (int i = Land3D.Surface_SkipStart; i < Land3D.n_I - 1 - Land3D.Surface_SkipEnd; i++) {
        for (int j = 0; j < Land3D.n_J - 1; j++) {
  
          float[][] base_Vertices = new float [4][3];
  
          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];
  
          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];
  
          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];
  
          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];
  
          for (int n = 0; n < TotalSubNo; n++) {
  
            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
  
            int n_Map = -1; 
            for (int q = 0; q < Land3D.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map
  
              n_Map = q; 
  
              for (int s = 0; s < subFace.length; s++) {
  
                float u = (subFace[s][0] / Land3D.Textures_scale_U[q] + 0.5);
                float v = (-subFace[s][1] / Land3D.Textures_scale_V[q] + 0.5);
  
                if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {
  
                  n_Map = -1;
  
                  break;
                }
              }            
  
              if (n_Map == q) break;
            }
  
            if (n_Map != -1) {
  
              int max_o = int(10000 / pow(2, Land3D.Tessellation)); // number of tries to find green points!
  
              //if (max_o > 100) max_o = 100;
  
              if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
              //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
              //if (i < 4) max_o = 0; // <<<<<<< do not create at near distances <<<<<<<<<<<<<<<
  
              for (int o = 0; o < max_o; o++) {
  
                float di = random(1);
                float dj = random(1);
  
                float x = SOLARCHVISION_Bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
                float y = SOLARCHVISION_Bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
                float z = SOLARCHVISION_Bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);
  
                float u = (x / Land3D.Textures_scale_U[n_Map] + 0.5);
                float v = (-y / Land3D.Textures_scale_V[n_Map] + 0.5);
  
                int uPixel = int(u * Land3D.Textures_Map[n_Map].width);
                int vPixel = int(v * Land3D.Textures_Map[n_Map].height);
  
                color COL = Land3D.Textures_Map[n_Map].get(uPixel, vPixel);
                //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                float r = COL >> 16 & 0xFF; 
                float g = COL >> 8 & 0xFF;
                float b = COL & 0xFF;
  
                //if ((g > r + 8) && (g > b + 16)) { // looks more green
                if ((g > r - 4) && (g > b + 16)) { // looks more green, slightly red is acceptible
  
                  if (g < 56) { // not on grass (light green) 
  
                    //if (z + STATION.getElevation() > 5) { // not in water (below see level)
  
                    //float s = 5 + random(10); 
                    float s = 5 + random(12.5);
                    //float s = 10 + random(20); // bigger trees        
  
                    int foundNearTree = 0;
  
                    for (int f = 1; f < treesXYZS.length; f++) {
  
                      float x0 = treesXYZS[f][0];
                      float y0 = treesXYZS[f][1];
                      float z0 = treesXYZS[f][2];
                      float s0 = treesXYZS[f][3];
  
                      //if (dist(x0, y0, z0, x, y, z) < 0.25 * (s0 + s)) { //avoids creating trees close to each other 
                      if (dist(x0, y0, z0, x, y, z) < 0.5 * (s0 + s)) { //avoids creating trees close to each other
                        foundNearTree = 1;
  
                        break;
                      }
                    }
  
                    if (foundNearTree == 0) {
  
                      if (people_or_trees == 2) {
                        this.add_single("TREES", 0, x, y, z, s);
                      } else {
                        allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, s, random(360), CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
                      }                  
  
  
                      float[][] newTree = {
                        {
                          x, y, z, s
                        }
                      };
                      treesXYZS = (float [][]) concat(treesXYZS, newTree);
                    }
                    //}
                  }
                }
              }
            }
          }
        }
      }
    } else {
  
      for (int i = Land3D.Surface_SkipStart; i < Land3D.n_I - 1 - Land3D.Surface_SkipEnd; i++) {
        for (int j = 0; j < Land3D.n_J - 1; j++) {
  
          float[][] base_Vertices = new float [4][3];
  
          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];
  
          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];
  
          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];
  
          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];      
  
          for (int n = 0; n < TotalSubNo; n++) {
  
            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
  
            int max_o = int((16.0 / pow(2, Land3D.Tessellation)) * pow(random(1), 8)); // i.e. maximum 3 people in each pixel for tes=2
  
  
            if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
            //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
  
            for (int o = 0; o < max_o; o++) {
  
              float di = random(1);
              float dj = random(1);
  
              float x = SOLARCHVISION_Bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
              float y = SOLARCHVISION_Bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
              float z = SOLARCHVISION_Bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);
  
              if (z + STATION.getElevation() > 0) { // i.e. above sea level 
  
                if (dist(x, y, 0, 0) > 10.0) { // i.e. No 2D at the center!
  
                  if (people_or_trees == 1) {
                    this.add_single("PEOPLE", 0, x, y, z, 2.5);
                  } else if (people_or_trees == 2) {
                    this.add_single("TREES", 0, x, y, z, 5 + random(10));
                  } else {
                    allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, 5 + random(10), random(360), CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  void add_polar (int people_or_trees, int n, float x0, float y0, float z0, float r1, float r2) {
  
    for (int i = 0; i < n; i++) {
  
      float a = random(360);
      float b = pow(random(pow(r1, 2), pow(r2, 2)), 0.5); // to make it uniform on the surface
  
      float x = x0 + b * cos_ang(a);
      float y = y0 + b * sin_ang(a);
      float z = z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, 5 + random(10), random(360), CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
      }
    }
  }
  
  void add_plane (int people_or_trees, int n, float x0, float y0, float z0, float rx, float ry, float rot) {
  
    for (int i = 0; i < n; i++) {
  
      //float a = random(-rx, rx); 
      //float b = random(-ry, ry);
  
      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);  
      float b = random(1-ry, ry-1);
  
      float x = a * cos_ang(rot) - b * sin_ang(rot);
      float y = a * sin_ang(rot) + b * cos_ang(rot);
      float z = 0;
  
      x += x0;
      y += y0;
      z += z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, 5 + random(10), random(360), CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
      }
    }
  }
  
  void add_Mesh2 (int people_or_trees, int n, float x1, float y1, float z1, float x2, float y2, float z2) {
  
    float x0 = 0.5 * (x1 + x2);
    float y0 = 0.5 * (y1 + y2);
    float z0 = 0.5 * (z1 + z2);
  
    float rx = 0.5 * abs(x2 - x1);
    float ry = 0.5 * abs(y2 - y1);
  
    for (int i = 0; i < n; i++) {
  
      //float a = random(-rx, rx); 
      //float b = random(-ry, ry);
  
      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);  
      float b = random(1-ry, ry-1);
  
      float x = x0 + a;
      float y = y0 + b;
      float z = z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, 5 + random(10), random(360), CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
      }
    }
  }  
  
  void add_single (String t, int m, float x, float y, float z, float s) {
  
    int n1 = this.PEOPLE_Files_Num;    
    int n2 = this.PEOPLE_Files_Num + this.TREES_Files_Num;
  
    int n = m;
  
    if (n == 0) {
      if (t.equals("PEOPLE")) n = int(random(1, 1 + n1));
      else if (t.equals("TREES")) n = int(random(1 + n1, 1 + n2));
    }
  
    int d = 1; 
    int r = int(random(2));
    if (r == 0) d = -1; 
  
    int[] Temp_MAP = {
      d * n
    }; 
    this.MAP = concat(this.MAP, Temp_MAP);
  
    float[][] Temp_XYZS = {
      {
        x, y, z, s
      }
    };
    this.XYZS = (float[][]) concat(this.XYZS, Temp_XYZS);
  
    this.num += 1;
  
    if (abs(n) > n1) {
  
      if (CreateInput_MeshOrSolid != 0) {
  
        float x0 = x;
        float y0 = y;
        float z0 = 0.5 * s + z;
        float r0 = 0.4 * s; // <<<<<<< approximate
  
        allModel3Ds.add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, CreateInput_MeshOrSolid);
      }
    }
  
    if (allGroups.num > 0) allGroups.allModel2Ds[allGroups.num - 1][1] = this.num - 1;
  }  
  
  void delete () {
  
    this.XYZS = new float [0][4]; 
  
    this.MAP = new int [0];
  
    this.num = 0;
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.allModel2Ds[q][0] = 0;
      allGroups.allModel2Ds[q][1] = -1;
    }  
  
    allModel3Ds.deselect_All();
  }  
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.XYZS[i].length; j++) {
      for (int j = 0; j < 4; j++) { // x, y, z, s 
        lineSTR += nf(this.XYZS[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += this.MAP[i];

      child.setContent(lineSTR);
    }  
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = parent.getInt("ni");

    this.XYZS = new float [ni][4];
    this.MAP = new int [ni];
    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {
      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 4; j++) {
        this.XYZS[i][j] = float(parts[j]);
      }
      this.MAP[i] = int(parts[4]);
    }
  }    
}

solarchvision_Model2Ds allModel2Ds = new solarchvision_Model2Ds();



class solarchvision_Model1Ds {
  
  private final static String CLASS_STAMP = "Model1Ds";

  float[][] XYZSR = new float[0][5];
  
  float getX (int n) {
    return this.XYZSR[n][0]; 
  }

  float getY (int n) {
    return this.XYZSR[n][1]; 
  }

  float getZ (int n) {
    return this.XYZSR[n][2]; 
  }

  float getS (int n) {
    return this.XYZSR[n][3]; 
  }
  
  float getR (int n) {
    return this.XYZSR[n][4]; 
  }  

  void setX (int n, float x) {
    this.XYZSR[n][0] = x;  
  }

  void setY (int n, float y) {
    this.XYZSR[n][1] = y;  
  }

  void setZ (int n, float z) {
    this.XYZSR[n][2] = z;  
  }

  void setS (int n, float s) {
    this.XYZSR[n][3] = s;  
  }  
  
  void setR (int n, float r) {
    this.XYZSR[n][4] = r;  
  }     
  
  int[] Type = new int[0];
  int[] Seed = new int[0];  
  int[] DegreeMin = new int[0];
  int[] DegreeMax = new int[0];
  
  int getType (int n) {
    return this.Type[n]; 
  }  

  void setType (int n, int t) {
    this.Type[n] = t;  
  }  
  
  int getSeed (int n) {
    return this.Seed[n]; 
  }  

  void setSeed (int n, int t) {
    this.Seed[n] = t;  
  }    
  
  int getDegreeMin (int n) {
    return this.DegreeMin[n]; 
  }  

  void setDegreeMin (int n, int t) {
    this.DegreeMin[n] = t;  
  }    
  
  int getDegreeMax (int n) {
    return this.DegreeMax[n]; 
  }  

  void setDegreeMax (int n, int t) {
    this.DegreeMax[n] = t;  
  }  


  float[] TrunkSize = new float[0];
  float[] LeafSize = new float[0];

  float getTrunkSize (int n) {
    return this.TrunkSize[n]; 
  }  

  void setTrunkSize (int n, float t) {
    this.TrunkSize[n] = t;  
  }  
  
  float getLeafSize (int n) {
    return this.LeafSize[n]; 
  }  

  void setLeafSize (int n, float t) {
    this.LeafSize[n] = t;  
  }   
  
  
  int num = 0; 
  
  
  float[][] Vertices;
  int[][] Faces;
  
  
  void draw () {
  
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
    if (Display_allModel1Ds) {
  
      for (int f = 0; f < this.num; f++) {
  
        float x = this.XYZSR[f][0];
        float y = this.XYZSR[f][1];
        float z = this.XYZSR[f][2];
  
        float r = this.XYZSR[f][3] * 0.5;
        float rot = this.XYZSR[f][4];
  
        int n = this.Type[f];
  
        int dMin = this.DegreeMin[f];
  
        int dMax = this.DegreeMax[f];
  
        int s = this.Seed[f];
  
        float TrunkSize = this.TrunkSize[f];
  
        float LeafSize = this.LeafSize[f];
  
        randomSeed(s);
  
        if (n == 0) {
  
          float Alpha = 0;
          float Beta = rot; 
  
          this.branch_main(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);
  
          // ----------------
          x *= OBJECTS_scale;
          y *= OBJECTS_scale;
          z *= OBJECTS_scale;
          r *= OBJECTS_scale;
          // ----------------        
  
          float t = PI + WIN3D.RZ_Coordinate * PI / 180.0;
          if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI; 
  
  
          this.Vertices[f * 4 + 0][0] = (x - r * cos(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 0][1] = (y - r * sin(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 0][2] = (z) / OBJECTS_scale;
  
          this.Vertices[f * 4 + 1][0] = (x + r * cos(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 1][1] = (y + r * sin(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 1][2] = (z) / OBJECTS_scale;
  
          this.Vertices[f * 4 + 2][0] = (x + r * cos(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 2][1] = (y + r * sin(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 2][2] = (z + 2 * r) / OBJECTS_scale;
  
          this.Vertices[f * 4 + 3][0] = (x - r * cos(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 3][1] = (y - r * sin(t)) / OBJECTS_scale;
          this.Vertices[f * 4 + 3][2] = (z + 2 * r) / OBJECTS_scale;
  
          this.Faces[f][0] = f * 4 + 0;
          this.Faces[f][1] = f * 4 + 1;
          this.Faces[f][2] = f * 4 + 2;
          this.Faces[f][3] = f * 4 + 3;
  
        }
      }
    }
  }
  
  
  
  
  void branch_export (int _turn, float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        //float[] COL = {255, 100 - 6 * w, 50 - 3 * w, 0};
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (Display_allModel1Ds) {
          int nSeg = 6; 
          for (int q = 0; q < nSeg; q++) {
  
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
  
              float x = Trunk_x_new;
              float y = Trunk_y_new;
              float z = Trunk_z_new;
              float u = the_U;
              float v = the_V;
  
              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
              if (_turn == 1) {
  
                SOLARCHVISION_OBJprintVertex(x, y, z);
              }
  
              if (_turn == 2) {
  
                SOLARCHVISION_OBJprintVtexture(u, v, 0);
              }
            }
  
            if (_turn == 3) {
  
              num_vertices_added += 4;
  
              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
  
              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);               
  
              if (Export_PolyToPoly == 0) {
                obj_lastGroupNumber += 1;
                objOutput.println(("g allModel1Ds_Trunk_n" + nf(q, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
              }
  
              if (Export_MaterialLibrary) {
                objOutput.println("usemtl allModel1Ds_Trunk");
              }
  
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            }
          }
        }
  
        this.branch_export(_turn, x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (Display_Leaves) {
  
        float LeafVertices[][] = {
          {
            0, 0, 0
          }
          , {
            1, 0, 1
          }
          , {
            0, 1, 1
          }
          , {
            -1, 0, 1
          }
          , {
            0, -1, 1
          }
          , {
            0, 0, 2
          }
        };
        int LeafFaces[][] = {
          {
            0, 1, 2, 5
          }
          , {
            0, 2, 3, 5
          }
          , {
            0, 3, 4, 5
          }
          , {
            0, 4, 1, 5
          }
        };
  
        for (int i = 0; i < 4; i++) { // 4: LeafFaces.length
          for (int j = 0; j < 4; j++) { // 4: LeafFaces[i].length
  
            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;
  
            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;
  
  
            float Leaf_x_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][0];
            float Leaf_y_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][1];
            float Leaf_z_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][2];
  
            float Leaf_x_rot = Leaf_z_dif * sin(rotZX) +  Leaf_x_dif * cos(rotZX);
            float Leaf_y_rot = Leaf_y_dif;
            float Leaf_z_rot = Leaf_z_dif * cos(rotZX) - Leaf_x_dif * sin(rotZX);
  
            float Leaf_x_new = x0 + Leaf_x_rot * cos(rotXY) - Leaf_y_rot * sin(rotXY);
            float Leaf_y_new = y0 + Leaf_x_rot * sin(rotXY) + Leaf_y_rot * cos(rotXY);
            float Leaf_z_new = z0 + Leaf_z_rot; 
  
            float x = Leaf_x_new;
            float y = Leaf_y_new;
            float z = Leaf_z_new;
            float u = the_U;
            float v = the_V;
  
            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
            if (_turn == 1) {
  
              SOLARCHVISION_OBJprintVertex(x, y, z);
            }
  
            if (_turn == 2) {
  
              SOLARCHVISION_OBJprintVtexture(u, v, 0);
            }
          }
  
  
          if (_turn == 3) {  
  
            num_vertices_added += 4;
  
            String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
  
            String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);        
  
            if (Export_PolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println(("g allModel1Ds_Leaf_n" + nf(i, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
            }
  
            if (Export_MaterialLibrary) {
              objOutput.println("usemtl allModel1Ds_Leaf");
            }
  
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
            if (Export_BackSides) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
          }
        }
      }
    }
  }
  
  
  
  
  float getRatio_Plant_branch (float d) {
    return (0.75 / pow(d, 0.06125));
  }
  
  void branch_main (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        float[] COL = {
          255, 100 - 6 * w, 50 - 3 * w, 0
        };
  
        WIN3D.graphics.strokeWeight(1);
  
        if (allModel3Ds.DisplayEdges == false) {
          WIN3D.graphics.noStroke();
        } else {
          WIN3D.graphics.stroke(0);
        }
  
        WIN3D.graphics.fill(COL[1], COL[2], COL[3]);
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (Display_allModel1Ds) {
          int nSeg = 6; 
          for (int q = 0; q < nSeg; q++) {
            WIN3D.graphics.beginShape();
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
              WIN3D.graphics.vertex(Trunk_x_new * OBJECTS_scale * WIN3D.scale, -Trunk_y_new * OBJECTS_scale * WIN3D.scale, Trunk_z_new * OBJECTS_scale * WIN3D.scale);
            }
            WIN3D.graphics.endShape(CLOSE);
          }
        }
  
        this.branch_main(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (Display_Leaves) {
  
        WIN3D.graphics.strokeWeight(0);
  
        float[] COL = {
          127, 2 * c, 191 - c, 0
        };  // opaque!
  
        WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
        WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
        WIN3D.graphics.pushMatrix(); 
        WIN3D.graphics.translate(x0 * OBJECTS_scale * WIN3D.scale, -y0 * OBJECTS_scale * WIN3D.scale, z0 * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.sphere(0.5 * LeafSize * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.popMatrix();
      }
    }
  }
  
  
  void branch_addallSolids (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
  
  
  
        float cx = 0.5 * (x0 + x_new); 
        float cy = 0.5 * (y0 + y_new); 
        float cz = 0.5 * (z0 + z_new);
  
        float the_thickness = 0.025 * w * h;
        float rx = 0.5 * the_thickness;
        float ry = 0.5 * the_thickness;
        //float rz = 0.5 * abs(z_new - z0);
        float rz = 0.5 * abs(z_new - z0) * 1.25; // <<<<<<< to somehow compensate the shrinkage!
  
        allModel3Ds.add_Solid(cx, cy, cz, 2, 2, 2, rx, ry, rz, 0, (rotZX * 180 / PI), (rotXY * 180 / PI), CreateInput_MeshOrSolid);
  
  
        this.branch_addallSolids(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (Display_Leaves) {
  
        float r0 = 0.5 * LeafSize;
        allModel3Ds.add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, CreateInput_MeshOrSolid);
      }
    }
  }
  
  void branch_shadow (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float[] SunR_Rotated, float Shades_scaleX, float Shades_scaleY, float Shades_offsetX, float Shades_offsetY) {
  
    SHADOW_graphics.strokeWeight(0);
  
    SHADOW_graphics.stroke(0);
    SHADOW_graphics.fill(0);
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (Display_allModel1Ds) {
          int nSeg = 6; 
          float[][] subFace = new float [nSeg * 4][3];
          for (int q = 0; q < nSeg; q++) {
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
              subFace[q * 4 + j][0] = Trunk_x_new;
              subFace[q * 4 + j][1] = Trunk_y_new; 
              subFace[q * 4 + j][2] = Trunk_z_new;
            }
          }
  
          float[][] subFace_Rotated = subFace;
  
          for (int s = 0; s < subFace_Rotated.length; s++) {
            if (SolarImpact_sectionType == 2) {
              float a = subFace_Rotated[s][0];
              float b = -subFace_Rotated[s][1];
              float c = subFace_Rotated[s][2];
  
              subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
              subFace_Rotated[s][1] = c;    
              subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
            } else if (SolarImpact_sectionType == 3) {
            }
          }  
  
          SHADOW_graphics.beginShape();
  
          for (int s = 0; s < subFace_Rotated.length; s++) {
  
            float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
            float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
            float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
            if (z >= 0) {
  
              if (SolarImpact_sectionType == 1) {                    
                float px = x;
                float py = y;
  
                x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
              } 
  
              SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY);
            } else {
              int s_next = (s + 1) % subFace_Rotated.length;
              int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
              float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
              float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
              float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
  
              if (z_prev > 0) { 
                float ratio = z_prev / (z_prev - z);
  
                float x_trim = x_prev * (1 - ratio) + x * ratio;
                float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                if (SolarImpact_sectionType == 1) {
                  float px = x_trim;
                  float py = y_trim;
  
                  x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                  y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                } 
  
                SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
              }
  
              float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
              float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
              float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
              if (z_next > 0) { 
                float ratio = z_next / (z_next - z);
  
                float x_trim = x_next * (1 - ratio) + x * ratio;
                float y_trim = y_next * (1 - ratio) + y * ratio;
  
                if (SolarImpact_sectionType == 1) {
                  float px = x_trim;
                  float py = y_trim;
  
                  x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                  y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                } 
  
                SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
              }
            }
          }
  
          SHADOW_graphics.endShape(CLOSE);
        }
  
        this.branch_shadow(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetY, Shades_offsetY);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int COL = int(random(127));      
  
      if (Display_Leaves) {
  
        float x0_Rotated = x0;
        float y0_Rotated = y0;
        float z0_Rotated = z0;
  
        if (SolarImpact_sectionType == 2) {
          float a = x0;
          float b = -y0;
          float c = z0;
  
          x0_Rotated = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
          y0_Rotated = c;    
          z0_Rotated= a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
        } else if (SolarImpact_sectionType == 3) {
        }
  
  
        float z = z0_Rotated - SolarImpact_Elevation;
        float x = x0_Rotated - z * SunR_Rotated[1] / SunR_Rotated[3];
        float y = y0_Rotated - z * SunR_Rotated[2] / SunR_Rotated[3];
  
        if (z >= 0) {
  
          if (SolarImpact_sectionType == 1) {                    
            float px = x;
            float py = y;
  
            x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
            y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
          } 
  
  
  
          SHADOW_graphics.ellipse((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY, LeafSize * Shades_scaleX, LeafSize * Shades_scaleY);
        }
      }
    }
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = SOLARCHVISION_isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }  
  
  
  
  
  void add_single (int PlantType, float x, float y, float z, float s, float rot, int PlantDegreeMin, int PlantDegreeMax, int PlantSeed, float TrunkSize, float LeafSize) {
  
    float[] TempallModel1Ds_TrunkSize = {
      TrunkSize
    }; 
    this.TrunkSize = concat(this.TrunkSize, TempallModel1Ds_TrunkSize);  
  
    float[] TempallModel1Ds_LeafSize = {
      LeafSize
    }; 
    this.LeafSize = concat(this.LeafSize, TempallModel1Ds_LeafSize);
  
    int[] TempallModel1Ds_Type = {
      PlantType
    }; 
    this.Type = concat(this.Type, TempallModel1Ds_Type);
  
    int[] TempallModel1Ds_DegreeMin = {
      PlantDegreeMin
    }; 
    this.DegreeMin = concat(this.DegreeMin, TempallModel1Ds_DegreeMin);
  
    int[] TempallModel1Ds_DegreeMax = {
      PlantDegreeMax
    }; 
    this.DegreeMax = concat(this.DegreeMax, TempallModel1Ds_DegreeMax);
  
    int q = PlantSeed;
    if (q == -1) q = int(random(32767));
  
    int[] TempallModel1Ds_Seed = {
      q
    }; 
    this.Seed = concat(this.Seed, TempallModel1Ds_Seed);
  
    float[][] TempallModel1Ds_XYZSR = {
      {
        x, y, z, s, rot
      }
    };
    this.XYZSR = (float[][]) concat(this.XYZSR, TempallModel1Ds_XYZSR);
  
    this.num += 1;
  
  
  
    if (CreateInput_MeshOrSolid != 0) {
  
      randomSeed(q);
  
      this.branch_addallSolids(x, y, z, 0, rot, 0.5 * s, PlantDegreeMin, PlantDegreeMin, PlantDegreeMax, TrunkSize, LeafSize);
    }
  
  
    if (allGroups.num > 0) allGroups.allModel1Ds[allGroups.num - 1][1] = this.num - 1;
  
  }  
  
  
  void delete () {
  
    this.XYZSR = new float [0][5]; 
  
    this.Type = new int [0];
  
    this.DegreeMin = new int [0];
  
    this.DegreeMax = new int [0];
  
    this.Seed = new int [0];
  
    this.TrunkSize = new float [0];
  
    this.LeafSize = new float [0];
  
    this.num = 0;
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.allModel1Ds[q][0] = 0;
      allGroups.allModel1Ds[q][1] = -1;
    }    
  
    allModel3Ds.deselect_All();
  }  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.XYZSR[i].length; j++) {
      for (int j = 0; j < 5; j++) { // x, y, z, s, rot
        lineSTR += nf(this.XYZSR[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(this.getType(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getDegreeMin(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getDegreeMax(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getSeed(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getTrunkSize(i), 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(this.getLeafSize(i), 0, 4).replace(",", "."); // <<<<

      child.setContent(lineSTR);
    } 
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = parent.getInt("ni");

    this.XYZSR = new float [ni][5];
    this.Type = new int [ni];
    this.DegreeMin = new int [ni];
    this.DegreeMax = new int [ni];
    this.Seed = new int [ni];
    this.TrunkSize = new float [ni];
    this.LeafSize = new float [ni];
    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 5; j++) {
        this.XYZSR[i][j] = float(parts[j]);
      }

      this.setType(i, int(parts[5]));
      this.setDegreeMin(i, int(parts[6]));
      this.setDegreeMax(i, int(parts[7]));
      this.setSeed(i, int(parts[8]));
      this.setTrunkSize(i, float(parts[9]));
      this.setLeafSize(i, float(parts[10]));
    }
  }    
}

solarchvision_Model1Ds allModel1Ds = new solarchvision_Model1Ds();



class solarchvision_Solids {
  
  private final static String CLASS_STAMP = "Solids";

  float[][] DEF = new float[0][13];
  
  void updatePosition (int n, float a, float b, float c) {
  
    this.DEF[n][0] = a;
    this.DEF[n][1] = b;
    this.DEF[n][2] = c;
  } 
  
  void updatePowers (int n, float a, float b, float c) {
  
    this.DEF[n][3] = a;
    this.DEF[n][4] = b;
    this.DEF[n][5] = c;
  } 
  
  void Scale (int n, float a, float b, float c) {
  
    this.DEF[n][6] *= a;
    this.DEF[n][7] *= b;
    this.DEF[n][8] *= c;
  } 
  
  void RotateX (int n, float t) {
  
    this.DEF[n][9] += t;
  } 
  
  void RotateY (int n, float t) {
  
    this.DEF[n][10] += t;
  } 
  
  void RotateZ (int n, float t) {
  
    this.DEF[n][11] += t;
  } 
  
  void set_posX (int n, float r) { 
  
    this.DEF[n][0] = r;
  } 
  
  void set_posY (int n, float r) { 
  
    this.DEF[n][1] = r;
  } 
  
  void set_posZ (int n, float r) { 
  
    this.DEF[n][2] = r;
  } 
  
  void set_powX (int n, float r) { 
  
    this.DEF[n][3] = r;
  } 
  
  void set_powY (int n, float r) { 
  
    this.DEF[n][4] = r;
  } 
  
  void set_powZ (int n, float r) { 
  
    this.DEF[n][5] = r;
  } 
  
  void set_scaleX (int n, float r) { 
  
    this.DEF[n][6] = r;
  } 
  
  void set_scaleY (int n, float r) { 
  
    this.DEF[n][7] = r;
  } 
  
  void set_scaleZ (int n, float r) { 
  
    this.DEF[n][8] = r;
  } 
  
  void set_rotX (int n, float r) { 
  
    this.DEF[n][9] = r;
  } 
  
  
  void set_rotY (int n, float r) { 
  
    this.DEF[n][10] = r;
  } 
  
  void set_rotZ (int n, float r) { 
  
    this.DEF[n][11] = r;
  } 
  
  void set_value (int n, float r) { 
  
    this.DEF[n][12] = r;
  }   
  
  float get_posX (int n) { 
  
    return this.DEF[n][0];
  } 
  
  float get_posY (int n) { 
  
    return this.DEF[n][1];
  } 
  
  float get_posZ (int n) { 
  
    return this.DEF[n][2];
  } 
  
  float get_powX (int n) { 
  
    return this.DEF[n][3];
  } 
  
  float get_powY (int n) { 
  
    return this.DEF[n][4];
  } 
  
  float get_powZ (int n) { 
  
    return this.DEF[n][5];
  } 
  
  float get_scaleX (int n) { 
  
    return this.DEF[n][6];
  } 
  
  float get_scaleY (int n) { 
  
    return this.DEF[n][7];
  } 
  
  float get_scaleZ (int n) { 
  
    return this.DEF[n][8];
  } 
  
  float get_rotX (int n) { 
  
    return this.DEF[n][9];
  } 
  
  
  float get_rotY (int n) { 
  
    return this.DEF[n][10];
  } 
  
  float get_rotZ (int n) { 
  
    return this.DEF[n][11];
  } 
  
  float get_value (int n) { 
  
    return this.DEF[n][12];
  } 
  
  float get_Distance (int n, float a, float b, float c) {
  
    float posX = this.DEF[n][0];
    float posY = this.DEF[n][1];
    float posZ = this.DEF[n][2];
    float powX = this.DEF[n][3];
    float powY = this.DEF[n][4];
    float powZ = this.DEF[n][5];
    float scaleX = this.DEF[n][6];
    float scaleY = this.DEF[n][7];
    float scaleZ = this.DEF[n][8];
    float rotX = this.DEF[n][9];
    float rotY = this.DEF[n][10];
    float rotZ = this.DEF[n][11];
    float value = this.DEF[n][12];
  
    a -= posX;
    b -= posY;    
    c -= posZ;
  
    ///////////////////////// NOT SURE START!    
  
    float y1 = b * cos_ang(-rotX) - c * sin_ang(-rotX); 
    float z1 = b * sin_ang(-rotX) + c * cos_ang(-rotX);
    float x1 = a;
  
    a = x1;
    b = y1;
    c = z1;  
  
    float z2 = c * cos_ang(-rotY) - a * sin_ang(-rotY);
    float x2 = c * sin_ang(-rotY) + a * cos_ang(-rotY);
    float y2 = b; 
  
    a = x2;
    b = y2;
    c = z2;      
    ///////////////////////// NOT SURE END!
  
    float x = a * cos_ang(-rotZ) - b * sin_ang(-rotZ);
    float y = a * sin_ang(-rotZ) + b * cos_ang(-rotZ); 
    float z = c;    
  
    x += posX;
    y += posY;  
    z += posZ;
  
     
    return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))));
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / (value * scaleX * scaleY * scaleZ * 0.001));
    //return(scaleX * scaleY * scaleZ * 0.01 * pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    
  
  }  
  
  
  int numDisplayFaces = 3; // internal - number of faces: XY, YZ, ZX
  int numDisplayDegree = 16; //8; // internal - number of each face corners 
  
  private float[][] Vertices;
  private int[][] Faces;

  void draw () {
  
    this.Faces = new int [this.numDisplayFaces * this.DEF.length][this.numDisplayDegree]; 
  
    this.Vertices = new float [this.numDisplayFaces * this.numDisplayDegree * this.DEF.length][3];
  
    if (Display_allSolids) {
  
      WIN3D.graphics.strokeWeight(2);
  
      for (int f = 0; f < this.DEF.length; f++) {
  
        float Solid_posX = this.get_posX(f);
        float Solid_posY = this.get_posY(f);
        float Solid_posZ = this.get_posZ(f);
        float Solid_powX = this.get_powX(f);
        float Solid_powY = this.get_powY(f);
        float Solid_powZ = this.get_powZ(f);
        float Solid_scaleX = this.get_scaleX(f);
        float Solid_scaleY = this.get_scaleY(f);
        float Solid_scaleZ = this.get_scaleZ(f);
        float Solid_rotX = this.get_rotX(f);
        float Solid_rotY = this.get_rotY(f);
        float Solid_rotZ = this.get_rotZ(f);
        float Solid_value = this.get_value(f);
  
        for (int plane_type = 0; plane_type < this.numDisplayFaces; plane_type++) {
  
          WIN3D.graphics.noFill();        
          WIN3D.graphics.stroke(0);
  
          if (plane_type == 0) {
            WIN3D.graphics.stroke(0, 255, 0);
          }  
          if (plane_type == 1) {
            WIN3D.graphics.stroke(255, 0, 0);
          }          
          if (plane_type == 2) {
            WIN3D.graphics.stroke(0, 0, 255);
          }          
  
          WIN3D.graphics.beginShape();
  
          float[][] ImageVertex = this.getCorners(plane_type, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
          for (int q = 1; q <= this.numDisplayDegree; q++) {
  
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
  
            if (q != 0) {
  
              int vNo = (f * this.numDisplayFaces + plane_type) * this.numDisplayDegree + q - 1;
  
              this.Vertices[vNo][0] = x;
              this.Vertices[vNo][1] = y;
              this.Vertices[vNo][2] = z;
  
              int fNo = (f * this.numDisplayFaces + plane_type);
  
              this.Faces[fNo][q - 1] = vNo;
            }
          }        
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
  
      WIN3D.graphics.noStroke();
      WIN3D.graphics.strokeWeight(0);
    }
  }
  
  
  float[][] getCorners (int plane_type, float Solid_posX, float Solid_posY, float Solid_posZ, float Solid_powX, float Solid_powY, float Solid_powZ, float Solid_scaleX, float Solid_scaleY, float Solid_scaleZ, float Solid_rotX, float Solid_rotY, float Solid_rotZ, float Solid_value) {
  
    float[][] ImageVertex = new float [this.numDisplayDegree + 1][3];
  
    for (int q = 0; q <= this.numDisplayDegree; q++) {
  
      float qx = 0;
      float qy = 0;
      float qz = 0;
  
      if (q != 0) {
        if (plane_type == 0) {
          qx = cos_ang(q * 360.0 / float(this.numDisplayDegree));
          qy = sin_ang(q * 360.0 / float(this.numDisplayDegree));
        }
  
        if (plane_type == 1) {
          qy = cos_ang(q * 360.0 / float(this.numDisplayDegree));
          qz = sin_ang(q * 360.0 / float(this.numDisplayDegree));
        }
  
        if (plane_type == 2) {
          qz = cos_ang(q * 360.0 / float(this.numDisplayDegree));
          qx = sin_ang(q * 360.0 / float(this.numDisplayDegree));
        }
      }
  
      if (q != 0) { // normalizing
  
        float d = pow(pow(abs(qx), Solid_powX) + pow(abs(qy), Solid_powY) + pow(abs(qz), Solid_powZ), 3.0 / (Solid_powX + Solid_powY + Solid_powZ));
  
        if (d != 0) {
          qx /= d;
          qy /= d;
          qz /= d;
        }
      }
  
  
      float a = qx * Solid_scaleX;
      float b = qy * Solid_scaleY;
      float c = qz * Solid_scaleZ;  
  
      ///////////////////////// NOT SURE START!    
  
      float y1 = b * cos_ang(Solid_rotX) - c * sin_ang(Solid_rotX); 
      float z1 = b * sin_ang(Solid_rotX) + c * cos_ang(Solid_rotX);
      float x1 = a;
  
      a = x1;
      b = y1;
      c = z1;  
  
      float z2 = c * cos_ang(Solid_rotY) - a * sin_ang(Solid_rotY);
      float x2 = c * sin_ang(Solid_rotY) + a * cos_ang(Solid_rotY);
      float y2 = b; 
  
      a = x2;
      b = y2;
      c = z2;      
      ///////////////////////// NOT SURE END!
  
      float x = a * cos_ang(Solid_rotZ) - b * sin_ang(Solid_rotZ);
      float y = a * sin_ang(Solid_rotZ) + b * cos_ang(Solid_rotZ);
      float z = c;         
  
  
      x += Solid_posX;
      y += Solid_posY;
      z += Solid_posZ;  
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }
  
    return ImageVertex;
  }

  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
      
      int n = this.Faces[f].length;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
      
      float dist2intersect = FLOAT_undefined;
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
    
          float AnglesAll = 0;      
    
          for (int i = 0; i < n; i++) {
            int next_i = (i + 1) % n;
    
            float[] vect1 = {this.Vertices[this.Faces[f][i]][0] - X_intersect, this.Vertices[this.Faces[f][i]][1] - Y_intersect, this.Vertices[this.Faces[f][i]][2] - Z_intersect};
            float[] vect2 = {this.Vertices[this.Faces[f][next_i]][0] - X_intersect, this.Vertices[this.Faces[f][next_i]][1] - Y_intersect, this.Vertices[this.Faces[f][next_i]][2] - Z_intersect};
    
            float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
    
            AnglesAll += t;
          }
          
          if (AnglesAll > 359) { // <<<<<<<<<
          
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
          }
        }
      }
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = int(f / this.numDisplayFaces);
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
  
      }
  
    }
  
    return return_point;
  }


  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    int ni = this.DEF.length;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.DEF[i].length; j++) {
      for (int j = 0; j < 13; j++) { // x, y, y, px, py, pz, sx, sy, sz, rx, ry, rz, v
        lineSTR += nf(this.DEF[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 != this.DEF[i].length) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = parent.getInt("ni");

    this.DEF = new float [ni][13];

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 13; j++) {
        this.DEF[i][j] = float(parts[j]);
      }
    }
  }    

}

solarchvision_Solids allSolids = new solarchvision_Solids();


















class solarchvision_Model3Ds {
  
  private final static String CLASS_STAMP = "Model3Ds";
    
  boolean DisplayVertices = false;
  boolean DisplayEdges = true;
  boolean DisplayNormals = false;
  
  int Tessellation = 2;
  



  void beginNewCurve () {
  
    int[] newCurve = {};    
    
    this.add_Curve(newCurve);
    
  }
  
  void beginNewFace () {
  
    int[] newFace = {};    
    
    this.add_Face(newFace);
    
  }
  
  void add_VertexToLastFace (float x, float y, float z) {
    
    int n = allFaces.nodes.length - 1;
    
    int[] newVertex = {
      this.add_Vertex(x, y, z)
    }; 
      
    allFaces.nodes[n] = (int[]) concat(allFaces.nodes[n], newVertex);
  
  }
  
  void add_VertexToLastCurve (float x, float y, float z) {
  
    int n = allCurves.nodes.length - 1;
    
    int[] newVertex = {
      this.add_Vertex(x, y, z)
    }; 
      
    allCurves.nodes[n] = (int[]) concat(allCurves.nodes[n], newVertex);
  
  }
  
  
  
  
  int add_Vertex (float x, float y, float z) {
  
    float[][] newVertex = {
      {
        x, y, z
      }
    }; 
  
    allVertices = (float[][]) concat(allVertices, newVertex);
  
    return(allVertices.length - 1);
  }
  
  
  
  int add_Face (int[] f) {
  
    {
  
      int[][] newFace_MTLVGC = {
        {
          defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
        }
      }; 
  
      allFaces.options =  (int[][]) concat(allFaces.options, newFace_MTLVGC);
  
      int[][] newFace = {
        f
      }; 
  
      allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
    }
  
    if (allGroups.num > 0) allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
  
    return(allFaces.nodes.length - 1);
  }
  
  int add_Curve (int[] f) {
  
    {
  
      int[][] newCurve_MTLVGC = {
        {
          defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
        }
      }; 
  
      allCurves.options =  (int[][]) concat(allCurves.options, newCurve_MTLVGC);
  
      int[][] newCurve = {
        f
      }; 
  
      allCurves.nodes = (int[][]) concat(allCurves.nodes, newCurve);
    }
  
    if (allGroups.num > 0) allGroups.Curves[allGroups.num - 1][1] = allCurves.nodes.length - 1;
  
    return(allCurves.nodes.length - 1);
  }


  void add_Spline (int m, int tes, int lyr, int vsb, int wgt, int clz, float[][] points) {
    
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt;  
    defaultClose = clz;
  
    int[] newCurve = new int[points.length];
   
    for (int i = 0; i < points.length; i++) {
      newCurve[i] = this.add_Vertex(points[i][0], points[i][1], points[i][2]);
    }
  
    this.add_Curve(newCurve);
  }
  
  
  void add_Arc (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot, float TotalAngle) {
  
    float AngleStep = TotalAngle / float(n);
    int EndOfLoop = n;
    if (TotalAngle % 360 == 0) {
      EndOfLoop -= 1;
      clz = 1; // for right closing of a circle 
    }
    
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt;
    defaultClose = clz;
  
  
    int[] newCurve = {
      this.add_Vertex(cx + r * cos_ang(0), cy + r * sin_ang(0), cz)
    };
    for (int i = 1; i <= EndOfLoop; i++) {
      float t = i * AngleStep + rot;
      int[] f = {
        this.add_Vertex(cx + r * cos_ang(t), cy + r * sin_ang(t), cz)
      };
      newCurve = concat(newCurve, f);
    } 
  
    this.add_Curve(newCurve);
  }
  
  


  
  
  int add_Solid (float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz, float v) {
  
    {
  
      float[][] newSolid = {
        {
          x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz, v
        }
      };
      allSolids.DEF = (float[][]) concat(allSolids.DEF, newSolid);
    }
  
    if (allGroups.num > 0) allGroups.allSolids[allGroups.num - 1][1] = allSolids.DEF.length - 1;
  
    return(allSolids.DEF.length - 1);
  }
  
  
  
  void add_Camera (int n, float x, float y, float z, float s, float rx, float ry, float rz, float f) {
  
    int[] TempCamera_Type = {
      n
    }; 
    allCameras.Type = concat(allCameras.Type, TempCamera_Type);
  
    float[][] TempCamera_PPPRRRF = {
      {
        x, y, z, s, rx, ry, rz, f
      }
    };
    allCameras.PPPSRRRF = (float[][]) concat(allCameras.PPPSRRRF, TempCamera_PPPRRRF);
  
    allCameras.num += 1;
  }
  
  
  void add_Section (int n, float u, float v, float elev, float rot, float dU, float dV, int RES1, int RES2) {
  
    int[] TempSection_Type = {
      n
    }; 
    allSections.Type = concat(allSections.Type, TempSection_Type);
  
    int[] TempSection_RES1 = {
      RES1
    }; 
    allSections.RES1 = concat(allSections.RES1, TempSection_RES1);
  
    int[] TempSection_RES2 = {
      RES2
    }; 
    allSections.RES2 = concat(allSections.RES2, TempSection_RES2);
  
    PImage[] TempSection_SolidImpact = {
      createImage(RES1, RES2, RGB)
    }; 
    allSections.SolidImpact = (PImage[]) concat(allSections.SolidImpact, TempSection_SolidImpact);
  
    PImage[][][] TempSection_SolarImpact = new PImage [1][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      int i = 0;
      for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {
        for (int q = 0; q < numberOfImpactVariations; q++) { 
          TempSection_SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
        }
      }
    }
    allSections.SolarImpact = (PImage[][][]) concat(allSections.SolarImpact, TempSection_SolarImpact);    
  
    float[][] TempSection_UVERAB = {
      {
        u, v, elev, rot, dU, dV
      }
    };
    allSections.UVERAB = (float[][]) concat(allSections.UVERAB, TempSection_UVERAB);
  
    allSections.num += 1;
  }  
  
  
  
  int beginNewGroup (float x, float y, float z, float sx, float sy, float sz, float rx, float ry, float rz) {
  
    float[][] newObject_PivotXYZ = {
      {
        x, y, z, sx, sy, sz, rx, ry, rz
      }
    }; 
  
    allGroups.PivotXYZ = (float[][]) concat(allGroups.PivotXYZ, newObject_PivotXYZ);
  
    int[][] newObject_Pivot = {
      {
        defaultPivotType
      }
    };
  
    allGroups.PivotType = (int[][]) concat(allGroups.PivotType, newObject_Pivot);  
  
  
    int[][] newObject_allModel1Ds = {
      {
        allModel1Ds.num, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.allModel1Ds = (int[][]) concat(allGroups.allModel1Ds, newObject_allModel1Ds);     
  
    int[][] newObject_allModel2Ds = {
      {
        allModel2Ds.num, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.allModel2Ds = (int[][]) concat(allGroups.allModel2Ds, newObject_allModel2Ds);   
  
    int[][] newObject_allSolids = {
      {
        allSolids.DEF.length, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.allSolids = (int[][]) concat(allGroups.allSolids, newObject_allSolids);      
  
    int[][] newObject_Faces = {
      {
        allFaces.nodes.length, -1
      }
    }; // i.e. null because start > end   
  
    allGroups.Faces = (int[][]) concat(allGroups.Faces, newObject_Faces);
  
    int[][] newObject_Curves = {
      {
        allCurves.nodes.length, -1
      }
    }; // i.e. null because start > end   
  
    allGroups.Curves = (int[][]) concat(allGroups.Curves, newObject_Curves);
    
  
  
    allGroups.num += 1;
    
    return(allGroups.num - 1);  
  }
  
  
  
  void duplicate_Selection (int produce_another_variation) {
  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }
  
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      int number_of_allModel1Ds_before = allModel1Ds.num; 
  
      for (int o = 0; o < selectedallModel1Ds_ids.length; o++) {
  
        int OBJ_NUM = selectedallModel1Ds_ids[o];
  
        float x = allModel1Ds.getX(OBJ_NUM);
        float y = allModel1Ds.getY(OBJ_NUM);
        float z = allModel1Ds.getZ(OBJ_NUM);
        float d = allModel1Ds.getS(OBJ_NUM);
        float rot = allModel1Ds.getR(OBJ_NUM);
  
        int n = allModel1Ds.getType(OBJ_NUM);
        int dMin = allModel1Ds.getDegreeMin(OBJ_NUM);
        int dMax = allModel1Ds.getDegreeMax(OBJ_NUM);
        int s = allModel1Ds.getSeed(OBJ_NUM);
        float TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
        float LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
  
        if (produce_another_variation == 1) randomSeed(millis());
        allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
      }
  
      // selecting new objetcs
  
      selectedallModel1Ds_ids = new int [0];
  
      for (int o = number_of_allModel1Ds_before; o < allModel1Ds.num; o++) {
  
        int[] newlyAddedallModel1Ds = {o};
  
        selectedallModel1Ds_ids = concat(selectedallModel1Ds_ids, newlyAddedallModel1Ds);
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      int n1 = allModel2Ds.PEOPLE_Files_Num;
  
      int number_of_allModel2Ds_before = allModel2Ds.num; 
  
      for (int o = 0; o < selectedallModel2Ds_ids.length; o++) {
  
        int OBJ_NUM = selectedallModel2Ds_ids[o];
  
        float x = allModel2Ds.getX(OBJ_NUM);
        float y = allModel2Ds.getY(OBJ_NUM);
        float z = allModel2Ds.getZ(OBJ_NUM);
        float s = allModel2Ds.getS(OBJ_NUM);
  
        int n = allModel2Ds.MAP[OBJ_NUM];
        if (abs(n) > n1) {
          if (produce_another_variation == 1) n = 0; // this makes it random
          allModel2Ds.add_single("TREES", n, x, y, z, s);
        } else {
          if (produce_another_variation == 1) n = 0; // this makes it random
          allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
        }
      }
  
      // selecting new objetcs
  
      selectedallModel2Ds_ids = new int [0];
  
      for (int o = number_of_allModel2Ds_before; o < allModel2Ds.num; o++) {
  
        int[] newlyAddedallModel2Ds = {o};
  
        selectedallModel2Ds_ids = concat(selectedallModel2Ds_ids, newlyAddedallModel2Ds);
      }
    }
  
  
    if (Current_ObjectCategory == ObjectCategory.FACE) {
  
      int number_of_Faces_before = allFaces.nodes.length;
  
      for (int o = 0; o < selectedFace_ids.length; o++) {
  
        int f = selectedFace_ids[o];        
  
        int number_of_Vertices_before = allVertices.length;
  
        int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
        if ((0 <= f) && (f < allFaces.nodes.length)) {
  
          int[] newFace = {
          };
  
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
            int vNo = allFaces.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
              if (vNo == PolymeshVertices_OLD[q]) {
                vertex_listed = q;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
              float x = allVertices[vNo][0];
              float y = allVertices[vNo][1];
              float z = allVertices[vNo][2];
  
              int[] newVertexAdded = {
                this.add_Vertex(x, y, z)
              };
              PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
              vertex_listed = PolymeshVertices_OLD.length;
            } 
  
            //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
  
            int[] new_vertexItem = {
              number_of_Vertices_before + vertex_listed - 1
            };
  
            newFace = concat(newFace, new_vertexItem);
          }
  
          defaultMaterial = allFaces.getMaterial(f);
          defaultTessellation = allFaces.getTessellation(f);
          defaultLayer = allFaces.getLayer(f);
          defaultVisibility = allFaces.getVisibility(f);        
  
          this.add_Face(newFace);
        }
      }
  
  
      // selecting new objetcs
  
      selectedFace_ids = new int [0];
  
      for (int o = number_of_Faces_before; o < allFaces.nodes.length; o++) {
  
        int[] newlyAddedFace = {o};
  
        selectedFace_ids = concat(selectedFace_ids, newlyAddedFace);
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.CURVE) {
  
      int number_of_Curves_before = allCurves.nodes.length;
  
      for (int o = 0; o < selectedCurve_ids.length; o++) {
  
        int f = selectedCurve_ids[o];        
  
        int number_of_Vertices_before = allVertices.length;
  
        int[] PolymeshVertices_OLD = new int [0];  // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
        if ((0 <= f) && (f < allCurves.nodes.length)) {
  
          int[] newCurve = {
          };
  
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
            int vNo = allCurves.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
              if (vNo == PolymeshVertices_OLD[q]) {
                vertex_listed = q;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
              float x = allVertices[vNo][0];
              float y = allVertices[vNo][1];
              float z = allVertices[vNo][2];
  
              int[] newVertexAdded = {
                this.add_Vertex(x, y, z)
              };
              PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
              vertex_listed = PolymeshVertices_OLD.length;
            } 
  
            //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
  
            int[] new_vertexItem = {
              number_of_Vertices_before + vertex_listed - 1
            };
  
            newCurve = concat(newCurve, new_vertexItem);
          }
  
          defaultMaterial = allCurves.getMaterial(f);
          defaultTessellation = allCurves.getTessellation(f);
          defaultLayer = allCurves.getLayer(f);
          defaultVisibility = allCurves.getVisibility(f);        
          defaultWeight = allCurves.getWeight(f);
          defaultClose = allCurves.getClose(f);
  
          this.add_Curve(newCurve);
        }
      }
  
  
      // selecting new objetcs
  
      selectedCurve_ids = new int [0];
  
      for (int o = number_of_Curves_before; o < allCurves.nodes.length; o++) {
  
        int[] newlyAddedCurve = {o};
  
        selectedCurve_ids = concat(selectedCurve_ids, newlyAddedCurve);
      }
    }
  
  
    if (Current_ObjectCategory == ObjectCategory.SOLID) {
  
      int number_of_Solid_before = allSolids.DEF.length; 
  
      for (int o = 0; o < selectedSolid_ids.length; o++) {
  
        int OBJ_NUM = selectedSolid_ids[o];
  
        float Solid_posX = allSolids.get_posX(OBJ_NUM);
        float Solid_posY = allSolids.get_posY(OBJ_NUM);
        float Solid_posZ = allSolids.get_posZ(OBJ_NUM);
        float Solid_powX = allSolids.get_powX(OBJ_NUM);
        float Solid_powY = allSolids.get_powY(OBJ_NUM);
        float Solid_powZ = allSolids.get_powZ(OBJ_NUM);
        float Solid_scaleX = allSolids.get_scaleX(OBJ_NUM);
        float Solid_scaleY = allSolids.get_scaleY(OBJ_NUM);
        float Solid_scaleZ = allSolids.get_scaleZ(OBJ_NUM);
        float Solid_rotX = allSolids.get_rotX(OBJ_NUM);
        float Solid_rotY = allSolids.get_rotY(OBJ_NUM);
        float Solid_rotZ = allSolids.get_rotZ(OBJ_NUM);
        float Solid_value = allSolids.get_value(OBJ_NUM);
  
        this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
      }
  
      // selecting new objetcs
  
      selectedSolid_ids = new int [0];
  
      for (int o = number_of_Solid_before; o < allSolids.DEF.length; o++) {
  
        int[] newlyAddedSolid = {o};
  
        selectedSolid_ids = concat(selectedSolid_ids, newlyAddedSolid);
      }
    }    
  
  
    if (Current_ObjectCategory == ObjectCategory.SECTION) {
  
      int number_of_Section_before = allSections.num; 
  
      for (int o = 0; o < selectedSection_ids.length; o++) {
  
        int OBJ_NUM = selectedSection_ids[o];
  
        float Section_offset_U = allSections.UVERAB[OBJ_NUM][0];
        float Section_offset_V = allSections.UVERAB[OBJ_NUM][1];
        float Section_Elevation = allSections.UVERAB[OBJ_NUM][2];
        float Section_Rotation = allSections.UVERAB[OBJ_NUM][3];
        float Section_scale_U = allSections.UVERAB[OBJ_NUM][4];
        float Section_scale_V = allSections.UVERAB[OBJ_NUM][5];
  
        int Section_Type = allSections.Type[OBJ_NUM];
        int Section_RES1 = allSections.RES1[OBJ_NUM];
        int Section_RES2 = allSections.RES2[OBJ_NUM];
  
        this.add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
      }
  
      // selecting new objetcs
  
      selectedSection_ids = new int [0];
  
      for (int o = number_of_Section_before; o < allSections.num; o++) {
  
        int[] newlyAddedSection = {o};
  
        selectedSection_ids = concat(selectedSection_ids, newlyAddedSection);
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
  
      int number_of_Camera_before = allCameras.num; 
  
      for (int o = 0; o < selectedCamera_ids.length; o++) {
  
        int OBJ_NUM = selectedCamera_ids[o];
  
        float Camera_X = allCameras.PPPSRRRF[OBJ_NUM][0];
        float Camera_Y = allCameras.PPPSRRRF[OBJ_NUM][1];
        float Camera_Z = allCameras.PPPSRRRF[OBJ_NUM][2];
        float Camera_S = allCameras.PPPSRRRF[OBJ_NUM][3];
        float Camera_RX = allCameras.PPPSRRRF[OBJ_NUM][4];
        float Camera_RY = allCameras.PPPSRRRF[OBJ_NUM][5];
        float Camera_RZ = allCameras.PPPSRRRF[OBJ_NUM][6];
        float Camera_ZOOM = allCameras.PPPSRRRF[OBJ_NUM][7];
  
        int Camera_Type = allCameras.Type[OBJ_NUM];
  
        this.add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);
      }
  
      // selecting new objetcs
  
      selectedCamera_ids = new int [0];
  
      for (int o = number_of_Camera_before; o < allCameras.num; o++) {
  
        int[] newlyAddedCamera = {o};
  
        selectedCamera_ids = concat(selectedCamera_ids, newlyAddedCamera);
      }
    }  
  
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
  
      int n1 = allModel2Ds.PEOPLE_Files_Num;
  
      int SOLID_added = 0;
  
      int number_of_allGroups_before = allGroups.num;
  
      for (int o = 0; o < selectedGroup_ids.length; o++) {
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        if ((0 <= allGroups.Faces[OBJ_NUM][0]) && (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1])) { 
  
          int number_of_Vertices_before = allVertices.length;
  
          this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
          int new_OBJ_NUM = allGroups.num - 1;
  
          allGroups.PivotType[new_OBJ_NUM][0] = allGroups.PivotType[OBJ_NUM][0];
  
          for (int j = 0; j < allGroups.PivotXYZ[OBJ_NUM].length; j++) { 
            allGroups.PivotXYZ[new_OBJ_NUM][j] = allGroups.PivotXYZ[OBJ_NUM][j];
          }
  
          if ((0 <= allGroups.allModel1Ds[OBJ_NUM][1]) && (allGroups.allModel1Ds[OBJ_NUM][0] <= allGroups.allModel1Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.allModel1Ds[OBJ_NUM][0]; q <= allGroups.allModel1Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel1Ds.getX(q);
              float y = allModel1Ds.getY(q);
              float z = allModel1Ds.getZ(q);
  
              float d = allModel1Ds.getS(q);
              float rot = allModel1Ds.getR(q);
  
              int n = allModel1Ds.getType(q);
  
              int dMin = allModel1Ds.getDegreeMin(q);
  
              int dMax = allModel1Ds.getDegreeMax(q);
  
              int s = allModel1Ds.getSeed(q);
  
              float TrunkSize = allModel1Ds.getTrunkSize(q);
  
              float LeafSize = allModel1Ds.getLeafSize(q);
  
              if (produce_another_variation == 1) {
                randomSeed(millis());
  
                rot = random(360);
                s = int(random(32767));
              }
              allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
            }
          }
  
          if ((0 <= allGroups.allModel2Ds[OBJ_NUM][1]) && (allGroups.allModel2Ds[OBJ_NUM][0] <= allGroups.allModel2Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.allModel2Ds[OBJ_NUM][0]; q <= allGroups.allModel2Ds[OBJ_NUM][1]; q++) {
    
              float x = allModel2Ds.getX(q);
              float y = allModel2Ds.getY(q);
              float z = allModel2Ds.getZ(q);
              float s = allModel2Ds.getS(q);
    
              int n = allModel2Ds.MAP[q];
    
              if (abs(n) > n1) {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("TREES", n, x, y, z, s);
              } else {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
              }
            }
          }
  
  
          if ((0 <= allGroups.allSolids[OBJ_NUM][1]) && (allGroups.allSolids[OBJ_NUM][0] <= allGroups.allSolids[OBJ_NUM][1])) { 
            for (int q = allGroups.allSolids[OBJ_NUM][0]; q <= allGroups.allSolids[OBJ_NUM][1]; q++) {
  
              float Solid_posX = allSolids.get_posX(q);
              float Solid_posY = allSolids.get_posY(q);
              float Solid_posZ = allSolids.get_posZ(q);
              float Solid_powX = allSolids.get_powX(q);
              float Solid_powY = allSolids.get_powY(q);
              float Solid_powZ = allSolids.get_powZ(q);
              float Solid_scaleX = allSolids.get_scaleX(q);
              float Solid_scaleY = allSolids.get_scaleY(q);
              float Solid_scaleZ = allSolids.get_scaleZ(q);
              float Solid_rotX = allSolids.get_rotX(q);
              float Solid_rotY = allSolids.get_rotY(q);
              float Solid_rotZ = allSolids.get_rotZ(q);
              float Solid_value = allSolids.get_value(q);
  
              this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
              SOLID_added += 1;
            }
          }
  
  
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
  
            if ((0 <= f) && (f < allFaces.nodes.length)) {
  
              int[] newFace = {
              };
  
              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                int vNo = allFaces.nodes[f][j];
  
                int vertex_listed = -1;
  
                for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;
                  }
                }         
  
                if (vertex_listed == -1) {
                  int[] newVertexListed = {
                    vNo
                  };
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                  float x = allVertices[vNo][0];
                  float y = allVertices[vNo][1];
                  float z = allVertices[vNo][2];
  
                  int[] newVertexAdded = {
                    this.add_Vertex(x, y, z)
                  };
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                  vertex_listed = PolymeshVertices_OLD.length - 1;
                }
  
                int[] new_vertexItem = {
                  number_of_Vertices_before + vertex_listed
                };
  
                newFace = concat(newFace, new_vertexItem);
              }
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);
  
              this.add_Face(newFace);
              
              println("newFace");
              println(newFace);
            }
          }
        }
        
        if ((0 <= allGroups.Curves[OBJ_NUM][0]) && (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1])) { 
  
          int number_of_Vertices_before = allVertices.length;
  
          this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
          int new_OBJ_NUM = allGroups.num - 1;
  
          allGroups.PivotType[new_OBJ_NUM][0] = allGroups.PivotType[OBJ_NUM][0];
  
          for (int j = 0; j < allGroups.PivotXYZ[OBJ_NUM].length; j++) { 
            allGroups.PivotXYZ[new_OBJ_NUM][j] = allGroups.PivotXYZ[OBJ_NUM][j];
          }
  
          if ((0 <= allGroups.allModel1Ds[OBJ_NUM][1]) && (allGroups.allModel1Ds[OBJ_NUM][0] <= allGroups.allModel1Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.allModel1Ds[OBJ_NUM][0]; q <= allGroups.allModel1Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel1Ds.getX(q);
              float y = allModel1Ds.getY(q);
              float z = allModel1Ds.getZ(q);
  
              float d = allModel1Ds.getS(q);
              float rot = allModel1Ds.getR(q);
  
              int n = allModel1Ds.getType(q);
  
              int dMin = allModel1Ds.getDegreeMin(q);
  
              int dMax = allModel1Ds.getDegreeMax(q);
  
              int s = allModel1Ds.getSeed(q);
  
              float TrunkSize = allModel1Ds.getTrunkSize(q);
  
              float LeafSize = allModel1Ds.getLeafSize(q);
  
              if (produce_another_variation == 1) {
                randomSeed(millis());
  
                rot = random(360);
                s = int(random(32767));
              }
              allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
            }
          }
  
          if ((0 <= allGroups.allModel2Ds[OBJ_NUM][1]) && (allGroups.allModel2Ds[OBJ_NUM][0] <= allGroups.allModel2Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.allModel2Ds[OBJ_NUM][0]; q <= allGroups.allModel2Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel2Ds.getX(q);
              float y = allModel2Ds.getY(q);
              float z = allModel2Ds.getZ(q);
              float s = allModel2Ds.getS(q);
  
              int n = allModel2Ds.MAP[q];
  
              if (abs(n) > n1) {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("TREES", n, x, y, z, s);
              } else {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
              }
            }
          }
  
          if ((0 <= allGroups.allSolids[OBJ_NUM][1]) && (allGroups.allSolids[OBJ_NUM][0] <= allGroups.allSolids[OBJ_NUM][1])) { 
            for (int q = allGroups.allSolids[OBJ_NUM][0]; q <= allGroups.allSolids[OBJ_NUM][1]; q++) {
  
              float Solid_posX = allSolids.get_posX(q);
              float Solid_posY = allSolids.get_posY(q);
              float Solid_posZ = allSolids.get_posZ(q);
              float Solid_powX = allSolids.get_powX(q);
              float Solid_powY = allSolids.get_powY(q);
              float Solid_powZ = allSolids.get_powZ(q);
              float Solid_scaleX = allSolids.get_scaleX(q);
              float Solid_scaleY = allSolids.get_scaleY(q);
              float Solid_scaleZ = allSolids.get_scaleZ(q);
              float Solid_rotX = allSolids.get_rotX(q);
              float Solid_rotY = allSolids.get_rotY(q);
              float Solid_rotZ = allSolids.get_rotZ(q);
              float Solid_value = allSolids.get_value(q);
  
              this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
              SOLID_added += 1;
            }
          }
  
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
  
            if ((0 <= f) && (f < allCurves.nodes.length)) {
  
              int[] newCurve = {
              };
  
              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                int vNo = allCurves.nodes[f][j];
  
                int vertex_listed = -1;
  
                for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;
                  }
                }         
  
                if (vertex_listed == -1) {
                  int[] newVertexListed = {
                    vNo
                  };
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                  float x = allVertices[vNo][0];
                  float y = allVertices[vNo][1];
                  float z = allVertices[vNo][2];
  
                  int[] newVertexAdded = {
                    this.add_Vertex(x, y, z)
                  };
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                  vertex_listed = PolymeshVertices_OLD.length - 1;
                } 
  
                int[] new_vertexItem = {
                  number_of_Vertices_before + vertex_listed
                };
  
                newCurve = concat(newCurve, new_vertexItem);
              }
  
              defaultMaterial = allCurves.getMaterial(f);
              defaultTessellation = allCurves.getTessellation(f);
              defaultLayer = allCurves.getLayer(f);
              defaultVisibility = allCurves.getVisibility(f);
              defaultWeight = allCurves.getWeight(f);
              defaultClose = allCurves.getClose(f);
  
              this.add_Curve(newCurve);
            }
          }
        }        
      }
    
  
  
      // selecting new objetcs
  
      selectedGroup_ids = new int [0];
  
      for (int o = number_of_allGroups_before; o < allGroups.num; o++) {
  
        int[] newlyAddedGroup = {o};
  
        selectedGroup_ids = concat(selectedGroup_ids, newlyAddedGroup);
      }       
  
  
      if (SOLID_added != 0) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
    }
  }
  
  
  
  
  
  void group_Selection (int createNewGroup) { // if this option == 0 then the objects are added to the last group
  
  
    int run_process = 0;
  
    if (Current_ObjectCategory == ObjectCategory.SOLID) run_process = 1;
    if (Current_ObjectCategory == ObjectCategory.FACE) run_process = 1;
    if (Current_ObjectCategory == ObjectCategory.CURVE) run_process = 1;
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) run_process = 1;
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) run_process = 1;
  
    if (run_process == 1) {
  
      if (createNewGroup == 1) {
        float x = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
        float y = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][1];
        float z = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][2];
  
        float rot = CreateInput_Orientation;
        if (rot == 360) rot = WIN3D.RZ_Coordinate;
  
        this.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
      }
  
  
      int pre_addToLastGroup = addToLastGroup;
      addToLastGroup = 1;
  
  
      if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
  
        for (int o = 0; o < selectedallModel1Ds_ids.length; o++) {
  
          int OBJ_NUM = selectedallModel1Ds_ids[o];
  
          float x = allModel1Ds.getX(OBJ_NUM);
          float y = allModel1Ds.getY(OBJ_NUM);
          float z = allModel1Ds.getZ(OBJ_NUM);
          float d = allModel1Ds.getS(OBJ_NUM);
          float rot = allModel1Ds.getR(OBJ_NUM);
  
          int n = allModel1Ds.getType(OBJ_NUM);
          int dMin = allModel1Ds.getDegreeMin(OBJ_NUM);
          int dMax = allModel1Ds.getDegreeMax(OBJ_NUM);
          int s = allModel1Ds.getSeed(OBJ_NUM);
          float TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
          float LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
  
          allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
        }
      }  
  
      if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
  
        int n1 = allModel2Ds.PEOPLE_Files_Num;
  
        for (int o = 0; o < selectedallModel2Ds_ids.length; o++) {
  
          int OBJ_NUM = selectedallModel2Ds_ids[o];
  
          float x = allModel2Ds.getX(OBJ_NUM);
          float y = allModel2Ds.getY(OBJ_NUM);
          float z = allModel2Ds.getZ(OBJ_NUM);
          float s = allModel2Ds.getS(OBJ_NUM);
  
          int n = allModel2Ds.MAP[OBJ_NUM];
          if (abs(n) > n1) {
            allModel2Ds.add_single("TREES", n, x, y, z, s);
          } else {
            allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
          }
        }
      }
  
  
      if (Current_ObjectCategory == ObjectCategory.SOLID) {
  
        for (int o = 0; o < selectedSolid_ids.length; o++) {
  
          int OBJ_NUM = selectedSolid_ids[o];
  
          float Solid_posX = allSolids.get_posX(OBJ_NUM);
          float Solid_posY = allSolids.get_posY(OBJ_NUM);
          float Solid_posZ = allSolids.get_posZ(OBJ_NUM);
          float Solid_powX = allSolids.get_powX(OBJ_NUM);
          float Solid_powY = allSolids.get_powY(OBJ_NUM);
          float Solid_powZ = allSolids.get_powZ(OBJ_NUM);
          float Solid_scaleX = allSolids.get_scaleX(OBJ_NUM);
          float Solid_scaleY = allSolids.get_scaleY(OBJ_NUM);
          float Solid_scaleZ = allSolids.get_scaleZ(OBJ_NUM);
          float Solid_rotX = allSolids.get_rotX(OBJ_NUM);
          float Solid_rotY = allSolids.get_rotY(OBJ_NUM);
          float Solid_rotZ = allSolids.get_rotZ(OBJ_NUM);
          float Solid_value = allSolids.get_value(OBJ_NUM);
  
          this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
        }
      }
  
  
  
  
      if (Current_ObjectCategory == ObjectCategory.FACE) {
  
        for (int o = 0; o < selectedFace_ids.length; o++) {
  
          int f = selectedFace_ids[o];        
  
          int number_of_Vertices_before = allVertices.length;
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          if ((0 <= f) && (f < allFaces.nodes.length)) {
  
            int[] newFace = {
            };
  
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
  
              int vertex_listed = -1;
  
              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }         
  
              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                float x = allVertices[vNo][0];
                float y = allVertices[vNo][1];
                float z = allVertices[vNo][2];
  
                int[] newVertexAdded = {
                  this.add_Vertex(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                vertex_listed = PolymeshVertices_OLD.length - 1;
              } 
  
              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };
  
              newFace = concat(newFace, new_vertexItem);
            }
  
            defaultMaterial = allFaces.getMaterial(f);
            defaultTessellation = allFaces.getTessellation(f);
            defaultLayer = allFaces.getLayer(f);
            defaultVisibility = allFaces.getVisibility(f);        
  
            this.add_Face(newFace);
          }
        }
      }
  
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) {
  
        for (int o = 0; o < selectedCurve_ids.length; o++) {
  
          int f = selectedCurve_ids[o];        
  
          int number_of_Vertices_before = allVertices.length;
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          if ((0 <= f) && (f < allCurves.nodes.length)) {
  
            int[] newCurve = {
            };
  
            for (int j = 0; j < allCurves.nodes[f].length; j++) {
              int vNo = allCurves.nodes[f][j];
  
              int vertex_listed = -1;
  
              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }         
  
              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                float x = allVertices[vNo][0];
                float y = allVertices[vNo][1];
                float z = allVertices[vNo][2];
  
                int[] newVertexAdded = {
                  this.add_Vertex(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                vertex_listed = PolymeshVertices_OLD.length - 1;
              } 
  
              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };
  
              newCurve = concat(newCurve, new_vertexItem);
            }
  
            defaultMaterial = allCurves.getMaterial(f);
            defaultTessellation = allCurves.getTessellation(f);
            defaultLayer = allCurves.getLayer(f);
            defaultVisibility = allCurves.getVisibility(f);      
            defaultWeight = allCurves.getWeight(f);
            defaultClose = allCurves.getClose(f);          
  
            this.add_Curve(newCurve);
          }
        }
      }
  
  
  
      addToLastGroup = pre_addToLastGroup;
  
  
      this.delete_Selection();
  
  
      selectedGroup_ids = new int [1];
      selectedGroup_ids[0] = allGroups.num - 1;
  
  
      Current_ObjectCategory = ObjectCategory.GROUP;
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 731");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void ungroup_Selection () {
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
  
      selectedGroup_ids = sort(selectedGroup_ids);
  
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        allGroups.Faces[OBJ_NUM][0] = 0;
        allGroups.Faces[OBJ_NUM][1] = -1;
  
        allGroups.Curves[OBJ_NUM][0] = 0;
        allGroups.Curves[OBJ_NUM][1] = -1;
  
        allGroups.allModel1Ds[OBJ_NUM][0] = 0;
        allGroups.allModel1Ds[OBJ_NUM][1] = -1;
  
        allGroups.allModel2Ds[OBJ_NUM][0] = 0;
        allGroups.allModel2Ds[OBJ_NUM][1] = -1;
  
        allGroups.allSolids[OBJ_NUM][0] = 0;
        allGroups.allSolids[OBJ_NUM][1] = -1;
      }
  
      this.delete_Selection();
    }
  }
  
  
  void dettachFromallGroups_Selection () {
  
    this.group_Selection(1);
    this.ungroup_Selection();
  }
  
  
  void deleteEmptyallGroups_Scene () {
  
    int pre_Current_ObjectCategory = Current_ObjectCategory;
  
    Current_ObjectCategory = ObjectCategory.GROUP;
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {  
  
      selectedGroup_ids = new int [0];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        int notEmpty = 0;
  
        if ((0 <= allGroups.Faces[OBJ_NUM][0]) && (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.Curves[OBJ_NUM][0]) && (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.allModel1Ds[OBJ_NUM][0]) && (allGroups.allModel1Ds[OBJ_NUM][0] <= allGroups.allModel1Ds[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.allModel2Ds[OBJ_NUM][0]) && (allGroups.allModel2Ds[OBJ_NUM][0] <= allGroups.allModel2Ds[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.allSolids[OBJ_NUM][0]) && (allGroups.allSolids[OBJ_NUM][0] <= allGroups.allSolids[OBJ_NUM][1])) notEmpty = 1;
  
        if (notEmpty == 0) {
  
          int[] emptyGroup = {
            OBJ_NUM
          };
  
          selectedGroup_ids = concat(selectedGroup_ids, emptyGroup);
        }
      }
  
      this.delete_Selection();
    }
  
    Current_ObjectCategory = pre_Current_ObjectCategory;
  }
  
  
  
  void delete_Selection () {
  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }
  
  
  
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
  
      selectedCamera_ids = sort(selectedCamera_ids);
  
      for (int o = selectedCamera_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedCamera_ids[o];
  
        {
          float[][] startList = (float[][]) subset(allCameras.PPPSRRRF, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allCameras.PPPSRRRF, OBJ_NUM + 1);
  
          allCameras.PPPSRRRF = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allCameras.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allCameras.Type, OBJ_NUM + 1);
  
          allCameras.Type = (int[]) concat(startList, endList);
        }
  
        allCameras.num -= 1;
  
        if (OBJ_NUM == WIN3D.CurrentCamera) {
    
          WIN3D.CurrentCamera = 0;
          
          SOLARCHVISION_modify_Viewport_Title();
        }
      }
    }
  
  
  
    if (Current_ObjectCategory == ObjectCategory.SECTION) {
  
      selectedSection_ids = sort(selectedSection_ids);
  
      for (int o = selectedSection_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedSection_ids[o];
  
        {
          float[][] startList = (float[][]) subset(allSections.UVERAB, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSections.UVERAB, OBJ_NUM + 1);
  
          allSections.UVERAB = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.Type, OBJ_NUM + 1);
  
          allSections.Type = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.RES1, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.RES1, OBJ_NUM + 1);
  
          allSections.RES1 = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.RES2, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.RES2, OBJ_NUM + 1);
  
          allSections.RES2 = (int[]) concat(startList, endList);
        }
  
        {
          PImage[] startList = (PImage[]) subset(allSections.SolidImpact, 0, OBJ_NUM);
          PImage[] endList = (PImage[]) subset(allSections.SolidImpact, OBJ_NUM + 1);
  
          allSections.SolidImpact = (PImage[]) concat(startList, endList);
        }
  
        {
          PImage[][][] startList = (PImage[][][]) subset(allSections.SolarImpact, 0, OBJ_NUM);
          PImage[][][] endList = (PImage[][][]) subset(allSections.SolarImpact, OBJ_NUM + 1);
  
          allSections.SolarImpact = (PImage[][][]) concat(startList, endList);
        }        
  
        allSections.num -= 1;
      }
    }
  
  
  
  
  
  
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      selectedallModel1Ds_ids = sort(selectedallModel1Ds_ids);
  
      for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedallModel1Ds_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.allModel1Ds[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.allModel1Ds[q][1])) {
            if (allGroups.allModel1Ds[q][1] >= 0) allGroups.allModel1Ds[q][1] -= 1;
          } else if (allGroups.allModel1Ds[q][0] > OBJ_NUM) {
            if (allGroups.allModel1Ds[q][0] >= 0) allGroups.allModel1Ds[q][0] -= 1;
            if (allGroups.allModel1Ds[q][1] >= 0) allGroups.allModel1Ds[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allModel1Ds.XYZSR, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allModel1Ds.XYZSR, OBJ_NUM + 1);
  
          allModel1Ds.XYZSR = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.Type, OBJ_NUM + 1);
  
          allModel1Ds.Type = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.DegreeMin, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.DegreeMin, OBJ_NUM + 1);
  
          allModel1Ds.DegreeMin = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.DegreeMax, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.DegreeMax, OBJ_NUM + 1);
  
          allModel1Ds.DegreeMax = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.Seed, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.Seed, OBJ_NUM + 1);
  
          allModel1Ds.Seed = (int[]) concat(startList, endList);
        }
  
        {
          float[] startList = (float[]) subset(allModel1Ds.TrunkSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allModel1Ds.TrunkSize, OBJ_NUM + 1);
  
          allModel1Ds.TrunkSize = (float[]) concat(startList, endList);
        }
  
        {
          float[] startList = (float[]) subset(allModel1Ds.LeafSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allModel1Ds.LeafSize, OBJ_NUM + 1);
  
          allModel1Ds.LeafSize = (float[]) concat(startList, endList);
        }
  
        allModel1Ds.num -= 1;
      }
    }
  
  
  
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      selectedallModel2Ds_ids = sort(selectedallModel2Ds_ids);
  
      for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedallModel2Ds_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.allModel2Ds[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.allModel2Ds[q][1])) {
            if (allGroups.allModel2Ds[q][1] >= 0) allGroups.allModel2Ds[q][1] -= 1;
          } else if (allGroups.allModel2Ds[q][0] > OBJ_NUM) {
            if (allGroups.allModel2Ds[q][0] >= 0) allGroups.allModel2Ds[q][0] -= 1;
            if (allGroups.allModel2Ds[q][1] >= 0) allGroups.allModel2Ds[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allModel2Ds.XYZS, OBJ_NUM + 1);
  
          allModel2Ds.XYZS = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel2Ds.MAP, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel2Ds.MAP, OBJ_NUM + 1);
  
          allModel2Ds.MAP = (int[]) concat(startList, endList);
        }   
  
        allModel2Ds.num -= 1;
      }
  
    }
  
  
  
  
  
    if (Current_ObjectCategory == ObjectCategory.SOLID) {
  
      selectedSolid_ids = sort(selectedSolid_ids);
  
      for (int o = selectedSolid_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedSolid_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.allSolids[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.allSolids[q][1])) {
            if (allGroups.allSolids[q][1] >= 0) allGroups.allSolids[q][1] -= 1;
          } else if (allGroups.allSolids[q][0] > OBJ_NUM) {
            if (allGroups.allSolids[q][0] >= 0) allGroups.allSolids[q][0] -= 1;
            if (allGroups.allSolids[q][1] >= 0) allGroups.allSolids[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allSolids.DEF, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSolids.DEF, OBJ_NUM + 1);
  
          allSolids.DEF = (float[][]) concat(startList, endList);
        }
      }
    }
  
  
  
  
    if (Current_ObjectCategory == ObjectCategory.FACE) {
  
      selectedFace_ids = sort(selectedFace_ids);
  
      for (int o = selectedFace_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedFace_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Faces[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Faces[q][1])) {
            if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
          } else if (allGroups.Faces[q][0] > OBJ_NUM) {
            if (allGroups.Faces[q][0] >= 0) allGroups.Faces[q][0] -= 1;
            if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
          }
        }
  
  
        {
          int[][] startList = (int[][]) subset(allFaces.nodes, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces.nodes, OBJ_NUM + 1);
  
          allFaces.nodes = (int[][]) concat(startList, endList);
        }
  
        {
          int[][] startList = (int[][]) subset(allFaces.options, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces.options, OBJ_NUM + 1);
  
          allFaces.options = (int[][]) concat(startList, endList);
        }
      }
    }
  
  
    if (Current_ObjectCategory == ObjectCategory.CURVE) {
  
      selectedCurve_ids = sort(selectedCurve_ids);
  
      for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedCurve_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Curves[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Curves[q][1])) {
            if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
          } else if (allGroups.Curves[q][0] > OBJ_NUM) {
            if (allGroups.Curves[q][0] >= 0) allGroups.Curves[q][0] -= 1;
            if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
          }
        }
  
  
        {
          int[][] startList = (int[][]) subset(allCurves.nodes, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allCurves.nodes, OBJ_NUM + 1);
  
          allCurves.nodes = (int[][]) concat(startList, endList);
        }
  
        {
          int[][] startList = (int[][]) subset(allCurves.options, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allCurves.options, OBJ_NUM + 1);
  
          allCurves.options = (int[][]) concat(startList, endList);
        }
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
      
      /////////////////////////////
      //SOLARCHVISION_hold_project();
      /////////////////////////////    
      
      
      
      this.convert_allGroups_to_Vertices(); // finding vertices so that we could delete the isolated ones later  
  
      selectedGroup_ids = sort(selectedGroup_ids);
  
      boolean allSolids_updated = false;  
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        int startFace = allGroups.Faces[OBJ_NUM][0];
        int endFace = allGroups.Faces[OBJ_NUM][1];
  
        {
  
          if ((0 <= startFace) && (startFace <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] -= 1 + endFace - startFace;
  
                if (allGroups.Faces[i][j] < 0) allGroups.Faces[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.Faces, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Faces, OBJ_NUM + 1);
  
          allGroups.Faces = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startFace) && (startFace <= endFace)) {
          {
            int[][] startList = (int[][]) subset(allFaces.nodes, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces.nodes, endFace + 1);
  
            allFaces.nodes = (int[][]) concat(startList, endList);
          }
  
          {
            int[][] startList = (int[][]) subset(allFaces.options, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces.options, endFace + 1);
  
            allFaces.options = (int[][]) concat(startList, endList);
          }
        }
  
  
        int startCurve = allGroups.Curves[OBJ_NUM][0];
        int endCurve = allGroups.Curves[OBJ_NUM][1];
  
        {
  
          if ((0 <= startCurve) && (startCurve <= endCurve)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Curves[i][j] -= 1 + endCurve - startCurve;
  
                if (allGroups.Curves[i][j] < 0) allGroups.Curves[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.Curves, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Curves, OBJ_NUM + 1);
  
          allGroups.Curves = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startCurve) && (startCurve <= endCurve)) {
          {
            int[][] startList = (int[][]) subset(allCurves.nodes, 0, startCurve);
            int[][] endList = (int[][]) subset(allCurves.nodes, endCurve + 1);
  
            allCurves.nodes = (int[][]) concat(startList, endList);
          }
  
          {
            int[][] startList = (int[][]) subset(allCurves.options, 0, startCurve);
            int[][] endList = (int[][]) subset(allCurves.options, endCurve + 1);
  
            allCurves.options = (int[][]) concat(startList, endList);
          }
        }
  
  
        int startallModel1Ds = allGroups.allModel1Ds[OBJ_NUM][0];
        int endallModel1Ds = allGroups.allModel1Ds[OBJ_NUM][1];
  
        {
  
          if ((0 <= startallModel1Ds) && (startallModel1Ds <= endallModel1Ds)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
  
                allGroups.allModel1Ds[i][j] -= 1 + endallModel1Ds - startallModel1Ds;
  
                if (allGroups.allModel1Ds[i][j] < 0) allGroups.allModel1Ds[i][j] = 0;
              }
            }
          }   
  
          int[][] startList = (int[][]) subset(allGroups.allModel1Ds, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.allModel1Ds, OBJ_NUM + 1);
  
          allGroups.allModel1Ds = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startallModel1Ds) && (startallModel1Ds <= endallModel1Ds)) {
  
          {
            float[][] startList = (float[][]) subset(allModel1Ds.XYZSR, 0, startallModel1Ds);
            float[][] endList = (float[][]) subset(allModel1Ds.XYZSR, endallModel1Ds + 1);
  
            allModel1Ds.XYZSR = (float[][]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.Type, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.Type, endallModel1Ds + 1);
  
            allModel1Ds.Type = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.DegreeMin, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.DegreeMin, endallModel1Ds + 1);
  
            allModel1Ds.DegreeMin = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.DegreeMax, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.DegreeMax, endallModel1Ds + 1);
  
            allModel1Ds.DegreeMax = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.Seed, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.Seed, endallModel1Ds + 1);
  
            allModel1Ds.Seed = (int[]) concat(startList, endList);
          }
  
          {
            float[] startList = (float[]) subset(allModel1Ds.TrunkSize, 0, startallModel1Ds);
            float[] endList = (float[]) subset(allModel1Ds.TrunkSize, endallModel1Ds + 1);
  
            allModel1Ds.TrunkSize = (float[]) concat(startList, endList);
          }
  
          {
            float[] startList = (float[]) subset(allModel1Ds.LeafSize, 0, startallModel1Ds);
            float[] endList = (float[]) subset(allModel1Ds.LeafSize, endallModel1Ds + 1);
  
            allModel1Ds.LeafSize = (float[]) concat(startList, endList);
          }
  
  
          allModel1Ds.num = allModel1Ds.XYZSR.length;
        }
  
        int startallModel2Ds = allGroups.allModel2Ds[OBJ_NUM][0];
        int endallModel2Ds = allGroups.allModel2Ds[OBJ_NUM][1];
  
        {
  
          if ((0 <= startallModel2Ds) && (startallModel2Ds <= endallModel2Ds)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
  
                allGroups.allModel2Ds[i][j] -= 1 + endallModel2Ds - startallModel2Ds;
  
                if (allGroups.allModel2Ds[i][j] < 0) allGroups.allModel2Ds[i][j] = 0;
              }
            }
          }   
  
          int[][] startList = (int[][]) subset(allGroups.allModel2Ds, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.allModel2Ds, OBJ_NUM + 1);
  
          allGroups.allModel2Ds = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startallModel2Ds) && (startallModel2Ds <= endallModel2Ds)) {
  
          {
            float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, startallModel2Ds);
            float[][] endList = (float[][]) subset(allModel2Ds.XYZS, endallModel2Ds + 1);
  
            allModel2Ds.XYZS = (float[][]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel2Ds.MAP, 0, startallModel2Ds);
            int[] endList = (int[]) subset(allModel2Ds.MAP, endallModel2Ds + 1);
  
            allModel2Ds.MAP = (int[]) concat(startList, endList);
          }
  
          allModel2Ds.num = allModel2Ds.XYZS.length;
        }
  
        int startSolid = allGroups.allSolids[OBJ_NUM][0];
        int endSolid = allGroups.allSolids[OBJ_NUM][1];
  
        {
          if ((0 <= startSolid) && (startSolid <= endSolid)) {
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
                allGroups.allSolids[i][j] -= 1 + endSolid - startSolid;
  
                if (allGroups.allSolids[i][j] < 0) allGroups.allSolids[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.allSolids, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.allSolids, OBJ_NUM + 1);
  
          allGroups.allSolids = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startSolid) && (startSolid <= endSolid)) {
  
          float[][] startList = (float[][]) subset(allSolids.DEF, 0, startSolid);
          float[][] endList = (float[][]) subset(allSolids.DEF, endSolid + 1);
  
          allSolids.DEF = (float[][]) concat(startList, endList);
  
          allSolids_updated = true;
        }
  
  
        {
          float[][] startList = (float[][]) subset(allGroups.PivotXYZ, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allGroups.PivotXYZ, OBJ_NUM + 1);
  
          allGroups.PivotXYZ = (float[][]) concat(startList, endList);
        } 
  
        {
          int[][] startList = (int[][]) subset(allGroups.PivotType, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.PivotType, OBJ_NUM + 1);
  
          allGroups.PivotType = (int[][]) concat(startList, endList);
        } 
  
        allGroups.num -= 1;
      }
      
      if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
  
    }
  
  
  
  
  
    if ((Current_ObjectCategory == ObjectCategory.VERTEX) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.GROUP)) { 
  
      println("deleteIsolatedVerticesSelection");
  
      this.deleteIsolatedVertices_Selection();
    }  
  
  
  
  
    if (allCameras.num == 0) {
      this.add_veryFirstCamera();
    }
  
    this.deselect_All();
  }
  
  
  void deleteIsolatedVertices_Selection () { 
  
    selectedVertex_ids = sort(selectedVertex_ids);
  
    for (int o = selectedVertex_ids.length - 1; o >= 0; o--) { 
  
      int vNo = selectedVertex_ids[o];
  
      int found = -1;
      
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
  
              found = 1;
            }
  
            if (found != -1) break;
          }
  
          if (found != -1) break;
        }  
      }
      
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
  
              found = 1;
            }
  
            if (found != -1) break;
          }
  
          if (found != -1) break;
        }        
      }
      
  
      if (found == -1) {
  
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {
  
              allFaces.nodes[i][j] -= 1;
            }
          }
        }             
  
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {
  
              allCurves.nodes[i][j] -= 1;
            }
          }
        }  
  
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);
  
        allVertices = (float[][]) concat(startList, endList);
      }
    }
  
    selectedVertex_ids = new int [0];
  }
  
  
  void deleteIsolatedVertices_Scene () {
  
    for (int vNo = allVertices.length - 1; vNo >= 0; vNo--) {
  
      int found = -1;
  
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        {
          float[][] startList = (float[][]) subset(allVertices, 0, vNo);
          float[][] endList = (float[][]) subset(allVertices, vNo + 1);
  
          allVertices = (float[][]) concat(startList, endList);
        }
  
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {
  
              allFaces.nodes[i][j] -= 1;
            }
          }
        }
        
        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {
  
              allCurves.nodes[i][j] -= 1;
            }
          }
        }      
      }
  
  
    } 
  
    selectedVertex_ids = new int [0];
  }
  
  
  void selectIsolatedVertices_Scene () {
  
    selectedVertex_ids = new int [0];
  
    for (int vNo = allVertices.length - 1; vNo >= 0; vNo--) { 
  
      int found = -1;
  
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
  
        int[] newIsolatedVertex = {
          vNo
        };
  
        selectedVertex_ids = concat(selectedVertex_ids, newIsolatedVertex);
  
  
      }
    } 
  
    Current_ObjectCategory = ObjectCategory.VERTEX; 
    UI_BAR_b_update = true;
  
    println("SOLARCHVISION_calculate_selection_BoundingBox 31");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
  
  
  
  void selectNearVertices_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      selectedVertex_ids = sort(selectedVertex_ids);
  
      int[] pre_selectedVertex_ids = selectedVertex_ids;
  
      for (int vNo = allVertices.length - 1; vNo >= 0; vNo--) {
  
        int isNearEnough = -1;
  
        for (int i = 0; i < pre_selectedVertex_ids.length; i++) {
  
          int q = pre_selectedVertex_ids[i];
  
          int found = -1;
  
          for (int j = 0; j < selectedVertex_ids.length; j++) {
  
            if (vNo == selectedVertex_ids[j]) {
  
              found = 1;
  
              break;
            }
          } 
  
          if (found == -1) { 
  
            float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
            if (d <= ModifyInput_WeldTreshold) { 
  
              isNearEnough = 1;
  
              break;
            }
          }
        }
  
  
        if (isNearEnough == 1) {
  
          int[] newVertex_id = {
            vNo
          };
  
          selectedVertex_ids = concat(selectedVertex_ids, newVertex_id);
        }
      } 
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 32");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void weldSceneVertices_Selection (float max_distance) {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      selectedVertex_ids = sort(selectedVertex_ids);
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = selectedVertex_ids[o];
  
        int found = -1;
        
        if (found != -1) {
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
  
              int q = allFaces.nodes[i][j];
  
              if (q > vNo) { // it is faster than (q != vNo)
  
                float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
                if (d <= max_distance) { 
  
                  allFaces.nodes[i][j] = vNo;
  
                  found = q;
                }
              }
            }
          }
        }
  
        if (found != -1) {
          for (int i = 0; i < allCurves.nodes.length; i++) { 
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
  
              int q = allCurves.nodes[i][j];
  
              if (q > vNo) { // it is faster than (q != vNo)
  
                float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
                if (d <= max_distance) { 
  
                  allCurves.nodes[i][j] = vNo;
  
                  found = q;
                }
              }
            }
          }
        }
  
        if (found != -1) {
  
          int q = found;
  
          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);
  
            allVertices = (float[][]) concat(startList, endList);
          }
  
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {
  
                allFaces.nodes[i][j] -= 1;
              }
            }
          }
          
          for (int i = 0; i < allCurves.nodes.length; i++) {
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {
  
                allCurves.nodes[i][j] -= 1;
              }
            }
          }          
        }
      }
  
      selectedVertex_ids = new int [0];
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 33");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void weldObjectsVertices_Selection (float max_distance) {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      this.convert_Vertices_to_Faces();
      this.convert_Vertices_to_Curves();
  
      selectedVertex_ids = sort(selectedVertex_ids);
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {  
  
        int vNo = selectedVertex_ids[o];
  
        int found = -1;
  
        for (int m = o - 1; m >= 0; m--) {
  
          int q = selectedVertex_ids[m];
  
          float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
          if (d <= max_distance) { 
  
            for (int i = 0; i < selectedFace_ids.length; i++) {
              int f = selectedFace_ids[i];
  
              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                if (allFaces.nodes[f][j] == q) {
  
                  allFaces.nodes[f][j] = vNo;
  
                  found = q;
                }
              }
            }
            
            for (int i = 0; i < selectedCurve_ids.length; i++) {
              int f = selectedCurve_ids[i];
  
              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                if (allCurves.nodes[f][j] == q) {
  
                  allCurves.nodes[f][j] = vNo;
  
                  found = q;
                }
              }
            }              
          }
        }
  
        if (found != -1) {
  
          int q = found;
  
          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);
  
            allVertices = (float[][]) concat(startList, endList);
          }
  
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {
  
                allFaces.nodes[i][j] -= 1;
              }
            }
          }
          
          for (int i = 0; i < allCurves.nodes.length; i++) { 
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {
  
                allCurves.nodes[i][j] -= 1;
              }
            }
          }          
        }
      }
  
      selectedVertex_ids = new int [0];
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 34");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void repositionVertices_Selection () {
  
    if (Current_ObjectCategory == ObjectCategory.VERTEX) { 
  
      SOLARCHVISION_calculate_selection_BoundingBox();
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) { 
  
        int vNo = selectedVertex_ids[o];
  
        allVertices[vNo][0] = SOLARCHVISION_selection_BoundingBox[1][0]; // center
        allVertices[vNo][1] = SOLARCHVISION_selection_BoundingBox[1][1]; // center
        allVertices[vNo][2] = SOLARCHVISION_selection_BoundingBox[1][2]; // center
      } 
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 35");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void separateVertices_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      selectedVertex_ids = sort(selectedVertex_ids);
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) { 
  
        int vNo = selectedVertex_ids[o];
  
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
  
            if (allFaces.nodes[i][j] == vNo) { 
  
              allFaces.nodes[i][j] = this.add_Vertex(allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
            }
          }
        }
        
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
  
            if (allCurves.nodes[i][j] == vNo) { 
  
              allCurves.nodes[i][j] = this.add_Vertex(allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
            }
          }
        }        
      }
  
  
      selectedVertex_ids = new int [0];
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 36");
      SOLARCHVISION_calculate_selection_BoundingBox();
    }
  }
  
  
  
  void insertCornerOpennings_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) {
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
  
                  new_Vertices[i][j] = pow(ModifyInput_OpenningArea, 0.5) * base_Vertices[i][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_Vertex_ids = new int [allFaces.nodes[f].length];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_Vertex_ids[s] = this.add_Vertex(new_Vertices[s][0], new_Vertices[s][1], new_Vertices[s][2]);
              } 
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);              
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace = {
                  {
                    new_Vertex_ids[s], allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_Vertex_ids[s_next]
                  }
                };
                int[][] newFace_MTLVGC = {
                  {
                    defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                  }
                }; 
  
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC);
              }
  
  
              { // modifying the base face to shape the openning  
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_Vertex_ids[s];
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 37");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void insertParallelOpennings_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) {
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += 2 * allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += 2 * allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) { 
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += 2 * allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
  
              float[][] new_A_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_B_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_A_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * 0.5 * (base_Vertices[s_prev][j] + base_Vertices[s][j]);
                  new_B_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * 0.5 * (base_Vertices[s_next][j] + base_Vertices[s][j]);
  
                  new_CenterVertices[s][j] = pow(ModifyInput_OpenningArea, 0.5) * base_Vertices[s][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_A_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge (1/3)
              int[] new_B_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the other edge (2/3)
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_A_EdgeVertex_ids[s] = this.add_Vertex(new_A_EdgeVertices[s][0], new_A_EdgeVertices[s][1], new_A_EdgeVertices[s][2]); 
                new_B_EdgeVertex_ids[s] = this.add_Vertex(new_B_EdgeVertices[s][0], new_B_EdgeVertices[s][1], new_B_EdgeVertices[s][2]);
                new_CenterVertex_ids[s] = this.add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              }               
  
  
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                {
                  int[][] newFace = {
                    {
                      allFaces.nodes[f][s], new_B_EdgeVertex_ids[s], new_CenterVertex_ids[s], new_A_EdgeVertex_ids[s]
                    }
                  };
                  int[][] newFace_MTLVGC = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                    }
                  }; 
  
                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC);
                }   
  
                {
                  int[][] newFace = {
                    {
                      new_B_EdgeVertex_ids[s], new_A_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                    }
                  };
                  int[][] newFace_MTLVGC = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                    }
                  }; 
  
                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC);
                }
              }
  
  
              { // modifying the base face to shape the openning  
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 38");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void insertRotatedOpennings_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) {
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) {
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * base_Vertices[s_prev][j];
  
                  new_CenterVertices[s][j] = pow(ModifyInput_OpenningArea, 0.5) * new_EdgeVertices[s][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
                new_CenterVertex_ids[s] = this.add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              } 
  
  
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                  }
                };
                int[][] newFace_MTLVGC = {
                  {
                    defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                  }
                }; 
  
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC);
              }
  
  
              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 39");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void insertEdgeOpennings_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) {
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * base_Vertices[s_prev][j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              } 
  
  
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next]
                  }
                };
                int[][] newFace_MTLVGC = {
                  {
                    defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                  }
                }; 
  
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC);
              }
  
  
              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_EdgeVertex_ids[s];
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 40");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateRowsColumnsFaceSelection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            if (allFaces.nodes[f].length == 4) {
  
              for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroups.Faces[i][j] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1;
                }
              }  
              allGroups.Faces[OBJ_NUM][1] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1; // because adding the faces also changes the end pointer of the same object 
  
              for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
                if (new_selectedFace_ids[p] != 0) {
  
                  if (new_selectedFace_ids[p] > f) {  
                    new_selectedFace_ids[p] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1;
                  }
                }
              }             
  
  
              int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces = new int [0][0];
              int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
              int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_MTLVGC = new int [0][0];
              int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
              { 
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                  }
                }
  
  
  
                float[][] new_EdgeVertices = new float [(ModifyInput_TessellateColumns + 1) * (ModifyInput_TessellateRows + 1)][3];
  
                for (int i = 0; i <= ModifyInput_TessellateColumns; i++) {
  
                  for (int j = 0; j <= ModifyInput_TessellateRows; j++) {
  
                    int s = i * (ModifyInput_TessellateRows + 1) + j;
  
                    for (int k = 0; k < 3; k++) {
  
                      float u = i / float(ModifyInput_TessellateColumns);
                      float v = j / float(ModifyInput_TessellateRows);
  
                      new_EdgeVertices[s][k] = SOLARCHVISION_Bilinear(base_Vertices[0][k], base_Vertices[1][k], base_Vertices[2][k], base_Vertices[3][k], u, v);
                    }
                  }
                }
  
                int[] new_EdgeVertex_ids = new int [(ModifyInput_TessellateColumns + 1) * (ModifyInput_TessellateRows + 1)]; // on the edge
  
                for (int i = 0; i <= ModifyInput_TessellateColumns; i++) {
  
                  for (int j = 0; j <= ModifyInput_TessellateRows; j++) {
  
                    int s = i * (ModifyInput_TessellateRows + 1) + j;
  
                    if ((i == 0) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][0];
                    } else if ((i == ModifyInput_TessellateColumns) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][1];
                    } else if ((i == ModifyInput_TessellateColumns) && (j == ModifyInput_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][2];
                    } else if ((i == 0) && (j == ModifyInput_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][3];
                    } else {
                      new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                    }
                  }
                }
  
  
                defaultMaterial = allFaces.getMaterial(f);
                defaultTessellation = allFaces.getTessellation(f);
                defaultLayer = allFaces.getLayer(f);
                defaultVisibility = allFaces.getVisibility(f);
  
                for (int i = 0; i < ModifyInput_TessellateColumns; i++) {
  
                  for (int j = 0; j < ModifyInput_TessellateRows; j++) {
  
                    int s = i * ModifyInput_TessellateRows + j;  // number of face
  
                    // number of vertices
                    int s00 = i * (ModifyInput_TessellateRows + 1) + j; 
                    int s01 = s00 + 1;
                    int s10 = s00 + (ModifyInput_TessellateRows + 1);
                    int s11 = s00 + (ModifyInput_TessellateRows + 1) + 1;
  
                    int[][] newFace = {
                      {
                        new_EdgeVertex_ids[s00], new_EdgeVertex_ids[s10], new_EdgeVertex_ids[s11], new_EdgeVertex_ids[s01]
                      }
                    };
                    int[][] newFace_MTLVGC = {
                      {
                        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                      }
                    }; 
  
                    midList_Faces = (int[][]) concat(midList_Faces, newFace);
                    midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC); 
  
                    if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                      int[] newFace_number = {
                        f + s
                      }; 
                      new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, newFace_number);
                    }
                  }
                }
              }
  
              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
              allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_ids.length; i++) {
                  selectedFace_ids[i] -= 1;
                }              
  
                int[] startList = (int[]) subset(selectedFace_ids, 0, q);
                int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
                selectedFace_ids = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 41");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateRectangularFaceSelection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) {
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += allFaces.nodes[f].length - 1;
                }
              }
            }             
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = new int [0][0];
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = new int [0][0];
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
                  new_EdgeVertices[s][j] = 0.5 * base_Vertices[s][j] + 0.5 * base_Vertices[s_prev][j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              } 
  
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);              
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_MTLVGC = {
                  {
                    defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                  }
                }; 
  
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC); 
  
                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_number = {
                    f + s
                  }; 
                  new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, newFace_number);
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 42");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateTriangularFaceSelection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) {
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
              if (new_selectedFace_ids[p] != 0) {
  
                if (new_selectedFace_ids[p] > f) {  
                  new_selectedFace_ids[p] += allFaces.nodes[f].length - 1;
                }
              }
            }             
  
  
            int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces = new int [0][0];
            int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_MTLVGC = new int [0][0];
            int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                }
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
  
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
              defaultMaterial = allFaces.getMaterial(f);
              defaultTessellation = allFaces.getTessellation(f);
              defaultLayer = allFaces.getLayer(f);
              defaultVisibility = allFaces.getVisibility(f);                
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace = {
                  {
                    allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_MTLVGC = {
                  {
                    defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                  }
                }; 
  
                midList_Faces = (int[][]) concat(midList_Faces, newFace);
                midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC); 
  
                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_number = {
                    f + s
                  }; 
                  new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, newFace_number);
                }
              }
            }
  
            startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
            startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
            allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 43");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void forceTriangulateFaces_Selection () {  
    
    // this function is the copy of above function (this.tessellateTriangularFaceSelection) 
    // but only processed the faces with degrees above 3.
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = selectedFace_ids;
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) {
  
          int f = selectedFace_ids[q];
  
          if (allFaces.nodes[f].length > 3) { // <<<<<<<<<<< the condition to perform the process 
  
            int startFace = allGroups.Faces[OBJ_NUM][0];
            int endFace = allGroups.Faces[OBJ_NUM][1];          
  
            if ((startFace <= f) && (f <= endFace)) {
  
              for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
                }
              }  
              allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
              for (int p = new_selectedFace_ids.length - 1; p >= 0; p--) {
  
                if (new_selectedFace_ids[p] != 0) {
  
                  if (new_selectedFace_ids[p] > f) {  
                    new_selectedFace_ids[p] += allFaces.nodes[f].length - 1;
                  }
                }
              }             
  
              int[][] startList_Faces = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces = new int [0][0];
              int[][] endList_Faces = (int[][]) subset(allFaces.nodes, f + 1);
  
  
              int[][] startList_Faces_MTLVGC = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_MTLVGC = new int [0][0];
              int[][] endList_Faces_MTLVGC = (int[][]) subset(allFaces.options, f + 1);
  
              { 
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces.nodes[f][i])][j];
                  }
                }
  
                float[] G_face = {
                  0, 0, 0
                };  
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                  }
                }
  
  
                int new_CenterVertex_number = 0; // at the center
                new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
                defaultMaterial = allFaces.getMaterial(f);
                defaultTessellation = allFaces.getTessellation(f);
                defaultLayer = allFaces.getLayer(f);
                defaultVisibility = allFaces.getVisibility(f);                
  
                for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                  int s_next = (s + 1) % allFaces.nodes[f].length;
  
                  int[][] newFace = {
                    {
                      allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                    }
                  };
                  int[][] newFace_MTLVGC = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
                    }
                  }; 
  
                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLVGC = (int[][]) concat(midList_Faces_MTLVGC, newFace_MTLVGC); 
  
                  if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                    int[] newFace_number = {
                      f + s
                    }; 
                    new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, newFace_number);
                  }
                }
              }
  
              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLVGC = (int[][]) concat(startList_Faces_MTLVGC, midList_Faces_MTLVGC);  
  
              allFaces.nodes = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces.options = (int[][]) concat(startList_Faces_MTLVGC, endList_Faces_MTLVGC);           
            }           
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < selectedFace_ids.length; i++) {
                selectedFace_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(selectedFace_ids, 0, q);
              int[] endList = (int[]) subset(selectedFace_ids, q + 1);
  
              selectedFace_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      selectedFace_ids = new_selectedFace_ids;
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 43bbb");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void autoNormalFaces_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
  
      if ((Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.GROUP)) {
  
  
        for (int o = 0; o < selectedFace_ids.length; o++) {
    
          int f = selectedFace_ids[o];     
        
          int n = allFaces.nodes[f].length;
    
          if (n > 2) {
            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            }; 
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allVertices[tmpFace[j]][0] / float(n); 
              G[1] += allVertices[tmpFace[j]][1] / float(n);
              G[2] += allVertices[tmpFace[j]][2] / float(n);
            }  
            
            PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
            PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);
    
            PVector GAxGB = AG.cross(BG);
  
            float[] ray_start = {G[0], G[1], G[2]};
            float[] ray_direction = {GAxGB.x, GAxGB.y, GAxGB.z};
  
            float[] RxP = SOLARCHVISION_intersect_selectedFaces(ray_start, ray_direction);
  
            if (RxP[0] >= 0) {
  
              for (int j = 0; j < n; j++) {
                allFaces.nodes[f][j] = tmpFace[n - j - 1];
              }
            }
          }
        }
      }
  
      Current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 3700");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void extrudeFaceEdges_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Faces();    
  
        selectedFace_ids = sort(selectedFace_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        selectedFace_ids = sort(selectedFace_ids);
  
        this.convert_Faces_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = {};
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
        for (int q = selectedFace_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedFace_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            float[][] top_Vertices = new float [allFaces.nodes[f].length][3];
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
              int vNo = allFaces.nodes[f][s];
  
              base_Vertices[s][0] = allVertices[vNo][0];
              base_Vertices[s][1] = allVertices[vNo][1];
              base_Vertices[s][2] = allVertices[vNo][2];
  
              top_Vertices[s][0] = allVertices[vNo][0];
              top_Vertices[s][1] = allVertices[vNo][1];
              top_Vertices[s][2] = allVertices[vNo][2];
            }
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allFaces.nodes[f].length;
              int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = SOLARCHVISION_fn_normalize(W);
  
              top_Vertices[s][0] += W[0] * ModifyInput_OpenningDepth;
              top_Vertices[s][1] += W[1] * ModifyInput_OpenningDepth;
              top_Vertices[s][2] += W[2] * ModifyInput_OpenningDepth;
            }  
  
            int[] base_Vertex_ids = new int [allFaces.nodes[f].length];
            int[] top_Vertex_ids = new int [allFaces.nodes[f].length];
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              base_Vertex_ids[s] = this.add_Vertex(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
              top_Vertex_ids[s] = this.add_Vertex(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }        
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allFaces.nodes[f].length;
  
              if (ModifyInput_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
              } else {
                int[][] newFace = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
              }       
  
              int[][] newFace_MTLVGC = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_MTLVGC);
            }  
  
            { // adding the cap
              int[][] newFace = {
                top_Vertex_ids
              };  
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);         
  
              int[][] newFace_MTLVGC = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_MTLVGC);  
  
              int[] lastFace = {
                allFaces.nodes.length - 1
              };
  
              new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, lastFace);
            }
  
            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }
  
      selectedFace_ids = new_selectedFace_ids;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 101");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void extrudeCurveEdges_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.CURVE)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        selectedGroup_ids = sort(selectedGroup_ids);
  
        this.convert_allGroups_to_Curves();    
  
        selectedCurve_ids = sort(selectedCurve_ids);
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        selectedCurve_ids = sort(selectedCurve_ids);
  
        this.convert_Curves_to_allGroups();    
  
        selectedGroup_ids = sort(selectedGroup_ids);
      }
  
      int[] new_selectedFace_ids = {};
  
      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = selectedGroup_ids[o];
  
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
        for (int q = selectedCurve_ids.length - 1; q >= 0; q--) { 
  
          int f = selectedCurve_ids[q];
  
          int startCurve = allGroups.Curves[OBJ_NUM][0];
          int endCurve = allGroups.Curves[OBJ_NUM][1];          
  
          if ((startCurve <= f) && (f <= endCurve)) {
  
            float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
            float[][] top_Vertices = new float [allCurves.nodes[f].length][3];
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
              int vNo = allCurves.nodes[f][s];
  
              base_Vertices[s][0] = allVertices[vNo][0];
              base_Vertices[s][1] = allVertices[vNo][1];
              base_Vertices[s][2] = allVertices[vNo][2];
  
              top_Vertices[s][0] = allVertices[vNo][0];
              top_Vertices[s][1] = allVertices[vNo][1];
              top_Vertices[s][2] = allVertices[vNo][2];
            }
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allCurves.nodes[f].length;
              int s_prev = (s + allCurves.nodes[f].length - 1) % allCurves.nodes[f].length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = SOLARCHVISION_fn_normalize(W);
  
              top_Vertices[s][0] += W[0] * ModifyInput_OpenningDepth;
              top_Vertices[s][1] += W[1] * ModifyInput_OpenningDepth;
              top_Vertices[s][2] += W[2] * ModifyInput_OpenningDepth;
            }  
  
            int[] base_Vertex_ids = new int [allCurves.nodes[f].length];
            int[] top_Vertex_ids = new int [allCurves.nodes[f].length];
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              base_Vertex_ids[s] = this.add_Vertex(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
              top_Vertex_ids[s] = this.add_Vertex(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }        
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allCurves.nodes[f].length;
  
              if (ModifyInput_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
              } else {
                int[][] newFace = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
              }       
  
              int[][] newFace_MTLVGC = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_MTLVGC);
            }  
  
            { // adding the cap
              int[][] newFace = {
                top_Vertex_ids
              };  
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);         
  
              int[][] newFace_MTLVGC = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_MTLVGC);  
  
              int[] lastFace = {
                allFaces.nodes.length - 1
              };
  
              new_selectedFace_ids = (int[]) concat(new_selectedFace_ids, lastFace);
            }
  
            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }
  
  
      selectedFace_ids = new_selectedFace_ids;
      
      Current_ObjectCategory = ObjectCategory.FACE;
      UI_BAR_b_update = true;
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 101b");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  void offsetVertices_Selection (int _type, float _amount) {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (Current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      float[][] selectedVertex_offsetValues = new float [selectedVertex_ids.length][3];
      int[] selectedVertex_offsetNum = new int [selectedVertex_ids.length];
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) { 
        selectedVertex_offsetValues[o][0] = 0;
        selectedVertex_offsetValues[o][1] = 0;
        selectedVertex_offsetValues[o][2] = 0;
  
        selectedVertex_offsetNum[o] = 0;
      }
  
      selectedVertex_ids = sort(selectedVertex_ids);
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = selectedVertex_ids[o];
  
        for (int f = 0; f < allFaces.nodes.length; f++) {
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
            if (allFaces.nodes[f][j] == vNo) { 
  
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                base_Vertices[s][0] = allVertices[allFaces.nodes[f][s]][0];
                base_Vertices[s][1] = allVertices[allFaces.nodes[f][s]][1];
                base_Vertices[s][2] = allVertices[allFaces.nodes[f][s]][2];
              }
  
              for (int s = 0; s < base_Vertices.length; s++) {
  
                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
                PVector UV = new PVector(0, 0, 0);
  
                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);
  
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = SOLARCHVISION_fn_normalize(W);
  
                selectedVertex_offsetValues[o][0] += W[0] * _amount;
                selectedVertex_offsetValues[o][1] += W[1] * _amount;
                selectedVertex_offsetValues[o][2] += W[2] * _amount;
  
                selectedVertex_offsetNum[o] += 1;
              }
            }
          }
        }
        
        for (int f = 0; f < allCurves.nodes.length; f++) {
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
            if (allCurves.nodes[f][j] == vNo) { 
  
              float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
  
              for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
                base_Vertices[s][0] = allVertices[allCurves.nodes[f][s]][0];
                base_Vertices[s][1] = allVertices[allCurves.nodes[f][s]][1];
                base_Vertices[s][2] = allVertices[allCurves.nodes[f][s]][2];
              }
  
              for (int s = 0; s < base_Vertices.length; s++) {
  
                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
                PVector UV = new PVector(0, 0, 0);
  
                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);
  
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = SOLARCHVISION_fn_normalize(W);
  
                selectedVertex_offsetValues[o][0] += W[0] * _amount;
                selectedVertex_offsetValues[o][1] += W[1] * _amount;
                selectedVertex_offsetValues[o][2] += W[2] * _amount;
  
                selectedVertex_offsetNum[o] += 1;
              }
            }
          }
        }        
  
  
        if (selectedVertex_offsetNum[o] != 0) {
          selectedVertex_offsetValues[o][0] /= float(selectedVertex_offsetNum[o]);
          selectedVertex_offsetValues[o][1] /= float(selectedVertex_offsetNum[o]);
          selectedVertex_offsetValues[o][2] /= float(selectedVertex_offsetNum[o]);
        }
      } 
  
  
      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = selectedVertex_ids[o];
  
        allVertices[vNo][0] += selectedVertex_offsetValues[o][0];
        allVertices[vNo][1] += selectedVertex_offsetValues[o][1];
        allVertices[vNo][2] += selectedVertex_offsetValues[o][2];
      } 
  
      println("SOLARCHVISION_calculate_selection_BoundingBox 102");
      SOLARCHVISION_calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  
  
  void changeVisibilityFaces_Selection (int new_vsb) {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Faces();
      }
  
      if (Current_ObjectCategory == ObjectCategory.VERTEX) { 
  
        this.convert_Vertices_to_Faces();
      }
  
      for (int o = selectedFace_ids.length - 1; o >= 0; o--) {
  
        int f = selectedFace_ids[o];
  
        allFaces.setVisibility(f, new_vsb);
  
      }
    }
  }
  
  
  void changeVisibilityFaces_Scene (int new_vsb) {
  
    for (int f = allFaces.nodes.length - 1; f >= 0; f--) { 
      allFaces.setVisibility(f, new_vsb);
    }
  }
  
  
  void reverseVisibilityFaces_Scene () {
  
    for (int f = allFaces.nodes.length - 1; f >= 0; f--) { 
  
      int vsb = allFaces.getVisibility(f);
      int new_vsb = vsb;
  
      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;
  
      allFaces.setVisibility(f, new_vsb);
    }
  }
  
  
  void changeVisibilityCurves_Selection (int new_vsb) {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (Current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Curves();
      }
  
      if (Current_ObjectCategory == ObjectCategory.VERTEX) { 
  
        this.convert_Vertices_to_Curves();
      }
  
      for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {
  
        int f = selectedCurve_ids[o];
  
        allCurves.setVisibility(f, new_vsb);
  
      }
    }
  }
  
  
  void changeVisibilityCurves_Scene (int new_vsb) {
  
    for (int f = allCurves.nodes.length - 1; f >= 0; f--) { 
      allCurves.setVisibility(f, new_vsb);
    }
  }
  
  
  void reverseVisibilityCurves_Scene () {
  
    for (int f = allCurves.nodes.length - 1; f >= 0; f--) { 
  
      int vsb = allCurves.getVisibility(f);
      int new_vsb = vsb;
  
      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;
  
      allCurves.setVisibility(f, new_vsb);
    }
  }
  
  
  
  void isolate_Selection () {
  
    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      this.changeVisibilityFaces_Scene(0);
      this.changeVisibilityFaces_Selection(1);
      
      this.changeVisibilityCurves_Scene(0);
      this.changeVisibilityCurves_Selection(1);    
    }
  }
  
  
  void select_Last () {
    
    if (Current_ObjectCategory == ObjectCategory.SECTION) {
      selectedSection_ids = new int [0];
      
      if (allSections.num > 0) {
        int[] new_Item = {allSections.num - 1};
        selectedSection_ids = concat(selectedSection_ids, new_Item);
      }
    }   
    
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
      selectedCamera_ids = new int [0];
      
      if (allCameras.num > 0) {
        int[] new_Item = {allCameras.num - 1};
        selectedCamera_ids = concat(selectedCamera_ids, new_Item);
      }
    }   
    
    if (Current_ObjectCategory == ObjectCategory.SOLID) {
      selectedSolid_ids = new int [0];
      
      if (allSolids.DEF.length > 0) {
        int[] new_Item = {allSolids.DEF.length - 1};
        selectedSolid_ids = concat(selectedSolid_ids, new_Item);
      }
    } 
  
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
      selectedallModel1Ds_ids = new int [0];
      
      if (allModel1Ds.num > 0) {
        int[] new_Item = {allModel1Ds.num - 1};
        selectedallModel1Ds_ids = concat(selectedallModel1Ds_ids, new_Item);
      }
    } 
  
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
      selectedallModel2Ds_ids = new int [0];
      
      if (allModel2Ds.num > 0) {
        int[] new_Item = {allModel2Ds.num - 1};
        selectedallModel2Ds_ids = concat(selectedallModel2Ds_ids, new_Item);
      }
    } 
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
      selectedGroup_ids = new int [0];
  
      if (allGroups.num > 0) {
        int[] new_Item = {allGroups.num - 1};
        selectedGroup_ids = concat(selectedGroup_ids, new_Item);
      }
    } 
  
    if (Current_ObjectCategory == ObjectCategory.FACE) {
      selectedFace_ids = new int [0];
      
      if (allFaces.nodes.length > 0) {
        int[] new_Item = {allFaces.nodes.length - 1};
        selectedFace_ids = concat(selectedFace_ids, new_Item);
      }
    } 
  
    if (Current_ObjectCategory == ObjectCategory.VERTEX) {
      selectedVertex_ids = new int [0];
      
      if (allVertices.length > 0) {
        int[] new_Item = {allVertices.length - 1};
        selectedVertex_ids = concat(selectedVertex_ids, new_Item);
      }
    } 
  
  
    if (Current_ObjectCategory == ObjectCategory.CURVE) {
      selectedCurve_ids = new int [0];
      
      if (allCurves.nodes.length > 0) {
        int[] new_Item = {allCurves.nodes.length - 1};
        selectedCurve_ids = concat(selectedCurve_ids, new_Item);
      }
    } 
  
    println("SOLARCHVISION_calculate_selection_BoundingBox 999");
    SOLARCHVISION_calculate_selection_BoundingBox();  
  }
  
  
  
  void deselect_All () {
  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
      selectedLandPoint_ids = new int [0];
    }  
  
    if (Current_ObjectCategory == ObjectCategory.SECTION) {  
      selectedSection_ids = new int [0];
    }  
  
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {  
      selectedCamera_ids = new int [0];
    }  
  
  
  
    if ((Current_ObjectCategory == ObjectCategory.MODEL1D) || (Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.MODEL2D) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX) || (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) || (Current_ObjectCategory == ObjectCategory.SOLID)) {  
  
      selectedallModel1Ds_ids = new int [0];
  
      selectedGroup_ids = new int [0];
  
      selectedallModel2Ds_ids = new int [0];
  
      selectedFace_ids = new int [0];
  
      selectedVertex_ids = new int [0];
    
      selectedCurve_ids = new int [0];
  
      selectedSolid_ids = new int [0];
    }  
  
    println("SOLARCHVISION_calculate_selection_BoundingBox 0");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
  
  void select_All () {
  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
      selectedLandPoint_ids = new int [Land3D.n_I * Land3D.n_J];
      for (int i = 0; i < selectedLandPoint_ids.length; i++) { 
        selectedLandPoint_ids[i] = i;
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
      selectedallModel1Ds_ids = new int [allModel1Ds.num];
      for (int i = 0; i < selectedallModel1Ds_ids.length; i++) { 
        selectedallModel1Ds_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
      selectedallModel2Ds_ids = new int [allModel2Ds.num];
      for (int i = 0; i < selectedallModel2Ds_ids.length; i++) { 
        selectedallModel2Ds_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
      selectedGroup_ids = new int [allGroups.num];
      for (int i = 0; i < selectedGroup_ids.length; i++) { 
        selectedGroup_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.FACE) {
      selectedFace_ids = new int [allFaces.nodes.length];
      for (int i = 0; i < selectedFace_ids.length; i++) { 
        selectedFace_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.VERTEX) {
      selectedVertex_ids = new int [allVertices.length];
      for (int i = 0; i < selectedVertex_ids.length; i++) { 
        selectedVertex_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.CURVE) {
      selectedCurve_ids = new int [allCurves.nodes.length];
      for (int i = 0; i < selectedCurve_ids.length; i++) { 
        selectedCurve_ids[i] = i;
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.SOLID) {
      selectedSolid_ids = new int [allSolids.DEF.length];
      for (int i = 0; i < selectedSolid_ids.length; i++) { 
        selectedSolid_ids[i] = i;
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.SECTION) {
      selectedSection_ids = new int [allSections.num];
      for (int i = 0; i < selectedSection_ids.length; i++) { 
        selectedSection_ids[i] = i;
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
      selectedCamera_ids = new int [allCameras.num];
      for (int i = 0; i < selectedCamera_ids.length; i++) { 
        selectedCamera_ids[i] = i;
      }
    }  
  
    println("SOLARCHVISION_calculate_selection_BoundingBox 44");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
  
  
  void reverse_Selection () {
  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
      int[] pre_selectedLandPoint_ids = sort(selectedLandPoint_ids);
  
      selectedLandPoint_ids = new int [0];
  
      for (int i = 0; i < Land3D.n_I * Land3D.n_J; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedLandPoint_ids.length; j++) {
  
          if (pre_selectedLandPoint_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedLandPoint_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedLandPoint_ids = concat(selectedLandPoint_ids, new_Item);
        }
      }
    }     
  
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
      int[] pre_selectedallModel1Ds_ids = sort(selectedallModel1Ds_ids);
  
      selectedallModel1Ds_ids = new int [0];
  
      for (int i = 0; i < allModel1Ds.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedallModel1Ds_ids.length; j++) {
  
          if (pre_selectedallModel1Ds_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedallModel1Ds_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedallModel1Ds_ids = concat(selectedallModel1Ds_ids, new_Item);
        }
      }
    }    
  
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
      int[] pre_selectedallModel2Ds_ids = sort(selectedallModel2Ds_ids);
  
      selectedallModel2Ds_ids = new int [0];
  
      for (int i = 0; i < allModel2Ds.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedallModel2Ds_ids.length; j++) {
  
          if (pre_selectedallModel2Ds_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedallModel2Ds_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedallModel2Ds_ids = concat(selectedallModel2Ds_ids, new_Item);
        }
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.GROUP) {
      int[] pre_selectedGroup_ids = sort(selectedGroup_ids);
  
      selectedGroup_ids = new int [0];
  
      for (int i = 0; i < allGroups.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedGroup_ids.length; j++) {
  
          if (pre_selectedGroup_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedGroup_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedGroup_ids = concat(selectedGroup_ids, new_Item);
        }
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.FACE) {
      int[] pre_selectedFace_ids = sort(selectedFace_ids);
  
      selectedFace_ids = new int [0];
  
      for (int i = 0; i < allFaces.nodes.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedFace_ids.length; j++) {
  
          if (pre_selectedFace_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedFace_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedFace_ids = concat(selectedFace_ids, new_Item);
        }
      }
    }  
  
    if (Current_ObjectCategory == ObjectCategory.CURVE) {
      int[] pre_selectedCurve_ids = sort(selectedCurve_ids);
  
      selectedCurve_ids = new int [0];
  
      for (int i = 0; i < allCurves.nodes.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedCurve_ids.length; j++) {
  
          if (pre_selectedCurve_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedCurve_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedCurve_ids = concat(selectedCurve_ids, new_Item);
        }
      }
    }  
  
  
    if (Current_ObjectCategory == ObjectCategory.VERTEX) {
      int[] pre_selectedVertex_ids = sort(selectedVertex_ids);
  
      selectedVertex_ids = new int [0];
  
      for (int i = 0; i < allVertices.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedVertex_ids.length; j++) {
  
          if (pre_selectedVertex_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedVertex_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedVertex_ids = concat(selectedVertex_ids, new_Item);
        }
      }
    }
  
    if (Current_ObjectCategory == ObjectCategory.SOLID) {
      int[] pre_selectedSolid_ids = sort(selectedSolid_ids);
  
      selectedSolid_ids = new int [0];
  
      for (int i = 0; i < allSolids.DEF.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedSolid_ids.length; j++) {
  
          if (pre_selectedSolid_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedSolid_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedSolid_ids = concat(selectedSolid_ids, new_Item);
        }
      }
    }      
  
    if (Current_ObjectCategory == ObjectCategory.SECTION) {
      int[] pre_selectedSection_ids = sort(selectedSection_ids);
  
      selectedSection_ids = new int [0];
  
      for (int i = 0; i < allSections.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedSection_ids.length; j++) {
  
          if (pre_selectedSection_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedSection_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedSection_ids = concat(selectedSection_ids, new_Item);
        }
      }
    }    
  
    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
      int[] pre_selectedCamera_ids = sort(selectedCamera_ids);
  
      selectedCamera_ids = new int [0];
  
      for (int i = 0; i < allCameras.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_selectedCamera_ids.length; j++) {
  
          if (pre_selectedCamera_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_selectedCamera_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          selectedCamera_ids = concat(selectedCamera_ids, new_Item);
        }
      }
    }    
  
    println("SOLARCHVISION_calculate_selection_BoundingBox 45");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }  
  
  
  void convert_allModel1Ds_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedallModel1Ds_ids.length; i++) {
  
      int f = selectedallModel1Ds_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.allModel1Ds[OBJ_NUM][0] <= f) && (f <= allGroups.allModel1Ds[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < selectedGroup_ids.length; q++) {
            if (selectedGroup_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            selectedGroup_ids = concat(selectedGroup_ids, new_Item);
          }
        }
      }
    }
  }
  
  
  void convert_allModel2Ds_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedallModel2Ds_ids.length; i++) {
  
      int f = selectedallModel2Ds_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.allModel2Ds[OBJ_NUM][0] <= f) && (f <= allGroups.allModel2Ds[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < selectedGroup_ids.length; q++) {
            if (selectedGroup_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            selectedGroup_ids = concat(selectedGroup_ids, new_Item);
          }
        }
      }
    }
  }
  
  
  void convert_allSolids_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedSolid_ids.length; i++) {
  
      int f = selectedSolid_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.allSolids[OBJ_NUM][0] <= f) && (f <= allGroups.allSolids[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < selectedGroup_ids.length; q++) {
  
  
            if (selectedGroup_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            selectedGroup_ids = concat(selectedGroup_ids, new_Item);
          }
        }
      }
    }
  }
  
  void convert_Faces_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedFace_ids.length; i++) {
  
      int f = selectedFace_ids[i];
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
        for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
          if ((allGroups.Faces[OBJ_NUM][0] <= f) && (f <= allGroups.Faces[OBJ_NUM][1])) { 
  
            int previously_added = 0;
            for (int q = 0; q < selectedGroup_ids.length; q++) {
              if (selectedGroup_ids[q] == OBJ_NUM) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_NUM
              };
              selectedGroup_ids = concat(selectedGroup_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  void convert_Curves_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedCurve_ids.length; i++) {
  
      int f = selectedCurve_ids[i];
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
        for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
          if ((allGroups.Curves[OBJ_NUM][0] <= f) && (f <= allGroups.Curves[OBJ_NUM][1])) { 
  
            int previously_added = 0;
            for (int q = 0; q < selectedGroup_ids.length; q++) {
              if (selectedGroup_ids[q] == OBJ_NUM) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_NUM
              };
              selectedGroup_ids = concat(selectedGroup_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  
  void convert_Vertices_to_allGroups () {
  
    selectedGroup_ids = new int [0];
  
    for (int i = 0; i < selectedVertex_ids.length; i++) {
  
      int vNo = selectedVertex_ids[i];
  
      for (int f = 0; f < allFaces.nodes.length; f++) {
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          if (allFaces.nodes[f][j] == vNo) { 
  
            for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
              if ((allGroups.Faces[OBJ_NUM][0] <= f) && (f <= allGroups.Faces[OBJ_NUM][1])) { 
  
                int previously_added = 0;
                for (int q = 0; q < selectedGroup_ids.length; q++) {
                  if (selectedGroup_ids[q] == OBJ_NUM) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_NUM
                  };
                  selectedGroup_ids = concat(selectedGroup_ids, new_Item);
                }
              }
            }
          }
        }
      }
      
      for (int f = 0; f < allCurves.nodes.length; f++) {
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          if (allCurves.nodes[f][j] == vNo) { 
  
            for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
              if ((allGroups.Curves[OBJ_NUM][0] <= f) && (f <= allGroups.Curves[OBJ_NUM][1])) { 
  
                int previously_added = 0;
                for (int q = 0; q < selectedGroup_ids.length; q++) {
                  if (selectedGroup_ids[q] == OBJ_NUM) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_NUM
                  };
                  selectedGroup_ids = concat(selectedGroup_ids, new_Item);
                }
              }
            }
          }
        }
      }    
    }
  }
  
  
  void convert_Vertices_to_Faces () {
  
    selectedFace_ids = new int [0];
  
    for (int i = 0; i < selectedVertex_ids.length; i++) {
  
      int vNo = selectedVertex_ids[i];
  
      for (int f = 0; f < allFaces.nodes.length; f++) {
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          if (allFaces.nodes[f][j] == vNo) { 
  
            int previously_added = 0;
            for (int q = 0; q < selectedFace_ids.length; q++) {
              if (selectedFace_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              selectedFace_ids = concat(selectedFace_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  void convert_Vertices_to_Curves () {
  
    selectedCurve_ids = new int [0];
  
    for (int i = 0; i < selectedVertex_ids.length; i++) {
  
      int vNo = selectedVertex_ids[i];
  
      for (int f = 0; f < allCurves.nodes.length; f++) {
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          if (allCurves.nodes[f][j] == vNo) { 
  
            int previously_added = 0;
            for (int q = 0; q < selectedCurve_ids.length; q++) {
              if (selectedCurve_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              selectedCurve_ids = concat(selectedCurve_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  void convert_allGroups_to_allModel1Ds () {
  
    selectedallModel1Ds_ids = new int [0];
    
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.allModel1Ds[OBJ_NUM][0]; f <= allGroups.allModel1Ds[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < selectedallModel1Ds_ids.length; q++) {
          if (selectedallModel1Ds_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          selectedallModel1Ds_ids = concat(selectedallModel1Ds_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_allModel2Ds () {
  
    selectedallModel2Ds_ids = new int [0];
  
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.allModel2Ds[OBJ_NUM][0]; f <= allGroups.allModel2Ds[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < selectedallModel2Ds_ids.length; q++) {
          if (selectedallModel2Ds_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          selectedallModel2Ds_ids = concat(selectedallModel2Ds_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_allSolids () {
  
    selectedSolid_ids = new int [0];
  
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.allSolids[OBJ_NUM][0]; f <= allGroups.allSolids[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < selectedSolid_ids.length; q++) {
          if (selectedSolid_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          selectedSolid_ids = concat(selectedSolid_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_Faces () {
  
    selectedFace_ids = new int [0];
  
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < selectedFace_ids.length; q++) {
          if (selectedFace_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          selectedFace_ids = concat(selectedFace_ids, new_Item);
        }
      }
    }
  }
  
  
  void convert_allGroups_to_Curves () {
  
    selectedCurve_ids = new int [0];
  
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < selectedCurve_ids.length; q++) {
          if (selectedCurve_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          selectedCurve_ids = concat(selectedCurve_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_Vertices () {
  
    selectedVertex_ids = new int [0];
  
    for (int i = 0; i < selectedGroup_ids.length; i++) {
  
      int OBJ_NUM = selectedGroup_ids[i];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) { 
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          int vNo = allFaces.nodes[f][j];
  
          int previously_added = 0;
          for (int q = 0; q < selectedVertex_ids.length; q++) {
            if (selectedVertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            selectedVertex_ids = concat(selectedVertex_ids, new_Item);
          }
        }
      }
      
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) { 
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          int vNo = allCurves.nodes[f][j];
  
          int previously_added = 0;
          for (int q = 0; q < selectedVertex_ids.length; q++) {
            if (selectedVertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            selectedVertex_ids = concat(selectedVertex_ids, new_Item);
          }
        }
      }    
    }
  }
  
  
  void convert_Faces_to_Vertices () {
  
    selectedVertex_ids = new int [0];
  
    for (int i = 0; i < selectedFace_ids.length; i++) {
  
      int f = selectedFace_ids[i];
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
        int vNo = allFaces.nodes[f][j];
  
        int previously_added = 0;
        for (int q = 0; q < selectedVertex_ids.length; q++) {
          if (selectedVertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          selectedVertex_ids = concat(selectedVertex_ids, new_Item);
        }
      }
    }
  }
  
  
  void convert_Curves_to_Vertices () {
  
    selectedVertex_ids = new int [0];
  
    for (int i = 0; i < selectedCurve_ids.length; i++) {
  
      int f = selectedCurve_ids[i];
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
        int vNo = allCurves.nodes[f][j];
  
        int previously_added = 0;
        for (int q = 0; q < selectedVertex_ids.length; q++) {
          if (selectedVertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          selectedVertex_ids = concat(selectedVertex_ids, new_Item);
        }
      }
    }
  }
  
  

  
  void convert_Vertex_to_softSelection () { 
  
    int[] keep_selectedVertex_ids = selectedVertex_ids;
  
    this.convert_Vertices_to_allGroups();
  
    this.convert_allGroups_to_Vertices();
  
    selectedVertex_softSelectionVertices = new int[selectedVertex_ids.length]; 
    selectedVertex_softSelectionValues = new float[selectedVertex_ids.length];
  
    for (int q = 0; q < selectedVertex_ids.length; q++) {
  
      int n = selectedVertex_ids[q];
  
      float d_min = FLOAT_undefined;
  
      for (int p = 0; p < keep_selectedVertex_ids.length; p++) {
  
        int m = keep_selectedVertex_ids[p];
  
        float d = dist(allVertices[m][0], allVertices[m][1], allVertices[m][2], allVertices[n][0], allVertices[n][1], allVertices[n][2]);
  
        if (d_min > d) {
          d_min = d;
        }
      }
  
      selectedVertex_softSelectionValues[q] = SOLARCHVISION_softVertexSelectionFunction(d_min);
    }
  
    selectedVertex_softSelectionVertices = selectedVertex_ids;
  
    selectedVertex_ids = keep_selectedVertex_ids;
  }
  
  
  
  void add_Octahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {
    
    if ((rx > 0) && (ry > 0) && (rz > 0)) {    
      
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      float teta = rot * PI / 180.0;
    
      float[] X_ = new float [6];
      float[] Y_ = new float [6];
      float[] Z_ = new float [6];
    
      float q = pow(2, 0.5);
    
      X_[0] = 0;  
      Y_[0] = 0;  
      Z_[0] = q;
      X_[1] = q;  
      Y_[1] = 0;  
      Z_[1] = 0;
      X_[2] = 0;  
      Y_[2] = q;  
      Z_[2] = 0;
      X_[3] = -q;  
      Y_[3] = 0;  
      Z_[3] = 0;
      X_[4] = 0;  
      Y_[4] = -q;  
      Z_[4] = 0;
      X_[5] = 0;  
      Y_[5] = 0;  
      Z_[5] = -q;
    
      for (int i = 0; i < 6; i++) {
        X_[i] *= rx;
        Y_[i] *= ry;
        Z_[i] *= rz;
    
        float X_r = X_[i] * cos(teta) - Y_[i] * sin(teta);
        float Y_r = X_[i] * sin(teta) + Y_[i] * cos(teta);
        float Z_r = Z_[i];
    
        X_[i] = X_r + x;
        Y_[i] = Y_r + y;
        Z_[i] = Z_r + z;
      }
    
      int[] v = new int [6];
    
      for (int i = 0; i < 6; i++) {
        v[i] = this.add_Vertex(X_[i], Y_[i], Z_[i]);
      } 
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
      {
        int[] newFace = {
          v[1], v[2], v[0]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
    
      {
        int[] newFace = {
          v[2], v[3], v[0]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
    
      {
        int[] newFace = {
          v[3], v[4], v[0]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
    
      {
        int[] newFace = {
          v[4], v[1], v[0]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
    
      {
        int[] newFace = {
          v[1], v[5], v[2]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
    
      {
        int[] newFace = {
          v[2], v[5], v[3]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }      
      {
        int[] newFace = {
          v[3], v[5], v[4]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
    
      {
        int[] newFace = {
          v[4], v[5], v[1]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      
    }            
  }
  
  
  void add_House1_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {
   
    if ((rx > 0) && (ry > 0) && (rz > 0)) {
      
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      float teta = rot * PI / 180.0;
    
      float x1 = rx;  
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;
    
      float y1 = ry;  
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;
    
      float z0 = -rz; 
      float z1 = rz;
      float z2 = h2;
    
      float[] vx = { 
        1, -1, -1, 1, 1, -1, -1, 1, 1, -1
      };
      float[] vy = { 
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };
    
      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;
    
        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];
    
        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }  
    
      int b1 = this.add_Vertex(vx[0], vy[0], vz[0]);
      int b2 = this.add_Vertex(vx[1], vy[1], vz[1]);
      int b3 = this.add_Vertex(vx[2], vy[2], vz[2]);
      int b4 = this.add_Vertex(vx[3], vy[3], vz[3]);
    
      int t1 = this.add_Vertex(vx[4], vy[4], vz[4]);
      int t2 = this.add_Vertex(vx[5], vy[5], vz[5]);
      int t3 = this.add_Vertex(vx[6], vy[6], vz[6]);
      int t4 = this.add_Vertex(vx[7], vy[7], vz[7]);
    
      int m1 = this.add_Vertex(vx[8], vy[8], vz[8]);
      int m2 = this.add_Vertex(vx[9], vy[9], vz[9]);
    
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
    
      {//West
        int[] newFace = {
          t3, m2, t2, b2, b3
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//Roof-South
        int[] newFace = {
          m1, m2, t3, t4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//East
        int[] newFace = {
          t1, m1, t4, b4, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//North
        int[] newFace = {
          t2, t1, b1, b2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//South
        int[] newFace = {
          t4, t3, b3, b4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//Roof-North
        int[] newFace = {
          m2, m1, t1, t2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//Bottom
        int[] newFace = {
          b4, b3, b2, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  void add_House2_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {
  
    if ((rx > 0) && (ry > 0) && (rz > 0)) {
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
  
      if (ry > rx) {
        
        float tmp = rx;
        rx = ry;
        ry = tmp;
        
        rot += 90;
      }      
  
      float teta = rot * PI / 180.0;
    
      float x1 = rx;  
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;
    
      float y1 = ry;  
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;
    
      float z0 = -rz; 
      float z1 = rz;
      float z2 = h2;
    
      float[] vx = { 
        1, -1, -1, 1, 1, -1, -1, 1, 1-ry/rx, -1+ry/rx
      };
      float[] vy = { 
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };
      
      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;
    
        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];
    
        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }  
    
      int b1 = this.add_Vertex(vx[0], vy[0], vz[0]);
      int b2 = this.add_Vertex(vx[1], vy[1], vz[1]);
      int b3 = this.add_Vertex(vx[2], vy[2], vz[2]);
      int b4 = this.add_Vertex(vx[3], vy[3], vz[3]);
    
      int t1 = this.add_Vertex(vx[4], vy[4], vz[4]);
      int t2 = this.add_Vertex(vx[5], vy[5], vz[5]);
      int t3 = this.add_Vertex(vx[6], vy[6], vz[6]);
      int t4 = this.add_Vertex(vx[7], vy[7], vz[7]);
    
      int m1 = this.add_Vertex(vx[8], vy[8], vz[8]);
      int m2 = this.add_Vertex(vx[9], vy[9], vz[9]);
    
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
    
      {//West
        int[] newFace = {
          t3, t2, b2, b3
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//Roof-West
        int[] newFace = {
          t3, m2, t2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//Roof-South
        int[] newFace = {
          m1, m2, t3, t4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//East
        int[] newFace = {
          t1, t4, b4, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//Roof-East
        int[] newFace = {
          t1, m1, t4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//North
        int[] newFace = {
          t2, t1, b1, b2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }  
      {//South
        int[] newFace = {
          t4, t3, b3, b4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//Roof-North
        int[] newFace = {
          m2, m1, t1, t2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }    
      {//Bottom
        int[] newFace = {
          b4, b3, b2, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  
  void add_Box_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {
  
    if ((rx > 0) && (ry > 0) && (rz > 0)) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      float teta = rot * PI / 180.0;
    
      int t1 = this.add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z + rz);
      int t2 = this.add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z + rz);
      int t3 = this.add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z + rz);
      int t4 = this.add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z + rz);
    
      int b1 = this.add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z - rz);
      int b2 = this.add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z - rz);
      int b3 = this.add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z - rz);
      int b4 = this.add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z - rz);
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
    
      {//West
        int[] newFace = {
          t3, t2, b2, b3
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//Roof
        int[] newFace = {
          t1, t2, t3, t4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//East
        int[] newFace = {
          t1, t4, b4, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//North
        int[] newFace = {
          t2, t1, b1, b2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//South
        int[] newFace = {
          t4, t3, b3, b4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//Bottom
        int[] newFace = {
          b4, b3, b2, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  void add_Box_Corners (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2) {
  
    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int t1 = this.add_Vertex(x2, y2, z2);
      int t2 = this.add_Vertex(x1, y2, z2);
      int t3 = this.add_Vertex(x1, y1, z2);
      int t4 = this.add_Vertex(x2, y1, z2);
    
      int b1 = this.add_Vertex(x2, y2, z1);
      int b2 = this.add_Vertex(x1, y2, z1);
      int b3 = this.add_Vertex(x1, y1, z1);
      int b4 = this.add_Vertex(x2, y1, z1);
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
    
      {//West
        int[] newFace = {
          t3, t2, b2, b3
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//Roof
        int[] newFace = {
          t1, t2, t3, t4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//East
        int[] newFace = {
          t1, t4, b4, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//North
        int[] newFace = {
          t2, t1, b1, b2
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//South
        int[] newFace = {
          t4, t3, b3, b4
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      {//Bottom
        int[] newFace = {
          b4, b3, b2, b1
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  void add_H_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float d, float w, float Alpha, float Beta) {
  
    if ((d > 0) && (w > 0)) {
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      float rx = 0.5 * d * cos_ang(Beta);
      float ry = 0.5 * d * sin_ang(Beta);
    
      float wx = w * cos_ang(Beta - 90) * cos_ang(Alpha);
      float wy = w * sin_ang(Beta - 90) * cos_ang(Alpha);
      float wz = w * sin_ang(Alpha);
    
      float x1 = x0 + rx;
      float y1 = y0 + ry;
      float z1 = z0;
    
      float x2 = x0 - rx;
      float y2 = y0 - ry;
      float z2 = z0;
    
      float x3 = wx + x0 - rx;
      float y3 = wy + y0 - ry;
      float z3 = wz + z0;
    
      float x4 = wx + x0 + rx;
      float y4 = wy + y0 + ry;
      float z4 = wz + z0;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  void add_V_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float h, float d, float t, float t0) {
  
    if ((d > 0) && (h > 0)) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      float dx = d * cos_ang(t + t0 - 90);
      float dy = d * sin_ang(t + t0 - 90);
    
      float x1 = x0;
      float y1 = y0;
      float z1 = z0 - 0.5 * h;
    
      float x2 = x0;
      float y2 = y0;
      float z2 = z0 + 0.5 * h;
    
      float x3 = x0 + dx;
      float y3 = y0 + dy;
      float z3 = z0 + 0.5 * h;
    
      float x4 = x0 + dx;
      float y4 = y0 + dy;
      float z4 = z0 - 0.5 * h;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  
  void add_Mesh2 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x3, float y3, float z3) {
  
    if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {    
      
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt; 
      defaultClose = clz;
    
      float x2 = x3;
      float y2 = y3;
      float z2 = z3;
    
      float x4 = x1;
      float y4 = y1;
      float z4 = z1;
    
      if (z1 == z3) {
        y2 = y1;
        y4 = y3;
      } else if (y1 == y3) {
        x2 = x1;
        x4 = x3;
      } else if (x1 == x3) {
        z2 = z1;
        z4 = z3;
      }  
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
    
      {
        int[] newFace = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace);
      }
      
    }
  }
  
  void add_Mesh3 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {
  
    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {  
      if ((x2 != x3) || (y2 != y3) || (z2 != z3)) {  
        if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {    
    
          defaultMaterial = m;
          defaultTessellation = tes;
          defaultLayer = lyr;
          defaultVisibility = vsb;
          defaultWeight = wgt;
          defaultClose = clz;
        
          int v1 = this.add_Vertex(x1, y1, z1);
          int v2 = this.add_Vertex(x2, y2, z2);
          int v3 = this.add_Vertex(x3, y3, z3);
        
          {
            int[] newFace = {
              v1, v2, v3
            };
            this.add_Face(newFace);
          }
    
        }
      }
    }
  }
  
  
  
  void add_Mesh4 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else if ((x1 == x4) && (y1 == y4) && (z1 == z4)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else {
          
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;  
      defaultClose = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace);
      }
          
    }
  
  }
  
  
  
  void add_Mesh5 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }
    else if ((x1 == x5) && (y1 == y5) && (z1 == z5)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }  
    else {  
      
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
      int v5 = this.add_Vertex(x5, y5, z5);
    
      {
        int[] newFace = {
          v1, v2, v3, v4, v5
        };
        this.add_Face(newFace);
      }
      
    }
  }
  
  
  void add_Mesh6 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5, float x6, float y6, float z6) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5, x6, y6, z6);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x6, y6, z6);
    }
    else if ((x5 == x6) && (y5 == y6) && (z5 == z6)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }    
    else if ((x1 == x6) && (y1 == y6) && (z1 == z6)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }  
    else {    
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
      int v5 = this.add_Vertex(x5, y5, z5);
      int v6 = this.add_Vertex(x6, y6, z6);
    
      {
        int[] newFace = {
          v1, v2, v3, v4, v5, v6
        };
        this.add_Face(newFace);
      }
    }
  }
  
  
  
  
  void add_PolygonHyper (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {
  
    if ((r > 0) && (h > 0) && (n > 2)) {
      
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int[] newFace = {
        this.add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);
        int[] f = {
          this.add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + (2 * (i % 2) - 1) * 0.5 * h)
        };
        newFace = concat(newFace, f);
      } 
    
      this.add_Face(newFace);
    }
  }
  
  
  
  void add_PolygonMesh (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot) {
  
    if ((r > 0) && (n > 2)) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int[] newFace = {
        this.add_Vertex(cx + r * cos_ang(0), cy + r * sin_ang(0), cz)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n) + rot;
        int[] f = {
          this.add_Vertex(cx + r * cos_ang(t), cy + r * sin_ang(t), cz)
        };
        newFace = concat(newFace, f);
      } 
    
      this.add_Face(newFace);
    }
  }
  
  
  
  void add_PolygonExtrude (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {
  
    if ((r > 0) && (h > 0) && (n > 2)) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int[] vT = new int [n];
      int[] vB = new int [n];
    
      vT[0] = this.add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz + 0.5 * h);
      vB[0] = this.add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h);
    
      int[] newFaceT = {
        vT[0]
      };
      int[] newFaceB = {
        vB[0]
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);
    
        vT[i] = this.add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + 0.5 * h);
        vB[i] = this.add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz - 0.5 * h);
        int[] fT = {
          vT[i]
        };
        int[] fB = {
          vB[i]
        };
    
        newFaceT = concat(newFaceT, fT);
        newFaceB = concat(newFaceB, fB);
      } 
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
      this.add_Face(newFaceT);
    
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
      this.add_Face(newFaceB);
    
      for (int i = 0; i < n; i++) {
        int next_i = (i + 1) % n;
    
        int[] newFace = {
          vT[i], vB[i], vB[next_i], vT[next_i]
        };
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
        this.add_Face(newFace);
      }
    }
  }
  
  
  
  
  
  
  void add_Icosahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float rot) {
  
    if (r > 0) {  
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int[] vT = new int [6];
      int[] vB = new int [6];
    
      vT[0] = this.add_Vertex(cx, cy, cz + r);
      vB[0] = this.add_Vertex(cx, cy, cz - r);
    
      for (int i = 1; i <= 5; i++) {
        float t = i * 72;
    
        float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
        float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;
    
        vT[i] = this.add_Vertex(cx + R_in * cos_ang(t + rot), cy + R_in * sin_ang(t + rot), cz + H_in);
        vB[i] = this.add_Vertex(cx + R_in * cos_ang(t + 36 + rot), cy + R_in * sin_ang(t + 36 + rot), cz - H_in);
      } 
    
    
      if (m == -1) defaultMaterial = 0;
      else defaultMaterial = m;
    
      for (int i = 1; i <= 5; i++) {
    
        int next_i = (i % 5) + 1;
    
        {
          int[] newFaceT = new int [3];
          int[] newFaceB = new int [3];
    
          newFaceT[0] = vT[i];
          newFaceT[1] = vT[next_i];
          newFaceT[2] = vT[0];
    
          newFaceB[0] = vB[i];
          newFaceB[1] = vB[next_i];
          newFaceB[2] = vT[next_i]; 
    
          if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));   
          this.add_Face(newFaceT);
          this.add_Face(newFaceB);
        }
    
        {
          int[] newFaceT = new int [3];
          int[] newFaceB = new int [3];
    
          newFaceT[0] = vT[next_i];
          newFaceT[1] = vT[i];
          newFaceT[2] = vB[i];
    
          newFaceB[0] = vB[next_i];
          newFaceB[1] = vB[i];
          newFaceB[2] = vB[0];    
    
          if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
          this.add_Face(newFaceT);
          this.add_Face(newFaceB);
        }
      }
    }
  }  
  
  
  void create_Face_afterSphericalTessellation (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int[] f) {
  
    if (r > 0) {
    
      defaultMaterial = m;
      defaultTessellation = tes;
      defaultLayer = lyr;
      defaultVisibility = vsb;
      defaultWeight = wgt;
      defaultClose = clz;
    
      int A = f[0];
      int B = f[1];
      int C = f[2];
      int D = f[3];
    
      int M, N;  // 
      int MM, NN; // MM: mirror of M based on AB; NN: mirror of N baesd on CD
    
      float[] G;
    
      { 
        float[][] the_points = {
          {
            allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz
          }
          , {
            allVertices[A][0] - cx, allVertices[A][1] - cy, allVertices[A][2] - cz
          }
          , {
            allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz
          }
        };
    
        G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
        M = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
        G[0] = (allVertices[C][0] - cx) + (allVertices[D][0] - cx) - (allVertices[M][0] - cx);
        G[1] = (allVertices[C][1] - cy) + (allVertices[D][1] - cy) - (allVertices[M][1] - cy);
        G[2] = (allVertices[C][2] - cz) + (allVertices[D][2] - cz) - (allVertices[M][2] - cz);
        G = SOLARCHVISION_fn_normalize(G);
        MM = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }   
    
    
      { 
        float[][] the_points = {
          {
            allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz
          }
          , {
            allVertices[C][0] - cx, allVertices[C][1] - cy, allVertices[C][2] - cz
          }
          , {
            allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz
          }
        };
    
        G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
        N = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
    
        G[0] = (allVertices[A][0] - cx) + (allVertices[B][0] - cx) - (allVertices[N][0] - cx);
        G[1] = (allVertices[A][1] - cy) + (allVertices[B][1] - cy) - (allVertices[N][1] - cy);
        G[2] = (allVertices[A][2] - cz) + (allVertices[B][2] - cz) - (allVertices[N][2] - cz);
        G = SOLARCHVISION_fn_normalize(G);    
        NN = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }
    
    
    
    
    
      {
        int[][] newFace_MTLVGC = {
          {
            defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
          }
        }; 
    
        allFaces.options = (int[][]) concat(allFaces.options, newFace_MTLVGC);
    
    
        int[][] newFace = {
          {
            M, B, N, D
          }
        }; 
    
        allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
      }
    
      {
        int[][] newFace_MTLVGC = {
          {
            defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility, defaultWeight, defaultClose
          }
        }; 
    
        //allFaces.options = (int[][]) concat(allFaces.options, newFace_MTLVGC);
    
    
        int[][] newFace = {
          {
            MM, B, M, A
          }
        }; 
    
        //allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace);
      }
    }
  }
  


  int[] get_selectedFace_Vertices () {
  
    int[] FaceVertices = new int [0];
  
    for (int o = selectedFace_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = selectedFace_ids[o];
  
      int f = OBJ_NUM;
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
  
        int vertex_listed = -1;
  
        for (int q = 0; q < FaceVertices.length; q++) {
          if (vNo == FaceVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }         
  
        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          FaceVertices = concat(FaceVertices, newVertexListed);
        }
      }
    }
  
  
    return FaceVertices;
  } 
  
  
  int[] get_selectedCurve_Vertices () {
  
    int[] CurveVertices = new int [0];
  
    for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = selectedCurve_ids[o];
  
      int f = OBJ_NUM;
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
        int vNo = allCurves.nodes[f][j];
  
        int vertex_listed = -1;
  
        for (int q = 0; q < CurveVertices.length; q++) {
          if (vNo == CurveVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }         
  
        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          CurveVertices = concat(CurveVertices, newVertexListed);
        }
      }
    }
  
    return CurveVertices;
  } 
  
  
  
  int[] get_selectedGroup_Vertices () {
  
    int[] PolymeshVertices = new int [0];
  
    for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = selectedGroup_ids[o];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
  
        if ((0 <= f) && (f < allFaces.nodes.length)) { 
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
            int vNo = allFaces.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
  
  
  
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
  
        if ((0 <= f) && (f < allCurves.nodes.length)) { 
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
            int vNo = allCurves.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
    }    
  
    return PolymeshVertices;
  }   
  
  
  
  
  void add_ParametricSurface (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float rx, float ry, float rz, int n, float rot) {
  
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt; 
    defaultClose = clz;
  
    if (m == -1) defaultMaterial = 0;
    else defaultMaterial = m;  
  
    float teta = rot * PI / 180.0;
  
    float stp_u = 0.1; //0.05;
    float stp_v = 0.1; //0.05;
  
    float start_u = -1;
    float start_v = -1;
    float end_u = 1;
    float end_v = 1;
  
    if (n == 1) {
      start_u = 0;
    }
    if (n == 2) {
      start_u = 0;
    }
  
    for (float a = start_u; a < end_u; a += stp_u) {
      for (float b = start_v; b < end_v; b += stp_v) {
  
        int[] newFace = {
        };
  
        for (int i = 0; i < 4; i++) {
  
          float u = a;
          float v = b;
  
          if ((i == 1) || (i == 2)) u += stp_u;
          if ((i == 2) || (i == 3)) v += stp_v;
  
          float x = 0;
          float y = 0;
          float z = 0;
  
          if (n == 1) { // LOGO:
            float x0 = cos(u * PI); 
            float y0 = sin(v * PI);
            float z0 = -sin(u * PI) * cos(v * PI);
  
            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;  
              y = y0 / d;  
              z = z0 / d;
            }
          } else if (n == 2) { 
            x = cos(u * PI); 
            y = sin(v * PI);
            z = -sin(u * PI) * cos(v * PI);
          } else if (n == 3) {
            x = sin(u * PI); 
            y = sin(v * PI);
            z = cos((u + v) * PI);
          } else if (n == 4) {
            float x0 = sin(u * PI); 
            float y0 = sin(v * PI);
            float z0 = cos((u + v) * PI);
  
            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;  
              y = y0 / d;  
              z = z0 / d;
            }
          } else if (n == 5) {
            x = u; 
            y = v; 
            z = cos(0.5 * u * PI) * cos(0.5 * v * PI);
          } else if (n == 6) {
            x = u; 
            y = v; 
            z = sin(u * PI) * sin(v * PI);
          } else if (n == 7) {
            x = u; 
            y = v; 
            z = 0.5 * cos(u * PI) + cos(v * PI);
          }
  
  
          x *= rx;
          y *= ry;
          z *= rz;
  
          float x_rot = cx + x * cos(teta) - y * sin(teta);
          float y_rot = cy + x * sin(teta) + y * cos(teta);
          float z_rot = cz + z;
  
          x = x_rot;
          y = y_rot;
          z = z_rot;
  
          int[] f = {
            this.add_Vertex(x, y, z)
          };
          newFace = concat(newFace, f);
        }
  
        if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));      
  
        this.add_Face(newFace);
      }
    }
  }  
  
  
  void add_CrystalSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int Tessellation, int isSky, float t) {
  
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt;
    defaultClose = clz;
  
    int[] vT = new int [6];
    int[] vB = new int [6];
  
    vT[0] = this.addToTempObjectVertices(0, 0, 1);
    vB[0] = this.addToTempObjectVertices(0, 0, -1);
  
    for (int i = 1; i <= 5; i++) {
      float q = i * 72 + t;
  
      float R_in = pow(5.0, 0.5) * 2.0 / 5.0;  
      float H_in = pow(5.0, 0.5) * 1.0 / 5.0;
  
      vT[i] = this.addToTempObjectVertices(R_in * cos_ang(q), R_in * sin_ang(q), H_in);
      vB[i] = this.addToTempObjectVertices(R_in * cos_ang(q + 36), R_in * sin_ang(q + 36), -H_in);
    } 
  
  
    int BuildFaces = 0;
  
    for (int Loop_Tessellation = 1; Loop_Tessellation <= Tessellation; Loop_Tessellation++) { // added so that the tree generated from the bottom to the top!
  
      if (Loop_Tessellation == Tessellation) BuildFaces = 1;
      else BuildFaces = 0;
  
      for (int i = 1; i <= 5; i++) {
  
        int next_i = (i % 5) + 1;
        int prev_i = ((i + 5 - 2) % 5) + 1;
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
          Loop_Tessellation, BuildFaces);
        }
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
          Loop_Tessellation, BuildFaces);
        }      
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          Loop_Tessellation, BuildFaces);
        }     
  
        {
          SOLARCHVISION_createLozenge(
  
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
  
          Loop_Tessellation, BuildFaces);
        }
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
          TempObjectVertices[vB[next_i]][0], TempObjectVertices[vB[next_i]][1], TempObjectVertices[vB[next_i]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
  
          Loop_Tessellation, BuildFaces);
        }
      }
    }
  
  
    //println("Vertices:", POINTER_TempObjectVertices);
    //println("Faces:", POINTER_TempObjectFaces);
  
    if (isSky == 0) {
      this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, r, r, r, t);
    } else if (isSky == 1) {
  
  
      skyVertices = new float [0][3]; 
      skyFaces = new int [0][1];
  
      for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
        float x = TempObjectVertices[i][0];
        float y = TempObjectVertices[i][1];
        float z = TempObjectVertices[i][2];
  
        float[][] newVertex = {
          {
            x, y, z
          }
        }; 
  
        skyVertices = (float[][]) concat(skyVertices, newVertex);
      }
  
      for (int i = 0; i < POINTER_TempObjectFaces; i++) {
  
        int[][] newFace = {
          {
            TempObjectFaces[i][0], TempObjectFaces[i][1], TempObjectFaces[i][2], TempObjectFaces[i][3]
          }
        }; 
  
        skyFaces = (int[][]) concat(skyFaces, newFace);
      }
  
  
      POINTER_TempObjectVertices = 0;
      POINTER_TempObjectFaces = 0;
    } else {
      // Nothing. In this case we should add temp object outside this function. See SuperSphere
    }
  }  
  
  
  
  void add_SuperSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float px, float py, float pz, float sx, float sy, float sz, int Tessellation, float t) {
  
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt; 
    defaultClose = clz;
  
    this.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, 1, Tessellation, -1, 90); // passing with isSky:-1
  
    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
    value = 1;
    posX = 0;
    posY = 0; 
    posZ = 0;    
    powX = px;
    powY = py;
    powZ = pz;    
    scaleX = 1;
    scaleY = 1; 
    scaleZ = 1;    
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];
  
      float the_dist = (pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
        z /= the_dist;
      }
  
      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }
  
    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);
  }  
  
  
  void add_SuperCylinder (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, int n, float t) {
  
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt; 
    defaultClose = clz;
  
    int[] vT = new int [n];
    int[] vB = new int [n];
  
    vT[0] = this.addToTempObjectVertices(1, 0, 1);
    vB[0] = this.addToTempObjectVertices(1, 0, -1);
  
    int[] newFaceT = {
      vT[0]
    };
    int[] newFaceB = {
      vB[0]
    };
    for (int i = 1; i < n; i++) {
      float rot = i * 360.0 / float(n);
  
      vT[i] = this.addToTempObjectVertices(cos_ang(rot), sin_ang(rot), 1);
      vB[i] = this.addToTempObjectVertices(cos_ang(rot), sin_ang(rot), -1);
      int[] fT = {
        vT[i]
      };
      int[] fB = {
        vB[i]
      };
  
      newFaceT = concat(newFaceT, fT);
      newFaceB = concat(newFaceB, fB);
    } 
  
    this.addToTempObjectFaces(newFaceT, 0); // 0:check_duplicates
    this.addToTempObjectFaces(newFaceB, 0); // 0:check_duplicates  
  
    for (int i = 0; i < n; i++) {
      int next_i = (i + 1) % n;
  
      int[] newFace = {
        vT[i], vB[i], vB[next_i], vT[next_i]
      };
  
      this.addToTempObjectFaces(newFace, 0); // 0:check_duplicates
    }  
  
    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
    value = 1;
    posX = 0;
    posY = 0; 
    posZ = 0;    
    scaleX = 1;
    scaleY = 1; 
    scaleZ = 1;    
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];
  
      float the_dist = (pow((pow(abs(x - posX) / scaleX, 2) + pow(abs(y - posY) / scaleY, 2)), 0.5) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
      }
  
      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }
  
    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);
  }
  
  
  int addToTempObjectVertices (float x, float y, float z) {
  
    float[][] newVertex = {
      {
        x, y, z
      }
    }; 
  
    int vertex_existed = 0;
  
    float min_dist = FLOAT_undefined;
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float the_dist = SOLARCHVISION_fn_dist(newVertex[0], TempObjectVertices[i]);
  
      if (the_dist < 0.1) { // avoid creating duplicate vertices - WELD is necessary for allModel1Ds spheres!
  
        if (min_dist > the_dist) {
          min_dist = the_dist;
          vertex_existed = i;
        }
      }
    }
  
    if (vertex_existed == 0) { 
  
      if (POINTER_TempObjectVertices >= TempObjectVertices.length) {
        TempObjectVertices = (float[][]) concat(TempObjectVertices, newVertex);
      } else {
        //TempObjectVertices[POINTER_TempObjectVertices] = new int [3];
  
        TempObjectVertices[POINTER_TempObjectVertices][0] = x;
        TempObjectVertices[POINTER_TempObjectVertices][1] = y;
        TempObjectVertices[POINTER_TempObjectVertices][2] = z;
      }
  
      vertex_existed = POINTER_TempObjectVertices;
  
      POINTER_TempObjectVertices += 1;
    }
  
    return(vertex_existed);
  }
  
  int addToTempObjectFaces (int[] f, int check_duplicates) {
  
    int face_existed = 0;
  
    if (check_duplicates == 1) {
  
      for (int i = 0; i < POINTER_TempObjectFaces; i++) {
        if (f.length == TempObjectFaces[i].length) {
  
          for (int k = 0; k < f.length; k++) { // "k" introduces different variations that two faces could match
  
            for (int dir = -1; dir <= 1; dir += 2) { // "dir" introduces different diretions that two faces could match
  
              //println("\ndir=", dir);
  
              float total_distances = 0; 
  
              for (int j = 0; j < f.length; j++) {
  
                int q = (j * dir + k + f.length) % f.length;
  
                //print("q=", q, "; k=" );
  
                total_distances += SOLARCHVISION_fn_dist(TempObjectVertices[f[q]], TempObjectVertices[TempObjectFaces[i][j]]);
              }
  
              if (total_distances < 0.0001) { // avoid creating duplicate faces
                //println("A duplicate face detected :", i);
  
                face_existed = i;
                break;
              }
            }
          }
        }
        if (face_existed != 0) break;
      }
    }
  
    if (face_existed == 0) { 
  
      if (POINTER_TempObjectFaces >= TempObjectFaces.length) {
        int[][] newFace = {
          f
        }; 
        TempObjectFaces = (int[][]) concat(TempObjectFaces, newFace);
      } else {
        TempObjectFaces[POINTER_TempObjectFaces] = new int [f.length];
  
        for (int i = 0; i < f.length; i++) {
          TempObjectFaces[POINTER_TempObjectFaces][i] = f[i];
        }
      }
  
      face_existed = POINTER_TempObjectFaces;
  
      POINTER_TempObjectFaces += 1;
    }
  
    return(face_existed);
  }
  
  void addTempObjectToScene (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, float t) {
  
    defaultMaterial = m;
    defaultTessellation = tes;
    defaultLayer = lyr;
    defaultVisibility = vsb;
    defaultWeight = wgt;
    defaultClose = clz;
  
    if (m == -1) defaultMaterial = 0;
    else defaultMaterial = m;
  
    for (int i = 0; i < POINTER_TempObjectFaces; i++) {
  
      int[] new_Vertex_ids = new int [TempObjectFaces[i].length];
  
      for (int j = 0; j < TempObjectFaces[i].length; j++) {
  
        float x0 = TempObjectVertices[TempObjectFaces[i][j]][0] * sx;
        float y0 = TempObjectVertices[TempObjectFaces[i][j]][1] * sy;
        float z0 = TempObjectVertices[TempObjectFaces[i][j]][2] * sz;
  
        float x = x0 * cos_ang(t) - y0 * sin_ang(t);
        float y = x0 * sin_ang(t) + y0 * cos_ang(t);
        float z = z0;
  
        new_Vertex_ids[j] = this.add_Vertex(x + cx, y + cy, z + cz);
      }
  
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));  
      this.add_Face(new_Vertex_ids);
    }
  
    TempObjectVertices = new float [0][3];
  
    TempObjectFaces = new int [0][1];
  
    POINTER_TempObjectVertices = 0;
    POINTER_TempObjectFaces = 0;
  }
  
  void SOLARCHVISION_createLozenge (float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, int Tessellation, int BuildFaces) {
  
  
    if (Tessellation > 0) {
  
      if (Tessellation == 1) {
  
        int[] newPoly = new int [4];
  
        newPoly[0] = this.addToTempObjectVertices(x1, y1, z1);    
        newPoly[1] = this.addToTempObjectVertices(x2, y2, z2);
        newPoly[2] = this.addToTempObjectVertices(x3, y3, z3);
        newPoly[3] = this.addToTempObjectVertices(x4, y4, z4);
  
        if (BuildFaces != 0) {
          this.addToTempObjectFaces(newPoly, 1); // 1:check_duplicates
        }
  
        {
          // because the vertices might be welded to a nearest point:  
  
          x1 = TempObjectVertices[newPoly[0]][0];
          y1 = TempObjectVertices[newPoly[0]][1];
          z1 = TempObjectVertices[newPoly[0]][2];
  
          x2 = TempObjectVertices[newPoly[1]][0];
          y2 = TempObjectVertices[newPoly[1]][1];
          z2 = TempObjectVertices[newPoly[1]][2];
  
          x3 = TempObjectVertices[newPoly[2]][0];
          y3 = TempObjectVertices[newPoly[2]][1];
          z3 = TempObjectVertices[newPoly[2]][2];
  
          x4 = TempObjectVertices[newPoly[3]][0];
          y4 = TempObjectVertices[newPoly[3]][1];
          z4 = TempObjectVertices[newPoly[3]][2];
        }
      }
  
  
  
      Tessellation -= 1;
  
      float[] M = {
        (x1 + x2 + x4) / 3.0, (y1 + y2 + y4) / 3.0, (z1 + z2 + z4) / 3.0
      };
      float[] N = {
        (x3 + x2 + x4) / 3.0, (y3 + y2 + y4) / 3.0, (z3 + z2 + z4) / 3.0
      };
  
      M = SOLARCHVISION_fn_normalize(M);
      N = SOLARCHVISION_fn_normalize(N);
  
      SOLARCHVISION_createLozenge(x2, y2, z2, N[0], N[1], N[2], x4, y4, z4, M[0], M[1], M[2], Tessellation, BuildFaces);     
  
  
      if (BuildFaces != 0) 
      {
  
        float[] P = M;
  
        PVector A_vec = new PVector(x1, y1, z1);
        PVector B_vec = new PVector(x2, y2, z2);
  
        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();
  
        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
  
        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };
  
        Q = SOLARCHVISION_fn_normalize(Q);
  
        SOLARCHVISION_createLozenge(x2, y2, z2, P[0], P[1], P[2], x1, y1, z1, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
      }
  
  
      if (BuildFaces != 0) 
      {
  
        float[] P = N;
  
        PVector A_vec = new PVector(x3, y3, z3);
        PVector B_vec = new PVector(x4, y4, z4);
  
        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();
  
        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
  
        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };
  
        Q = SOLARCHVISION_fn_normalize(Q);
  
        SOLARCHVISION_createLozenge(x4, y4, z4, P[0], P[1], P[2], x3, y3, z3, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
      }
    }
  }  
  
  
  void delete_Faces () {
  
    allFaces.nodes = new int [0][3];
  
    allFaces.options = new int [0][6];
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Faces[q][0] = 0;
      allGroups.Faces[q][1] = -1;
    }  
  
    this.deselect_All();
  }
  
  void delete_Curves () {
  
    allCurves.nodes = new int [0][3];
  
    allCurves.options = new int [0][6];
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Curves[q][0] = 0;
      allGroups.Curves[q][1] = -1;
    }  
  
    this.deselect_All();
  }
  
  void delete_Vertices () {
  
    allVertices = new float [0][3];
  
    this.deselect_All();
  }
  
  void delete_allGroups () {
    
    allGroups.allModel1Ds = new int [0][2];
  
    allGroups.allModel2Ds = new int [0][2];
  
    allGroups.Faces = new int [0][2];
  
    allGroups.Curves = new int [0][2];
  
    allGroups.allSolids = new int [0][2];
  
    allGroups.PivotXYZ = new float [0][9];
  
    allGroups.PivotType = new int [0][1];
  
    allGroups.num = 0;
    
    this.deselect_All();
   
  }    
  
  
  void delete_allSolids () {
    allSolids.DEF = new float [0][13]; 
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.allSolids[q][0] = 0;
      allGroups.allSolids[q][1] = -1;
    }
  
    this.deselect_All();
  }    

  
  void delete_allCameras () {
  
    allCameras.PPPSRRRF = new float [0][8]; 
  
    allCameras.Type = new int [0];
  
    this.add_veryFirstCamera();
  
    this.deselect_All();
  }
  
  void add_veryFirstCamera () {
    
    allCameras.PPPSRRRF = new float [1][8]; 
    allCameras.PPPSRRRF[0][0] = WIN3D.X_Coordinate;
    allCameras.PPPSRRRF[0][1] = WIN3D.Y_Coordinate;
    allCameras.PPPSRRRF[0][2] = WIN3D.Z_Coordinate;
    allCameras.PPPSRRRF[0][3] = WIN3D.S_Coordinate;
    allCameras.PPPSRRRF[0][4] = WIN3D.RX_Coordinate;
    allCameras.PPPSRRRF[0][5] = WIN3D.RY_Coordinate;
    allCameras.PPPSRRRF[0][6] = WIN3D.RZ_Coordinate;
    allCameras.PPPSRRRF[0][7] = WIN3D.Zoom;
  
    allCameras.Type = new int [1];
    allCameras.Type[0] = WIN3D.ViewType;  
    
    allCameras.num = 1;
  }  
  

  
  void delete_allSections () {
    allSections.UVERAB = new float [0][6]; 
  
    allSections.Type = new int [0];
  
    allSections.RES1 = new int [0];
  
    allSections.RES2 = new int [0];
  
    allSections.SolidImpact = new PImage [0];
  
    allSections.SolarImpact = new PImage [0][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
  
    allSections.num = 0;
  
    this.deselect_All();
  }

  

  
  
  void draw_Faces () {
  
    if (Display_allModel3Ds) {
  
      if (this.DisplayNormals) {
  
        for (int f = 0; f < allFaces.nodes.length; f++) {
  
          int vsb = allFaces.getVisibility(f);
  
          if (vsb > 0) {
  
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allVertices[vNo][0];
              base_Vertices[j][1] = allVertices[vNo][1];
              base_Vertices[j][2] = allVertices[vNo][2];
            }
  
            float G_x0 = 0;
            float G_y0 = 0;
            float G_z0 = 0;
  
            float G_x1 = 0;
            float G_y1 = 0;
            float G_z1 = 0;
  
            float n = float(base_Vertices.length);
  
            for (int s = 0; s < base_Vertices.length; s++) {
  
              int s_next = (s + 1) % base_Vertices.length;
              int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = SOLARCHVISION_fn_normalize(W);
  
              float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
              float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
              float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;
  
              float x1 = (base_Vertices[s][0] + W[0]) * OBJECTS_scale * WIN3D.scale;
              float y1 = (base_Vertices[s][1] + W[1]) * OBJECTS_scale * WIN3D.scale;
              float z1 = (base_Vertices[s][2] + W[2]) * OBJECTS_scale * WIN3D.scale;
  
              G_x0 += x0 / n;
              G_y0 += y0 / n;
              G_z0 += z0 / n;
  
              G_x1 += x1 / n;
              G_y1 += y1 / n;
              G_z1 += z1 / n;
            }
  
            WIN3D.graphics.strokeWeight(3);
            WIN3D.graphics.stroke(127, 255, 127);
            WIN3D.graphics.line(G_x0, -G_y0, G_z0, G_x1, -G_y1, G_z1);        
  
            WIN3D.graphics.strokeWeight(1);
            WIN3D.graphics.stroke(0, 127, 0);
  
            for (int s = 0; s < base_Vertices.length; s++) {
  
              float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
              float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
              float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;
  
              WIN3D.graphics.line(x0, -y0, z0, G_x1, -G_y1, G_z1);
            }
          }
        }
      }
  
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(0, 0, 0);
      if (this.DisplayEdges == false) WIN3D.graphics.noStroke();
  
      int PAL_TYPE = SHADE.get_PAL_TYPE(); 
      int PAL_DIR = SHADE.get_PAL_DIR();
      float PAL_Multiplier = SHADE.get_PAL_Multiplier(); 
  
      for (int f = 0; f < allFaces.nodes.length; f++) {
  
        int vsb = allFaces.getVisibility(f);
  
        if (vsb > 0) {        
  
          if (WIN3D.FacesShade == SHADE.Surface_Base) {
  
            WIN3D.graphics.fill(255, 255, 255);
  
            WIN3D.graphics.beginShape();
  
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
  
              WIN3D.graphics.vertex(allVertices[vNo][0] * OBJECTS_scale * WIN3D.scale, -(allVertices[vNo][1] * OBJECTS_scale * WIN3D.scale), allVertices[vNo][2] * OBJECTS_scale * WIN3D.scale);
            }    
  
            WIN3D.graphics.endShape(CLOSE);
          } else {
  
            int mt = allFaces.getMaterial(f);
  
            int Tessellation = allFaces.getTessellation(f);
  
            int TotalSubNo = 1;  
            if (allFaces.getMaterial(f) == 0) {
              Tessellation += this.Tessellation;
            }
            if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allVertices[vNo][0];
              base_Vertices[j][1] = allVertices[vNo][1];
              base_Vertices[j][2] = allVertices[vNo][2];
            }
  
            for (int n = 0; n < TotalSubNo; n++) {
  
              float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
  
              WIN3D.graphics.beginShape();
  
              for (int s = 0; s < subFace.length; s++) {
  
                if (WIN3D.FacesShade != SHADE.Surface_Wire) {
  
                  float[] COL = {
                    255, 255, 255, 255
                  };
  
                  if (WIN3D.FacesShade == SHADE.Global_Solar) {
                    int s_next = (s + 1) % subFace.length;
                    int s_prev = (s + subFace.length - 1) % subFace.length;
                    
                    COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }        
            
                  if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
  
                    COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }                   
  
                  if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
  
                    COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }
  
                  if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
  
                    COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }
  
                  if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                    COL = SHADE.vertexRender_Surface_Materials(mt);
                  }              
  
                  if (WIN3D.FacesShade == SHADE.Surface_White) {
                    COL = SHADE.vertexRender_Surface_White(255);
                  }
             
                  WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                } else {
                  WIN3D.graphics.noFill();
                }
  
                WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -(subFace[s][1] * OBJECTS_scale * WIN3D.scale), subFace[s][2] * OBJECTS_scale * WIN3D.scale);
              }
  
              WIN3D.graphics.endShape(CLOSE);
            }
          }
        }
      }
    }
  }
  
  
  
  void draw_Curves () {
  
    WIN3D.graphics.strokeWeight(3);
    
    WIN3D.graphics.noFill();
  
    if (Display_allModel3Ds) {
      
      for (int f = 0; f < allCurves.nodes.length; f++) {    
        
        int vsb = allCurves.getVisibility(f);
  
        if (vsb > 0) {      
      
          int mt = allCurves.getMaterial(f);  
      
          float[] COL = {
            Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]
          };      
          
          float weight = 0.1 * allCurves.getWeight(f);
        
          WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);    
      
          int Tessellation = int(pow(2, allCurves.getTessellation(f)));
  
          float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
            int vNo = allCurves.nodes[f][j];
            base_Vertices[j][0] = allVertices[vNo][0];
            base_Vertices[j][1] = allVertices[vNo][1];
            base_Vertices[j][2] = allVertices[vNo][2];
          }
          
          
          WIN3D.graphics.beginShape();
          
          int div = base_Vertices.length;
          
          for (int j = 0; j < base_Vertices.length; j++) {
            
            int drawSegment = 1;
            
            int nA = j % div;
            int nB = (j + 1)  % div;
            int nB_after = (j + 2) % div;
            int nA_before = (j - 1 + div) % div;        
            
            if (allCurves.getClose(f) == 0) { // if not closed
  
              if (nB_after < nB) nB_after = nB;
              if (nA_before > nA) nA_before = nA; 
              
              if (j == base_Vertices.length - 1) drawSegment = 0; 
            }
            
            if (drawSegment == 1) {
  
              for (int q = 0; q <= Tessellation; q++) {
    
                float[] P = {0, 0, 0};
                
                for (int i = 0; i < 3; i++) {
                  P[i] = ((Tessellation - q) * base_Vertices[nA][i] + q * base_Vertices[nB][i]) / float(Tessellation);
                }
                
                
                float[] ANG_start = {0, 0, 0};
                float[] ANG_end = {0, 0, 0};
                
                for (int i = 0; i < 3; i++) {
                  ANG_start[i] = base_Vertices[nA][i] - base_Vertices[nA_before][i];
    
                  ANG_end[i] = base_Vertices[nB][i] - base_Vertices[nB_after][i];
                }
                
                if ((ANG_start[0] != 0) || (ANG_start[1] != 0) || (ANG_start[2] != 0)) {
                  ANG_start = SOLARCHVISION_fn_normalize(ANG_start);
                }
                if ((ANG_end[0] != 0) || (ANG_end[1] != 0) || (ANG_end[2] != 0)) {
                  ANG_end = SOLARCHVISION_fn_normalize(ANG_end);
                }
              
              
                float dist_start = dist(P[0], P[1], P[2], base_Vertices[nA][0], base_Vertices[nA][1], base_Vertices[nA][2]);
                float dist_end = dist(P[0], P[1], P[2], base_Vertices[nB][0], base_Vertices[nB][1], base_Vertices[nB][2]);
                
                for (int i = 0; i < 3; i++) {
                  ANG_start[i] *= dist_start;
                  ANG_end[i] *= dist_end;
                }
                
                for (int i = 0; i < 3; i++) {
                  P[i] += weight * ((Tessellation - q) * ANG_start[i] + q * ANG_end[i]) / float(Tessellation);
                }        
     
                
                
                WIN3D.graphics.vertex(P[0] * OBJECTS_scale * WIN3D.scale, -(P[1] * OBJECTS_scale * WIN3D.scale), P[2] * OBJECTS_scale * WIN3D.scale);
                
              }
            }
            
          }
          
          if (allCurves.getClose(f) == 0) { // if not closed
            WIN3D.graphics.endShape();
          }
          else {
            WIN3D.graphics.endShape(CLOSE);
          }
            
            
        }
      }
    }
    
    WIN3D.graphics.strokeWeight(0);
  }
  
  
  
  
  
  void draw_Vertices () {
  
    WIN3D.graphics.strokeWeight(3);
  
    WIN3D.graphics.stroke(0); 
    
    WIN3D.graphics.noFill();
     
  
    if (this.DisplayVertices) {
      
      float d = 0.5; // <<<<<<<<<<<<<< distance 
  
      for (int f = 0; f < allVertices.length; f++) {    
                
        float x = allVertices[f][0];
        float y = allVertices[f][1];
        float z = allVertices[f][2];
        
        WIN3D.graphics.line((x - d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, (x + d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);
  
        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -((y - d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -((y + d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);
  
        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z - d) * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z + d) * OBJECTS_scale * WIN3D.scale);
  
              
      }
    }
    
    WIN3D.graphics.strokeWeight(0);
  }
  
  
  
  void add_DefaultModel (int n) {
  
    if (Land3D.Load_Mesh) {
  
      allModel2Ds.add_onLand(1); // 1 = people
  
      allModel2Ds.add_onLand(2); // 2 = 2D trees
    } else {
      //allModel2Ds.add_polar(1, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // people
      //allModel2Ds.add_polar(2, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // trees
    }  
  
  
  
    //if (n != 0) {
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    this.add_Mesh2(8, 0, 0, 1, 0, 0, -25, -25, 0, 25, 25, 0);
    //}
  
    if (n == 1) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 90);
    }
  
    if (n == 2) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0);
    }  
  
    if (n == 3) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_PolygonHyper(0, 0, 0, 1, 0, 0, 0, 0, 5, 10, 10, 4, 0);
  
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(7, 0, 0, 1, 0, 0, 25, 25, 0, 6, 6, 6, 6, 0);
    }   
  
    if (n == 4) {
      for (int i = 0; i < int (10 + random (10)); i++) {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        this.add_House1_Core(7, 0, 0, 1, 0, 0, random(-80, 80), random(-80, 80), 0, random(5, 10), random(5, 10), random(5, 10), random(2.5, 7.5), random(360));
      }
    }    
  
  
    if (n == 5) {
      //SOLARCHVISION Complex:
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 3);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 2, 1, 1, 3, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 2, 1, 3, 3);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 0, 0, 6, 4, 0.5);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7, 0, 0, 9, 2, 2);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7, 3, 0, 9, 4, 4);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 0, 0, 13, 4, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 0, 0, 13, 1, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 1, 0, 10.5, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12.5, 1, 0, 13, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 3, 0, 13, 4, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 4, 0, 1, 8, 2);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5, 0, 4, 8, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5, 0, 4, 5.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5.5, 0, 2.5, 7.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 3.5, 5.5, 0, 4, 7.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 7.5, 0, 4, 8, 2);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 5, 0, 8, 8, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 9, 5, 0, 11, 9, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 5, 0, 13, 7, 4);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 8, 0, 13, 9, 8);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 9, 0, 4, 11, 1);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 9, 0, 8, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 9, 0, 5.5, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5.5, 9, 0, 7.5, 9.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5.5, 10.5, 0, 7.5, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7.5, 9, 0, 8, 11, 2);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 0, 3, 13, 3);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 0, 3, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 1, 1, 13, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 12, 1, 3, 13, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 2, 3, 13, 3);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 4, 12, 0, 8, 13, 2);
  
      //this.add_Box_Corners(-1, 0 , 0 , 1 ,0, 0, 9, 10, 0, 13, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 9, 10, 0, 10, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 10, 0, 12, 10.5, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 12.5, 0, 12, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 10, 0, 13, 13, 1);
  
      float model_scale = 12; // to make grid scale equal to 12m. <<<<
  
      for (int i = 1; i < allVertices.length; i++) {
        allVertices[i][0] -= 6.5;
        allVertices[i][1] -= 6.5; 
  
        allVertices[i][0] *= model_scale;
        allVertices[i][1] *= model_scale; 
        allVertices[i][2] *= model_scale;
      }
    }      
  
    if (n == 6) {
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 0;
        float z = 0;
        float r = 10;
        this.add_CrystalSphere(1, 0, 0, 1, 0, 0, x, y, z, r, 5, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
  
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 30;
        float y = 0;
        float z = 0;
        float r = 8;
        this.add_CrystalSphere(2, 0, 0, 1, 0, 0, x, y, z, r, 4, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
  
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 20;
        float z = 0;
        float r = 8;
        this.add_CrystalSphere(3, 0, 0, 1, 0, 0, x, y, z, r, 3, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
    }
  
    if (n == 7) {
      this.add_Model_Main();
    }
  }  
  
  int maximum_default_models = 7;
  
  
  void add_Model_2DsFromFile () {
  
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
  
    String[] FileALL = loadStrings(BaseFolder + "/Import/Hamedan_PEOPLE.txt");
  
    String lineSTR;  
  
    for (int f = 1; f < FileALL.length; f++) { // skip the first line.
  
      lineSTR = FileALL[f];
      //println(lineSTR);
  
      String[] parts = split(lineSTR, ',');
  
      float x = float(parts[0]);
      float y = float(parts[1]);
      float z = float(parts[2]);
  
      allModel2Ds.add_single("PEOPLE", 0, x, y, z, 2.5);
    }
  }
  
  
  
  void add_Model_Main () { 
  
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
    addToLastGroup = 0;
  }
  
  
  
}

solarchvision_Model3Ds allModel3Ds = new solarchvision_Model3Ds();




class solarchvision_Cameras {

  private final static String CLASS_STAMP = "Cameras";
  
  float[][] PPPSRRRF = {
    {
      WIN3D.X_Coordinate, WIN3D.Y_Coordinate, WIN3D.Z_Coordinate, WIN3D.S_Coordinate, WIN3D.RX_Coordinate, WIN3D.RY_Coordinate, WIN3D.RZ_Coordinate, WIN3D.Zoom
    }
  };
  int[] Type = {
    WIN3D.ViewType
  };
  int num = 1;
  
  
  private float[][] Vertices;
  private int[][] Faces;
  
  void draw () {
  
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
    if (Display_allCameras) {
  
      for (int f = 0; f < this.num; f++) {
  
        float Camera_X = this.PPPSRRRF[f][0];
        float Camera_Y = this.PPPSRRRF[f][1];
        float Camera_Z = this.PPPSRRRF[f][2];
        float Camera_S = this.PPPSRRRF[f][3];
        float Camera_RX = this.PPPSRRRF[f][4];
        float Camera_RY = this.PPPSRRRF[f][5];
        float Camera_RZ = this.PPPSRRRF[f][6];
        float Camera_ZOOM = this.PPPSRRRF[f][7];
  
        int Camera_Type = this.Type[f];
  
        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        WIN3D.graphics.noFill();  
  
        WIN3D.graphics.beginShape();
  
        float[][] ImageVertex = getCorners(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);
  
        for (int q = 1; q <= 4; q++) {
  
          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];
  
          WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
  
          this.Vertices[f * 4 + q - 1][0] = x;
          this.Vertices[f * 4 + q - 1][1] = y;
          this.Vertices[f * 4 + q - 1][2] = z;
        }        
  
        this.Faces[f][0] = f * 4 + 0;
        this.Faces[f][1] = f * 4 + 1;
        this.Faces[f][2] = f * 4 + 2;
        this.Faces[f][3] = f * 4 + 3;  
  
        WIN3D.graphics.endShape(CLOSE);
  
        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        //WIN3D.graphics.fill(127,255,127,127);
        WIN3D.graphics.noFill();
  
        WIN3D.graphics.beginShape();
  
        for (int q = 1; q <= 4; q++) {
  
          {
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
  
          {
            int next_q = 1 + (q % 4); 
  
            float x = ImageVertex[next_q][0];
            float y = ImageVertex[next_q][1];
            float z = ImageVertex[next_q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
  
          {
            int o = 0; 
  
            float x = ImageVertex[o][0];
            float y = ImageVertex[o][1];
            float z = ImageVertex[o][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
        }        
  
        WIN3D.graphics.endShape(CLOSE);
      }
  
      WIN3D.graphics.strokeWeight(0);
    }
  }
  
  
  float[][] getCorners (int Camera_Type, float Camera_X, float Camera_Y, float Camera_Z, float Camera_S, float Camera_RX, float Camera_RY, float Camera_RZ, float Camera_ZOOM) {
  
    float[][] ImageVertex = new float [5][3];
  
    float r = Camera_S * 5; // <<<<<<
  
    float rx = r * sin_ang(0.5 * Camera_ZOOM) /  WIN3D.R_View;
    float ry = r * sin_ang(0.5 * Camera_ZOOM);  
    float rz = r * cos_ang(0.5 * Camera_ZOOM);  
  
    for (int q = 0; q < 5; q++) {  
  
      float qx = 0, qy = 0, qz = 0;
  
      if (q == 0) {
        qx = 0; 
        qy = 0; 
        qz = 0;
      } else if (q == 1) {
        qx = -1; 
        qy = -1; 
        qz = -1;
      } else if (q == 2) {
        qx = -1; 
        qy = 1; 
        qz = -1;
      } else if (q == 3) {
        qx = 1; 
        qy = 1; 
        qz = -1;
      } else if (q == 4) {
        qx = 1; 
        qy = -1; 
        qz = -1;
      }
  
      float x = 0, y = 0, z = 0;
  
      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
      float keep_WIN3D_X_Coordinate = WIN3D.X_Coordinate; 
      float keep_WIN3D_Y_Coordinate = WIN3D.Y_Coordinate;
      float keep_WIN3D_Z_Coordinate = WIN3D.Z_Coordinate;
      float keep_WIN3D_S_Coordinate = WIN3D.S_Coordinate;
      float keep_WIN3D_RX_Coordinate = WIN3D.RX_Coordinate; 
      float keep_WIN3D_RY_Coordinate = WIN3D.RY_Coordinate;
      float keep_WIN3D_RZ_Coordinate = WIN3D.RZ_Coordinate;
      float keep_WIN3D_Zoom = WIN3D.Zoom;
  
      {
  
        WIN3D.X_Coordinate = Camera_X;
        WIN3D.Y_Coordinate = Camera_Y;
        WIN3D.Z_Coordinate = Camera_Z;
        WIN3D.S_Coordinate = Camera_S;
        WIN3D.RX_Coordinate = Camera_RX; 
        WIN3D.RY_Coordinate = Camera_RY;
        WIN3D.RZ_Coordinate = Camera_RZ;
        WIN3D.Zoom = Camera_ZOOM;
  
        WIN3D.transform_3DViewport();
  
        float x1 = rx * qx;
        float y1 = ry * qy;
        float z1 = rz * qz;
  
        float x2 = x1;
        float y2 = y1 * cos_ang(Camera_RX) - z1 * sin_ang(Camera_RX);
        float z2 = y1 * sin_ang(Camera_RX) + z1 * cos_ang(Camera_RX);
  
        float x3 = x2 * cos_ang(Camera_RZ) - y2 * sin_ang(Camera_RZ);
        float y3 = x2 * sin_ang(Camera_RZ) + y2 * cos_ang(Camera_RZ);
        float z3 = z2;
  
        x = WIN3D.CAM_x + x3;
        y = WIN3D.CAM_y + y3;
        z = WIN3D.CAM_z + z3;
      }
  
      WIN3D.CAM_x = keep_WIN3D_CAM_x;
      WIN3D.CAM_y = keep_WIN3D_CAM_y;
      WIN3D.CAM_z = keep_WIN3D_CAM_z;
      WIN3D.X_Coordinate = keep_WIN3D_X_Coordinate; 
      WIN3D.Y_Coordinate = keep_WIN3D_Y_Coordinate;
      WIN3D.Z_Coordinate = keep_WIN3D_Z_Coordinate;
      WIN3D.S_Coordinate = keep_WIN3D_S_Coordinate;
      WIN3D.RX_Coordinate = keep_WIN3D_RX_Coordinate; 
      WIN3D.RY_Coordinate = keep_WIN3D_RY_Coordinate;
      WIN3D.RZ_Coordinate = keep_WIN3D_RZ_Coordinate;
      WIN3D.Zoom = keep_WIN3D_Zoom;
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }
  
    return ImageVertex;
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = SOLARCHVISION_isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }  
  
  

  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.PPPSRRRF[i].length; j++) {
      for (int j = 0; j < 8; j++) { // x, y, z, s, rx, ry, rz, zoom
        lineSTR += nf(this.PPPSRRRF[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(this.Type[i], 0);
      lineSTR += ",";

      child.setContent(lineSTR);
    }
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = parent.getInt("ni");

    this.PPPSRRRF = new float [ni][8];
    this.Type = new int [ni];

    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 8; j++) {
        this.PPPSRRRF[i][j] = float(parts[j]);
      }

      this.Type[i] = int(parts[8]);
    }
  }    

}

solarchvision_Cameras allCameras = new solarchvision_Cameras();



class solarchvision_Sections {

  private final static String CLASS_STAMP = "Sections";

  float[][] UVERAB = new float[0][6];
  int[] Type = new int[0];
  
  int[] RES1 = new int[0];
  int[] RES2 = new int[0];
  int num = 0;


  private float[][] Vertices;
  private int[][] Faces;
  
  PImage[] SolidImpact = new PImage[0];
  PImage[][][] SolarImpact = new PImage [0][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];

  void resize_SolarImpact_array () { // called when STUDY.j_End changes
  
    allSections.SolarImpact = new PImage [allSections.num][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      for (int i = 0; i < allSections.num; i++) {
        for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) { 
          for (int q = 0; q < numberOfImpactVariations; q++) {
            allSections.SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
          }
        }
      }
    }
  
  }  
  
  
  void draw (int target_window) {
    
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
  
    boolean proceed = true;
  
    if (Display_allSections) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if (proceed) {
  
      for (int f = 0; f < this.num; f++) {
  
        float Section_offset_U = this.UVERAB[f][0];
        float Section_offset_V = this.UVERAB[f][1];
        float Section_Elevation = this.UVERAB[f][2];
        float Section_Rotation = this.UVERAB[f][3];
        float Section_scale_U = this.UVERAB[f][4];
        float Section_scale_V = this.UVERAB[f][5];
  
        int Section_Type = this.Type[f];
        int Section_RES1 = this.RES1[f];
        int Section_RES2 = this.RES2[f];
  
        if (Section_Type != 0) {
          
          String the_filename = "Impact_" + nf(f, 0) + ".bmp";
          
          if (Export_MaterialLibrary) {
  
            String TEXTURE_path = allModel3DsFolder + "/" + Export_MapsSubfolder + the_filename;
  
            if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
  
              if (Display_SolarImpactImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolarImpact[f][IMPACTS_DisplayDay][Impact_TYPE].save(TEXTURE_path);
              } else if (Display_SolidImpactImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolidImpact[f].save(TEXTURE_path);
              }
  
              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
                htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Export_MapsSubfolder + the_filename + "'><ImageTexture/>");
                htmlOutput.println("\t\t\t\t</Appearance>");
              }
    
              if (target_window == TypeWindow.OBJ) {
    
                mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      
                //mtlOutput.println("\tmap_Ka " + Export_MapsSubfolder + the_filename); // ambient map
                mtlOutput.println("\tmap_Kd " + Export_MapsSubfolder + the_filename); // diffuse map
              }
            }
          }
  
  
          if (target_window == TypeWindow.OBJ) {
  
            if (Export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;  
              objOutput.println("g Impact_" + nf(f, 0));
            }
    
            if (Export_MaterialLibrary) {
              objOutput.println("usemtl " + the_filename.replace('.', '_'));
            }
          }
  
  
          float[][] subFace = getCorners(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
    
  
          num_vertices_added = 0;
        
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
  
            boolean display_image = false;
            
            if (target_window == TypeWindow.WIN3D) {
      
              WIN3D.graphics.beginShape();
  
              WIN3D.graphics.noStroke();
              WIN3D.graphics.noFill();
    
              if (Display_SolarImpactImage) { 
                
                WIN3D.graphics.texture(this.SolarImpact[f][IMPACTS_DisplayDay][Impact_TYPE]);
  
              } else if (Display_SolidImpactImage) {
                
                WIN3D.graphics.texture(this.SolidImpact[f]);
              }  
              
            }
    
  
            for (int q = 1; q <= 4; q++) {
    
              float x = subFace[q][0];
              float y = subFace[q][1];
              float z = subFace[q][2];
              float u = subFace[q][3];
              float v = subFace[q][4];
    
              if (target_window == TypeWindow.WIN3D) {
    
                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * Section_RES1, v * Section_RES2);
              }
              
              
              if (target_window == TypeWindow.OBJ) {
                
                v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }
  
                if (_turn == 2) {
                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }
  
                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }           
              } 
    
              this.Vertices[f * 4 + q - 1][0] = x;
              this.Vertices[f * 4 + q - 1][1] = y;
              this.Vertices[f * 4 + q - 1][2] = z;
            }       
           
            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }
    
            this.Faces[f][0] = f * 4 + 0;
            this.Faces[f][1] = f * 4 + 1;
            this.Faces[f][2] = f * 4 + 2;
            this.Faces[f][3] = f * 4 + 3;  
          }
          
          if (target_window == TypeWindow.OBJ) {
  
            String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber - 0, 0);
  
            String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
  
            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (Export_BackSides) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
  
          }
          
          
          if (target_window == TypeWindow.HTML) {
            
            htmlOutput.println("\t\t\t\t<shape>");
  
            htmlOutput.println("\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");
  
            
            htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
           
            htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
            for (int s = 1; s < subFace.length; s++) {
              if (s > 1) {
                htmlOutput.print(",");
              }                  
              
              htmlOutput.print(nf(subFace[s][0], 0, Export_PrecisionVertex) + " " + nf(subFace[s][1], 0, Export_PrecisionVertex) + " " + nf(subFace[s][2], 0, Export_PrecisionVertex));
            }                
            htmlOutput.println("'></Coordinate>");          
            
            
            for (int s = 1; s < subFace.length; s++) {
              
              float u = subFace[s][3];
              float v = subFace[s][4];
              
              if (s == 1) {
                htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
              }
              if (s > 1) {
                htmlOutput.print(",");
              }                  
    
              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
              SOLARCHVISION_HTMLprintVtexture(u, v);
              
              if (s == subFace.length - 1) {
                htmlOutput.println("'></TextureCoordinate>");
              }     
            }  
  
          
    
            htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
           
            htmlOutput.println("\t\t\t\t</shape>");          
          }
      
        }
      }
  
    }
  
  }
  
  
  float[][] getCorners (int Section_Type, float Section_offset_U, float Section_offset_V, float Section_Elevation, float Section_Rotation, float Section_scale_U, float Section_scale_V, int Section_RES1, int Section_RES2) {
  
    float[][] ImageVertex = new float [5][5];
  
    for (int q = 0; q < 5; q++) {
  
      float qx = 0, qy = 0, u = 0, v = 0;
  
      if (q == 0) {
        qx = 0; 
        qy = 0; 
        u = 0.5; 
        v = 0.5;
      } // center    
      else if (q == 1) {
        qx = -1; 
        qy = -1; 
        u = 0; 
        v = 1;
      } else if (q == 2) {
        qx = 1; 
        qy = -1; 
        u = 1; 
        v = 1;
      } else if (q == 3) {
        qx = 1; 
        qy = 1; 
        u = 1; 
        v = 0;
      } else if (q == 4) {
        qx = -1; 
        qy = 1; 
        u = 0; 
        v = 0;
      }    
  
      float a = qx * 0.5 * Section_scale_U + Section_offset_U;
      float b = qy * 0.5 * Section_scale_V + Section_offset_V;
      float c = Section_Elevation;  
  
      float x = 0, y = 0, z = 0;
  
      if (Section_Type == 1) {
        x = a * cos_ang(Section_Rotation) - b * sin_ang(Section_Rotation);
        y = a * sin_ang(Section_Rotation) + b * cos_ang(Section_Rotation);
        z = c;
      } else if (Section_Type == 2) {
        x = a * cos_ang(Section_Rotation) - c * sin_ang(Section_Rotation);
        y = -(a * sin_ang(Section_Rotation) + c * cos_ang(Section_Rotation));
        z = b;
      } else if (Section_Type == 3) {
        x = a * cos_ang(90 - Section_Rotation) - c * sin_ang(90 - Section_Rotation); // ????????????
        y = -(a * sin_ang(90 - Section_Rotation) + c * cos_ang(90 - Section_Rotation)); // ????????????
        z = b;
      }      
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
      ImageVertex[q][3] = u;
      ImageVertex[q][4] = v;
    }
  
    return ImageVertex;
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = SOLARCHVISION_isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.UVERAB[i].length; j++) {
      for (int j = 0; j < 6; j++) { // u, v, e, r, a, b
        lineSTR += nf(this.UVERAB[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(this.Type[i], 0);
      lineSTR += ",";
      lineSTR += nf(this.RES1[i], 0);
      lineSTR += ",";
      lineSTR += nf(this.RES2[i], 0);

      child.setContent(lineSTR);
    }
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = parent.getInt("ni");

    this.UVERAB = new float [ni][6];
    this.Type = new int [ni];
    this.RES1 = new int [ni];
    this.RES2 = new int [ni];
    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 6; j++) {
        this.UVERAB[i][j] = float(parts[j]);
      }

      this.Type[i] = int(parts[6]);
      this.RES1[i] = int(parts[7]);
      this.RES2[i] = int(parts[8]);
    }
  }  
  
}  

solarchvision_Sections allSections = new solarchvision_Sections();








void SOLARCHVISION_resize_VertexSolar_array () { // called when STUDY.j_End changes

  VertexSolar_XYZ     = new float [0][3];
  VertexSolar_amounts = new float [2][1 + STUDY.j_End - STUDY.j_Start][0];

  rebuild_VertexSolar_array = 0;
}


void SOLARCHVISION_calculate_VertexSolar_array () {
  
  cursor(WAIT);

  SOLARCHVISION_resize_VertexSolar_array();

  float keep_STUDY_PerDays = STUDY.PerDays;
  int keep_STUDY_JoinDays = STUDY.JoinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.PerDays = 1;
    STUDY.JoinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;

  Impact_TYPE = Impact_ACTIVE; 
  if (STUDY.PlotImpacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int[][] PROCESSED_DAILY_SCENARIOS = {
    {
    }
  };  
  
  float Progress = 0;

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if (1 + Progress < 100 * f / float(allFaces.nodes.length)) { 
      Progress = 100 * f / float(allFaces.nodes.length);
      println("Progress:", int(Progress), "%");
    }

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allModel3Ds.Tessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allVertices[vNo][0];
        base_Vertices[j][1] = allVertices[vNo][1];
        base_Vertices[j][2] = allVertices[vNo][2];
      }     

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

        for (int s = 0; s < subFace.length; s++) {
          
          int q = SHADE.findID_SolarImpact_atXYZ(subFace[s][0], subFace[s][1], subFace[s][2]);
          
          if (q < 0) { // this will compute and add new points to the list only if there are not computed before.
  
            int s_next = (s + 1) % subFace.length;
            int s_prev = (s + subFace.length - 1) % subFace.length;
  
            PVector U = new PVector(subFace[s_next][0] - subFace[s][0], subFace[s_next][1] - subFace[s][1], subFace[s_next][2] - subFace[s][2]);
            PVector V = new PVector(subFace[s_prev][0] - subFace[s][0], subFace[s_prev][1] - subFace[s][1], subFace[s_prev][2] - subFace[s][2]);
            PVector UV = U.cross(V);
            float[] W = {
              UV.x, UV.y, UV.z
            };
            W = SOLARCHVISION_fn_normalize(W);
  
            float Alpha = asin_ang(W[2]);
            float Beta = atan2_ang(W[1], W[0]) + 90; 
  
            float[] VECT = {
              0, 0, 0
            }; 
  
            if (abs(Alpha) > 89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = 1;
            } else if (Alpha < -89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = -1;
            } else {
              VECT[0] = sin_ang(Beta);
              VECT[1] = -cos_ang(Beta);
              VECT[2] = tan_ang(Alpha);
            }  
  
            VECT = SOLARCHVISION_fn_normalize(VECT);
            
            
            float SkyMask = 0;
            
            for (int i = 0; i < DiffuseVectors.length; i++) {
              float[] SkyV = {
                DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
              };
  
              float tmp = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SkyV), SOLARCHVISION_fn_normalize(VECT));
              if (tmp <= 0) tmp = 0; // removes backing faces
           
              SkyMask += tmp / float(DiffuseVectors.length);
            }   
            
            
  
            int l = STUDY.ImpactLayer;
  
            int DATE_step = 1;
      
            int J_START = STUDY.j_Start;
            int J_END = STUDY.j_End;
      
            float TOTAL_valuesSUM_RAD = FLOAT_undefined;
            float TOTAL_valuesSUM_EFF_P = FLOAT_undefined;
            float TOTAL_valuesSUM_EFF_N = FLOAT_undefined;
            int TOTAL_valuesNUM = 0;                          
      
            for (int j = J_START; j < J_END; j += DATE_step) {
              
              float _valuesSUM_RAD = FLOAT_undefined;
              float _valuesSUM_EFF_P = FLOAT_undefined;
              float _valuesSUM_EFF_N = FLOAT_undefined;
              int _valuesNUM = 0;                     
  
              now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;
  
              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }
  
              float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
              float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
              float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
              int[] Normals_COL_N;
  
  
              if (PROCESSED_DAILY_SCENARIOS.length > STUDY.j_End - STUDY.j_Start) {
                Normals_COL_N = PROCESSED_DAILY_SCENARIOS[STUDY.j_End - STUDY.j_Start];
              } else {
                Normals_COL_N = new int [9];
                Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
                int[][] newNormals = {
                  Normals_COL_N
                };
                PROCESSED_DAILY_SCENARIOS = (int[][]) concat(PROCESSED_DAILY_SCENARIOS, newNormals);
                //println("length of PROCESSED_DAILY_SCENARIOS =", PROCESSED_DAILY_SCENARIOS.length);
              }
  
              int nk = Normals_COL_N[l];
  
              if (nk != -1) {
                int k = int(nk / STUDY.JoinDays);
                int j_ADD = nk % STUDY.JoinDays; 
  
                for (int i = 0; i < 24; i++) {
  
                  if (STUDY.isInHourlyRange(i) == 1) {
  
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                    if (SunR[3] > 0) {
  
                      now_k = k + start_k;
                      now_i = i;
                      now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;
  
                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }
  
                      Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                      Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                      Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                      Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
  
                      if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                        _values_R_dir = FLOAT_undefined;
                        _values_R_dif = FLOAT_undefined;
                        _values_E_dir = FLOAT_undefined;
                        _values_E_dif = FLOAT_undefined;
                      } else {
  
                        int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                        
                        if (memberCount == 1) {
                          _values_R_dir = 0.001 * Pa; 
                          _values_R_dif = 0.001 * Pb;  
                          _values_E_dir = 0.001 * Pc;
                          _values_E_dif = 0.001 * Pd;
  
                          if (is_undefined_FLOAT(_valuesSUM_RAD)) {
                            _valuesSUM_RAD = 0;
                            _valuesSUM_EFF_P = 0;
                            _valuesSUM_EFF_N = 0;
                            _valuesNUM = 0;
                          } else {
  
  
  
                            float[] SunV = {
                              SunR[1], SunR[2], SunR[3]
                            };
  
                            float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
                            if (SunMask <= 0) SunMask = 0; // removes backing faces 
  
  
  
                            float[] ray_start = subFace[s];     
                            float[] ray_direction = {
                              SunR[1], SunR[2], SunR[3]
                            }; 
  
                            if (SOLARCHVISION_fn_dot(W, ray_direction) > 0) { // removes backing faces
  
                              if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) { 
                                if (_values_E_dir < 0) {
                                  _valuesSUM_EFF_P += -(_values_E_dir * SunMask); 
                                  _valuesSUM_EFF_N += -(_values_E_dif * SkyMask); 
                                } else {
                                  _valuesSUM_EFF_N += (_values_E_dir * SunMask); 
                                  _valuesSUM_EFF_P += (_values_E_dif * SkyMask); 
                                }
  
                                _valuesSUM_RAD += (_values_R_dif * SkyMask);
                              } else { 
                                if (_values_E_dir < 0) {
                                  _valuesSUM_EFF_N += -((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
                                } else {
                                  _valuesSUM_EFF_P += ((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
                                }
  
                                _valuesSUM_RAD += ((_values_R_dir * SunMask) + (_values_R_dif * SkyMask)); // calculates total radiation
                              }
                            }
                            _valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
              
  
              if (_valuesNUM != 0) {
                //float _valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * _valuesNUM);  
                //float _valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * _valuesNUM);
                float _valuesMUL = roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * _valuesNUM);
  
                _valuesSUM_RAD *= _valuesMUL;
                _valuesSUM_EFF_P *= _valuesMUL;
                _valuesSUM_EFF_N *= _valuesMUL;
  
                if (TOTAL_valuesNUM == 0) {
                  TOTAL_valuesSUM_RAD = 0;
                  TOTAL_valuesSUM_EFF_P = 0;
                  TOTAL_valuesSUM_EFF_N = 0;
                }
  
                TOTAL_valuesSUM_RAD += _valuesSUM_RAD;
                TOTAL_valuesSUM_EFF_P += _valuesSUM_EFF_P;
                TOTAL_valuesSUM_EFF_N += _valuesSUM_EFF_N;
                TOTAL_valuesNUM += 1;
              } else {
                _valuesSUM_RAD = FLOAT_undefined;
                _valuesSUM_EFF_P = FLOAT_undefined;
                _valuesSUM_EFF_N = FLOAT_undefined;
              }
              
              float AVERAGE, PERCENTAGE, COMPARISON;
  
              AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
              if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
              else PERCENTAGE = 0.0;
              COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
              //println("3D-Model >> _valuesSUM_RAD:", _valuesSUM_RAD, "|COMPARISON:", COMPARISON);
  
              float[] ADD_values_RAD = {
                _valuesSUM_RAD
              };
              VertexSolar_amounts[Impact_ACTIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][j + 1], ADD_values_RAD);
  
              float[] ADD_values_EFF = {
                COMPARISON
              };
              VertexSolar_amounts[Impact_PASSIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][j + 1], ADD_values_EFF);
             
            }    
  
  
            if (TOTAL_valuesNUM != 0) {
              TOTAL_valuesSUM_RAD /= 1.0 * TOTAL_valuesNUM;
              TOTAL_valuesSUM_EFF_P /= 1.0 * TOTAL_valuesNUM;
              TOTAL_valuesSUM_EFF_N /= 1.0 * TOTAL_valuesNUM;
            } else {
              TOTAL_valuesSUM_RAD = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_P = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_N = FLOAT_undefined;
            }
  
  
            float AVERAGE, PERCENTAGE, COMPARISON;
  
            AVERAGE = (TOTAL_valuesSUM_EFF_P - TOTAL_valuesSUM_EFF_N);
            if ((TOTAL_valuesSUM_EFF_P + TOTAL_valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P - TOTAL_valuesSUM_EFF_N) / (1.0 * (TOTAL_valuesSUM_EFF_P + TOTAL_valuesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
  
            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 
  
            //println("3D-Model >> _valuesSUM_RAD:", _valuesSUM_RAD, "|COMPARISON:", COMPARISON);
  
            float[] ADD_values_RAD = {
              TOTAL_valuesSUM_RAD
            };
            VertexSolar_amounts[Impact_ACTIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][0], ADD_values_RAD);
  
            float[] ADD_values_EFF = {
              COMPARISON
            };
            VertexSolar_amounts[Impact_PASSIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][0], ADD_values_EFF);
            
            float[][] ADD_values_XYZ = {
              {
                subFace[s][0], subFace[s][1], subFace[s][2]
              }
            };
            VertexSolar_XYZ = (float[][]) concat(VertexSolar_XYZ, ADD_values_XYZ);          
  
          }
          
        }

      }
    }
  }
  
  cursor(ARROW);
}






float[] SOLARCHVISION_snap_Faces (float[] RxP) {
  
  if (RxP[0] >= 0) {
    
    int f = int(RxP[0]);
    float x = RxP[1];
    float y = RxP[2];
    float z = RxP[3];
  
    if (CreateInput_Snap == 1) { // nearest endpoint
    
      float nearest_D = FLOAT_undefined;
      float nearest_X = FLOAT_undefined;
      float nearest_Y = FLOAT_undefined;
      float nearest_Z = FLOAT_undefined;

      int mt = allFaces.getMaterial(f);

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allModel3Ds.Tessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allVertices[vNo][0];
        base_Vertices[j][1] = allVertices[vNo][1];
        base_Vertices[j][2] = allVertices[vNo][2];
      }

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

        WIN3D.graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {
      
          float d = dist(x, y, z, subFace[s][0], subFace[s][1], subFace[s][2]);
          
          if (nearest_D > d) {
            nearest_D = d;
            nearest_X = subFace[s][0];
            nearest_Y = subFace[s][1];
            nearest_Z = subFace[s][2];
          }
        }
      }
      
      if (is_undefined_FLOAT(nearest_D) == false) {
        RxP[1] = nearest_X;
        RxP[2] = nearest_Y;
        RxP[3] = nearest_Z;
      }
    }
  }
  
  return RxP;
}


int SOLARCHVISION_isIntersected_Faces (float[] ray_pnt, float[] ray_dir, int firstGuess) {
  
  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  int hit = 0;

  for (int q = 0; q < allFaces.nodes.length; q++) {
    
    int f = (q + firstGuess) % allFaces.nodes.length;
    
    if (f > 0) {
      
      int n = allFaces.nodes[f].length;
      
      if (n > 2) {      
  
        int vsb = allFaces.getVisibility(f);
    
          if (vsb > 0) {    
  
          float X_intersect = FLOAT_undefined;         
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};
          
          boolean InPoly = false;
          
          if (n < 5) { // works if n==3 or n==4
      
            float[] A = allVertices[allFaces.nodes[f][0]];
            float[] B = allVertices[allFaces.nodes[f][1]];
            float[] C = allVertices[allFaces.nodes[f][n - 2]];
            float[] D = allVertices[allFaces.nodes[f][n - 1]];
            
            float[] AC = SOLARCHVISION_3xSub(A, C);
            float[] BD = SOLARCHVISION_3xSub(B, D);
            
            face_norm = SOLARCHVISION_3xCross(AC, BD);
            
            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
          
            float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
                
                if (n == 4) InPoly = SOLARCHVISION_isInside_Quadrangle(P, A, B, C, D);
                else InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case
  
              }
            }
          }
          else {        
  
            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            }; 
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allVertices[tmpFace[j]][0] / float(n); 
              G[1] += allVertices[tmpFace[j]][1] / float(n);
              G[2] += allVertices[tmpFace[j]][2] / float(n);
            }  
            
            for (int j = 0; j < n; j++) {
      
              int j_next = (j + 1) % n;
      
              float[] A = {
                allVertices[allFaces.nodes[f][j]][0],
                allVertices[allFaces.nodes[f][j]][1],
                allVertices[allFaces.nodes[f][j]][2]
              };            
              
              float[] B = {
                allVertices[allFaces.nodes[f][j_next]][0],
                allVertices[allFaces.nodes[f][j_next]][1],
                allVertices[allFaces.nodes[f][j_next]][2]
              };                
    
              float[] AG = SOLARCHVISION_3xSub(A, G);
              float[] BG = SOLARCHVISION_3xSub(B, G);
              
              face_norm = SOLARCHVISION_3xCross(AG, BG);
                
              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
              
              float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
        
              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
        
                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {
      
                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                  
                  float[] P = {X_intersect, Y_intersect, Z_intersect};
    
                  InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, G); 
                  
                }
              }
              
              if (InPoly) break;
            }
          }
                
          if (InPoly) {
            
            hit = f;
            
            break;         
          }               
  
        }
        
        if (hit != 0) break;
      }
    }
  }

  return hit;
}


float[] SOLARCHVISION_intersect_Faces (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allFaces.nodes.length][7];

  for (int f = 0; f < allFaces.nodes.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
    hitPoint[f][4] = FLOAT_undefined;
    hitPoint[f][5] = FLOAT_undefined;
    hitPoint[f][6] = FLOAT_undefined;
  }
  
  for (int f = 0; f < allFaces.nodes.length; f++) {
    
    int n = allFaces.nodes[f].length;
    
    if (n > 2) {
  
      int vsb = allFaces.getVisibility(f);
  
      if (vsb > 0) {    

        float X_intersect = FLOAT_undefined;         
        float Y_intersect = FLOAT_undefined;
        float Z_intersect = FLOAT_undefined;
        float dist2intersect = FLOAT_undefined;
        float[] face_norm = {0,0,0};
        
        boolean InPoly = false;
        
        if (n < 5) { // works if n==3 or n==4
    
          float[] A = allVertices[allFaces.nodes[f][0]];
          float[] B = allVertices[allFaces.nodes[f][1]];
          float[] C = allVertices[allFaces.nodes[f][n - 2]];
          float[] D = allVertices[allFaces.nodes[f][n - 1]];
          
          float[] AC = SOLARCHVISION_3xSub(A, C);
          float[] BD = SOLARCHVISION_3xSub(B, D);
          
          face_norm = SOLARCHVISION_3xCross(AC, BD);
          
          float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
        
          float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
    
          if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
            dist2intersect = FLOAT_huge;
          }
          else {
            dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
    
            //if (dist2intersect > 0) {
            if (dist2intersect > FLOAT_tiny) {
  
              X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
              Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
              Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
              
              float[] P = {X_intersect, Y_intersect, Z_intersect};
              
              if (n == 4) InPoly = SOLARCHVISION_isInside_Quadrangle(P, A, B, C, D);
              else InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

            }
          }
        }
        else {        

          int[] tmpFace = new int[n];
          float[] G = {
            0, 0, 0
          }; 
          for (int j = 0; j < n; j++) {
            tmpFace[j] = allFaces.nodes[f][j];
            G[0] += allVertices[tmpFace[j]][0] / float(n); 
            G[1] += allVertices[tmpFace[j]][1] / float(n);
            G[2] += allVertices[tmpFace[j]][2] / float(n);
          }  
          
          for (int j = 0; j < n; j++) {
    
            int j_next = (j + 1) % n;
    
            float[] A = {
              allVertices[allFaces.nodes[f][j]][0],
              allVertices[allFaces.nodes[f][j]][1],
              allVertices[allFaces.nodes[f][j]][2]
            };            
            
            float[] B = {
              allVertices[allFaces.nodes[f][j_next]][0],
              allVertices[allFaces.nodes[f][j_next]][1],
              allVertices[allFaces.nodes[f][j_next]][2]
            };                
  
            float[] AG = SOLARCHVISION_3xSub(A, G);
            float[] BG = SOLARCHVISION_3xSub(B, G);
            
            face_norm = SOLARCHVISION_3xCross(AG, BG);
              
            float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
            
            float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
  
                InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, G); 
                
              }
            }
            
            if (InPoly) break;
          }
        }
              
        if (InPoly) {
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
          hitPoint[f][4] = face_norm[0];
          hitPoint[f][5] = face_norm[1];
          hitPoint[f][6] = face_norm[2];             
        }               

      }
    }  
  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
      return_point[5] = hitPoint[f][4];
      return_point[6] = hitPoint[f][5];
      return_point[7] = hitPoint[f][6];

    }

  }

  return return_point;
}


float[] SOLARCHVISION_intersect_selectedFaces (float[] ray_pnt, float[] ray_dir) {
  
  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [selectedFace_ids.length][7];

  for (int o = 0; o < selectedFace_ids.length; o++) {
    hitPoint[o][0] = FLOAT_undefined;
    hitPoint[o][1] = FLOAT_undefined;
    hitPoint[o][2] = FLOAT_undefined;
    hitPoint[o][3] = FLOAT_undefined;
    hitPoint[o][4] = FLOAT_undefined;
    hitPoint[o][5] = FLOAT_undefined;
    hitPoint[o][6] = FLOAT_undefined;
  }
  
  
  for (int o = 0; o < selectedFace_ids.length; o++) {
    
    int f = selectedFace_ids[o];     
    
    if (f > 0) {  

      int n = allFaces.nodes[f].length;
      
      if (n > 2) {
        
        int vsb = allFaces.getVisibility(f);
    
        if (vsb > 0) {    
  
          float X_intersect = FLOAT_undefined;         
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};
          
          boolean InPoly = false;
          
          if (n < 5) { // works if n==3 or n==4
      
            float[] A = allVertices[allFaces.nodes[f][0]];
            float[] B = allVertices[allFaces.nodes[f][1]];
            float[] C = allVertices[allFaces.nodes[f][n - 2]];
            float[] D = allVertices[allFaces.nodes[f][n - 1]];
            
            float[] AC = SOLARCHVISION_3xSub(A, C);
            float[] BD = SOLARCHVISION_3xSub(B, D);
            
            face_norm = SOLARCHVISION_3xCross(AC, BD);
            
            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
          
            float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
                
                if (n == 4) InPoly = SOLARCHVISION_isInside_Quadrangle(P, A, B, C, D);
                else InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case
  
              }
            }
          }
          else {        
  
            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            }; 
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allVertices[tmpFace[j]][0] / float(n); 
              G[1] += allVertices[tmpFace[j]][1] / float(n);
              G[2] += allVertices[tmpFace[j]][2] / float(n);
            }  
            
            for (int j = 0; j < n; j++) {
      
              int j_next = (j + 1) % n;
      
              float[] A = {
                allVertices[allFaces.nodes[f][j]][0],
                allVertices[allFaces.nodes[f][j]][1],
                allVertices[allFaces.nodes[f][j]][2]
              };            
              
              float[] B = {
                allVertices[allFaces.nodes[f][j_next]][0],
                allVertices[allFaces.nodes[f][j_next]][1],
                allVertices[allFaces.nodes[f][j_next]][2]
              };                
    
              float[] AG = SOLARCHVISION_3xSub(A, G);
              float[] BG = SOLARCHVISION_3xSub(B, G);
              
              face_norm = SOLARCHVISION_3xCross(AG, BG);
                
              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
              
              float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
        
              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
        
                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {
      
                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                  
                  float[] P = {X_intersect, Y_intersect, Z_intersect};
    
                  InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, G); 
                  
                }
              }
              
              if (InPoly) break;
            }
          }
                
          if (InPoly) {
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
            hitPoint[f][4] = face_norm[0];
            hitPoint[f][5] = face_norm[1];
            hitPoint[f][6] = face_norm[2];             
          }               
  
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int o = 0; o < selectedFace_ids.length; o++) {
    
    if (pre_dist > hitPoint[o][3]) {

      pre_dist = hitPoint[o][3];

      return_point[0] = o;
      return_point[1] = hitPoint[o][0];
      return_point[2] = hitPoint[o][1];
      return_point[3] = hitPoint[o][2];
      return_point[4] = hitPoint[o][3];
      return_point[5] = hitPoint[o][4];
      return_point[6] = hitPoint[o][5];
      return_point[7] = hitPoint[o][6];

    }

  }

  return return_point;
}





float[] SOLARCHVISION_intersect_Curves (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allCurves.nodes.length][7];

  for (int f = 0; f < allCurves.nodes.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
    hitPoint[f][4] = FLOAT_undefined;
    hitPoint[f][5] = FLOAT_undefined;
    hitPoint[f][6] = FLOAT_undefined;
  }
  
  for (int f = 0; f < allCurves.nodes.length; f++) {
    
    int n = allCurves.nodes[f].length;
    
    if (n > 2) {
  
      int vsb = allCurves.getVisibility(f);
  
      if (vsb > 0) {    

        float X_intersect = FLOAT_undefined;         
        float Y_intersect = FLOAT_undefined;
        float Z_intersect = FLOAT_undefined;
        float dist2intersect = FLOAT_undefined;
        float[] face_norm = {0,0,0};
        
        boolean InPoly = false;
        
        if (n < 5) { // works if n==3 or n==4
    
          float[] A = allVertices[allCurves.nodes[f][0]];
          float[] B = allVertices[allCurves.nodes[f][1]];
          float[] C = allVertices[allCurves.nodes[f][n - 2]];
          float[] D = allVertices[allCurves.nodes[f][n - 1]];
          
          float[] AC = SOLARCHVISION_3xSub(A, C);
          float[] BD = SOLARCHVISION_3xSub(B, D);
          
          face_norm = SOLARCHVISION_3xCross(AC, BD);
          
          float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
        
          float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
    
          if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
            dist2intersect = FLOAT_huge;
          }
          else {
            dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
    
            //if (dist2intersect > 0) {
            if (dist2intersect > FLOAT_tiny) {
  
              X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
              Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
              Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
              
              float[] P = {X_intersect, Y_intersect, Z_intersect};
              
              if (n == 4) InPoly = SOLARCHVISION_isInside_Quadrangle(P, A, B, C, D);
              else InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

            }
          }
        }
        else {        

          int[] tmpCurve = new int[n];
          float[] G = {
            0, 0, 0
          }; 
          for (int j = 0; j < n; j++) {
            tmpCurve[j] = allCurves.nodes[f][j];
            G[0] += allVertices[tmpCurve[j]][0] / float(n); 
            G[1] += allVertices[tmpCurve[j]][1] / float(n);
            G[2] += allVertices[tmpCurve[j]][2] / float(n);
          }  
          
          for (int j = 0; j < n; j++) {
    
            int j_next = (j + 1) % n;
    
            float[] A = {
              allVertices[allCurves.nodes[f][j]][0],
              allVertices[allCurves.nodes[f][j]][1],
              allVertices[allCurves.nodes[f][j]][2]
            };            
            
            float[] B = {
              allVertices[allCurves.nodes[f][j_next]][0],
              allVertices[allCurves.nodes[f][j_next]][1],
              allVertices[allCurves.nodes[f][j_next]][2]
            };                
  
            float[] AG = SOLARCHVISION_3xSub(A, G);
            float[] BG = SOLARCHVISION_3xSub(B, G);
            
            face_norm = SOLARCHVISION_3xCross(AG, BG);
              
            float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
            
            float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
  
                InPoly = SOLARCHVISION_isInside_Triangle(P, A, B, G); 
                
              }
            }
            
            if (InPoly) break;
          }
        }
              
        if (InPoly) {
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
          hitPoint[f][4] = face_norm[0];
          hitPoint[f][5] = face_norm[1];
          hitPoint[f][6] = face_norm[2];             
        }               

      }
    }  
  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < allCurves.nodes.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
      return_point[5] = hitPoint[f][4];
      return_point[6] = hitPoint[f][5];
      return_point[7] = hitPoint[f][6];

    }

  }

  return return_point;
}






























float[] SOLARCHVISION_intersect_LandPoints (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [(Land3D.n_I - 1) * (Land3D.n_J - 1)][4];

  for (int f = 0; f < (Land3D.n_I - 1) * (Land3D.n_J - 1); f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }

  for (int f = 0; f < (Land3D.n_I - 1) * (Land3D.n_J - 1); f++) {

    float X_intersect = FLOAT_undefined;         
    float Y_intersect = FLOAT_undefined;
    float Z_intersect = FLOAT_undefined;
    float dist2intersect = FLOAT_undefined;
    
    boolean InPoly = false;

    int LAND_i = f / (Land3D.n_J - 1);
    int LAND_j = f % (Land3D.n_J - 1);
    
    float[] A = Land3D.Mesh[LAND_i][LAND_j];
    float[] B = Land3D.Mesh[LAND_i][LAND_j + 1];
    float[] C = Land3D.Mesh[LAND_i + 1][LAND_j + 1];
    float[] D = Land3D.Mesh[LAND_i + 1][LAND_j];
    float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]), 0.25 * (A[1] + B[1] + C[1] + D[1]), 0.25 * (A[2] + B[2] + C[2] + D[2])}; 
    
    for (int i = 0; i < 4; i++) {
      
      float[] M = {0,0,0};
      float[] N = {0,0,0};

      if (i == 0) {
        M = A;
        N = B;
      } else if (i == 1) {
        M = B;
        N = C;
      } else if (i == 2) {
        M = C;
        N = D;
      } else if (i == 3) {
        M = D;
        N = A;
      }       
    
      float[] NG = SOLARCHVISION_3xSub(N, G);
      float[] GM = SOLARCHVISION_3xSub(G, M);
      
      float[] face_norm = SOLARCHVISION_3xCross(NG, GM);
      
      float face_offset = ((G[0] + M[0] + N[0]) * face_norm[0] + (G[1] + M[1] + N[1]) * face_norm[1] + (G[2] + M[2] + N[2]) * face_norm[2]) / 3.0;  
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          InPoly = SOLARCHVISION_isInside_Triangle(P, M, N, G); 
          
        }
      }
      
      if (InPoly) break;
    }
    
    if (InPoly) {
      hitPoint[f][0] = X_intersect;
      hitPoint[f][1] = Y_intersect;
      hitPoint[f][2] = Z_intersect;
      hitPoint[f][3] = dist2intersect;
    }   

  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < (Land3D.n_I - 1) * (Land3D.n_J - 1); f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}




float[][] getSubFace (float[][] base_Vertices, int Tessellation, int n) {

  float[][] return_vertices = {
  };

  int TotalSubNo = 1;
  if (Tessellation > 0) TotalSubNo = base_Vertices.length * int(roundTo(pow(4, Tessellation - 1), 1));   

  if ((Tessellation <= 0) || (n < 0) || (n >= TotalSubNo)) {
    return_vertices = new float [base_Vertices.length][3];

    for (int j = 0; j < base_Vertices.length; j++) {
      return_vertices[j] = base_Vertices[j];
    }
  } else {
    return_vertices = new float [4][3];

    int div = base_Vertices.length;

    int the_first = n % div;
    int the_next = (the_first + 1) % div;
    int the_previous = (the_first + div - 1) % div;

    float[] A = {
      0, 0, 0
    };
    float[] B = {
      0, 0, 0
    };
    float[] C = {
      0, 0, 0
    };
    float[] D = {
      0, 0, 0
    };

    for (int i = 0; i < 3; i++) {

      A[i] = base_Vertices[the_first][i];
      B[i] = 0.5 * (A[i] + base_Vertices[the_next][i]);
      D[i] = 0.5 * (A[i] + base_Vertices[the_previous][i]);

      for (int j = 0; j < base_Vertices.length; j++) {
        C[i] += base_Vertices[j][i] / (1.0 * base_Vertices.length);
      }
    }

    if (Tessellation == 1) {
      return_vertices[0] = A; 
      return_vertices[1] = B; 
      return_vertices[2] = C; 
      return_vertices[3] = D;
    } else {

      int section = n / div;
      int res = int(roundTo(pow(2, Tessellation - 1), 1));
      int u = section / res;
      int v = section % res;

      float x1 = (1.0 * u) / (1.0 * res);
      float y1 = (1.0 * v) / (1.0 * res);
      float x2 = (1.0 * (u + 1)) / (1.0 * res);
      float y2 = (1.0 * (v + 1)) / (1.0 * res);

      float[] P0 = {
        0, 0, 0
      };
      float[] P1 = {
        0, 0, 0
      };
      float[] P2 = {
        0, 0, 0
      };
      float[] P3 = {
        0, 0, 0
      };

      for (int i = 0; i < 3; i++) {
        P0[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x1, y1); 
        P1[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x2, y1); 
        P2[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x2, y2); 
        P3[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x1, y2);
      }      

      //return_vertices[0] = P0; 
      //return_vertices[1] = P1; 
      //return_vertices[2] = P2; 
      //return_vertices[3] = P3;

      //to rotate tri-grid cells:

      int d = ((u % 2) + ((v + 1) % 2)) % 2; 
      if (d == 0) {
        return_vertices[0] = P0; 
        return_vertices[1] = P1; 
        return_vertices[2] = P2; 
        return_vertices[3] = P3;
      } else {
        return_vertices[0] = P1; 
        return_vertices[1] = P2; 
        return_vertices[2] = P3; 
        return_vertices[3] = P0;
      }
    }
  }


  return return_vertices;
}






// ---------------------------------------------------------





double[] getLandGrid (int i, int j) {

  double stp_lat = 1.0 / 2224.5968; // equals to 50m 

  double stp_lon = stp_lat / cos_ang(STATION.getLatitude());   
  
  //float q = 2;
  float q = pow(2, 0.5);
  //float q = 1.25;
  //float q = 1.125;  
  
  float t = j * 360.0 / (Land3D.n_J - 1);
  
  float r = 0;
  if (i > 0) r = pow(q, i - 1);

  double _lon = STATION.getLongitude() + stp_lon * r * cos_ang(t);
  double _lat = STATION.getLatitude() + stp_lat * r * sin_ang(t);
  
  double[] LON_LAT = {_lon, _lat};
  
  return LON_LAT;
  
}

float[] convert_lonlat2XY (double _lon, double _lat) {

  double du = ((_lon - STATION.getLongitude()) / 180.0) * (PI * DOUBLE_r_Earth);
  double dv = ((_lat - STATION.getLatitude()) / 180.0) * (PI * DOUBLE_r_Earth);

  float x = (float) du * cos_ang((float) _lat);
  float y = (float) dv;   
  
  float[] XY = {x, y};
  
  return XY;
}



























void SOLARCHVISION_resize_SolarImpact_Image_array () {

  SolarImpact_Image = new PImage [2][(1 + STUDY.j_End - STUDY.j_Start)];

  for (int i = 0; i < SolarImpact_Image.length; i++) {
    for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) { // total image at j = -1 
  
      SolarImpact_Image[i][j + 1] = createImage(2, 2, RGB); // empty and small
    }  
  }

  rebuild_SolarImpactImage_array = 0;
}

void SOLARCHVISION_resize_WindRose_Image_array () {

  WindRose_Image = new PImage [(1 + STUDY.j_End - STUDY.j_Start)];

  for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 

    WindRose_Image[j + 1] = createImage(2, 2, RGB); // empty and small
  }  

  rebuild_WindRoseImage_array = 0;
}

int IMPACTS_DisplayDay = 0; // 0:total 1:day-1 2:day-2 etc.

PImage[] WindRose_Image;

boolean Display_WindRoseImage = false; 

int Rendered_WindRose_RES = 1;
int WindRose_RES = 400;

PImage[][] SolarImpact_Image;

boolean Display_SolarImpactImage = false;
int SolarImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float SolarImpact_Rotation = 0; // North is up by default

float SolarImpact_scale_U = 500; // i.e. 500 = 500m 
float SolarImpact_scale_V = 500; // i.e. 500 = 500m 

float SolarImpact_offset_U = 0;
float SolarImpact_offset_V = 0; 

int SolarImpact_RES1 = 100; //200;
int SolarImpact_RES2 = 100; //200;

float SolarImpact_Elevation;


void SOLARCHVISION_calculate_SolarImpact_CurrentPreBaked () {

  if (rebuild_SolarImpactImage_array != 0) {
    SOLARCHVISION_resize_SolarImpact_Image_array();
  }
  
  println("AAA");

  if (SolarImpact_sectionType != 0) {

    println("BBB");
    
    cursor(WAIT);

    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;


    int RES1 = SolarImpact_RES1;
    int RES2 = SolarImpact_RES2;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;

    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    for (int p = 0; p < 1; p++) { 
      int l = STUDY.ImpactLayer;

      PImage[] total_Image_RGBA = new PImage[2];
      for (int q = 0; q < numberOfImpactVariations; q++) {
        total_Image_RGBA[q] = createImage(RES1, RES2, RGB);
      }

      float[][][][] total_Matrix_ARGB;
      total_Matrix_ARGB = new float [2][4][RES1][RES2];

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;
        
        for (int q = 0; q < numberOfImpactVariations; q++) {
          total_Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
          total_Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
          total_Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
          total_Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
        }
      }

      for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

        now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        int DATE_ANGLE_approximate = int((DATE_ANGLE + 15) / 30) * 30;
        if (DATE_ANGLE_approximate == 360) DATE_ANGLE_approximate = 0;

        float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

        //println(DATE_ANGLE, DATE_ANGLE_approximate);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        //println("j =", j);
        //println(Normals_COL_N);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / STUDY.JoinDays);
            int j_ADD = nk % STUDY.JoinDays; 

            float[][][][] Matrix_ARGB;

            Matrix_ARGB = new float [2][4][RES1][RES2];

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
              
              for (int q = 0; q < numberOfImpactVariations; q++) {
                Matrix_ARGB[q][0][Image_X][Image_Y] = FLOAT_undefined;
                Matrix_ARGB[q][1][Image_X][Image_Y] = FLOAT_undefined;
                Matrix_ARGB[q][2][Image_X][Image_Y] = FLOAT_undefined;
                Matrix_ARGB[q][3][Image_X][Image_Y] = FLOAT_undefined;
              }
            }

            PImage[] Image_RGBA = new PImage[2];
            for (int q = 0; q < numberOfImpactVariations; q++) {
              Image_RGBA[q] = createImage(RES1, RES2, RGB);
            }
            
            int _valuesNUM = 0;  

            for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not available out of this period. 
              if (STUDY.isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
        
                  if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                    
                    if (memberCount == 1) {
                      _values_R_dir = 0.001 * Pa;  
                      _values_R_dif = 0.001 * Pb; 
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      for (int RAD_TYPE = 0; RAD_TYPE <= 1; RAD_TYPE++) { 
                        float RAD_VALUE = 0;
                        float EFF_VALUE = 0;
                        if (RAD_TYPE == 0) {
                          RAD_VALUE = _values_R_dir; 
                          EFF_VALUE = _values_E_dir;
                        } else { 
                          //float MULT_dif = 2.0;
                          float MULT_dif = FLOAT_e; // 2.718

                          RAD_VALUE = _values_R_dif * MULT_dif;
                          EFF_VALUE = _values_E_dif * MULT_dif;
                        }

                        PImage[] Shadings = new PImage [2];
                        for (int SHD = 0; SHD <= 1; SHD++) {
                          String[] STR_SHD = {
                            "F", "T"
                          };
                          String File_Name = ShadingFolder + "/" + NearLatitude_Stamp() + "/" + SceneName;

                          if (RAD_TYPE == 0) {
                            File_Name += nf(DATE_ANGLE_approximate, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
                          } else {
                            File_Name += "DIF_" + STR_SHD[SHD];
                          }

                          File_Name += "_Camera" + nf(Camera_Variation, 2) + ".PNG";


                          println(File_Name);
                          Shadings[SHD]  = loadImage(File_Name);
                        }   

                        for (int np = 0; np < (RES1 * RES2); np++) {
                          int Image_X = np % RES1;
                          int Image_Y = np / RES1;

                          for (int q = 0; q < numberOfImpactVariations; q++) {
                            if (is_undefined_FLOAT(Matrix_ARGB[q][0][Image_X][Image_Y])) {
                            
                              Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
                              Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
                              Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
                              Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
                            }
                          }                             

                          color COL0 = Shadings[0].get(Image_X, Image_Y);
                          color COL1 = Shadings[1].get(Image_X, Image_Y);
                          //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                          float COL_V0 = (COL0 >> 8 & 0xFF) / 255.0; 
                          float COL_V1 = (COL1 >> 8 & 0xFF) / 255.0;

                          float COL_Alpha = (COL1 >> 24 & 0xFF);

                          Matrix_ARGB[Impact_ACTIVE][0][Image_X][Image_Y] = COL_Alpha;
                          Matrix_ARGB[Impact_PASSIVE][0][Image_X][Image_Y] = COL_Alpha;

                          Matrix_ARGB[Impact_ACTIVE][2][Image_X][Image_Y] += RAD_VALUE * COL_V1;

                          if (EFF_VALUE < 0) {
                            Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] -= EFF_VALUE * COL_V1;
                            if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] -= EFF_VALUE * (COL_V0 - COL_V1);
                          } else {
                            Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] += EFF_VALUE * COL_V1;
                            if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] += EFF_VALUE * (COL_V0 - COL_V1);
                          }

                          if (np == 0) _valuesNUM += 1;
                        }
                      }
                    }
                  }
                }
              }
            }

            float _valuesMUL = 0;

            if (_valuesNUM != 0) {
              //_valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * _valuesNUM);  
              //_valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * _valuesNUM);
              _valuesMUL = roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * _valuesNUM);
            }


            for (int q = 0; q < numberOfImpactVariations; q++) {
              Image_RGBA[q].loadPixels();
            }

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
              
              for (int q = 0; q < numberOfImpactVariations; q++) {

                float Image_A = Matrix_ARGB[q][0][Image_X][Image_Y] * _valuesMUL;
                float Image_R = Matrix_ARGB[q][1][Image_X][Image_Y] * _valuesMUL;
                float Image_G = Matrix_ARGB[q][2][Image_X][Image_Y] * _valuesMUL;
                float Image_B = Matrix_ARGB[q][3][Image_X][Image_Y] * _valuesMUL;
  
                total_Matrix_ARGB[q][0][Image_X][Image_Y] += Image_A;
                total_Matrix_ARGB[q][1][Image_X][Image_Y] += Image_R;
                total_Matrix_ARGB[q][2][Image_X][Image_Y] += Image_G;
                total_Matrix_ARGB[q][3][Image_X][Image_Y] += Image_B; 
              
                float[] _c = {
                  0, 0, 0, 0
                };
  
                float _u = 0;
  
                float _valuesSUM = FLOAT_undefined;
  
                int PAL_TYPE = 0; 
                int PAL_DIR = 1;
                float PAL_Multiplier = 1; 
  
                if (q == Impact_ACTIVE) {
                  _valuesSUM = Image_G;
  
                  PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
                  PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
                  PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
  
                  //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
                  //_u = (0.1 * PAL_Multiplier * _valuesSUM);
                  _u = (0.2 * PAL_Multiplier * _valuesSUM);
                }
  
                if (q == Impact_PASSIVE) {
                  float AVERAGE, PERCENTAGE, COMPARISON;
  
                  AVERAGE = (Image_B - Image_R);
                  if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
                  else PERCENTAGE = 0.0;
                  COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
                  _valuesSUM = COMPARISON;
  
                  PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
                  PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
                  PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
  
                  //_u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
                  _u = 0.5 + 0.5 * (0.2 * PAL_Multiplier * _valuesSUM);
                }
  
  
                //if ((Image_X == RES1 / 2) && (Image_Y == RES2 / 2)) println("Image Processing: <CENTER> _valuesSUM =", _valuesSUM); 
                //if ((Image_X == RES1 - 1) && (Image_Y == RES2 - 1)) println("Image Processing: <CORNER> _valuesSUM =", _valuesSUM); 
  
                if (PAL_DIR == -1) _u = 1 - _u;
                if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_DIR == 2) _u =  0.5 * _u;
  
                _c = PAINT.getColorStyle(PAL_TYPE, _u);
  
                if (Image_A != 0) Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
                else Image_RGBA[q].pixels[np] = color(223, 223, 223);
              }
            }
            
            for (int q = 0; q < numberOfImpactVariations; q++) {
              Image_RGBA[q].updatePixels();

  
              //if (Camera_Variation == 0) {
              SolarImpact_Image[q][j + 1] = Image_RGBA[q];           
              if (SolarImpact_record_JPG == 1) {
                String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(j + 1, 0) + ".jpg";
                SolarImpact_Image[q][j + 1].save(myFile);
                if (j == 0) SOLARCHVISION_explore_output(myFile);
                println("File created:" + myFile);
              }
              //}
            }
          }
        }
      }

      { 
        int j = -1; // << to put the summary graph before the daily graphs
        
        for (int q = 0; q < numberOfImpactVariations; q++) {
          total_Image_RGBA[q].loadPixels();
        }

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          for (int q = 0; q < numberOfImpactVariations; q++) {
            
            float Image_A = total_Matrix_ARGB[q][0][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
            float Image_R = total_Matrix_ARGB[q][1][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
            float Image_G = total_Matrix_ARGB[q][2][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
            float Image_B = total_Matrix_ARGB[q][3][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));

            float[] _c = {
              0, 0, 0, 0
            };
  
            float _u = 0;
  
            float _valuesSUM = FLOAT_undefined;

            int PAL_TYPE = 0; 
            int PAL_DIR = 1;
            float PAL_Multiplier = 1; 
  
            if (q == Impact_ACTIVE) {
              _valuesSUM = Image_G;
  
              PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
              PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
              PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
  
              //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
              //_u = (0.1 * PAL_Multiplier * _valuesSUM);
              _u = (0.2 * PAL_Multiplier * _valuesSUM);
            }
  
            if (q == Impact_PASSIVE) {
              float AVERAGE, PERCENTAGE, COMPARISON;
  
              AVERAGE = (Image_B - Image_R);
              if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
              else PERCENTAGE = 0.0;
              COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
   
              _valuesSUM = COMPARISON;
  
              PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
              PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
              PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
  
              //_u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
              _u = 0.5 + 0.5 * (0.2 * PAL_Multiplier * _valuesSUM);
            }
  
            if (PAL_DIR == -1) _u = 1 - _u;
            if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_DIR == 2) _u =  0.5 * _u;
  
            _c = PAINT.getColorStyle(PAL_TYPE, _u);
  
            if (Image_A != 0) total_Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
            else total_Image_RGBA[q].pixels[np] = color(223, 223, 223);
          }
        }
        
        for (int q = 0; q < numberOfImpactVariations; q++) {
  
          total_Image_RGBA[q].updatePixels(); 
  
          //if (Camera_Variation == 0) {
          SolarImpact_Image[q][0] = total_Image_RGBA[q];           
          if (SolarImpact_record_JPG == 1) {
            String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(0, 0) + ".jpg";
            SolarImpact_Image[q][0].save(myFile);
            //SOLARCHVISION_explore_output(myFile);
            println("File created:" + myFile);
          }
          //}
        }
      }
    }

    cursor(ARROW);
  }
}



void SOLARCHVISION_render_Shadows_selectedallSections () {

  for (int o = selectedSection_ids.length - 1; o >= 0; o--) {

    int f = selectedSection_ids[o];

    SolarImpact_sectionType = allSections.Type[f];
    SolarImpact_RES1 = allSections.RES1[f];
    SolarImpact_RES2 = allSections.RES2[f];     

    SolarImpact_offset_U = allSections.UVERAB[f][0];
    SolarImpact_offset_V = allSections.UVERAB[f][1];
    SolarImpact_Elevation = 0.1 + allSections.UVERAB[f][2];
    SolarImpact_Rotation = allSections.UVERAB[f][3];
    SolarImpact_scale_U = allSections.UVERAB[f][4];
    SolarImpact_scale_V = allSections.UVERAB[f][5];

    SceneName = "Section_" + Section_Stamp();

    SOLARCHVISION_render_Shadows_CurrentSection();
  }

  Display_SolarImpactImage = true;
  Display_SolidImpactImage = false;
  ROLLOUT.update = true;
}




void SOLARCHVISION_calculate_SolarImpact_selectedallSections () {

  for (int o = selectedSection_ids.length - 1; o >= 0; o--) {

    int f = selectedSection_ids[o];

    SolarImpact_sectionType = allSections.Type[f];
    SolarImpact_RES1 = allSections.RES1[f];
    SolarImpact_RES2 = allSections.RES2[f];     

    SolarImpact_offset_U = allSections.UVERAB[f][0];
    SolarImpact_offset_V = allSections.UVERAB[f][1];
    SolarImpact_Elevation = 0.1 + allSections.UVERAB[f][2];
    SolarImpact_Rotation = allSections.UVERAB[f][3];
    SolarImpact_scale_U = allSections.UVERAB[f][4];
    SolarImpact_scale_V = allSections.UVERAB[f][5];

    SceneName = "Section_" + Section_Stamp();

    SOLARCHVISION_calculate_SolarImpact_CurrentPreBaked();
    
    
    for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) {
      for (int q = 0; q < numberOfImpactVariations; q++) {
        allSections.SolarImpact[f][j + 1][q] = createImage(SolarImpact_RES1, SolarImpact_RES2, RGB);

        allSections.SolarImpact[f][j + 1][q].copy(SolarImpact_Image[q][j + 1], 0, 0, SolarImpact_RES1, SolarImpact_RES2, 0, 0, SolarImpact_RES1, SolarImpact_RES2);
      }
    }
  }
}




void SOLARCHVISION_calculate_SolidImpact_selectedallSections () {

  println("SOLARCHVISION_calculate_SolidImpact_selectedallSections");

  for (int o = selectedSection_ids.length - 1; o >= 0; o--) {

    int f = selectedSection_ids[o];

    SolidImpact_sectionType = allSections.Type[f];
    SolidImpact_RES1 = allSections.RES1[f];
    SolidImpact_RES2 = allSections.RES2[f];     

    SolidImpact_offset_U[SolidImpact_sectionType] = allSections.UVERAB[f][0];
    SolidImpact_offset_V[SolidImpact_sectionType] = allSections.UVERAB[f][1];
    SolidImpact_Elevation[SolidImpact_sectionType] = allSections.UVERAB[f][2];
    SolidImpact_Rotation[SolidImpact_sectionType] = allSections.UVERAB[f][3];
    SolidImpact_scale_U[SolidImpact_sectionType] = allSections.UVERAB[f][4];
    SolidImpact_scale_V[SolidImpact_sectionType] = allSections.UVERAB[f][5];

    {
      if ((SolidImpact_Image.width != SolidImpact_RES1) || (SolidImpact_Image.height != SolidImpact_RES2)) {
        SolidImpact_Image = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);

        allSections.SolidImpact[f] = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);
      }

      SOLARCHVISION_calculate_SolidImpact_CurrentSection();

      allSections.SolidImpact[f].copy(SolidImpact_Image, 0, 0, SolidImpact_RES1, SolidImpact_RES2, 0, 0, SolidImpact_RES1, SolidImpact_RES2);
    }
  }

}






float[] SolidImpact_scale_U = {
  100, 100, 100, 100
}; // i.e. 100m
float[] SolidImpact_scale_V = {
  100, 100, 100, 100
}; // i.e. 100m

float[] SolidImpact_offset_U = {
  0, 0, 0, 0
}; 
float[] SolidImpact_offset_V = {
  0, 0, 0, 0
}; 

int SolidImpact_RES1 = 200; //400;
int SolidImpact_RES2 = 200; //400;

PImage SolidImpact_Image = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);



boolean Display_SolidImpactImage = true;
int SolidImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float[] SolidImpact_Elevation = {
  0, 0.1, 0, 0
}; // <<<
float[] SolidImpact_Rotation = {
  0, 0, 0, 0
};

float SolidImpact_positionStep = 1.25;


int SolidImpactType = 0; // INTERNAL! 0:simple 1:complex

float SOLARCHVISION_get_SolidImpact_atXYZ (float x, float y, float z) {

  float v = 0;

  if (SolidImpactType == 0) {
    v = SOLARCHVISION_calculate_SolidImpact_atXYZ_simple(x, y, z);
  } else {
    v = SOLARCHVISION_calculate_SolidImpact_atXYZ_complex(x, y, z);
  }

  return v;
}



float SOLARCHVISION_calculate_SolidImpact_atXYZ_simple (float x, float y, float z) {

  float val = 1;

  for (int n = 0; n < allSolids.DEF.length; n++) {

    float r = allSolids.get_value(n);
    float d = allSolids.get_Distance(n, x, y, z);

    //d *= pow(d, SolidImpact_Power);
    d *= pow(d, SolidImpact_Power / float(allSolids.DEF.length));    

    if (val < 0) val *= abs(d - r);
    else {
      val *= d - r;
    }
  }

  if (allSolids.DEF.length > 0) {
    float val_sign = 1;
    if (val < 0) {
      val_sign = -1;
      val = abs(val);
    } 
    val = pow(val, 1.0 / float(allSolids.DEF.length));
    val *= val_sign;
  } 

  return val;
}



float SOLARCHVISION_calculate_SolidImpact_atXYZ_complex (float x, float y, float z) {

  float deltaX = SolidImpact_WindSpeed * cos_ang(SolidImpact_WindDirection);
  float deltaY = SolidImpact_WindSpeed * sin_ang(SolidImpact_WindDirection);

  float[] val = {
    1, 1
  };

  for (int o = 0; o < 2; o++) {

    for (int n = 0; n < allSolids.DEF.length; n++) {

      float r = allSolids.get_value(n);
      float d = allSolids.get_Distance(n, x + o * deltaX, y + o * deltaY, z);

      //d *= pow(d, SolidImpact_Power);
      d *= pow(d, SolidImpact_Power / float(allSolids.DEF.length));

      if (val[o] < 0) val[o] *= abs(d - r);
      else {
        val[o] *= d - r;
      }
    }

    if (allSolids.DEF.length > 0) {
      float val_sign = 1;
      if (val[o] < 0) {
        val_sign = -1;
        val[o] = abs(val[o]);
      } 
      val[o] = pow(val[o], 1.0 / float(allSolids.DEF.length));
      val[o] *= val_sign;
    }
  }

  return val[1] - val[0];
}




float[][] WindFlow_Vertices = new float [0][4]; // keeping values at the 4th member
int[][] WindFlow_Lines = new int [0][2];

void SOLARCHVISION_calculate_WindFlow () {

  cursor(WAIT);  

  WindFlow_Vertices = new float [0][4];

  WindFlow_Lines = new int [0][2];




  float deltaX = -SolidImpact_WindSpeed * cos_ang(SolidImpact_WindDirection);
  float deltaY = -SolidImpact_WindSpeed * sin_ang(SolidImpact_WindDirection);
  float deltaZ = 0;   

  /* 
   
   float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
   float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
   float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
   float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
   float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
   float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];
   
   int Section_Type = SolidImpact_sectionType;
   int Section_RES1 = SolidImpact_RES1;
   int Section_RES2 = SolidImpact_RES2; 
   
   float[][] ImageVertex = allSections.getCorners(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2); 
   
   float[] SectionCorner_A = ImageVertex[1];
   float[] SectionCorner_B = ImageVertex[2];
   float[] SectionCorner_C = ImageVertex[3];
   float[] SectionCorner_D = ImageVertex[4]; 
   
   for (int i = 0; i < SolidImpact_RES1; i += 10) {
   for (int j = 0; j < SolidImpact_RES2; j += 10) {
   
   float x = SOLARCHVISION_Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   float y = SOLARCHVISION_Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   float z = SOLARCHVISION_Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   
   */


  for (float z = 2.5; z <= 30; z += 5.0) {
    for (float y = -80; y <= 80; y += 5.0) {
      for (float x = -80; x <= 80; x += 5.0) {



        float[] test_point = {
          x, y, z
        };


        int num_steps = 1; //1; //4;

        for (int n = 0; n < num_steps; n++) {

          SolidImpactType = 0;
          float inside_or_outside = SOLARCHVISION_get_SolidImpact_atXYZ(test_point[0], test_point[1], test_point[2]);

          if (inside_or_outside > 0) {

            SolidImpactType = 1;
            float val = SOLARCHVISION_get_SolidImpact_atXYZ(test_point[0], test_point[1], test_point[2]);


            float MinimumDistance_trace = 1 / float(num_steps);

            //-----------------------------------------------------------------------------------------------------------------------------------------
            float[][] tracedPoints = SOLARCHVISION_3DtraceContour(MinimumDistance_trace, test_point[0], test_point[1], test_point[2], val);
            //-----------------------------------------------------------------------------------------------------------------------------------------

            float[] point_min = tracedPoints[0];
            //float[] point_equ = tracedPoints[1];
            //float[] point_max = tracedPoints[2];

            float[] v1 = {
              deltaX, deltaY, deltaZ
            };

            float[] v2 = {
              point_min[0] - x, point_min[1] - y, point_min[2] - z
            };

            float acceleration = -SolidImpact_WindSpeed * (point_min[3] - val);

            float dx = v1[0] + v2[0] * acceleration;
            float dy = v1[1] + v2[1] * acceleration;
            float dz = v1[2] + v2[2] * acceleration;

            //float scale = 1.0 / float(num_steps);
            float scale = 0.1 / float(num_steps); // <<<<<<<<<<<<<<<<<<<<

            float x1 = test_point[0] - 0.5 * dx * scale;
            float y1 = test_point[1] - 0.5 * dy * scale;
            float z1 = test_point[2] - 0.5 * dz * scale;

            float x2 = test_point[0] + 0.5 * dx * scale;
            float y2 = test_point[1] + 0.5 * dy * scale;
            float z2 = test_point[2] + 0.5 * dz * scale;


            float AB = (dist(x1, y1, z1, x2, y2, z2) / scale - SolidImpact_WindSpeed) / SolidImpact_WindSpeed; 

            int point_prev = 0;
            int point_next = 0;

            {
              float[][] newVertex = {
                {
                  x1, y1, z1, AB
                }
              };
              WindFlow_Vertices = (float[][]) concat(WindFlow_Vertices, newVertex);

              point_prev = WindFlow_Vertices.length - 1;
            }      


            {
              float[][] newVertex = {
                {
                  x2, y2, z2, AB
                }
              };
              WindFlow_Vertices = (float[][]) concat(WindFlow_Vertices, newVertex);

              point_next = WindFlow_Vertices.length - 1;
            }      

            if ((point_prev != 0) && (point_next != 0)) {
              int[][] newU1Line = {
                {
                  point_prev, point_next
                }
              };
              WindFlow_Lines = (int[][]) concat(WindFlow_Lines, newU1Line);

              point_prev = point_next;
            }      


            test_point[0] = x2;       
            test_point[1] = y2;
            test_point[2] = z2;
          }
        }
      }
    }
  }  

  cursor(ARROW);  

  Display_WindFlow = true;                
  ROLLOUT.update = true;
}










float SOLARCHVISION_fn_2Ddot (float x1, float y1, float x2, float y2) {
  return x1 * x2 + y1 * y2;
}

float[] SOLARCHVISION_2DtraceContour (int traceType, float epsilon, float x, float y, float z, float dx, float dy, float dz, float v) {

  float t_max = FLOAT_undefined;
  float t_min = FLOAT_undefined;
  float t_equ = 0; //FLOAT_undefined;  

  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;

  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = x + dx; //FLOAT_undefined;

  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = y + dy; //FLOAT_undefined;

  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = z + dz; //FLOAT_undefined;

  float min_dist = FLOAT_undefined;  

  float r = epsilon;

  float t = atan2_ang(dy, dx);

  //for (int test_t = -180; test_t < 180; test_t += 5) { 
  for (int test_t = -150; test_t <= 150; test_t += 5) { // <<<<

    float a = r * cos_ang(t + test_t);
    float b = r * sin_ang(t + test_t);
    float c = 0;

    if (SolidImpact_sectionType == 1) {
      float Qx = a * cos_ang(-SolidImpact_Rotation[SolidImpact_sectionType]) - b * sin_ang(-SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(-SolidImpact_Rotation[SolidImpact_sectionType]) + b * cos_ang(-SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = c;

      a = Qx; 
      b = Qy; 
      c = Qz;
    } else if (SolidImpact_sectionType == 2) {
      float Qx = a * cos_ang(SolidImpact_Rotation[SolidImpact_sectionType]) - c * sin_ang(SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(SolidImpact_Rotation[SolidImpact_sectionType]) + c * cos_ang(SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = -b; 

      a = Qx; 
      b = Qy; 
      c = Qz;
    } else if (SolidImpact_sectionType == 3) {
      float Qx = a * cos_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]) - c * sin_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]) + c * cos_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = -b; 

      a = Qx; 
      b = Qy; 
      c = Qz;
    }

    float test_x = x + a;
    float test_y = y + b;
    float test_z = z + c;

    float test_v = SOLARCHVISION_get_SolidImpact_atXYZ(test_x, test_y, test_z);        

    if ((test_v < v_min) || (is_undefined_FLOAT(v_min))) {
      v_min = test_v;
      t_min = test_t;
      x_min = test_x;
      y_min = test_y;
      z_min = test_z;
    }
    if ((test_v > v_max) || (is_undefined_FLOAT(v_max))) {
      v_max = test_v;
      t_max = test_t;
      x_max = test_x;
      y_max = test_y;          
      z_max = test_z;
    }

    //if (((abs(test_v - v) < min_dist) && (SOLARCHVISION_fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0)) || (is_undefined_FLOAT(v_equ)))  {
    if ((abs(test_v - v) < min_dist) || (is_undefined_FLOAT(v_equ))) {
      //if (SOLARCHVISION_fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0) {

      min_dist = abs(test_v - v);

      v_equ = test_v;
      t_equ = test_t;
      x_equ = test_x;
      y_equ = test_y;          
      z_equ = test_z;
      //}
    }
  }     


  float the_X = 0, the_Y = 0, the_Z = 0, the_T = 0;

  if (traceType == 0) {
    the_X = x_equ;
    the_Y = y_equ;
    the_Z = z_equ;
    the_T = t_equ;
  }
  if (traceType == -1) {
    the_X = x_min;
    the_Y = y_min;
    the_Z = z_min;
    the_T = t_min;
  }
  if (traceType == 1) {
    the_X = x_max;
    the_Y = y_max;
    the_Z = z_max;
    the_T = t_max;
  }

  float[] return_array = {
    the_X, the_Y, the_Z, cos_ang(t + the_T), sin_ang(t + the_T), 0
  };

  return return_array;
}


float[][] SOLARCHVISION_3DtraceContour (float epsilon, float x, float y, float z, float v) {

  float tz_max = FLOAT_undefined;
  float tz_min = FLOAT_undefined;
  float tz_equ = FLOAT_undefined;  

  float txy_max = FLOAT_undefined;
  float txy_min = FLOAT_undefined;
  float txy_equ = FLOAT_undefined;  

  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;

  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = FLOAT_undefined;

  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = FLOAT_undefined;

  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = FLOAT_undefined;

  float min_dist = FLOAT_undefined;  

  float r = epsilon;

  for (int test_tz = -90; test_tz <= 90; test_tz += 30) { // in the space 
    //for (int test_tz = 0; test_tz <= 0; test_tz += 30) { // on the surface! 

    float c = r * sin_ang(test_tz);

    for (int test_txy = -180; test_txy < 180; test_txy += 15) { 

      float a = r * cos_ang(test_tz) * cos_ang(test_txy);
      float b = r * cos_ang(test_tz) * sin_ang(test_txy);


      float test_x = x + a;
      float test_y = y + b;
      float test_z = z + c;

      float test_v = SOLARCHVISION_get_SolidImpact_atXYZ(test_x, test_y, test_z);        

      if ((test_v < v_min) || (is_undefined_FLOAT(v_min))) {
        v_min = test_v;
        tz_min = test_tz;
        txy_min = test_txy;
        x_min = test_x;
        y_min = test_y;
        z_min = test_z;
      }
      if ((test_v > v_max) || (is_undefined_FLOAT(v_max))) {
        v_max = test_v;
        tz_max = test_tz;
        txy_max = test_txy;
        x_max = test_x;
        y_max = test_y;          
        z_max = test_z;
      }

      if ((abs(test_v - v) < min_dist) || (is_undefined_FLOAT(v_equ))) {

        min_dist = abs(test_v - v);

        v_equ = test_v;
        tz_equ = test_tz;
        txy_equ = test_txy;
        x_equ = test_x;
        y_equ = test_y;          
        z_equ = test_z;
      }
    }
  }

  float[][] return_array = {
    {
      x_min, y_min, z_min, v_min
    }
    , {
      x_equ, y_equ, z_equ, v_equ
    }
    , {
      x_max, y_max, z_max, v_max
    }
  };

  return return_array;
}





float[][] SolidImpact_Contours_U1Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
float[][] SolidImpact_Contours_V1Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
float[][] SolidImpact_Contours_V2Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
int[][] SolidImpact_Contours_U1Lines = {
  {
    0, 0
  }
};
int[][] SolidImpact_Contours_V1Lines = {
  {
    0, 0
  }
};
int[][] SolidImpact_Contours_V2Lines = {
  {
    0, 0
  }
};

int Process_subDivisions = 1; //1; // 0,1,2,3

float deltaSolidImpactStep = 0.05;
float deltaSolidImpactLines = 0.1 * deltaSolidImpactStep;


void SOLARCHVISION_calculate_SolidImpact_CurrentSection () {

  if (SolidImpact_sectionType != 0) {

    cursor(WAIT);

    SolidImpact_Contours_U1Vertices = new float [1][4];
    SolidImpact_Contours_U1Vertices[0][0] = 0; 
    SolidImpact_Contours_U1Vertices[0][1] = 0; 
    SolidImpact_Contours_U1Vertices[0][2] = 0; 
    SolidImpact_Contours_U1Vertices[0][3] = 0;   

    SolidImpact_Contours_V1Vertices = new float [1][4];
    SolidImpact_Contours_V1Vertices[0][0] = 0; 
    SolidImpact_Contours_V1Vertices[0][1] = 0; 
    SolidImpact_Contours_V1Vertices[0][2] = 0; 
    SolidImpact_Contours_V1Vertices[0][3] = 0;

    SolidImpact_Contours_V2Vertices = new float [1][4];
    SolidImpact_Contours_V2Vertices[0][0] = 0; 
    SolidImpact_Contours_V2Vertices[0][1] = 0; 
    SolidImpact_Contours_V2Vertices[0][2] = 0; 
    SolidImpact_Contours_V2Vertices[0][3] = 0;

    SolidImpact_Contours_U1Lines = new int [1][2];
    SolidImpact_Contours_U1Lines[0][0] = 0;
    SolidImpact_Contours_U1Lines[0][1] = 0;

    SolidImpact_Contours_V1Lines = new int [1][2];
    SolidImpact_Contours_V1Lines[0][0] = 0;
    SolidImpact_Contours_V1Lines[0][1] = 0;

    SolidImpact_Contours_V2Lines = new int [1][2];
    SolidImpact_Contours_V2Lines[0][0] = 0;
    SolidImpact_Contours_V2Lines[0][1] = 0;  


    int PAL_TYPE = SOLID_Pallet_CLR; 
    int PAL_DIR = SOLID_Pallet_DIR;
    float PAL_Multiplier = SOLID_Pallet_MLT;     

    SolidImpact_Image.loadPixels();

    float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
    float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
    float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
    float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
    float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
    float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];

    int Section_Type = SolidImpact_sectionType;
    int Section_RES1 = SolidImpact_RES1;
    int Section_RES2 = SolidImpact_RES2; 

    float[][] ImageVertex = allSections.getCorners(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

    float[] SectionCorner_A = ImageVertex[1];
    float[] SectionCorner_B = ImageVertex[2];
    float[] SectionCorner_C = ImageVertex[3];
    float[] SectionCorner_D = ImageVertex[4]; 

    for (int i = 0; i < SolidImpact_RES1; i++) {
      for (int j = 0; j < SolidImpact_RES2; j++) {

        float x = SOLARCHVISION_Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
        float y = SOLARCHVISION_Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
        float z = SOLARCHVISION_Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));

        SolidImpactType = 0;
        float val = SOLARCHVISION_get_SolidImpact_atXYZ(x, y, z);     

        float g =      roundTo(SolidImpact_Grade * val, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
        float g_line = roundTo(SolidImpact_Grade * val, deltaSolidImpactLines);

        float _u = PAL_Multiplier * val + 0.5;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_TYPE, _u);     

        if ((Process_subDivisions == 1) || (Process_subDivisions == 2)) {
          //if ((g == g_line) && (g != 0)) {
          if ((abs(g - g_line) < 0.001) && (g != 0)) {      
            COL[0] = 0;    
            COL[1] = 0;//255;
            COL[2] = 0;//255;
            COL[3] = 0;//255;
          }
        } 

        if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {

          if ((abs(g - g_line) < 0.0001) && (g != 0) && (g_line <= 1)) {
            //if ((g_line > 1 - deltaSolidImpactLines) && (g_line <= 1)) { // not sure!

            float dx = 1;
            float dy = 0;
            float dz = 0;             

            float[] test_point_dir = {
              x, y, z, dx, dy, dz
            };

            SOLARCHVISION_trace_U1Line(test_point_dir, g_line, 100);
          }
        }

        SolidImpact_Image.pixels[i + j * SolidImpact_RES1] = color(COL[1], COL[2], COL[3], COL[0]);
      }
    }

    SolidImpact_Image.updatePixels();

    if (SolidImpact_record_JPG == 1) {
      String myFile = getFilename_SolidImpact() + ".jpg";
      SolidImpact_Image.save(myFile);
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    }    



    if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {
      /*    
       for (int k = 1; k < SolidImpact_Contours_U1Vertices.length; k++) {  
       
       float x = SolidImpact_Contours_U1Vertices[k][0];
       float y = SolidImpact_Contours_U1Vertices[k][1];
       float z = SolidImpact_Contours_U1Vertices[k][2];
       
       float val = SolidImpact_Contours_U1Vertices[k][3]; //SOLARCHVISION_get_SolidImpact_atXYZ(x, y, z);
       
       float g =      roundTo(SolidImpact_Grade * val, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
       float g_line = roundTo(SolidImpact_Grade * val, deltaSolidImpactLines);
       
       float dx = 1;
       float dy = 0;
       float dz = 0;   
       
       float[] test_point_dir = {x, y, z, dx, dy, dz}; 
       
       // making the first VVertex on the UVertice
       {
       float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade}};
       SolidImpact_Contours_V1Vertices = (float[][]) concat(SolidImpact_Contours_V1Vertices, newVertex);
       }      
       
       // making the first WVertex on the UVertice
       {
       float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade}};
       SolidImpact_Contours_V2Vertices = (float[][]) concat(SolidImpact_Contours_V2Vertices, newVertex);
       }      
       
       
       SOLARCHVISION_trace_V1Line(test_point_dir, g_line, 100);
       }
       */
    }

    if (SolidImpact_record_PDF == 1) {

      String myFile = getFilename_SolidImpact() + ".pdf";

      PGraphics SolidImpact_PDF = createGraphics(SolidImpact_RES1, SolidImpact_RES2, PDF, myFile);

      SolidImpact_PDF.beginDraw();

      SolidImpact_PDF.image(SolidImpact_Image, 0, 0, SolidImpact_RES1, SolidImpact_RES2);

      if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {
        if (Display_SolidImpact_Lines) {

          for (int U_or_V_or_W = 0; U_or_V_or_W < 3; U_or_V_or_W++) {

            if (U_or_V_or_W == 0) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(255, 0, 0);
              SolidImpact_PDF.fill(255, 0, 0);
            } 
            if (U_or_V_or_W == 1) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(0, 255, 0);
              SolidImpact_PDF.fill(0, 255, 0);
            }
            if (U_or_V_or_W == 2) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(0, 0, 255);
              SolidImpact_PDF.fill(0, 0, 255);
            }

            int q_num = 0;
            if (U_or_V_or_W == 0) {
              q_num = SolidImpact_Contours_U1Lines.length;
            } 
            if (U_or_V_or_W == 1) {
              q_num = SolidImpact_Contours_V1Lines.length;
            }
            if (U_or_V_or_W == 2) {
              q_num = SolidImpact_Contours_V2Lines.length;
            }

            for (int q = 1; q < q_num; q++) {

              float[] i = {
                0, 0
              };
              float[] j = {
                0, 0
              };

              for (int p = 0; p < 2; p++) {

                int n = 0;
                float x0 = 0, y0 = 0, z0 = 0;

                if (U_or_V_or_W == 0) {
                  n = SolidImpact_Contours_U1Lines[q][p];
                  x0 = SolidImpact_Contours_U1Vertices[n][0];
                  y0 = SolidImpact_Contours_U1Vertices[n][1];
                  z0 = SolidImpact_Contours_U1Vertices[n][2];
                }
                if (U_or_V_or_W == 1) {
                  n = SolidImpact_Contours_V1Lines[q][p];        
                  x0 = SolidImpact_Contours_V1Vertices[n][0];
                  y0 = SolidImpact_Contours_V1Vertices[n][1];
                  z0 = SolidImpact_Contours_V1Vertices[n][2];
                }
                if (U_or_V_or_W == 2) {
                  n = SolidImpact_Contours_V2Lines[q][p];        
                  x0 = SolidImpact_Contours_V2Vertices[n][0];
                  y0 = SolidImpact_Contours_V2Vertices[n][1];
                  z0 = SolidImpact_Contours_V2Vertices[n][2];
                }

                float r = 0;

                if (SolidImpact_sectionType == 1) {
                  r = -SolidImpact_Rotation[SolidImpact_sectionType];
                } else if (SolidImpact_sectionType == 2) {
                  r = SolidImpact_Rotation[SolidImpact_sectionType];
                } else if (SolidImpact_sectionType == 3) {
                  r = -SolidImpact_Rotation[SolidImpact_sectionType];
                }     

                float x = x0 * cos_ang(r) - y0 * sin_ang(r);
                float y = x0 * sin_ang(r) + y0 * cos_ang(r);
                float z = z0;

                float a = 0;
                float b = 0;

                if (SolidImpact_sectionType == 1) {
                  a = x;
                  b = -y;
                } else if (SolidImpact_sectionType == 2) {
                  a = x;
                  b = -z;
                } else if (SolidImpact_sectionType == 3) {
                  a = -y;
                  b = -z;
                }

                i[p] = SolidImpact_RES1 * ((a - SolidImpact_offset_U[SolidImpact_sectionType]) / SolidImpact_scale_U[SolidImpact_sectionType] + 0.5);
                j[p] = SolidImpact_RES2 * ((b + SolidImpact_offset_V[SolidImpact_sectionType]) / SolidImpact_scale_V[SolidImpact_sectionType] + 0.5);
              }   

              SolidImpact_PDF.line(i[0], j[0], i[1], j[1]);
            }
          }
        }

        if (Display_SolidImpact_Points) {
          SolidImpact_PDF.strokeWeight(0.5);
          SolidImpact_PDF.stroke(255, 127, 0);
          SolidImpact_PDF.noFill();  
          SolidImpact_PDF.ellipseMode(CENTER);

          for (int n = 1; n < SolidImpact_Contours_U1Vertices.length; n++) {

            float x0 = SolidImpact_Contours_U1Vertices[n][0];
            float y0 = SolidImpact_Contours_U1Vertices[n][1];
            float z0 = SolidImpact_Contours_U1Vertices[n][2];

            float r = 0;

            if (SolidImpact_sectionType == 1) {
              r = -SolidImpact_Rotation[SolidImpact_sectionType];
            } else if (SolidImpact_sectionType == 2) {
              r = SolidImpact_Rotation[SolidImpact_sectionType];
            } else if (SolidImpact_sectionType == 3) {
              r = -SolidImpact_Rotation[SolidImpact_sectionType];
            }     

            float x = x0 * cos_ang(r) - y0 * sin_ang(r);
            float y = x0 * sin_ang(r) + y0 * cos_ang(r);
            float z = z0;

            float a = 0;
            float b = 0;

            if (SolidImpact_sectionType == 1) {
              a = x;
              b = -y;
            } else if (SolidImpact_sectionType == 2) {
              a = x;
              b = -z;
            } else if (SolidImpact_sectionType == 3) {
              a = -y;
              b = -z;
            }

            float i = SolidImpact_RES1 * ((a - SolidImpact_offset_U[SolidImpact_sectionType]) / SolidImpact_scale_U[SolidImpact_sectionType] + 0.5);
            float j = SolidImpact_RES2 * ((b + SolidImpact_offset_V[SolidImpact_sectionType]) / SolidImpact_scale_V[SolidImpact_sectionType] + 0.5);

            SolidImpact_PDF.ellipse(i, j, 1, 1);
          }

          SolidImpact_PDF.strokeWeight(0);
        }
      }


      SolidImpact_PDF.dispose();

      SolidImpact_PDF.endDraw();

      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    }

    cursor(ARROW);
  }
}



void SOLARCHVISION_draw_SolidImpact_lines () {

  if (Display_SolidImpact_Lines) {

    WIN3D.graphics.strokeWeight(1);
    WIN3D.graphics.stroke(255, 0, 0);
    WIN3D.graphics.fill(255, 0, 0);  

    for (int q = 1; q < SolidImpact_Contours_U1Lines.length; q++) {

      int n1 = SolidImpact_Contours_U1Lines[q][0];
      int n2 = SolidImpact_Contours_U1Lines[q][1];

      float x1 = SolidImpact_Contours_U1Vertices[n1][0];
      float y1 = SolidImpact_Contours_U1Vertices[n1][1];
      float z1 = SolidImpact_Contours_U1Vertices[n1][2];

      float x2 = SolidImpact_Contours_U1Vertices[n2][0];
      float y2 = SolidImpact_Contours_U1Vertices[n2][1];
      float z2 = SolidImpact_Contours_U1Vertices[n2][2];

      WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
    }

    WIN3D.graphics.strokeWeight(1);
    WIN3D.graphics.stroke(0, 255, 0);
    WIN3D.graphics.fill(0, 255, 0);  

    for (int q = 1; q < SolidImpact_Contours_V1Lines.length; q++) {

      int n1 = SolidImpact_Contours_V1Lines[q][0];
      int n2 = SolidImpact_Contours_V1Lines[q][1];

      float x1 = SolidImpact_Contours_V1Vertices[n1][0];
      float y1 = SolidImpact_Contours_V1Vertices[n1][1];
      float z1 = SolidImpact_Contours_V1Vertices[n1][2];

      float x2 = SolidImpact_Contours_V1Vertices[n2][0];
      float y2 = SolidImpact_Contours_V1Vertices[n2][1];
      float z2 = SolidImpact_Contours_V1Vertices[n2][2];

      WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
    }

    WIN3D.graphics.strokeWeight(1);
    WIN3D.graphics.stroke(255, 0, 0);
    WIN3D.graphics.fill(255, 0, 0);  

    for (int q = 1; q < SolidImpact_Contours_V2Lines.length; q++) {

      int n1 = SolidImpact_Contours_V2Lines[q][0];
      int n2 = SolidImpact_Contours_V2Lines[q][1];

      float x1 = SolidImpact_Contours_V2Vertices[n1][0];
      float y1 = SolidImpact_Contours_V2Vertices[n1][1];
      float z1 = SolidImpact_Contours_V2Vertices[n1][2];

      float x2 = SolidImpact_Contours_V2Vertices[n2][0];
      float y2 = SolidImpact_Contours_V2Vertices[n2][1];
      float z2 = SolidImpact_Contours_V2Vertices[n2][2];

      WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
    }

    WIN3D.graphics.strokeWeight(0);
  }
}

void SOLARCHVISION_draw_SolidImpact_points () {
  if (Display_SolidImpact_Points) {

    WIN3D.graphics.strokeWeight(0);
    WIN3D.graphics.stroke(255, 127, 0);
    WIN3D.graphics.fill(255, 127, 0);  

    float R = 1; //0.2;

    for (int n = 1; n < SolidImpact_Contours_U1Vertices.length; n++) {

      float x = SolidImpact_Contours_U1Vertices[n][0];
      float y = SolidImpact_Contours_U1Vertices[n][1];
      float z = SolidImpact_Contours_U1Vertices[n][2];

      WIN3D.graphics.pushMatrix();
      WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
      WIN3D.graphics.sphere(R);
      WIN3D.graphics.popMatrix();
    }
  }
}

float MinimumDistance_traceU = 1.0;
float MinimumDistance_traceV = 0.25;

void SOLARCHVISION_trace_U1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = 0; 
  int point_next = 0;

  for (int n = 0; n < n_Tries; n++) {

    float[][] preVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };

    if (point_prev == 0) {
      float nearestPointDist = FLOAT_undefined;
      int nearestPointNum = 0;

      for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {
        //if (preVertex[0][3] == SolidImpact_Contours_U1Vertices[q][3]) {
        if (preVertex[0][3] - SolidImpact_Contours_U1Vertices[q][3] < 0.0001) {

          float d = dist(preVertex[0][0], preVertex[0][1], preVertex[0][2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

          if (nearestPointDist > d) {
            nearestPointDist = d;
            nearestPointNum = q;
          }
        }
      }

      if (nearestPointDist < 0.5) {  //i.e. 0.5m 
        point_prev = nearestPointNum;

        test_point_dir[0] = SolidImpact_Contours_U1Vertices[point_prev][0];
        test_point_dir[1] = SolidImpact_Contours_U1Vertices[point_prev][1];
        test_point_dir[2] = SolidImpact_Contours_U1Vertices[point_prev][2];
      }
    } 

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(0, MinimumDistance_traceU, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SolidImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    float[][] newVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };
    point_next = 0; 

    float nearestPointDist = FLOAT_undefined;
    int nearestPointNum = 0;

    int next_point_existed = 0;

    for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {
      //if (newVertex[0][3] == SolidImpact_Contours_U1Vertices[q][3]) {
      if (abs(newVertex[0][3] - SolidImpact_Contours_U1Vertices[q][3]) < 0.0001) {

        float d = dist(newVertex[0][0], newVertex[0][1], newVertex[0][2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

        if ((nearestPointDist > d) && (point_prev != q)) { 
          nearestPointDist = d;
          nearestPointNum = q;
        }
      }
    }

    if (nearestPointDist < MinimumDistance_traceU) {
      point_next = nearestPointNum;

      test_point_dir[0] = SolidImpact_Contours_U1Vertices[point_next][0];
      test_point_dir[1] = SolidImpact_Contours_U1Vertices[point_next][1];
      test_point_dir[2] = SolidImpact_Contours_U1Vertices[point_next][2];

      next_point_existed = 1;
    }


    if (point_next == 0) {

      SolidImpact_Contours_U1Vertices = (float[][]) concat(SolidImpact_Contours_U1Vertices, newVertex);              
      point_next = SolidImpact_Contours_U1Vertices.length - 1;
    } 

    if ((point_prev != 0) && (point_next != 0)) {
      int[][] newU1Line = {
        {
          point_prev, point_next
        }
      };
      SolidImpact_Contours_U1Lines = (int[][]) concat(SolidImpact_Contours_U1Lines, newU1Line);

      point_prev = point_next;
    }

    if (next_point_existed == 1) {
      break; // when reaching an existing line
    }
  }
}

void SOLARCHVISION_trace_V1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = SolidImpact_Contours_V1Vertices.length - 1; // the last added point
  int point_next = 0;

  for (int n = 0; n < n_Tries; n++) {

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(-1, MinimumDistance_traceV, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SolidImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    float[][] newVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };

    point_next = 0;

    {
      SolidImpact_Contours_V1Vertices = (float[][]) concat(SolidImpact_Contours_V1Vertices, newVertex);              
      point_next = SolidImpact_Contours_V1Vertices.length - 1;
    }

    if ((point_prev != 0) && (point_next != 0)) {
      int[][] newV1Line = {
        {
          point_prev, point_next
        }
      };
      SolidImpact_Contours_V1Lines = (int[][]) concat(SolidImpact_Contours_V1Lines, newV1Line);

      float val_new = SOLARCHVISION_get_SolidImpact_atXYZ(test_point_dir[0], test_point_dir[1], test_point_dir[2]);
      float g_new =      roundTo(SolidImpact_Grade * val_new, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
      float g_line_new = roundTo(SolidImpact_Grade * val_new, deltaSolidImpactLines);

      if (g_line - g_line_new >= deltaSolidImpactStep) {


        float nearestPointDist = FLOAT_undefined;
        int nearestPointNum = 0;

        for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {

          //if (abs(g_line_new / SolidImpact_Grade - SolidImpact_Contours_U1Vertices[q][3]) < 0.0001) {
          if (g_line - g_line_new < 2 * deltaSolidImpactStep) {

            float d = dist(test_point_dir[0], test_point_dir[1], test_point_dir[2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

            if (nearestPointDist > d) { 
              nearestPointDist = d;
              nearestPointNum = q;
            }
          }
        }

        if (nearestPointDist < MinimumDistance_traceU) {

          int q = nearestPointNum;

          float[][] endVertex = {
            {
              SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2], SolidImpact_Contours_U1Vertices[q][3]
            }
          };
          SolidImpact_Contours_V2Vertices = (float[][]) concat(SolidImpact_Contours_V2Vertices, endVertex);

          int[][] newV2Line = {
            {
              SolidImpact_Contours_V2Vertices.length - 2, SolidImpact_Contours_V2Vertices.length - 1
            }
          }; // last two WVertices
          SolidImpact_Contours_V2Lines = (int[][]) concat(SolidImpact_Contours_V2Lines, newV2Line);
        }


        break; // when reaching the area outside contour level
      }

      point_prev = point_next;
    }
  }
}









float[][] skyVertices = new float [0][3];
int[][] skyFaces = new int [0][1];

int POINTER_TempObjectVertices = 0;
int POINTER_TempObjectFaces = 0;

float[][] TempObjectVertices = new float [0][3];
int[][] TempObjectFaces = new int [0][1];

float SOLARCHVISION_SolarAtSurface (float SunR1, float SunR2, float SunR3, float SunR4, float SunR5, float Alpha, float Beta, float THE_ALBEDO) {

  float return_value = FLOAT_undefined;

  if ((is_undefined_FLOAT(SunR1) == false) && (is_undefined_FLOAT(SunR2) == false) && (is_undefined_FLOAT(SunR3) == false) && (is_undefined_FLOAT(SunR4) == false) && (is_undefined_FLOAT(SunR5) == false)) { 

    float[] VECT = {
      0, 0, 0
    }; 

    if (abs(Alpha) > 89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = 1;
    } else if (Alpha < -89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = -1;
    } else {
      VECT[0] = sin_ang(Beta);
      VECT[1] = -cos_ang(Beta);
      VECT[2] = tan_ang(Alpha);
    }   

    VECT = SOLARCHVISION_fn_normalize(VECT);


    float[] SunV = {
      SunR1, SunR2, SunR3
    };

    float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
    if (SunMask <= 0) SunMask = 0; // removes backing faces 

    float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));

    return_value = (SunR4 * SunMask) + (SunR5 * SkyMask);    


    /*
    float[] REF_SunV = {SunR1, SunR2, -SunR3};
     
     float REF_SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(REF_SunV), SOLARCHVISION_fn_normalize(VECT));
     if (REF_SunMask <= 0) REF_SunMask = 0; // removes backing faces 
     
     float REF_SkyMask = 1 - (0.5 * (1.0 + (Alpha / 90.0)));      
     
     return_value +=  (0.01 * THE_ALBEDO) * ((SunR4 * REF_SunMask) + (SunR5 * REF_SkyMask));
     */
  }

  return (return_value);
}












void SOLARCHVISION_resize_GlobalSolar_array () {

  SOLARCHVISION_GLOBE_stp_slp = GLOBE_calculatedResolution;
  SOLARCHVISION_GLOBE_stp_dir = GLOBE_calculatedResolution;
  SOLARCHVISION_GLOBE_n_slp = int(roundTo(180.0 / (1.0 * SOLARCHVISION_GLOBE_stp_slp), 1)) + 1;  
  SOLARCHVISION_GLOBE_n_dir = int(roundTo(360.0 / (1.0 * SOLARCHVISION_GLOBE_stp_dir), 1));

  GlobalSolar = new float [2][(1 + STUDY.j_End - STUDY.j_Start)][SOLARCHVISION_GLOBE_n_slp][SOLARCHVISION_GLOBE_n_dir];

  for (int i = 0; i < GlobalSolar.length; i++) {
    for (int j = 0; j < GlobalSolar[i].length; j++) {
  
      for (int a = 0; a < SOLARCHVISION_GLOBE_n_slp; a++) {
        for (int b = 0; b < SOLARCHVISION_GLOBE_n_dir; b++) {  
          GlobalSolar[i][j][a][b] = FLOAT_undefined;
        }
      }
    }
  }

  rebuild_GlobalSolar_array = 0;
}


void SOLARCHVISION_calculate_GlobalSolar_array () {

  cursor(WAIT);

  if (rebuild_GlobalSolar_array != 0) {
    SOLARCHVISION_resize_GlobalSolar_array();
  }

  float keep_STUDY_PerDays = STUDY.PerDays;
  int keep_STUDY_JoinDays = STUDY.JoinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.PerDays = 1;
    STUDY.JoinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;



  if (STUDY.PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
  else Impact_TYPE = Impact_PASSIVE;



  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int l = STUDY.ImpactLayer;

  float[][] TOTAL_valuesSUM_RAD = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  int[][] TOTAL_valuesNUM = new int [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];

  for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
    for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
      TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      TOTAL_valuesNUM[a][b] = 0;
    }
  }

  for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

    now_j = (j * int(STUDY.PerDays) + TIME_BeginDay + 365) % 365;

    if (now_j >= 365) {
      now_j = now_j % 365;
    }
    if (now_j < 0) {
      now_j = (now_j + 365) % 365;
    }

    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

    float _sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
    float _sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

    int[] Normals_COL_N;
    Normals_COL_N = new int [9];
    Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

    for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
      if (nk != -1) {
        int k = int(nk / STUDY.JoinDays);
        int j_ADD = nk % STUDY.JoinDays; 

        for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
          float Alpha = a * SOLARCHVISION_GLOBE_stp_slp - 90;
          for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
            float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF_P = 0;
            float _valuesSUM_EFF_N = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i++) {
              if (STUDY.isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
        
                  if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                    
                    if (memberCount == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      if (is_undefined_FLOAT(_valuesSUM_RAD)) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF_P = 0;
                        _valuesSUM_EFF_N = 0;
                        _valuesNUM = 0;
                      } else {

                        if (_values_E_dir < 0) {
                          _valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                        } else {
                          _valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                        }

                        _valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 

                        _valuesNUM += 1;
                      }
                    }
                  }
                }
              }
            }


            if (_valuesNUM != 0) {
              //float _valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * _valuesNUM);  
              //float _valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * _valuesNUM);
              float _valuesMUL = roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * _valuesNUM);

              _valuesSUM_RAD *= _valuesMUL;
              _valuesSUM_EFF_P *= _valuesMUL;
              _valuesSUM_EFF_N *= _valuesMUL;

              if (TOTAL_valuesNUM[a][b] == 0) {
                TOTAL_valuesSUM_RAD[a][b] = 0;
                TOTAL_valuesSUM_EFF_P[a][b] = 0;
                TOTAL_valuesSUM_EFF_N[a][b] = 0;
              }

              TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
              TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
              TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
              TOTAL_valuesNUM[a][b] += 1;
            } else {
              _valuesSUM_RAD = FLOAT_undefined;
              _valuesSUM_EFF_P = FLOAT_undefined;
              _valuesSUM_EFF_N = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
            if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

            if (is_undefined_FLOAT(_valuesSUM_RAD) == false) {
              GlobalSolar[Impact_ACTIVE][j + 1][a][b] = _valuesSUM_RAD;
            }
            if (is_undefined_FLOAT(COMPARISON) == false) {
              GlobalSolar[Impact_PASSIVE][j + 1][a][b] = COMPARISON;
            }
          }
        }
      }
    }
  }



  for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a++) { 
    float Alpha = a * SOLARCHVISION_GLOBE_stp_slp - 90;
    for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b++) {
      float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

      if (TOTAL_valuesNUM[a][b] != 0) {
        TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
      } else {
        TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      }

      float AVERAGE, PERCENTAGE, COMPARISON;

      AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
      if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
      else PERCENTAGE = 0.0;
      COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

      if (is_undefined_FLOAT(TOTAL_valuesSUM_RAD[a][b]) == false) {
        GlobalSolar[Impact_ACTIVE][0][a][b] = TOTAL_valuesSUM_RAD[a][b];
      }
      if (is_undefined_FLOAT(COMPARISON) == false) {
        GlobalSolar[Impact_PASSIVE][0][a][b] = COMPARISON;
      }

    }
  }


  keep_STUDY_PerDays = STUDY.PerDays;
  STUDY.JoinDays = keep_STUDY_JoinDays;

  cursor(ARROW);
}


void SOLARCHVISION_draw_logo (float cx, float cy, float cz, float cr, int the_view) {

  float stp_u = 1.0 / 12.0;
  float stp_v = 1.0 / 12.0;

  int n_a = 1;

  for (float a = -1; a < 1; a += stp_u) {

    n_a *= -1;

    int n_b = n_a;

    for (float b = -1; b < 1; b += stp_v) {

      n_b *= -1;

      float[][] newQuad = {
        {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
      };

      for (int i = 0; i < 4; i++) {

        float u = a;
        float v = b;

        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        //---------------------------------------
        float x0 = cos(u * PI); 
        float y0 = sin(u * PI) * cos(v * PI);
        float z0 = sin(v * PI);

        float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
        x0 /= d;  
        y0 /= d;  
        z0 /= d;  

        float x = x0;
        float y = y0;
        float z = z0;

        if (the_view == 0) { // corner view: logo
          float t = 0.25 * PI;
          newQuad[i][0] = x0 * cos(t) - z0 * sin(t);
          newQuad[i][1] = y0;   
          newQuad[i][2] = x0 * sin(t) + z0 * cos(t);
        } else if (the_view == 1) { // front view
          newQuad[i][0] = x0;
          newQuad[i][1] = y0;   
          newQuad[i][2] = z0;
        } else if (the_view == -1) { // top view
          newQuad[i][0] = x0;
          newQuad[i][1] = z0;   
          newQuad[i][2] = y0;
        }
      }

      float x1 = cr * newQuad[0][0] + cx;
      float y1 = cr * newQuad[0][1] + cy;
      float z1 = cr * newQuad[0][2] + cz;

      float x2 = cr * newQuad[1][0] + cx;
      float y2 = cr * newQuad[1][1] + cy;
      float z2 = cr * newQuad[1][2] + cz;

      float x3 = cr * newQuad[2][0] + cx;
      float y3 = cr * newQuad[2][1] + cy;
      float z3 = cr * newQuad[2][2] + cz;

      float x4 = cr * newQuad[3][0] + cx;
      float y4 = cr * newQuad[3][1] + cy;
      float z4 = cr * newQuad[3][2] + cz;

      if (n_a * n_b == 1) {
        triangle(x1, y1, x2, y2, x3, y3);
        triangle(x3, y3, x4, y4, x1, y1);
      } else {
        triangle(x4, y4, x1, y1, x2, y2);
        triangle(x2, y2, x3, y3, x4, y4);
      }
    }
  }
}





void SOLARCHVISION_PickSelect (float[] RxP) {
  
  if (addNewSelectionToPreviousSelection == 0) allModel3Ds.deselect_All();


  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedLandPoint_ids.length - 1; o >= 0; o--) {
        if (selectedLandPoint_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedLandPoint_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedLandPoint_ids, found_at + 1);

      selectedLandPoint_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedLandPoint_ids = (int[]) concat(selectedLandPoint_ids, newObject_id);
    }

    WIN3D.update = true;

    println("SOLARCHVISION_calculate_selection_BoundingBox 6");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }


  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {
        if (selectedallModel1Ds_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedallModel1Ds_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedallModel1Ds_ids, found_at + 1);

      selectedallModel1Ds_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedallModel1Ds_ids = (int[]) concat(selectedallModel1Ds_ids, newObject_id);
    }

    WIN3D.update = true;


    println("SOLARCHVISION_calculate_selection_BoundingBox 6");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }


  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {
        if (selectedallModel2Ds_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedallModel2Ds_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedallModel2Ds_ids, found_at + 1);

      selectedallModel2Ds_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedallModel2Ds_ids = (int[]) concat(selectedallModel2Ds_ids, newObject_id);
    }

    WIN3D.update = true;

    println("SOLARCHVISION_calculate_selection_BoundingBox 5");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }


  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    int f = int(RxP[0]);

    int OBJ_NUM = 0;

    for (int i = 0; i < allGroups.num; i++) {
      if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {

        OBJ_NUM = i;

        WIN3D.update = true;
        break;
      }
    }

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
        if (selectedGroup_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedGroup_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedGroup_ids, found_at + 1);

      selectedGroup_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedGroup_ids = (int[]) concat(selectedGroup_ids, newObject_id);
    }



    println("SOLARCHVISION_calculate_selection_BoundingBox 4");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }

  if (Current_ObjectCategory == ObjectCategory.FACE) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedFace_ids.length - 1; o >= 0; o--) {
        if (selectedFace_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedFace_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedFace_ids, found_at + 1);

      selectedFace_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedFace_ids = (int[]) concat(selectedFace_ids, newObject_id);
    }


    println("SOLARCHVISION_calculate_selection_BoundingBox 3");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }

  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {
        if (selectedCurve_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedCurve_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedCurve_ids, found_at + 1);

      selectedCurve_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedCurve_ids = (int[]) concat(selectedCurve_ids, newObject_id);
    }

    println("SOLARCHVISION_calculate_selection_BoundingBox 3");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
  

  if (Current_ObjectCategory == ObjectCategory.VERTEX) {

    int f = int(RxP[0]);

    int OBJ_NUM = 0;
    float min_dist = FLOAT_undefined;  

    for (int j = 0; j < allFaces.nodes[f].length; j++) {
      int vNo = allFaces.nodes[f][j];

      float x = allVertices[vNo][0];
      float y = allVertices[vNo][1];          
      float z = allVertices[vNo][2];

      float now_dist = dist(x, y, z, RxP[1], RxP[2], RxP[3]);

      if (min_dist > now_dist) {
        min_dist = now_dist;
        OBJ_NUM = vNo;
      }
    }


    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {
        if (selectedVertex_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedVertex_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedVertex_ids, found_at + 1);

      selectedVertex_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedVertex_ids = (int[]) concat(selectedVertex_ids, newObject_id);
    }


    println("SOLARCHVISION_calculate_selection_BoundingBox 2");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }



  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedSolid_ids.length - 1; o >= 0; o--) {
        if (selectedSolid_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedSolid_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedSolid_ids, found_at + 1);

      selectedSolid_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedSolid_ids = (int[]) concat(selectedSolid_ids, newObject_id);
    }

    WIN3D.update = true;

    println("SOLARCHVISION_calculate_selection_BoundingBox 6e");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }



  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedSection_ids.length - 1; o >= 0; o--) {
        if (selectedSection_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedSection_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedSection_ids, found_at + 1);

      selectedSection_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedSection_ids = (int[]) concat(selectedSection_ids, newObject_id);
    }

    WIN3D.update = true;

    println("SOLARCHVISION_calculate_selection_BoundingBox 6b");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }

  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedCamera_ids.length - 1; o >= 0; o--) {
        if (selectedCamera_ids[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedCamera_ids, 0, found_at);
      int[] endList = (int[]) subset(selectedCamera_ids, found_at + 1);

      selectedCamera_ids = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] newObject_id = {
        OBJ_NUM
      };

      selectedCamera_ids = (int[]) concat(selectedCamera_ids, newObject_id);
    }

    WIN3D.update = true;

    println("SOLARCHVISION_calculate_selection_BoundingBox 6c");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}


void SOLARCHVISION_RectSelect (float corner1x, float corner1y, float corner2x, float corner2y) {

  if (addNewSelectionToPreviousSelection == 0) allModel3Ds.deselect_All();


  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {

    for (int OBJ_NUM = 0; OBJ_NUM < Land3D.n_I * Land3D.n_J; OBJ_NUM++) {

      int i = OBJ_NUM / Land3D.n_J;
      int j = OBJ_NUM % Land3D.n_J;      

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      for (int k = 0; k < 1; k++) { // just a loop to make those break commands relevant!  

        float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
        float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
        float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }
      }        



      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedLandPoint_ids.length - 1; o >= 0; o--) {
            if (selectedLandPoint_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedLandPoint_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedLandPoint_ids, found_at + 1);

          selectedLandPoint_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedLandPoint_ids = (int[]) concat(selectedLandPoint_ids, newObject_id);
        }
      }
    }
  }   



  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    for (int OBJ_NUM = 0; OBJ_NUM < allModel1Ds.Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

        int vNo = allModel1Ds.Faces[f][j];

        float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
        float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
        float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {
            if (selectedallModel1Ds_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedallModel1Ds_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedallModel1Ds_ids, found_at + 1);

          selectedallModel1Ds_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedallModel1Ds_ids = (int[]) concat(selectedallModel1Ds_ids, newObject_id);
        }
      }
    }
  }    


  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allFaces.nodes.length)) { 

            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];

              float x = allVertices[vNo][0] * OBJECTS_scale;
              float y = allVertices[vNo][1] * OBJECTS_scale;            
              float z = -allVertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                  if (mouseButton == RIGHT) {
                    include_OBJ_in_newSelection = 1;
                    break_loops = 1;
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }
              } else {
                if (mouseButton == LEFT) {
                  include_OBJ_in_newSelection = 0;
                  break_loops = 1;
                }
              }                        

              if (break_loops == 1) break;
            }

            if (break_loops == 1) break;
          }
        }
      }
      
      if (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1]) {

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allCurves.nodes.length)) { 

            for (int j = 0; j < allCurves.nodes[f].length; j++) {
              int vNo = allCurves.nodes[f][j];

              float x = allVertices[vNo][0] * OBJECTS_scale;
              float y = allVertices[vNo][1] * OBJECTS_scale;            
              float z = -allVertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                  if (mouseButton == RIGHT) {
                    include_OBJ_in_newSelection = 1;
                    break_loops = 1;
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }
              } else {
                if (mouseButton == LEFT) {
                  include_OBJ_in_newSelection = 0;
                  break_loops = 1;
                }
              }                        

              if (break_loops == 1) break;
            }

            if (break_loops == 1) break;
          }
        }
      }      

      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {
            if (selectedGroup_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedGroup_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedGroup_ids, found_at + 1);

          selectedGroup_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedGroup_ids = (int[]) concat(selectedGroup_ids, newObject_id);
        }
      }
    }
  }


  if (Current_ObjectCategory == ObjectCategory.FACE) {

    for (int OBJ_NUM = 0; OBJ_NUM < allFaces.nodes.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      for (int j = 0; j < allFaces.nodes[OBJ_NUM].length; j++) {
        int vNo = allFaces.nodes[OBJ_NUM][j];

        float x = allVertices[vNo][0] * OBJECTS_scale;
        float y = allVertices[vNo][1] * OBJECTS_scale;            
        float z = -allVertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                        

        if (break_loops == 1) break;
      }



      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedFace_ids.length - 1; o >= 0; o--) {
            if (selectedFace_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedFace_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedFace_ids, found_at + 1);

          selectedFace_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedFace_ids = (int[]) concat(selectedFace_ids, newObject_id);
        }
      }
    }
  }                

  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    for (int OBJ_NUM = 0; OBJ_NUM < allCurves.nodes.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      for (int j = 0; j < allCurves.nodes[OBJ_NUM].length; j++) {
        int vNo = allCurves.nodes[OBJ_NUM][j];

        float x = allVertices[vNo][0] * OBJECTS_scale;
        float y = allVertices[vNo][1] * OBJECTS_scale;            
        float z = -allVertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                        

        if (break_loops == 1) break;
      }



      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {
            if (selectedCurve_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedCurve_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedCurve_ids, found_at + 1);

          selectedCurve_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedCurve_ids = (int[]) concat(selectedCurve_ids, newObject_id);
        }
      }
    }
  }    


  if (Current_ObjectCategory == ObjectCategory.VERTEX) {

    for (int OBJ_NUM = 0; OBJ_NUM < allVertices.length; OBJ_NUM++) {

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      float x = allVertices[OBJ_NUM][0] * OBJECTS_scale;
      float y = allVertices[OBJ_NUM][1] * OBJECTS_scale;            
      float z = -allVertices[OBJ_NUM][2] * OBJECTS_scale;

      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
          if (mouseButton == RIGHT) {
            include_OBJ_in_newSelection = 1;
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
          }
        }
      } else {
        if (mouseButton == LEFT) {
          include_OBJ_in_newSelection = 0;
        }
      }                        


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {
            if (selectedVertex_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedVertex_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedVertex_ids, found_at + 1);

          selectedVertex_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedVertex_ids = (int[]) concat(selectedVertex_ids, newObject_id);
        }
      }
    }
  }             

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    for (int f = 0; f < allModel2Ds.Faces.length; f++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int OBJ_NUM = f / allModel2Ds.numDisplayFaces;

      //println(f, OBJ_NUM);

      for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

        int vNo = allModel2Ds.Faces[f][j];

        float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
        float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
        float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {
            if (selectedallModel2Ds_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }


        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedallModel2Ds_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedallModel2Ds_ids, found_at + 1);

          selectedallModel2Ds_ids = (int[]) concat(startList, endList);
        }



        if (use_it == 1) {
          
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedallModel2Ds_ids = (int[]) concat(selectedallModel2Ds_ids, newObject_id);
          
          // skip the same object's drawn faces
          f += allModel2Ds.numDisplayFaces - (f % allModel2Ds.numDisplayFaces) - 1;
        }
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    for (int f = 0; f < allSolids.Faces.length; f++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int OBJ_NUM = f / allSolids.numDisplayFaces;

      //println(f, OBJ_NUM);

      for (int j = 0; j < allSolids.Faces[f].length; j++) {

        int vNo = allSolids.Faces[f][j];

        float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
        float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
        float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedSolid_ids.length - 1; o >= 0; o--) {
            if (selectedSolid_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }


        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedSolid_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedSolid_ids, found_at + 1);

          selectedSolid_ids = (int[]) concat(startList, endList);
        }



        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedSolid_ids = (int[]) concat(selectedSolid_ids, newObject_id);
          
          // skip the same object's drawn faces
          f += allSolids.numDisplayFaces - (f % allSolids.numDisplayFaces) - 1;          
        }
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    for (int OBJ_NUM = 0; OBJ_NUM < allSections.Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allSections.Faces[f].length; j++) {

        int vNo = allSections.Faces[f][j];

        float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
        float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
        float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedSection_ids.length - 1; o >= 0; o--) {
            if (selectedSection_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedSection_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedSection_ids, found_at + 1);

          selectedSection_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedSection_ids = (int[]) concat(selectedSection_ids, newObject_id);
        }
      }
    }
  }  


  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    for (int OBJ_NUM = 0; OBJ_NUM < allCameras.Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allCameras.Faces[f].length; j++) {

        int vNo = allCameras.Faces[f][j];

        float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
        float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
        float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedCamera_ids.length - 1; o >= 0; o--) {
            if (selectedCamera_ids[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedCamera_ids, 0, found_at);
          int[] endList = (int[]) subset(selectedCamera_ids, found_at + 1);

          selectedCamera_ids = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] newObject_id = {
            OBJ_NUM
          };

          selectedCamera_ids = (int[]) concat(selectedCamera_ids, newObject_id);
        }
      }
    }
  }
}




int mouseWheelConsume = 0;

void mouseWheel (MouseEvent event) {

  if (frameCount > Last_initializationStep) {

    if (UI_BAR_a_selected_parent == -1) {

      mouseWheelConsume += 1;
      if (mouseWheelConsume % 2 == 0) {
        mouseWheelConsume = 0;

        float Wheel_Value = event.getCount(); 

        if (SOLARCHVISION_automated == 0) {
          SOLARCHVISION_X_clicked = mouseX;
          SOLARCHVISION_Y_clicked = mouseY;

          {
            float displayBarHeight = MessageSize;
            float displayBarWidth = 2 * SOLARCHVISION_W_Pixel; 

            STUDY.X_control = 0.5 * displayBarWidth;
            STUDY.Y_control = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel + 0.5 * UI_BAR_d_tab;

            for (int i = 0; i < UI_BAR_d_Items.length; i++) {

              float x1 = STUDY.X_control - 0.366 * displayBarWidth;
              float x2 = STUDY.X_control + 0.5 * displayBarWidth;
              float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
              float y2 = STUDY.Y_control + 0.45 * displayBarHeight;

              if (UI_BAR_d_Items[i][0].equals("Day")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_i_Start = STUDY.i_Start;
                  int keep_STUDY_i_End = STUDY.i_End;

                  if (Wheel_Value > 0) {
                    STUDY.i_Start += 1; 
                    STUDY.i_End += 1;
                  } 
                  if (Wheel_Value < 0) {
                    STUDY.i_Start -= 1; 
                    STUDY.i_End -= 1;
                  } 

                  if (STUDY.i_Start < 0) STUDY.i_Start = 23;
                  if (STUDY.i_Start > 23) STUDY.i_Start = 0;
                  if (STUDY.i_End < 0) STUDY.i_End = 23;
                  if (STUDY.i_End > 23) STUDY.i_End = 0;

                  if ((keep_STUDY_i_Start != STUDY.i_Start) || (keep_STUDY_i_End != STUDY.i_End)) {

                    ROLLOUT.update = true;
                    STUDY.update = true;
                    WIN3D.update = true;
                    WORLD.update = true;
                    UI_BAR_d_update = true;

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_BAR_d_Items[i][0].equals("Year")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_JoinDays = STUDY.JoinDays;

                  if (Wheel_Value > 0) STUDY.JoinDays += 2;
                  if (Wheel_Value < 0) STUDY.JoinDays -= 2;

                  if (STUDY.JoinDays > 365 / STUDY.j_End) STUDY.JoinDays = 365 / STUDY.j_End;
                  if (STUDY.JoinDays < 1) STUDY.JoinDays = 1;

                  if (keep_STUDY_JoinDays != STUDY.JoinDays) {

                    ROLLOUT.update = true;
                    STUDY.update = true;
                    WIN3D.update = true;
                    UI_BAR_d_update = true;

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_BAR_d_Items[i][0].equals("Scenario")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CWEEDS_start) SampleYear_Start = CLIMATE_CWEEDS_start;
                    if (SampleYear_Start > CLIMATE_CWEEDS_end) SampleYear_Start = CLIMATE_CWEEDS_end;
                    if (SampleYear_End < CLIMATE_CWEEDS_start) SampleYear_End = CLIMATE_CWEEDS_start;
                    if (SampleYear_End > CLIMATE_CWEEDS_end) SampleYear_End = CLIMATE_CWEEDS_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d_update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }
                  
                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CLMREC_start) SampleYear_Start = CLIMATE_CLMREC_start;
                    if (SampleYear_Start > CLIMATE_CLMREC_end) SampleYear_Start = CLIMATE_CLMREC_end;
                    if (SampleYear_End < CLIMATE_CLMREC_start) SampleYear_End = CLIMATE_CLMREC_start;
                    if (SampleYear_End > CLIMATE_CLMREC_end) SampleYear_End = CLIMATE_CLMREC_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d_update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }                  

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    int keep_SampleMember_Start = SampleMember_Start;
                    int keep_SampleMember_End = SampleMember_End;

                    if (Wheel_Value > 0) {
                      SampleMember_Start += 1; 
                      SampleMember_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleMember_Start -= 1; 
                      SampleMember_End -= 1;
                    }

                    if (SampleMember_End < SampleMember_Start) SampleMember_End = SampleMember_Start;
                    if (SampleMember_Start > SampleMember_End) SampleMember_Start = SampleMember_End; 

                    if (SampleMember_Start < ENSEMBLE_FORECAST_start) SampleMember_Start = ENSEMBLE_FORECAST_start;
                    if (SampleMember_Start > ENSEMBLE_FORECAST_end) SampleMember_Start = ENSEMBLE_FORECAST_end;
                    if (SampleMember_End < ENSEMBLE_FORECAST_start) SampleMember_End = ENSEMBLE_FORECAST_start;
                    if (SampleMember_End > ENSEMBLE_FORECAST_end) SampleMember_End = ENSEMBLE_FORECAST_end;

                    if ((keep_SampleMember_Start != SampleMember_Start) || (keep_SampleMember_End != SampleMember_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d_update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }   

                  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                    int keep_SampleStation_Start = SampleStation_Start;
                    int keep_SampleStation_End = SampleStation_End;

                    if (Wheel_Value > 0) {
                      SampleStation_Start += 1; 
                      SampleStation_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleStation_Start -= 1; 
                      SampleStation_End -= 1;
                    }

                    if (SampleStation_End < SampleStation_Start) SampleStation_End = SampleStation_Start;
                    if (SampleStation_Start > SampleStation_End) SampleStation_Start = SampleStation_End; 

                    if (SampleStation_Start < ENSEMBLE_OBSERVED_start) SampleStation_Start = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_Start > ENSEMBLE_OBSERVED_end) SampleStation_Start = ENSEMBLE_OBSERVED_end;
                    if (SampleStation_End < ENSEMBLE_OBSERVED_start) SampleStation_End = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_End > ENSEMBLE_OBSERVED_end) SampleStation_End = ENSEMBLE_OBSERVED_end;

                    if ((keep_SampleStation_Start != SampleStation_Start) || (keep_SampleStation_End != SampleStation_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d_update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }
                }
              }            


              STUDY.Y_control += UI_BAR_d_tab;
            }
          }


          if (WORLD.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY) == 1) {

              int keep_WORLD_Viewport_ZOOM = WORLD.Viewport_ZOOM;

              if (Wheel_Value < 0) WORLD.Viewport_ZOOM -= 1;
              if (Wheel_Value > 0) WORLD.Viewport_ZOOM += 1;

              if (WORLD.Viewport_ZOOM < 1) WORLD.Viewport_ZOOM = 1;
              if (WORLD.Viewport_ZOOM > 6) WORLD.Viewport_ZOOM = 6;

              if (keep_WORLD_Viewport_ZOOM != WORLD.Viewport_ZOOM) {
                WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

                WORLD.update = true;
              }
            }
          }    

          if (WIN3D.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

              float[] P = SOLARCHVISION_getPivot();

              float x0 = P[0];
              float y0 = P[1];
              float z0 = P[2];


              if (WIN3D.UI_CurrentTask == UITASK.Rotate) { // rotate

                float r = 5 * Wheel_Value;

                int the_Vector = selected_rotVector;

                SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);

                WIN3D.update = true;
              }   

              if (WIN3D.UI_CurrentTask == UITASK.Scale) { // scale

                float s = pow(pow(2.0, 0.25), Wheel_Value);

                float sx = s;
                float sy = s;
                float sz = s;

                int the_Vector = selected_scaleVector;

                if (the_Vector == 0) {
                  sy = 1; 
                  sz = 1;
                }  
                if (the_Vector == 1) {
                  sz = 1; 
                  sx = 1;
                }  
                if (the_Vector == 2) {
                  sx = 1; 
                  sy = 1;
                }                    

                SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);

                WIN3D.update = true;
              }       


              if (WIN3D.UI_CurrentTask == UITASK.Move) { // move

                float d = Wheel_Value;

                float dx = d;
                float dy = d;
                float dz = d;

                int the_Vector = selected_posVector;

                if (the_Vector == 0) {
                  dy = 0; 
                  dz = 0;
                }  
                if (the_Vector == 1) {
                  dz = 0; 
                  dx = 0;
                }  
                if (the_Vector == 2) {
                  dx = 0; 
                  dy = 0;
                }  

                SOLARCHVISION_move_Selection(dx, dy, dz);

                WIN3D.update = true;
              }   



              if (WIN3D.UI_TaskModifyParameter == 0) {
                if (WIN3D.UI_CurrentTask >= UITASK.Seed_Material) { // other properties

                  int p = int(Wheel_Value);

                  SOLARCHVISION_changeProperties_Selection(p);

                  WIN3D.update = true;
                }
              }
              
              



              if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) || (WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll)) { // viewport:zoom

                if (WIN3D.ViewType == 1) {
                  WIN3D.Z_Coordinate += Wheel_Value * WIN3D.S_Coordinate * OBJECTS_scale;
                } else {
                  WIN3D.Zoom /= pow(2.0, Wheel_Value);
                }

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) { // viewport:elevation

                if (Wheel_Value > 0) WIN3D.Zoom = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * WIN3D.Zoom)); 
                if (Wheel_Value < 0) WIN3D.Zoom = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * WIN3D.Zoom));

                WIN3D.update = true;
              }  

              if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport:3DModelSize

                if (Wheel_Value > 0) OBJECTS_scale *= pow(2.0, 0.25);
                if (Wheel_Value < 0) OBJECTS_scale /= pow(2.0, 0.25);

                WIN3D.update = true;
              }          

              if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.X_Coordinate += Wheel_Value * WIN3D.S_Coordinate * OBJECTS_scale;

                    WIN3D.update = true;
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.Y_Coordinate += Wheel_Value * WIN3D.S_Coordinate * OBJECTS_scale;

                    WIN3D.update = true;
                  }
                }


                if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.RX_Coordinate += Wheel_Value * WIN3D.RS_Coordinate;

                    WIN3D.update = true;
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.RZ_Coordinate += Wheel_Value * WIN3D.RS_Coordinate;

                    WIN3D.update = true;
                  }
                }


                WIN3D.update = true;
              }  


              if (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // SkydomeSize

                  if (Wheel_Value > 0) Sky3D.scale *= pow(2.0, 0.25);              
                  if (Wheel_Value < 0) Sky3D.scale /= pow(2.0, 0.25);

                  WIN3D.update = true;
                }
              }

              if (WIN3D.UI_CurrentTask == UITASK.AllModelSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // AllModelSize

                  if (Wheel_Value > 0) {
                    OBJECTS_scale *= pow(2.0, 0.25);
                    Sky3D.scale *= pow(2.0, 0.25);
                  }              

                  if (Wheel_Value < 0) {
                    OBJECTS_scale /= pow(2.0, 0.25);
                    Sky3D.scale /= pow(2.0, 0.25);
                  }      

                  WIN3D.update = true;
                }
              }    

              if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport:TargetRollXY/TargetRoolZ

                if (WIN3D.UI_OptionXorY == 0) {   
                  WIN3D.RX_Coordinate += Wheel_Value * WIN3D.RS_Coordinate;

                  WIN3D.reverseTransform_3DViewport();
                }

                if (WIN3D.UI_OptionXorY == 1) {   
                  WIN3D.RZ_Coordinate += Wheel_Value * WIN3D.RS_Coordinate;

                  WIN3D.reverseTransform_3DViewport();
                }              

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport:CameraRollXY/CameraRoolZ

                if (WIN3D.UI_OptionXorY == 0) {   

                  WIN3D.rotateZ_3DViewport_around_Selection(Wheel_Value * WIN3D.RS_Coordinate);
                }

                if (WIN3D.UI_OptionXorY == 1) {   

                  WIN3D.rotateXY_3DViewport_around_Selection(Wheel_Value * WIN3D.RS_Coordinate);
                }    

                WIN3D.update = true;
              }            

              if (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ) { // viewport:CameraDistance

                WIN3D.move_3DViewport_towards_Selection(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }              

              if (WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) { // viewport:PanX

                WIN3D.X_Coordinate += Wheel_Value * WIN3D.S_Coordinate * OBJECTS_scale;

                WIN3D.update = true;
              }         

              if (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ) { // viewport:PanY

                WIN3D.Y_Coordinate += Wheel_Value * WIN3D.S_Coordinate * OBJECTS_scale;

                WIN3D.update = true;
              }      

              if ((WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport:DistMouseXY

                WIN3D.move_3DViewport_towards_Mouse(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport:LandOrbit

                WIN3D.move_3DViewport_towards_Mouse(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }      


              
            }
          }
        }
      }
    }
  }
}


int dragging_started = 0;

void mouseReleased () {

  if (frameCount > Last_initializationStep) {  

    if (SOLARCHVISION_automated == 0) {

      if (dragging_started != 0) {

        SOLARCHVISION_X_click2 = mouseX;
        SOLARCHVISION_Y_click2 = mouseY;

        int swap_tmp = 0;

        if (SOLARCHVISION_X_click2 < SOLARCHVISION_X_click1) {
          swap_tmp = SOLARCHVISION_X_click2;
          SOLARCHVISION_X_click2 = SOLARCHVISION_X_click1;
          SOLARCHVISION_X_click1 = swap_tmp;
        }

        if (SOLARCHVISION_Y_click2 < SOLARCHVISION_Y_click1) {
          swap_tmp = SOLARCHVISION_Y_click2;
          SOLARCHVISION_Y_click2 = SOLARCHVISION_Y_click1;
          SOLARCHVISION_Y_click1 = swap_tmp;
        }        

        if (FRAME_drag_JPG) {

          SOLARCHVISION_RecordFrame();

          strokeWeight(2);
          if (mouseButton == RIGHT) {
            noStroke();
            fill(127, 127);
          } else {
            stroke(255, 0, 0);
            noFill();
          }          

          rect(SOLARCHVISION_X_click1, SOLARCHVISION_Y_click1, SOLARCHVISION_X_click2 - SOLARCHVISION_X_click1, SOLARCHVISION_Y_click2 - SOLARCHVISION_Y_click1);
          strokeWeight(0);

          SOLARCHVISION_RecordFrame();

          WORLD.update = true;
          WIN3D.update = true;  
          STUDY.update = true;
          ROLLOUT.update = true;
          UI_BAR_a_update = true;
          UI_BAR_b_update = true;
          UI_BAR_d_update = true;          

          FRAME_drag_JPG = false;

          dragging_started = 0;
        } else {        

          if (WIN3D.include) {
            if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

              if ((WIN3D.UI_CurrentTask == UITASK.RectSelect) || (WIN3D.UI_CurrentTask > UITASK.Move)) { // RectSelect also if scale, rotate, modify, etc. where selected          

                float corner1x = SOLARCHVISION_X_click1 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner1y = SOLARCHVISION_Y_click1 - 0.5 * WIN3D.dY - WIN3D.cY;

                float corner2x = SOLARCHVISION_X_click2 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner2y = SOLARCHVISION_Y_click2 - 0.5 * WIN3D.dY - WIN3D.cY;

                pushMatrix();

                translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

                noFill();

                stroke(127); 
                strokeWeight(2);

                rect(corner1x, corner1y, corner2x - corner1x, corner2y - corner1y);

                popMatrix();            

                SOLARCHVISION_RectSelect(corner1x, corner1y, corner2x, corner2y);

                println("SOLARCHVISION_calculate_selection_BoundingBox 1");
                SOLARCHVISION_calculate_selection_BoundingBox();

                SOLARCHVISION_reset_selectedRefValues();  

                WIN3D.update = true;
              }


              if (WIN3D.UI_CurrentTask == UITASK.GetLength) {      

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                for (int q = 0; q < 2; q++) {

                  float Image_X = 0;
                  float Image_Y = 0;

                  if (q == 0) {
                    Image_X = SOLARCHVISION_X_click1 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click1 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }
                  if (q == 1) {
                    Image_X = SOLARCHVISION_X_click2 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click2 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }

                  float[] ray_direction = new float [3];

                  float[] ray_start = {
                    WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
                  };

                  float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

                  ray_start[0] /= OBJECTS_scale;
                  ray_start[1] /= OBJECTS_scale;
                  ray_start[2] /= OBJECTS_scale;          

                  ray_end[0] /= OBJECTS_scale;
                  ray_end[1] /= OBJECTS_scale;
                  ray_end[2] /= OBJECTS_scale;

                  if (WIN3D.ViewType == 0) {
                    float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

                    ray_center[0] /= OBJECTS_scale;
                    ray_center[1] /= OBJECTS_scale;
                    ray_center[2] /= OBJECTS_scale;

                    ray_start[0] += ray_end[0] - ray_center[0];
                    ray_start[1] += ray_end[1] - ray_center[1];
                    ray_start[2] += ray_end[2] - ray_center[2];
                  }

                  ray_direction[0] = ray_end[0] - ray_start[0];
                  ray_direction[1] = ray_end[1] - ray_start[1];
                  ray_direction[2] = ray_end[2] - ray_start[2];

                  float[] RxP = new float [8]; 

                  if (mouseButton == RIGHT) {
                    RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
                  } else if (mouseButton == LEFT) {
                    RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));
                  }

                  if (RxP[0] >= 0) {
                    if (q == 0) {
                      x1 = RxP[1];
                      y1 = RxP[2];
                      z1 = RxP[3];
                    }
                    if (q == 1) {
                      x2 = RxP[1];
                      y2 = RxP[2];
                      z2 = RxP[3];
                    }
                  }
                }

                float dx = x2 - x1;
                float dy = y2 - y1;
                float dz = z2 - z1;

                float dx_rot = dx * cos_ang(-WIN3D.RZ_Coordinate) - dy * sin_ang(-WIN3D.RZ_Coordinate);
                float dy_rot = dx * sin_ang(-WIN3D.RZ_Coordinate) + dy * cos_ang(-WIN3D.RZ_Coordinate);
                float dz_rot = dz;

                if (WIN3D.UI_TaskModifyParameter == 0) {
                  CreateInput_Length = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 1) {
                  CreateInput_Width = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 2) {
                  CreateInput_Height = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 3) {
                  CreateInput_Length = abs(dx_rot);
                  CreateInput_Width = abs(dy_rot);
                  CreateInput_Height = abs(dz_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 4) {
                  CreateInput_Length = abs(dx_rot);
                  CreateInput_Width = abs(dy_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 5) {
                  CreateInput_Orientation = atan2_ang(y2 - y1, x2 - x1) + 90;
                }

                ROLLOUT.update = true;
              }
            }
          }

          dragging_started = 0;
        }
      }
    }
  }
}

void mouseDragged () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_drag_JPG) {
        if (dragging_started == 0) {
          SOLARCHVISION_X_click1 = pmouseX;
          SOLARCHVISION_Y_click1 = pmouseY;

          dragging_started = 1;
        }
      } else if (WIN3D.include) {
        if (isInside(pmouseX, pmouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {
          if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

            if (dragging_started == 0) {

              SOLARCHVISION_X_click1 = pmouseX;
              SOLARCHVISION_Y_click1 = pmouseY;

              dragging_started = 1;
            }

            float dx = (mouseX - pmouseX) / float(WIN3D.dX);
            float dy = (mouseY - pmouseY) / float(WIN3D.dY);

            if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraLandOrbit

                WIN3D.rotateXY_3DViewport_around_LandIntersection(10 * dx * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }
            } 

            if ((WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }
            } 

            if ((WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll) || (WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }      

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.RZ_Coordinate += 10 * dx * WIN3D.RS_Coordinate; 
                WIN3D.RX_Coordinate += 10 * dy * WIN3D.RS_Coordinate;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }            

            if ((WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRoll

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.RS_Coordinate);

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.RS_Coordinate);

                WIN3D.update = true;
              }
            }            

            if (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) { // viewport

              if (mouseButton == LEFT) { // TargetRoll

                WIN3D.RZ_Coordinate += 10 * dx * WIN3D.RS_Coordinate; 
                WIN3D.RX_Coordinate += 10 * dy * WIN3D.RS_Coordinate;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // TargetRollXY

                WIN3D.RZ_Coordinate += 10 * dx * WIN3D.RS_Coordinate; 

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // TargetRollZ

                WIN3D.RX_Coordinate += 10 * dy * WIN3D.RS_Coordinate;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }            

            if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) || (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) || (WIN3D.UI_CurrentTask == UITASK.AllModelSize)) { // viewport

              if (mouseButton == LEFT) { // orbit

                WIN3D.RZ_Coordinate -= 10 * dx * WIN3D.RS_Coordinate; 
                WIN3D.RX_Coordinate -= 10 * dy * WIN3D.RS_Coordinate;

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) { 

              if (mouseButton == LEFT) { // move Y

                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale;  

                WIN3D.update = true;
              }              

              if (mouseButton == RIGHT) { // move X

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  

                WIN3D.update = true;
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 

                WIN3D.update = true;
              }   

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.RZ_Coordinate += 10 * dx * WIN3D.RS_Coordinate; 
                WIN3D.RX_Coordinate += 10 * dy * WIN3D.RS_Coordinate;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions

              if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                  if (mouseButton == RIGHT) WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 
                  WIN3D.update = true;
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.X_Coordinate += 100 * dx * WIN3D.S_Coordinate * OBJECTS_scale;  
                  if (mouseButton == LEFT) WIN3D.Y_Coordinate += 100 * dy * WIN3D.S_Coordinate * OBJECTS_scale; 
                  WIN3D.update = true;
                }
              }


              if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.RX_Coordinate -= 10 * dy * WIN3D.RS_Coordinate;
                  if (mouseButton == RIGHT) WIN3D.RZ_Coordinate -= 10 * dx * WIN3D.RS_Coordinate;
                  WIN3D.update = true;
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.RX_Coordinate -= 10 * dy * WIN3D.RS_Coordinate;
                  if (mouseButton == LEFT) WIN3D.RZ_Coordinate -= 10 * dx * WIN3D.RS_Coordinate;
                  WIN3D.update = true;
                }
              }


              WIN3D.update = true;
            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_update_project_info (File selectedFile) {

  ProjectName = selectedFile.getName().replace(".xml", "").replace(".XML", "").replace(".Xml", ""); // should work most of the times!
  ProjectFolder =  selectedFile.getAbsolutePath().replace(char(92), '/').replace("/" + selectedFile.getName(), "");

  println("New ProjectName:", ProjectName);
  println("New ProjectFolder:", ProjectFolder);
}

void SOLARCHVISION_fileSelected_New (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("New project:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
}

void SOLARCHVISION_fileSelected_Open (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Loading:", Filename);

    SOLARCHVISION_load_project(Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
} 


void SOLARCHVISION_fileSelected_SaveAs (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Saving to:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);

    SOLARCHVISION_save_project(Filename, Display_Output_in_Explorer);
  }
}     



void SOLARCHVISION_SelectFile_Import_3DModel (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Importing:", Filename);

    int number_of_allGroups_before = allGroups.num;

    //SOLARCHVISION_import_objects_OBJ(Filename, -1,0,0,1,0,0, 0,0,0, 1,1,1); // different objects: different materials
    SOLARCHVISION_import_objects_OBJ(Filename, DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, 0, 0, 0, 1, 1, 1); // apply default material

    int number_of_allGroups_after = allGroups.num;

    selectedGroup_ids = new int [1 + number_of_allGroups_after - number_of_allGroups_before];
    for (int i = 0; i < selectedGroup_ids.length - 1; i++) { 
      selectedGroup_ids[i] = i + number_of_allGroups_before;
      //println(selectedGroup_ids[i]);
    }

    Current_ObjectCategory = ObjectCategory.GROUP;

    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D.update = true;
  }
}     


void SOLARCHVISION_SelectFile_Execute_CommandFile (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Executing:", Filename);

    SOLARCHVISION_execute_commands_TXT(Filename);

    WIN3D.update = true;
  }
} 


void mouseClicked () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_click_JPG) {

        SOLARCHVISION_RecordFrame();

        UI_dessin_Mouse(1, mouseX, mouseY, 2 * MessageSize);        

        SOLARCHVISION_RecordFrame();
        /*        
         WORLD.update = true;
         WIN3D.update = true;  
         STUDY.update = true;
         ROLLOUT.update = true;
         UI_BAR_a_update = true;
         UI_BAR_b_update = true;
         UI_BAR_d_update = true;          
         
         FRAME_click_JPG = 0;
         */
      }    


      if ((UI_BAR_a_selected_parent != -1) && (isInside(mouseX, mouseY, 0, 0, width, SOLARCHVISION_A_Pixel) == 0)) {

        if (mouseButton == LEFT) {
          if (UI_BAR_a_selected_child != 0) {

            // should call the functions here!

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Mojtaba Samimi")) { 
              link("http://solarchvision.com/?page_id=102");
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("www.solarchvision.com")) { 
              link("http://solarchvision.com/");
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("New")) { 
              
              /////////////////////////////
              SOLARCHVISION_hold_project();
              /////////////////////////////
              
              selectInput("Specify project name:", "SOLARCHVISION_fileSelected_New");

              SOLARCHVISION_delete_All();

              //SOLARCHVISION_update_station(0);
            }  

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Save")) { 
              SOLARCHVISION_save_project(ProjectFolder + "/" + ProjectName + ".xml", false);
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hold")) {
              
              SOLARCHVISION_hold_project();
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Fetch")) {
              
              SOLARCHVISION_fetch_project();
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Undo")) {
            }             

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Open...")) { 
              selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
            }          

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Save As...")) { 
              selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Import 3D-Model...")) { 
              selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Execute CommandFile...")) { 
              selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > OBJ (time-series)")) {
              SOLARCHVISION_export_objects_OBJ_timeSeries();
            } 
                        

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > OBJ (date-series)")) {
              SOLARCHVISION_export_objects_OBJ_dateSeries();
            } 
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > OBJ")) {
              SOLARCHVISION_export_objects_OBJ("");
            }    
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > HTML")) {
              SOLARCHVISION_export_objects_HTML();
            }              
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > RAD")) {
              SOLARCHVISION_export_objects_RAD();
            }
        
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Export 3D-Model > SCR")) {
              SOLARCHVISION_export_objects_SCR();
            }                

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Quit")) { 
              exit();
            }      



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Wind pattern (active)")) {
              STUDY.PlotImpacts = -2;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = true;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Wind pattern (passive)")) {
              STUDY.PlotImpacts = -1;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = true;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Urban solar potential (active)")) {
              STUDY.PlotImpacts = 0;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Urban solar potential (passive)")) {
              STUDY.PlotImpacts = 1;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Orientation potential (active)")) {
              STUDY.PlotImpacts = 2;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Orientation potential (passive)")) {
              STUDY.PlotImpacts = 3;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hourly sun position (active)")) {
              STUDY.PlotImpacts = 4;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hourly sun position (passive)")) {
              STUDY.PlotImpacts = 5;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("View from sun & sky (active)")) {
              STUDY.PlotImpacts = 6;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("View from sun & sky (passive)")) {
              STUDY.PlotImpacts = 7;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Annual cycle sun path (active)")) {
              STUDY.PlotImpacts = 8;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Annual cycle sun path (passive)")) {
              STUDY.PlotImpacts = 9;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              Display_WindRoseImage = false;
              ROLLOUT.update = true;
            }  

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pre-bake Selected allSections")) {
              SOLARCHVISION_render_Shadows_selectedallSections();              
              WIN3D.update = true;
            }         

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Process Active Impact")) {
              STUDY.PlotImpacts = 0;         
              SOLARCHVISION_calculate_SolarImpact_selectedallSections();              
              WIN3D.update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Process Passive Impact")) {
              STUDY.PlotImpacts = 1;         
              SOLARCHVISION_calculate_SolarImpact_selectedallSections();              
              WIN3D.update = true;
            }               

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Process Solid Impact")) {
              SOLARCHVISION_calculate_SolidImpact_selectedallSections();              
              WIN3D.update = true;
            }  

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Run wind 3D-model")) {
              SOLARCHVISION_calculate_WindFlow();              
              WIN3D.update = true;
            }  

            for (int n = -2; n <= 14; n++) { 
              if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Layout " + nf(n, 0))) {

                STUDY.plotSetup = n;
                STUDY.update = true;

                if (STUDY.plotSetup == 14) {
                } else {  

                  if (FrameVariation != 2) {
                    FrameVariation = 2;
                    SOLARCHVISION_update_frame_layout();
                  }
                }
              }
            }




            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Stop REC.")) { 
              STUDY.record_AUTO = false;
              STUDY.record_JPG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_JPG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_JPG = false;
              FRAME_record_AUTO = false;
              FRAME_record_JPG = false;
              FRAME_click_JPG = false;
              FRAME_drag_JPG = false;   

              ROLLOUT.update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("REC. Time Graph")) { 
              STUDY.record_AUTO = true;
              STUDY.record_JPG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_JPG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_JPG = false;
              FRAME_record_AUTO = false;
              FRAME_record_JPG = false;
              FRAME_click_JPG = false;
              FRAME_drag_JPG = false;   

              ROLLOUT.update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("REC. Location Graph")) { 
              STUDY.record_AUTO = false;
              STUDY.record_JPG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = true;
              WORLD.record_JPG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_JPG = false;
              FRAME_record_AUTO = false;
              FRAME_record_JPG = false;
              FRAME_click_JPG = false;
              FRAME_drag_JPG = false;   

              ROLLOUT.update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("REC. Solid Graph")) { 
              STUDY.record_AUTO = false;
              STUDY.record_JPG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_JPG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = true;
              WIN3D.record_JPG = false;
              FRAME_record_AUTO = false;
              FRAME_record_JPG = false;
              FRAME_click_JPG = false;
              FRAME_drag_JPG = false;   

              ROLLOUT.update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("REC. Screenshot")) { 
              STUDY.record_AUTO = false;
              STUDY.record_JPG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_JPG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_JPG = false;
              FRAME_record_AUTO = true;
              FRAME_record_JPG = false;
              FRAME_click_JPG = false;
              FRAME_drag_JPG = false;   

              ROLLOUT.update = true;
            }             

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PDF Time Graph")) { 
              STUDY.record_PDF = true;
              STUDY.update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("JPG Time Graph")) { 
              STUDY.record_JPG = true;
              STUDY.update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("JPG Location Graph")) { 
              WORLD.record_JPG = true;
              WORLD.update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PDF Location Graph")) { 
              WORLD.record_PDF = true;
              WORLD.update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("JPG 3D Graph")) { 
              WIN3D.record_JPG = true;
              WIN3D.update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Screenshot")) { 
              FRAME_record_JPG = true;
            }             

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Screenshot+Click")) { 
              FRAME_click_JPG = true;
            }           

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Screenshot+Drag")) { 
              FRAME_drag_JPG = true;
            }                

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update Station")) { 
              SOLARCHVISION_update_station(0);
            }
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Load Land Mesh")) { 
              Land3D.update_textures();
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Load Land Texture")) { 
              Land3D.update_textures();
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download Land Mesh")) { 
              Land3D.download_mesh();
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download Land Texture")) { 
              Land3D.download_textures();
            }   
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download Toroposphere")) {
              Tropo3D.download_images();
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download Aerial")) {
              SOLARCHVISION_download_AERIAL(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download NAEFS")) {
              download_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download CLMREC")) {
              download_CLIMATE_CLMREC();
            }                      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Download SWOB")) {
              download_ENSEMBLE_OBSERVED();
            }            
            
            
            


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update TMYEPW")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;
              
              CLIMATE_TMYEPW_load = true;
              update_CLIMATE_TMYEPW();
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update CWEEDS")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;
              
              CLIMATE_CWEEDS_load = true;
              update_CLIMATE_CWEEDS();
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update CLMREC")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;
              
              CLIMATE_CLMREC_load = true;
              update_CLIMATE_CLMREC();
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update SWOB")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;
              
              ENSEMBLE_OBSERVED_load = true;
              SOLARCHVISION_update_ENSEMBLE_OBSERVED();
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update NAEFS")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              
              ENSEMBLE_FORECAST_load = true;
              update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("update Aerial")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              
              ENSEMBLE_FORECAST_load = true;
              SOLARCHVISION_load_AERIAL(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
            }      
   
        
            
            
            
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Typical Year (TMY)")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d_update = true;    

              Display_TMYEPW_Points = 1;
              Display_TMYEPW_Nearest = true;  
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Long-term (CWEEDS)")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d_update = true;    

              Display_CWEEDS_Points = 1;
              Display_CWEEDS_Nearest = true;                
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Long-term (CLMREC)")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d_update = true; 

              Display_CLMREC_Points = 1;
              Display_CLMREC_Nearest = true;   
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Real-time Observed (SWOB)")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d_update = true;      
  
              Display_SWOB_Points = 1;
              Display_SWOB_Nearest = true;             
            }                  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Weather Forecast (NAEFS)")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d_update = true;     
 
              Display_NAEFS_Points = 1;
              Display_NAEFS_Nearest = true;                 
            } 
     
            


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][0].equals("Layers")) {
              if (UI_BAR_a_selected_child > 0) {
                if (CurrentLayer_id != UI_BAR_a_selected_child - 1) {

                  if (UI_BAR_a_selected_child < numberOfLayers) {

                    changeCurrentLayerTo(UI_BAR_a_selected_child - 1);

                    DevelopLayer_id = CurrentLayer_id;

                    STUDY.update = true;
                  } else {

                    if ((Develop_Option == DEV_OP_06) || (Develop_Option == DEV_OP_07) || (Develop_Option == DEV_OP_08)) {

                      if (CurrentLayer_id == DevelopLayer_id) {

                        changeCurrentLayerTo(LAYER_developed.id);
                      }

                      Develop_Option = UI_BAR_a_selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);   

                      STUDY.update = true;
                    } else {

                      DevelopLayer_id = CurrentLayer_id;

                      changeCurrentLayerTo(LAYER_developed.id); 

                      Develop_Option = UI_BAR_a_selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);   

                      STUDY.update = true;
                    }
                  }
                }
              }
            }            



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Surface Wire")) {
              WIN3D.FacesShade = SHADE.Surface_Wire;
              allModel3Ds.DisplayEdges = true; //<<<<<<<<<<<<<<<

              WIN3D.update = true;  
            }       
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Surface Base")) {
              WIN3D.FacesShade = SHADE.Surface_Base;
              WIN3D.update = true;  
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Surface White")) {
              WIN3D.FacesShade = SHADE.Surface_White;
              WIN3D.update = true;  
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Surface Materials")) {
              WIN3D.FacesShade = SHADE.Surface_Materials;
              WIN3D.update = true;  
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Global Solar")) {
              WIN3D.FacesShade = SHADE.Global_Solar;
              WIN3D.update = true;  
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Vertex Solar")) {
              WIN3D.FacesShade = SHADE.Vertex_Solar;
              WIN3D.update = true;  
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Vertex Solid")) {
              WIN3D.FacesShade = SHADE.Vertex_Solid;
              WIN3D.update = true;  
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Shade Vertex Elevation")) {
              WIN3D.FacesShade = SHADE.Vertex_Elevation;
              WIN3D.update = true;  
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Render Viewport")) {
              
              SOLARCHVISION_RenderViewport();            
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PreBake Viewport")) {
              
              SOLARCHVISION_PreBakeViewport();            
            }           
            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Land Mesh")) {
              Land3D.Display_Surface = !Land3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Land Texture")) {
              Land3D.Display_Textures = !Land3D.Display_Textures;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }       
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Land Points")) {
              Land3D.Display_Points = !Land3D.Display_Points;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Land Depth")) {
              Land3D.Display_Depth = !Land3D.Display_Depth;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Vertices")) {
              allModel3Ds.DisplayVertices = !allModel3Ds.DisplayVertices;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Edges")) {
              allModel3Ds.DisplayEdges = !allModel3Ds.DisplayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Normals")) {
              allModel3Ds.DisplayNormals = !allModel3Ds.DisplayNormals;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Leaves")) {
              Display_Leaves = !Display_Leaves;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide allModel2Ds Objects")) {
              Display_allModel2Ds = !Display_allModel2Ds;
              Display_allModel1Ds = Display_allModel2Ds; // <<<<<<<
              Display_Leaves = Display_allModel1Ds; // <<<<<<

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Building Objects")) {
              Display_allModel3Ds = !Display_allModel3Ds;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide allSolids")) {
              Display_allSolids = !Display_allSolids;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide allSections")) {
              Display_allSections = !Display_allSections;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide allCameras")) {
              Display_allCameras = !Display_allCameras;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Sky")) {
              Sky3D.Display_Surface = !Sky3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Sun Path")) {
              Display_SUN_Path = !Display_SUN_Path;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Sun Pattern")) {
              Display_SUN_Pattern = !Display_SUN_Pattern;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Star")) {
              Star3D.Display_Surface = !Star3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Moon")) {
              Moon3D.Display_Surface = !Moon3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Earth")) {
              Earth3D.Display_Surface = !Earth3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Troposphere")) {
              Tropo3D.Display_Surface = !Tropo3D.Display_Surface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Solar Section")) {
              Display_SolarImpactImage = !Display_SolarImpactImage;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Solid Section")) {
              Display_SolidImpactImage = !Display_SolidImpactImage;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected allSolids")) {
              selectedSolid_displayEdges = !selectedSolid_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected allSections")) {
              selectedSection_displayEdges = !selectedSection_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected allCameras")) {
              selectedCamera_displayEdges = !selectedCamera_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected LandPoints")) {
              selectedLandPoint_displayPoints = !selectedLandPoint_displayPoints;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Wind Flow")) {
              Display_WindFlow = !Display_WindFlow;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Faces")) {
              selectedFace_displayEdges = !selectedFace_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Faces Vertex Count")) {
              selectedFace_displayVertexCount = !selectedFace_displayVertexCount;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Curves Vertex Count")) {
              selectedCurve_displayVertexCount = !selectedCurve_displayVertexCount;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Vertices")) {
              selectedVertex_displayVertices = !selectedVertex_displayVertices;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Curves")) {
              selectedCurve_displayVertices = !selectedCurve_displayVertices;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected REF Pivot")) {
              selected_displayReferencePivot = !selected_displayReferencePivot;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }        
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Group Pivot")) {
              selectedGroup_displayPivot = !selectedGroup_displayPivot;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Group Edges")) {
              selectedGroup_displayEdges = !selectedGroup_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected Group Box")) {
              selectedGroup_displayBox = !selectedGroup_displayBox;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected 2½D Edges")) {
              selectedallModel2Ds_displayEdges = !selectedallModel2Ds_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide Selected ∞-D Edges")) {
              selectedallModel1Ds_displayEdges = !selectedallModel1Ds_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }              

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide SWOB points")) {
              Display_SWOB_Points = (Display_SWOB_Points + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide SWOB nearest")) {
              Display_SWOB_Nearest = !Display_SWOB_Nearest;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide NAEFS points")) {
              Display_NAEFS_Points = (Display_NAEFS_Points + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide NAEFS nearest")) {
              Display_NAEFS_Nearest = !Display_NAEFS_Nearest;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide CWEEDS points")) {
              Display_CWEEDS_Points = (Display_CWEEDS_Points + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide CWEEDS nearest")) {
              Display_CWEEDS_Nearest = !Display_CWEEDS_Nearest;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide CLMREC points")) {
              Display_CLMREC_Points = (Display_CLMREC_Points + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide CLMREC nearest")) {
              Display_CLMREC_Nearest = !Display_CLMREC_Nearest;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide TMYEPW points")) {
              Display_TMYEPW_Points = (Display_TMYEPW_Points + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display/Hide TMYEPW nearest")) {
              Display_TMYEPW_Nearest = !Display_TMYEPW_Nearest;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("allModel1Ds")) {
              UI_set_to_Create_allModel1Ds();
              SOLARCHVISION_highlight_in_BAR_b("allModel1Ds");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Tree")) {
              UI_set_to_Create_Tree();
              SOLARCHVISION_highlight_in_BAR_b("Tree");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Person")) {
              UI_set_to_Create_Person();
              SOLARCHVISION_highlight_in_BAR_b("Person");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Point")) {
              UI_set_to_Create_Vertex();
              SOLARCHVISION_highlight_in_BAR_b("Point");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Spline")) {
              UI_set_to_Create_Curve();
              SOLARCHVISION_highlight_in_BAR_b("Spline");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Surface")) {
              UI_set_to_Create_Face();
              SOLARCHVISION_highlight_in_BAR_b("Surface");
              UI_BAR_b_update = true;
            }

            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 1")) {
              UI_set_to_Create_Parametric(1);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 2")) {
              UI_set_to_Create_Parametric(2);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 3")) {
              UI_set_to_Create_Parametric(3);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 4")) {
              UI_set_to_Create_Parametric(4);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 5")) {
              UI_set_to_Create_Parametric(5);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 6")) {
              UI_set_to_Create_Parametric(6);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Parametric 7")) {
              UI_set_to_Create_Parametric(7);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Tri")) {
              UI_set_to_Create_Tri();
              SOLARCHVISION_highlight_in_BAR_b("Tri");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Plane")) {
              UI_set_to_Create_Plane();
              SOLARCHVISION_highlight_in_BAR_b("Plane");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Poly")) {
              UI_set_to_Create_Poly();
              SOLARCHVISION_highlight_in_BAR_b("Poly");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Extrude")) {
              UI_set_to_Create_Extrude();
              SOLARCHVISION_highlight_in_BAR_b("Extrude");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hyper")) {
              UI_set_to_Create_Hyper();
              SOLARCHVISION_highlight_in_BAR_b("Hyper");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("House1")) {
              UI_set_to_Create_House1();
              SOLARCHVISION_highlight_in_BAR_b("House1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("House2")) {
              UI_set_to_Create_House2();
              SOLARCHVISION_highlight_in_BAR_b("House2");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Box")) {
              UI_set_to_Create_Box();
              SOLARCHVISION_highlight_in_BAR_b("Box");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Icosahedron")) {
              UI_set_to_Create_Icosahedron();
              SOLARCHVISION_highlight_in_BAR_b("Icosahedron");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Octahedron")) {
              UI_set_to_Create_Octahedron();
              SOLARCHVISION_highlight_in_BAR_b("Octahedron");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Sphere")) {
              UI_set_to_Create_Sphere();
              SOLARCHVISION_highlight_in_BAR_b("Sphere");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Cylinder")) {
              UI_set_to_Create_Cylinder();
              SOLARCHVISION_highlight_in_BAR_b("Cylinder");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Cushion")) {
              UI_set_to_Create_Cushion();
              SOLARCHVISION_highlight_in_BAR_b("Cushion");
              UI_BAR_b_update = true;
            }



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Drop on LandSurface")) {
              UI_set_to_Modify_Drop(0);
              SOLARCHVISION_highlight_in_BAR_b("DrL±");
              UI_BAR_b_update = true;  

              SOLARCHVISION_drop_Selection();
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Drop on ModelSurface (Down)")) {
              UI_set_to_Modify_Drop(1);
              SOLARCHVISION_highlight_in_BAR_b("DrM-");
              UI_BAR_b_update = true;  

              SOLARCHVISION_drop_Selection(); 
              WIN3D.update = true;
            }                      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Drop on ModelSurface (Up)")) {
              UI_set_to_Modify_Drop(2);
              SOLARCHVISION_highlight_in_BAR_b("DrM+");
              UI_BAR_b_update = true;  

              SOLARCHVISION_drop_Selection();
              WIN3D.update = true;
            }



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get dX")) {
              UI_set_to_Modify_GetLength(0);
              SOLARCHVISION_highlight_in_BAR_b("GLx");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get dY")) {
              UI_set_to_Modify_GetLength(1);
              SOLARCHVISION_highlight_in_BAR_b("GLy");
              UI_BAR_b_update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get dZ")) {
              UI_set_to_Modify_GetLength(2);
              SOLARCHVISION_highlight_in_BAR_b("GLz");
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get dXYZ")) {
              UI_set_to_Modify_GetLength(3);
              SOLARCHVISION_highlight_in_BAR_b("GL³");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get dXY")) {
              UI_set_to_Modify_GetLength(4);
              SOLARCHVISION_highlight_in_BAR_b("GL²");
              UI_BAR_b_update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get Angle")) {
              UI_set_to_Modify_GetLength(5);
              SOLARCHVISION_highlight_in_BAR_b("GLa");
              UI_BAR_b_update = true;
            }               


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("MoveX")) {
              UI_set_to_Modify_Move(0);
              SOLARCHVISION_highlight_in_BAR_b("MVx");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("MoveY")) {
              UI_set_to_Modify_Move(1);
              SOLARCHVISION_highlight_in_BAR_b("MVy");
              UI_BAR_b_update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("MoveZ")) {
              UI_set_to_Modify_Move(2);
              SOLARCHVISION_highlight_in_BAR_b("MVz");
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Move")) {
              UI_set_to_Modify_Move(3);
              SOLARCHVISION_highlight_in_BAR_b("MV³");
              UI_BAR_b_update = true;
            }


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ScaleX")) {
              UI_set_to_Modify_Scale(0);
              SOLARCHVISION_highlight_in_BAR_b("SCx");
              UI_BAR_b_update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ScaleY")) {
              UI_set_to_Modify_Scale(1);
              SOLARCHVISION_highlight_in_BAR_b("SCy");
              UI_BAR_b_update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ScaleZ")) {
              UI_set_to_Modify_Scale(2);
              SOLARCHVISION_highlight_in_BAR_b("SCz");
              UI_BAR_b_update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Scale")) {
              UI_set_to_Modify_Scale(3);
              SOLARCHVISION_highlight_in_BAR_b("SC³");
              UI_BAR_b_update = true;
            }


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PowerX")) {
              UI_set_to_Modify_Power(0);
              SOLARCHVISION_highlight_in_BAR_b("PWx");
              UI_BAR_b_update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PowerY")) {
              UI_set_to_Modify_Power(1);
              SOLARCHVISION_highlight_in_BAR_b("PWy");
              UI_BAR_b_update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PowerZ")) {
              UI_set_to_Modify_Power(2);
              SOLARCHVISION_highlight_in_BAR_b("PWz");
              UI_BAR_b_update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Power")) {
              UI_set_to_Modify_Power(3);
              SOLARCHVISION_highlight_in_BAR_b("PW³");
              UI_BAR_b_update = true;
            }


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("RotateX")) {
              UI_set_to_Modify_Rotate(0);
              SOLARCHVISION_highlight_in_BAR_b("RTx");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("RotateY")) {
              UI_set_to_Modify_Rotate(1);
              SOLARCHVISION_highlight_in_BAR_b("RTy");
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("RotateZ")) {
              UI_set_to_Modify_Rotate(2);
              SOLARCHVISION_highlight_in_BAR_b("RTz");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Rotate")) {
              UI_set_to_Modify_Rotate(2);
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pivot")) {
              UI_set_to_Modify_Pivot(0);
              SOLARCHVISION_highlight_in_BAR_b("SPvt0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Pivot")) {
              UI_set_to_Modify_Pivot(1);
              SOLARCHVISION_highlight_in_BAR_b("SPvt1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Pivot")) {
              UI_set_to_Modify_Pivot(2);
              SOLARCHVISION_highlight_in_BAR_b("SPvt2");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Save Current ReferenceBox")) {
              SOLARCHVISION_save_current_BoundingBox();
              SOLARCHVISION_highlight_in_BAR_b("<pvt>");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Reset Saved ReferenceBox")) {
              SOLARCHVISION_apply_saved_ReferenceBox();
              SOLARCHVISION_highlight_in_BAR_b(">pvt<");
              UI_BAR_b_update = true;  
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Use Selection ReferenceBox")) {
              SOLARCHVISION_calculate_selection_BoundingBox();
              SOLARCHVISION_highlight_in_BAR_b("|pvt|");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Use Origin ReferenceBox")) {
              SOLARCHVISION_apply_origin_ReferenceBox();
              SOLARCHVISION_highlight_in_BAR_b(".pvt.");
              UI_BAR_b_update = true;  
              WIN3D.update = true;
            }



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Begin New Group at Origin")) {
              
              allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

              selectedGroup_ids = new int [1];
              selectedGroup_ids[0] = allGroups.num - 1;

              WIN3D.update = true;
            }    

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Begin New Group at Pivot")) {

              allModel3Ds.beginNewGroup(SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][1], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][2], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][4], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][5], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][7], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][8]);

              selectedGroup_ids = new int [1];
              selectedGroup_ids[0] = allGroups.num - 1;       

              WIN3D.update = true;
            }              

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Solid")) {
              UI_set_to_Create_Solid();
              SOLARCHVISION_highlight_in_BAR_b("SLD");
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Section")) {
              UI_set_to_Create_Section();
              SOLARCHVISION_highlight_in_BAR_b("SEC");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Camera")) {
              UI_set_to_Create_Camera();
              SOLARCHVISION_highlight_in_BAR_b("CAM");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Viewport >> Camera")) {

              float Camera_X = WIN3D.X_Coordinate;
              float Camera_Y = WIN3D.Y_Coordinate;
              float Camera_Z = WIN3D.Z_Coordinate;
              float Camera_S = WIN3D.S_Coordinate;
              float Camera_RX = WIN3D.RX_Coordinate;
              float Camera_RY = WIN3D.RY_Coordinate;
              float Camera_RZ = WIN3D.RZ_Coordinate;
              float Camera_ZOOM = WIN3D.Zoom;

              int Camera_Type = WIN3D.ViewType;

              allModel3Ds.add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

              WIN3D.CurrentCamera = allCameras.num - 1;
              WIN3D.apply_currentCamera();
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D.update = true;   
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Camera >> Viewport")) {

              allCameras.PPPSRRRF[0][0] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][0];
              allCameras.PPPSRRRF[0][1] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][1];
              allCameras.PPPSRRRF[0][2] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][2];
              allCameras.PPPSRRRF[0][3] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][3];
              allCameras.PPPSRRRF[0][4] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][4];
              allCameras.PPPSRRRF[0][5] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][5];
              allCameras.PPPSRRRF[0][6] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][6];
              allCameras.PPPSRRRF[0][7] = allCameras.PPPSRRRF[WIN3D.CurrentCamera][7];

              allCameras.Type[0] = allCameras.Type[WIN3D.CurrentCamera];

              WIN3D.CurrentCamera = 0;
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D.update = true;   
              UI_BAR_b_update = true;
            }  

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("GoTo Selected Camera")) {
              if (selectedCamera_ids.length > 0) {
                WIN3D.CurrentCamera = selectedCamera_ids[selectedCamera_ids.length - 1];
                WIN3D.apply_currentCamera();
                SOLARCHVISION_modify_Viewport_Title();
  
                WIN3D.update = true;   
                UI_BAR_b_update = true;
              }
            }
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("LandMesh >> Group")) {
              Land3D.draw(TypeWindow.LandMesh);
              
              WIN3D.update = true;   
            }          
          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("LandGap >> Group")) {
              Land3D.draw(TypeWindow.LandGap);

              WIN3D.update = true;   
            }                



            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change Seed/Material")) {
              UI_set_to_Modify_Seed(0);
              SOLARCHVISION_highlight_in_BAR_b("Mat0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Seed/Material")) {
              UI_set_to_Modify_Seed(1);
              SOLARCHVISION_highlight_in_BAR_b("Mat1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Seed/Material")) {
              UI_set_to_Modify_Seed(2);
              SOLARCHVISION_highlight_in_BAR_b("Mat2");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change Tessellation")) {
              UI_set_to_Modify_Tessellation(0);
              SOLARCHVISION_highlight_in_BAR_b("Tes0");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Tessellation")) {
              UI_set_to_Modify_Tessellation(1);
              SOLARCHVISION_highlight_in_BAR_b("Tes1");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Tessellation")) {
              UI_set_to_Modify_Tessellation(2);
              SOLARCHVISION_highlight_in_BAR_b("Tes2");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change Layer")) {
              UI_set_to_Modify_Layer(0);
              SOLARCHVISION_highlight_in_BAR_b("Lyr0");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Layer")) {
              UI_set_to_Modify_Layer(1);
              SOLARCHVISION_highlight_in_BAR_b("Lyr1");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Layer")) {
              UI_set_to_Modify_Layer(2);
              SOLARCHVISION_highlight_in_BAR_b("Lyr2");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change Visibility")) {
              UI_set_to_Modify_Visibility(0);
              SOLARCHVISION_highlight_in_BAR_b("Vsb0");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Visibility")) {
              UI_set_to_Modify_Visibility(1);
              SOLARCHVISION_highlight_in_BAR_b("Vsb1");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Visibility")) {
              UI_set_to_Modify_Visibility(2);
              SOLARCHVISION_highlight_in_BAR_b("Vsb2");
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change Weight")) {
              UI_set_to_Modify_Weight(0);
              SOLARCHVISION_highlight_in_BAR_b("Wgt0");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick Weight")) {
              UI_set_to_Modify_Weight(1);
              SOLARCHVISION_highlight_in_BAR_b("Wgt1");
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign Weight")) {
              UI_set_to_Modify_Weight(2);
              SOLARCHVISION_highlight_in_BAR_b("Wgt2");
              UI_BAR_b_update = true;
            } 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Flip Normal")) {
              UI_set_to_Modify_Normal(1);
              SOLARCHVISION_highlight_in_BAR_b("Norm1");
              UI_BAR_b_update = true;
            }                

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Set-Out Normal")) {
              UI_set_to_Modify_Normal(2);
              SOLARCHVISION_highlight_in_BAR_b("Norm2");
              UI_BAR_b_update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Set-In Normal")) {
              UI_set_to_Modify_Normal(3);
              SOLARCHVISION_highlight_in_BAR_b("Norm3");
              UI_BAR_b_update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Get FirstVertex")) {
              UI_set_to_Modify_FirstVertex(1);
              SOLARCHVISION_highlight_in_BAR_b("1stV");
              UI_BAR_b_update = true;
            }     
            


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMax0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick DegreeMax")) {
              UI_set_to_Modify_DegreeMax(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMax1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign DegreeMax")) {
              UI_set_to_Modify_DegreeMax(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMax2");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeDif")) {
              UI_set_to_Modify_DegreeDif(0);
              SOLARCHVISION_highlight_in_BAR_b("dgDif0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick DegreeDif")) {
              UI_set_to_Modify_DegreeDif(1);
              SOLARCHVISION_highlight_in_BAR_b("dgDif1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign DegreeDif")) {
              UI_set_to_Modify_DegreeDif(2);
              SOLARCHVISION_highlight_in_BAR_b("dgDif2");
              UI_BAR_b_update = true;
            }                 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeMin")) {
              UI_set_to_Modify_DegreeMin(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMin0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick DegreeMin")) {
              UI_set_to_Modify_DegreeMin(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMin1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign DegreeMin")) {
              UI_set_to_Modify_DegreeMin(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMin2");
              UI_BAR_b_update = true;
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
              SOLARCHVISION_highlight_in_BAR_b("trSz0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick TrunkSize")) {
              UI_set_to_Modify_TrunkSize(1);
              SOLARCHVISION_highlight_in_BAR_b("trSz1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign TrunkSize")) {
              UI_set_to_Modify_TrunkSize(2);
              SOLARCHVISION_highlight_in_BAR_b("trSz2");
              UI_BAR_b_update = true;
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
              SOLARCHVISION_highlight_in_BAR_b("lfSz0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick LeafSize")) {
              UI_set_to_Modify_LeafSize(1);
              SOLARCHVISION_highlight_in_BAR_b("lfSz1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign LeafSize")) {
              UI_set_to_Modify_LeafSize(2);
              SOLARCHVISION_highlight_in_BAR_b("lfSz2");
              UI_BAR_b_update = true;
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("AllallModel1DsProps")) {
              UI_set_to_Modify_AllallModel1DsProps(0);
              SOLARCHVISION_highlight_in_BAR_b("allFP0");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pick AllallModel1DsProps")) {
              UI_set_to_Modify_AllallModel1DsProps(1);
              SOLARCHVISION_highlight_in_BAR_b("allFP1");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Assign AllallModel1DsProps")) {
              UI_set_to_Modify_AllallModel1DsProps(2);
              SOLARCHVISION_highlight_in_BAR_b("allFP2");
              UI_BAR_b_update = true;
            }                 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeDif")) {
              UI_set_to_Modify_DegreeDif(0);
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change DegreeMin")) {
              UI_set_to_Modify_DegreeMin(0);
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
            }           


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Orthographic")) {
              UI_set_to_View_ProjectionType(0);
              SOLARCHVISION_highlight_in_BAR_b("P<>");
              UI_BAR_b_update = true;
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Perspective")) {
              UI_set_to_View_ProjectionType(1);
              SOLARCHVISION_highlight_in_BAR_b("P><");
              UI_BAR_b_update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Reverse Selection")) {
              allModel3Ds.reverse_Selection();
              WIN3D.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Deselect All")) {
              allModel3Ds.deselect_All();
              WIN3D.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select All")) {
              allModel3Ds.select_All();
              WIN3D.update = true;
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Solid")) {
              Current_ObjectCategory = ObjectCategory.SOLID;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }                 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Section")) {
              Current_ObjectCategory = ObjectCategory.SECTION;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }       
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Camera")) {
              Current_ObjectCategory = ObjectCategory.CAMERA;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select LandPoint")) {
              Current_ObjectCategory = ObjectCategory.LANDPOINT;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select allModel1Ds")) {
              Current_ObjectCategory = ObjectCategory.MODEL1D;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select allModel2Ds")) {
              Current_ObjectCategory = ObjectCategory.MODEL2D;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Group")) {
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Face")) {
              Current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Curve")) {
              Current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Vertex")) {
              Current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Soft Selection")) {
              allModel3Ds.convert_Vertex_to_softSelection();

              Current_ObjectCategory = ObjectCategory.SOFTVERTEX;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }                 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Vertex >> Group")) {
              allModel3Ds.convert_Vertices_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Face >> Group")) {
              allModel3Ds.convert_Faces_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> Face")) {
              allModel3Ds.convert_allGroups_to_Faces();
              Current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Curve >> Group")) {
              allModel3Ds.convert_Curves_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> Curve")) {
              allModel3Ds.convert_allGroups_to_Curves();
              Current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Curve >> Vertex")) {
              allModel3Ds.convert_Curves_to_Vertices();
              Current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Vertex >> Curve")) {
              allModel3Ds.convert_Vertices_to_Curves();
              Current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }               
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> Vertex")) {
              allModel3Ds.convert_allGroups_to_Vertices();
              Current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Face >> Vertex")) {
              allModel3Ds.convert_Faces_to_Vertices();
              Current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Vertex >> Face")) {
              allModel3Ds.convert_Vertices_to_Faces();
              Current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Solid >> Group")) {
              allModel3Ds.convert_allSolids_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> Solid")) {
              allModel3Ds.convert_allGroups_to_allSolids();
              Current_ObjectCategory = ObjectCategory.SOLID;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }                
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("allModel2Ds >> Group")) {
              allModel3Ds.convert_allModel2Ds_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> allModel2Ds")) {
              allModel3Ds.convert_allGroups_to_allModel2Ds();
              Current_ObjectCategory = ObjectCategory.MODEL2D;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("allModel1Ds >> Group")) {
              allModel3Ds.convert_allModel1Ds_to_allGroups();
              Current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group >> allModel1Ds")) {
              allModel3Ds.convert_allGroups_to_allModel1Ds();
              Current_ObjectCategory = ObjectCategory.MODEL1D;
              WIN3D.update = true;
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Click Select")) {
              UI_set_to_View_ClickSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±CS");
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Click Select+")) {
              UI_set_to_View_ClickSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+CS");
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Click Select-")) {
              UI_set_to_View_ClickSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-CS");
              UI_BAR_b_update = true;
            }            

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Window Select")) {
              UI_set_to_View_WindowSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±WS");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Window Select+")) {
              UI_set_to_View_WindowSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+WS");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Window Select-")) {
              UI_set_to_View_WindowSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-WS");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select Near Vertices Selection")) {
              allModel3Ds.selectNearVertices_Selection();
              WIN3D.update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Weld Objects Vertices Selection")) {
              allModel3Ds.weldObjectsVertices_Selection(ModifyInput_WeldTreshold);
              WIN3D.update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Weld Scene Vertices Selection")) {
              allModel3Ds.weldSceneVertices_Selection(ModifyInput_WeldTreshold);
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Reposition Vertices Selection")) {
              allModel3Ds.repositionVertices_Selection();
              WIN3D.update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Separate Vertices Selection")) {
              allModel3Ds.separateVertices_Selection();
              WIN3D.update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Select All Isolated Vertices")) {
              allModel3Ds.selectIsolatedVertices_Scene();
              WIN3D.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Delete All Isolated Vertices")) {
              allModel3Ds.deleteIsolatedVertices_Scene();
              WIN3D.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Delete Isolated Vertices Selection")) {
              allModel3Ds.deleteIsolatedVertices_Selection();
              WIN3D.update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Delete All Empty allGroups")) {
              allModel3Ds.deleteEmptyallGroups_Scene();
              WIN3D.update = true;
            }               
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Delete Selection")) {
              allModel3Ds.delete_Selection();
              WIN3D.update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Dettach from allGroups")) {
              allModel3Ds.dettachFromallGroups_Selection();
              WIN3D.update = true;
            }                
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Ungroup Selection")) {
              allModel3Ds.ungroup_Selection();
              WIN3D.update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Group Selection")) {
              allModel3Ds.group_Selection(1);
              WIN3D.update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Attach to Last Group")) {
              allModel3Ds.group_Selection(0);
              WIN3D.update = true;
            }                 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Duplicate Selection (Identical)")) {
              allModel3Ds.duplicate_Selection(0);
              WIN3D.update = true;
            }      
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Duplicate Selection (Variation)")) {
              allModel3Ds.duplicate_Selection(1);
              WIN3D.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Auto-Normal Faces Selection")) {
              allModel3Ds.autoNormalFaces_Selection();
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Force Triangulate Faces Selection")) {
              allModel3Ds.forceTriangulateFaces_Selection();
              WIN3D.update = true;
            }            
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Insert Corner Opennings")) {
              allModel3Ds.insertCornerOpennings_Selection();
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Insert Parallel Opennings")) {
              allModel3Ds.insertParallelOpennings_Selection();              
              WIN3D.update = true;
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Insert Rotated Opennings")) {
              allModel3Ds.insertRotatedOpennings_Selection();
              WIN3D.update = true;
            }       
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Insert Edge Opennings")) {
              allModel3Ds.insertEdgeOpennings_Selection();
              WIN3D.update = true;
            } 
            
 

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Tessellate Rows & Columns")) {
              allModel3Ds.tessellateRowsColumnsFaceSelection();
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Tessellate Rectangular")) {
              allModel3Ds.tessellateRectangularFaceSelection();
              WIN3D.update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Tessellation Triangular")) {
              allModel3Ds.tessellateTriangularFaceSelection();
              WIN3D.update = true;
            }            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Extrude Face Edges")) {
              allModel3Ds.extrudeFaceEdges_Selection();
              WIN3D.update = true;
            }    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Extrude Curve Edges")) {
              allModel3Ds.extrudeCurveEdges_Selection();
              WIN3D.update = true;
            }                
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Offset(above) Vertices")) {
              allModel3Ds.offsetVertices_Selection(0, abs(ModifyInput_OffsetAmount));
              WIN3D.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Offset(below) Vertices")) {
              allModel3Ds.offsetVertices_Selection(0, -abs(ModifyInput_OffsetAmount));
              WIN3D.update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Offset(expand) Vertices")) {
              allModel3Ds.offsetVertices_Selection(1, -abs(ModifyInput_OffsetAmount));
              WIN3D.update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Offset(shrink) Vertices")) {
              allModel3Ds.offsetVertices_Selection(1, abs(ModifyInput_OffsetAmount));
              WIN3D.update = true;
            }               

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Reverse Visibility of All Faces")) {
              allModel3Ds.reverseVisibilityFaces_Scene();
              WIN3D.update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hide All Faces")) {
              allModel3Ds.changeVisibilityFaces_Scene(0);
              WIN3D.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Unhide All Faces")) {
              allModel3Ds.changeVisibilityFaces_Scene(1);
              WIN3D.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Hide Selected Faces")) {
              allModel3Ds.changeVisibilityFaces_Selection(0);
              WIN3D.update = true;
            }  
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Unhide Selected Faces")) {
              allModel3Ds.changeVisibilityFaces_Selection(1);
              WIN3D.update = true;
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Isolate Selection")) {
              allModel3Ds.isolate_Selection();
              WIN3D.update = true;
            }         

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Flatten Selected LandPoints")) {

              SOLARCHVISION_flatten_selectedLandPoints();
              WIN3D.update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allModel1Ds")) {
              allModel1Ds.delete();
              WIN3D.update = true;
            }      
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allModel2Ds")) {
              allModel2Ds.delete();
              WIN3D.update = true;
            }        
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allGroups")) {
              allModel3Ds.delete_allGroups();
              WIN3D.update = true;
            }
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allSolids")) {
              allModel3Ds.delete_allSolids();
              WIN3D.update = true;
            }          
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allSections")) {
              allModel3Ds.delete_allSections();
              WIN3D.update = true;
            }       
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_allCameras")) {
              allModel3Ds.delete_allCameras();
              WIN3D.update = true;
            }    
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_Faces")) {
              allModel3Ds.delete_Faces();
              WIN3D.update = true;
            }             
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_Curves")) {
              allModel3Ds.delete_Curves();
              WIN3D.update = true;
            }  
    
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("ERASE_All")) {
              SOLARCHVISION_delete_All();
              WIN3D.update = true;
            }  
            
        
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TargetRoll")) {
              UI_set_to_View_TargetRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("TRL");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TargetRollZ")) {
              UI_set_to_View_TargetRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("TRLz");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TargetRollXY")) {
              UI_set_to_View_TargetRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("TRLxy");
              UI_BAR_b_update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("CameraRoll")) {
              UI_set_to_View_CameraRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("CRL");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("CameraRollZ")) {
              UI_set_to_View_CameraRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("CRLz");
              UI_BAR_b_update = true;
            }                
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("CameraRollXY")) {
              UI_set_to_View_CameraRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("CRLxy");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Orbit")) {
              UI_set_to_View_Orbit(0);
              SOLARCHVISION_highlight_in_BAR_b("OR");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("OrbitZ")) {
              UI_set_to_View_Orbit(1);
              SOLARCHVISION_highlight_in_BAR_b("ORz");
              UI_BAR_b_update = true;
            }           
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("OrbitXY")) {
              UI_set_to_View_Orbit(2);
              SOLARCHVISION_highlight_in_BAR_b("ORxy");
              UI_BAR_b_update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("LandOrbit")) {
              UI_set_to_View_LandOrbit(0);
              SOLARCHVISION_highlight_in_BAR_b("LNOR");
              UI_BAR_b_update = true;
            }   

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Pan")) {
              UI_set_to_View_Pan(0);
              SOLARCHVISION_highlight_in_BAR_b("Pan");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PanX")) {
              UI_set_to_View_Pan(1);
              SOLARCHVISION_highlight_in_BAR_b("PanX");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PanY")) {
              UI_set_to_View_Pan(2);
              SOLARCHVISION_highlight_in_BAR_b("PanY");
              UI_BAR_b_update = true;
            }          

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Zoom")) {
              UI_set_to_View_ZOOM(0);
              SOLARCHVISION_highlight_in_BAR_b("±ZM");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Zoom as default")) {
              UI_set_to_View_ZOOM(1);
              SOLARCHVISION_highlight_in_BAR_b("0ZM");
              UI_BAR_b_update = true;
            }


            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TruckX")) {
              UI_set_to_View_Truck(1);
              SOLARCHVISION_highlight_in_BAR_b("DIx");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TruckY")) {
              UI_set_to_View_Truck(2);
              SOLARCHVISION_highlight_in_BAR_b("DIy");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("TruckZ")) {
              UI_set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("DIz");
              UI_BAR_b_update = true;
            }          
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("DistZ")) {
              UI_set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDZ");
              UI_BAR_b_update = true;
            }     
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("CameraDistance")) {
              UI_set_to_View_CameraDistance(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDS");
              UI_BAR_b_update = true;
            }   
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("DistMouseXY")) {
              UI_set_to_View_DistMouseXY(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDM");
              UI_BAR_b_update = true;
            }  

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Look at origin")) {
              UI_set_to_View_LookAtOrigin(0);
              SOLARCHVISION_highlight_in_BAR_b("LAO");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Look at direction")) {
              UI_set_to_View_LookAtDirection(0);
              SOLARCHVISION_highlight_in_BAR_b("LAD");
              UI_BAR_b_update = true;
            }             
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Look at selection")) {
              UI_set_to_View_LookAtSelection(0);
              SOLARCHVISION_highlight_in_BAR_b("LAS");
              UI_BAR_b_update = true;
            }          
 
            
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("3DModelSize")) {
              UI_set_to_View_3DModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SZ");
              UI_BAR_b_update = true;
            }          

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("SkydomeSize")) {
              UI_set_to_View_SkydomeSize();
              SOLARCHVISION_highlight_in_BAR_b("±SK");
              UI_BAR_b_update = true;
            }       

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("AllModelSize")) {
              UI_set_to_View_AllModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SA");
              UI_BAR_b_update = true;
            }     

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Display All Viewports")) {
              UI_set_to_Viewport(0);
              SOLARCHVISION_highlight_in_BAR_b("AllViewports");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Enlarge 3D Viewport")) {
              UI_set_to_Viewport(1);
              SOLARCHVISION_highlight_in_BAR_b("Expand3DView");
              UI_BAR_b_update = true;
            } 
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Enlarge Time Viewport")) {
              UI_set_to_Viewport(2);
              SOLARCHVISION_highlight_in_BAR_b("ExpandTimeView");
              UI_BAR_b_update = true;
            }              
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Enlarge Map Viewport")) {
              UI_set_to_Viewport(3);
              SOLARCHVISION_highlight_in_BAR_b("ExpandMapView");
              UI_BAR_b_update = true;
            }             

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Top")) {
              UI_set_to_View_3DViewPoint(0);
              SOLARCHVISION_highlight_in_BAR_b("Top");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Front")) {
              UI_set_to_View_3DViewPoint(1);
              SOLARCHVISION_highlight_in_BAR_b("Front");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Left")) {
              UI_set_to_View_3DViewPoint(2);
              SOLARCHVISION_highlight_in_BAR_b("Left");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Back")) {
              UI_set_to_View_3DViewPoint(3);
              SOLARCHVISION_highlight_in_BAR_b("Back");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Right")) {
              UI_set_to_View_3DViewPoint(4);
              SOLARCHVISION_highlight_in_BAR_b("Right");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("Bottom")) {
              UI_set_to_View_3DViewPoint(5);
              SOLARCHVISION_highlight_in_BAR_b("Bottom");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("S.W.")) {
              UI_set_to_View_3DViewPoint(6);
              SOLARCHVISION_highlight_in_BAR_b("S.W.");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("S.E.")) {
              UI_set_to_View_3DViewPoint(7);
              SOLARCHVISION_highlight_in_BAR_b("S.E.");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("N.E.")) {
              UI_set_to_View_3DViewPoint(8);
              SOLARCHVISION_highlight_in_BAR_b("N.E.");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("N.W.")) {
              UI_set_to_View_3DViewPoint(9);
              SOLARCHVISION_highlight_in_BAR_b("N.W.");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotX:Minimum")) {
              UI_set_to_View_PivotX(-1);
              SOLARCHVISION_highlight_in_BAR_b("X<");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotX:Center")) {
              UI_set_to_View_PivotX(0);
              SOLARCHVISION_highlight_in_BAR_b("X|");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotX:Maximum")) {
              UI_set_to_View_PivotX(1);
              SOLARCHVISION_highlight_in_BAR_b("X>");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotY:Minimum")) {
              UI_set_to_View_PivotY(-1);
              SOLARCHVISION_highlight_in_BAR_b("Y<");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotY:Center")) {
              UI_set_to_View_PivotY(0);
              SOLARCHVISION_highlight_in_BAR_b("Y|");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotY:Maximum")) {
              UI_set_to_View_PivotY(1);
              SOLARCHVISION_highlight_in_BAR_b("Y>");
              UI_BAR_b_update = true;
            }

            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotZ:Minimum")) {
              UI_set_to_View_PivotZ(-1);
              SOLARCHVISION_highlight_in_BAR_b("Z<");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotZ:Center")) {
              UI_set_to_View_PivotZ(0);
              SOLARCHVISION_highlight_in_BAR_b("Z|");
              UI_BAR_b_update = true;
            }
            if (UI_BAR_a_Items[UI_BAR_a_selected_parent][UI_BAR_a_selected_child].equals("PivotZ:Maximum")) {
              UI_set_to_View_PivotZ(1);
              SOLARCHVISION_highlight_in_BAR_b("Z>");
              UI_BAR_b_update = true;
            }
          }
        }

        UI_BAR_a_selected_parent = -1;
        UI_BAR_a_selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);

        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      } else {    

        SOLARCHVISION_X_clicked = mouseX;
        SOLARCHVISION_Y_clicked = mouseY;

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, 0, width, SOLARCHVISION_A_Pixel) == 1) {
          UI_BAR_a_update = true;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_A_Pixel, width, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel) == 1) {
          UI_BAR_b_update = true;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel, width, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel) == 1) {
          UI_BAR_c_update = true;
          typeUserCommand = 1;
        }  

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel, width, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel + SOLARCHVISION_D_Pixel) == 1) {
          UI_BAR_d_update = true;
        }  

        if (WORLD.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY) == 1) {

            float mouse_lon = 360.0 * ((mouseX - WORLD.cX) * WORLD.sX / WORLD.dX - 0.5) + WORLD.oX;
            float mouse_lat = -180.0 * ((mouseY - WORLD.cY) * WORLD.sY / WORLD.dY - 0.5) + WORLD.oY;
            //float mouse_lon = STATION.getLongitude();
            //float mouse_lat = STATION.getLatitude();


            pre_LocationLAT = LocationLAT;
            pre_LocationLON = LocationLON;

            STATION.setLatitude(mouse_lat);
            STATION.setLongitude(mouse_lon);

            if (mouseButton == LEFT) {
              WORLD.Viewport_ZOOM = 6;
            }

            if ((pre_LocationLAT != LocationLAT) || (pre_LocationLON != LocationLON)) {
              WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
            } 



            {
              int nearest_WORLD_NAEFS = -1;
              float nearest_WORLD_NAEFS_dist = FLOAT_undefined;

              for (int f = 0; f < NAEFS_Coordinates.length; f++) {

                float _lat = NAEFS_Coordinates[f].getLatitude();
                float _lon = NAEFS_Coordinates[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_NAEFS_dist > d) {
                  nearest_WORLD_NAEFS_dist = d;
                  nearest_WORLD_NAEFS = f;
                }
              }

              {
                int f = nearest_WORLD_NAEFS;

                if (STATION.getFilename_NAEFS().equals(NAEFS_Coordinates[f].getFilename_NAEFS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_NAEFS(NAEFS_Coordinates[f].getFilename_NAEFS()); // naefs filename

                  println("nearest naefs filename:", NAEFS_Coordinates[f].getFilename_NAEFS());    

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    STATION.setCity(NAEFS_Coordinates[f].getCity());
                    STATION.setProvince(NAEFS_Coordinates[f].getProvince());
                    STATION.setCountry(NAEFS_Coordinates[f].getCountry());

                    //STATION.setLatitude(NAEFS_Coordinates[f].getLatitude());
                    //STATION.setLongitude(NAEFS_Coordinates[f].getLongitude());
                    STATION.setElevation(NAEFS_Coordinates[f].getElevation()); 
                    STATION.setTimelong(NAEFS_Coordinates[f].getTimelong());                     

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;


                    SOLARCHVISION_update_station(1);
                    update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
                  }
                }
              }
            }        


            {
              int nearest_WORLD_CWEEDS = -1;
              float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;

              for (int f = 0; f < CWEEDS_Coordinates.length; f++) {

                float _lat = CWEEDS_Coordinates[f].getLatitude();
                float _lon = CWEEDS_Coordinates[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_CWEEDS_dist > d) {
                  nearest_WORLD_CWEEDS_dist = d;
                  nearest_WORLD_CWEEDS = f;
                }
              }

              {
                int f = nearest_WORLD_CWEEDS;

                if (STATION.getFilename_CWEEDS().equals(CWEEDS_Coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon); 

                  STATION.setFilename_CWEEDS(CWEEDS_Coordinates[f].getFilename_CWEEDS()); // CWEEDS filename

                  println("nearest CWEEDS filename:", CWEEDS_Coordinates[f].getFilename_CWEEDS());       

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) { 

                    STATION.setCity(CWEEDS_Coordinates[f].getCity());
                    STATION.setProvince(CWEEDS_Coordinates[f].getProvince());
                    STATION.setCountry(CWEEDS_Coordinates[f].getCountry()); 

                    //STATION.setLatitude(CWEEDS_Coordinates[f].getLatitude());
                    //STATION.setLongitude(CWEEDS_Coordinates[f].getLongitude());
                    STATION.setElevation(CWEEDS_Coordinates[f].getElevation());
                    STATION.setTimelong(roundTo(STATION.getLongitude(), 15));   

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CWEEDS();
                  }
                }
              }
            }          

            {
              int nearest_WORLD_CLMREC = -1;
              float nearest_WORLD_CLMREC_dist = FLOAT_undefined;

              for (int f = 0; f < CLMREC_Coordinates.length; f++) {
                
                //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016) 
                { // only use stations with this condition

                  float _lat = CLMREC_Coordinates[f].getLatitude();
                  float _lon = CLMREC_Coordinates[f].getLongitude(); 
                  if (_lon > 180) _lon -= 360; // << important!
  
                  float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
                  if (nearest_WORLD_CLMREC_dist > d) {
                    nearest_WORLD_CLMREC_dist = d;
                    nearest_WORLD_CLMREC = f;
                  }
                }
              }

              {
                int f = nearest_WORLD_CLMREC;

                if (STATION.getFilename_CWEEDS().equals(CLMREC_Coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);                   

                  STATION.setFilename_CWEEDS(CLMREC_Coordinates[f].getFilename_CWEEDS()); // CLMREC filename

                  println("nearest CLMREC filename:", CLMREC_Coordinates[f].getFilename_CWEEDS());       

                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) { 

                    STATION.setCity(CLMREC_Coordinates[f].getCity());
                    STATION.setProvince(CLMREC_Coordinates[f].getProvince());
                    STATION.setCountry(CLMREC_Coordinates[f].getCountry()); 

                    //STATION.setLatitude(CLMREC_Coordinates[f].getLatitude());
                    //STATION.setLongitude(CLMREC_Coordinates[f].getLongitude());
                    STATION.setElevation(CLMREC_Coordinates[f].getElevation());
                    STATION.setTimelong(CLMREC_Coordinates[f].getTimelong());   

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CLMREC();
                  }
                }
              }
            }          


            {
              int nearest_WORLD_TMYEPW = -1;
              float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;

              for (int f = 0; f < TMYEPW_Coordinates.length; f++) {

                float _lat = TMYEPW_Coordinates[f].getLatitude();
                float _lon = TMYEPW_Coordinates[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_TMYEPW_dist > d) {
                  nearest_WORLD_TMYEPW_dist = d;
                  nearest_WORLD_TMYEPW = f;
                }
              }

              {
                int f = nearest_WORLD_TMYEPW;

                if (STATION.getFilename_TMYEPW().equals(TMYEPW_Coordinates[f].getFilename_TMYEPW())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_TMYEPW(TMYEPW_Coordinates[f].getFilename_TMYEPW()); // epw filename

                  println("nearest epw filename:", TMYEPW_Coordinates[f].getFilename_TMYEPW());       

                  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {     
                    STATION.setCity(TMYEPW_Coordinates[f].getCity());
                    STATION.setProvince(TMYEPW_Coordinates[f].getProvince());
                    STATION.setCountry(TMYEPW_Coordinates[f].getCountry()); 

                    //STATION.setLatitude(TMYEPW_Coordinates[f].getLatitude());
                    //STATION.setLongitude(TMYEPW_Coordinates[f].getLongitude());
                    STATION.setElevation(TMYEPW_Coordinates[f].getElevation());
                    STATION.setTimelong(TMYEPW_Coordinates[f].getTimelong());    

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_TMYEPW();
                  }
                }
              }
            }          




            WORLD.update = true;
          }
        }

        if (WIN3D.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

            float Image_X = 0;
            float Image_Y = 0;

            Image_X = SOLARCHVISION_X_clicked - (WIN3D.cX + 0.5 * WIN3D.dX);
            Image_Y = SOLARCHVISION_Y_clicked - (WIN3D.cY + 0.5 * WIN3D.dY);
            
            if (WIN3D.UI_CurrentTask == UITASK.LookAtDirection) { // viewport:LookAtDirection

              WIN3D.look_3DViewport_towards_Direction(Image_X, Image_Y);

              WIN3D.update = true;
            }
            else {
  
              float[] ray_direction = new float [3];
  
              float[] ray_start = {
                WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
              };
  
              float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);
  
              ray_start[0] /= OBJECTS_scale;
              ray_start[1] /= OBJECTS_scale;
              ray_start[2] /= OBJECTS_scale;          
  
              ray_end[0] /= OBJECTS_scale;
              ray_end[1] /= OBJECTS_scale;
              ray_end[2] /= OBJECTS_scale;
  
              if (WIN3D.ViewType == 0) {
                float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);
  
                ray_center[0] /= OBJECTS_scale;
                ray_center[1] /= OBJECTS_scale;
                ray_center[2] /= OBJECTS_scale;
  
                ray_start[0] += ray_end[0] - ray_center[0];
                ray_start[1] += ray_end[1] - ray_center[1];
                ray_start[2] += ray_end[2] - ray_center[2];
              }
  
              ray_direction[0] = ray_end[0] - ray_start[0];
              ray_direction[1] = ray_end[1] - ray_start[1];
              ray_direction[2] = ray_end[2] - ray_start[2];
  
              float[] RxP = new float [8];
  
              if (mouseButton == RIGHT) {
                RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
              } else if (mouseButton == LEFT) {

                if ((WIN3D.UI_CurrentTask == UITASK.Create) || (WIN3D.UI_CurrentTask == UITASK.Move)) {
                   RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));

                } else {
 
                  if (Current_ObjectCategory == ObjectCategory.CURVE) {
                    RxP = SOLARCHVISION_intersect_Curves(ray_start, ray_direction);
                  } else if (Current_ObjectCategory == ObjectCategory.CAMERA) {
                    RxP = allCameras.intersect(ray_start, ray_direction);
                  } else if (Current_ObjectCategory == ObjectCategory.SECTION) {
                    RxP = allSections.intersect(ray_start, ray_direction);
                  } else if (Current_ObjectCategory == ObjectCategory.SOLID) {
                    RxP = allSolids.intersect(ray_start, ray_direction);
                  } else if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
                    RxP = allModel1Ds.intersect(ray_start, ray_direction);
                  } else if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
                    RxP = allModel2Ds.intersect(ray_start, ray_direction);
                  } else {
                    RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));
                  }
                }
                
                

              }
  
  
              //println(ray_start[0], ray_start[1], ray_start[2], ">>", ray_end[0], ray_end[1], ray_end[2], ">>", RxP[1], RxP[2], RxP[3], RxP[4], RxP[0]);
  
              if (RxP[0] >= 0) {
  
                if (WIN3D.UI_CurrentTask == UITASK.Move) { // move
  
                  float x1 = FLOAT_undefined;
                  float y1 = FLOAT_undefined;
                  float z1 = FLOAT_undefined;
  
                  if (Current_ObjectCategory == ObjectCategory.GROUP) {
  
                    float[] P = SOLARCHVISION_getPivot();
  
                    x1 = P[0];
                    y1 = P[1];
                    z1 = P[2];
                  }
  
                  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
  
                    x1 = allModel2Ds.getX(selectedallModel2Ds_ids[selectedallModel2Ds_ids.length - 1]); 
                    y1 = allModel2Ds.getY(selectedallModel2Ds_ids[selectedallModel2Ds_ids.length - 1]); 
                    z1 = allModel2Ds.getZ(selectedallModel2Ds_ids[selectedallModel2Ds_ids.length - 1]);
                  }
  
                  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
  
                    x1 = allModel1Ds.getX(selectedallModel1Ds_ids[selectedallModel1Ds_ids.length - 1]); 
                    y1 = allModel1Ds.getY(selectedallModel1Ds_ids[selectedallModel1Ds_ids.length - 1]); 
                    z1 = allModel1Ds.getZ(selectedallModel1Ds_ids[selectedallModel1Ds_ids.length - 1]);
                  }            
  
                  if (Current_ObjectCategory == ObjectCategory.SOLID) {
  
                    x1 = allSolids.get_posX(selectedSolid_ids[selectedSolid_ids.length - 1]); 
                    y1 = allSolids.get_posY(selectedSolid_ids[selectedSolid_ids.length - 1]); 
                    z1 = allSolids.get_posZ(selectedSolid_ids[selectedSolid_ids.length - 1]);
                  }                 
  
                  if (Current_ObjectCategory == ObjectCategory.VERTEX) {
  
                    x1 = allVertices[selectedVertex_ids[selectedVertex_ids.length - 1]][0]; 
                    y1 = allVertices[selectedVertex_ids[selectedVertex_ids.length - 1]][1]; 
                    z1 = allVertices[selectedVertex_ids[selectedVertex_ids.length - 1]][2];
                  }             
  
                  if ((x1 != FLOAT_undefined) && (y1 != FLOAT_undefined) && (z1 != FLOAT_undefined)) {       
  
                    float x2 = RxP[1];
                    float y2 = RxP[2];
                    float z2 = RxP[3];
  
                    float[] p = SOLARCHVISION_translateOutside_ReferencePivot(x2, y2, z2);
  
                    float dx = p[0] - x1; 
                    float dy = p[1] - y1;
                    float dz = p[2] - z1;
  
                    int the_Vector = selected_posVector;
  
                    if (the_Vector == 0) {
                      dy = 0; 
                      dz = 0;
                    }  
                    if (the_Vector == 1) {
                      dz = 0; 
                      dx = 0;
                    }  
                    if (the_Vector == 2) {
                      dx = 0; 
                      dy = 0;
                    } 
  
                    SOLARCHVISION_move_Selection(dx, dy, dz);
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 10");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                    WIN3D.update = true;
                  }
                }   
  
  
  
  
                if (mouseButton == LEFT) { // modify should work only with left click because the right click returns the land info, not objects info
  
                  if ((WIN3D.UI_TaskModifyParameter != 0) && (WIN3D.UI_CurrentTask >= UITASK.Seed_Material)) { // Pick/Assign properties 
  
                    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE)) {
  
                      int f = int(RxP[0]);
  
                      if ((WIN3D.UI_CurrentTask == UITASK.Seed_Material) || (WIN3D.UI_CurrentTask == UITASK.Tessellation) || (WIN3D.UI_CurrentTask == UITASK.Layer) || (WIN3D.UI_CurrentTask == UITASK.Visibility) || (WIN3D.UI_CurrentTask == UITASK.Weight)) {
  
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) DEFAULT_CreateMaterial     = allFaces.getMaterial(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  DEFAULT_CreateTessellation = allFaces.getTessellation(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         DEFAULT_CreateLayer        = allFaces.getLayer(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    DEFAULT_CreateVisibility   = allFaces.getVisibility(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        DEFAULT_CreateWeight       = allFaces.getWeight(f);
                        } 
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign(sub) 
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (f, DEFAULT_CreateMaterial);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(f, DEFAULT_CreateTessellation);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (f, DEFAULT_CreateLayer);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (f, DEFAULT_CreateVisibility);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setWeight      (f, DEFAULT_CreateWeight);
                        }
                        if (WIN3D.UI_TaskModifyParameter == 3) { // Assign(all) 
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }

                          for (int q = allGroups.Faces[OBJ_NUM][0]; q <= allGroups.Faces[OBJ_NUM][1]; q++) {                    
                            if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (q, DEFAULT_CreateMaterial);
                            if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(q, DEFAULT_CreateTessellation);
                            if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (q, DEFAULT_CreateLayer);
                            if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (q, DEFAULT_CreateVisibility);
                            if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setClose       (q, DEFAULT_CreateWeight);
                          }
                        }
                      }
  
                      if (WIN3D.UI_CurrentTask == UITASK.Pivot) {
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          //?????????????????????????????????????????????????
                        }     
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }


                          float[] P = SOLARCHVISION_getPivot();

                          allGroups.PivotXYZ[OBJ_NUM][0] = P[0];
                          allGroups.PivotXYZ[OBJ_NUM][1] = P[1];
                          allGroups.PivotXYZ[OBJ_NUM][2] = P[2];

                          //zzzzzzzzzzzzzzzzzzz should add other components?

                        }
                      }
  
                      if (WIN3D.UI_CurrentTask == UITASK.Normal) { //Normal
  
                        if (Current_ObjectCategory == ObjectCategory.FACE) {
  
                          selectedFace_ids = new int [1];
                          selectedFace_ids[0] = f;       
  
                          selectedFace_displayVertexCount = true;                 
  
                          int n = allFaces.nodes[f].length;
  
                          if (n > 2) {
                            int[] tmpFace = new int[n];
                            float[] G = {
                              0, 0, 0
                            }; 
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                              G[0] += allVertices[tmpFace[j]][0] / float(n); 
                              G[1] += allVertices[tmpFace[j]][1] / float(n);
                              G[2] += allVertices[tmpFace[j]][2] / float(n);
                            }  
  
                            int flip_face = 0;
                            if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                            else {
                              PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                              PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);
  
                              PVector GAxGB = AG.cross(BG);
  
                              float[] P = SOLARCHVISION_getPivot();
  
                              float x0 = P[0];
                              float y0 = P[1];
                              float z0 = P[2];                            
  
                              PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);
  
                              float V = PG.dot(GAxGB); 
  
                              if (WIN3D.UI_TaskModifyParameter == 2) {
                                if (V > 0) flip_face = 1;
                              }
                              if (WIN3D.UI_TaskModifyParameter == 3) {
                                if (V < 0) flip_face = 1;
                              }
                            }
  
                            if (flip_face == 1) {
                              for (int j = 0; j < n; j++) {
                                allFaces.nodes[f][j] = tmpFace[n - j - 1];
                              }
                            }
                          }
                        }
  
                        if (Current_ObjectCategory == ObjectCategory.GROUP) {
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }
     
                          for (int q = allGroups.Faces[OBJ_NUM][0]; q <= allGroups.Faces[OBJ_NUM][1]; q++) {                    
                            int n = allFaces.nodes[q].length;

                            if (n > 2) {
                              int[] tmpFace = new int[n];
                              float[] G = {
                                0, 0, 0
                              }; 
                              for (int j = 0; j < n; j++) {
                                tmpFace[j] = allFaces.nodes[q][j];
                                G[0] += allVertices[tmpFace[j]][0] / float(n); 
                                G[1] += allVertices[tmpFace[j]][1] / float(n);
                                G[2] += allVertices[tmpFace[j]][2] / float(n);
                              }  

                              int flip_face = 0;
                              if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                              else {
                                PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                                PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);

                                PVector GAxGB = AG.cross(BG);

                                float[] P = SOLARCHVISION_getPivot();

                                float x0 = P[0];
                                float y0 = P[1];
                                float z0 = P[2];                                

                                PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                                float V = PG.dot(GAxGB); 

                                if (WIN3D.UI_TaskModifyParameter == 2) {
                                  if (V > 0) flip_face = 1;
                                }
                                if (WIN3D.UI_TaskModifyParameter == 3) {
                                  if (V < 0) flip_face = 1;
                                }
                              }

                              if (flip_face == 1) {
                                for (int j = 0; j < n; j++) {
                                  allFaces.nodes[q][j] = tmpFace[n - j - 1];
                                }
                              }
                            }
                          }

                        }
                      }   
  
  
                      if (WIN3D.UI_CurrentTask == UITASK.FirstVertex) { //FirstVertex
  
                        if (Current_ObjectCategory == ObjectCategory.FACE) {
  
                          selectedFace_ids = new int [1];
                          selectedFace_ids[0] = f;
  
                          selectedFace_displayVertexCount = true;
  
                          int n = allFaces.nodes[f].length;
  
                          if (n > 2) {
  
                            int min_num = 0;
                            float min_dist = FLOAT_undefined;
  
                            for (int j = 0; j < n; j++) {
                              int vNo = allFaces.nodes[f][j];
  
                              float d = dist(RxP[1], RxP[2], RxP[3], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }
  
                            int[] tmpFace = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                            }  
  
                            for (int j = 0; j < n; j++) {
                              allFaces.nodes[f][j] = tmpFace[(j + min_num + n) % n];
                            }
                          }
                        }
                        
                        
                        if (Current_ObjectCategory == ObjectCategory.CURVE) {
  
                          selectedCurve_ids = new int [1];
                          selectedCurve_ids[0] = f;
  
                          selectedCurve_displayVertexCount = true;
  
                          int n = allCurves.nodes[f].length;
  
                          if (n > 2) {
  
                            int min_num = 0;
                            float min_dist = FLOAT_undefined;
  
                            for (int j = 0; j < n; j++) {
                              int vNo = allCurves.nodes[f][j];
  
                              float d = dist(RxP[1], RxP[2], RxP[3], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
  
                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }
  
                            int[] tmpCurve = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpCurve[j] = allCurves.nodes[f][j];
                            }  
  
                            for (int j = 0; j < n; j++) {
                              allCurves.nodes[f][j] = tmpCurve[(j + min_num + n) % n];
                            }
                          }
                        }                      
                        
                      }
                    } 
  
  
  
  
  
  
  
  
  
  
                    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
  
                      int OBJ_NUM = int(RxP[0]);
  
                      int n = allModel2Ds.MAP[OBJ_NUM];
                      int sign_n = 1;
                      if (n < 0) sign_n = -1;
                      n = abs(n);
                      int n1 = allModel2Ds.PEOPLE_Files_Num;
                      int n2 = allModel2Ds.PEOPLE_Files_Num + allModel2Ds.TREES_Files_Num;
  
                      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
  
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          if (n <= n1) { // case: people 
                            CreatePerson_Type = n;
                          } else { // case: trees
                            CreatePlant_Type = n - n1;
                          }
                        } 
                        if ((WIN3D.UI_TaskModifyParameter == 2) || (WIN3D.UI_TaskModifyParameter == 3)) { // Assign
                          if (n <= n1) { // case: people 
                            allModel2Ds.MAP[OBJ_NUM] = sign_n * CreatePerson_Type;
                          } else { // case: trees
                            allModel2Ds.MAP[OBJ_NUM] = sign_n * (CreatePlant_Type + n1);
                          }
                        }
                      }
                    }      
  
  
                    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
  
                      int OBJ_NUM = int(RxP[0]);
  
                      if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) CreateallModel1Ds_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
                          CreateallModel1Ds_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM); 
                          CreateallModel1Ds_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                        }
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) CreateallModel1Ds_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) CreateallModel1Ds_TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) CreateallModel1Ds_LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.AllallModel1DsProps) { // all properties
                          CreateallModel1Ds_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM);
                          CreateallModel1Ds_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                          CreateallModel1Ds_TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
                          CreateallModel1Ds_LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
                        }
                      } 
                      if (WIN3D.UI_TaskModifyParameter == 2) { //Assign
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) allModel1Ds.setDegreeMax(OBJ_NUM, CreateallModel1Ds_DegreeMax);                    
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
                          allModel1Ds.setDegreeMax(OBJ_NUM, CreateallModel1Ds_DegreeMax); 
                          allModel1Ds.setDegreeMin(OBJ_NUM, CreateallModel1Ds_DegreeMin);
                        }                 
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) allModel1Ds.setDegreeMin(OBJ_NUM, CreateallModel1Ds_DegreeMin);                    
                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) allModel1Ds.setTrunkSize(OBJ_NUM, CreateallModel1Ds_TrunkSize);                    
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) allModel1Ds.setLeafSize(OBJ_NUM, CreateallModel1Ds_LeafSize);
                        if (WIN3D.UI_CurrentTask == UITASK.AllallModel1DsProps) { // all properties
                          allModel1Ds.setDegreeMax(OBJ_NUM, CreateallModel1Ds_DegreeMax);
                          allModel1Ds.setDegreeMin(OBJ_NUM, CreateallModel1Ds_DegreeMin);                    
                          allModel1Ds.setTrunkSize(OBJ_NUM, CreateallModel1Ds_TrunkSize);                    
                          allModel1Ds.setLeafSize(OBJ_NUM, CreateallModel1Ds_LeafSize);
                        }
                      }
                    }                        
  
                    WIN3D.update = true;                 
                    ROLLOUT.update = true;
                  } else if ((WIN3D.UI_CurrentTask != UITASK.Create) && (WIN3D.UI_CurrentTask != UITASK.Move)) { // PickSelect also if scale, rotate, modify, etc. where selected
  
                    SOLARCHVISION_PickSelect(RxP);
                  }
                }
  
                if (WIN3D.UI_CurrentTask == UITASK.Create) { // create
                  
                  int keep_number_of_allGroups = allGroups.num;
                  int keep_number_of_allModel2Ds = allModel2Ds.num;
                  int keep_number_of_allModel1Ds = allModel1Ds.num;
                  int keep_number_of_allSolids = allSolids.DEF.length;
                  int keep_number_of_allSections = allSections.num;
                  int keep_number_of_allCameras = allCameras.num;
  
                  float x = RxP[1]; 
                  float y = RxP[2]; 
                  float z = RxP[3];         
              
                  float rot = CreateInput_Orientation;
                  if (rot == 360) rot = WIN3D.RZ_Coordinate;
  
  
  
                  float rx = 0.5 * CreateInput_Length;
                  if (rx < 0) rx = random(0.25 * abs(rx), abs(rx));
  
                  float ry = 0.5 * CreateInput_Width;
                  if (ry < 0) ry = random(0.25 * abs(ry), abs(ry));
  
                  float rz = 0.5 * CreateInput_Height;
                  if (rz < 0) rz = random(0.25 * abs(rz), abs(rz));
  
  
  
                  float px = CreateInput_powX; 
                  float py = CreateInput_powY;
                  float pz = CreateInput_powZ;
  
                  if (CreateInput_powRnd == 1) {
                    px = pow(2, int(random(5)) - 1);
                    py = px;
                    pz = px;
                  }
  
                  if (CreateInput_Volume != 0) {
  
                    if ((rx != 0) && (ry != 0)) {
                      rz = CreateInput_Volume / (8 * rx * ry);
                    }
  
                    //---------------------------------------------------
                    float A = 1; 
                    // cube volume: 8*r^3, sphere volume: 4*r^3, so maybe:
                    if (pz >= 8) A = 1;
                    else if (pz == 4) A = 0.75;
                    else if (pz == 2) A = 0.5;
                    else if (pz == 1) A = 0.25;
                    else if (pz == 0.5) A = 0.125;
                    else if (pz == 0.25) A = 0.0625;
  
                    rx /= pow(A, (1.0 / 3.0));
                    ry /= pow(A, (1.0 / 3.0));
                    rz /= pow(A, (1.0 / 3.0));
                    //---------------------------------------------------
                  }
  
  
                  if ((Current_ObjectCategory != ObjectCategory.MODEL1D) && (Current_ObjectCategory != ObjectCategory.MODEL2D) && (Current_ObjectCategory != ObjectCategory.LANDPOINT) && (Current_ObjectCategory != ObjectCategory.CAMERA) && (Current_ObjectCategory != ObjectCategory.SECTION)) {
  
                    x -= rx * selection_alignX;
                    y -= ry * selection_alignY;
                    z -= rz * selection_alignZ;
                  }
  
  
  
                  //if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.SOLID) || (Current_ObjectCategory == ObjectCategory.MODEL1D) || (Current_ObjectCategory == ObjectCategory.MODEL2D)) {
                  if (Current_ObjectCategory == ObjectCategory.GROUP) {
  
                    if (addToLastGroup == 0) {
  
                      allModel3Ds.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
                    }
                  }
  
  
                  if (Current_ObjectCategory == ObjectCategory.GROUP) { // working with meshes
    
                    if (CreateObject == CREATE.SuperOBJ) {
    
                      if ((px == CubePower) && (py == CubePower) && (pz == 2)) {
    
                        allModel3Ds.add_ParametricSurface(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, 2, rot);
                      } else if ((px == 2) && (py == 2) && (pz == CubePower)) {
    
                        allModel3Ds.add_SuperCylinder(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, CreateInput_CylinderDegree, rot);
                      } else if ((px == CubePower) && (py == CubePower) && (pz == CubePower)) {
    
                        allModel3Ds.add_Box_Core(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, rot);
                      } else if ((px == 1) && (py == 1) && (pz == 1)) {
    
                        allModel3Ds.add_Octahedron(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, rot);
                      } else {
    
                        allModel3Ds.add_SuperSphere(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, pz, py, pz, rx, ry, rz, CreateInput_SphereDegree, rot);
                      }
    
    
    
    
                      if (CreateInput_MeshOrSolid != 0) {
    
                        allModel3Ds.add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                      }
                    }
    
  
    
                    if (CreateObject == CREATE.Tri) {
    
                      allModel3Ds.add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x-rx, y-ry, z-rz, x+rx, y-ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x+rx, y-ry, z-rz, x+rx, y+ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x+rx, y+ry, z-rz, x-rx, y+ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x-rx, y+ry, z-rz, x-rx, y-ry, z-rz, x, y, z+rz);
                    }
    

                    if (CreateObject == CREATE.Plane) {
    
                      allModel3Ds.add_Mesh4(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x-rx, y-ry, z, x+rx, y-ry, z, x+rx, y+ry, z, x-rx, y+ry, z);
                    }
                    
                    if (CreateObject == CREATE.Poly) {
    
                      allModel3Ds.add_PolygonMesh(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, CreateInput_PolyDegree, rot);
                    }                    
                    
                    if (CreateObject == CREATE.Hyper) {
    
                      allModel3Ds.add_PolygonHyper(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, 2 * rz, CreateInput_PolyDegree, rot);
                    }
                      
    
                    if (CreateObject == CREATE.Extrude) {       
    
                      allModel3Ds.add_PolygonExtrude(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, 2 * rz, CreateInput_PolyDegree, rot);
                    }
    
                    if (CreateObject == CREATE.House1) {   
                      
                      float h = ry;  

                      allModel3Ds.add_House1_Core(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, h, rot);
                    }

                    if (CreateObject == CREATE.House2) {   
       
                      float h = ry;   
          
                      if (ry > rx) h = rx;            
    
                      allModel3Ds.add_House2_Core(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, h, rot);
                    }
    
                    if (CreateObject == CREATE.Parametric) {
    
                      allModel3Ds.add_ParametricSurface(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateWeight, DEFAULT_CreateClose, x, y, z, rx, ry, rz, CreateParametric_Type, rot);
                    }
                    
                  }
  
                  if (Current_ObjectCategory == ObjectCategory.MODEL2D) { // working with object2Ds
                    if (CreateObject == CREATE.Person) {
    
                      randomSeed(millis());
                      allModel2Ds.add_single("PEOPLE", CreatePerson_Type, x, y, z, 2.5);
                    }
    
                    if (CreateObject == CREATE.Plant) {
                      int n = 0;
                      if (CreatePlant_Type > 0) n = CreatePlant_Type + allModel2Ds.PEOPLE_Files_Num;
    
                      randomSeed(millis());
                      allModel2Ds.add_single("TREES", n, x, y, z, 2 * rz);
                    }
                  }    
                  
                  if (Current_ObjectCategory == ObjectCategory.MODEL1D) { // working with allModel1Ds
                    if (CreateObject == CREATE.allModel1Ds) {
  
                      randomSeed(millis());
                      allModel1Ds.add_single(CreateallModel1Ds_Type, x, y, z, 2 * rz, rot, CreateallModel1Ds_DegreeMin, CreateallModel1Ds_DegreeMax, CreateallModel1Ds_Seed, CreateallModel1Ds_TrunkSize, CreateallModel1Ds_LeafSize);
                    }        
                  }

                  if (Current_ObjectCategory == ObjectCategory.VERTEX) { // working with vertices
                    if (CreateObject == CREATE.Vertex) {
                      allModel3Ds.add_Vertex(x, y, z);
                      
                    }
                  }    


                  if (Current_ObjectCategory == ObjectCategory.FACE) { // working with faces
                    if (CreateObject == CREATE.Face) {
                      allModel3Ds.add_VertexToLastFace(x, y, z); 

                      selectedFace_ids = new int [1];
                      selectedFace_ids[0] = allFaces.nodes.length - 1;
    
                      println("SOLARCHVISION_calculate_selection_BoundingBox 9_Face");
                      SOLARCHVISION_calculate_selection_BoundingBox();
                    }
                  }      
          
                  if (Current_ObjectCategory == ObjectCategory.CURVE) { // working with curves
                    if (CreateObject == CREATE.Curve) {
                      allModel3Ds.add_VertexToLastCurve(x, y, z);                   

                      selectedCurve_ids = new int [1];
                      selectedCurve_ids[0] = allCurves.nodes.length - 1;
    
                      println("SOLARCHVISION_calculate_selection_BoundingBox 9_Curve");
                      SOLARCHVISION_calculate_selection_BoundingBox();
                    }
                  }        
                      

  
                  if (Current_ObjectCategory == ObjectCategory.SOLID) { // working with solids
                    if (CreateObject == CREATE.Solid) {
                      allModel3Ds.add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                    }
                  }        
  
  
                  if (Current_ObjectCategory == ObjectCategory.CAMERA) { // working with cameras
                    if (CreateObject == CREATE.Camera) {              
    
                      int f = int(RxP[0]);
    
                      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
                      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
                      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
                      float keep_WIN3D_X_Coordinate = WIN3D.X_Coordinate; 
                      float keep_WIN3D_Y_Coordinate = WIN3D.Y_Coordinate;
                      float keep_WIN3D_Z_Coordinate = WIN3D.Z_Coordinate;
                      float keep_WIN3D_S_Coordinate = WIN3D.S_Coordinate;
                      float keep_WIN3D_RX_Coordinate = WIN3D.RX_Coordinate; 
                      float keep_WIN3D_RY_Coordinate = WIN3D.RY_Coordinate;
                      float keep_WIN3D_RZ_Coordinate = WIN3D.RZ_Coordinate;
                      float keep_WIN3D_Zoom = WIN3D.Zoom;
    
                      {
    
                        WIN3D.CAM_x = RxP[1];
                        WIN3D.CAM_y = RxP[2];
                        WIN3D.CAM_z = RxP[3] + EyeLevel;       
    
                        WIN3D.reverseTransform_3DViewport();
    
                        float Camera_X = WIN3D.X_Coordinate;
                        float Camera_Y = WIN3D.Y_Coordinate;
                        float Camera_Z = WIN3D.Z_Coordinate;
                        float Camera_S = WIN3D.S_Coordinate;
                        float Camera_RX = WIN3D.RX_Coordinate;
                        float Camera_RY = WIN3D.RY_Coordinate;
                        float Camera_RZ = WIN3D.RZ_Coordinate;
                        float Camera_ZOOM = WIN3D.Zoom;
    
                        int Camera_Type = WIN3D.ViewType;
    
                        allModel3Ds.add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);
    
                        WIN3D.update = true;
                      }  
    
                      WIN3D.CAM_x = keep_WIN3D_CAM_x;
                      WIN3D.CAM_y = keep_WIN3D_CAM_y;
                      WIN3D.CAM_z = keep_WIN3D_CAM_z;
                      WIN3D.X_Coordinate = keep_WIN3D_X_Coordinate; 
                      WIN3D.Y_Coordinate = keep_WIN3D_Y_Coordinate;
                      WIN3D.Z_Coordinate = keep_WIN3D_Z_Coordinate;
                      WIN3D.S_Coordinate = keep_WIN3D_S_Coordinate;
                      WIN3D.RX_Coordinate = keep_WIN3D_RX_Coordinate; 
                      WIN3D.RY_Coordinate = keep_WIN3D_RY_Coordinate;
                      WIN3D.RZ_Coordinate = keep_WIN3D_RZ_Coordinate;
                      WIN3D.Zoom = keep_WIN3D_Zoom;
                    }
                  }
                  
                  
                  if (Current_ObjectCategory == ObjectCategory.SECTION) { // working with sections
                    if (CreateObject == CREATE.Section) {
    
                      int createNewSection = 0;
    
                      float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
                      float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
                      float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
                      float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
                      float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
                      float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];
    
                      int Section_Type = SolidImpact_sectionType;
                      int Section_RES1 = SolidImpact_RES1;
                      int Section_RES2 = SolidImpact_RES2;  
      
                      if (mouseButton == LEFT) {   
                        
                        int f = int(RxP[0]);
                        
                        int n = allFaces.nodes[f].length;
      
                        if (n > 2) {
      
                          //float min_Alpha = 90;
                          float min_Beta = 360;
      
                          for (int j = 0; j < n; j++) {
      
                            int j_next = (j + 1) % n;
      
                            float x1 = allVertices[allFaces.nodes[f][j]][0];
                            float y1 = allVertices[allFaces.nodes[f][j]][1];
                            float z1 = allVertices[allFaces.nodes[f][j]][2];                        
      
                            float x2 = allVertices[allFaces.nodes[f][j_next]][0];
                            float y2 = allVertices[allFaces.nodes[f][j_next]][1];
                            float z2 = allVertices[allFaces.nodes[f][j_next]][2];                        
      
      
                            //float Alpha = asin_ang(z2 - z1);
                            float Beta = atan2_ang(y2 - y1, x2 - x1) + 90;
      
                            //if (min_Alpha > Alpha) min_Alpha = Alpha;                      
                            if (min_Beta > Beta) min_Beta = Beta;
                          }
      
                          //println("min_Alpha", min_Alpha);
      
                          float[][] tmpVertices = new float[n][3];
      
      
                          for (int j = 0; j < n; j++) {
      
                            float x1 = allVertices[allFaces.nodes[f][j]][0];
                            float y1 = allVertices[allFaces.nodes[f][j]][1];
                            float z1 = allVertices[allFaces.nodes[f][j]][2];
      
                            float x2 = x1 * cos_ang(-min_Beta) - y1 * sin_ang(-min_Beta);
                            float y2 = x1 * sin_ang(-min_Beta) + y1 * cos_ang(-min_Beta);
                            float z2 = z1;
      
                            tmpVertices[j][0] = x2;
                            tmpVertices[j][1] = y2;
                            tmpVertices[j][2] = z2;
                          }    
      
                          float min_x = FLOAT_undefined;
                          float max_x = -FLOAT_undefined;
                          float min_y = FLOAT_undefined;
                          float max_y = -FLOAT_undefined;
                          float min_z = FLOAT_undefined;
                          float max_z = -FLOAT_undefined;
      
                          float[] G = {
                            0, 0, 0
                          }; 
                          for (int j = 0; j < n; j++) {
                            float the_x = tmpVertices[j][0];
                            float the_y = tmpVertices[j][1];
                            float the_z = tmpVertices[j][2];
      
                            G[0] += the_x / float(n); 
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);
      
                            if (min_x > the_x) min_x = the_x; 
                            if (max_x < the_x) max_x = the_x; 
                            if (min_y > the_y) min_y = the_y; 
                            if (max_y < the_y) max_y = the_y; 
                            if (min_z > the_z) min_z = the_z; 
                            if (max_z < the_z) max_z = the_z;
                          }
      
    
    
                          if ((max_z - min_z < max_x - min_x) && (max_z - min_z < max_y - min_y)) {
                            Section_Type = 1;
      
                            Section_scale_U = max_x - min_x; 
                            Section_scale_V = max_y - min_y;
      
                            Section_offset_U = G[0];
                            Section_offset_V = G[1];
      
                            Section_Elevation = G[2];
      
                            Section_Rotation = min_Beta;
                          } else {
                            Section_Type = 2;
      
                            Section_scale_U = max_y - min_y;
                            Section_scale_V = max_z - min_z; 
      
                            Section_offset_U = -G[1];
                            Section_offset_V = G[2];        
      
                            Section_Elevation = -G[0];
      
                            Section_Rotation = 90 - min_Beta;
                          }       
      
      
                          // recalculating G...  
                          G[0] = 0;             
                          G[1] = 0;
                          G[2] = 0;
                          for (int j = 0; j < n; j++) {
                            float the_x = allVertices[allFaces.nodes[f][j]][0];
                            float the_y = allVertices[allFaces.nodes[f][j]][1];
                            float the_z = allVertices[allFaces.nodes[f][j]][2];
      
                            G[0] += the_x / float(n); 
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);
                          }
      
                          PVector AG = new PVector(allVertices[allFaces.nodes[f][0]][0] - G[0], allVertices[allFaces.nodes[f][0]][1] - G[1], allVertices[allFaces.nodes[f][0]][2] - G[2]);                       
                          PVector BG = new PVector(allVertices[allFaces.nodes[f][1]][0] - G[0], allVertices[allFaces.nodes[f][1]][1] - G[1], allVertices[allFaces.nodes[f][1]][2] - G[2]);
      
                          PVector GAxGB = AG.cross(BG);
      
                          float[][] ImageVertex = allSections.getCorners(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
      
                          float[] SectionCorner_A = ImageVertex[1];
                          float[] SectionCorner_B = ImageVertex[2];
                          float[] SectionCorner_C = ImageVertex[3];
                          float[] SectionCorner_D = ImageVertex[4]; 
      
                          float[] ImageCenter = {
                            0, 0, 0
                          };
                          for (int j = 0; j < 3; j++) {
                            ImageCenter[j] = 0.25 * (SectionCorner_A[j] + SectionCorner_B[j] + SectionCorner_C[j] + SectionCorner_D[j]);
                          }  
      
                          PVector AG_other = new PVector(SectionCorner_A[0] - ImageCenter[0], SectionCorner_A[1] - ImageCenter[1], SectionCorner_A[2] - ImageCenter[2]);                       
                          PVector BG_other = new PVector(SectionCorner_B[0] - ImageCenter[0], SectionCorner_B[1] - ImageCenter[1], SectionCorner_B[2] - ImageCenter[2]);
      
                          PVector GAxGB_other = AG_other.cross(BG_other);
      
                          //println("GAxGB", GAxGB);
                          //println("GAxGB_other", GAxGB_other);
      
                          float V = GAxGB_other.dot(GAxGB);
      
                          //println("V", nf(V, 0, 6));                        
      
                          if (V < 0) {
                            println("flip face!");
      
                            Section_Rotation = 180 + Section_Rotation;
                            Section_Elevation *= -1;
                            Section_offset_U *= -1;
                          } else {
                            println("face OK!");
                          }
                          
                          createNewSection = 1;
      
                        }
                      }
                      
                      if (mouseButton == RIGHT) {   
    
                        Section_Type = 1;
    
                        Section_offset_U = RxP[1];
                        Section_offset_V = RxP[2];
                        Section_Elevation = RxP[3];
    
    
                        createNewSection = 1;
                      }
                      
                      if (createNewSection != 0) {
      
                        allModel3Ds.add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
    
                        if (keep_number_of_allSections != allSections.num) { // if any Section created during the process
    
                          selectedSection_ids = new int [0];
    
                          for (int o = keep_number_of_allSections; o < allSections.num; o++) {
    
                            int[] newlyAddedSection = {o};
    
                            selectedSection_ids = concat(selectedSection_ids, newlyAddedSection);
                          }  
    
                          println("SOLARCHVISION_calculate_selection_BoundingBox 9_Section");
                          SOLARCHVISION_calculate_selection_BoundingBox();
                        }      
    
                        SolidImpact_offset_U[SolidImpact_sectionType] = Section_offset_U;
                        SolidImpact_offset_V[SolidImpact_sectionType] = Section_offset_V;
                        SolidImpact_Elevation[SolidImpact_sectionType] = Section_Elevation;
                        SolidImpact_Rotation[SolidImpact_sectionType] = Section_Rotation;
                        SolidImpact_scale_U[SolidImpact_sectionType] = Section_scale_U;
                        SolidImpact_scale_V[SolidImpact_sectionType] = Section_scale_V;
    
                        SolidImpact_sectionType = Section_Type;
                        SolidImpact_RES1 = Section_RES1;
                        SolidImpact_RES2 = Section_RES2;    
    
                        SOLARCHVISION_calculate_SolidImpact_selectedallSections();
    
                        SolarImpact_sectionType = Section_Type;          
    
                        WIN3D.update = true; 
                        ROLLOUT.update = true;
    
                      }                  
                    }
                  }
  
  

  
                  if (keep_number_of_allSolids != allSolids.DEF.length) { // if any Solid created during the process
  
                    selectedSolid_ids = new int [0];
  
                    for (int o = keep_number_of_allSolids; o < allSolids.DEF.length; o++) {
  
                      int[] newlyAddedSolid = {o};
  
                      selectedSolid_ids = concat(selectedSolid_ids, newlyAddedSolid);
                    }  
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 9_Solid");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                  }   
  
  
  
                  if (keep_number_of_allCameras != allCameras.num) { // if any Camera created during the process
  
                    selectedCamera_ids = new int [0];
  
                    for (int o = keep_number_of_allCameras; o < allCameras.num; o++) {
  
                      int[] newlyAddedCamera = {o};
  
                      selectedCamera_ids = concat(selectedCamera_ids, newlyAddedCamera);
                    }  
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 9_Camera");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                  }                   
  
  
                  if (keep_number_of_allGroups != allGroups.num) { // if any Group created during the process
  
                    selectedGroup_ids = new int [0];
  
                    for (int o = keep_number_of_allGroups; o < allGroups.num; o++) {
  
                      int[] newlyAddedGroup = {o};
  
                      selectedGroup_ids = concat(selectedGroup_ids, newlyAddedGroup);
                    }  
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 9_Group");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                  }   
  
                  if (keep_number_of_allModel2Ds != allModel2Ds.num) { // if any allModel2Ds created during the process
  
                    selectedallModel2Ds_ids = new int [0];
  
                    for (int o = keep_number_of_allModel2Ds; o < allModel2Ds.num; o++) {
  
                      int[] newlyAddedallModel2Ds = {o};
  
                      selectedallModel2Ds_ids = concat(selectedallModel2Ds_ids, newlyAddedallModel2Ds);
                    }  
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 9_allModel2Ds");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                  }   
  
  
                  if (keep_number_of_allModel1Ds != allModel1Ds.num) { // if any allModel1Ds created during the process
  
                    selectedallModel1Ds_ids = new int [0];
  
                    for (int o = keep_number_of_allModel1Ds; o < allModel1Ds.num; o++) {
  
                      int[] newlyAddedallModel1Ds = {o};
  
                      selectedallModel1Ds_ids = concat(selectedallModel1Ds_ids, newlyAddedallModel1Ds);
                    }  
  
                    println("SOLARCHVISION_calculate_selection_BoundingBox 9_allModel1Ds");
                    SOLARCHVISION_calculate_selection_BoundingBox();
                  }
                  
          
                  
                  
                }
              }          
  
              WIN3D.update = true;
            }
          }
        }

        ROLLOUT.update = true;

        redraw();
      }
    }
  }
}

int isInside (float x, float y, float x1, float y1, float x2, float y2) {
  if ((x1 < x) && (x < x2) && (y1 < y) && (y < y2)) return 1;
  else return 0;
} 















//---------------------------------------------------------------------


void SOLARCHVISION_download_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {

  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR;

/*
  String the_directory = getGrib2Folder(GRIB2_DomainSelection);
  {  
    String[] tmpMessage = {
      nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
    };
    saveStrings(the_directory + "/TempEmpty.txt", tmpMessage);
  }


  for (int h = 0; h < GRIB2_TGL_number; h++) {

    if (GRIB2_TGL_Selected[h] != 0) {

      for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
        GRIB2_Layer = l;

        for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
          GRIB2_Hour = k;

          boolean new_files_downloaded = false;

          String the_link = "";

          String the_filename = getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);

          String the_target = the_directory + "/" + the_filename;
          
          File dir = new File(the_target);
          if (!dir.isFile()) {

            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDWPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("HRDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }          
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("REPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GEPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }


            println("Try downloading: " + the_link);
        
            try {
              saveBytes(the_target, loadBytes(the_link));
            } 
            catch (Exception e) {
              println("LINK NOT AVAILABLE:", the_link);
            }

          }

        }
      }
    }
  }
*/
}




void SOLARCHVISION_load_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {


  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR; 

/*


  AERIAL_Data = new float [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Flags = new int [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Locations = new float [AERIAL_num][3]; // lon, lat, tgl
  AERIAL_Center_Longitude = STATION.getLongitude();
  AERIAL_Center_Latitude = STATION.getLatitude();

  for (int h = 0; h < GRIB2_TGL_number; h++) {
    GRIB2_TGL_Selected[h] = 0; // deselect all layers first.
  }

  for (int n = 0; n < AERIAL_num; n++) {
    for (int k = 0; k <= 48; k++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int o = 0; o < GRIB2_maxScenarios; o++) {   
          AERIAL_Data[k][l][n][o] = FLOAT_undefined;
          AERIAL_Flags[k][l][n][o] = -1;
        }
      }
    }  


    float stp_lat = 20.0 / 2224.5968; // equals to 1km <<<<<<<<
    float stp_lon = stp_lat / cos_ang(AERIAL_Center_Latitude); 


    float r1 = float(GRIB2_Domains[GRIB2_DomainSelection][5]);
    float r = 0; 
    float t = 0; 

    int p = n / (1 + 6 + 12);
    int q = n % (1 + 6 + 12);

    if ((q > 0) && (q <= 6)) {
      r = 1 * r1;
      t = 360 * q / 6.0;
    }  

    if ((q > 6) && (q <= 18)) {
      r = 2 * r1;
      t = 360 * (q - 6) / 12.0;
    }  

    if ((q > 18) && (q <= 36)) {
      r = 3 * r1;
      t = 360 * (q - 18) / 18.0;
    }  

    float _tgl = 40 * p;

    if (_tgl == 0) _tgl = 10; // <<<<<<  

    AERIAL_Locations[n][0] = AERIAL_Center_Longitude + stp_lon * r * cos_ang(t);
    AERIAL_Locations[n][1] = AERIAL_Center_Latitude + stp_lat * r * sin_ang(t);
    AERIAL_Locations[n][2] = _tgl;

    GRIB2_TGL_Selected[p] = 1;
  }  
    
    
  
  
  if (ENSEMBLE_FORECAST_load) {
  
    String the_directory = getGrib2Folder(GRIB2_DomainSelection);
    {  
      String[] tmpMessage = {
        nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
      };
      saveStrings(Wgrib2TempFolder + "/TempEmpty.txt", tmpMessage);
    }
  
  
    for (int h = 0; h < GRIB2_TGL_number; h++) {
  
      if (GRIB2_TGL_Selected[h] != 0) {
  
        for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
          GRIB2_Layer = l;
  
          for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
            GRIB2_Hour = k;
  
            boolean new_files_downloaded = false;
  
            String the_link = "";
  
            String the_target = the_directory + "/" + getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);
            
            File dir = new File(the_target);
            if (dir.isFile()) {
  
              float[][] Points = {
                {
                  0, 0, 0
                }
              };
  
              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
  
                if (p == h) {
  
                  float[][] newPoint = {
                    {
                      AERIAL_Locations[n][0], AERIAL_Locations[n][1], AERIAL_Locations[n][2]
                    }
                  };
                  Points = (float[][]) concat(Points, newPoint);
  
                }
              }
  
  
              float[][] GRIB2_values = getGrib2Value_MultiplePoints(GRIB2_Hour, GRIB2_Layer, h, Points, the_link);
  
              int nPoint = 0;
  
              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
  
                if (p == h) {
  
                  nPoint += 1;
  
                  for (int o = 0; o < GRIB2_maxScenarios; o++) {
                    AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] = GRIB2_values[nPoint][o];
                  }
                }
              }
            }
          }
        }
      }
    }
  
  

  
  
  
  
    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;
  
      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;
  
        for (int n = 0; n < AERIAL_num; n++) {
          for (int o = 0; o < GRIB2_maxScenarios; o++) {
            if (is_undefined_FLOAT(AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]) == false) {
              AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = 1;
            } else AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = -1;
          }
        }
      }
    }

    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;
  
      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;
  
        for (int n = 0; n < 1; n++) { // <<<<<<<<<<<<<<<< For now: only the first point (i.e. the center)
          for (int o = 0; o < GRIB2_maxScenarios; o++) {  
  
            int THE_YEAR = GRIB2_Year;
            int THE_MONTH = GRIB2_Month;
            int THE_DAY = GRIB2_Day;
            int THE_HOUR = GRIB2_ModelRun;
  
            int now_i = int(THE_HOUR);
            int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);
  
            now_i -= int(-STATION.getTimelong() / 15);
            if (now_i < 0) {
              now_i += 24;
              now_j -= 1;
              if (now_j < 0) {
                now_j += 365;
              }
            }          
  
            int next_i = now_i + k;
            int next_j = now_j;
            if (next_i >= 24) {
  
              next_j += int(next_i / 24);
              if (next_j >= 365) {
                next_j = next_j % 365;
              }
  
              next_i = next_i % 24;
            }
  
  
            ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o] = AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]; // <<<<<<<<<<< writing after member 43
  
            println(GRIB2_Domains[GRIB2_DomainSelection][0] + "[" + nf(o, 0) + "]:", ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o]);          
            println("GDPS:", ENSEMBLE_FORECAST_values[next_i][next_j][l][21]);
          }
        }
      }
    }


    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);
    
    Display_NAEFS_Points = 1;
    Display_NAEFS_Nearest = true;     
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d_update = true;    
  
  SampleMember_Start = 44; //ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;
  
  */
}












float[] SOLARCHVISION_calculate_Perspective_Internally (float x, float y, float z) {

  float Image_X = FLOAT_undefined;
  float Image_Y = FLOAT_undefined;
  float Image_Z = -FLOAT_undefined; // negative so that it automatically illuminated by Draw function 


  float px, py, pz;

  x -= WIN3D.CAM_x;
  y -= WIN3D.CAM_y;
  z += WIN3D.CAM_z;

  pz = z;
  px = x * cos_ang(-WIN3D.RZ_Coordinate) - y * sin_ang(-WIN3D.RZ_Coordinate);
  py = x * sin_ang(-WIN3D.RZ_Coordinate) + y * cos_ang(-WIN3D.RZ_Coordinate);

  x = px;
  y = py;
  z = pz;    

  px = x;
  py = y * cos_ang(WIN3D.RX_Coordinate) - z * sin_ang(WIN3D.RX_Coordinate);
  pz = y * sin_ang(WIN3D.RX_Coordinate) + z * cos_ang(WIN3D.RX_Coordinate);

  x = px;
  y = py;
  z = pz;


  if (z > 0) {
    if (WIN3D.ViewType == 1) {

      Image_X = (x / z) * (0.5 * WIN3D.scale / tan(0.5 * WIN3D.CAM_fov)) * WIN3D.refScale;
      Image_Y = -(y / z) * (0.5 * WIN3D.scale / tan(0.5 * WIN3D.CAM_fov)) * WIN3D.refScale;
      Image_Z = z;
    } else {

      float ZOOM = WIN3D.Orthographic_ZOOM();

      Image_X = (x / ZOOM) * (0.5 * WIN3D.scale);
      Image_Y = -(y / ZOOM) * (0.5 * WIN3D.scale);
      Image_Z = z;
    }
  }

  float[] theValues = {
    Image_X, Image_Y, Image_Z
  };

  return theValues;
}




void SOLARCHVISION_draw_Perspective_Internally () {

  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {    

    if (selectedLandPoint_displayPoints) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = selectedLandPoint_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedLandPoint_ids[o];


        int i = OBJ_NUM / Land3D.n_J;
        int j = OBJ_NUM % Land3D.n_J;

        float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
        float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
        float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }

      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    if (selectedCamera_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedCamera_ids.length - 1; o >= 0; o--) {

          int f = selectedCamera_ids[o];

          beginShape();

          for (int j = 0; j < allCameras.Faces[f].length; j++) {

            int vNo = allCameras.Faces[f][j];

            float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
            float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    if (selectedSection_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedSection_ids.length - 1; o >= 0; o--) {

          int f = selectedSection_ids[o];

          beginShape();

          for (int j = 0; j < allSections.Faces[f].length; j++) {

            int vNo = allSections.Faces[f][j];

            float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
            float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    if (selectedSolid_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedSolid_ids.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedSolid_ids[o];

          for (int plane_type = 0; plane_type < allSolids.numDisplayFaces; plane_type++) {          

            int f = OBJ_NUM * allSolids.numDisplayFaces + plane_type; 

            beginShape();

            for (int j = 0; j < allSolids.Faces[f].length; j++) {

              int vNo = allSolids.Faces[f][j];

              float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
              float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

      }


      strokeWeight(0);   

      popMatrix();
    }
  }  
  
  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    if (selectedallModel2Ds_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedallModel2Ds_ids[o];

          for (int plane_type = 0; plane_type < allModel2Ds.numDisplayFaces; plane_type++) {          

            int f = OBJ_NUM * allModel2Ds.numDisplayFaces + plane_type; 

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    if (selectedallModel1Ds_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {

          int f = selectedallModel1Ds_ids[o];

          beginShape();

          for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

            int vNo = allModel1Ds.Faces[f][j];

            float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
            float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);

        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }

  if (Current_ObjectCategory == ObjectCategory.FACE) {    

    if (selectedFace_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(127, 0, 255); 
      strokeWeight(2);

      for (int o = selectedFace_ids.length - 1; o >= 0; o--) {

        int f = selectedFace_ids[o];

        int Tessellation = allFaces.getTessellation(f);

        int TotalSubNo = 1;  
        if (allFaces.getMaterial(f) == 0) {
          Tessellation += allModel3Ds.Tessellation;
        }
        if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

        float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];
          base_Vertices[j][0] = allVertices[vNo][0];
          base_Vertices[j][1] = allVertices[vNo][1];
          base_Vertices[j][2] = allVertices[vNo][2];
        }

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

          beginShape();

          for (int s = 0; s < subFace.length; s++) {

            float x = subFace[s][0] * OBJECTS_scale;
            float y = subFace[s][1] * OBJECTS_scale;            
            float z = -subFace[s][2] * OBJECTS_scale;

            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }

      }

      strokeWeight(0);   

      popMatrix();
    }


    if (selectedFace_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      fill(0);

      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = selectedFace_ids.length - 1; o >= 0; o--) {

        int f = selectedFace_ids[o];

        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];

          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;            
          float z = -allVertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }
  
  
  if (Current_ObjectCategory == ObjectCategory.CURVE) {    

    if (selectedCurve_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      fill(0);

      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {

        int f = selectedCurve_ids[o];

        for (int j = 0; j < allCurves.nodes[f].length; j++) {
          int vNo = allCurves.nodes[f][j];

          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;            
          float z = -allVertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }


  if (Current_ObjectCategory == ObjectCategory.VERTEX) {    

    if (selectedVertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = selectedVertex_ids.length - 1; o >= 0; o--) {

        int vNo = selectedVertex_ids[o];

        float x = allVertices[vNo][0] * OBJECTS_scale;
        float y = allVertices[vNo][1] * OBJECTS_scale;
        float z = -allVertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  



  if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {    

    if (selectedVertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      strokeWeight(0);

      ellipseMode(CENTER);

      float R = 5;

      for (int q = 0; q < selectedVertex_softSelectionVertices.length; q++) {

        int vNo = selectedVertex_softSelectionVertices[q];

        float _u = selectedVertex_softSelectionValues[q];    

        float x = allVertices[vNo][0] * OBJECTS_scale;
        float y = allVertices[vNo][1] * OBJECTS_scale;
        float z = -allVertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) {

            float[] COL = PAINT.getColorStyle(14, _u); // <<<<<<<<<<<<<<<<<
            fill(COL[1], COL[2], COL[3], COL[0]);
            stroke(COL[1], COL[2], COL[3], COL[0]); 

            ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }
  }    



  if (Current_ObjectCategory == ObjectCategory.GROUP) {    

    if (selectedGroup_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(127); 
      strokeWeight(2);

      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedGroup_ids[o];


        for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allFaces.nodes.length)) { 

            int Tessellation = allFaces.getTessellation(f);

            int TotalSubNo = 1;  
            if (allFaces.getMaterial(f) == 0) {
              Tessellation += allModel3Ds.Tessellation;
            }
            if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allVertices[vNo][0];
              base_Vertices[j][1] = allVertices[vNo][1];
              base_Vertices[j][2] = allVertices[vNo][2];
            }

            for (int n = 0; n < TotalSubNo; n++) {

              float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

              beginShape();

              for (int s = 0; s < subFace.length; s++) {

                float x = subFace[s][0] * OBJECTS_scale;
                float y = subFace[s][1] * OBJECTS_scale;            
                float z = -subFace[s][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }


        for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allCurves.nodes.length)) { 

            beginShape();

            for (int vNo = 0; vNo < allCurves.nodes[f].length; vNo++) {

              float x = allVertices[vNo][0] * OBJECTS_scale;
              float y = allVertices[vNo][1] * OBJECTS_scale;            
              float z = -allVertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
        

        for (int f = allGroups.allModel1Ds[OBJ_NUM][0]; f <= allGroups.allModel1Ds[OBJ_NUM][1]; f++) {

          if ((0 <= f) && (f < allModel1Ds.Faces.length)) { 

            beginShape();

            for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

              int vNo = allModel1Ds.Faces[f][j];

              float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }


        for (int f = allGroups.allModel2Ds[OBJ_NUM][0]; f <= allGroups.allModel2Ds[OBJ_NUM][1]; f++) {

          if ((0 <= f) && (f < allModel2Ds.Faces.length)) { 

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

        for (int q = allGroups.allSolids[OBJ_NUM][0]; q <= allGroups.allSolids[OBJ_NUM][1]; q++) {

          if ((0 < q) && (q < allSolids.Faces.length)) {

            for (int plane_type = 0; plane_type < allSolids.numDisplayFaces; plane_type++) {          

              int f = (q - 1) * allSolids.numDisplayFaces + plane_type + 1; 

              if ((0 <= f) && (f < allSolids.Faces.length)) {               

                beginShape();

                for (int j = 0; j < allSolids.Faces[f].length; j++) {

                  int vNo = allSolids.Faces[f][j];

                  float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
                  float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
                  float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

                  float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                }

                endShape(CLOSE);
              }
            }
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }


    if (selectedGroup_displayBox) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(0, 127, 0, 127);
      strokeWeight(2);

      int keep_selection_alignX = selection_alignX;
      int keep_selection_alignY = selection_alignY;
      int keep_selection_alignZ = selection_alignZ;

      selection_alignX = 0; // apply the centre
      selection_alignY = 0; // apply the centre
      selection_alignZ = 0; // apply the centre

      float[] P = SOLARCHVISION_getPivot();

      float posX = P[0];
      float posY = P[1];
      float posZ = P[2];

      float posX_min = SOLARCHVISION_selection_BoundingBox[0][0];
      float posY_min = SOLARCHVISION_selection_BoundingBox[0][1];
      float posZ_min = SOLARCHVISION_selection_BoundingBox[0][2];

      float posX_max = SOLARCHVISION_selection_BoundingBox[2][0];
      float posY_max = SOLARCHVISION_selection_BoundingBox[2][1];
      float posZ_max = SOLARCHVISION_selection_BoundingBox[2][2];

      float[][] BoundingBox_Vertices = {
        {
          posX_min, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_max, posZ_max
        }
        , 
        {
          posX_min, posY_max, posZ_max
        }
      }; 


      for (int i = 0; i < BoundingBox_Vertices.length; i++) {

        float x = BoundingBox_Vertices[i][0] - posX;
        float y = BoundingBox_Vertices[i][1] - posY;
        float z = BoundingBox_Vertices[i][2] - posZ;

        float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2]; 

        BoundingBox_Vertices[i][0] = x;
        BoundingBox_Vertices[i][1] = y;
        BoundingBox_Vertices[i][2] = z;
      }                                     

      int[][] BoundingBox_Faces = {
        {
          3, 2, 1, 0
        }
        , {
          0, 1, 5, 4
        }
        , {
          1, 2, 6, 5
        }
        , {
          2, 3, 7, 6
        }
        , {
          3, 0, 4, 7
        }
        , {
          4, 5, 6, 7
        }
      };

      for (int f = 0; f < BoundingBox_Faces.length; f++) {

        beginShape();

        for (int g = 0; g < BoundingBox_Faces[f].length; g++) {

          int vNo = BoundingBox_Faces[f][g];

          float x = BoundingBox_Vertices[vNo][0] * OBJECTS_scale;
          float y = BoundingBox_Vertices[vNo][1] * OBJECTS_scale;            
          float z = -BoundingBox_Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
          }
        }
        endShape(CLOSE);
      }

      strokeWeight(0);   

      popMatrix();


      selection_alignX = keep_selection_alignX;
      selection_alignY = keep_selection_alignY;
      selection_alignZ = keep_selection_alignZ;
    }  




    if (selectedGroup_displayPivot) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0, 127); 

      strokeWeight(5);

      for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedGroup_ids[o];

        float[][] Pivot_Vertices = {
          {
            0, 0, 0
          }
          , 
          {
            1, 0, 0
          }
          , 
          {
            0, 1, 0
          }
          , 
          {
            0, 0, 1
          }
        }; 


        float x0 = allGroups.PivotXYZ[OBJ_NUM][0];
        float y0 = allGroups.PivotXYZ[OBJ_NUM][1];
        float z0 = allGroups.PivotXYZ[OBJ_NUM][2];

        for (int i = 0; i < Pivot_Vertices.length; i++) {

          float x = Pivot_Vertices[i][0];
          float y = Pivot_Vertices[i][1];
          float z = Pivot_Vertices[i][2];

          float r = 10; // <<<<<<<<< display size

          x *= r;
          y *= r;
          z *= r;

          float[] O = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
          float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          float dx = A[0] - O[0];
          float dy = A[1] - O[1];
          float dz = A[2] - O[2];

          Pivot_Vertices[i][0] = x0 + dx;
          Pivot_Vertices[i][1] = y0 + dy;
          Pivot_Vertices[i][2] = z0 + dz;
        }


        int[][] Pivot_Lines = {
          {
            0, 1
          }
          , {
            0, 2
          }
          , {
            0, 3
          }
        };

        int f_start = 0;
        int f_end = Pivot_Lines.length - 1;

        if (allGroups.PivotType[OBJ_NUM][0] == 1) {
          f_start = 0; 
          f_end = f_start;
        }
        if (allGroups.PivotType[OBJ_NUM][0] == 2) {
          f_start = 1; 
          f_end = f_start;
        }
        if (allGroups.PivotType[OBJ_NUM][0] == 3) {
          f_start = 2; 
          f_end = f_start;
        }

        for (int f = f_start; f <= f_end; f++) {

          int a = Pivot_Lines[f][0];
          int b = Pivot_Lines[f][1];

          float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
          float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
          float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

          float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
          float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
          float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

          float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1, y1, z1);            
          float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2, y2, z2);

          if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
                line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
              }
            }
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }
  }



  if (selected_displayReferencePivot) {

    pushMatrix();

    translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

    noFill();

    strokeWeight(2);

    float[][] Pivot_Vertices = {
      {
        0, 0, 0
      }
      , 
      {
        1, 0, 0
      }
      , 
      {
        0, 1, 0
      }
      , 
      {
        0, 0, 1
      }
    }; 

    float[] P = SOLARCHVISION_getPivot();

    float x0 = P[0];
    float y0 = P[1];
    float z0 = P[2];

    for (int i = 0; i < Pivot_Vertices.length; i++) {

      float x = Pivot_Vertices[i][0];
      float y = Pivot_Vertices[i][1];
      float z = Pivot_Vertices[i][2];

      float r = 5; // <<<<<<<<< display size

      x *= r;
      y *= r;
      z *= r;

      float[] O = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
      float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      float dx = A[0] - O[0];
      float dy = A[1] - O[1];
      float dz = A[2] - O[2];

      Pivot_Vertices[i][0] = x0 + dx;
      Pivot_Vertices[i][1] = y0 + dy;
      Pivot_Vertices[i][2] = z0 + dz;
    }

    int[][] Pivot_Lines = {
      {
        0, 1
      }
      , {
        0, 2
      }
      , {
        0, 3
      }
    };


    for (int f = 0; f < Pivot_Lines.length; f++) {

      if (f == 0) stroke(255, 0, 0);
      if (f == 1) stroke(0, 0, 255);
      if (f == 2) stroke(127, 127, 0);

      int a = Pivot_Lines[f][0];
      int b = Pivot_Lines[f][1];

      float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
      float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
      float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

      float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
      float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
      float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

      float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1, y1, z1);            
      float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2, y2, z2);

      if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
          if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
            line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
          }
        }
      }
    }

    strokeWeight(0);   

    popMatrix();
  }
}






float[] SOLARCHVISION_calculate_Click3D (float Image_X, float Image_Y) {

  float PNT_x = FLOAT_undefined;
  float PNT_y = FLOAT_undefined;
  float PNT_z = FLOAT_undefined;

  if (WIN3D.ViewType == 1) {

    PNT_z = 0.5/ tan(0.5 * PI / 3.0); //100; // for perspective: any value the plane we need the results on!

    PNT_x = PNT_z * Image_X / ((0.5 * WIN3D.scale / tan(0.5 * WIN3D.CAM_fov)) * WIN3D.refScale);
    PNT_y = PNT_z * -Image_Y / ((0.5 * WIN3D.scale / tan(0.5 * WIN3D.CAM_fov)) * WIN3D.refScale);
  } else {
    float ZOOM = WIN3D.Orthographic_ZOOM();

    PNT_z = (0.5 * WIN3D.refScale) / tan(0.5 * PI / 3.0); // for orthographic: should be this.

    PNT_x = ZOOM * Image_X / (0.5 * WIN3D.scale);
    PNT_y = ZOOM * -Image_Y / (0.5 * WIN3D.scale);
  }

  float px, py, pz;

  px = PNT_x;
  py = PNT_y * cos_ang(-WIN3D.RX_Coordinate) - PNT_z * sin_ang(-WIN3D.RX_Coordinate);
  pz = PNT_y * sin_ang(-WIN3D.RX_Coordinate) + PNT_z * cos_ang(-WIN3D.RX_Coordinate);

  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;

  pz = PNT_z;
  px = PNT_x * cos_ang(WIN3D.RZ_Coordinate) - PNT_y * sin_ang(WIN3D.RZ_Coordinate);
  py = PNT_x * sin_ang(WIN3D.RZ_Coordinate) + PNT_y * cos_ang(WIN3D.RZ_Coordinate);

  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;    

  PNT_x += WIN3D.CAM_x;
  PNT_y += WIN3D.CAM_y;
  PNT_z -= WIN3D.CAM_z;  

  float[] return_array = {
    PNT_x, PNT_y, -PNT_z
  };

  return return_array;
}







String NearLatitude_Stamp () {

  int Round_Latitude = int(roundTo(STATION.getLatitude(), 5));
  if (Round_Latitude > 70) Round_Latitude = 70; // <<<<<<<<<<<<<<<
  if (Round_Latitude < -45) Round_Latitude = -45; // <<<<<<<<<<<<<<<

  String a = nf(abs(Round_Latitude), 2);

  if (Round_Latitude < 0) a += "S";
  else a += "N";

  return a;
}



String Section_Stamp () {

  String s = "";

  s += "t" + nf(SolidImpact_sectionType, 0);
  s += "u" + nf(SolarImpact_offset_U, 0, 3);
  s += "v" + nf(SolarImpact_offset_V, 0, 3);
  s += "w" + nf(SolarImpact_Elevation, 0, 3);
  s += "r" + nf(SolarImpact_Rotation, 0, 3);  

  s = s.replace('.', 'p');
  s = s.replace('-', 'n');

  return s;
}


String Viewport_Stamp () {

  String s = "";
  
  /*

  s += "x" + nf(WIN3D.X_Coordinate, 0, 3);
  s += "y" + nf(WIN3D.Y_Coordinate, 0, 3);
  s += "z" + nf(WIN3D.Z_Coordinate, 0, 3);

  s += "rx" + nf(WIN3D.RX_Coordinate, 0, 3);
  s += "ry" + nf(WIN3D.RY_Coordinate, 0, 3);
  s += "rz" + nf(WIN3D.RZ_Coordinate, 0, 3);
  
  s = s.replace('.', 'p');
  s = s.replace('-', 'n');
  
  */

  return s;
}


PGraphics SHADOW_graphics; // to be accessible to allModel1Ds plants



void SOLARCHVISION_render_Shadows_CurrentSection () {

  cursor(WAIT);  

  SceneName = "Section_" + Section_Stamp();


  int RES1 = SolarImpact_RES1;
  int RES2 = SolarImpact_RES2;

  float Shades_scaleX = RES1 / SolarImpact_scale_U;
  float Shades_scaleY = RES2 / SolarImpact_scale_V;

  float Shades_offsetX = SolarImpact_offset_U;
  float Shades_offsetY = SolarImpact_offset_V; 


  SHADOW_graphics = createGraphics(RES1, RES2, P2D); 

  PGraphics TREES_graphics = createGraphics(RES1, RES2, P2D);

  int keep_SolarImpact_sectionType = SolarImpact_sectionType;
  float keep_SolarImpact_Rotation = SolarImpact_Rotation;

  if (SolarImpact_sectionType == 3) {
    SolarImpact_sectionType = 2;
    SolarImpact_Rotation = 90 - SolarImpact_Rotation;
  }

  {  
    int RAD_TYPE = 0;

    for (int DATE_ANGLE = 0; DATE_ANGLE < 360; DATE_ANGLE += 15) {

      //for (int i = 0; i < 24; i++) {
      for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not needed out of this period.

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);

          SunR_Rotated_check = 2;
        } else if (SolarImpact_sectionType == 3) {
        }

        for (int SHD = 0; SHD <= 1; SHD++) {

          String[] STR_SHD = {
            "F", "T"
          };
          String File_Name = ShadingFolder + "/" + NearLatitude_Stamp() + "/" + SceneName;

          File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);

          File_Name += "_Camera00";

          TREES_graphics.beginDraw();

          TREES_graphics.blendMode(REPLACE);

          TREES_graphics.fill(255); 
          TREES_graphics.stroke(255);
          TREES_graphics.strokeWeight(0);
          TREES_graphics.rectMode(CORNER);
          TREES_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            TREES_graphics.pushMatrix();
            TREES_graphics.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

            TREES_graphics.stroke(0); 
            TREES_graphics.fill(0);     

            TREES_graphics.blendMode(BLEND);        

            if (Display_allModel2Ds) {

              for (int f = 0; f < allModel2Ds.num; f++) {

                int n = abs(allModel2Ds.MAP[f]);

                int w = allModel2Ds.Images[n].width; 
                int h = allModel2Ds.Images[n].height;

                float r = allModel2Ds.getS(f) * 0.5;

                float t = atan2(SunR[2], SunR[1]) + 0.5 * PI; 

                if (allModel2Ds.MAP[f] < 0) t += PI;         

                if (r > 2.5) { // to select only trees!               

                  float x = 0, y = 0, z = 0;

                  { // Vertical mask
                    TREES_graphics.beginShape();

                    TREES_graphics.texture(allModel2Ds.Images[n]); 

                    x = allModel2Ds.getX(f);
                    y = allModel2Ds.getY(f);
                    z = allModel2Ds.getZ(f);

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z; 
                    TX[2] = x + r * cos(t); 
                    TY[2] = y + r * sin(t); 
                    TZ[2] = z + 2 * r; 
                    TX[3] = x - r * cos(t); 
                    TY[3] = y - r * sin(t); 
                    TZ[3] = z + 2 * r;            

                    TU[0] = 0; 
                    TV[0] = h;
                    TU[1] = w; 
                    TV[1] = h;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (SolarImpact_sectionType == 2) {
                      {
                        for (int q = 0; q < 4; q++) {
                          float a = TX[q];
                          float b = -TY[q];
                          float c = TZ[q];

                          TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                          TY[q] = c;
                          TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                        }
                      } 
                      { // now that we rotated 2D we could rotate x,y,z
                        float a = x;
                        float b = -y;
                        float c = z;

                        x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        y = c;
                        z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }
                    } else if (SolarImpact_sectionType == 3) {
                    }

                    if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {

                      float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                      TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                      TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                      if (SolarImpact_sectionType == 1) {

                        TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                        TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                      } else if (SolarImpact_sectionType == 2) {

                        TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                        TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }

                    if (TZ[2] > SolarImpact_Elevation) {

                      for (int q = 0; q < 4; q++) {

                        TZ[q] = TZ[q] - SolarImpact_Elevation;
                        TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                        TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                        if (SolarImpact_sectionType == 1) {
                          float px = TX[q];
                          float py = TY[q];

                          TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                          

                        TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                      }
                    }

                    TREES_graphics.endShape(CLOSE);
                  }

                  { // Horizontal mask
                    float ratio = 0.5; // put the mask at half of the height of the tree 

                    for (int back_front = -1; back_front <= 1; back_front += 2) {

                      float rot = back_front * PI / 2 + t;

                      TREES_graphics.beginShape();

                      TREES_graphics.texture(allModel2Ds.Images[n]); 

                      x = allModel2Ds.getX(f);
                      y = allModel2Ds.getY(f);
                      z = allModel2Ds.getZ(f);                      

                      float[] TX = {
                        0, 0, 0, 0
                      };
                      float[] TY = {
                        0, 0, 0, 0
                      };
                      float[] TZ = {
                        0, 0, 0, 0
                      };
                      float[] TU = {
                        0, 0, 0, 0
                      };
                      float[] TV = {
                        0, 0, 0, 0
                      };

                      TX[0] = x - r * cos(t); 
                      TY[0] = y - r * sin(t); 
                      TZ[0] = z + 2 * r * ratio; 
                      TX[1] = x + r * cos(t); 
                      TY[1] = y + r * sin(t); 
                      TZ[1] = z + 2 * r * ratio; 
                      TX[2] = x + r * cos(t) + r * cos(rot); 
                      TY[2] = y + r * sin(t) + r * sin(rot); 
                      TZ[2] = z + 2 * r * ratio; 
                      TX[3] = x - r * cos(t) + r * cos(rot); 
                      TY[3] = y - r * sin(t) + r * sin(rot); 
                      TZ[3] = z + 2 * r * ratio;    

                      TU[0] = 0; 
                      TV[0] = h * ratio;
                      TU[1] = w; 
                      TV[1] = h * ratio;
                      TU[2] = w; 
                      TV[2] = 0;
                      TU[3] = 0; 
                      TV[3] = 0;   

                      if (SolarImpact_sectionType == 1) {

                        if (z + 2 * r * ratio > SolarImpact_Elevation) {

                          for (int q = 0; q < 4; q++) {

                            TZ[q] = TZ[q] - SolarImpact_Elevation;
                            TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                            TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);  

                            if (SolarImpact_sectionType == 1) {
                              float px = TX[q];
                              float py = TY[q];

                              TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            }                            

                            TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                          }
                        }
                      }

                      TREES_graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }

            TREES_graphics.popMatrix();
          }


          TREES_graphics.endDraw();     

          TREES_graphics.save(File_Name + "_2D.JPG");



          SHADOW_graphics.beginDraw();

          SHADOW_graphics.blendMode(REPLACE);

          float _val = 0;
          if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
          SHADOW_graphics.fill(255 * _val); 
          SHADOW_graphics.stroke(255 * _val);
          SHADOW_graphics.strokeWeight(0);
          SHADOW_graphics.rectMode(CORNER);
          SHADOW_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            SHADOW_graphics.pushMatrix();
            SHADOW_graphics.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

            SHADOW_graphics.stroke(0); 
            SHADOW_graphics.fill(0);              

            if (Display_allModel3Ds) {

              for (int f = 0; f < allFaces.nodes.length; f++) {
  
                int vsb = allFaces.getVisibility(f);
  
                if (vsb > 0) {
  
                  int  mt = allFaces.getMaterial(f);
                  if (Materials_Color[mt][0] > 127) {
  
                    int Tessellation = allFaces.getTessellation(f);
  
                    int TotalSubNo = 1;  
                    if (allFaces.getMaterial(f) == 0) {
                      Tessellation += allModel3Ds.Tessellation;
                    }
                    if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
                    float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                    for (int g = 0; g < allFaces.nodes[f].length; g++) {
                      int vNo = allFaces.nodes[f][g];
                      base_Vertices[g][0] = allVertices[vNo][0];
                      base_Vertices[g][1] = allVertices[vNo][1];
                      base_Vertices[g][2] = allVertices[vNo][2];
                    }
  
                    for (int n = 0; n < TotalSubNo; n++) {
  
                      float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                      float[][] subFace_Rotated = subFace;
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
                        if (SolarImpact_sectionType == 2) {
                          float a = subFace_Rotated[s][0];
                          float b = -subFace_Rotated[s][1];
                          float c = subFace_Rotated[s][2];
  
                          subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                          subFace_Rotated[s][1] = c;    
                          subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                        } else if (SolarImpact_sectionType == 3) {
                        }
                      }  
  
                      SHADOW_graphics.beginShape();
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
  
                        float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                        float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                        float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
  
  
                        if (z >= 0) {
  
                          if (SolarImpact_sectionType == 1) {                    
                            float px = x;
                            float py = y;
  
                            x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 
  
                          SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                        } else {
                          int s_next = (s + 1) % subFace_Rotated.length;
                          int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                          float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                          float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_prev > 0) { 
                            float ratio = z_prev / (z_prev - z);
  
                            float x_trim = x_prev * (1 - ratio) + x * ratio;
                            float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                            if (SolarImpact_sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            } 
  
                            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
  
                          float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                          float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_next > 0) { 
                            float ratio = z_next / (z_next - z);
  
                            float x_trim = x_next * (1 - ratio) + x * ratio;
                            float y_trim = y_next * (1 - ratio) + y * ratio;
  
                            if (SolarImpact_sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            } 
  
                            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
                        }
                      }
  
                      SHADOW_graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }
            

            if (Land3D.Display_Surface) {
              
              int Tessellation = Land3D.Tessellation;
              if (WIN3D.FacesShade == SHADE.Surface_Base) {
                Tessellation = 0;
              }
        
              int TotalSubNo = 1;  
              if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
        
        
              for (int Li = Land3D.Surface_SkipStart; Li < Land3D.n_I - 1 - Land3D.Surface_SkipEnd; Li++) {
                for (int Lj = 0; Lj < Land3D.n_J - 1; Lj++) {
        
                  float[][] base_Vertices = new float [4][3];
        
                  base_Vertices[0][0] = Land3D.Mesh[Li][Lj][0];
                  base_Vertices[0][1] = Land3D.Mesh[Li][Lj][1];
                  base_Vertices[0][2] = Land3D.Mesh[Li][Lj][2];
        
                  base_Vertices[1][0] = Land3D.Mesh[Li+1][Lj][0];
                  base_Vertices[1][1] = Land3D.Mesh[Li+1][Lj][1];
                  base_Vertices[1][2] = Land3D.Mesh[Li+1][Lj][2];
        
                  base_Vertices[2][0] = Land3D.Mesh[Li+1][Lj+1][0];
                  base_Vertices[2][1] = Land3D.Mesh[Li+1][Lj+1][1];
                  base_Vertices[2][2] = Land3D.Mesh[Li+1][Lj+1][2];
        
                  base_Vertices[3][0] = Land3D.Mesh[Li][Lj+1][0];
                  base_Vertices[3][1] = Land3D.Mesh[Li][Lj+1][1];
                  base_Vertices[3][2] = Land3D.Mesh[Li][Lj+1][2];        
        
                  for (int n = 0; n < TotalSubNo; n++) {

                    float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;

                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (SolarImpact_sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];

                        subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                        subFace_Rotated[s][1] = c;    
                        subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }  

                    SHADOW_graphics.beginShape();

                    for (int s = 0; s < subFace_Rotated.length; s++) {

                      float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                      if (z >= 0) {

                        if (SolarImpact_sectionType == 1) {                    
                          float px = x;
                          float py = y;

                          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                        float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);

                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;

                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 

                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }

                        float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);

                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;

                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 

                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }

                    SHADOW_graphics.endShape(CLOSE);
                  }
                }
              }
            }
            
            

            //now calculating allModel1Ds plants
            if (Display_allModel1Ds) {

              for (int f = 0; f < allModel1Ds.num; f++) {

                float x = allModel1Ds.getX(f);
                float y = allModel1Ds.getY(f);
                float z = allModel1Ds.getZ(f);

                float r = allModel1Ds.getS(f) * 0.5;
                float rot = allModel1Ds.getR(f);      

                int n = allModel1Ds.getType(f);

                int dMin = allModel1Ds.getDegreeMin(f);

                int dMax = allModel1Ds.getDegreeMax(f);

                int s = allModel1Ds.getSeed(f);

                float TrunkSize = allModel1Ds.getTrunkSize(f);

                float LeafSize = allModel1Ds.getLeafSize(f);

                randomSeed(s);

                if (n == 0) {

                  float Alpha = 0;
                  float Beta = rot; 

                  allModel1Ds.branch_shadow(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
                }
              }
            }            

            SHADOW_graphics.popMatrix();
          }


          SHADOW_graphics.save(File_Name + "3D_.JPG"); //just to test   

          if (Display_allModel2Ds) {

            PImage img = loadImage(File_Name + "_2D.JPG");

            img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

            SHADOW_graphics.blendMode(DARKEST); 

            SHADOW_graphics.tint(255, 255);

            SHADOW_graphics.image(img, 0, 0, RES1, RES2);

            SHADOW_graphics.noTint();
          }  

          SHADOW_graphics.endDraw();        


          SHADOW_graphics.save(File_Name + ".PNG");
        }
      }
    }
  }


  {
    int RAD_TYPE = 1;

    for (int SHD = 0; SHD <= 1; SHD++) {

      String[] STR_SHD = {
        "F", "T"
      };
      String File_Name = ShadingFolder + "/" + NearLatitude_Stamp() + "/" + SceneName;

      File_Name += "DIF_" + STR_SHD[SHD];

      for (int i = 0; i < DiffuseVectors.length; i++) {

        float[] SunR= {
          0, DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
        };

        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);

          SunR_Rotated_check = 2;
        } else if (SolarImpact_sectionType == 3) {
        }


        //------------------------------------ start of copy & paste from the direct version!
        TREES_graphics.beginDraw();

        TREES_graphics.blendMode(REPLACE);

        TREES_graphics.fill(255); 
        TREES_graphics.stroke(255);
        TREES_graphics.strokeWeight(0);
        TREES_graphics.rectMode(CORNER);
        TREES_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          TREES_graphics.pushMatrix();
          TREES_graphics.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

          TREES_graphics.stroke(0); 
          TREES_graphics.fill(0);     

          TREES_graphics.blendMode(BLEND);        

          if (Display_allModel2Ds) {

            for (int f = 0; f < allModel2Ds.num; f++) {

              int n = abs(allModel2Ds.MAP[f]);

              int w = allModel2Ds.Images[n].width; 
              int h = allModel2Ds.Images[n].height;

              float r = allModel2Ds.getS(f) * 0.5;

              float t = atan2(SunR[2], SunR[1]) + 0.5 * PI;

              if (allModel2Ds.MAP[f] < 0) t += PI;         

              if (r > 2.5) { // to select only trees!               

                float x = allModel2Ds.getX(f);
                float y = allModel2Ds.getY(f);
                float z = allModel2Ds.getZ(f);

                { // Vertical mask
                  TREES_graphics.beginShape();

                  TREES_graphics.texture(allModel2Ds.Images[n]); 

                  x = allModel2Ds.getX(f);
                  y = allModel2Ds.getY(f);
                  z = allModel2Ds.getZ(f);

                  float[] TX = {
                    0, 0, 0, 0
                  };
                  float[] TY = {
                    0, 0, 0, 0
                  };
                  float[] TZ = {
                    0, 0, 0, 0
                  };
                  float[] TU = {
                    0, 0, 0, 0
                  };
                  float[] TV = {
                    0, 0, 0, 0
                  };

                  TX[0] = x - r * cos(t); 
                  TY[0] = y - r * sin(t); 
                  TZ[0] = z; 
                  TX[1] = x + r * cos(t); 
                  TY[1] = y + r * sin(t); 
                  TZ[1] = z; 
                  TX[2] = x + r * cos(t); 
                  TY[2] = y + r * sin(t); 
                  TZ[2] = z + 2 * r; 
                  TX[3] = x - r * cos(t); 
                  TY[3] = y - r * sin(t); 
                  TZ[3] = z + 2 * r;            

                  TU[0] = 0; 
                  TV[0] = h;
                  TU[1] = w; 
                  TV[1] = h;
                  TU[2] = w; 
                  TV[2] = 0;
                  TU[3] = 0; 
                  TV[3] = 0;   

                  if (SolarImpact_sectionType == 2) {
                    {
                      for (int q = 0; q < 4; q++) {
                        float a = TX[q];
                        float b = -TY[q];
                        float c = TZ[q];

                        TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        TY[q] = c;
                        TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }
                    } 
                    { // now that we rotated 2D we could rotate x,y,z
                      float a = x;
                      float b = -y;
                      float c = z;

                      x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                      y = c;
                      z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                    }
                  } else if (SolarImpact_sectionType == 3) {
                  }

                  if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {

                    float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                    TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                    TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                    if (SolarImpact_sectionType == 1) {

                      TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                      TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                    } else if (SolarImpact_sectionType == 2) {

                      TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                      TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                    } else if (SolarImpact_sectionType == 3) {
                    }
                  }

                  if (TZ[2] > SolarImpact_Elevation) {

                    for (int q = 0; q < 4; q++) {

                      TZ[q] = TZ[q] - SolarImpact_Elevation;
                      TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                      TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                      if (SolarImpact_sectionType == 1) {
                        float px = TX[q];
                        float py = TY[q];

                        TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      }                          

                      TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                    }
                  }

                  TREES_graphics.endShape(CLOSE);
                }

                { // Horizontal mask
                  float ratio = 0.5; // put the mask at half of the height of the tree 

                  for (int back_front = -1; back_front <= 1; back_front += 2) {

                    float rot = back_front * PI / 2 + t;

                    TREES_graphics.beginShape();

                    TREES_graphics.texture(allModel2Ds.Images[n]); 

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z + 2 * r * ratio; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z + 2 * r * ratio; 
                    TX[2] = x + r * cos(t) + r * cos(rot); 
                    TY[2] = y + r * sin(t) + r * sin(rot); 
                    TZ[2] = z + 2 * r * ratio; 
                    TX[3] = x - r * cos(t) + r * cos(rot); 
                    TY[3] = y - r * sin(t) + r * sin(rot); 
                    TZ[3] = z + 2 * r * ratio;    

                    TU[0] = 0; 
                    TV[0] = h * ratio;
                    TU[1] = w; 
                    TV[1] = h * ratio;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (SolarImpact_sectionType == 1) {
                      if (z + 2 * r * ratio > SolarImpact_Elevation) {

                        for (int q = 0; q < 4; q++) {

                          TZ[q] = TZ[q] - SolarImpact_Elevation;
                          TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                          TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);                  

                          if (SolarImpact_sectionType == 1) {
                            float px = TX[q];
                            float py = TY[q];

                            TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }      

                          TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                        }
                      }
                    }

                    TREES_graphics.endShape(CLOSE);
                  }
                }
              }
            }
          }

          TREES_graphics.popMatrix();
        }


        TREES_graphics.endDraw();
        //------------------------------------ end of copy & paste from the direct version!

        TREES_graphics.save(File_Name + nf(i, 3) + "_2D.JPG");



        SHADOW_graphics.beginDraw();

        SHADOW_graphics.blendMode(REPLACE);

        float _val = 0;
        if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
        SHADOW_graphics.fill(255 * _val); 
        SHADOW_graphics.stroke(255 * _val);
        SHADOW_graphics.strokeWeight(0);
        SHADOW_graphics.rectMode(CORNER);
        SHADOW_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          SHADOW_graphics.pushMatrix();
          SHADOW_graphics.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

          SHADOW_graphics.stroke(0); 
          SHADOW_graphics.fill(0);
          
          if (Display_allModel3Ds) {

            for (int f = 0; f < allFaces.nodes.length; f++) {
  
              int vsb = allFaces.getVisibility(f);
  
              if (vsb > 0) {
  
                int  mt = allFaces.getMaterial(f);            
                if (Materials_Color[mt][0] > 127) {
  
                  int Tessellation = allFaces.getTessellation(f);
  
                  int TotalSubNo = 1;  
                  if (allFaces.getMaterial(f) == 0) {
                    Tessellation += allModel3Ds.Tessellation;
                  }
                  if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
                  float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                  for (int g = 0; g < allFaces.nodes[f].length; g++) {
                    int vNo = allFaces.nodes[f][g];
                    base_Vertices[g][0] = allVertices[vNo][0];
                    base_Vertices[g][1] = allVertices[vNo][1];
                    base_Vertices[g][2] = allVertices[vNo][2];
                  }
  
                  for (int n = 0; n < TotalSubNo; n++) {
  
                    float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (SolarImpact_sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];
  
                        subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                        subFace_Rotated[s][1] = c;      
                        subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }                
  
                    SHADOW_graphics.beginShape();
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
  
                      float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
                      if (z >= 0) {
  
                        if (SolarImpact_sectionType == 1) {
                          float px = x;
                          float py = y;
  
                          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                   
  
                        SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                        float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];       
  
                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);
  
                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }                     
  
                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
  
                        float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);
  
                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;
  
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }                     
  
                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }
  
                    SHADOW_graphics.endShape(CLOSE);
                  }
                }
              }
            }
          }
          
          
          if (Land3D.Display_Surface) {
            
            int Tessellation = Land3D.Tessellation;
            if (WIN3D.FacesShade == SHADE.Surface_Base) {
              Tessellation = 0;
            }
      
            int TotalSubNo = 1;  
            if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
      
      
            for (int Li = Land3D.Surface_SkipStart; Li < Land3D.n_I - 1 - Land3D.Surface_SkipEnd; Li++) {
              for (int Lj = 0; Lj < Land3D.n_J - 1; Lj++) {
      
                float[][] base_Vertices = new float [4][3];
      
                base_Vertices[0][0] = Land3D.Mesh[Li][Lj][0];
                base_Vertices[0][1] = Land3D.Mesh[Li][Lj][1];
                base_Vertices[0][2] = Land3D.Mesh[Li][Lj][2];
      
                base_Vertices[1][0] = Land3D.Mesh[Li+1][Lj][0];
                base_Vertices[1][1] = Land3D.Mesh[Li+1][Lj][1];
                base_Vertices[1][2] = Land3D.Mesh[Li+1][Lj][2];
      
                base_Vertices[2][0] = Land3D.Mesh[Li+1][Lj+1][0];
                base_Vertices[2][1] = Land3D.Mesh[Li+1][Lj+1][1];
                base_Vertices[2][2] = Land3D.Mesh[Li+1][Lj+1][2];
      
                base_Vertices[3][0] = Land3D.Mesh[Li][Lj+1][0];
                base_Vertices[3][1] = Land3D.Mesh[Li][Lj+1][1];
                base_Vertices[3][2] = Land3D.Mesh[Li][Lj+1][2];        
      
                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                  float[][] subFace_Rotated = subFace;

                  for (int s = 0; s < subFace_Rotated.length; s++) {
                    if (SolarImpact_sectionType == 2) {
                      float a = subFace_Rotated[s][0];
                      float b = -subFace_Rotated[s][1];
                      float c = subFace_Rotated[s][2];

                      subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                      subFace_Rotated[s][1] = c;    
                      subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                    } else if (SolarImpact_sectionType == 3) {
                    }
                  }  

                  SHADOW_graphics.beginShape();

                  for (int s = 0; s < subFace_Rotated.length; s++) {

                    float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                    float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                    float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                    if (z >= 0) {

                      if (SolarImpact_sectionType == 1) {                    
                        float px = x;
                        float py = y;

                        x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      } 

                      SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                    } else {
                      int s_next = (s + 1) % subFace_Rotated.length;
                      int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                      float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                      float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_prev > 0) { 
                        float ratio = z_prev / (z_prev - z);

                        float x_trim = x_prev * (1 - ratio) + x * ratio;
                        float y_trim = y_prev * (1 - ratio) + y * ratio;

                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }

                      float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                      float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_next > 0) { 
                        float ratio = z_next / (z_next - z);

                        float x_trim = x_next * (1 - ratio) + x * ratio;
                        float y_trim = y_next * (1 - ratio) + y * ratio;

                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }
                    }
                  }

                  SHADOW_graphics.endShape(CLOSE);
                }
              }
            }
          }          

          //now calculating allModel1Ds plants
          if (Display_allModel1Ds) {

            for (int f = 0; f < allModel1Ds.num; f++) {

              float x = allModel1Ds.getX(f);
              float y = allModel1Ds.getY(f);
              float z = allModel1Ds.getZ(f);

              float r = allModel1Ds.getS(f) * 0.5;
              float rot = allModel1Ds.getR(f);      

              int n = allModel1Ds.getType(f);

              int dMin = allModel1Ds.getDegreeMin(f);

              int dMax = allModel1Ds.getDegreeMax(f);

              int s = allModel1Ds.getSeed(f);

              float TrunkSize = allModel1Ds.getTrunkSize(f);

              float LeafSize = allModel1Ds.getLeafSize(f);

              randomSeed(s);

              if (n == 0) {

                float Alpha = 0;
                float Beta = rot; 

                allModel1Ds.branch_shadow(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
              }
            }
          }          

          SHADOW_graphics.popMatrix();
        }

        SHADOW_graphics.save(File_Name + "3D_.JPG"); //just to test   

        if (Display_allModel2Ds) {

          PImage img = loadImage(File_Name + nf(i, 3) + "_2D.JPG");

          img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

          SHADOW_graphics.blendMode(DARKEST); 

          SHADOW_graphics.tint(255, 255);

          SHADOW_graphics.image(img, 0, 0, RES1, RES2);

          SHADOW_graphics.noTint();
        }  

        SHADOW_graphics.endDraw();    

        SHADOW_graphics.save(File_Name + nf(i, 3) + ".JPG");
      }



      PGraphics DIFFUSE_graphics = createGraphics(RES1, RES2, P2D);    

      DIFFUSE_graphics.beginDraw();

      DIFFUSE_graphics.blendMode(REPLACE);

      DIFFUSE_graphics.fill(0); 
      DIFFUSE_graphics.stroke(0);
      DIFFUSE_graphics.strokeWeight(0);
      DIFFUSE_graphics.rectMode(CORNER);
      DIFFUSE_graphics.rect(0, 0, RES1, RES2);

      for (int i = 0; i < skyFaces.length; i++) {

        PImage img = loadImage(File_Name + nf(i, 3) + ".JPG");

        DIFFUSE_graphics.blendMode(ADD); 

        DIFFUSE_graphics.tint(255, 255 / (0.5 * float(skyFaces.length)));

        DIFFUSE_graphics.image(img, 0, 0, RES1, RES2);

        DIFFUSE_graphics.noTint();
      }

      DIFFUSE_graphics.endDraw();

      File_Name += "_Camera00.PNG"; 

      DIFFUSE_graphics.save(File_Name);
      println(File_Name);
    }
  }

  SolarImpact_sectionType = keep_SolarImpact_sectionType;
  SolarImpact_Rotation = keep_SolarImpact_Rotation;  

  cursor(ARROW);
}












void SOLARCHVISION_draw_WindRoseImage () {

  if (Display_WindRoseImage) {

    if (rebuild_WindRoseImage_array != 0) {
      SOLARCHVISION_resize_WindRose_Image_array();
    }    

    WIN3D.graphics.stroke(0);
    WIN3D.graphics.fill(127, 127, 127);    

    WIN3D.graphics.beginShape();

    float WindRose_Elevation = 0.0 + SolidImpact_Elevation[1];
    float WindRose_scale_U = WindRose_scale; 
    float WindRose_scale_V = WindRose_scale;

    float minU = 0;
    float maxU = Rendered_WindRose_RES;
    float minV = 0;
    float maxV = Rendered_WindRose_RES;

    //float c = HeightAboveGround * OBJECTS_scale; // <<< or zero i.e. height of the plane in 3D  // ?????????
    float c = WindRose_Elevation * OBJECTS_scale; 

    c += 1; // put WindRose_Image it at level 1m. // <<<<<<<<<<<

    WIN3D.graphics.beginShape();

    WIN3D.graphics.texture(WindRose_Image[IMPACTS_DisplayDay]);  
    WIN3D.graphics.stroke(255, 255, 255, 0);
    WIN3D.graphics.fill(255, 255, 255, 0);  

    for (int q = 0; q < 4; q++) {

      float qx = 0, qy = 0, u = 0, v = 0;

      if (q == 0) {
        qx = -1; 
        qy = -1; 
        u = minU; 
        v = maxV;
      } else if (q == 1) {
        qx = 1; 
        qy = -1; 
        u = maxU; 
        v = maxV;
      } else if (q == 2) {
        qx = 1; 
        qy = 1; 
        u = maxU; 
        v = minV;
      } else if (q == 3) {
        qx = -1; 
        qy = 1; 
        u = minU; 
        v = minV;
      }    

      float a = qx * 0.5;
      float b = qy * 0.5;    

      float x = 0, y = 0, z = 0;

      x = a;
      y = b;
      z = c;         

      WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * WindRose_scale_U, v * WindRose_scale_V);
    }   

    WIN3D.graphics.endShape(CLOSE);
  }
}







void SOLARCHVISION_draw_referencePivot () {


  WIN3D.graphics.strokeWeight(3);
  WIN3D.graphics.stroke(127, 0, 255, 127);
  WIN3D.graphics.fill(127, 0, 255, 127);  

  float[] P = SOLARCHVISION_getPivot();

  float x = P[0];
  float y = P[1];
  float z = P[2];


  WIN3D.graphics.pushMatrix(); 
  WIN3D.graphics.translate(x * WIN3D.scale, -y * WIN3D.scale, z * WIN3D.scale);

  WIN3D.graphics.sphere(1); // <<<<<< size

  WIN3D.graphics.popMatrix();

  WIN3D.graphics.strokeWeight(0);
}



































float[][] SOLARCHVISION_selection_BoundingBox = {
  {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
}; // [min|mid|max]

float[][] SOLARCHVISION_saved_BoundingBox = {
  {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
};

int SOLARCHVISION_saved_alignX = 0;
int SOLARCHVISION_saved_alignY = 0;
int SOLARCHVISION_saved_alignZ = 0;

void SOLARCHVISION_calculate_selection_BoundingBox () {

  int keep_selection_alignX = selection_alignX;
  int keep_selection_alignY = selection_alignY;
  int keep_selection_alignZ = selection_alignZ;

  selection_alignX = 0; // apply the centre
  selection_alignY = 0; // apply the centre
  selection_alignZ = 0; // apply the centre

  int[] theVertices = new int [0];

  if (Current_ObjectCategory == ObjectCategory.CAMERA) {
    theVertices = selectedCamera_ids;
  } 

  if (Current_ObjectCategory == ObjectCategory.SECTION) {
    theVertices = selectedSection_ids;
  } 

  if (Current_ObjectCategory == ObjectCategory.SOLID) {
    theVertices = selectedSolid_ids;
  } 

  if ((Current_ObjectCategory == ObjectCategory.VERTEX) || (Current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {
    theVertices = selectedVertex_ids;
  }
  if (Current_ObjectCategory == ObjectCategory.FACE) {
    theVertices = allModel3Ds.get_selectedFace_Vertices();
  }  
  if (Current_ObjectCategory == ObjectCategory.CURVE) {
    theVertices = allModel3Ds.get_selectedCurve_Vertices();
  }    
  if (Current_ObjectCategory == ObjectCategory.GROUP) {
    theVertices = allModel3Ds.get_selectedGroup_Vertices();
  }
  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
    theVertices = selectedallModel2Ds_ids;
  }
  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
    theVertices = selectedallModel1Ds_ids;
  }  
  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
    theVertices = selectedLandPoint_ids;
  }    

  float posX = 0;
  float posY = 0;
  float posZ = 0;

  float scaleX = 1; 
  float scaleY = 1; 
  float scaleZ = 1; 

  float rotX = 0;
  float rotY = 0;
  float rotZ = 0;

  if (Current_ObjectCategory == ObjectCategory.GROUP) { 

    if (selectedGroup_ids.length > 0) {
    
      int o = selectedGroup_ids.length - 1; // applying the local coordinates of the last selected object <<<<<<<<<<<<<<<<<<<<<<<
  
      int OBJ_NUM = selectedGroup_ids[o];
  
      posX = allGroups.PivotXYZ[OBJ_NUM][0];
      posY = allGroups.PivotXYZ[OBJ_NUM][1];
      posZ = allGroups.PivotXYZ[OBJ_NUM][2];
  
      scaleX = allGroups.PivotXYZ[OBJ_NUM][3];
      scaleY = allGroups.PivotXYZ[OBJ_NUM][4];
      scaleZ = allGroups.PivotXYZ[OBJ_NUM][5];
  
      rotX = allGroups.PivotXYZ[OBJ_NUM][6];
      rotY = allGroups.PivotXYZ[OBJ_NUM][7];
      rotZ = allGroups.PivotXYZ[OBJ_NUM][8];
    }
  }


  for (int i = 0; i < 3; i++) {
    float ratio = 0.5 * i;
    SOLARCHVISION_selection_BoundingBox[i][0] = posX;
    SOLARCHVISION_selection_BoundingBox[i][1] = posY;
    SOLARCHVISION_selection_BoundingBox[i][2] = posZ;

    SOLARCHVISION_selection_BoundingBox[i][3] = scaleX;
    SOLARCHVISION_selection_BoundingBox[i][4] = scaleY;
    SOLARCHVISION_selection_BoundingBox[i][5] = scaleZ;

    SOLARCHVISION_selection_BoundingBox[i][6] = rotX;
    SOLARCHVISION_selection_BoundingBox[i][7] = rotY;
    SOLARCHVISION_selection_BoundingBox[i][8] = rotZ;
  }   


  float posX_min = FLOAT_undefined;
  float posY_min = FLOAT_undefined;
  float posZ_min = FLOAT_undefined;

  float posX_max = -FLOAT_undefined;  
  float posY_max = -FLOAT_undefined;  
  float posZ_max = -FLOAT_undefined;



  for (int q = 0; q < theVertices.length; q++) {

    float x = 0;
    float y = 0;
    float z = 0;

    if (Current_ObjectCategory == ObjectCategory.CAMERA) {
      int n = theVertices[q];

      if (n < allCameras.num) {

        float Camera_X = allCameras.PPPSRRRF[n][0];
        float Camera_Y = allCameras.PPPSRRRF[n][1];
        float Camera_Z = allCameras.PPPSRRRF[n][2];
        float Camera_S = allCameras.PPPSRRRF[n][3];
        float Camera_RX = allCameras.PPPSRRRF[n][4];
        float Camera_RY = allCameras.PPPSRRRF[n][5];
        float Camera_RZ = allCameras.PPPSRRRF[n][6];
        float Camera_ZOOM = allCameras.PPPSRRRF[n][7];

        int Camera_Type = allCameras.Type[n];

        float[][] ImageVertex = allCameras.getCorners(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

        // the first vertex is the Camera point
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  

    if (Current_ObjectCategory == ObjectCategory.SECTION) {
      int n = theVertices[q];

      if (n < allSections.num) {

        float Section_offset_U = allSections.UVERAB[n][0];
        float Section_offset_V = allSections.UVERAB[n][1];
        float Section_Elevation = allSections.UVERAB[n][2];
        float Section_Rotation = allSections.UVERAB[n][3];
        float Section_scale_U = allSections.UVERAB[n][4];
        float Section_scale_V = allSections.UVERAB[n][5];

        int Section_Type = allSections.Type[n];
        int Section_RES1 = allSections.RES1[n];
        int Section_RES2 = allSections.RES2[n];

        float[][] ImageVertex = allSections.getCorners(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

        // the first vertex is the center of Section plane
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  

    if (Current_ObjectCategory == ObjectCategory.SOLID) {
      int n = theVertices[q];

      if (n < allSolids.DEF.length) {

        float Solid_posX = allSolids.get_posX(n);
        float Solid_posY = allSolids.get_posY(n);
        float Solid_posZ = allSolids.get_posZ(n);
        float Solid_powX = allSolids.get_powX(n);
        float Solid_powY = allSolids.get_powY(n);
        float Solid_powZ = allSolids.get_powZ(n);
        float Solid_scaleX = allSolids.get_scaleX(n);
        float Solid_scaleY = allSolids.get_scaleY(n);
        float Solid_scaleZ = allSolids.get_scaleZ(n);
        float Solid_rotX = allSolids.get_rotX(n);
        float Solid_rotY = allSolids.get_rotY(n);
        float Solid_rotZ = allSolids.get_rotZ(n);
        float Solid_value = allSolids.get_value(n);

        float[][] ImageVertex = allSolids.getCorners(0, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

        // the first vertex is the center of Solid plane
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  


    if ((Current_ObjectCategory == ObjectCategory.GROUP) || (Current_ObjectCategory == ObjectCategory.FACE) || (Current_ObjectCategory == ObjectCategory.CURVE) || (Current_ObjectCategory == ObjectCategory.VERTEX) || (Current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {
      int n = theVertices[q];

      x = allVertices[n][0];
      y = allVertices[n][1];
      z = allVertices[n][2];
    }
    if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
      int n = theVertices[q];

      x = allModel2Ds.getX(n);
      y = allModel2Ds.getY(n);
      z = allModel2Ds.getZ(n);
    }     
    if (Current_ObjectCategory == ObjectCategory.MODEL1D) {
      int n = theVertices[q];

      x = allModel1Ds.getX(n);
      y = allModel1Ds.getY(n);
      z = allModel1Ds.getZ(n);
    }  
    if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
      int n = theVertices[q];

      int OBJ_NUM = n;

      int the_i = OBJ_NUM / Land3D.n_J;
      int the_j = OBJ_NUM % Land3D.n_J;

      x = Land3D.Mesh[the_i][the_j][0];
      y = Land3D.Mesh[the_i][the_j][1];
      z = Land3D.Mesh[the_i][the_j][2];

    }             




    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = A[0];
    y = A[1];
    z = A[2];


    if (posX_min > x) posX_min = x;   
    if (posY_min > y) posY_min = y;   
    if (posZ_min > z) posZ_min = z;

    if (posX_max < x) posX_max = x;   
    if (posY_max < y) posY_max = y;   
    if (posZ_max < z) posZ_max = z;
  }   

  if ((posX_min != FLOAT_undefined) && (posX_max != -FLOAT_undefined) && (posY_min != FLOAT_undefined) && (posY_max != -FLOAT_undefined) && (posZ_min != FLOAT_undefined) && (posZ_max != -FLOAT_undefined)) {

    float dx = posX;
    float dy = posY;
    float dz = posZ;

    posX_min += dx;
    posY_min += dy;
    posZ_min += dz;    

    posX_max += dx;
    posY_max += dy;
    posZ_max += dz;   

    for (int i = 0; i < 3; i++) {
      float ratio = 0.5 * i;
      SOLARCHVISION_selection_BoundingBox[i][0] = (1 - ratio) * posX_min + ratio * posX_max;
      SOLARCHVISION_selection_BoundingBox[i][1] = (1 - ratio) * posY_min + ratio * posY_max;
      SOLARCHVISION_selection_BoundingBox[i][2] = (1 - ratio) * posZ_min + ratio * posZ_max;

      SOLARCHVISION_selection_BoundingBox[i][3] = scaleX;
      SOLARCHVISION_selection_BoundingBox[i][4] = scaleY;
      SOLARCHVISION_selection_BoundingBox[i][5] = scaleZ;

      SOLARCHVISION_selection_BoundingBox[i][6] = rotX;
      SOLARCHVISION_selection_BoundingBox[i][7] = rotY;
      SOLARCHVISION_selection_BoundingBox[i][8] = rotZ;
    }
  }



  selection_alignX = keep_selection_alignX;
  selection_alignY = keep_selection_alignY;
  selection_alignZ = keep_selection_alignZ;
}



void SOLARCHVISION_save_current_BoundingBox () {

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 9; j++) {
      SOLARCHVISION_saved_BoundingBox[i][j] = SOLARCHVISION_selection_BoundingBox[i][j];
    }
  } 

  SOLARCHVISION_saved_alignX = selection_alignX;
  SOLARCHVISION_saved_alignY = selection_alignY;
  SOLARCHVISION_saved_alignZ = selection_alignZ;
}


void SOLARCHVISION_apply_saved_ReferenceBox () {

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 9; j++) {
      SOLARCHVISION_selection_BoundingBox[i][j] = SOLARCHVISION_saved_BoundingBox[i][j];
    }
  } 

  selection_alignX = SOLARCHVISION_saved_alignX;
  selection_alignY = SOLARCHVISION_saved_alignY;
  selection_alignZ = SOLARCHVISION_saved_alignZ;
}


void SOLARCHVISION_apply_origin_ReferenceBox () {

  for (int i = 0; i < 3; i++) {
    SOLARCHVISION_selection_BoundingBox[i][0] = 0;
    SOLARCHVISION_selection_BoundingBox[i][1] = 0;
    SOLARCHVISION_selection_BoundingBox[i][2] = 0;
    SOLARCHVISION_selection_BoundingBox[i][3] = 1;
    SOLARCHVISION_selection_BoundingBox[i][4] = 1;
    SOLARCHVISION_selection_BoundingBox[i][5] = 1;
    SOLARCHVISION_selection_BoundingBox[i][6] = 0;
    SOLARCHVISION_selection_BoundingBox[i][7] = 0;
    SOLARCHVISION_selection_BoundingBox[i][8] = 0;
  }

  //selection_alignX = 0;
  //selection_alignY = 0;
  //selection_alignZ = 0;
}




void SOLARCHVISION_reset_selectedRefValues () {

  selected_posValue = 0;  
  selected_rotValue = 0;  
  selected_scaleValue = 0;
}





void SOLARCHVISION_move_selectedallGroups (float dx, float dy, float dz) {

  int[] PolymeshVertices = allModel3Ds.get_selectedGroup_Vertices();

  for (int q = 0; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    allVertices[n][0] += dx; 
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }

  boolean allSolids_updated = false;

  for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup_ids[o];

    {
      allGroups.PivotXYZ[OBJ_NUM][0] += dx;
      allGroups.PivotXYZ[OBJ_NUM][1] += dy;
      allGroups.PivotXYZ[OBJ_NUM][2] += dz;
    }

    for (int f = allGroups.allModel1Ds[OBJ_NUM][0]; f <= allGroups.allModel1Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel1Ds.num)) {

        allModel1Ds.setX(f, allModel1Ds.getX(f) + dx);
        allModel1Ds.setY(f, allModel1Ds.getY(f) + dy);
        allModel1Ds.setZ(f, allModel1Ds.getZ(f) + dz);
      }
    }

    for (int f = allGroups.allModel2Ds[OBJ_NUM][0]; f <= allGroups.allModel2Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel2Ds.num)) {

        allModel2Ds.setX(f, allModel2Ds.getX(f) + dx);
        allModel2Ds.setY(f, allModel2Ds.getY(f) + dy);
        allModel2Ds.setZ(f, allModel2Ds.getZ(f) + dz);
      }
    }

    for (int f = allGroups.allSolids[OBJ_NUM][0]; f <= allGroups.allSolids[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allSolids.DEF.length)) {

        float Solid_posX = allSolids.get_posX(f);
        float Solid_posY = allSolids.get_posY(f);
        float Solid_posZ = allSolids.get_posZ(f);

        allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

        allSolids_updated = true;
      }
    }
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}

void SOLARCHVISION_rotate_selectedallGroups (float r, int the_Vector) {

  int[] PolymeshVertices = allModel3Ds.get_selectedGroup_Vertices();

  for (int q = 0; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    float x = allVertices[n][0]; 
    float y = allVertices[n][1]; 
    float z = allVertices[n][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = A[0];
    y = A[1];
    z = A[2];

    {
      float a = x;
      float b = y;
      float c = z;

      if (the_Vector == 2) {
        a = x * cos(r) - y * sin(r); 
        b = x * sin(r) + y * cos(r);
        c = z;
      } else if (the_Vector == 1) {
        a = z * sin(r) + x * cos(r); 
        b = y;
        c = z * cos(r) - x * sin(r);
      } else if (the_Vector == 0) {
        a = x;
        b = y * cos(r) - z * sin(r);
        c = y * sin(r) + z * cos(r);
      }   

      x = a;
      y = b;
      z = c;
    }

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[n][0] = x; 
    allVertices[n][1] = y;
    allVertices[n][2] = z;
  }






  boolean allSolids_updated = false;

  for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup_ids[o];

    { 
      float x = allGroups.PivotXYZ[OBJ_NUM][0]; 
      float y = allGroups.PivotXYZ[OBJ_NUM][1]; 
      float z = allGroups.PivotXYZ[OBJ_NUM][2];

      float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

      x = A[0];
      y = A[1];
      z = A[2];

      {
        float a = x;
        float b = y;
        float c = z;

        if (the_Vector == 2) {
          a = x * cos(r) - y * sin(r); 
          b = x * sin(r) + y * cos(r);
          c = z;
        } else if (the_Vector == 1) {
          a = z * sin(r) + x * cos(r); 
          b = y;
          c = z * cos(r) - x * sin(r);
        } else if (the_Vector == 0) {
          a = x;
          b = y * cos(r) - z * sin(r);
          c = y * sin(r) + z * cos(r);
        }   

        x = a;
        y = b;
        z = c;
      }

      float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allGroups.PivotXYZ[OBJ_NUM][0] = x;
      allGroups.PivotXYZ[OBJ_NUM][1] = y;
      allGroups.PivotXYZ[OBJ_NUM][2] = z;

      if (the_Vector == 2) {
        allGroups.PivotXYZ[OBJ_NUM][8] += r * 180.0 / PI;
      } else if (the_Vector == 1) {
        allGroups.PivotXYZ[OBJ_NUM][7] += r * 180.0 / PI;
      } else if (the_Vector == 0) {
        allGroups.PivotXYZ[OBJ_NUM][6] += r * 180.0 / PI;
      }
    }    


    for (int f = allGroups.allModel1Ds[OBJ_NUM][0]; f <= allGroups.allModel1Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel1Ds.num)) {

        float x = allModel1Ds.getX(f); 
        float y = allModel1Ds.getY(f); 
        float z = allModel1Ds.getZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        {
          float a = x;
          float b = y;
          float c = z;

          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r); 
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r); 
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }   

          x = a;
          y = b;
          z = c;
        }

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allModel1Ds.setX(f, x);
        allModel1Ds.setY(f, y);
        allModel1Ds.setZ(f, z);


        if (the_Vector == 2) {
          allModel1Ds.setR(f, allModel1Ds.getR(f) + r); // <<<<<<<<<
        } else if (the_Vector == 1) {
        } else if (the_Vector == 0) {
        }
      }
    }         

    for (int f = allGroups.allModel2Ds[OBJ_NUM][0]; f <= allGroups.allModel2Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel2Ds.num)) {

        float x = allModel2Ds.getX(f); 
        float y = allModel2Ds.getY(f); 
        float z = allModel2Ds.getZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        {
          float a = x;
          float b = y;
          float c = z;

          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r); 
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r); 
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }   

          x = a;
          y = b;
          z = c;
        }

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allModel2Ds.setX(f, x);
        allModel2Ds.setY(f, y);
        allModel2Ds.setZ(f, z);
      }
    }         

    for (int f = allGroups.allSolids[OBJ_NUM][0]; f <= allGroups.allSolids[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allSolids.DEF.length)) {

        float x = allSolids.get_posX(f);
        float y = allSolids.get_posY(f);
        float z = allSolids.get_posZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        {
          float a = x;
          float b = y;
          float c = z;

          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r); 
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r); 
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }   

          x = a;
          y = b;
          z = c;
        }

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];


        allSolids.updatePosition(f, x, y, z);

        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Note: these rotations could be translated to locals to avoid problems!
        if (the_Vector == 2) {
          allSolids.RotateZ(f, r * 180 / PI);
        } else if (the_Vector == 1) {
          allSolids.RotateY(f, r * 180 / PI);
        } else if (the_Vector == 0) {
          allSolids.RotateX(f, r * 180 / PI);
        }

        allSolids_updated = true;
      }
    }
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}



void SOLARCHVISION_scale_selectedallGroups (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] PolymeshVertices = allModel3Ds.get_selectedGroup_Vertices();

  for (int q = 0; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    float x = allVertices[n][0]; 
    float y = allVertices[n][1]; 
    float z = allVertices[n][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[n][0] = x; 
    allVertices[n][1] = y;
    allVertices[n][2] = z;
  }

  int n1 = allModel2Ds.PEOPLE_Files_Num;

  boolean allSolids_updated = false;

  for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup_ids[o];

    {
      float x = allGroups.PivotXYZ[OBJ_NUM][0]; 
      float y = allGroups.PivotXYZ[OBJ_NUM][1]; 
      float z = allGroups.PivotXYZ[OBJ_NUM][2];

      float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allGroups.PivotXYZ[OBJ_NUM][0] = x; 
      allGroups.PivotXYZ[OBJ_NUM][1] = y;
      allGroups.PivotXYZ[OBJ_NUM][2] = z;        

      // ???????
      //allGroups.PivotXYZ[OBJ_NUM][3] *= sx; 
      //allGroups.PivotXYZ[OBJ_NUM][4] *= sy;
      //allGroups.PivotXYZ[OBJ_NUM][5] *= sz;
      // ???????
    }


    for (int f = allGroups.allModel1Ds[OBJ_NUM][0]; f <= allGroups.allModel1Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel1Ds.num)) {

        float x = allModel1Ds.getX(f);
        float y = allModel1Ds.getY(f); 
        float z = allModel1Ds.getZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allModel1Ds.setX(f, x);
        allModel1Ds.setY(f, y);
        allModel1Ds.setZ(f, z);

        allModel1Ds.setS(f, allModel1Ds.getS(f) * sz);
      }
    }  


    for (int f = allGroups.allModel2Ds[OBJ_NUM][0]; f <= allGroups.allModel2Ds[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allModel2Ds.num)) {

        float x = allModel2Ds.getX(f);
        float y = allModel2Ds.getY(f); 
        float z = allModel2Ds.getZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];         

        allModel2Ds.setX(f, x); 
        allModel2Ds.setY(f, y);
        allModel2Ds.setZ(f, z);

        int n = allModel2Ds.MAP[f];

        if (abs(n) > n1) { // does not scale poeple!    
          allModel2Ds.setS(f, allModel2Ds.getS(f) * sz);
        }
      }
    }     

    for (int f = allGroups.allSolids[OBJ_NUM][0]; f <= allGroups.allSolids[OBJ_NUM][1]; f++) {
      if ((0 <= f) && (f < allSolids.DEF.length)) {

        float x = allSolids.get_posX(f);
        float y = allSolids.get_posY(f);
        float z = allSolids.get_posZ(f);

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0]; 
        y = B[1];
        z = B[2];

        allSolids.updatePosition(f, x, y, z);

        allSolids.Scale(f, sx, sy, sz);

        allSolids_updated = true;
      }
    }
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}



void SOLARCHVISION_move_selectedFaces (float dx, float dy, float dz) {

  int[] FaceVertices = allModel3Ds.get_selectedFace_Vertices();

  for (int q = 0; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    allVertices[f][0] += dx; 
    allVertices[f][1] += dy;
    allVertices[f][2] += dz;
  }
}

void SOLARCHVISION_rotate_selectedFaces (float x0, float y0, float z0, float r, int the_Vector) {

  int[] FaceVertices = allModel3Ds.get_selectedFace_Vertices();

  for (int q = 0; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[f][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}

void SOLARCHVISION_scale_selectedFaces (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] FaceVertices = allModel3Ds.get_selectedFace_Vertices();

  for (int q = 0; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    float x = allVertices[f][0];
    float y = allVertices[f][1];
    float z = allVertices[f][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];    

    allVertices[f][0] = x; 
    allVertices[f][1] = y;
    allVertices[f][2] = z;
  }
}


void SOLARCHVISION_move_selectedCurves (float dx, float dy, float dz) {

  int[] CurveVertices = allModel3Ds.get_selectedCurve_Vertices();

  for (int q = 0; q < CurveVertices.length; q++) {

    int f = CurveVertices[q];

    allVertices[f][0] += dx; 
    allVertices[f][1] += dy;
    allVertices[f][2] += dz;
  }
}

void SOLARCHVISION_rotate_selectedCurves (float x0, float y0, float z0, float r, int the_Vector) {

  int[] CurveVertices = allModel3Ds.get_selectedCurve_Vertices();

  for (int q = 0; q < CurveVertices.length; q++) {

    int f = CurveVertices[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[f][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}

void SOLARCHVISION_scale_selectedCurves (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] CurveVertices = allModel3Ds.get_selectedCurve_Vertices();

  for (int q = 0; q < CurveVertices.length; q++) {

    int f = CurveVertices[q];

    float x = allVertices[f][0];
    float y = allVertices[f][1];
    float z = allVertices[f][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];    

    allVertices[f][0] = x; 
    allVertices[f][1] = y;
    allVertices[f][2] = z;
  }
}

void SOLARCHVISION_move_selectedVertices (float dx, float dy, float dz) {

  for (int q = 0; q < selectedVertex_ids.length; q++) {

    int f = selectedVertex_ids[q];

    allVertices[f][0] += dx; 
    allVertices[f][1] += dy;
    allVertices[f][2] += dz;
  }
}


void SOLARCHVISION_rotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 0; q < selectedVertex_ids.length; q++) {

    int f = selectedVertex_ids[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[f][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}


void SOLARCHVISION_scale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 0; q < selectedVertex_ids.length; q++) {

    int f = selectedVertex_ids[q];

    float x = allVertices[f][0]; 
    float y = allVertices[f][1]; 
    float z = allVertices[f][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[f][0] = x; 
    allVertices[f][1] = y;
    allVertices[f][2] = z;
  }
}




float SOLARCHVISION_softVertexSelectionFunction (float d_min) {

  float v = 0;

  if (d_min < softSelection_Radius) {
    v = pow(cos_ang(90 * d_min / softSelection_Radius), softSelection_Power);
  }

  return v;
}

void SOLARCHVISION_softMove_selectedVertices (float dx, float dy, float dz) {

  for (int q = 0; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];

    allVertices[f][0] += dx * v; 
    allVertices[f][1] += dy * v;
    allVertices[f][2] += dz * v;
  }
}


void SOLARCHVISION_softRotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 0; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r * v) - y * sin(r * v)); 
      allVertices[f][1] = y0 + (x * sin(r * v) + y * cos(r * v));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r * v) + x * cos(r * v)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r * v) - x * sin(r * v));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r * v) - z * sin(r * v));
      allVertices[f][2] = z0 + (y * sin(r * v) + z * cos(r * v));
    }
  }
}



void SOLARCHVISION_softScale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 0; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];    

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    allVertices[f][0] = (x0 + sx * x) * v + (x0 + x) * (1 - v); 
    allVertices[f][1] = (y0 + sy * y) * v + (y0 + y) * (1 - v); 
    allVertices[f][2] = (z0 + sz * z) * v + (z0 + z) * (1 - v);
  }
}



void SOLARCHVISION_scale_selectedallModel2Ds (float x0, float y0, float z0, float sx, float sy, float sz) { 

  int n1 = allModel2Ds.PEOPLE_Files_Num;    

  for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {

    int f = selectedallModel2Ds_ids[o];

    float x = allModel2Ds.getX(f);
    float y = allModel2Ds.getY(f); 
    float z = allModel2Ds.getZ(f);

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];         

    allModel2Ds.setX(f, x); 
    allModel2Ds.setY(f, y);
    allModel2Ds.setZ(f, z);    


    int n = allModel2Ds.MAP[f];

    if (abs(n) > n1) { // does not scale poeple!    
      allModel2Ds.setS(f, allModel2Ds.getS(f) * sz);
    }
  }
}


void SOLARCHVISION_rotate_selectedallModel2Ds (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 0; q < selectedallModel2Ds_ids.length; q++) {

    int f = selectedallModel2Ds_ids[q];

    float x = allModel2Ds.getX(f) - x0; 
    float y = allModel2Ds.getY(f) - y0; 
    float z = allModel2Ds.getZ(f) - z0;

    if (the_Vector == 2) {
      allModel2Ds.setX(f, x0 + (x * cos(r) - y * sin(r))); 
      allModel2Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
      allModel2Ds.setZ(f, z0 + (z));
    } else if (the_Vector == 1) {
      allModel2Ds.setX(f, x0 + (z * sin(r) + x * cos(r))); 
      allModel2Ds.setY(f, y0 + (y));
      allModel2Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
    } else if (the_Vector == 0) {
      allModel2Ds.setX(f, x0 + (x)); 
      allModel2Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
      allModel2Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
    }
  }
}



void SOLARCHVISION_move_selectedallModel2Ds (float dx, float dy, float dz) {

  for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {

    int f = selectedallModel2Ds_ids[o];
    
    allModel2Ds.setX(f, allModel2Ds.getX(f) + dx); 
    allModel2Ds.setY(f, allModel2Ds.getY(f) + dy); 
    allModel2Ds.setZ(f, allModel2Ds.getZ(f) + dz);
  }
} 


void SOLARCHVISION_scale_selectedallModel1Ds (float x0, float y0, float z0, float sx, float sy, float sz) { 

  for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {

    int f = selectedallModel1Ds_ids[o];

    float x = allModel1Ds.getX(f);
    float y = allModel1Ds.getY(f); 
    float z = allModel1Ds.getZ(f);

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allModel1Ds.setX(f, x);
    allModel1Ds.setY(f, y);
    allModel1Ds.setZ(f, z);

    allModel1Ds.setS(f, allModel1Ds.getS(f) * sz);
  }
}


void SOLARCHVISION_rotate_selectedallModel1Ds (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 0; q < selectedallModel1Ds_ids.length; q++) {

    int f = selectedallModel1Ds_ids[q];

    float x = allModel1Ds.getX(f) - x0; 
    float y = allModel1Ds.getY(f) - y0; 
    float z = allModel1Ds.getZ(f) - z0;

    if (the_Vector == 2) {
      allModel1Ds.setX(f, x0 + (x * cos(r) - y * sin(r))); 
      allModel1Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
      allModel1Ds.setZ(f, z0 + (z));

      allModel1Ds.setR(f, allModel1Ds.getR(f) + r); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    } else if (the_Vector == 1) {
      allModel1Ds.setX(f, x0 + (z * sin(r) + x * cos(r))); 
      allModel1Ds.setY(f, y0 + (y));
      allModel1Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
    } else if (the_Vector == 0) {
      allModel1Ds.setX(f, x0 + (x)); 
      allModel1Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
      allModel1Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
    }
  }
}


void SOLARCHVISION_move_selectedallModel1Ds (float dx, float dy, float dz) {

  for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {

    int f = selectedallModel1Ds_ids[o];

    allModel1Ds.setX(f, allModel1Ds.getX(f) + dx); 
    allModel1Ds.setY(f, allModel1Ds.getY(f) + dy); 
    allModel1Ds.setZ(f, allModel1Ds.getZ(f) + dz);
  }
} 


void SOLARCHVISION_move_selectedallSolids (float dx, float dy, float dz) {

  boolean allSolids_updated = false; 

  for (int q = 0; q < selectedSolid_ids.length; q++) {

    int f = selectedSolid_ids[q];

    float Solid_posX = allSolids.get_posX(f);
    float Solid_posY = allSolids.get_posY(f);
    float Solid_posZ = allSolids.get_posZ(f);

    allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

    allSolids_updated = true;
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}


void SOLARCHVISION_rotate_selectedallSolids (float x0, float y0, float z0, float r, int the_Vector) {

  boolean allSolids_updated = false; 

  for (int q = 0; q < selectedSolid_ids.length; q++) {

    int f = selectedSolid_ids[q];

    float Solid_posX = allSolids.get_posX(f);
    float Solid_posY = allSolids.get_posY(f);
    float Solid_posZ = allSolids.get_posZ(f);


    float x = Solid_posX - x0; 
    float y = Solid_posY - y0; 
    float z = Solid_posZ - z0;

    if (the_Vector == 2) {
      allSolids.updatePosition(f, x0 + (x * cos(r) - y * sin(r)), y0 + (x * sin(r) + y * cos(r)), z0 + (z));

      allSolids.RotateZ(f, r * 180 / PI);
    } else if (the_Vector == 1) {
      allSolids.updatePosition(f, x0 + (z * sin(r) + x * cos(r)), y0 + (y), z0 + (z * cos(r) - x * sin(r)));

      allSolids.RotateY(f, r * 180 / PI);
    } else if (the_Vector == 0) {
      allSolids.updatePosition(f, x0 + (x), y0 + (y * cos(r) - z * sin(r)), z0 + (y * sin(r) + z * cos(r)));

      allSolids.RotateX(f, r * 180 / PI);
    }

    allSolids_updated = true;
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}


void SOLARCHVISION_scale_selectedallSolids (float x0, float y0, float z0, float sx, float sy, float sz) {

  boolean allSolids_updated = false; 

  for (int q = 0; q < selectedSolid_ids.length; q++) {

    int f = selectedSolid_ids[q];

    float x = allSolids.get_posX(f);
    float y = allSolids.get_posY(f);
    float z = allSolids.get_posZ(f);

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0]; 
    y = B[1];
    z = B[2];

    allSolids.updatePosition(f, x, y, z);

    allSolids.Scale(f, sx, sy, sz);    

    allSolids_updated = true;
  }

  if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
}


void SOLARCHVISION_move_selectedallSections (float dx, float dy, float dz) {

  for (int q = 0; q < selectedSection_ids.length; q++) {

    int f = selectedSection_ids[q];

    allSections.UVERAB[f][0] += dx;
    allSections.UVERAB[f][1] += dy;
    allSections.UVERAB[f][2] += dz;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedallSections();

  WIN3D.update = true;
  ROLLOUT.update = true;
}


void SOLARCHVISION_rotate_selectedallSections (float r) {

  for (int q = 0; q < selectedSection_ids.length; q++) {

    int f = selectedSection_ids[q];

    allSections.UVERAB[f][3] += r * 180.0 / PI;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 

  WIN3D.update = true;
  ROLLOUT.update = true;
}

void SOLARCHVISION_scale_selectedallSections (float sx, float sy) {

  for (int q = 0; q < selectedSection_ids.length; q++) {

    int f = selectedSection_ids[q];

    allSections.UVERAB[f][4] *= sx;
    allSections.UVERAB[f][5] *= sy;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedallSections(); 

  WIN3D.update = true;
  ROLLOUT.update = true;
}


void SOLARCHVISION_move_selectedallCameras (float dx, float dy, float dz) {

  // swapping y and z vectors to match camera's local coordinate
  float tmp = dz;
  dz = dy;
  dy = tmp;

  for (int q = 0; q < selectedCamera_ids.length; q++) {

    int f = selectedCamera_ids[q];

    allCameras.PPPSRRRF[f][0] += dx; 
    allCameras.PPPSRRRF[f][1] += dy;
    allCameras.PPPSRRRF[f][2] += dz;

    if (f == WIN3D.CurrentCamera) WIN3D.apply_currentCamera();
  }
}


void SOLARCHVISION_rotate_selectedallCameras (float x0, float y0, float z0, float r, int the_Vector) {

  // swapping y and z vectors to match camera's local coordinate
  if (the_Vector == 2) the_Vector = 1;
  else if (the_Vector == 1) the_Vector = 2;

  for (int q = 0; q < selectedCamera_ids.length; q++) {

    int f = selectedCamera_ids[q];

    float x = allCameras.PPPSRRRF[f][0] - x0; 
    float y = allCameras.PPPSRRRF[f][1] - y0; 
    float z = allCameras.PPPSRRRF[f][2] - z0;

    if (the_Vector == 2) {
      allCameras.PPPSRRRF[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allCameras.PPPSRRRF[f][1] = y0 + (x * sin(r) + y * cos(r));
      allCameras.PPPSRRRF[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allCameras.PPPSRRRF[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allCameras.PPPSRRRF[f][1] = y0 + (y);
      allCameras.PPPSRRRF[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allCameras.PPPSRRRF[f][0] = x0 + (x); 
      allCameras.PPPSRRRF[f][1] = y0 + (y * cos(r) - z * sin(r));
      allCameras.PPPSRRRF[f][2] = z0 + (y * sin(r) + z * cos(r));
    }    

    if (f == WIN3D.CurrentCamera) WIN3D.apply_currentCamera();
  }
}


void SOLARCHVISION_scale_selectedallCameras (float x0, float y0, float z0, float sx, float sy, float sz) {

  // swapping y and z vectors to match camera's local coordinate
  float tmp = sz;
  sz = sy;
  sy = tmp;

  for (int q = 0; q < selectedCamera_ids.length; q++) {

    int f = selectedCamera_ids[q];

    float x = allCameras.PPPSRRRF[f][0] - x0; 
    float y = allCameras.PPPSRRRF[f][1] - y0; 
    float z = allCameras.PPPSRRRF[f][2] - z0;

    allCameras.PPPSRRRF[f][0] = x0 + sx * x; 
    allCameras.PPPSRRRF[f][1] = y0 + sy * y;
    allCameras.PPPSRRRF[f][2] = z0 + sz * z;

    if (f == WIN3D.CurrentCamera) WIN3D.apply_currentCamera();
  }
}


void SOLARCHVISION_flatten_selectedLandPoints () {

  for (int q = 0; q < selectedLandPoint_ids.length; q++) {

    int f = selectedLandPoint_ids[q];

    int i = f / Land3D.n_J;
    int j = f % Land3D.n_J;

    Land3D.Mesh[i][j][2] = 0;

  }
}



void SOLARCHVISION_move_selectedLandPoints (float dx, float dy, float dz) {

  for (int q = 0; q < selectedLandPoint_ids.length; q++) {

    int f = selectedLandPoint_ids[q];

    int i = f / Land3D.n_J;
    int j = f % Land3D.n_J;

    Land3D.Mesh[i][j][0] += dx; 
    Land3D.Mesh[i][j][1] += dy;
    Land3D.Mesh[i][j][2] += dz;
  }
}


void SOLARCHVISION_rotate_selectedLandPoints (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 0; q < selectedLandPoint_ids.length; q++) {

    int f = selectedLandPoint_ids[q];

    int i = f / Land3D.n_J;
    int j = f % Land3D.n_J;

    float x = Land3D.Mesh[i][j][0] - x0; 
    float y = Land3D.Mesh[i][j][1] - y0; 
    float z = Land3D.Mesh[i][j][2] - z0;

    if (the_Vector == 2) {
      Land3D.Mesh[i][j][0] = x0 + (x * cos(r) - y * sin(r)); 
      Land3D.Mesh[i][j][1] = y0 + (x * sin(r) + y * cos(r));
      Land3D.Mesh[i][j][2] = z0 + (z);
    } else if (the_Vector == 1) {
      Land3D.Mesh[i][j][0] = x0 + (z * sin(r) + x * cos(r)); 
      Land3D.Mesh[i][j][1] = y0 + (y);
      Land3D.Mesh[i][j][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      Land3D.Mesh[i][j][0] = x0 + (x); 
      Land3D.Mesh[i][j][1] = y0 + (y * cos(r) - z * sin(r));
      Land3D.Mesh[i][j][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}


void SOLARCHVISION_scale_selectedLandPoints (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 0; q < selectedLandPoint_ids.length; q++) {

    int f = selectedLandPoint_ids[q];

    int i = f / Land3D.n_J;
    int j = f % Land3D.n_J;

    float x = Land3D.Mesh[i][j][0];
    float y = Land3D.Mesh[i][j][1]; 
    float z = Land3D.Mesh[i][j][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    Land3D.Mesh[i][j][0] = x; 
    Land3D.Mesh[i][j][1] = y;
    Land3D.Mesh[i][j][2] = z;

  }
}



void SOLARCHVISION_scale_Selection (float x0, float y0, float z0, float sx, float sy, float sz) {

  float[] O = SOLARCHVISION_translateOutside_ReferencePivot(x0, y0, z0);

  x0 = O[0];
  y0 = O[1];
  z0 = O[2];    


  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    SOLARCHVISION_scale_selectedallCameras(x0, y0, z0, sx, sy, sz);
  }   

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    SOLARCHVISION_scale_selectedallSections(sx, sy);
  }   

  if (Current_ObjectCategory == ObjectCategory.SOLID) {
    SOLARCHVISION_scale_selectedallSolids(x0, y0, z0, sx, sy, sz);
  }       

  if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {

    SOLARCHVISION_softScale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }    

  if (Current_ObjectCategory == ObjectCategory.VERTEX) {

    SOLARCHVISION_scale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }  

  if (Current_ObjectCategory == ObjectCategory.FACE) {

    SOLARCHVISION_scale_selectedFaces(x0, y0, z0, sx, sy, sz);
  }  
  
  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    SOLARCHVISION_scale_selectedCurves(x0, y0, z0, sx, sy, sz);
  }    

  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    SOLARCHVISION_scale_selectedallGroups(x0, y0, z0, sx, sy, sz);
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    SOLARCHVISION_scale_selectedallModel2Ds(x0, y0, z0, sx, sy, sz);
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    SOLARCHVISION_scale_selectedallModel1Ds(x0, y0, z0, sx, sy, sz);
  }  

  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {

    SOLARCHVISION_scale_selectedLandPoints(x0, y0, z0, sx, sy, sz);
  }
}



void SOLARCHVISION_rotate_Selection (float x0, float y0, float z0, float r, int the_Vector) {
  
  r *= PI / 180; // <<<<<<<<

  float[] A = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
  float[] B = SOLARCHVISION_translateInside_ReferencePivot(x0, y0, z0);

  x0 = B[0] - A[0];
  y0 = B[1] - A[1];
  z0 = B[2] - A[2];  


  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    SOLARCHVISION_rotate_selectedallCameras(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    SOLARCHVISION_rotate_selectedallSections(r);
  }   

  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    SOLARCHVISION_rotate_selectedallSolids(x0, y0, z0, r, the_Vector);
  }       

  if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {

    SOLARCHVISION_softRotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory.VERTEX) {

    SOLARCHVISION_rotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory.FACE) {

    SOLARCHVISION_rotate_selectedFaces(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    SOLARCHVISION_rotate_selectedCurves(x0, y0, z0, r, the_Vector);
  }  
  
  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    SOLARCHVISION_rotate_selectedallGroups(r, the_Vector);
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    SOLARCHVISION_rotate_selectedallModel2Ds(x0, y0, z0, r, the_Vector);
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    SOLARCHVISION_rotate_selectedallModel1Ds(x0, y0, z0, r, the_Vector);
  }   

  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {

    SOLARCHVISION_rotate_selectedLandPoints(x0, y0, z0, r, the_Vector);
  }
} 






void SOLARCHVISION_move_Selection (float dx, float dy, float dz) {
  
  println("Move: dx=", dx, ", dy=", dy, ", dz=", dz);

  float[] A = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
  float[] B = SOLARCHVISION_translateInside_ReferencePivot(dx, dy, dz);

  dx = B[0] - A[0];
  dy = B[1] - A[1];
  dz = B[2] - A[2];




  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    SOLARCHVISION_move_selectedallCameras(dx, dy, dz);
  }     

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    SOLARCHVISION_move_selectedallSections(dx, dy, dz);
  }   

  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    SOLARCHVISION_move_selectedallSolids(dx, dy, dz);
  }      

  if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {

    SOLARCHVISION_softMove_selectedVertices(dx, dy, dz);
  }    

  if (Current_ObjectCategory == ObjectCategory.VERTEX) {

    SOLARCHVISION_move_selectedVertices(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory.FACE) {

    SOLARCHVISION_move_selectedFaces(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    SOLARCHVISION_move_selectedCurves(dx, dy, dz);
  }
  
  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    SOLARCHVISION_move_selectedallGroups(dx, dy, dz);
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    SOLARCHVISION_move_selectedallModel2Ds(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    SOLARCHVISION_move_selectedallModel1Ds(dx, dy, dz);
  }    

  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {

    SOLARCHVISION_move_selectedLandPoints(dx, dy, dz);
  }
}


void SOLARCHVISION_drop_Selection () {


  if (Current_ObjectCategory == ObjectCategory.CAMERA) {
  }     

  if (Current_ObjectCategory == ObjectCategory.SECTION) {
  }   

  if (Current_ObjectCategory == ObjectCategory.SOLID) {
  }      

  if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
  }    

  if (Current_ObjectCategory == ObjectCategory.VERTEX) {
  }  

  if (Current_ObjectCategory == ObjectCategory.FACE) {
  }  

  if (Current_ObjectCategory == ObjectCategory.CURVE) {
  }  

  if (Current_ObjectCategory == ObjectCategory.GROUP) {
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {

    for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedallModel2Ds_ids[o];

      float x = allModel2Ds.getX(OBJ_NUM);
      float y = allModel2Ds.getY(OBJ_NUM);
      float z = allModel2Ds.getZ(OBJ_NUM);

      float[] ray_start = {
        x, y, z
      };

      float[] ray_direction = {
        0, 0, -1
      };

      float[] RxP = new float [8];

      if (WIN3D.UI_TaskModifyParameter == 0) { 
        RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
      } else if (WIN3D.UI_TaskModifyParameter == 1) {
        RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
      } else {
        RxP[0] = -1; // undefined
      }

      if (RxP[0] >= 0) {
        allModel2Ds.setX(OBJ_NUM, RxP[1]); 
        allModel2Ds.setY(OBJ_NUM, RxP[2]); 
        allModel2Ds.setZ(OBJ_NUM, RxP[3]);
      } else {
        ray_direction[2] = 1; // <<<< going upwards

        if (WIN3D.UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 2) {
          RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] >= 0) {
          allModel2Ds.setX(OBJ_NUM, RxP[1]); 
          allModel2Ds.setY(OBJ_NUM, RxP[2]); 
          allModel2Ds.setZ(OBJ_NUM, RxP[3]);
        }
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedallModel1Ds_ids[o];

      float x = allModel1Ds.getX(OBJ_NUM);
      float y = allModel1Ds.getY(OBJ_NUM);
      float z = allModel1Ds.getZ(OBJ_NUM);

      float[] ray_start = {
        x, y, z
      };

      float[] ray_direction = {
        0, 0, -1
      };

      float[] RxP = new float [8];

      if (WIN3D.UI_TaskModifyParameter == 0) { 
        RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
      } else if (WIN3D.UI_TaskModifyParameter == 1) {
        RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
      } else {
        RxP[0] = -1; // undefined
      }

      if (RxP[0] >= 0) {
        allModel1Ds.setX(OBJ_NUM, RxP[1]); 
        allModel1Ds.setY(OBJ_NUM, RxP[2]); 
        allModel1Ds.setZ(OBJ_NUM, RxP[3]);
      } else {
        ray_direction[2] = 1; // <<<< going upwards

        if (WIN3D.UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 2) {
          RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] >= 0) {
          allModel1Ds.setX(OBJ_NUM, RxP[1]); 
          allModel1Ds.setY(OBJ_NUM, RxP[2]); 
          allModel1Ds.setZ(OBJ_NUM, RxP[3]);
        }
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory.LANDPOINT) {
  }
}



void SOLARCHVISION_changeProperties_Selection (int p) {

  if (Current_ObjectCategory == ObjectCategory.CAMERA) {

    for (int o = selectedCamera_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedCamera_ids[o];

      int f = OBJ_NUM;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allCameras.Type[f];
        n += p;
        if (n > 1) n = 0;
        if (n < 0) n = 1;
        allCameras.Type[f] = n;         

        if (f == WIN3D.CurrentCamera) WIN3D.ViewType = allCameras.Type[f];
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory.SECTION) {

    boolean allSolids_updated = false;  

    for (int o = selectedSection_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSection_ids[o];

      int f = OBJ_NUM;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allSections.Type[f];
        n += p;
        if (n > 3) n = 0;
        if (n < 0) n = 3;
        allSections.Type[f] = n;         

        allSolids_updated = true;
      }        

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allSections.RES1[f];
        if (p > 0) n *= 2;
        if (p < 0) n /= 2;

        if (n > 1600) n = 100;
        if (n < 100) n = 1600;
        allSections.RES1[f] = n;

        allSections.RES2[f] = n; // also modifying the other one

        println("RES:", n);

        allSolids_updated = true;
      }

    } 

    if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
  }  


  if (Current_ObjectCategory == ObjectCategory.SOLID) {

    boolean allSolids_updated = false;  

    for (int o = selectedSolid_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSolid_ids[o];

      int f = OBJ_NUM;

      if ((WIN3D.UI_CurrentTask == UITASK.PowerX) ||  (WIN3D.UI_CurrentTask == UITASK.PowerY) ||  (WIN3D.UI_CurrentTask == UITASK.PowerZ) ||  (WIN3D.UI_CurrentTask == UITASK.PowerAll)) {


        float Solid_powX = allSolids.get_powX(f);
        float Solid_powY = allSolids.get_powY(f);
        float Solid_powZ = allSolids.get_powZ(f);


        float n = 2;

        if (WIN3D.UI_CurrentTask == UITASK.PowerX) n = Solid_powX; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerY) n = Solid_powY; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerZ) n = Solid_powZ; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
          n = Solid_powX;
        }          

        if (p > 0) n *= 2;
        if (p < 0) n /= 2;

        if (n > CubePower) n = StarPower;
        if (n < StarPower) n = CubePower;

        if (WIN3D.UI_CurrentTask == UITASK.PowerX) Solid_powX = n; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerY) Solid_powY = n; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerZ) Solid_powZ = n; 
        if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
          Solid_powX = n;
          Solid_powY = n;
          Solid_powZ = n;
        } 

        allSolids.updatePowers(f, Solid_powX, Solid_powY, Solid_powZ);          

        allSolids_updated = true;
      }
    }

    if (allSolids_updated) SOLARCHVISION_calculate_SolidImpact_selectedallSections();
  }    


  if (Current_ObjectCategory == ObjectCategory.FACE) {

    for (int o = selectedFace_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFace_ids[o];

      int f = OBJ_NUM;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allFaces.getMaterial(f);
        n += p;
        if (n > 8) n = 0;
        if (n < 0) n = 8;
        allFaces.setMaterial(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allFaces.getTessellation(f);
        n += p;
        if (n > 4) n = 0;
        if (n < 0) n = 4;
        allFaces.setTessellation(f, n);
      }   

      if (WIN3D.UI_CurrentTask == UITASK.Layer) {
        int n = allFaces.getLayer(f);
        n += p;
        if (n > 16) n = 0;
        if (n < 0) n = 16;
        allFaces.setLayer(f, n);
      }  

      if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
        int n = allFaces.getVisibility(f);
        n += p;
        if (n > 2) n = 0;
        if (n < 0) n = 2;
        allFaces.setVisibility(f, n);
      }
      
      if (WIN3D.UI_CurrentTask == UITASK.Weight) {
        int n = allFaces.getWeight(f);
        n += p;
        if (n > 20) n = -20;
        if (n < -20) n = 20;
        allFaces.setWeight(f, n);
      }        
    }
  }  

  if (Current_ObjectCategory == ObjectCategory.CURVE) {

    for (int o = selectedCurve_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedCurve_ids[o];

      int f = OBJ_NUM;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allCurves.getMaterial(f);
        n += p;
        if (n > 8) n = 0;
        if (n < 0) n = 8;
        allCurves.setMaterial(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allCurves.getTessellation(f);
        n += p;
        if (n > 4) n = 0;
        if (n < 0) n = 4;
        allCurves.setTessellation(f, n);
      }   

      if (WIN3D.UI_CurrentTask == UITASK.Layer) {
        int n = allCurves.getLayer(f);
        n += p;
        if (n > 16) n = 0;
        if (n < 0) n = 16;
        allCurves.setLayer(f, n);
      }  

      if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
        int n = allCurves.getVisibility(f);
        n += p;
        if (n > 2) n = 0;
        if (n < 0) n = 2;
        allCurves.setVisibility(f, n);
      }
      
      if (WIN3D.UI_CurrentTask == UITASK.Weight) {
        int n = allCurves.getWeight(f);
        n += p;
        if (n > 20) n = -20;
        if (n < -20) n = 20;
        allCurves.setWeight(f, n);
      }        
    }
  }

  if (Current_ObjectCategory == ObjectCategory.GROUP) {

    for (int o = selectedGroup_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup_ids[o];

      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allFaces.nodes.length)) {

          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
            int n = allFaces.getMaterial(f);
            n += p;
            if (n > 8) n = 0;
            if (n < 0) n = 8;
            allFaces.setMaterial(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
            int n = allFaces.getTessellation(f);
            n += p;
            if (n > 4) n = 0;
            if (n < 0) n = 4;
            allFaces.setTessellation(f, n);
          }      

          if (WIN3D.UI_CurrentTask == UITASK.Layer) {
            int n = allFaces.getLayer(f);
            n += p;
            if (n > 16) n = 0;
            if (n < 0) n = 16;
            allFaces.setLayer(f, n);
          }  

          if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
            int n = allFaces.getVisibility(f);
            n += p;
            if (n > 2) n = 0;
            if (n < 0) n = 2;
            allFaces.setVisibility(f, n);
          }
          
          if (WIN3D.UI_CurrentTask == UITASK.Weight) {
            int n = allFaces.getWeight(f);
            n += p;
            if (n > 20) n = -20;
            if (n < -20) n = 20;
            allFaces.setWeight(f, n);
          }            
        }
      }
      
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allCurves.nodes.length)) {

          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
            int n = allCurves.getMaterial(f);
            n += p;
            if (n > 8) n = 0;
            if (n < 0) n = 8;
            allCurves.setMaterial(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
            int n = allCurves.getTessellation(f);
            n += p;
            if (n > 4) n = 0;
            if (n < 0) n = 4;
            allCurves.setTessellation(f, n);
          }      

          if (WIN3D.UI_CurrentTask == UITASK.Layer) {
            int n = allCurves.getLayer(f);
            n += p;
            if (n > 16) n = 0;
            if (n < 0) n = 16;
            allCurves.setLayer(f, n);
          }  

          if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
            int n = allCurves.getVisibility(f);
            n += p;
            if (n > 2) n = 0;
            if (n < 0) n = 2;
            allCurves.setVisibility(f, n);
          }
          
          if (WIN3D.UI_CurrentTask == UITASK.Weight) {
            int n = allCurves.getWeight(f);
            n += p;
            if (n > 20) n = -20;
            if (n < -20) n = 20;
            allCurves.setWeight(f, n);
          }            
        }
      }        
    }
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL2D) {
    for (int o = selectedallModel2Ds_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedallModel2Ds_ids[o];

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {

        int n = allModel2Ds.MAP[OBJ_NUM];
        int sign_n = 1;
        if (n < 0) sign_n = -1;

        n = abs(n);

        int n1 = allModel2Ds.PEOPLE_Files_Num;
        int n2 = allModel2Ds.PEOPLE_Files_Num + allModel2Ds.TREES_Files_Num;


        if (n <= n1) { // case: people 

          n += p;

          if (n > n1) {
            n = 1; 
            sign_n *= -1;
          }
          if (n < 1) {
            n = n1; 
            sign_n *= -1;
          }
        } else { // case: trees

          n += p;

          if (n > n2) {
            n = n1 + 1; 
            sign_n *= -1;
          }
          if (n < n1 + 1) {
            n = n2; 
            sign_n *= -1;
          }
        }

        n *= sign_n;

        allModel2Ds.MAP[OBJ_NUM] = n;
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory.MODEL1D) {

    for (int o = selectedallModel1Ds_ids.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedallModel1Ds_ids[o];

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {

        allModel1Ds.setSeed(OBJ_NUM, allModel1Ds.getSeed(OBJ_NUM) + p);
      } 
      if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) {
        int q = allModel1Ds.getDegreeMax(OBJ_NUM);

        q += p;

        if (q < 0) q = 0;

        allModel1Ds.setDegreeMax(OBJ_NUM, q);

        CreateallModel1Ds_DegreeMax = q;
        ROLLOUT.update = true;
      }
      if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
        int q1 = allModel1Ds.getDegreeMin(OBJ_NUM);
        int q2 = allModel1Ds.getDegreeMax(OBJ_NUM);
        q1 += p;
        q2 += p;

        int change_them = 1; 

        if (q1 < 0) {
          q1 = 0; 
          change_them = 0;
        } 
        if (q2 < 0) {
          q2 = 0; 
          change_them = 0;
        }

        if (change_them == 1) {

          allModel1Ds.setDegreeMin(OBJ_NUM, q1);
          allModel1Ds.setDegreeMax(OBJ_NUM, q2);

          CreateallModel1Ds_DegreeMin = q1;
          CreateallModel1Ds_DegreeMax = q2;

          ROLLOUT.update = true;
        }
      }
      if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) {
        int q = allModel1Ds.getDegreeMin(OBJ_NUM);

        q += p;

        if (q < 0) q = 0;

        allModel1Ds.setDegreeMin(OBJ_NUM, q);

        CreateallModel1Ds_DegreeMin = q;
        ROLLOUT.update = true;
      }        
      if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) {
        float q = allModel1Ds.getTrunkSize(OBJ_NUM);

        q += 0.25 * p;

        if (q < 0) q = 0;

        allModel1Ds.setTrunkSize(OBJ_NUM, q);

        CreateallModel1Ds_TrunkSize = q;
        ROLLOUT.update = true;
      }
      if (WIN3D.UI_CurrentTask == UITASK.LeafSize) {
        float q = allModel1Ds.getLeafSize(OBJ_NUM);

        q += 0.25 * p;

        if (q < 0) q = 0;

        allModel1Ds.setLeafSize(OBJ_NUM, q);

        CreateallModel1Ds_LeafSize = q;
        ROLLOUT.update = true;
      }
    }
  }
} 




void UI_dessin_Mouse (int _type, float x, float y, float r) {

  float d = 0.4 * r;

  for (int i = 0; i < 3; i++) { 

    float dx = 0;
    float dy = 0;

    if (i == 0) {
      dx = 0.5 * d;
      dy = 0.5 * d;
      strokeWeight(1);
      stroke(63); 
      fill(63);
    } else if (i == 1) {
      strokeWeight(3);
      stroke(0); 
      fill(0);
    } else {
      strokeWeight(1);
      stroke(1);
      stroke(255); 
      fill(255);
    }          

    pushMatrix();
    translate(x + d + dx, y + d + dy);

    triangle(-d, -d, -d, d, d, -d); 

    if (i == 1) {
      strokeWeight(2 + d);
    } else { 
      strokeWeight(d);
    }

    line(0, 0, d, d);

    popMatrix();
  }

  strokeWeight(0);
}

void UI_dessin_ClickSelect (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(255);  

  float d = 0.3 * r;
  triangle(-d, -d, -d, d, d, -d); 

  strokeWeight(5);
  line(0, 0, d, d);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_WindowSelect (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(63);  
  rect(-0.5 * r, -0.5 * r, 1.25 * r, 1.25 * r);

  strokeWeight(1);
  stroke(255); 
  fill(255);  

  float d = 0.3 * r;
  triangle(-d, -d, -d, d, d, -d); 

  strokeWeight(5);
  line(0, 0, d, d);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Drop (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(0);

  float d = 0.8 * r;

  if (_type == 1) {
    ellipse(0, 0, 2 * d, d);
  } 
  if ((_type == 2) || (_type == 3)) {
    beginShape();
    vertex(0, 0.5 * d);
    vertex(cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-cos_ang(30) * d, 0);
    endShape(CLOSE);
  } 




  strokeWeight(2);
  stroke(255); 
  fill(0);

  if (_type == 1) {
    line(0, 0, 0, -d);  
    line(0, 0, 0 - 0.25 * d, 0.25 * -d);
    line(0, 0, 0 + 0.25 * d, 0.25 * -d);

    line(0, 0, 0, d);  
    line(0, 0, 0 - 0.25 * d, 0.25 * d);
    line(0, 0, 0 + 0.25 * d, 0.25 * d);
  }

  if (_type == 2) {
    line(0, 0.25 * d, 0, -d);  
    line(0, 0.25 * d, 0 - 0.25 * d, 0);
    line(0, 0.25 * d, 0 + 0.25 * d, 0);
  }

  if (_type == 3) {
    line(0, 0.25 * -d, 0, d);  
    line(0, 0.25 * -d, 0 - 0.25 * d, 0);
    line(0, 0.25 * -d, 0 + 0.25 * d, 0);
  }  

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_GetLength (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();


  float d = 0.8 * r;

  beginShape();
  vertex(0, 0);
  vertex(cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, -d);
  vertex(-cos_ang(30) * d, -sin_ang(30) * d);
  endShape(CLOSE);

  beginShape();
  vertex(cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, 0);
  vertex(0, d);
  vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
  endShape(CLOSE);

  beginShape();
  vertex(-cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, 0);
  vertex(0, d);
  vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
  endShape(CLOSE);


  strokeWeight(2);
  stroke(0, 127, 255); 
  fill(0);

  if (_type == 1) {
    line(0, 0, cos_ang(30) * d, -sin_ang(30) * d);
  }
  if (_type == 2) {
    line(0, 0, cos_ang(30) * d, -sin_ang(30) * d);
  }    
  if (_type == 3) {
    line(0, 0, -cos_ang(30) * d, -sin_ang(30) * d);
  }      
  if (_type == 4) {
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);  

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }     
  if (_type == 5) {
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  }    
  if (_type == 6) {
    line(0, 0, 0, -d);
  }      


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Move (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(3);
  stroke(255); 
  noFill();  

  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);  
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
  if (_type == 4) line(-0.4 * r, -0.4 * r, 0.4 * r, 0.4 * r);

  noStroke();
  fill(255, 0, 0);
  float d = 5;
  if (_type == 1) {
    ellipse(-0.8 * r, 0, d, d); 
    ellipse(0.8 * r, 0, d, d);
  }
  if (_type == 2) {
    ellipse(0.4 * r, -0.4 * r, d, d); 
    ellipse(-0.4 * r, 0.4 * r, d, d);
  }    
  if (_type == 3) {
    ellipse(0, 0.8 * r, d, d); 
    ellipse(0, -0.8 * r, d, d);
  }
  if (_type == 4) {
    ellipse(-0.4 * r, -0.4 * r, d, d); 
    ellipse(0.4 * r, 0.4 * r, d, d);
  }  

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}

void UI_dessin_Scale (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(5);
  stroke(0, 255, 0); 
  noFill();  

  if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
  if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
  if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
  if (_type == 4) {
    line(-0.4 * r, 0, 0.4 * r, 0);
    line(0, 0.4 * r, 0, -0.4 * r);
    line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
  }  

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Power (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(3);
  stroke(0, 127, 255); 
  noFill();  

  if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
  if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
  if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
  if (_type == 4) {
    line(-0.4 * r, 0, 0.4 * r, 0);
    line(0, 0.4 * r, 0, -0.4 * r);
    line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
  }  

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Rotate (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(3);
  stroke(255); 
  noFill();  

  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);

  strokeWeight(2);
  stroke(0, 127, 255);
  noFill();
  float d = 0.85 * r;
  if (_type == 1) {
    arc(0, 0, d, d, 0.25 * PI, 1.75 * PI);
  }
  if (_type == 2) {
    arc(0, 0, d, d, (0.25 + 0.75) * PI, (1.75 + 0.75) * PI);
  }
  if (_type == 3) {
    arc(0, 0, d, d, (0.25 - 0.5) * PI, (1.75 - 0.5) * PI);
  }


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}





void UI_dessin_Seed (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(1);
  stroke(255, 255, 0); 
  noFill();  

  for (int i = 0; i < 360; i += 30) {
    float d = random(0.25, 0.75);

    line(0, 0, 0.8 * r * d * cos(i), 0.8 * r * d * sin(i));
  }  

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_Tessellation (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 1.25 * r;

  strokeWeight(2);
  stroke(255); 
  fill(63);  
  rect(-0.5 * d, -0.5 * d, d, d);

  strokeWeight(1);
  stroke(191); 
  fill(191);  

  for (int i = 1; i < 4; i++) {
    float w = (0.25 * i - 0.5) * d;
    line(-0.5 * d, w, 0.5 * d, w);  
    line(w, -0.5 * d, w, 0.5 * d);
  }

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Layer (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(2);
  stroke(255); 
  fill(0, 127, 255);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Visibility (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(0);
  stroke(255); 
  fill(127, 127);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Weight (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);


  strokeWeight(1);
  stroke(255); 
  fill(63);  
  //rect(-0.5 * r, -0.5 * r, r, r);
  
  float d = r * pow(2, 0.5);
  
  strokeWeight(1);
  noFill();  
  ellipse(0, 0, d, d);

  strokeWeight(1);
  noFill();  
  arc(0, -r, d, d, 0.25 * PI, 0.75 * PI);
  arc(r, 0, d, d, 0.75 * PI, 1.25 * PI);
  arc(0, r, d, d, 1.25 * PI, 1.75 * PI);
  arc(-r, 0, d, d, 1.75 * PI, 2.25 * PI);


  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Normal (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  if (_type == 1) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);

    line(0, 0.5 * d, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }

  if (_type == 2) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
  }


  if (_type == 3) {
    line(0, 0, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }  


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_FirstVertex (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE);

  stroke(255, 0, 0);
  ellipse(0, 0, 0.25 * d, 0.25 * d);

  fill(255);
  textSize(d);
  textAlign(CENTER, BOTTOM);
  text("1st", 0, 0);

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_3DViewSpace (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  noFill();

  strokeWeight(1);
  stroke(255); 
  if (_type == 1) fill(63);  
  if (_type == 2) fill(191);
  rect(-0.75 * r, -0.75 * r, 1.5 * r, 1.5 * r);

  if (_type == 1) fill(191);  
  if (_type == 2) fill(63);
  rect(-0.75 * r, -0.75 * r, 0.75 * r, 0.75 * r);

  strokeWeight(2);
  line(0, 0, 0.75 * r, 0.75 * r);

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}

void UI_dessin_ProjectionType (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  fill(0);


  float d = 0.8 * r;

  if (_type == 1) {

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  

  if (_type == 2) {

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0.75 * sin_ang(0) * d, 0.75 * -cos_ang(0) * d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(0.75 * sin_ang(120) * d, 0.75 * -cos_ang(120) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(0.75 * sin_ang(240) * d, 0.75 * -cos_ang(240) * d);
    endShape(CLOSE);
  }



  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Truck (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);


  stroke(255); 
  fill(0);

  float d = 0.625 * r;

  float a = 0;
  float b = 0;
  if (_type == 1) {
    a = cos_ang(30) * d; 
    b = -sin_ang(30) * d;
  }
  if (_type == 2) {
    a = -cos_ang(30) * d; 
    b = -sin_ang(30) * d;
  }
  if (_type == 3) {
    a = 0; 
    b = d;
  }

  strokeWeight(1);
  {
    pushMatrix();
    translate(0.5 * a, 0.5 * b);

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    popMatrix();
  }




  strokeWeight(2);
  {
    pushMatrix();
    translate(-0.5 * a, -0.5 * b);

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}




void UI_dessin_ZOOM (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    pushMatrix();
    translate(0.25 * r, 0.25 * r);

    stroke(255); 

    fill(0);
    strokeWeight(1);
    ellipse(-0.4 * r, -0.4 * r, 0.8 * r, 0.8 * r); 

    noFill();  
    strokeWeight(4);
    line(-0.1 * r, -0.1 * r, 0.3 * r, 0.3 * r);

    strokeWeight(2);
    stroke(255, 255, 0);
    if (_type == 1) {
      line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r); 
      line(-0.4 * r, -0.6 * r, -0.4 * r, -0.2 * r);
    } 
    if (_type == 2) {
      line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);
    }

    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_3DModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  stroke(255); 
  fill(0);
  strokeWeight(2);
  ellipse(0, 0, r, r);
  noFill();
  strokeWeight(1);
  ellipse(0, 0, 1.5 * r, 1.5 * r); 

  strokeWeight(1);
  line(-0.75 * r, 0, -0.5 * r, 0);
  line(0, -0.75 * r, 0, -0.5 * r);
  line(0.75 * r, 0, 0.5 * r, 0);
  line(0, 0.75 * r, 0, 0.5 * r);


  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}





void UI_dessin_AllModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.75 * r;

  stroke(255); 
  fill(0); 
  strokeWeight(1);
  ellipse(0, 0, d, d);
  noFill();
  strokeWeight(1);
  ellipse(0, 0, 2 * d, 2 * d); 

  strokeWeight(1);
  line(-1 * d, 0, -0.5 * d, 0);
  line(0, -1 * d, 0, -0.5 * d);
  line(1 * d, 0, 0.5 * d, 0);
  line(0, 1 * d, 0, 0.5 * d);


  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_SkydomeSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    pushMatrix();
    translate(0, 0.125 * r);

    float d = 1.0 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);
    arc(0, 0, d, d, PI, 2 * PI); 
    arc(0, 0, d, 0.333 * d, 0, PI);

    d = 1.5 * r;

    strokeWeight(2);
    stroke(255); 
    noFill();  
    arc(0, 0, d, d, PI, 2 * PI);
    arc(0, 0, d, 0.333 * d, 0, PI);

    popMatrix();
  }

  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_LandOrbit (int _type, float x, float y, float r) {

  {
    pushMatrix();
    translate(x, y);
    translate(-0.333 * r, -0.333 * r); // <<<<<<
  
    float d = 1.0 * r;
  
    strokeWeight(1);
    stroke(255); 
    fill(0); 
    ellipse(0, 0, d, d); 
  
    strokeWeight(2);
    stroke(255); 
    noFill();  
  
    if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      arc(0, 0, d, 0.333 * d, 0, PI);
    }
  
    strokeWeight(0);
  
    popMatrix();
  }
  
  {  
    pushMatrix();
    translate(x, y);
    translate(0.333 * r, 0.333 * r); // <<<<<<
  
    float d = 0.75 * r;
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
    arc(0, 0, d, d, 0, PI); 
  
    stroke(255); 
    noFill();  
  
    for (float i = -1.5; i <= 1.5; i++) { 
      line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);
  
      if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
    }
    
    strokeWeight(0);

    popMatrix();      
  }

  UI_BAR_b_Display_Text = 0;
}

void UI_dessin_Orbit (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 1.5 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0); 
  ellipse(0, 0, d, d); 

  strokeWeight(2);
  stroke(255); 
  noFill();  

  if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
  if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
  if (_type == 1) {
    arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    arc(0, 0, d, 0.333 * d, 0, PI);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_LookAtOrigin (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255);
  fill(127, 63, 0); 

  {
    float d = 0.8 * r;

    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_LookAtDirection (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255);
  fill(127, 63, 0); 

  {
    float d = 0.8 * r;

    line(-d,d/2,d,d/2);
    line(d/2,-d,d/2,d);
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_LookAtSelection (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255);
  fill(127, 63, 0); 

  {
    float d = 0.8 * r;

    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }

  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }    

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_CameraRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    float d = 1.5 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);
    ellipse(0, 0, d, d);
  }


  strokeWeight(1);
  stroke(255);
  fill(127, 63, 0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  



  {
    float d = 1.5 * r;

    strokeWeight(2);
    stroke(255); 
    noFill();  

    if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      arc(0, 0, d, 0.333 * d, 0, PI);
    }
  }  

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_TargetRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {  

    float d = 1.5 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);  
    rect(-d/2, -d/2, d, d);   

    strokeWeight(2);
    stroke(255); 
    noFill();  

    if (_type == 3) arc(0, 0, d, 0.333 * d, PI, 2 * PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
      arc(0, 0, d, 0.333 * d, PI, 2 * PI);
    }
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}


void UI_dessin_Pan (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    float d = 1.0 * r;

    strokeWeight(1);
    stroke(255); 
    noFill();  
    arc(0, 0, d, d, 0, PI); 

    stroke(255); 
    noFill();  

    for (float i = -1.5; i <= 1.5; i++) { 
      line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);

      if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
    }
  }

  strokeWeight(2);
  stroke(255); 
  noFill();  
  {
    float d = 0.75 * r;

    if (_type == 2) {
      line(-1 * d, 0, -0.5 * d, 0);
      line(1 * d, 0, 0.5 * d, 0);
    }
    if (_type == 3) {
      line(0, -1 * d, 0, -0.5 * d);
      line(0, 1 * d, 0, 0.5 * d);
    }
  }

  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_DistMouseXY (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, -0.5 * r, r, -0.5 * r);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, r, 0);
  line(-0.5 * r, -0.5 * r, -r, 0);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, 0, r);


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_CameraDistance (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);

  strokeWeight(1);
  stroke(255);
  fill(127, 63, 0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}



void UI_dessin_DistZ (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);


  strokeWeight(0);

  popMatrix();

  UI_BAR_b_Display_Text = 0;
}






int UI_X_moved = -1;
int UI_Y_moved = -1;


void mouseMoved () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (UI_BAR_a_selected_parent != -1) {

        if ((UI_X_moved != mouseX) || (UI_Y_moved != mouseY)) {

          UI_X_moved = mouseX;
          UI_Y_moved = mouseY;      

          UI_BAR_a_update = true;     

          redraw();
        }
      }
    }
  }
}



PImage pre_screen;

boolean UI_BAR_a_update = true;

float UI_BAR_a_width_parent = 4 * SOLARCHVISION_A_Pixel;
float UI_BAR_a_width_child = 3.5 * UI_BAR_a_width_parent;

int UI_BAR_a_selected_parent = -1;
int UI_BAR_a_selected_child = 0;

String[][] UI_BAR_a_Items = {
  {
    "SOLARCHVISION-2017", "Designed & developed by", "Mojtaba Samimi", "www.solarchvision.com"
  }
  , 
  {
    "Project", "New", "Save", "Hold", "Fetch", "Open...", "Save As...", "Export 3D-Model > SCR", "Export 3D-Model > RAD", "Export 3D-Model > HTML", "Export 3D-Model > OBJ", "Export 3D-Model > OBJ (date-series)", "Export 3D-Model > OBJ (time-series)", "Import 3D-Model...", "Execute CommandFile...", "Preferences", "Quit"
  }
  , 
  {
    "Site", "update Station", "Load Land Mesh", "Load Land Texture", "Download Land Mesh", "Download Land Texture", "Download Toroposphere", "Download NAEFS", "Download SWOB", "Download CLMREC", "Download Aerial" 
  }
  , 
  {
    "Data", "Typical Year (TMY)", "Long-term (CWEEDS)", "Long-term (CLMREC)", "Real-time Observed (SWOB)", "Weather Forecast (NAEFS)", "update NAEFS", "update SWOB", "update CLMREC", "update CWEEDS", "update TMYEPW", "update Aerial"
  }
  , 
  {
    "View", "Camera >> Viewport", "GoTo Selected Camera", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Display All Viewports", "Enlarge 3D Viewport", "Enlarge Map Viewport", "Enlarge Time Viewport", "Perspective", "Orthographic", "Zoom", "Zoom as default", "Look at origin", "Look at direction", "Look at selection", "Pan", "PanX", "PanY", "LandOrbit", "Orbit", "OrbitXY", "OrbitZ", "CameraRoll", "CameraRollXY", "CameraRollZ", "TargetRoll", "TargetRollXY", "TargetRollZ", "TruckX", "TruckY", "TruckZ", "DistZ", "DistMouseXY", "CameraDistance", "3DModelSize", "SkydomeSize"
  }
  , 
  {
    "Display", "Display/Hide Land Mesh", "Display/Hide Land Texture", "Display/Hide Land Points", "Display/Hide Land Depth", "Display/Hide Vertices", "Display/Hide Edges", "Display/Hide Normals", "Display/Hide Leaves", "Display/Hide allModel2Ds Objects", "Display/Hide Building Objects", "Display/Hide allSolids", "Display/Hide allSections", "Display/Hide allCameras", "Display/Hide Sky", "Display/Hide Sun Path", "Display/Hide Sun Pattern", "Display/Hide Star", "Display/Hide Moon", "Display/Hide Troposphere", "Display/Hide Earth", "Display/Hide Solar Section", "Display/Hide Solid Section", "Display/Hide Wind Flow", "Display/Hide Selected allSolids", "Display/Hide Selected allSections", "Display/Hide Selected allCameras", "Display/Hide Selected LandPoints", "Display/Hide Selected Faces", "Display/Hide Selected Faces Vertex Count", "Display/Hide Selected Curves Vertex Count", "Display/Hide Selected Vertices", "Display/Hide Selected REF Pivot", "Display/Hide Selected Group Pivot", "Display/Hide Selected Group Edges", "Display/Hide Selected Group Box", "Display/Hide Selected 2½D Edges", "Display/Hide Selected ∞-D Edges", "Display/Hide SWOB points", "Display/Hide SWOB nearest", "Display/Hide NAEFS points", "Display/Hide NAEFS nearest", "Display/Hide CWEEDS points", "Display/Hide CWEEDS nearest", "Display/Hide CLMREC points", "Display/Hide CLMREC nearest", "Display/Hide TMYEPW points", "Display/Hide TMYEPW nearest"
  }
  , 
  {
    "Shade", "Shade Surface Wire", "Shade Surface Base", "Shade Surface White", "Shade Surface Materials", "Shade Global Solar", "Shade Vertex Solar", "Shade Vertex Solid", "Shade Vertex Elevation"
  }
  , 
  {
    "Study", "Wind pattern (active)", "Wind pattern (passive)", "Urban solar potential (active)", "Urban solar potential (passive)", "Orientation potential (active)", "Orientation potential (passive)", "Hourly sun position (active)", "Hourly sun position (passive)", "View from sun & sky (active)", "View from sun & sky (passive)", "Annual cycle sun path (active)", "Annual cycle sun path (passive)", "Render Viewport", "PreBake Viewport", "Pre-bake Selected allSections", "Process Active Impact", "Process Passive Impact", "Process Solid Impact", "Run wind 3D-model"
  }
  , 
  {
    "Layers"
  }
  , // Parameters 
  {
    "Layout", "Layout -2", "Layout -1", "Layout 0", "Layout 1", "Layout 2", "Layout 3", "Layout 4", "Layout 5", "Layout 6", "Layout 7", "Layout 8", "Layout 9", "Layout 10", "Layout 11", "Layout 12", "Layout 13", "Layout 14"
  }
  , 
  {
    "Create", "Begin New Group at Origin", "Begin New Group at Pivot", "LandMesh >> Group", "LandGap >> Group", "Viewport >> Camera", "Camera", "Section", "Solid", "Point", "Spline", "Surface", "allModel1Ds", "Tree", "Person", "House1", "House2", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Icosahedron", "Tri", "Hyper", "Plane", "Poly", "Extrude", "Parametric 1", "Parametric 2", "Parametric 3", "Parametric 4", "Parametric 5", "Parametric 6", "Parametric 7", "Get dX", "Get dY", "Get dZ", "Get dXYZ", "Get dXY", "Get Angle"
  }
  , 
  {
    "Select", "Reverse Selection", "Deselect All", "Select All", "Select Solid", "Select Section", "Select Camera", "Select LandPoint", "Select allModel1Ds", "Select allModel2Ds", "Select Group", "Select Face", "Select Curve", "Select Vertex", "Soft Selection", "Group >> Vertex", "Group >> Curve", "Group >> Face", "Group >> Solid", "Group >> allModel2Ds", "Group >> allModel1Ds", "allModel1Ds >> Group", "allModel2Ds >> Group", "Solid >> Group", "Face >> Group", "Curve >> Group", "Vertex >> Group", "Vertex >> Face", "Face >> Vertex", "Click Select", "Click Select+", "Click Select-", "Window Select", "Window Select+", "Window Select-", "Select Near Vertices Selection", "Select All Isolated Vertices"
  }
  ,
 
  {
    "Edit", "Duplicate Selection (Identical)", "Duplicate Selection (Variation)", "Attach to Last Group", "Dettach from allGroups", "Group Selection", "Ungroup Selection", "Delete All Empty allGroups", "Delete Selection", "Delete All Isolated Vertices", "Delete Isolated Vertices Selection", "Separate Vertices Selection", "Reposition Vertices Selection", "Weld Objects Vertices Selection", "Weld Scene Vertices Selection", "Offset(above) Vertices", "Offset(below) Vertices", "Offset(expand) Vertices", "Offset(shrink) Vertices", "Extrude Face Edges", "Extrude Curve Edges", "Tessellation Triangular", "Tessellate Rectangular", "Tessellate Rows & Columns", "Auto-Normal Faces Selection", "Force Triangulate Faces Selection", "Insert Corner Opennings", "Insert Parallel Opennings", "Insert Rotated Opennings", "Insert Edge Opennings", "Reverse Visibility of All Faces", "Hide All Faces", "Hide Selected Faces", "Unhide Selected Faces", "Unhide All Faces", "Isolate Selection", "Reverse Visibility of All Curves", "Hide All Curves", "Hide Selected Curves", "Unhide Selected Curves", "Unhide All Curves", "Flatten Selected LandPoints"  }
  , 
  {
    "Modify", "Move", "MoveX", "MoveY", "MoveZ", "Rotate", "RotateX", "RotateY", "RotateZ", "Scale", "ScaleX", "ScaleY", "ScaleZ", "Power", "PowerX", "PowerY", "PowerZ", "Flip Normal", "Set-Out Normal", "Set-In Normal", "Get FirstVertex", "Change Seed/Material", "Change Tessellation", "Change Layer", "Change Visibility", "Change Weight", "Change DegreeMax", "Change DegreeDif", "Change DegreeMin", "Change TrunkSize", "Change LeafSize"
  }
  , 
  {
    "Match", "Save Current ReferenceBox", "Reset Saved ReferenceBox", "Use Selection ReferenceBox", "Use Origin ReferenceBox", "PivotX:Minimum", "PivotX:Center", "PivotX:Maximum", "PivotY:Minimum", "PivotY:Center", "PivotY:Maximum", "PivotZ:Minimum", "PivotZ:Center", "PivotZ:Maximum", "Pick Seed/Material", "Pick Tessellation", "Pick Layer", "Pick Visibility", "Pick DegreeMax", "Pick DegreeDif", "Pick DegreeMin", "Pick TrunkSize", "Pick LeafSize", "Pick AllallModel1DsProps", "Assign Seed/Material", "Assign Tessellation", "Assign Layer", "Assign Visibility", "Assign DegreeMax", "Assign DegreeDif", "Assign DegreeMin", "Assign TrunkSize", "Assign LeafSize", "Assign AllallModel1DsProps", "Assign Pivot", "Drop on LandSurface", "Drop on ModelSurface (Up)", "Drop on ModelSurface (Down)"
  }
  , 
  {
    "Action", "Undo", "Redo", "JPG Time Graph", "PDF Time Graph", "JPG Location Graph", "PDF Location Graph", "JPG 3D Graph", "Screenshot", "Screenshot+Click", "Screenshot+Drag", "REC. Time Graph", "REC. Location Graph", "REC. Solid Graph", "REC. Screenshot", "Stop REC.", "ERASE_allModel1Ds", "ERASE_allModel2Ds", "ERASE_allGroups", "ERASE_allSolids", "ERASE_allSections", "ERASE_allCameras", "ERASE_Faces", "ERASE_Curves", "ERASE_All"
  }
};





int LayersID_in_Bar_a = 8; 
{

  UI_BAR_a_Items[LayersID_in_Bar_a] = new String [numberOfLayers + 12];

  UI_BAR_a_Items[LayersID_in_Bar_a][0] = "Layers";

  for (int i = 0; i < numberOfLayers; i++) {

    UI_BAR_a_Items[LayersID_in_Bar_a][i + 1] = allLayers[i].descriptions[Language_EN];
  }

  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 0] = "12h accumulated Precipitation";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 1] = "Hourly precipitation";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 2] = "Wind power";  
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 3] = "Accumulated degree day <18°C<";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 4] = "Accumulated radiation on tracker";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 5] = "Accumulated radiation on surface";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 6] = "Radiation on surface inclination";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 7] = "Radiation on solar tracker";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 8] = "Radiation on surface material";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 9] = "Normal trend of parameter";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 10] = "Passive trend of parameter";
  UI_BAR_a_Items[LayersID_in_Bar_a][numberOfLayers + 11] = "Active trend of parameter";
}


void SOLARCHVISION_draw_window_BAR_a () {
  
  if (UI_BAR_a_update) {

    //println("update BAR!");

    UI_BAR_a_update = false;

    fill(127);
    noStroke();

    rect(0, 0, width, SOLARCHVISION_A_Pixel);

    STUDY.X_control = 0; //0.25 * MessageSize;
    STUDY.Y_control = 0.5 * SOLARCHVISION_A_Pixel;

    for (int i = 0; i < UI_BAR_a_Items.length; i++) {

      float cx = STUDY.X_control + i * UI_BAR_a_width_parent;
      float cy = STUDY.Y_control;
      float cr = 0.5 * SOLARCHVISION_A_Pixel; 

      if (i > 0) cx += 1.5 * UI_BAR_a_width_parent; // to include SOLARCHVISION title     

      if (isInside(mouseX, mouseY, cx, cy - cr, cx + UI_BAR_a_width_parent, cy + cr) == 1) {

        if (UI_BAR_a_selected_parent == -1) {

          pre_screen = get(0, SOLARCHVISION_A_Pixel, width, height - SOLARCHVISION_A_Pixel);

          //println("Screen GET!");
        }     

        UI_BAR_a_selected_parent = i;

        UI_BAR_a_selected_child = 0;
      }     


      textAlign(LEFT, CENTER);   

      if (UI_BAR_a_selected_parent == i) {

        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);
      } else {
        stroke(255); 
        fill(255);
        textSize(1.25 * MessageSize);
      }

      text(UI_BAR_a_Items[i][0], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize);



      if (UI_BAR_a_selected_parent == i) {

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);

        UI_BAR_a_selected_child = 0; 

        for (int j = 1; j < UI_BAR_a_Items[UI_BAR_a_selected_parent].length; j++) {

          if (isInside(UI_X_moved, UI_Y_moved, cx, cy - cr + j * SOLARCHVISION_A_Pixel, cx + UI_BAR_a_width_child, cy + cr + j * SOLARCHVISION_A_Pixel) == 1) {

            UI_BAR_a_selected_child = j;

            fill(255, 127, 0);
            noStroke();
            rect(cx, cy - cr + j * SOLARCHVISION_A_Pixel, UI_BAR_a_width_child, SOLARCHVISION_A_Pixel);
          } else {

            fill(0, 223);
            noStroke();
            rect(cx, cy - cr + j * SOLARCHVISION_A_Pixel, UI_BAR_a_width_child, SOLARCHVISION_A_Pixel);
          }

          textAlign(LEFT, CENTER);

          if (UI_BAR_a_selected_child == j) {

            stroke(0); 
            fill(0);
            textSize(1.25 * MessageSize);
          } else {
            stroke(255); 
            fill(255);

            if (UI_BAR_a_Items[i][0].equals("Display")) {
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Land Mesh")) {
                if (Land3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }       
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Land Texture")) {
                if (Land3D.Display_Textures == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Land Points")) {
                if (Land3D.Display_Points == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Land Depth")) {
                if (Land3D.Display_Depth == false) {
                  stroke(127); 
                  fill(127);
                }
              }  
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Vertices")) {
                if (allModel3Ds.DisplayVertices == false) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Edges")) {
                if (allModel3Ds.DisplayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              } 
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Normals")) {
                if (allModel3Ds.DisplayNormals == false) {
                  stroke(127); 
                  fill(127);
                }
              }               
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Leaves")) {
                if (Display_Leaves == false) {
                  stroke(127); 
                  fill(127);
                }
              }                
              if (UI_BAR_a_Items[i][j].equals("Display/Hide allModel2Ds Objects")) {
                if (Display_allModel2Ds == false) {
                  stroke(127); 
                  fill(127);
                }
                //if (Display_allModel1Ds == false) {stroke(127); fill(127);}
                //if (Display_Leaves == false) {stroke(127); fill(127);}
              } 
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Building Objects")) {
                if (Display_allModel3Ds == false) {
                  stroke(127); 
                  fill(127);
                }
              }           
              if (UI_BAR_a_Items[i][j].equals("Display/Hide allSolids")) {
                if (Display_allSolids == false) {
                  stroke(127); 
                  fill(127);
                }
              }                  
              if (UI_BAR_a_Items[i][j].equals("Display/Hide allSections")) {
                if (Display_allSections == false) {
                  stroke(127); 
                  fill(127);
                }
              }          
              if (UI_BAR_a_Items[i][j].equals("Display/Hide allCameras")) {
                if (Display_allCameras == false) {
                  stroke(127); 
                  fill(127);
                }
              }                
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Sky")) {
                if (Sky3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Sun Path")) {
                if (Display_SUN_Path == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Sun Pattern")) {
                if (Display_SUN_Pattern == false) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Star")) {
                if (Star3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Moon")) {
                if (Moon3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Earth")) {
                if (Earth3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Troposphere")) {
                if (Tropo3D.Display_Surface == false) {
                  stroke(127); 
                  fill(127);
                }
              }  
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Solar Section")) {
                if (Display_SolarImpactImage == false) {
                  stroke(127); 
                  fill(127);
                }
              }  
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Solid Section")) {
                if (Display_SolidImpactImage == false) {
                  stroke(127); 
                  fill(127);
                }
              } 
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Wind Flow")) {
                if (Display_WindFlow == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected allSolids")) {
                if (selectedSolid_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }                        
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected allSections")) {
                if (selectedSection_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }          
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected allCameras")) {
                if (selectedCamera_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }        
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected LandPoints")) {
                if (selectedLandPoint_displayPoints == false) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Faces")) {
                if (selectedFace_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }      
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Curves")) {
                if (selectedCurve_displayVertices == false) {
                  stroke(127); 
                  fill(127);
                }
              }         
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Faces Vertex Count")) {
                if (selectedFace_displayVertexCount == false) {
                  stroke(127); 
                  fill(127);
                }
              }   
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Curves Vertex Count")) {
                if (selectedCurve_displayVertexCount == false) {
                  stroke(127); 
                  fill(127);
                }
              }                
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Vertices")) {
                if (selectedVertex_displayVertices == false) {
                  stroke(127); 
                  fill(127);
                }
              }               
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected REF Pivot")) {
                if (selected_displayReferencePivot == false) {
                  stroke(127); 
                  fill(127);
                }
              }                 
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group Pivot")) {
                if (selected_displayReferencePivot == false) {
                  stroke(127); 
                  fill(127);
                }
              }                    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group Edges")) {
                if (selectedGroup_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group Box")) {
                if (selectedGroup_displayBox == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected 2½D Edges")) {
                if (selectedallModel2Ds_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (UI_BAR_a_Items[i][j].equals("Display/Hide Selected ∞-D Edges")) {
                if (selectedallModel1Ds_displayEdges == false) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (UI_BAR_a_Items[i][j].equals("Display/Hide SWOB points")) {
                if (Display_SWOB_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide SWOB nearest")) {
                if (Display_SWOB_Nearest == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide NAEFS points")) {
                if (Display_NAEFS_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide NAEFS nearest")) {
                if (Display_NAEFS_Nearest == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide CWEEDS points")) {
                if (Display_CWEEDS_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide CWEEDS nearest")) {
                if (Display_CWEEDS_Nearest == false) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide CLMREC points")) {
                if (Display_CLMREC_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide CLMREC nearest")) {
                if (Display_CLMREC_Nearest == false) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (UI_BAR_a_Items[i][j].equals("Display/Hide TMYEPW points")) {
                if (Display_TMYEPW_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (UI_BAR_a_Items[i][j].equals("Display/Hide TMYEPW nearest")) {
                if (Display_TMYEPW_Nearest == false) {
                  stroke(127); 
                  fill(127);
                }
              }
            }

            textSize(1.25 * MessageSize);
          }

          text(UI_BAR_a_Items[i][j], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize + j * SOLARCHVISION_A_Pixel);
        }
      }
    }

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
  
}


void SOLARCHVISION_modify_Viewport_Title () {

  String s = "Cam" + nf(WIN3D.CurrentCamera, 2);

  UI_BAR_b_Items[0][11] = s; // <<<<< Note: 3DViewPoint is the first index on BAR_b 
  SOLARCHVISION_highlight_in_BAR_b(s);

  UI_BAR_b_update = true;
}  



boolean UI_BAR_b_update = true;

float UI_BAR_b_tab = SOLARCHVISION_B_Pixel;

String[][] UI_BAR_b_Items = {
  {
    "11", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Cam00", "3DViewPoint", "2.0"
  }
  , 
  {
    "2", "AllViewports", "Expand3DView", "ExpandTimeView", "ExpandMapView", "3DViewSpace", "1"
  }
  , 

  {
    "2", "P<>", "P><", "ProjectionType", "1.0"
  }
  , 
  {
    "1", "LAO", "LookAtOrigin", "1.0"
  }
  , 
  {
    "1", "LAD", "LookAtDirection", "1.0"
  }  
  , 
  {
    "1", "LAS", "LookAtSelection", "1.0"
  }
  , 
  {
    "3", "CRL", "CRLz", "CRLxy", "CameraRoll", "1.0"
  }
  , 
  {
    "1", "±CDS", "CameraDistance", "1.0"
  }
  , 
  {
    "1", "±CDM", "DistMouseXY", "1.0"
  }
  , 
  {
    "1", "±CDZ", "DistZ", "1.0"
  }
  , 
  {
    "3", "DIz", "DIx", "DIy", "Truck", "1.0"
  }
  ,
  {
    "1", "LNOR", "LandOrbit", "1.0"
  }
  ,  
  {
    "1", "OR", "ORxy", "ORz", "Orbit", "1.0"
  }
  ,   
  {
    "1", "TRL", "TRLz", "TRLxy", "TargetRoll", "1.0"
  }
  , 
  {
    "1", "Pan", "PanX", "PanY", "Pan", "1.0"
  }
  , 
  {
    "1", "±ZM", "0ZM", "Zoom", "1.0"
  }
  , 
  {
    "1", "±SA", "AllModelSize", "1.0"
  }
  , 
  {
    "1", "±SZ", "3DModelSize", "1.0"
  }
  , 
  {
    "1", "±SK", "SkydomeSize", "1.0"
  }
  , 

  {
    "2", "allModel1Ds", "Tree", "Person", "allModel2DsType", "1.5"
  }
  , 
  {
    "1", "House1", "House2", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Icosahedron", "Tri", "Hyper", "Plane", "Poly", "Extrude", "Parametric", "Point", "Spline", "Surface", "BuildingType", "2.5"
  }
  , 
  {
    "1", "as_Mesh", "as_Solid", "Mesh|Solid", "2.0"
  }
  , 

  {
    "4", "LandP", "allModel1Ds", "2½D", "Group", "Face", "Vertex", "Soft", "Solid", "Section", "Camera", "Curve", "LayerType", "2.0"
  }
  , 
  {
    "1", "±CS", "+CS", "-CS", "ClickSelect", "1.0"
  }
  , 
  {
    "1", "±WS", "+WS", "-WS", "WindowSelect", "1.0"
  }
  , 
  {
    "2", "X<", "X|", "X>", "PivotX", "1.0"
  }
  , 
  {
    "2", "Y<", "Y|", "Y>", "PivotY", "1.0"
  }
  , 
  {
    "2", "Z<", "Z|", "Z>", "PivotZ", "1.0"
  }
  , 
  //{"1", "DrL±", "DrM+", "DrM-", "Drop", "1.0"},
  {
    "4", "GLx", "GLy", "GLz", "GL³", "GL²", "GLa", "GetLength", "1.0"
  }
  , 
  {
    "3", "MVx", "MVy", "MVz", "MV³", "Move", "1.0"
  }
  , 
  {
    "3", "SCx", "SCy", "SCz", "SC³", "Scale", "1.0"
  }
  , 
  {
    "3", "RTx", "RTy", "RTz", "Rotate", "1.0"
  }
  , 
  //{"3", "PWx", "PWy", "PWz", "PW³", "Power", "1.0"},
  {
    "1", "Mat0", "Mat1", "Mat2", "Mat3", "Change Seed/Material", "1.0"
  }
  , 
  {
    "1", "Tes0", "Tes1", "Tes2", "Tes3", "Change Tessellation", "1.0"
  }
  , 
  {
    "1", "Lyr0", "Lyr1", "Lyr2", "Lyr3", "Change Layer", "1.0"
  }
  , 
  {
    "1", "Vsb0", "Vsb1", "Vsb2", "Vsb3", "Change Visibility", "1.0"
  }
  , 
  {
    "1", "Wgt0", "Wgt1", "Wgt2", "Wgt3", "Change Weight", "1.0"
  }
  ,   
  {
    "1", "Norm1", "Norm2", "Norm3", "Normal", "1.0"
  }
  , 
  {
    "1", "1stV", "FirstVertex", "1.0"
  }
  , 


  //{"1", "<pvt>", ">pvt<", "|pvt|", ".pvt.", "Get/Set Pivot", "1.0"},

  //{"1", "SPvt0", "SPvt1", "SPvt2", "Pivot", "1.0"},

  //{"1", "dgMax0", "dgMax1", "dgMax2", "Change DegreeMax", "1.0"},
  //{"1", "dgDif0", "dgDif1", "dgDif2", "Change DegreeDif", "1.0"},
  //{"1", "dgMin0", "dgMin1", "dgMin2", "Change DegreeMin", "1.0"},
  //{"1", "tsSz0", "trSz1", "trSz2", "Change TrunkSize", "1.0"},
  //{"1", "lfSz0", "lfSz1", "lfSz2", "Change LeafSize", "1.0"},
  //{"1", "allFP0", "allFP1", "allFP2", "AllallModel1DsProps", "1.0"},

  //{"1", "SEC", "Section", "1.0"},
  //{"1", "SLD", "Solid", "1.0"},
  //{"1", "CAM", "Pick Study Camera", "1.0"},
};         



int UI_Bar_b_Selection = -1;                        


int UI_BAR_b_Display_Text; 


void SOLARCHVISION_highlight_in_BAR_b (String s) {

  int break_loops = 0;

  for (int i = 0; i < UI_BAR_b_Items.length; i++) {
    for (int j = 1; j < UI_BAR_b_Items[i].length - 2; j++) {
      if (UI_BAR_b_Items[i][j].equals(s)) {

        UI_BAR_b_Items[i][0] = nf(j, 0);

        break_loops = 1;
      }

      if (break_loops == 1) break;
    }
    if (break_loops == 1) break;
  }
}


void SOLARCHVISION_draw_window_BAR_b () {

  if (UI_BAR_b_update) {

    UI_BAR_b_update = false;

    fill(0);
    noStroke();
    rect(0, SOLARCHVISION_A_Pixel, width, SOLARCHVISION_B_Pixel);

    STUDY.X_control = 0; //0.25 * MessageSize;
    STUDY.Y_control = SOLARCHVISION_A_Pixel + 0.5 * SOLARCHVISION_B_Pixel;

    float cx = STUDY.X_control;
    float cy = STUDY.Y_control;
    float cr = 0.5 * SOLARCHVISION_B_Pixel;   

    for (int i = 0; i < UI_BAR_b_Items.length; i++) {

      {
        String Bar_Switch = UI_BAR_b_Items[i][UI_BAR_b_Items[i].length - 2];

        if (Bar_Switch.equals("LayerType")) {
          UI_BAR_b_Items[i][0] = nf(Current_ObjectCategory + 1, 0);
        }
      }



      int j = int(UI_BAR_b_Items[i][0]);

      float Item_width = UI_BAR_b_tab * float(UI_BAR_b_Items[i][UI_BAR_b_Items[i].length - 1]);

      noFill();
      stroke(255);
      strokeWeight(1);
      rect(cx, cy - cr, Item_width, SOLARCHVISION_B_Pixel);
      strokeWeight(0);




      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + Item_width, cy + cr) == 1) {

        if (mouseButton == RIGHT) {       

          if (UI_Bar_b_Selection != i) {
            UI_Bar_b_Selection = i;
          } else {

            int n = int(UI_BAR_b_Items[i][0]);

            n -= 1;

            if (n <= 0) n = UI_BAR_b_Items[i].length - 3;

            UI_BAR_b_Items[i][0] = nf(n, 0);

            j = n;
          }
        }

        if (mouseButton == LEFT) {

          if (UI_Bar_b_Selection != i) {
            UI_Bar_b_Selection = i;
          } else {

            int n = int(UI_BAR_b_Items[i][0]);

            n += 1;

            if (n >= UI_BAR_b_Items[i].length - 2) n = 1;

            UI_BAR_b_Items[i][0] = nf(n, 0);

            j = n;
          }
        }               


        fill(255, 127, 0);
        noStroke();
        rect(cx, cy - cr, Item_width, SOLARCHVISION_B_Pixel);     

        String Bar_Switch = UI_BAR_b_Items[i][UI_BAR_b_Items[i].length - 2];


        if (Bar_Switch.equals("LayerType")) {
          Current_ObjectCategory = j - 1;

          if (Current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
            allModel3Ds.convert_Vertex_to_softSelection();
          }

          ROLLOUT.update = true;   
          WIN3D.update = true;
        }

        if (Bar_Switch.equals("Mesh|Solid")) {
          CreateInput_MeshOrSolid = j - 1;

          ROLLOUT.update = true;
        }        

        if ((Bar_Switch.equals("allModel2DsType")) || (Bar_Switch.equals("BuildingType"))) {
          if ((UI_BAR_b_Items[i][j]).equals("allModel1Ds")) UI_set_to_Create_allModel1Ds();
          else if ((UI_BAR_b_Items[i][j]).equals("Tree")) UI_set_to_Create_Tree();
          else if ((UI_BAR_b_Items[i][j]).equals("Person")) UI_set_to_Create_Person();
          else if ((UI_BAR_b_Items[i][j]).equals("Point")) UI_set_to_Create_Vertex();
          else if ((UI_BAR_b_Items[i][j]).equals("Spline")) UI_set_to_Create_Curve();
          else if ((UI_BAR_b_Items[i][j]).equals("Surface")) UI_set_to_Create_Face();
          else if ((UI_BAR_b_Items[i][j]).equals("Tri")) UI_set_to_Create_Tri();
          else if ((UI_BAR_b_Items[i][j]).equals("Plane")) UI_set_to_Create_Plane();
          else if ((UI_BAR_b_Items[i][j]).equals("Poly")) UI_set_to_Create_Poly();
          else if ((UI_BAR_b_Items[i][j]).equals("Extrude")) UI_set_to_Create_Extrude();
          else if ((UI_BAR_b_Items[i][j]).equals("Hyper")) UI_set_to_Create_Hyper();
          else if ((UI_BAR_b_Items[i][j]).equals("House1")) UI_set_to_Create_House1();
          else if ((UI_BAR_b_Items[i][j]).equals("House2")) UI_set_to_Create_House2();
          else if ((UI_BAR_b_Items[i][j]).equals("Box")) UI_set_to_Create_Box();
          else if ((UI_BAR_b_Items[i][j]).equals("Icosahedron")) UI_set_to_Create_Octahedron();
          else if ((UI_BAR_b_Items[i][j]).equals("Octahedron")) UI_set_to_Create_Octahedron();
          else if ((UI_BAR_b_Items[i][j]).equals("Sphere")) UI_set_to_Create_Sphere();
          else if ((UI_BAR_b_Items[i][j]).equals("Cylinder")) UI_set_to_Create_Cylinder();
          else if ((UI_BAR_b_Items[i][j]).equals("Cushion")) UI_set_to_Create_Cushion();
          else if ((UI_BAR_b_Items[i][j]).equals("Parametric")) UI_set_to_Create_Parametric(CreateParametric_Type);
        }

        if (Bar_Switch.equals("Change Seed/Material")) {
          if ((UI_BAR_b_Items[i][j]).equals("Mat0")) UI_set_to_Modify_Seed(0);
          if ((UI_BAR_b_Items[i][j]).equals("Mat1")) UI_set_to_Modify_Seed(1);
          if ((UI_BAR_b_Items[i][j]).equals("Mat2")) UI_set_to_Modify_Seed(2);
          if ((UI_BAR_b_Items[i][j]).equals("Mat3")) UI_set_to_Modify_Seed(3);
        }

        if (Bar_Switch.equals("Change Tessellation")) {
          if ((UI_BAR_b_Items[i][j]).equals("Tes0")) UI_set_to_Modify_Tessellation(0);
          if ((UI_BAR_b_Items[i][j]).equals("Tes1")) UI_set_to_Modify_Tessellation(1);
          if ((UI_BAR_b_Items[i][j]).equals("Tes2")) UI_set_to_Modify_Tessellation(2);
          if ((UI_BAR_b_Items[i][j]).equals("Tes3")) UI_set_to_Modify_Tessellation(3);
        }

        if (Bar_Switch.equals("Change Layer")) {
          if ((UI_BAR_b_Items[i][j]).equals("Lyr0")) UI_set_to_Modify_Layer(0);
          if ((UI_BAR_b_Items[i][j]).equals("Lyr1")) UI_set_to_Modify_Layer(1);
          if ((UI_BAR_b_Items[i][j]).equals("Lyr2")) UI_set_to_Modify_Layer(2);
          if ((UI_BAR_b_Items[i][j]).equals("Lyr3")) UI_set_to_Modify_Layer(3);
        }

        if (Bar_Switch.equals("Change Visibility")) {
          if ((UI_BAR_b_Items[i][j]).equals("Vsb0")) UI_set_to_Modify_Visibility(0);
          if ((UI_BAR_b_Items[i][j]).equals("Vsb1")) UI_set_to_Modify_Visibility(1);
          if ((UI_BAR_b_Items[i][j]).equals("Vsb2")) UI_set_to_Modify_Visibility(2);
          if ((UI_BAR_b_Items[i][j]).equals("Vsb3")) UI_set_to_Modify_Visibility(3);
        }    
    
        if (Bar_Switch.equals("Change Weight")) {
          if ((UI_BAR_b_Items[i][j]).equals("Wgt0")) UI_set_to_Modify_Weight(0);
          if ((UI_BAR_b_Items[i][j]).equals("Wgt1")) UI_set_to_Modify_Weight(1);
          if ((UI_BAR_b_Items[i][j]).equals("Wgt2")) UI_set_to_Modify_Weight(2);
          if ((UI_BAR_b_Items[i][j]).equals("Wgt3")) UI_set_to_Modify_Weight(3);
        }           

        if (Bar_Switch.equals("Normal")) {
          if ((UI_BAR_b_Items[i][j]).equals("Norm1")) UI_set_to_Modify_Normal(1);
          if ((UI_BAR_b_Items[i][j]).equals("Norm2")) UI_set_to_Modify_Normal(2);
          if ((UI_BAR_b_Items[i][j]).equals("Norm3")) UI_set_to_Modify_Normal(3);
        }

        if (Bar_Switch.equals("FirstVertex")) {
          if ((UI_BAR_b_Items[i][j]).equals("1stV")) UI_set_to_Modify_FirstVertex(1);
        }        



        if (Bar_Switch.equals("Rotate")) UI_set_to_Modify_Rotate(j - 1);
        if (Bar_Switch.equals("Power")) UI_set_to_Modify_Power(j - 1);        
        if (Bar_Switch.equals("Scale")) UI_set_to_Modify_Scale(j - 1);
        if (Bar_Switch.equals("Move")) UI_set_to_Modify_Move(j - 1);
        if (Bar_Switch.equals("GetLength")) UI_set_to_Modify_GetLength(j - 1);
        if (Bar_Switch.equals("Drop")) UI_set_to_Modify_Drop(j - 1);

        if (Bar_Switch.equals("ProjectionType")) UI_set_to_View_ProjectionType(j - 1);

        if (Bar_Switch.equals("ClickSelect")) UI_set_to_View_ClickSelect(j - 1);
        if (Bar_Switch.equals("WindowSelect")) UI_set_to_View_WindowSelect(j - 1);

        if (Bar_Switch.equals("PivotX")) UI_set_to_View_PivotX(j - 2);
        if (Bar_Switch.equals("PivotY")) UI_set_to_View_PivotY(j - 2);
        if (Bar_Switch.equals("PivotZ")) UI_set_to_View_PivotZ(j - 2);

        if (Bar_Switch.equals("LandOrbit")) UI_set_to_View_LandOrbit(0);
        
        if (Bar_Switch.equals("Orbit")) UI_set_to_View_Orbit(j - 1);
        if (Bar_Switch.equals("CameraRoll")) UI_set_to_View_CameraRoll(j - 1);
        if (Bar_Switch.equals("TargetRoll")) UI_set_to_View_TargetRoll(j - 1);

        if (Bar_Switch.equals("LookAtOrigin")) UI_set_to_View_LookAtOrigin(j - 1);
        if (Bar_Switch.equals("LookAtDirection")) UI_set_to_View_LookAtDirection(j - 1);
        if (Bar_Switch.equals("LookAtSelection")) UI_set_to_View_LookAtSelection(j - 1);

        if (Bar_Switch.equals("Pan")) {

          UI_set_to_View_Pan(j - 1);
        }  

        if (Bar_Switch.equals("Zoom")) {
          UI_set_to_View_ZOOM(j - 1);

          UI_BAR_b_Items[i][0] = "1"; // << set it to default choice next time
        }     

        if (Bar_Switch.equals("CameraDistance")) UI_set_to_View_CameraDistance(0);

        if (Bar_Switch.equals("DistMouseXY")) UI_set_to_View_DistMouseXY(0);

        if (Bar_Switch.equals("DistZ")) UI_set_to_View_Truck(0);
        if (Bar_Switch.equals("Truck")) UI_set_to_View_Truck(j - 1);

        if (Bar_Switch.equals("3DModelSize")) UI_set_to_View_3DModelSize();

        if (Bar_Switch.equals("SkydomeSize")) UI_set_to_View_SkydomeSize();

        if (Bar_Switch.equals("AllModelSize")) UI_set_to_View_AllModelSize();

        if (Bar_Switch.equals("3DViewSpace")) UI_set_to_Viewport(j - 1);

        if (Bar_Switch.equals("3DViewPoint")) UI_set_to_View_3DViewPoint(j - 1);
      }


      UI_BAR_b_Display_Text = 1;  

      { // drawing the icons where available

        String Bar_Switch = UI_BAR_b_Items[i][UI_BAR_b_Items[i].length - 2];

        if (Bar_Switch.equals("Drop")) {
          UI_dessin_Drop(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("GetLength")) {
          UI_dessin_GetLength(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("Move")) {
          UI_dessin_Move(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Scale")) {
          UI_dessin_Scale(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }    
        if (Bar_Switch.equals("Power")) {
          UI_dessin_Power(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }            
        if (Bar_Switch.equals("Rotate")) {
          UI_dessin_Rotate(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }    
        if (Bar_Switch.equals("Change Seed/Material")) {
          UI_dessin_Seed(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Tessellation")) {
          UI_dessin_Tessellation(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Layer")) {
          UI_dessin_Layer(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Visibility")) {
          UI_dessin_Visibility(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }       
        if (Bar_Switch.equals("Change Weight")) {
          UI_dessin_Weight(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }          
        if (Bar_Switch.equals("Normal")) {
          UI_dessin_Normal(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }           
        if (Bar_Switch.equals("FirstVertex")) {
          UI_dessin_FirstVertex(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }            

        if (Bar_Switch.equals("ClickSelect")) {
          UI_dessin_ClickSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }       
        if (Bar_Switch.equals("WindowSelect")) {
          UI_dessin_WindowSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }   
        if (Bar_Switch.equals("ProjectionType")) {
          UI_dessin_ProjectionType(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }          
        if (Bar_Switch.equals("Zoom")) {
          UI_dessin_ZOOM(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("LandOrbit")) {
          UI_dessin_LandOrbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }             
        if (Bar_Switch.equals("Orbit")) {
          UI_dessin_Orbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }     
        if (Bar_Switch.equals("CameraRoll")) {
          UI_dessin_CameraRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }             
        if (Bar_Switch.equals("TargetRoll")) {
          UI_dessin_TargetRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }      
        if (Bar_Switch.equals("CameraDistance")) {
          UI_dessin_CameraDistance(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }           
        if (Bar_Switch.equals("LookAtOrigin")) {
          UI_dessin_LookAtOrigin(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }  
        if (Bar_Switch.equals("LookAtDirection")) {
          UI_dessin_LookAtDirection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }              
        if (Bar_Switch.equals("LookAtSelection")) {
          UI_dessin_LookAtSelection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }                
        if (Bar_Switch.equals("Pan")) {
          UI_dessin_Pan(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("DistMouseXY")) {
          UI_dessin_DistMouseXY(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }          
        if (Bar_Switch.equals("DistZ")) {
          UI_dessin_DistZ(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("Truck")) {
          UI_dessin_Truck(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("3DModelSize")) {
          UI_dessin_3DModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }      
        if (Bar_Switch.equals("SkydomeSize")) {
          UI_dessin_SkydomeSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("AllModelSize")) {
          UI_dessin_AllModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }  

        if (Bar_Switch.equals("3DViewSpace")) {
          UI_dessin_3DViewSpace(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
      }

      if (UI_BAR_b_Display_Text == 1) { // writing titles where the icon is not available

        textAlign(CENTER, CENTER);   
        stroke(255); 
        fill(255);
        textSize(0.45 * SOLARCHVISION_B_Pixel);

        text(UI_BAR_b_Items[i][j], cx + 0.5 * Item_width, cy - 0.2 * MessageSize);
      }


      cx += Item_width;
    }


    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
}   





void UI_set_to_Create_Nothing () {

  CreateObject = CREATE.Nothing;

  WIN3D.UI_CurrentTask = UITASK.Create;

  ROLLOUT.update = true;
}


void UI_set_to_Create_allModel1Ds () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.allModel1Ds;
  Current_ObjectCategory = ObjectCategory.MODEL1D;
}  


void UI_set_to_Create_Tree () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plant;
  Current_ObjectCategory = ObjectCategory.MODEL2D;
}

void UI_set_to_Create_Person () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Person;
  Current_ObjectCategory = ObjectCategory.MODEL2D;
}

void UI_set_to_Create_Vertex () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Vertex;
  Current_ObjectCategory = ObjectCategory.VERTEX;
}

void UI_set_to_Create_Face () {
  UI_set_to_Create_Nothing();

  defaultMaterial = DEFAULT_CreateMaterial;
  defaultTessellation = DEFAULT_CreateTessellation;
  defaultLayer = DEFAULT_CreateLayer;
  defaultVisibility = DEFAULT_CreateVisibility;
  defaultWeight = DEFAULT_CreateWeight;  
  defaultClose = DEFAULT_CreateClose;   
  
  allModel3Ds.beginNewFace();

  CreateObject = CREATE.Face;
  Current_ObjectCategory = ObjectCategory.FACE;
}

void UI_set_to_Create_Curve () {
  UI_set_to_Create_Nothing();

  defaultMaterial = DEFAULT_CreateMaterial;
  defaultTessellation = DEFAULT_CreateTessellation;
  defaultLayer = DEFAULT_CreateLayer;
  defaultVisibility = DEFAULT_CreateVisibility;
  defaultWeight = DEFAULT_CreateWeight;  
  defaultClose = DEFAULT_CreateClose;   
  
  allModel3Ds.beginNewCurve();

  CreateObject = CREATE.Curve;
  Current_ObjectCategory = ObjectCategory.CURVE;
}

void UI_set_to_Create_Solid () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Solid;
  Current_ObjectCategory = ObjectCategory.SOLID;
}

void UI_set_to_Create_Section () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Section;
  Current_ObjectCategory = ObjectCategory.SECTION;
}


void UI_set_to_Create_Camera () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Camera;
  Current_ObjectCategory = ObjectCategory.CAMERA;
}






void UI_set_to_Create_Parametric (int n) {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Parametric;
  CreateParametric_Type = n;

  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Tri () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Tri;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Plane () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plane;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Poly () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Poly;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Extrude () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Extrude;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Hyper () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Hyper;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_House1 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House1;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_House2 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House2;
  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Box () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = CubePower;   
  CreateInput_powY = CubePower; 
  CreateInput_powZ = CubePower;             

  Current_ObjectCategory = ObjectCategory.GROUP;
}


void UI_set_to_Create_Icosahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = 1;  
  CreateInput_powY = 1; 
  CreateInput_powZ = 1;            

  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Octahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = 1;  
  CreateInput_powY = 1; 
  CreateInput_powZ = 1;            

  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Sphere () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = 2;  
  CreateInput_powY = 2; 
  CreateInput_powZ = 2;            

  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Cylinder () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = 2;  
  CreateInput_powY = 2; 
  CreateInput_powZ = CubePower;             

  Current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Cushion () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  CreateInput_powX = CubePower;   
  CreateInput_powY = CubePower;  
  CreateInput_powZ = 2;            

  Current_ObjectCategory = ObjectCategory.GROUP;
}




void UI_set_to_Modify_Move (int n) {
  WIN3D.UI_CurrentTask = UITASK.Move;

  selected_posVector = n;

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Scale (int n) {
  WIN3D.UI_CurrentTask = UITASK.Scale;

  selected_scaleVector = n;

  ROLLOUT.update = true;
}


void UI_set_to_Modify_Rotate (int n) {
  WIN3D.UI_CurrentTask = UITASK.Rotate;

  selected_rotVector = n;

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Seed (int n) {
  WIN3D.UI_CurrentTask = UITASK.Seed_Material;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Tessellation (int n) {
  WIN3D.UI_CurrentTask = UITASK.Tessellation;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Layer (int n) {
  WIN3D.UI_CurrentTask = UITASK.Layer;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Visibility (int n) {
  WIN3D.UI_CurrentTask = UITASK.Visibility;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Weight (int n) {
  WIN3D.UI_CurrentTask = UITASK.Weight;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

// the same messages of WIN3D.UI_CurrentTask=6/7 for both Layer/Visibility of group3Ds and DegreeMax/DegreeDif is not good!

void UI_set_to_Modify_DegreeMax (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeMax;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_DegreeDif (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeDif;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_DegreeMin (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeMin;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_TrunkSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.TrunkSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_LeafSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.LeafSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_AllallModel1DsProps (int n) {
  WIN3D.UI_CurrentTask = UITASK.AllallModel1DsProps;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Pivot (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pivot;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Normal (int n) {
  WIN3D.UI_CurrentTask = UITASK.Normal;
  WIN3D.UI_TaskModifyParameter = n; // 1:flip normal, 2:set out from pivot, 3:set in from pivot    

  ROLLOUT.update = true;
}

void UI_set_to_Modify_FirstVertex (int n) {
  WIN3D.UI_CurrentTask = UITASK.FirstVertex;
  WIN3D.UI_TaskModifyParameter = n; // 1:default

  ROLLOUT.update = true;
}




void UI_set_to_Modify_Drop (int n) {
  WIN3D.UI_CurrentTask = UITASK.Drop;

  WIN3D.UI_TaskModifyParameter = n; // 0:LandSurface± 1:ModelSurface- 2:ModelSurface+

  ROLLOUT.update = true;
}


void UI_set_to_Modify_GetLength (int n) {
  WIN3D.UI_CurrentTask = UITASK.GetLength;

  WIN3D.UI_TaskModifyParameter = n; // 0:x 1:y 2:z 3:xyz 4:xy 5:angle(on XY plane) 

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Power (int n) {

  if (n == 0) WIN3D.UI_CurrentTask = UITASK.PowerX; // x 
  if (n == 1) WIN3D.UI_CurrentTask = UITASK.PowerY; // y 
  if (n == 2) WIN3D.UI_CurrentTask = UITASK.PowerZ; // z 
  if (n == 3) WIN3D.UI_CurrentTask = UITASK.PowerAll; // xyz

  WIN3D.UI_TaskModifyParameter = 0; // 0:change

  ROLLOUT.update = true;
}










void UI_set_to_View_ProjectionType (int n) {
  WIN3D.ViewType = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_ClickSelect (int n) {

  WIN3D.UI_CurrentTask = UITASK.PickSelect;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.update = true;
}

void UI_set_to_View_WindowSelect (int n) {
  WIN3D.UI_CurrentTask = UITASK.RectSelect;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.update = true;
}    

void UI_set_to_View_PivotX (int n) {

  selection_alignX = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_PivotY (int n) {

  selection_alignY = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_PivotZ (int n) {

  selection_alignZ = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}      


void UI_set_to_View_Truck (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  


void UI_set_to_View_DistMouseXY (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.DistMouseXY_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.update = true;
}  



void UI_set_to_View_CameraDistance (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraDistance_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.update = true;
}  



void UI_set_to_View_CameraRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  



void UI_set_to_View_TargetRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.TargetRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  


void UI_set_to_View_Orbit (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  



void UI_set_to_View_LandOrbit (int n) {

  WIN3D.UI_CurrentTask = UITASK.LandOrbit_Pan_TargetRollZ;

  ROLLOUT.update = true;
}  



void UI_set_to_View_LookAtSelection (int n) {

  WIN3D.look_3DViewport_towards_Selection();

  { // automatically set another choice of ineterest
    UI_set_to_View_CameraDistance(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDS");
    UI_BAR_b_update = true;
  }

  WIN3D.update = true;

  ROLLOUT.update = true;
}  


void UI_set_to_View_LookAtDirection (int n) {

  WIN3D.UI_CurrentTask = UITASK.LookAtDirection;

  ROLLOUT.update = true;
}  


void UI_set_to_View_LookAtOrigin (int n) {

  WIN3D.X_Coordinate = 0;
  WIN3D.Y_Coordinate = 0;
  WIN3D.Z_Coordinate = 0; 

  {
    // automatically set another choice of ineterest

    UI_set_to_View_Truck(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDZ");
    UI_BAR_b_update = true;
  }

  WIN3D.update = true;

  ROLLOUT.update = true;
}  


void UI_set_to_View_Pan (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Pan_TargetRoll;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.PanX_TargetRollXY_TargetRollZ;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.PanY_TargetRollXY_TargetRollZ;
  }


  ROLLOUT.update = true;
}  

void UI_set_to_View_ZOOM (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pan_Height;

  if (n == 1) {
    WIN3D.Zoom = 60;
    WIN3D.update = true;
  }

  ROLLOUT.update = true;
}      

void UI_set_to_View_3DModelSize () {

  WIN3D.UI_CurrentTask = UITASK.ModelSize_Pan_TargetRoll;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}      

void UI_set_to_View_SkydomeSize () {

  WIN3D.UI_CurrentTask = UITASK.SkydomeSize;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}   

void UI_set_to_View_AllModelSize () {

  WIN3D.UI_CurrentTask = UITASK.AllModelSize;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}   


void UI_set_to_Viewport (int n) {

  FrameVariation = n;
  SOLARCHVISION_update_frame_layout();

  ROLLOUT.update = true;
}

void UI_set_to_View_3DViewPoint (int n) {

  WIN3D.CurrentCamera = 0;

  WIN3D.apply_currentCamera();

  if (n == 0) {
    WIN3D.rotateZ_3DViewport_around_Selection(0 - WIN3D.RX_Coordinate);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.RZ_Coordinate);
  }

  if (n == 1) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.RZ_Coordinate);
  }          

  if (n == 2) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(-90 - WIN3D.RZ_Coordinate);
  }    

  if (n == 3) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(180 - WIN3D.RZ_Coordinate);
  }   

  if (n == 4) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(90 - WIN3D.RZ_Coordinate);
  }  

  if (n == 5) {
    WIN3D.rotateZ_3DViewport_around_Selection(180 - WIN3D.RX_Coordinate);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.RZ_Coordinate);
  }             

  if (n == 6) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(-45 - WIN3D.RZ_Coordinate);
  }             

  if (n == 7) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(45 - WIN3D.RZ_Coordinate);
  }     

  if (n == 8) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(135 - WIN3D.RZ_Coordinate);
  }

  if (n == 9) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.RX_Coordinate); 
    WIN3D.rotateXY_3DViewport_around_Selection(-135 - WIN3D.RZ_Coordinate);
  }


  UI_BAR_b_update = true;

  WIN3D.update = true;   

  ROLLOUT.update = true;
} 









boolean UI_BAR_d_update = true;

float UI_BAR_d_tab;

String[][] UI_BAR_d_Items = {

  {
    "Day"
  }
  , 
  {
    "Year"
  }
  , 
  {
    "Scenario"
  }
};         



void SOLARCHVISION_draw_window_BAR_d () {

  if (UI_BAR_d_update) {

    UI_BAR_d_update = false;

    UI_BAR_d_tab = SOLARCHVISION_D_Pixel / float(UI_BAR_d_Items.length);

    fill(191);
    noStroke();
    rect(0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel, width, SOLARCHVISION_D_Pixel);



    float displayBarHeight = MessageSize;
    float displayBarWidth = 2 * SOLARCHVISION_W_Pixel; 

    STUDY.X_control = 0.5 * displayBarWidth;
    STUDY.Y_control = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel + 0.5 * UI_BAR_d_tab;

    for (int i = 0; i < UI_BAR_d_Items.length; i++) {

      float x1 = STUDY.X_control - 0.3666 * displayBarWidth;
      float x2 = STUDY.X_control + 0.4875 * displayBarWidth;
      float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
      float y2 = STUDY.Y_control + 0.45 * displayBarHeight;

      fill(127);
      noStroke();      
      rect(x1, y1, x2 - x1, y2 - y1);      

      textAlign(RIGHT, CENTER);   
      stroke(0); 
      fill(0);
      textSize(1.25 * MessageSize);

      text(UI_BAR_d_Items[i][0] + ": ", x1, STUDY.Y_control - 0.2 * MessageSize);

      if (UI_BAR_d_Items[i][0].equals("Day")) {

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {
            STUDY.i_Start = int(roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            ROLLOUT.update = true;
            STUDY.update = true;
            WIN3D.update = true;
            WORLD.update = true;

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }

          if (mouseButton == RIGHT) {
            STUDY.i_End = int(roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            ROLLOUT.update = true;
            STUDY.update = true;
            WIN3D.update = true;
            WORLD.update = true;

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }
        }        

        float x_start = x1 + (x2 - x1) * (STUDY.i_Start) / 24.0;  
        float x_end = x1 + (x2 - x1) * (STUDY.i_End + 1) / 24.0;

        fill(0, 191, 0, 191);
        noStroke();

        if (STUDY.i_Start <= STUDY.i_End) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        } else {
          rect(x1, y1, x_end - x1, y2 - y1);
          rect(x_start, y1, x2 - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);

        for (int j = 0; j < 24; j++) {
          text(nf(j, 0), x1 + (x2 - x1) * (j + 0.5) / 24.0, STUDY.Y_control - 0.2 * MessageSize);
        }
      }

      if (UI_BAR_d_Items[i][0].equals("Year")) {

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {
            float keep_TIME_Date = TIME_Date;
            TIME_Date = (int(roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
            SOLARCHVISION_update_date(); 
            TIME_BeginDay = int(TIME_BeginDay + (TIME_Date - keep_TIME_Date) + 365) % 365;
            update_ENSEMBLE_FORECAST(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
            
            STUDY.update = true; 
            ROLLOUT.update = true;
            WIN3D.update = true;            

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }

          if (mouseButton == RIGHT) {

            float _DATE2 = (int(roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;

            if (TIME_Date > _DATE2) _DATE2 += 365;

            STUDY.PerDays = int(roundTo((_DATE2 - TIME_Date) / float(STUDY.j_End - STUDY.j_Start - 1), 1));

            if (STUDY.PerDays < 0) STUDY.PerDays = 1;

            STUDY.update = true; 
            ROLLOUT.update = true;
            WIN3D.update = true;

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }
        }        

        float keep_STUDY_PerDays = STUDY.PerDays;
        int keep_STUDY_JoinDays = STUDY.JoinDays;
        if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
          STUDY.PerDays = 1;
          STUDY.JoinDays = 1;
        }

        for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 

          for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {    

            int now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;

            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            float x_start = x1 + (x2 - x1) * ((now_j) % 365) / 365.0;  
            float x_end = x1 + (x2 - x1) * ((now_j + 1) % 365) / 365.0;

            fill(191, 0, 0, 191);
            noStroke();

            if (x_start <= x_end) { 
              rect(x_start, y1, x_end - x_start, y2 - y1);
            } else {
              rect(x1, y1, x_end - x1, y2 - y1);
              rect(x_start, y1, x2 - x_start, y2 - y1);
            }
          }
        }

        {
          textAlign(CENTER, CENTER);   
          stroke(0); 
          fill(0);
          textSize(1.25 * MessageSize);

          for (int j = 0; j < 12; j++) {
            text(CalendarMonth[j][Language_Active], x1 + (x2 - x1) * (j + 0.5) / 12.0, STUDY.Y_control - 0.2 * MessageSize);
          }
        }        

        STUDY.PerDays = keep_STUDY_PerDays;
        STUDY.JoinDays = keep_STUDY_JoinDays;
      }


      if (UI_BAR_d_Items[i][0].equals("Scenario")) {

        int n1 = 0;
        int n2 = 1;

        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
          n1 = 1950;
          n2 = 2050;
        }
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
          n1 = 1950;
          n2 = 2050;
        }        
        if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
          n1 = 1950;
          n2 = 2050;
        }        
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
          n1 = ENSEMBLE_FORECAST_start;
          n2 = ENSEMBLE_FORECAST_end;
        }        
        if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
          n1 = ENSEMBLE_OBSERVED_start;
          n2 = ENSEMBLE_OBSERVED_end;
        }  

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {

            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
              SampleYear_Start = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

            }
            
            if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
              SampleYear_Start = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

            }            

            if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
              SampleMember_Start = V_selection;

              if (SampleMember_Start > SampleMember_End) {
                int swap_tmp = SampleMember_Start;
                SampleMember_Start = SampleMember_End;
                SampleMember_End = swap_tmp;
              }

            }            

            if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
              SampleStation_Start = V_selection;

              if (SampleStation_Start > SampleStation_End) {
                int swap_tmp = SampleStation_Start;
                SampleStation_Start = SampleStation_End;
                SampleStation_End = swap_tmp;
              }

            }       

            ROLLOUT.update = true;
            STUDY.update = true;
            WIN3D.update = true;

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }

          if (mouseButton == RIGHT) {

            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
              SampleYear_End = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

            }

            if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
              SampleYear_End = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

            }

            if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
              SampleMember_End = V_selection;

              if (SampleMember_Start > SampleMember_End) {
                int swap_tmp = SampleMember_Start;
                SampleMember_Start = SampleMember_End;
                SampleMember_End = swap_tmp;
              }

            }

            if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
              SampleStation_End = V_selection;

              if (SampleStation_Start > SampleStation_End) {
                int swap_tmp = SampleStation_Start;
                SampleStation_Start = SampleStation_End;
                SampleStation_End = swap_tmp;
              }

            }                

            ROLLOUT.update = true;
            STUDY.update = true;
            WIN3D.update = true;

            SOLARCHVISION_find_which_bakings_to_regenerate();
          }
        }        

        float V_start = 0;  
        float V_end = 0;        

        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
          V_start = SampleYear_Start;
          V_end = SampleYear_End;
        }
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
          V_start = SampleYear_Start;
          V_end = SampleYear_End;
        }        
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
          V_start = SampleMember_Start;
          V_end = SampleMember_End;
        }
        if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
          V_start = SampleStation_Start;
          V_end = SampleStation_End;
        }        

        float x_start = x1 + (x2 - x1) * (V_start - n1) / float(n2 - n1 + 1);  
        float x_end = x1 + (x2 - x1) * (V_end - n1 + 1) / float(n2 - n1 + 1);

        fill(0, 0, 191, 191);
        noStroke();

        if (x_start <= x_end) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);

        for (int j = 0; j < n2 - n1 + 1; j++) {

          String txt = ".";

          if (j % 5 == 0) {
            txt = "|";
          }          

          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
            if ((j % 10 == 5)) {
              txt = nf(j - 5 + n1, 0) + "s";
            }
          }
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
            if ((j % 10 == 5)) {
              txt = nf(j - 5 + n1, 0) + "s";
            }
          }          
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
            //if ((j % 1 == 0)) {
            txt = nf(j + n1, 0);
            //}
          }
          if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
            //if ((j % 1 == 0)) {
            txt = SWOB_Coordinates[nearest_Station_ENSEMBLE_OBSERVED_id[j]].getCode();
            //}
          }                 

          text(txt, x1 + (x2 - x1) * (j + 0.5) / float(n2 - n1 + 1), STUDY.Y_control - 0.2 * MessageSize);
        }
      }        




      STUDY.Y_control += UI_BAR_d_tab;
    }


    displayBarWidth = ROLLOUT.dX; // <<<<<<<<<
    displayBarHeight = 4.5 * MessageSize;

    float temp_offsetX = ROLLOUT.cX + 0.5 * displayBarWidth;
    float temp_offsetY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_C_Pixel + 0.5 * displayBarHeight;

    for (int n = 0; n < 9; n++) {

      int i = 2 - n / 3;
      int j = 2 - n % 3;

      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;

      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

        STUDY.ImpactLayer = n;

        STUDY.update = true; 
        ROLLOUT.update = true;
        WIN3D.update = true;

        SOLARCHVISION_find_which_bakings_to_regenerate();
      }
    }

    for (int n = 0; n < 9; n++) {

      int i = 2 - n / 3;
      int j = 2 - n % 3;

      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;

      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (n == STUDY.ImpactLayer) { 
        fill(255, 127, 0);
        noStroke();
      } else if (n / 3 == STUDY.ImpactLayer / 3) {
        fill(127, 63, 0);
        noStroke();
      } else {
        fill(127);
        noStroke();
      }  
      rect(x1, y1, x2 - x1, y2 - y1);      

      textAlign(CENTER, CENTER);   
      if (n == STUDY.ImpactLayer) { 
        stroke(0); 
        fill(0);
      } else if (n / 3 == STUDY.ImpactLayer / 3) {
        stroke(191); 
        fill(191);
      } else {
        stroke(255); 
        fill(255);
      }        

      if (n == STUDY.ImpactLayer) { 
        textSize(1.25 * MessageSize);
      } else {
        textSize(1.125 * MessageSize);
      }

      text(STAT_N_Title[n], 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.2 * MessageSize);
    }    

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
}   





void SOALRCHVISION_refreshDateTabs () {
  if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || (CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
    if (STUDY.PerDays == 1) { 
      STUDY.PerDays = int(365 / float(STUDY.j_End - STUDY.j_Start));
    } else {
      STUDY.PerDays = 1;
    }
  } 
  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    STUDY.PerDays = 1;
  }           
  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    if (STUDY.PerDays == 1) { 
      STUDY.PerDays = int(ENSEMBLE_OBSERVED_maxDays / float(STUDY.j_End - STUDY.j_Start));
    } else {
      STUDY.PerDays = 1;
    }
  }
}  










int[] get_startK_endK () {
  int[] a = new int [2];

  int start_k = -1;
  int end_k = -1; 

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End; 

    if (start_k < CLIMATE_CWEEDS_start) start_k = CLIMATE_CWEEDS_start;
    if (end_k > CLIMATE_CWEEDS_end) end_k = CLIMATE_CWEEDS_end;

    start_k -= CLIMATE_CWEEDS_start;
    end_k -= CLIMATE_CWEEDS_start;
  }
  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End;

    if (start_k < CLIMATE_CLMREC_start) start_k = CLIMATE_CLMREC_start;
    if (end_k > CLIMATE_CLMREC_end) end_k = CLIMATE_CLMREC_end;

    start_k -= CLIMATE_CLMREC_start;
    end_k -= CLIMATE_CLMREC_start;
  }  
  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {

    start_k = 0;
    end_k = 0;   
  }     
  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {

    start_k = SampleMember_Start;
    end_k = SampleMember_End;

    start_k -= ENSEMBLE_FORECAST_start;
    end_k -= ENSEMBLE_FORECAST_start;    
  }    
  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {

    start_k =  SampleStation_Start;
    end_k =  SampleStation_End;
    
    start_k -= ENSEMBLE_OBSERVED_start;
    end_k -= ENSEMBLE_OBSERVED_start;     
  }   


  //println("start_k=", start_k);
  //println("end_k=", end_k);

  a[0] = start_k;
  a[1] = end_k;
  
  return  a;
}



void SOLARCHVISION_explore_output (String outputFile) {

  if ((Display_Output_in_Explorer)  && (STUDY.record_AUTO == false) && (WORLD.record_AUTO == false) && (WIN3D.record_AUTO == false) && (FRAME_record_AUTO == false)) {
    launch("explorer /select," + outputFile.replace('/', char(92)));
  }
}





              


void SOLARCHVISION_save_project (String myFile, boolean explore_output) {

  myFile = myFile.replace(char(92), '/');

  XML my_xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  XML newChild1 = null;
  XML newChild2 = null;
  XML newChild3 = null;


  my_xml.setName("SOLARCHVISION_" + SOLARCHVISION_version + "_project");

  STATION.to_XML(my_xml);


  newChild1 = my_xml.addChild("SOLARCHVISION_variables");

  newChild1.setString("Display_Output_in_Explorer", Boolean.toString(Display_Output_in_Explorer));
  newChild1.setString("Display_allModel3Ds", Boolean.toString(Display_allModel3Ds));
  newChild1.setString("Display_allModel2Ds", Boolean.toString(Display_allModel2Ds));
  newChild1.setString("Display_allModel1Ds", Boolean.toString(Display_allModel1Ds));
  newChild1.setString("Display_Leaves", Boolean.toString(Display_Leaves));

  newChild1.setString("Display_allSolids", Boolean.toString(Display_allSolids));
  newChild1.setString("Display_allSections", Boolean.toString(Display_allSections));
  newChild1.setString("Display_allCameras", Boolean.toString(Display_allCameras));

  newChild1.setInt("DEFAULT_CreateMaterial", DEFAULT_CreateMaterial);  
  newChild1.setInt("DEFAULT_CreateTessellation", DEFAULT_CreateTessellation);
  newChild1.setInt("DEFAULT_CreateLayer", DEFAULT_CreateLayer);
  newChild1.setInt("DEFAULT_CreateVisibility", DEFAULT_CreateVisibility);
  newChild1.setInt("DEFAULT_CreateWeight", DEFAULT_CreateWeight);
  newChild1.setInt("DEFAULT_CreateClose", DEFAULT_CreateClose);
  newChild1.setInt("DEFAULT_CreatePivotType", DEFAULT_CreatePivotType);

  newChild1.setFloat("ModifyInput_WeldTreshold", ModifyInput_WeldTreshold);

  newChild1.setFloat("ModifyInput_OffsetAmount", ModifyInput_OffsetAmount);

  newChild1.setInt("ModifyInput_TessellateRows", ModifyInput_TessellateRows);
  newChild1.setInt("ModifyInput_TessellateColumns", ModifyInput_TessellateColumns);

  newChild1.setFloat("ModifyInput_OpenningDepth", ModifyInput_OpenningDepth);
  newChild1.setFloat("ModifyInput_OpenningArea", ModifyInput_OpenningArea);
  newChild1.setFloat("ModifyInput_OpenningDeviation", ModifyInput_OpenningDeviation);
  newChild1.setFloat("CreateInput_Length", CreateInput_Length);
  newChild1.setFloat("CreateInput_Width", CreateInput_Width);
  newChild1.setFloat("CreateInput_Height", CreateInput_Height);
  newChild1.setFloat("CreateInput_Volume", CreateInput_Volume);
  newChild1.setFloat("CreateInput_Orientation", CreateInput_Orientation);
  newChild1.setFloat("CreateInput_powX", CreateInput_powX);
  newChild1.setFloat("CreateInput_powY", CreateInput_powY);
  newChild1.setFloat("CreateInput_powZ", CreateInput_powZ);
  newChild1.setFloat("CreateInput_powAll", CreateInput_powAll);
  newChild1.setInt("CreateInput_powRnd", CreateInput_powRnd);
  newChild1.setInt("CreateInput_SphereDegree", CreateInput_SphereDegree);
  newChild1.setInt("CreateInput_CylinderDegree", CreateInput_CylinderDegree);
  newChild1.setInt("CreateInput_PolyDegree", CreateInput_PolyDegree);
  newChild1.setInt("CreateInput_Snap", CreateInput_Snap);
  
  newChild1.setInt("CreateParametric_Type", CreateParametric_Type);
  newChild1.setInt("CreatePerson_Type", CreatePerson_Type);
  newChild1.setInt("CreatePlant_Type", CreatePlant_Type);
  newChild1.setInt("CreateallModel1Ds_Type", CreateallModel1Ds_Type);
  newChild1.setInt("CreateallModel1Ds_DegreeMin", CreateallModel1Ds_DegreeMin);
  newChild1.setInt("CreateallModel1Ds_DegreeMax", CreateallModel1Ds_DegreeMax);
  newChild1.setInt("CreateallModel1Ds_Seed", CreateallModel1Ds_Seed);
  newChild1.setFloat("CreateallModel1Ds_TrunkSize", CreateallModel1Ds_TrunkSize);
  newChild1.setFloat("CreateallModel1Ds_LeafSize", CreateallModel1Ds_LeafSize);
  newChild1.setInt("Current_ObjectCategory", Current_ObjectCategory);
  newChild1.setInt("CreateInput_MeshOrSolid", CreateInput_MeshOrSolid);
  newChild1.setInt("WIN3D.UI_CurrentTask", WIN3D.UI_CurrentTask);
  newChild1.setInt("WIN3D.UI_OptionXorY", WIN3D.UI_OptionXorY);
  newChild1.setInt("WIN3D.UI_TaskModifyParameter", WIN3D.UI_TaskModifyParameter);  

  newChild1.setInt("Display_SWOB_Points", Display_SWOB_Points);
  newChild1.setInt("Display_NAEFS_Points", Display_NAEFS_Points);
  newChild1.setInt("Display_CWEEDS_Points", Display_CWEEDS_Points);
  newChild1.setInt("Display_CLMREC_Points", Display_CLMREC_Points);
  newChild1.setInt("Display_TMYEPW_Points", Display_TMYEPW_Points);
  
  newChild1.setString("Display_SWOB_Nearest", Boolean.toString(Display_SWOB_Nearest));
  newChild1.setString("Display_NAEFS_Nearest", Boolean.toString(Display_NAEFS_Nearest));
  newChild1.setString("Display_CWEEDS_Nearest", Boolean.toString(Display_CWEEDS_Nearest));
  newChild1.setString("Display_CLMREC_Nearest", Boolean.toString(Display_CLMREC_Nearest));
  newChild1.setString("Display_TMYEPW_Nearest", Boolean.toString(Display_TMYEPW_Nearest));

  newChild1.setFloat("SolidImpact_WindSpeed", SolidImpact_WindSpeed); 
  newChild1.setFloat("SolidImpact_WindDirection", SolidImpact_WindDirection);
  newChild1.setFloat("SolidImpact_Power", SolidImpact_Power);
  newChild1.setFloat("GlobalAlbedo", GlobalAlbedo);
  newChild1.setFloat("Interpolation_Weight", Interpolation_Weight);
  newChild1.setFloat("GLOBE_calculatedResolution", GLOBE_calculatedResolution);
  newChild1.setInt("CLIMATIC_SolarForecast", CLIMATIC_SolarForecast);
  newChild1.setInt("CLIMATIC_WeatherForecast", CLIMATIC_WeatherForecast);
  newChild1.setInt("SOLARCHVISION_automated", SOLARCHVISION_automated);

  newChild1.setInt("TIME_ModelRun", TIME_ModelRun);
  newChild1.setInt("TIME_Year", TIME_Year);
  newChild1.setInt("TIME_Month", TIME_Month);
  newChild1.setInt("TIME_Day", TIME_Day); 
  newChild1.setInt("TIME_Hour", TIME_Hour); 
  newChild1.setInt("TIME_BeginDay", TIME_BeginDay);
  newChild1.setFloat("TIME_Date", TIME_Date);

  newChild1.setInt("STUDY.j_Start", STUDY.j_Start);
  newChild1.setInt("STUDY.j_End", STUDY.j_End);
  newChild1.setFloat("STUDY.PerDays", STUDY.PerDays);
  newChild1.setInt("STUDY.JoinDays", STUDY.JoinDays);
  newChild1.setInt("CLIMATE_TMYEPW_start", CLIMATE_TMYEPW_start);
  newChild1.setInt("CLIMATE_TMYEPW_end", CLIMATE_TMYEPW_end);
  newChild1.setInt("CLIMATE_CWEEDS_start", CLIMATE_CWEEDS_start);
  newChild1.setInt("CLIMATE_CWEEDS_end", CLIMATE_CWEEDS_end);
  newChild1.setInt("CLIMATE_CLMREC_start", CLIMATE_CLMREC_start);
  newChild1.setInt("CLIMATE_CLMREC_end", CLIMATE_CLMREC_end);
  newChild1.setInt("ENSEMBLE_FORECAST_start", ENSEMBLE_FORECAST_start);
  newChild1.setInt("ENSEMBLE_FORECAST_end", ENSEMBLE_FORECAST_end);
  newChild1.setInt("ENSEMBLE_FORECAST_maxDays", ENSEMBLE_FORECAST_maxDays);
  newChild1.setInt("ENSEMBLE_OBSERVED_maxDays", ENSEMBLE_OBSERVED_maxDays);
  newChild1.setInt("ENSEMBLE_OBSERVED_numNearest", ENSEMBLE_OBSERVED_numNearest);
  newChild1.setInt("ENSEMBLE_OBSERVED_start", ENSEMBLE_OBSERVED_start);
  newChild1.setInt("ENSEMBLE_OBSERVED_end", ENSEMBLE_OBSERVED_end);
  newChild1.setInt("SampleYear_Start", SampleYear_Start);
  newChild1.setInt("SampleYear_End", SampleYear_End);
  newChild1.setInt("SampleMember_Start", SampleMember_Start);
  newChild1.setInt("SampleMember_End", SampleMember_End);
  newChild1.setInt("SampleStation_Start", SampleStation_Start);
  newChild1.setInt("SampleStation_End", SampleStation_End);
  newChild1.setString("CLIMATE_TMYEPW_load", Boolean.toString(CLIMATE_TMYEPW_load));
  newChild1.setString("CLIMATE_CWEEDS_load", Boolean.toString(CLIMATE_CWEEDS_load));
  newChild1.setString("CLIMATE_CLMREC_load", Boolean.toString(CLIMATE_CLMREC_load));  
  newChild1.setString("ENSEMBLE_FORECAST_load", Boolean.toString(ENSEMBLE_FORECAST_load));
  newChild1.setString("ENSEMBLE_OBSERVED_load", Boolean.toString(ENSEMBLE_OBSERVED_load));
  newChild1.setInt("GRIB2_Month", GRIB2_Month);
  newChild1.setInt("GRIB2_Day", GRIB2_Day);
  newChild1.setInt("GRIB2_ModelRun", GRIB2_ModelRun);
  newChild1.setInt("AERIAL_num", AERIAL_num);
  newChild1.setFloat("AERIAL_Center_Longitude", AERIAL_Center_Longitude);
  newChild1.setFloat("AERIAL_Center_Latitude", AERIAL_Center_Latitude);
  newChild1.setInt("GRIB2_Hour_Start", GRIB2_Hour_Start);
  newChild1.setInt("GRIB2_Hour_End", GRIB2_Hour_End);
  newChild1.setInt("GRIB2_Hour_Step", GRIB2_Hour_Step);
  newChild1.setInt("GRIB2_Layer_Start", GRIB2_Layer_Start);
  newChild1.setInt("GRIB2_Layer_End", GRIB2_Layer_End);
  newChild1.setInt("GRIB2_Layer_Step", GRIB2_Layer_Step);
  newChild1.setInt("GRIB2_Hour", GRIB2_Hour);
  newChild1.setInt("GRIB2_Layer", GRIB2_Layer);
  newChild1.setInt("GRIB2_DomainSelection", GRIB2_DomainSelection);
  newChild1.setInt("GRIB2_TGL_number", GRIB2_TGL_number);
  newChild1.setInt("AERIAL_graphOption", AERIAL_graphOption);
  newChild1.setInt("Develop_Option", Develop_Option);
  newChild1.setInt("Develop_DayHour", Develop_DayHour);
  newChild1.setString("DevelopData_update", Boolean.toString(DevelopData_update));
  newChild1.setInt("numberOfLayers", numberOfLayers);
  newChild1.setInt("LAYER_windspd200hPa.id", LAYER_windspd200hPa.id);
  newChild1.setInt("LAYER_thicknesses_1000_500.id", LAYER_thicknesses_1000_500.id);
  newChild1.setInt("LAYER_heightp500hPa.id", LAYER_heightp500hPa.id);
  newChild1.setInt("LAYER_ceilingsky.id", LAYER_ceilingsky.id);
  newChild1.setInt("LAYER_cloudcover.id", LAYER_cloudcover.id);
  newChild1.setInt("LAYER_winddir.id", LAYER_winddir.id);
  newChild1.setInt("LAYER_windspd.id", LAYER_windspd.id);
  newChild1.setInt("LAYER_pressure.id", LAYER_pressure.id);
  newChild1.setInt("LAYER_drybulb.id", LAYER_drybulb.id);
  newChild1.setInt("LAYER_relhum.id", LAYER_relhum.id);
  newChild1.setInt("LAYER_dirnorrad.id", LAYER_dirnorrad.id);
  newChild1.setInt("LAYER_difhorrad.id", LAYER_difhorrad.id);
  newChild1.setInt("LAYER_glohorrad.id", LAYER_glohorrad.id);
  newChild1.setInt("LAYER_direffect.id", LAYER_direffect.id);
  newChild1.setInt("LAYER_difeffect.id", LAYER_difeffect.id);
  newChild1.setInt("LAYER_precipitation.id", LAYER_precipitation.id);
  newChild1.setInt("LAYER_developed.id", LAYER_developed.id);
  newChild1.setFloat("Develop_AngleInclination", Develop_AngleInclination);
  newChild1.setFloat("Develop_AngleOrientation", Develop_AngleOrientation);
  newChild1.setInt("CurrentLayer_id", CurrentLayer_id);
  newChild1.setInt("DevelopLayer_id", DevelopLayer_id);
  newChild1.setFloat("STUDY.T_scale", STUDY.T_scale);
  newChild1.setFloat("STUDY.U_scale", STUDY.U_scale);
  newChild1.setInt("STUDY.skyScenario", STUDY.skyScenario);
  newChild1.setInt("FILTER_Hourly", FILTER_Hourly);
  newChild1.setInt("FILTER_Daily", FILTER_Daily);
  newChild1.setInt("STUDY.filter", STUDY.filter);
  newChild1.setInt("STUDY.TrendJoinHours", STUDY.TrendJoinHours);
  newChild1.setInt("STUDY.TrendJoinType", STUDY.TrendJoinType);
  newChild1.setString("STUDY.Export_info_node", Boolean.toString(STUDY.Export_info_node));
  newChild1.setString("STUDY.Export_info_norm", Boolean.toString(STUDY.Export_info_norm));
  newChild1.setString("STUDY.Export_info_prob", Boolean.toString(STUDY.Export_info_prob));
  newChild1.setInt("STUDY.Pallet_SORT_CLR", STUDY.Pallet_SORT_CLR);
  newChild1.setInt("STUDY.Pallet_SORT_DIR", STUDY.Pallet_SORT_DIR);
  newChild1.setFloat("STUDY.Pallet_SORT_MLT", STUDY.Pallet_SORT_MLT);
  newChild1.setInt("STUDY.Pallet_PROB_CLR", STUDY.Pallet_PROB_CLR);
  newChild1.setInt("STUDY.Pallet_PROB_DIR", STUDY.Pallet_PROB_DIR);
  newChild1.setFloat("STUDY.Pallet_PROB_MLT", STUDY.Pallet_PROB_MLT);
  newChild1.setInt("STUDY.Pallet_ACTIVE_CLR", STUDY.Pallet_ACTIVE_CLR);
  newChild1.setInt("STUDY.Pallet_ACTIVE_DIR", STUDY.Pallet_ACTIVE_DIR);
  newChild1.setFloat("STUDY.Pallet_ACTIVE_MLT", STUDY.Pallet_ACTIVE_MLT);
  newChild1.setInt("STUDY.Pallet_PASSIVE_CLR", STUDY.Pallet_PASSIVE_CLR);
  newChild1.setInt("STUDY.Pallet_PASSIVE_DIR", STUDY.Pallet_PASSIVE_DIR);
  newChild1.setFloat("STUDY.Pallet_PASSIVE_MLT", STUDY.Pallet_PASSIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT);
  newChild1.setInt("SunPath_Pallet_ACTIVE_CLR", SunPath_Pallet_ACTIVE_CLR);
  newChild1.setInt("SunPath_Pallet_ACTIVE_DIR", SunPath_Pallet_ACTIVE_DIR);
  newChild1.setFloat("SunPath_Pallet_ACTIVE_MLT", SunPath_Pallet_ACTIVE_MLT);
  newChild1.setInt("SunPath_Pallet_PASSIVE_CLR", SunPath_Pallet_PASSIVE_CLR);
  newChild1.setInt("SunPath_Pallet_PASSIVE_DIR", SunPath_Pallet_PASSIVE_DIR);
  newChild1.setFloat("SunPath_Pallet_PASSIVE_MLT", SunPath_Pallet_PASSIVE_MLT);
  newChild1.setInt("Sky3D.Pallet_ACTIVE_CLR", Sky3D.Pallet_ACTIVE_CLR);
  newChild1.setInt("Sky3D.Pallet_ACTIVE_DIR", Sky3D.Pallet_ACTIVE_DIR);
  newChild1.setFloat("Sky3D.Pallet_ACTIVE_MLT", Sky3D.Pallet_ACTIVE_MLT);
  newChild1.setInt("Sky3D.Pallet_PASSIVE_CLR", Sky3D.Pallet_PASSIVE_CLR);
  newChild1.setInt("Sky3D.Pallet_PASSIVE_DIR", Sky3D.Pallet_PASSIVE_DIR);
  newChild1.setFloat("Sky3D.Pallet_PASSIVE_MLT", Sky3D.Pallet_PASSIVE_MLT);
  newChild1.setInt("ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR);
  newChild1.setInt("ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR);
  newChild1.setFloat("ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT);
  newChild1.setInt("SOLID_Pallet_CLR", SOLID_Pallet_CLR);
  newChild1.setInt("SOLID_Pallet_DIR", SOLID_Pallet_DIR);
  newChild1.setFloat("SOLID_Pallet_MLT", SOLID_Pallet_MLT);
  newChild1.setInt("WindFlow_Pallet_CLR", WindFlow_Pallet_CLR);
  newChild1.setInt("WindFlow_Pallet_DIR", WindFlow_Pallet_DIR);
  newChild1.setFloat("WindFlow_Pallet_MLT", WindFlow_Pallet_MLT);
  newChild1.setInt("Impact_TYPE", Impact_TYPE);
  newChild1.setFloat("STUDY.O_scale", STUDY.O_scale);
  newChild1.setFloat("STUDY.W_scale", STUDY.W_scale);
  newChild1.setInt("COLOR_STYLE_Current", COLOR_STYLE_Current);
  newChild1.setInt("COLOR_STYLE_Number", COLOR_STYLE_Number);
  newChild1.setFloat("STUDY.rect_scale", STUDY.rect_scale);
  newChild1.setFloat("STUDY.rect_offset_x", STUDY.rect_offset_x);
  newChild1.setInt("CurrentDataSource", CurrentDataSource);
  newChild1.setString("STUDY.impact_summary", Boolean.toString(STUDY.impact_summary));
  newChild1.setInt("STUDY.ImpactLayer", STUDY.ImpactLayer);
  newChild1.setInt("STUDY.PlotImpacts", STUDY.PlotImpacts);
  newChild1.setString("STUDY.Impacts_update", Boolean.toString(STUDY.Impacts_update));
  newChild1.setInt("DrawnFrame", DrawnFrame);

  newChild1.setInt("Land3D.Tessellation", Land3D.Tessellation);
  newChild1.setInt("allModel3Ds.Tessellation", allModel3Ds.Tessellation);
  newChild1.setInt("Sky3D.Tessellation", Sky3D.Tessellation);
  newChild1.setFloat("Sky3D.scale", Sky3D.scale);
  newChild1.setFloat("WindRose_scale", WindRose_scale);

  newChild1.setFloat("Planetary_Magnification", Planetary_Magnification);
  newChild1.setString("Display_SolarRotation", Boolean.toString(Display_SolarRotation));
  newChild1.setString("Display_SUN_Path", Boolean.toString(Display_SUN_Path));
  newChild1.setString("Display_SUN_Pattern", Boolean.toString(Display_SUN_Pattern));
  newChild1.setString("Sky3D.Display_Surface", Boolean.toString(Sky3D.Display_Surface));
  newChild1.setString("Star3D.Display_Surface", Boolean.toString(Star3D.Display_Surface));
  newChild1.setString("Star3D.Display_Texture", Boolean.toString(Star3D.Display_Texture));
  newChild1.setString("Moon3D.Display_Surface", Boolean.toString(Moon3D.Display_Surface));
  newChild1.setString("Moon3D.Display_Texture", Boolean.toString(Moon3D.Display_Texture));
  newChild1.setString("Tropo3D.Display_Surface", Boolean.toString(Tropo3D.Display_Surface));
  newChild1.setString("Tropo3D.Display_Texture", Boolean.toString(Tropo3D.Display_Texture));
  newChild1.setString("Earth3D.Display_Surface", Boolean.toString(Earth3D.Display_Surface));
  newChild1.setString("Earth3D.Display_Texture", Boolean.toString(Earth3D.Display_Texture));
  newChild1.setString("Land3D.Load_Textures", Boolean.toString(Land3D.Load_Textures));  
  newChild1.setString("Land3D.Load_Mesh", Boolean.toString(Land3D.Load_Mesh));
  newChild1.setString("Land3D.Display_Surface", Boolean.toString(Land3D.Display_Surface));
  newChild1.setString("Land3D.Display_Points", Boolean.toString(Land3D.Display_Points));
  newChild1.setString("Land3D.Display_Textures", Boolean.toString(Land3D.Display_Textures));
  newChild1.setString("Land3D.Display_Depth", Boolean.toString(Land3D.Display_Depth));
  newChild1.setInt("Land3D.Surface_SkipStart", Land3D.Surface_SkipStart);
  newChild1.setInt("Land3D.Surface_SkipEnd", Land3D.Surface_SkipEnd);
  newChild1.setString("Display_SolidImpact_Points", Boolean.toString(Display_SolidImpact_Points));
  newChild1.setString("Display_SolidImpact_Lines", Boolean.toString(Display_SolidImpact_Lines));
  newChild1.setString("allModel3Ds.DisplayVertices", Boolean.toString(allModel3Ds.DisplayVertices));       
  newChild1.setString("allModel3Ds.DisplayEdges", Boolean.toString(allModel3Ds.DisplayEdges));
  newChild1.setString("allModel3Ds.DisplayNormals", Boolean.toString(allModel3Ds.DisplayNormals));
  newChild1.setString("Display_WindFlow", Boolean.toString(Display_WindFlow));
  //newChild1.setInt("Camera_Variation", Camera_Variation);
  newChild1.setString("STUDY.DisplayRaws", Boolean.toString(STUDY.DisplayRaws));
  newChild1.setString("STUDY.DisplaySorted", Boolean.toString(STUDY.DisplaySorted));
  newChild1.setString("STUDY.DisplayNormals", Boolean.toString(STUDY.DisplayNormals));
  newChild1.setString("STUDY.DisplayProbs", Boolean.toString(STUDY.DisplayProbs));
  newChild1.setInt("STUDY.SumInterval", STUDY.SumInterval);
  newChild1.setFloat("STUDY.LevelPix", STUDY.LevelPix);
  newChild1.setFloat("STUDY.Pix", STUDY.Pix);
  newChild1.setInt("STUDY.plotSetup", STUDY.plotSetup);
  newChild1.setInt("Materials_Selection", Materials_Selection);
  newChild1.setFloat("WIN3D.CAM_x", WIN3D.CAM_x);
  newChild1.setFloat("WIN3D.CAM_y", WIN3D.CAM_y);
  newChild1.setFloat("WIN3D.CAM_z", WIN3D.CAM_z);
  newChild1.setFloat("WIN3D.CAM_fov", WIN3D.CAM_fov);
  newChild1.setFloat("WIN3D.CAM_dist", WIN3D.CAM_dist);
  newChild1.setFloat("WIN3D.CAM_clipNear", WIN3D.CAM_clipNear);
  newChild1.setFloat("WIN3D.CAM_clipFar", WIN3D.CAM_clipFar);
  newChild1.setInt("WIN3D.CurrentCamera", WIN3D.CurrentCamera);
  newChild1.setFloat("OBJECTS_scale", OBJECTS_scale);
  newChild1.setFloat("WIN3D.refScale", WIN3D.refScale);
  newChild1.setFloat("WIN3D.X_Coordinate", WIN3D.X_Coordinate);
  newChild1.setFloat("WIN3D.Y_Coordinate", WIN3D.Y_Coordinate);
  newChild1.setFloat("WIN3D.Z_Coordinate", WIN3D.Z_Coordinate);
  newChild1.setFloat("WIN3D.S_Coordinate", WIN3D.S_Coordinate);
  newChild1.setFloat("WIN3D.RX_Coordinate", WIN3D.RX_Coordinate);
  newChild1.setFloat("WIN3D.RY_Coordinate", WIN3D.RY_Coordinate);
  newChild1.setFloat("WIN3D.RZ_Coordinate", WIN3D.RZ_Coordinate);
  newChild1.setFloat("WIN3D.RS_Coordinate", WIN3D.RS_Coordinate);
  newChild1.setFloat("WIN3D.Zoom", WIN3D.Zoom);
  newChild1.setInt("WIN3D.ViewType", WIN3D.ViewType);
  newChild1.setInt("WIN3D.FacesShade", WIN3D.FacesShade);
  newChild1.setInt("selected_posVector", selected_posVector);
  newChild1.setInt("selected_rotVector", selected_rotVector);
  newChild1.setInt("selected_scaleVector", selected_scaleVector);
  newChild1.setFloat("selected_posValue", selected_posValue);
  newChild1.setFloat("selected_rotValue", selected_rotValue);
  newChild1.setFloat("selected_scaleValue", selected_scaleValue);
  newChild1.setInt("selection_alignX", selection_alignX);
  newChild1.setInt("selection_alignY", selection_alignY);
  newChild1.setInt("selection_alignZ", selection_alignZ);

  newChild1.setString("selectedFace_displayEdges", Boolean.toString(selectedFace_displayEdges));
  newChild1.setString("selectedFace_displayVertexCount", Boolean.toString(selectedFace_displayVertexCount));
  newChild1.setString("selectedCurve_displayVertexCount", Boolean.toString(selectedCurve_displayVertexCount));
  newChild1.setString("selectedVertex_displayVertices", Boolean.toString(selectedVertex_displayVertices));
  newChild1.setString("selectedCurve_displayVertices", Boolean.toString(selectedCurve_displayVertices));
  newChild1.setString("selectedGroup_displayPivot", Boolean.toString(selectedGroup_displayPivot));  
  newChild1.setString("selected_displayReferencePivot", Boolean.toString(selected_displayReferencePivot));
  newChild1.setString("selectedGroup_displayEdges", Boolean.toString(selectedGroup_displayEdges));
  newChild1.setString("selectedGroup_displayBox", Boolean.toString(selectedGroup_displayBox));
  newChild1.setString("selectedallModel2Ds_displayEdges", Boolean.toString(selectedallModel2Ds_displayEdges));
  newChild1.setString("selectedallModel1Ds_displayEdges", Boolean.toString(selectedallModel1Ds_displayEdges));
  newChild1.setString("selectedSolid_displayEdges", Boolean.toString(selectedSolid_displayEdges));
  newChild1.setString("selectedSection_displayEdges", Boolean.toString(selectedSection_displayEdges));
  newChild1.setString("selectedCamera_displayEdges", Boolean.toString(selectedCamera_displayEdges));
  newChild1.setString("selectedLandPoint_displayPoints", Boolean.toString(selectedLandPoint_displayPoints));

  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius);

  newChild1.setInt("WORLD.Viewport_ZOOM", WORLD.Viewport_ZOOM);
  newChild1.setInt("FrameVariation", FrameVariation);
  newChild1.setInt("Language_Active", Language_Active);

  newChild1.setInt("IMPACTS_DisplayDay", IMPACTS_DisplayDay);
  newChild1.setString("Display_WindRoseImage", Boolean.toString(Display_WindRoseImage));
  newChild1.setInt("WindRose_RES", WindRose_RES);
  newChild1.setInt("Rendered_WindRose_RES", Rendered_WindRose_RES);
  newChild1.setString("Display_SolarImpactImage", Boolean.toString(Display_SolarImpactImage));
  newChild1.setInt("SolarImpact_sectionType", SolarImpact_sectionType);
  newChild1.setFloat("SolarImpact_Rotation", SolarImpact_Rotation);
  newChild1.setFloat("SolarImpact_scale_U", SolarImpact_scale_U);
  newChild1.setFloat("SolarImpact_scale_V", SolarImpact_scale_V);
  newChild1.setFloat("SolarImpact_offset_U", SolarImpact_offset_U);
  newChild1.setFloat("SolarImpact_offset_V", SolarImpact_offset_V);  
  newChild1.setInt("SolarImpact_RES1", SolarImpact_RES1);
  newChild1.setInt("SolarImpact_RES2", SolarImpact_RES2);
  newChild1.setFloat("SolarImpact_Elevation", SolarImpact_Elevation);
  newChild1.setInt("SolidImpact_RES1", SolidImpact_RES1);
  newChild1.setInt("SolidImpact_RES2", SolidImpact_RES2);
  newChild1.setFloat("SolidImpact_Grade", SolidImpact_Grade);
  newChild1.setString("Display_SolidImpactImage", Boolean.toString(Display_SolidImpactImage));
  newChild1.setInt("SolidImpact_sectionType", SolidImpact_sectionType);
  newChild1.setFloat("SolidImpact_positionStep", SolidImpact_positionStep);
  newChild1.setInt("Process_subDivisions", Process_subDivisions);
  newChild1.setFloat("deltaSolidImpactStep", deltaSolidImpactStep);
  newChild1.setFloat("deltaSolidImpactLines", deltaSolidImpactLines);
  newChild1.setFloat("MinimumDistance_traceU", MinimumDistance_traceU);
  newChild1.setFloat("MinimumDistance_traceV", MinimumDistance_traceV);
  newChild1.setFloat("SOLARCHVISION_GLOBE_stp_slp", SOLARCHVISION_GLOBE_stp_slp);
  newChild1.setFloat("SOLARCHVISION_GLOBE_stp_dir", SOLARCHVISION_GLOBE_stp_dir);
  newChild1.setInt("SOLARCHVISION_GLOBE_n_slp", SOLARCHVISION_GLOBE_n_slp);
  newChild1.setInt("SOLARCHVISION_GLOBE_n_dir", SOLARCHVISION_GLOBE_n_dir);
  newChild1.setInt("Land3D.n_I", Land3D.n_I);
  newChild1.setInt("Land3D.n_J", Land3D.n_J);

  newChild1.setInt("allModel2Ds.PEOPLE_Files_Num", allModel2Ds.PEOPLE_Files_Num);
  newChild1.setInt("allModel2Ds.TREES_Files_Num", allModel2Ds.TREES_Files_Num); 

  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius); 

  newChild1.setInt("addToLastGroup", addToLastGroup);

  newChild1.setFloat("BIOSPHERE_drawResolution", BIOSPHERE_drawResolution);
  newChild1.setFloat("Export_Scale", Export_Scale);
  newChild1.setInt("Export_FlipZYaxis", Export_FlipZYaxis);
  newChild1.setInt("Export_PrecisionVertex", Export_PrecisionVertex);
  newChild1.setInt("Export_PrecisionVtexture", Export_PrecisionVtexture);
  newChild1.setInt("Export_PolyToPoly", Export_PolyToPoly);
  newChild1.setString("Export_MaterialLibrary", Boolean.toString(Export_MaterialLibrary));
  newChild1.setString("Export_BackSides", Boolean.toString(Export_BackSides));
  newChild1.setInt("Export_PalletResolution", Export_PalletResolution);

  newChild1.setString("Default_Font", Default_Font);

  newChild1.setInt("Land3D.n_I", Land3D.n_I);
  newChild1.setInt("Land3D.n_J", Land3D.n_J);

  newChild1.setInt("Land3D.Textures_num", Land3D.Textures_num);



  {
    int TEXTURE_copied = 0;

    String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder

    for (int q = 0; q < Land3D.Textures_num; q++) {

      int n_Map = q; 

      String the_filename = Land3D.Textures_ImagePath[n_Map].substring(Land3D.Textures_ImagePath[n_Map].lastIndexOf("/") + 1); // image name

      String new_Texture_path = the_dir + "/Textures/" +  the_filename;

      //println("pre_Land3D.Textures_ImagePath", Land3D.Textures_ImagePath[n_Map]);
      //println("new_Texture_path", new_Texture_path);

      if (Land3D.Textures_ImagePath[n_Map].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        TEXTURE_copied = -1;
      } else {

        println("Copying texture:", Land3D.Textures_ImagePath[n_Map], ">", new_Texture_path);
        saveBytes(new_Texture_path, loadBytes(Land3D.Textures_ImagePath[n_Map]));
        Land3D.Textures_ImagePath[n_Map] = new_Texture_path;

        TEXTURE_copied = 1;
      }

      //if (TEXTURE_copied == 0) {
      //  println("Saving texture from the scene.");
      //  Land3D.Textures_Map[n_Map].save(new_Texture_path);
      //}
    }
  }

  {
    newChild1 = my_xml.addChild("Land3D.Textures_ImagePath");
    int ni = Land3D.Textures_ImagePath.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i);
      newChild2.setFloat("scale_U", Land3D.Textures_scale_U[i]);
      newChild2.setFloat("scale_V", Land3D.Textures_scale_U[i]);
      newChild2.setContent(Land3D.Textures_ImagePath[i]);          
    }
  }


  {
    newChild1 = my_xml.addChild("allModel2Ds.ImagePath");
    int ni = allModel2Ds.ImagePath.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {

      int TEXTURE_copied = 0;

      String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder

      String the_filename = "";
      if (allModel2Ds.ImagePath[i].equals("")) {
      } else {
        the_filename = allModel2Ds.ImagePath[i].substring(allModel2Ds.ImagePath[i].lastIndexOf("/") + 1); // image name


        String new_Texture_path = the_dir + "/Textures/" + the_filename;

        //println("pre_allModel2Ds.ImagePath", allModel2Ds.ImagePath[i]);
        //println("new_allModel2Ds.ImagePath", new_allModel2Ds.ImagePath[i]);

        if (allModel2Ds.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
          TEXTURE_copied = -1;
        } else {
          if (allModel2Ds.ImagePath[i].equals("")) {
          } else {
            println("Copying texture:", allModel2Ds.ImagePath[i], ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(allModel2Ds.ImagePath[i]));
            allModel2Ds.ImagePath[i] = new_Texture_path;

            TEXTURE_copied = 1;
          }
        }

        //if (TEXTURE_copied == 0) {
        //  println("Saving texture from the scene.");
        //  allModel2Ds.Images[i].save(new_Texture_path);
        //}
      }

      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(allModel2Ds.ImagePath[i]);
    }
  }



  {
    newChild1 = my_xml.addChild("allSections.SolidImpact");
    int ni = allSections.SolidImpact.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {

      String the_filename = "SolidImpact_" + nf(i, 0) + ".bmp";

      String TEXTURE_path = ProjectFolder + "/Textures/" + the_filename;

      println("Saving texture:", TEXTURE_path);
      allSections.SolidImpact[i].save(TEXTURE_path);

      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(TEXTURE_path);
    }
  }

  {
    newChild1 = my_xml.addChild("allSections.SolarImpact");
    int ni = allSections.SolarImpact.length;
    if (ni > 0) {
      int nj = allSections.SolarImpact[0].length;
      if (nj > 0) {
        int nk = allSections.SolarImpact[0][0].length;
        newChild1.setInt("ni", ni);
        newChild1.setInt("nj", nj);
        newChild1.setInt("nk", nk);
    
        println("ni", ni);
        println("nj", nj);
        println("nk", nk);
    
        for (int i = 0; i < ni; i++) {
          for (int j = 0; j < nj; j++) {
            for (int k = 0; k < nk; k++) {
    
              String the_filename = "SolarImpact_" + nf((i * nj + j) * nk + k, 0) + ".bmp";
      
              String TEXTURE_path = ProjectFolder + "/Textures/" + the_filename;
      
              println("Saving texture:", TEXTURE_path);
              allSections.SolarImpact[i][j][k].save(TEXTURE_path);
      
              newChild2 = newChild1.addChild("Path");
              newChild2.setInt("id", (i * nj + j) * nk + k); 
              newChild2.setContent(TEXTURE_path);
            }
          }
        }
      }
    }
  }



  Land3D.to_XML(my_xml);

  allSections.to_XML(my_xml);
  
  allCameras.to_XML(my_xml);
  
  allSolids.to_XML(my_xml);

  allModel1Ds.to_XML(my_xml);
  
  allModel2Ds.to_XML(my_xml);
  
  





  println("Saving:Vertices");
  {
    XML parent = my_xml.addChild("allVertices");
    parent.setInt("ni", allVertices.length);
    for (int i = 0; i < allVertices.length; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allVertices[i].length; j++) {
      for (int j = 0; j < 3; j++) { // x, y, z 
        lineSTR += nf(allVertices[i][j], 0, 4).replace(",", "."); // <<<<
        if (j < allVertices[i].length - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  }



  allCurves.to_XML(my_xml);

  allFaces.to_XML(my_xml);



  println("Saving:allGroups");
  {
    {
      newChild1 = my_xml.addChild("allGroups.allModel2Ds");
      newChild1.setInt("ni", allGroups.num);
      for (int i = 0; i < allGroups.num; i++) {
        newChild2 = newChild1.addChild("allModel2Ds");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroups.allModel2Ds[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroups.allModel2Ds[i][j], 0);
          if (j < allGroups.allModel2Ds[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroups.allModel1Ds");
      newChild1.setInt("ni", allGroups.num);
      for (int i = 0; i < allGroups.num; i++) {
        newChild2 = newChild1.addChild("allModel1Ds");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroups.allModel1Ds[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroups.allModel1Ds[i][j], 0);
          if (j < allGroups.allModel1Ds[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroups.Faces");
      newChild1.setInt("ni", allGroups.num);
      for (int i = 0; i < allGroups.num; i++) {
        newChild2 = newChild1.addChild("Faces");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroups.Faces[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroups.Faces[i][j], 0);
          if (j < allGroups.Faces[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroups.Curves");
      newChild1.setInt("ni", allGroups.num);
      for (int i = 0; i < allGroups.num; i++) {
        newChild2 = newChild1.addChild("Curves");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroups.Curves[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroups.Curves[i][j], 0);
          if (j < allGroups.Curves[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {    
      newChild1 = my_xml.addChild("allGroups.allSolids");
      newChild1.setInt("ni", allGroups.num);
      for (int i = 0; i < allGroups.num; i++) {
        newChild2 = newChild1.addChild("allSolids");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroups.allSolids[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroups.allSolids[i][j], 0);
          if (j < allGroups.allSolids[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroups.PivotXYZ");
      int ni = allGroups.num;
      newChild1.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        newChild2 = newChild1.addChild("PivotXYZ");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allGroups.PivotXYZ[i].length; j++) {
          lineSTR += nf(allGroups.PivotXYZ[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < allGroups.PivotXYZ[i].length) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }  

    {
      newChild1 = my_xml.addChild("allGroups.PivotType");
      int ni = allGroups.num;
      newChild1.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        newChild2 = newChild1.addChild("PivotType");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allGroups.PivotType[i].length; j++) {
          lineSTR += nf(allGroups.PivotType[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < allGroups.PivotType[i].length) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }
  }

  {
    newChild1 = my_xml.addChild("selectedLandPoint_ids");
    int ni = selectedLandPoint_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedLandPoint_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("selectedallModel1Ds_ids");
    int ni = selectedallModel1Ds_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedallModel1Ds_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedallModel2Ds_ids");
    int ni = selectedallModel2Ds_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedallModel2Ds_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedGroup_ids");
    int ni = selectedGroup_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedGroup_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("selectedFace_ids");
    int ni = selectedFace_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedFace_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedCurve_ids");
    int ni = selectedCurve_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedCurve_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedVertex_ids");
    int ni = selectedVertex_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionVertices");
    int ni = selectedVertex_softSelectionVertices.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_softSelectionVertices[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionValues");
    int ni = selectedVertex_softSelectionValues.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(selectedVertex_softSelectionValues[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedSolid_ids");
    int ni = selectedSolid_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedSolid_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedSection_ids");
    int ni = selectedSection_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedSection_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedCamera_ids");
    int ni = selectedCamera_ids.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedCamera_ids[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    



  {
    newChild1 = my_xml.addChild("SolidImpact_Elevation");
    int ni = SolidImpact_Elevation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_Elevation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("SolidImpact_Rotation");
    int ni = SolidImpact_Rotation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_Rotation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("SolidImpact_scale_U");
    int ni = SolidImpact_scale_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_scale_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_scale_V");
    int ni = SolidImpact_scale_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_scale_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_offset_U");
    int ni = SolidImpact_offset_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_offset_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_offset_V");
    int ni = SolidImpact_offset_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_offset_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    


  saveXML(my_xml, myFile);    

  println("End of saving project.");

  if (explore_output) SOLARCHVISION_explore_output(myFile);
}


void SOLARCHVISION_load_project (String myFile) {

  myFile = myFile.replace(char(92), '/');


  int continue_process = 1;

  XML FileAll = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileAll = loadXML(myFile);
  }
  catch (Exception e) {
    println("Can't read:", myFile);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    XML[] children0;
   
    STATION.from_XML(FileAll);

    children0 = FileAll.getChildren("SOLARCHVISION_variables");
    for (int L = 0; L < children0.length; L++) {

      Display_Output_in_Explorer = Boolean.parseBoolean(children0[L].getString("Display_Output_in_Explorer"));
      Display_allModel3Ds = Boolean.parseBoolean(children0[L].getString("Display_allModel3Ds"));
      Display_allModel2Ds = Boolean.parseBoolean(children0[L].getString("Display_allModel2Ds"));
      Display_allModel1Ds = Boolean.parseBoolean(children0[L].getString("Display_allModel1Ds"));
      Display_Leaves = Boolean.parseBoolean(children0[L].getString("Display_Leaves"));

      Display_allSolids = Boolean.parseBoolean(children0[L].getString("Display_allSolids"));
      Display_allSections = Boolean.parseBoolean(children0[L].getString("Display_allSections"));
      Display_allCameras = Boolean.parseBoolean(children0[L].getString("Display_allCameras"));

      DEFAULT_CreateMaterial = children0[L].getInt("DEFAULT_CreateMaterial");
      DEFAULT_CreateTessellation = children0[L].getInt("DEFAULT_CreateTessellation");
      DEFAULT_CreateLayer = children0[L].getInt("DEFAULT_CreateLayer");
      DEFAULT_CreateVisibility = children0[L].getInt("DEFAULT_CreateVisibility");
      DEFAULT_CreateWeight = children0[L].getInt("DEFAULT_CreateWeight");
      DEFAULT_CreateClose = children0[L].getInt("DEFAULT_CreateClose");
      DEFAULT_CreatePivotType = children0[L].getInt("DEFAULT_CreatePivotType");

      ModifyInput_WeldTreshold = children0[L].getFloat("ModifyInput_WeldTreshold");

      ModifyInput_OffsetAmount = children0[L].getFloat("ModifyInput_OffsetAmount");

      ModifyInput_TessellateRows = children0[L].getInt("ModifyInput_TessellateRows");
      ModifyInput_TessellateColumns = children0[L].getInt("ModifyInput_TessellateColumns");

      ModifyInput_OpenningDepth = children0[L].getFloat("ModifyInput_OpenningDepth");
      ModifyInput_OpenningArea = children0[L].getFloat("ModifyInput_OpenningArea");
      ModifyInput_OpenningDeviation = children0[L].getFloat("ModifyInput_OpenningDeviation");
      CreateInput_Length = children0[L].getFloat("CreateInput_Length");
      CreateInput_Width = children0[L].getFloat("CreateInput_Width");
      CreateInput_Height = children0[L].getFloat("CreateInput_Height");
      CreateInput_Volume = children0[L].getFloat("CreateInput_Volume");
      CreateInput_Orientation = children0[L].getFloat("CreateInput_Orientation");
      CreateInput_powX = children0[L].getFloat("CreateInput_powX");
      CreateInput_powY = children0[L].getFloat("CreateInput_powY");
      CreateInput_powZ = children0[L].getFloat("CreateInput_powZ");
      CreateInput_powAll = children0[L].getFloat("CreateInput_powAll");
      CreateInput_powRnd = children0[L].getInt("CreateInput_powRnd");
      CreateInput_SphereDegree = children0[L].getInt("CreateInput_SphereDegree");
      CreateInput_CylinderDegree = children0[L].getInt("CreateInput_CylinderDegree");
      CreateInput_PolyDegree = children0[L].getInt("CreateInput_PolyDegree");
      CreateInput_Snap = children0[L].getInt("CreateInput_Snap");
      
      CreateParametric_Type = children0[L].getInt("CreateParametric_Type");
      CreatePerson_Type = children0[L].getInt("CreatePerson_Type");
      CreatePlant_Type = children0[L].getInt("CreatePlant_Type");
      CreateallModel1Ds_Type = children0[L].getInt("CreateallModel1Ds_Type");
      CreateallModel1Ds_DegreeMin = children0[L].getInt("CreateallModel1Ds_DegreeMin");
      CreateallModel1Ds_DegreeMax = children0[L].getInt("CreateallModel1Ds_DegreeMax");
      CreateallModel1Ds_Seed = children0[L].getInt("CreateallModel1Ds_Seed");
      CreateallModel1Ds_TrunkSize = children0[L].getFloat("CreateallModel1Ds_TrunkSize");
      CreateallModel1Ds_LeafSize = children0[L].getFloat("CreateallModel1Ds_LeafSize");
      Current_ObjectCategory = children0[L].getInt("Current_ObjectCategory");
      CreateInput_MeshOrSolid = children0[L].getInt("CreateInput_MeshOrSolid");
      WIN3D.UI_CurrentTask = children0[L].getInt("WIN3D.UI_CurrentTask");
      WIN3D.UI_OptionXorY = children0[L].getInt("WIN3D.UI_OptionXorY");
      WIN3D.UI_TaskModifyParameter = children0[L].getInt("WIN3D.UI_TaskModifyParameter");      

      Display_SWOB_Points = children0[L].getInt("Display_SWOB_Points");
      Display_NAEFS_Points = children0[L].getInt("Display_NAEFS_Points");
      Display_CWEEDS_Points = children0[L].getInt("Display_CWEEDS_Points");
      Display_CLMREC_Points = children0[L].getInt("Display_CLMREC_Points");
      Display_TMYEPW_Points = children0[L].getInt("Display_TMYEPW_Points");

      Display_SWOB_Nearest = Boolean.parseBoolean(children0[L].getString("Display_SWOB_Nearest"));
      Display_NAEFS_Nearest = Boolean.parseBoolean(children0[L].getString("Display_NAEFS_Nearest"));
      Display_CWEEDS_Nearest = Boolean.parseBoolean(children0[L].getString("Display_CWEEDS_Nearest"));
      Display_CLMREC_Nearest = Boolean.parseBoolean(children0[L].getString("Display_CLMREC_Nearest"));      
      Display_TMYEPW_Nearest = Boolean.parseBoolean(children0[L].getString("Display_TMYEPW_Nearest"));

      SolidImpact_WindSpeed = children0[L].getFloat("SolidImpact_WindSpeed"); 
      SolidImpact_WindDirection = children0[L].getFloat("SolidImpact_WindDirection");
      SolidImpact_Power = children0[L].getFloat("SolidImpact_Power");
      GlobalAlbedo = children0[L].getFloat("GlobalAlbedo");
      Interpolation_Weight = children0[L].getFloat("Interpolation_Weight");
      GLOBE_calculatedResolution = children0[L].getFloat("GLOBE_calculatedResolution");
      CLIMATIC_SolarForecast = children0[L].getInt("CLIMATIC_SolarForecast");
      CLIMATIC_WeatherForecast = children0[L].getInt("CLIMATIC_WeatherForecast");
      SOLARCHVISION_automated = children0[L].getInt("SOLARCHVISION_automated");

      TIME_ModelRun = children0[L].getInt("TIME_ModelRun"); 
      TIME_Year = children0[L].getInt("TIME_Year");
      TIME_Month = children0[L].getInt("TIME_Month");
      TIME_Day = children0[L].getInt("TIME_Day"); 
      TIME_Hour = children0[L].getInt("TIME_Hour"); 
      TIME_BeginDay = children0[L].getInt("TIME_BeginDay");
      TIME_Date = children0[L].getFloat("TIME_Date");

      STUDY.i_Start = children0[L].getInt("STUDY.i_Start");
      STUDY.i_End = children0[L].getInt("STUDY.i_End");
      //STUDY.j_Start = children0[L].getInt("STUDY.j_Start");
      STUDY.j_End = children0[L].getInt("STUDY.j_End");
      STUDY.PerDays = children0[L].getFloat("STUDY.PerDays");
      STUDY.JoinDays = children0[L].getInt("STUDY.JoinDays");
      CLIMATE_TMYEPW_start = children0[L].getInt("CLIMATE_TMYEPW_start");
      CLIMATE_TMYEPW_end = children0[L].getInt("CLIMATE_TMYEPW_end");
      CLIMATE_CWEEDS_start = children0[L].getInt("CLIMATE_CWEEDS_start");
      CLIMATE_CWEEDS_end = children0[L].getInt("CLIMATE_CWEEDS_end");
      CLIMATE_CLMREC_start = children0[L].getInt("CLIMATE_CLMREC_start");
      CLIMATE_CLMREC_end = children0[L].getInt("CLIMATE_CLMREC_end");
      ENSEMBLE_FORECAST_start = children0[L].getInt("ENSEMBLE_FORECAST_start");
      ENSEMBLE_FORECAST_end = children0[L].getInt("ENSEMBLE_FORECAST_end");
      ENSEMBLE_FORECAST_maxDays = children0[L].getInt("ENSEMBLE_FORECAST_maxDays");
      ENSEMBLE_OBSERVED_maxDays = children0[L].getInt("ENSEMBLE_OBSERVED_maxDays");      
      ENSEMBLE_OBSERVED_numNearest = children0[L].getInt("ENSEMBLE_OBSERVED_numNearest");
      ENSEMBLE_OBSERVED_start = children0[L].getInt("ENSEMBLE_OBSERVED_start");
      ENSEMBLE_OBSERVED_end = children0[L].getInt("ENSEMBLE_OBSERVED_end");
      SampleYear_Start = children0[L].getInt("SampleYear_Start");
      SampleYear_End = children0[L].getInt("SampleYear_End");
      SampleMember_Start = children0[L].getInt("SampleMember_Start");
      SampleMember_End = children0[L].getInt("SampleMember_End");
      SampleStation_Start = children0[L].getInt("SampleStation_Start");
      SampleStation_End = children0[L].getInt("SampleStation_End");
      CLIMATE_TMYEPW_load = Boolean.parseBoolean(children0[L].getString("CLIMATE_TMYEPW_load"));
      CLIMATE_CWEEDS_load = Boolean.parseBoolean(children0[L].getString("CLIMATE_CWEEDS_load"));
      CLIMATE_CLMREC_load = Boolean.parseBoolean(children0[L].getString("CLIMATE_CLMREC_load"));
      ENSEMBLE_FORECAST_load = Boolean.parseBoolean(children0[L].getString("ENSEMBLE_FORECAST_load"));
      ENSEMBLE_OBSERVED_load = Boolean.parseBoolean(children0[L].getString("ENSEMBLE_OBSERVED_load"));
      GRIB2_Month = children0[L].getInt("GRIB2_Month");
      GRIB2_Day = children0[L].getInt("GRIB2_Day");
      GRIB2_ModelRun = children0[L].getInt("GRIB2_ModelRun");
      AERIAL_num = children0[L].getInt("AERIAL_num");
      AERIAL_Center_Longitude = children0[L].getFloat("AERIAL_Center_Longitude");
      AERIAL_Center_Latitude = children0[L].getFloat("AERIAL_Center_Latitude");
      GRIB2_Hour_Start = children0[L].getInt("GRIB2_Hour_Start");
      GRIB2_Hour_End = children0[L].getInt("GRIB2_Hour_End");
      GRIB2_Hour_Step = children0[L].getInt("GRIB2_Hour_Step");
      GRIB2_Layer_Start = children0[L].getInt("GRIB2_Layer_Start");
      GRIB2_Layer_End = children0[L].getInt("GRIB2_Layer_End");
      GRIB2_Layer_Step = children0[L].getInt("GRIB2_Layer_Step");
      GRIB2_Hour = children0[L].getInt("GRIB2_Hour");
      GRIB2_Layer = children0[L].getInt("GRIB2_Layer");
      GRIB2_DomainSelection = children0[L].getInt("GRIB2_DomainSelection");
      GRIB2_TGL_number = children0[L].getInt("GRIB2_TGL_number");
      AERIAL_graphOption = children0[L].getInt("AERIAL_graphOption");
      Develop_Option = children0[L].getInt("Develop_Option");
      Develop_DayHour = children0[L].getInt("Develop_DayHour");
      //DevelopData_update = Boolean.parseBoolean(children0[L].getString("DevelopData_update"));
      numberOfLayers = children0[L].getInt("numberOfLayers");
      LAYER_windspd200hPa.id = children0[L].getInt("LAYER_windspd200hPa.id");
      LAYER_thicknesses_1000_500.id = children0[L].getInt("LAYER_thicknesses_1000_500.id");
      LAYER_heightp500hPa.id = children0[L].getInt("LAYER_heightp500hPa.id");
      LAYER_ceilingsky.id = children0[L].getInt("LAYER_ceilingsky.id");
      LAYER_cloudcover.id = children0[L].getInt("LAYER_cloudcover.id");
      LAYER_winddir.id = children0[L].getInt("LAYER_winddir.id");
      LAYER_windspd.id = children0[L].getInt("LAYER_windspd.id");
      LAYER_pressure.id = children0[L].getInt("LAYER_pressure.id");
      LAYER_drybulb.id = children0[L].getInt("LAYER_drybulb.id");
      LAYER_relhum.id = children0[L].getInt("LAYER_relhum.id");
      LAYER_dirnorrad.id = children0[L].getInt("LAYER_dirnorrad.id");
      LAYER_difhorrad.id = children0[L].getInt("LAYER_difhorrad.id");
      LAYER_glohorrad.id = children0[L].getInt("LAYER_glohorrad.id");
      LAYER_direffect.id = children0[L].getInt("LAYER_direffect.id");
      LAYER_difeffect.id = children0[L].getInt("LAYER_difeffect.id");
      LAYER_precipitation.id = children0[L].getInt("LAYER_precipitation.id");
      LAYER_developed.id = children0[L].getInt("LAYER_developed.id");
      Develop_AngleInclination = children0[L].getFloat("Develop_AngleInclination");
      Develop_AngleOrientation = children0[L].getFloat("Develop_AngleOrientation");
      
      changeCurrentLayerTo(children0[L].getInt("CurrentLayer_id"));
      
      DevelopLayer_id = children0[L].getInt("DevelopLayer_id");
      STUDY.T_scale = children0[L].getFloat("STUDY.T_scale");
      STUDY.U_scale = children0[L].getFloat("STUDY.U_scale");
      STUDY.skyScenario = children0[L].getInt("STUDY.skyScenario");
      FILTER_Hourly = children0[L].getInt("FILTER_Hourly");
      FILTER_Daily = children0[L].getInt("FILTER_Daily");
      STUDY.filter = children0[L].getInt("STUDY.filter");
      STUDY.TrendJoinHours = children0[L].getInt("STUDY.TrendJoinHours");
      STUDY.TrendJoinType = children0[L].getInt("STUDY.TrendJoinType");
      STUDY.Export_info_node = Boolean.parseBoolean(children0[L].getString("STUDY.Export_info_node"));
      STUDY.Export_info_norm = Boolean.parseBoolean(children0[L].getString("STUDY.Export_info_norm"));
      STUDY.Export_info_prob = Boolean.parseBoolean(children0[L].getString("STUDY.Export_info_prob"));
      STUDY.Pallet_SORT_CLR = children0[L].getInt("STUDY.Pallet_SORT_CLR");
      STUDY.Pallet_SORT_DIR = children0[L].getInt("STUDY.Pallet_SORT_DIR");
      STUDY.Pallet_SORT_MLT = children0[L].getFloat("STUDY.Pallet_SORT_MLT");
      STUDY.Pallet_PROB_CLR = children0[L].getInt("STUDY.Pallet_PROB_CLR");
      STUDY.Pallet_PROB_DIR = children0[L].getInt("STUDY.Pallet_PROB_DIR");
      STUDY.Pallet_PROB_MLT = children0[L].getFloat("STUDY.Pallet_PROB_MLT");
      STUDY.Pallet_ACTIVE_CLR = children0[L].getInt("STUDY.Pallet_ACTIVE_CLR");
      STUDY.Pallet_ACTIVE_DIR = children0[L].getInt("STUDY.Pallet_ACTIVE_DIR");
      STUDY.Pallet_ACTIVE_MLT = children0[L].getFloat("STUDY.Pallet_ACTIVE_MLT");
      STUDY.Pallet_PASSIVE_CLR = children0[L].getInt("STUDY.Pallet_PASSIVE_CLR");
      STUDY.Pallet_PASSIVE_DIR = children0[L].getInt("STUDY.Pallet_PASSIVE_DIR");
      STUDY.Pallet_PASSIVE_MLT = children0[L].getFloat("STUDY.Pallet_PASSIVE_MLT");
      OBJECTS_Pallet_ACTIVE_CLR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_CLR");
      OBJECTS_Pallet_ACTIVE_DIR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_DIR");
      OBJECTS_Pallet_ACTIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_ACTIVE_MLT");
      OBJECTS_Pallet_PASSIVE_CLR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_CLR");
      OBJECTS_Pallet_PASSIVE_DIR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_DIR");
      OBJECTS_Pallet_PASSIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_PASSIVE_MLT");
      SunPath_Pallet_ACTIVE_CLR = children0[L].getInt("SunPath_Pallet_ACTIVE_CLR");
      SunPath_Pallet_ACTIVE_DIR = children0[L].getInt("SunPath_Pallet_ACTIVE_DIR");
      SunPath_Pallet_ACTIVE_MLT = children0[L].getFloat("SunPath_Pallet_ACTIVE_MLT");
      SunPath_Pallet_PASSIVE_CLR = children0[L].getInt("SunPath_Pallet_PASSIVE_CLR");
      SunPath_Pallet_PASSIVE_DIR = children0[L].getInt("SunPath_Pallet_PASSIVE_DIR");
      SunPath_Pallet_PASSIVE_MLT = children0[L].getFloat("SunPath_Pallet_PASSIVE_MLT");
      Sky3D.Pallet_ACTIVE_CLR = children0[L].getInt("Sky3D.Pallet_ACTIVE_CLR");
      Sky3D.Pallet_ACTIVE_DIR = children0[L].getInt("Sky3D.Pallet_ACTIVE_DIR");
      Sky3D.Pallet_ACTIVE_MLT = children0[L].getFloat("Sky3D.Pallet_ACTIVE_MLT");
      Sky3D.Pallet_PASSIVE_CLR = children0[L].getInt("Sky3D.Pallet_PASSIVE_CLR");
      Sky3D.Pallet_PASSIVE_DIR = children0[L].getInt("Sky3D.Pallet_PASSIVE_DIR");
      Sky3D.Pallet_PASSIVE_MLT = children0[L].getFloat("Sky3D.Pallet_PASSIVE_MLT");
      ELEVATION_Pallet_CLR = children0[L].getInt("ELEVATION_Pallet_CLR");
      ELEVATION_Pallet_DIR = children0[L].getInt("ELEVATION_Pallet_DIR");
      ELEVATION_Pallet_MLT = children0[L].getFloat("ELEVATION_Pallet_MLT");
      SOLID_Pallet_CLR = children0[L].getInt("SOLID_Pallet_CLR");
      SOLID_Pallet_DIR = children0[L].getInt("SOLID_Pallet_DIR");
      SOLID_Pallet_MLT = children0[L].getFloat("SOLID_Pallet_MLT");
      WindFlow_Pallet_CLR = children0[L].getInt("WindFlow_Pallet_CLR");
      WindFlow_Pallet_DIR = children0[L].getInt("WindFlow_Pallet_DIR");
      WindFlow_Pallet_MLT = children0[L].getFloat("WindFlow_Pallet_MLT");
      Impact_TYPE = children0[L].getInt("Impact_TYPE");
      STUDY.O_scale = children0[L].getFloat("STUDY.O_scale");
      STUDY.W_scale = children0[L].getFloat("STUDY.W_scale");
      COLOR_STYLE_Current = children0[L].getInt("COLOR_STYLE_Current");
      COLOR_STYLE_Number = children0[L].getInt("COLOR_STYLE_Number");
      STUDY.rect_scale = children0[L].getFloat("STUDY.rect_scale");
      STUDY.rect_offset_x = children0[L].getFloat("STUDY.rect_offset_x");
      CurrentDataSource = children0[L].getInt("CurrentDataSource");
      STUDY.impact_summary = Boolean.parseBoolean(children0[L].getString("STUDY.impact_summary"));
      STUDY.ImpactLayer = children0[L].getInt("STUDY.ImpactLayer");
      STUDY.PlotImpacts = children0[L].getInt("STUDY.PlotImpacts");
      STUDY.Impacts_update = Boolean.parseBoolean(children0[L].getString("STUDY.Impacts_update"));
      DrawnFrame = children0[L].getInt("DrawnFrame");

      Land3D.Tessellation = children0[L].getInt("Land3D.Tessellation");
      allModel3Ds.Tessellation = children0[L].getInt("allModel3Ds.Tessellation");
      Sky3D.Tessellation = children0[L].getInt("Sky3D.Tessellation");
      Sky3D.scale = children0[L].getFloat("Sky3D.scale");
      WindRose_scale = children0[L].getFloat("WindRose_scale");

      Planetary_Magnification = children0[L].getFloat("Planetary_Magnification");
      Display_SolarRotation = Boolean.parseBoolean(children0[L].getString("Display_SolarRotation"));      
      Display_SUN_Path = Boolean.parseBoolean(children0[L].getString("Display_SUN_Path"));
      Display_SUN_Pattern = Boolean.parseBoolean(children0[L].getString("Display_SUN_Pattern"));
      Sky3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Sky3D.Display_Surface"));
      Star3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Star3D.Display_Surface"));
      Star3D.Display_Texture = Boolean.parseBoolean(children0[L].getString("Star3D.Display_Texture"));            
      Moon3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Moon3D.Display_Surface"));
      Moon3D.Display_Texture = Boolean.parseBoolean(children0[L].getString("Moon3D.Display_Texture"));
      Tropo3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Tropo3D.Display_Surface"));
      Tropo3D.Display_Texture = Boolean.parseBoolean(children0[L].getString("Tropo3D.Display_Texture"));
      Earth3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Earth3D.Display_Surface"));
      Earth3D.Display_Texture = Boolean.parseBoolean(children0[L].getString("Earth3D.Display_Texture"));
      Land3D.Load_Textures = Boolean.parseBoolean(children0[L].getString("Land3D.Load_Textures"));      
      Land3D.Load_Mesh = Boolean.parseBoolean(children0[L].getString("Land3D.Load_Mesh"));
      Land3D.Display_Surface = Boolean.parseBoolean(children0[L].getString("Land3D.Display_Surface"));
      Land3D.Display_Points = Boolean.parseBoolean(children0[L].getString("Land3D.Display_Points"));
      Land3D.Display_Textures = Boolean.parseBoolean(children0[L].getString("Land3D.Display_Textures"));
      Land3D.Display_Depth = Boolean.parseBoolean(children0[L].getString("Land3D.Display_Depth"));
      Land3D.Surface_SkipStart = children0[L].getInt("Land3D.Surface_SkipStart");
      Land3D.Surface_SkipEnd = children0[L].getInt("Land3D.Surface_SkipEnd");
      Display_SolidImpact_Points = Boolean.parseBoolean(children0[L].getString("Display_SolidImpact_Points"));
      Display_SolidImpact_Lines = Boolean.parseBoolean(children0[L].getString("Display_SolidImpact_Lines"));
      allModel3Ds.DisplayVertices = Boolean.parseBoolean(children0[L].getString("allModel3Ds.DisplayVertices"));  
      allModel3Ds.DisplayEdges = Boolean.parseBoolean(children0[L].getString("allModel3Ds.DisplayEdges"));
      allModel3Ds.DisplayNormals = Boolean.parseBoolean(children0[L].getString("allModel3Ds.DisplayNormals"));
      Display_WindFlow = Boolean.parseBoolean(children0[L].getString("Display_WindFlow"));
      Camera_Variation = children0[L].getInt("Camera_Variation");
      STUDY.DisplayRaws = Boolean.parseBoolean(children0[L].getString("STUDY.DisplayRaws"));
      STUDY.DisplaySorted = Boolean.parseBoolean(children0[L].getString("STUDY.DisplaySorted"));
      STUDY.DisplayNormals = Boolean.parseBoolean(children0[L].getString("STUDY.DisplayNormals"));
      STUDY.DisplayProbs = Boolean.parseBoolean(children0[L].getString("STUDY.DisplayProbs"));
      STUDY.SumInterval = children0[L].getInt("STUDY.SumInterval");
      STUDY.LevelPix = children0[L].getFloat("STUDY.LevelPix");
      STUDY.Pix = children0[L].getFloat("STUDY.Pix");
      STUDY.plotSetup = children0[L].getInt("STUDY.plotSetup");
      Materials_Selection = children0[L].getInt("Materials_Selection");
      WIN3D.CAM_x = children0[L].getFloat("WIN3D.CAM_x");
      WIN3D.CAM_y = children0[L].getFloat("WIN3D.CAM_y");
      WIN3D.CAM_z = children0[L].getFloat("WIN3D.CAM_z");
      WIN3D.CAM_fov = children0[L].getFloat("WIN3D.CAM_fov");
      WIN3D.CAM_dist = children0[L].getFloat("WIN3D.CAM_dist");
      WIN3D.CAM_clipNear = children0[L].getFloat("WIN3D.CAM_clipNear");
      WIN3D.CAM_clipFar = children0[L].getFloat("WIN3D.CAM_clipFar");
      WIN3D.CurrentCamera = children0[L].getInt("WIN3D.CurrentCamera");
      OBJECTS_scale = children0[L].getFloat("OBJECTS_scale");
      WIN3D.refScale = children0[L].getFloat("WIN3D.refScale");
      WIN3D.X_Coordinate = children0[L].getFloat("WIN3D.X_Coordinate");
      WIN3D.Y_Coordinate = children0[L].getFloat("WIN3D.Y_Coordinate");
      WIN3D.Z_Coordinate = children0[L].getFloat("WIN3D.Z_Coordinate");
      WIN3D.S_Coordinate = children0[L].getFloat("WIN3D.S_Coordinate");
      WIN3D.RX_Coordinate = children0[L].getFloat("WIN3D.RX_Coordinate");
      WIN3D.RY_Coordinate = children0[L].getFloat("WIN3D.RY_Coordinate");
      WIN3D.RZ_Coordinate = children0[L].getFloat("WIN3D.RZ_Coordinate");
      WIN3D.RS_Coordinate = children0[L].getFloat("WIN3D.RS_Coordinate");
      WIN3D.Zoom = children0[L].getFloat("WIN3D.Zoom");
      WIN3D.ViewType = children0[L].getInt("WIN3D.ViewType");
      WIN3D.FacesShade = children0[L].getInt("WIN3D.FacesShade");

      selected_posVector = children0[L].getInt("selected_posVector");
      selected_rotVector = children0[L].getInt("selected_rotVector");
      selected_scaleVector = children0[L].getInt("selected_scaleVector");
      selected_posValue = children0[L].getFloat("selected_posValue");
      selected_rotValue = children0[L].getFloat("selected_rotValue");
      selected_scaleValue = children0[L].getFloat("selected_scaleValue");
      selection_alignX = children0[L].getInt("selection_alignX");
      selection_alignY = children0[L].getInt("selection_alignY");
      selection_alignZ = children0[L].getInt("selection_alignZ");

      selected_displayReferencePivot = Boolean.parseBoolean(children0[L].getString("selected_displayReferencePivot"));
      selectedGroup_displayPivot = Boolean.parseBoolean(children0[L].getString("selectedGroup_displayPivot"));
      selectedGroup_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedGroup_displayEdges"));
      selectedGroup_displayBox = Boolean.parseBoolean(children0[L].getString("selectedGroup_displayBox"));
      selectedFace_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedFace_displayEdges"));
      selectedFace_displayVertexCount = Boolean.parseBoolean(children0[L].getString("selectedFace_displayVertexCount"));
      selectedCurve_displayVertexCount = Boolean.parseBoolean(children0[L].getString("selectedCurve_displayVertexCount"));
      selectedVertex_displayVertices = Boolean.parseBoolean(children0[L].getString("selectedVertex_displayVertices"));      
      selectedCurve_displayVertices = Boolean.parseBoolean(children0[L].getString("selectedCurve_displayVertices"));
      selectedallModel2Ds_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedallModel2Ds_displayEdges"));
      selectedallModel1Ds_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedallModel1Ds_displayEdges"));
      selectedSolid_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedSolid_displayEdges"));
      selectedSection_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedSection_displayEdges"));
      selectedCamera_displayEdges = Boolean.parseBoolean(children0[L].getString("selectedCamera_displayEdges"));
      selectedLandPoint_displayPoints = Boolean.parseBoolean(children0[L].getString("selectedLandPoint_displayPoints"));

      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");

      WORLD.Viewport_ZOOM = children0[L].getInt("WORLD.Viewport_ZOOM");
      FrameVariation = children0[L].getInt("FrameVariation");
      Language_Active = children0[L].getInt("Language_Active");

      IMPACTS_DisplayDay = children0[L].getInt("IMPACTS_DisplayDay");
      Display_WindRoseImage = Boolean.parseBoolean(children0[L].getString("Display_WindRoseImage"));
      WindRose_RES = children0[L].getInt("WindRose_RES");
      Rendered_WindRose_RES = children0[L].getInt("Rendered_WindRose_RES");
      Display_SolarImpactImage = Boolean.parseBoolean(children0[L].getString("Display_SolarImpactImage"));
      SolarImpact_sectionType = children0[L].getInt("SolarImpact_sectionType");
      SolarImpact_Rotation = children0[L].getFloat("SolarImpact_Rotation");
      SolarImpact_scale_U = children0[L].getFloat("SolarImpact_scale_U");
      SolarImpact_scale_V = children0[L].getFloat("SolarImpact_scale_V");
      SolarImpact_offset_U = children0[L].getFloat("SolarImpact_offset_U");
      SolarImpact_offset_V = children0[L].getFloat("SolarImpact_offset_V");      
      SolarImpact_RES1 = children0[L].getInt("SolarImpact_RES1");
      SolarImpact_RES2 = children0[L].getInt("SolarImpact_RES2");
      SolarImpact_Elevation = children0[L].getFloat("SolarImpact_Elevation");
      SolidImpact_RES1 = children0[L].getInt("SolidImpact_RES1");
      SolidImpact_RES2 = children0[L].getInt("SolidImpact_RES2");
      SolidImpact_Grade = children0[L].getFloat("SolidImpact_Grade");
      Display_SolidImpactImage = Boolean.parseBoolean(children0[L].getString("Display_SolidImpactImage"));
      SolidImpact_sectionType = children0[L].getInt("SolidImpact_sectionType");
      SolidImpact_positionStep = children0[L].getFloat("SolidImpact_positionStep");
      Process_subDivisions = children0[L].getInt("Process_subDivisions");
      deltaSolidImpactStep = children0[L].getFloat("deltaSolidImpactStep");
      deltaSolidImpactLines = children0[L].getFloat("deltaSolidImpactLines");
      MinimumDistance_traceU = children0[L].getFloat("MinimumDistance_traceU");
      MinimumDistance_traceV = children0[L].getFloat("MinimumDistance_traceV");
      SOLARCHVISION_GLOBE_stp_slp = children0[L].getFloat("SOLARCHVISION_GLOBE_stp_slp");
      SOLARCHVISION_GLOBE_stp_dir = children0[L].getFloat("SOLARCHVISION_GLOBE_stp_dir");
      SOLARCHVISION_GLOBE_n_slp = children0[L].getInt("SOLARCHVISION_GLOBE_n_slp");
      SOLARCHVISION_GLOBE_n_dir = children0[L].getInt("SOLARCHVISION_GLOBE_n_dir");
      Land3D.n_I = children0[L].getInt("Land3D.n_I");
      Land3D.n_J = children0[L].getInt("Land3D.n_J");
      allModel2Ds.PEOPLE_Files_Num = children0[L].getInt("allModel2Ds.PEOPLE_Files_Num");
      allModel2Ds.TREES_Files_Num = children0[L].getInt("allModel2Ds.TREES_Files_Num");
      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");

      addToLastGroup = children0[L].getInt("addToLastGroup");      

      BIOSPHERE_drawResolution = children0[L].getFloat("BIOSPHERE_drawResolution");

      Export_Scale = children0[L].getFloat("Export_Scale");
      Export_FlipZYaxis = children0[L].getInt("Export_FlipZYaxis");
      Export_PrecisionVertex = children0[L].getInt("Export_PrecisionVertex");
      Export_PrecisionVtexture = children0[L].getInt("Export_PrecisionVtexture");
      Export_PolyToPoly = children0[L].getInt("Export_PolyToPoly");
      Export_MaterialLibrary  = Boolean.parseBoolean(children0[L].getString("Export_MaterialLibrary"));
      Export_BackSides = Boolean.parseBoolean(children0[L].getString("Export_BackSides"));
     
      Export_PalletResolution = children0[L].getInt("Export_PalletResolution");


      {
        String new_Default_Font = children0[L].getString("Default_Font");
        if (Default_Font.equals(new_Default_Font)) {
        } else {
          Default_Font = new_Default_Font;        
          SOLARCHVISION_loadDefaultFontStyle();
        }
      } 

      Land3D.n_I = children0[L].getInt("Land3D.n_I");
      Land3D.n_J = children0[L].getInt("Land3D.n_J");


      int pre_Land3D_Textures_num = Land3D.Textures_num;
      Land3D.Textures_num = children0[L].getInt("Land3D.Textures_num");

      if (pre_Land3D_Textures_num != Land3D.Textures_num) {

        int ni = Land3D.Textures_num;

        Land3D.Textures_ImagePath = new String [ni];
        Land3D.Textures_Map = new PImage [ni];

        for (int i = 0; i < ni; i++) {

          Land3D.Textures_ImagePath[i] = "";
          Land3D.Textures_Map[i] = createImage(2, 2, RGB); // empty and small
        }
      }
    }


  
    {
      XML parent = FileAll.getChild("Land3D.Textures_ImagePath");
    
      int ni = parent.getInt("ni");
      
      XML[] children1 = parent.getChildren("Path");       
      for (int i = 0; i < ni; i++) {
        
        Land3D.Textures_scale_U[i] = children1[i].getFloat("scale_U");
        Land3D.Textures_scale_V[i] = children1[i].getFloat("scale_V");

        String new_Texture_path = children1[i].getContent();

        if (Land3D.Textures_ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        } else {

          Land3D.Textures_ImagePath[i] = new_Texture_path;

          if (Land3D.Textures_ImagePath[i].equals("")) {
          } else {
            println("Loading texture:", Land3D.Textures_ImagePath[i]);
            Land3D.Textures_Map[i] = loadImage(Land3D.Textures_ImagePath[i]);
          }
        }
      }
    }


    {
      {
        XML parent = FileAll.getChild("allModel2Ds.ImagePath");
      
        int ni = parent.getInt("ni");

        int reload_All_textures = 0;

        if (allModel2Ds.ImagePath.length != ni) {
          allModel2Ds.Images = new PImage [ni];
          allModel2Ds.ImageRatios = new float [ni];

          reload_All_textures = 1;
        }

        XML[] children1 = parent.getChildren("Path");         
        for (int i = 0; i < ni; i++) {      

          String new_Texture_path = children1[i].getContent();
          if ((reload_All_textures == 0) && (allModel2Ds.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase()))) {
          } else {
            allModel2Ds.ImagePath[i] = new_Texture_path;
            allModel2Ds.Images[i] = createImage(2, 2, RGB); // empty and small
            if (allModel2Ds.ImagePath[i].equals("")) {
            } else {
              println("Loading texture(" + i + "):", allModel2Ds.ImagePath[i]);
              allModel2Ds.Images[i] = loadImage(allModel2Ds.ImagePath[i]);
              println("loaded!");

              if (allModel2Ds.Images[i].height != 0) {
                allModel2Ds.ImageRatios[i] = float(allModel2Ds.Images[i].width) / float(allModel2Ds.Images[i].height);
              } else {
                allModel2Ds.ImageRatios[i] = 1;
              }
            }
          }
        }
      }
    }


    {
      {
        XML parent = FileAll.getChild("allSections.SolidImpact");
      
        int ni = parent.getInt("ni");

        allSections.SolidImpact = new PImage [ni];

        XML[] children1 = parent.getChildren("Path");         
        for (int i = 0; i < ni; i++) {      

          String TEXTURE_path = children1[i].getContent();

          allSections.SolidImpact[i] = createImage(2, 2, RGB); // empty and small

          println("Loading texture(" + i + "):", TEXTURE_path);
          allSections.SolidImpact[i] = loadImage(TEXTURE_path);
          println("loaded!");
        }
      }
    }

    {
      {
        XML parent = FileAll.getChild("allSections.SolarImpact");
      
        int ni = parent.getInt("ni");
        int nj = parent.getInt("nj");
        int nk = parent.getInt("nk");

        allSections.SolarImpact = new PImage [ni][nj][nk]; 

        XML[] children1 = parent.getChildren("Path");         
        for (int i = 0; i < ni; i++) {      
          for (int j = 0; j < nj; j++) {
            for (int k = 0; k < nk; k++) {

              String TEXTURE_path = children1[(i * nj + j) * nk + k].getContent();
  
              allSections.SolarImpact[i][j][k] = createImage(2, 2, RGB); // empty and small
  
              println("Loading texture(" + i + "," + j + "," + k + "):", TEXTURE_path);
              allSections.SolarImpact[i][j][k] = loadImage(TEXTURE_path);
              println("loaded!");
            }
          }
        }
      }
    }




    Land3D.from_XML(FileAll);

    allSections.from_XML(FileAll);
    
    allCameras.from_XML(FileAll);
    
    allSolids.from_XML(FileAll);
    
    allModel1Ds.from_XML(FileAll);
    
    allModel2Ds.from_XML(FileAll);
    







    {  
      println("Loading:Vertices");
      XML parent = FileAll.getChild("allVertices");
      int ni = parent.getInt("ni");
      allVertices = new float [ni][3];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allVertices[i][j] = float(parts[j]);
        }
      }
    }

    
    allCurves.from_XML(FileAll);

    allFaces.from_XML(FileAll);
    
    



    println("Loading:allGroups");
    {
      {
        XML parent = FileAll.getChild("allGroups.PivotXYZ");
      

        int ni = parent.getInt("ni");

        allGroups.num = ni;

        allGroups.PivotXYZ = new float [ni][9];

        XML[] children1 = parent.getChildren("PivotXYZ");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < 9; j++) {
            allGroups.PivotXYZ[i][j] = float(parts[j]);
          }
        }
      }  


      {
        XML parent = FileAll.getChild("allGroups.PivotType");
      
        int ni = parent.getInt("ni");

        allGroups.PivotType = new int [ni][1];

        XML[] children1 = parent.getChildren("PivotType");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < 1; j++) {
            allGroups.PivotType[i][j] = int(parts[j]);
          }
        }
      }          

      {
        XML parent = FileAll.getChild("allGroups.Faces");
      
        int ni = parent.getInt("ni");
        allGroups.Faces = new int [ni][2];
        XML[] children1 = parent.getChildren("Faces");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroups.Faces[i][j] = int(parts[j]);
          }
        }
      }
 
      {
        XML parent = FileAll.getChild("allGroups.Curves");
      
        int ni = parent.getInt("ni");
        allGroups.Curves = new int [ni][2];
        XML[] children1 = parent.getChildren("Curves");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroups.Curves[i][j] = int(parts[j]);
          }
        }
      }        

      {
        XML parent = FileAll.getChild("allGroups.allSolids");
      
        int ni = parent.getInt("ni");
        allGroups.allSolids = new int [ni][2];
        XML[] children1 = parent.getChildren("allSolids");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroups.allSolids[i][j] = int(parts[j]);
          }
        }
      } 

      {
        XML parent = FileAll.getChild("allGroups.allModel2Ds");
      
        int ni = parent.getInt("ni");
        allGroups.allModel2Ds = new int [ni][2];
        XML[] children1 = parent.getChildren("allModel2Ds");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroups.allModel2Ds[i][j] = int(parts[j]);
          }
        }
      } 

      {
        XML parent = FileAll.getChild("allGroups.allModel1Ds");
      
        int ni = parent.getInt("ni");
        allGroups.allModel1Ds = new int [ni][2];
        XML[] children1 = parent.getChildren("allModel1Ds");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroups.allModel1Ds[i][j] = int(parts[j]);
          }
        }
      }
    }


    {
      XML parent = FileAll.getChild("selectedLandPoint_ids");
    
      int ni = parent.getInt("ni");
      selectedLandPoint_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedLandPoint_ids[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedallModel1Ds_ids");
    
      int ni = parent.getInt("ni");
      selectedallModel1Ds_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedallModel1Ds_ids[i] = int(parts[i]);
      }
    } 

    {
      XML parent = FileAll.getChild("selectedallModel2Ds_ids");
    
      int ni = parent.getInt("ni");
      selectedallModel2Ds_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedallModel2Ds_ids[i] = int(parts[i]);
      }
    } 

    {
      XML parent = FileAll.getChild("selectedGroup_ids");
    
      int ni = parent.getInt("ni");
      selectedGroup_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedGroup_ids[i] = int(parts[i]);
      }
    } 

    {
      XML parent = FileAll.getChild("selectedFace_ids");
    
      int ni = parent.getInt("ni");
      selectedFace_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedFace_ids[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedCurve_ids");
    
      int ni = parent.getInt("ni");
      selectedCurve_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedCurve_ids[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedVertex_ids");
    
      int ni = parent.getInt("ni");
      selectedVertex_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_ids[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedVertex_softSelectionVertices");
    
      int ni = parent.getInt("ni");
      selectedVertex_softSelectionVertices = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionVertices[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedVertex_softSelectionValues");
    
      int ni = parent.getInt("ni");
      selectedVertex_softSelectionValues = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionValues[i] = float(parts[i]);
      }
    }


    {
      XML parent = FileAll.getChild("selectedSolid_ids");
    
      int ni = parent.getInt("ni");
      selectedSolid_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedSolid_ids[i] = int(parts[i]);
      }
    }


    {
      XML parent = FileAll.getChild("selectedSection_ids");
    
      int ni = parent.getInt("ni");
      selectedSection_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedSection_ids[i] = int(parts[i]);
      }
    }

    {
      XML parent = FileAll.getChild("selectedCamera_ids");
    
      int ni = parent.getInt("ni");
      selectedCamera_ids = new int [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedCamera_ids[i] = int(parts[i]);
      }
    }



    {
      XML parent = FileAll.getChild("SolidImpact_Elevation");
    
      int ni = parent.getInt("ni");
      SolidImpact_Elevation = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_Elevation[i] = float(parts[i]);
      }
    } 

    {
      XML parent = FileAll.getChild("SolidImpact_Rotation");
    
      int ni = parent.getInt("ni");
      SolidImpact_Rotation = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_Rotation[i] = float(parts[i]);
      }
    } 

    {
      XML parent = FileAll.getChild("SolidImpact_scale_U");
    
      int ni = parent.getInt("ni");
      SolidImpact_scale_U = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_scale_U[i] = float(parts[i]);
      }
    } 

    {
        XML parent = FileAll.getChild("SolidImpact_scale_V");
    
      int ni = parent.getInt("ni");
      SolidImpact_scale_V = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_scale_V[i] = float(parts[i]);
      }
    }     

    {
      XML parent = FileAll.getChild("SolidImpact_offset_U");
    
      int ni = parent.getInt("ni");
      SolidImpact_offset_U = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_offset_U[i] = float(parts[i]);
      }
    } 


    {
      XML parent = FileAll.getChild("SolidImpact_offset_V");
    
      int ni = parent.getInt("ni");
      SolidImpact_offset_V = new float [ni];
      String lineSTR = parent.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_offset_V[i] = float(parts[i]);
      }
    }         

    
  }
  println("End of loading project.");


  // loading only weather data // 
  SOLARCHVISION_update_station(2); 
  SOLARCHVISION_update_station(3);
  SOLARCHVISION_update_station(4);
  SOLARCHVISION_update_station(5);
  ///////////////////////////////

  addNewSelectionToPreviousSelection = 0;

  UI_set_to_Create_Nothing();

  WORLD.AutoView = 1;

  WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

  SOLARCHVISION_update_frame_layout();

  ROLLOUT.update = true;
  WORLD.update = true;
  WIN3D.update = true; 
  STUDY.update = true;     
  UI_BAR_a_update = true; 
  UI_BAR_b_update = true;
  UI_BAR_d_update = true;



  rebuild_SolarImpactImage_array = 1;
  rebuild_WindRoseImage_array = 1; 

  //rebuild_VertexSolar_array = 1;
  rebuild_GlobalSolar_array = 1;

  SOLARCHVISION_resize_VertexSolar_array(); 
  SOLARCHVISION_resize_GlobalSolar_array();


  SOLARCHVISION_modify_Viewport_Title();
}


void SOLARCHVISION_hold_project () {

  HoldStamp = nf(millis(), 0);

  SOLARCHVISION_save_project(ProjectFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml", false);  
}

void SOLARCHVISION_fetch_project () {
  try {
    SOLARCHVISION_load_project(ProjectFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml");
  }
  catch (Exception e) {
    println("Cannot find hold file!");
  }
}








float[] SOLARCHVISION_translateInside_ReferencePivot (float a, float b, float c) {


  float rotX = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6];
  float rotY = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][7];
  float rotZ = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][8];

  float y1 = b * cos_ang(rotX) - c * sin_ang(rotX); 
  float z1 = b * sin_ang(rotX) + c * cos_ang(rotX);
  float x1 = a;

  a = x1;
  b = y1;
  c = z1;  

  float z2 = c * cos_ang(rotY) - a * sin_ang(rotY);
  float x2 = c * sin_ang(rotY) + a * cos_ang(rotY);
  float y2 = b; 

  a = x2;
  b = y2;
  c = z2;      

  float x = a * cos_ang(rotZ) - b * sin_ang(rotZ);
  float y = a * sin_ang(rotZ) + b * cos_ang(rotZ); 
  float z = c;      

  x *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3];
  y *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][4];
  z *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][5]; 

  x += SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  y += SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  z += SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];  

  float[] return_array = {
    x, y, z
  };

  return return_array;
}



float[] SOLARCHVISION_translateOutside_ReferencePivot (float a, float b, float c) {

  a -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  b -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  c -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];   

  a /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3];
  b /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][4];
  c /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][5];    



  float rotX = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6];
  float rotY = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][7];
  float rotZ = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][8];

  float x1 = a * cos_ang(-rotZ) - b * sin_ang(-rotZ);
  float y1 = a * sin_ang(-rotZ) + b * cos_ang(-rotZ); 
  float z1 = c;      

  a = x1;
  b = y1;
  c = z1;  

  float z2 = c * cos_ang(-rotY) - a * sin_ang(-rotY);
  float x2 = c * sin_ang(-rotY) + a * cos_ang(-rotY);
  float y2 = b; 

  a = x2;
  b = y2;
  c = z2;      

  float y = b * cos_ang(-rotX) - c * sin_ang(-rotX); 
  float z = b * sin_ang(-rotX) + c * cos_ang(-rotX);
  float x = a;  


  float[] return_array = {
    x, y, z
  };

  return return_array;
}




float[] SOLARCHVISION_getPivot () {

  float posX = SOLARCHVISION_selection_BoundingBox[1][0];
  float posY = SOLARCHVISION_selection_BoundingBox[1][1];
  float posZ = SOLARCHVISION_selection_BoundingBox[1][2];

  float x = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  float y = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  float z = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];

  {
    int keep_selection_alignX = selection_alignX;
    int keep_selection_alignY = selection_alignY;
    int keep_selection_alignZ = selection_alignZ;

    selection_alignX = 0; // apply the centre
    selection_alignY = 0; // apply the centre
    selection_alignZ = 0; // apply the centre

    float[] A = SOLARCHVISION_translateInside_ReferencePivot(x - posX, y - posY, z - posZ);  

    x = A[0];
    y = A[1];
    z = A[2];

    selection_alignX = keep_selection_alignX;
    selection_alignY = keep_selection_alignY;
    selection_alignZ = keep_selection_alignZ;
  }

  float[] return_array = {
    x, y, z
  };

  return return_array;
}















int typeUserCommand = 0;

boolean UI_BAR_c_update = true;

String[] allCommands = {"SOLARCHVISION Command Input:", ""};
String[] allMessages = {"SOLARCHVISION Command Output:", ""};

void SOLARCHVISION_draw_window_BAR_c () {
  if (UI_BAR_c_update) {
    
    UI_BAR_c_update = false;
    
    int maxDisplayLines = 2;

    if (typeUserCommand == 1) {
      fill(0);
    }
    else {
      fill(63);
    }
    noStroke();
    rect(0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel, width, SOLARCHVISION_C_Pixel);

    noStroke();
    
    textSize(1.5 * MessageSize);
    

    pushMatrix();
    translate(0, 0.333 * MessageSize + SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel);

    for (int q = 0; q < maxDisplayLines; q++) {
      
      int n = allCommands.length + q - maxDisplayLines;
      
      if ((0 <= n) && (n < allCommands.length)) {
        
        textAlign(RIGHT, CENTER);
        fill(255,127,0);
        text(allMessages[n], width - 0.5 * MessageSize, q * 1.5 * MessageSize);
        
        textAlign(LEFT, CENTER);
        fill(255);
        text(allCommands[n], 0.5 * MessageSize, q * 1.5 * MessageSize);

      }
    }
    
    popMatrix();

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }  
}



void COMIN_keyPressed (KeyEvent e) {



  if (e.isAltDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {
      }
    }
  } else if (e.isControlDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {
      }
    }
  } else if (e.isShiftDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    }
  }


  if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {

    if (key == CODED) { 
      switch(keyCode) {
      }
    }
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key != CODED) { 
      switch(key) {

       case ENTER:
         String[] newCommand = {""};
         String[] newMessage = {""};
         
         allMessages[allMessages.length - 1] = SOLARCHVISION_executeCommand(allCommands[allCommands.length - 1]);         
         
         allCommands = concat(allCommands, newCommand);  
         allMessages = concat(allMessages, newMessage);
         break;
        
       case BACKSPACE: 
          if (allCommands[allCommands.length - 1].length() > 0) {
            allCommands[allCommands.length - 1] = allCommands[allCommands.length - 1].substring(0, allCommands[allCommands.length - 1].length() - 1);
          }
          break;

        default:
          if ((31 < key) && (key < 127)) { 
            allCommands[allCommands.length - 1] += key;
          }
          break;
      }
      
      
    }
  }
}

void SOLARCHVISION_execute_commands_TXT (String FileName) {

  String[] FileALL = loadStrings(FileName);

  for (int f = 0; f < FileALL.length; f++) {

    String lineSTR = FileALL[f];
  
    SOLARCHVISION_executeCommand(lineSTR);
  } 
  
}

String SOLARCHVISION_executeCommand (String lineSTR) {

  String return_message = "";
  
  lineSTR = lineSTR.replace("\"", ""); 
  
  String[] parts = split(lineSTR, ' ');
  
  String Command_CAPITAL = parts[0].toUpperCase();
  
  if (Command_CAPITAL.equals("CLS")) {
    allCommands = new String[1];
    allMessages = new String[1];

    allCommands[0] = "";
    allMessages[0] = "";
  }
  
  else if (Command_CAPITAL.equals("OPEN")) {
    selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
  }          

  else if (Command_CAPITAL.equals("SAVE.AS")) {
    selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
  }

  else if (Command_CAPITAL.equals("SAVE")) {
    SOLARCHVISION_save_project(ProjectFolder + "/" + ProjectName + ".xml", false);
  }    

  else if (Command_CAPITAL.equals("HOLD")) {
    SOLARCHVISION_hold_project();
  }  

  else if (Command_CAPITAL.equals("FETCH")) {
    SOLARCHVISION_fetch_project();
  }    

  else if (Command_CAPITAL.equals("IMPORT")) {
    selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
  }   

  else if (Command_CAPITAL.equals("EXECUTE")) {
    selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
  }
  
  else if (Command_CAPITAL.equals("EXPORT.OBJ.TIMESERIES")) {
    SOLARCHVISION_export_objects_OBJ_timeSeries();
  }    

  else if (Command_CAPITAL.equals("EXPORT.OBJ.DATESERIES")) {
    SOLARCHVISION_export_objects_OBJ_dateSeries();
  }      

  else if (Command_CAPITAL.equals("EXPORT.OBJ")) {
    SOLARCHVISION_export_objects_OBJ("");
  }    
  
  else if (Command_CAPITAL.equals("EXPORT.RAD")) {
    SOLARCHVISION_export_objects_RAD();
  }

  else if (Command_CAPITAL.equals("EXPORT.SCR")) {
    SOLARCHVISION_export_objects_SCR();
  }                

  else if (Command_CAPITAL.equals("QUIT")) {
    exit();
  }      





  else if (Command_CAPITAL.equals("MOVE")) {
    if (parts.length > 1) {
      float dx = 0;
      float dy = 0;
      float dz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
        }
        else {
               if (q == 1) dx = float(parameters[0]);
          else if (q == 2) dy = float(parameters[0]);
          else if (q == 3) dz = float(parameters[0]);
        }
      }
      SOLARCHVISION_move_Selection(dx, dy, dz);
      WIN3D.update = true;
    }
    else {
      return_message = "Move dx=? dy=? dz=?";
      
      SOLARCHVISION_highlight_in_BAR_b("MV³");
      UI_BAR_b_update = true;
    }
  }  
  
  else if ((Command_CAPITAL.equals("ROTATE")) || (Command_CAPITAL.equals("ROTATEX")) || (Command_CAPITAL.equals("ROTATEY")) || (Command_CAPITAL.equals("ROTATEZ"))) {
    if (parts.length > 1) {
      int v = 2;
      if (Command_CAPITAL.equals("ROTATEX")) v = 0;
      if (Command_CAPITAL.equals("ROTATEY")) v = 1;
      if (Command_CAPITAL.equals("ROTATEZ")) v = 2;
      
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) r = float(parameters[0]);
        }      
      }
      SOLARCHVISION_rotate_Selection(x, y, z, r, v);
      WIN3D.update = true;
    }
    else {
      return_message = "Rotate[X|Y|Z] r=? x=? y=? z=?";
  
      UI_set_to_Modify_Rotate(2);
      UI_BAR_b_update = true;
    }    
  }    
  
  else if (Command_CAPITAL.equals("SCALE")) {
    if (parts.length > 1) {
      float sx = 1;
      float sy = 1;
      float sz = 1;
      
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("s")) {sx = float(parameters[1]); sy = sx; sz = sx;}
          else if (parameters[0].toLowerCase().equals("sxy")) {sx = float(parameters[1]); sy = sx;}             
          else if (parameters[0].toLowerCase().equals("syz")) {sy = float(parameters[1]); sz = sy;}
          else if (parameters[0].toLowerCase().equals("szx")) {sz = float(parameters[1]); sx = sz;}
          else if (parameters[0].toLowerCase().equals("sx")) sx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sy")) sy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sz")) sz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) {sx = float(parameters[0]); sy = sx; sz = sx;}
        }           
      }
      SOLARCHVISION_scale_Selection(x, y, z, sx, sy, sz);
      WIN3D.update = true;
    }
    else {
      return_message = "Scale s=? sx=? sy=? sz=? x=? y=? z=?";
      
      SOLARCHVISION_highlight_in_BAR_b("SC³");
      UI_BAR_b_update = true;      
    }        
  }    
  
  else if (Command_CAPITAL.equals("DELETE")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
             if (parts[q].toLowerCase().equals("all")) {SOLARCHVISION_delete_All(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("selection")) {allModel3Ds.delete_Selection(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("group3ds")) {allModel3Ds.delete_allGroups(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("object2ds")) {allModel2Ds.delete(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("allModel1Ds")) {allModel1Ds.delete(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("vertices")) {allModel3Ds.deleteIsolatedVertices_Selection(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("faces")) {allModel3Ds.delete_Faces(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("lines")) {allModel3Ds.delete_Curves(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("solids")) {allModel3Ds.delete_allSolids(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("sections")) {allModel3Ds.delete_allSections(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("cameras")) {allModel3Ds.delete_allCameras(); WIN3D.update = true;}
      }
    }
    else {
      return_message = "Delete all/selection/group3Ds/object2Ds/allModel1Ds/vertices/faces/solids/sections/cameras";
    }
  }   
  
  else if (Command_CAPITAL.equals("COPY")) {
    if (parts.length > 1) {
      int n = 1;
      float dx = 0;
      float dy = 0;
      float dz = 0;
      float rx = 0;
      float ry = 0;
      float rz = 0;      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("n")) n = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rx")) rx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("ry")) ry = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rz")) rz = float(parameters[1]);          
        }
      }
      
      for (int q = 0; q < n; q++) {
        allModel3Ds.duplicate_Selection(0); 
        if ((dx != 0) || (dy != 0) || (dz != 0)) SOLARCHVISION_move_Selection(dx, dy, dz);
        if (rx != 0) SOLARCHVISION_rotate_Selection(0, 0, 0, rx, 0);
        if (ry != 0) SOLARCHVISION_rotate_Selection(0, 0, 0, ry, 1);
        if (rz != 0) SOLARCHVISION_rotate_Selection(0, 0, 0, rz, 2);
      }
      WIN3D.update = true;
    }
    else {
      return_message = "Copy n=? dx=? dy=? dz=? rx=? ry=? rz=?";
    }
  }   
  
  else if (Command_CAPITAL.equals("SELECT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
             if (parts[q].toLowerCase().equals("group3ds")) {Current_ObjectCategory = ObjectCategory.GROUP; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("object2ds")) {Current_ObjectCategory = ObjectCategory.MODEL2D; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("allModel1Ds")) {Current_ObjectCategory = ObjectCategory.MODEL1D; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("vertices")) {Current_ObjectCategory = ObjectCategory.VERTEX; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("faces")) {Current_ObjectCategory = ObjectCategory.FACE; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("lines")) {Current_ObjectCategory = ObjectCategory.CURVE; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("solids")) {Current_ObjectCategory = ObjectCategory.SOLID; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("sections")) {Current_ObjectCategory = ObjectCategory.SECTION; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("cameras")) {Current_ObjectCategory = ObjectCategory.CAMERA; UI_BAR_b_update = true;}
        else if (parts[q].toLowerCase().equals("landpoints")) {Current_ObjectCategory = ObjectCategory.LANDPOINT; UI_BAR_b_update = true;}
      }
      
      for (int q = 1; q < parts.length; q++) {
             if (parts[q].toLowerCase().equals("all")) {allModel3Ds.select_All(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("reverse")) {allModel3Ds.reverse_Selection(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("nothing")) {allModel3Ds.deselect_All(); WIN3D.update = true;}
        else if (parts[q].toLowerCase().equals("last")) {allModel3Ds.select_Last(); WIN3D.update = true;}
      }
    }
    else {
      return_message = "Select all/last/nothing/reverse group3Ds/object2Ds/allModel1Ds/vertices/faces/solids/sections/cameras/landpoint";
    }
  }





  
  else if (Command_CAPITAL.equals("2DMAN")) {
    if (parts.length > 1) {
      String t = "PEOPLE";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
        }
      }
      allModel2Ds.add_single(t, m, x, y, z, 2.5);
      WIN3D.update = true;  
      Current_ObjectCategory = ObjectCategory.MODEL2D; 
      UI_BAR_b_update = true;
      //allModel3Ds.select_Last();
    }
    else {
      return_message = "2Dman m=? x=? y=? z=?";

      UI_set_to_Create_Person();
      SOLARCHVISION_highlight_in_BAR_b("Person");
      UI_BAR_b_update = true;      
    }  
  }
     
  else if (Command_CAPITAL.equals("2DTREE")) {
    if (parts.length > 1) {
      String t = "TREES";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel2Ds.add_single(t, m, x, y, z, h);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.MODEL2D; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "2Dtree m=? x=? y=? z=? h=?";
      
      UI_set_to_Create_Tree();
      SOLARCHVISION_highlight_in_BAR_b("Tree");
      UI_BAR_b_update = true;      
    }  
  }    
 
  else if (Command_CAPITAL.equals("3DTREE")) {
    if (parts.length > 1) {
      int m = 0;
      int Sd = 0; //PlantSeed
      int Min = 2; //PlantDegreeMin
      int Max = 5; //PlantDegreeMax
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      float r = 0;
      float Tk = 1.0; //TrunkSize
      float Lf = 1.0; //LeafSize
       
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sd")) Sd = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("min")) Min = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("max")) Max = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]) * PI / 180.0;
          else if (parameters[0].toLowerCase().equals("tk")) Tk = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lf")) Lf = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel1Ds.add_single(m, x, y, z, h, r, Min, Max, Sd, Tk, Lf);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.MODEL1D; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "3Dtree m=? Sd=? Min=? Max=? x=? y=? z=? h=? r=? Tk=? Lf=?";
      
      UI_set_to_Create_allModel1Ds();
      SOLARCHVISION_highlight_in_BAR_b("allModel1Ds");
      UI_BAR_b_update = true;      
    }  
  }     

  else if (Command_CAPITAL.equals("BOX2P")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x2 - x1 != 0) && (y2 - y1 != 0) && (z2 - z1 != 0)) {   
        allModel3Ds.add_Box_Corners(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Box2P m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";

      UI_set_to_Create_Box();
      SOLARCHVISION_highlight_in_BAR_b("Box");
      UI_BAR_b_update = true;            
    }  
  }  
  
  else if (Command_CAPITAL.equals("BOX")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_Box_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Box m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";

      UI_set_to_Create_Box();
      SOLARCHVISION_highlight_in_BAR_b("Box");
      UI_BAR_b_update = true;      
    }  
  }     

  else if (Command_CAPITAL.equals("HOUSE1")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_House1_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "House1 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House1();
      SOLARCHVISION_highlight_in_BAR_b("House1");
      UI_BAR_b_update = true;      
    }  
  }     
  
  else if (Command_CAPITAL.equals("HOUSE2")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_House2_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "House2 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House1();
      SOLARCHVISION_highlight_in_BAR_b("House2");
      UI_BAR_b_update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("CYLINDER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 16;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_SuperCylinder(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, 0.5 * d, 0.5 * h, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Cylinder m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";
      
      UI_set_to_Create_Cylinder();
      SOLARCHVISION_highlight_in_BAR_b("Cylinder");
      UI_BAR_b_update = true;            
    }  
  }   

  else if (Command_CAPITAL.equals("SPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, 0, 90 + r); // passing with isSky:0
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Sphere m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";
      
      UI_set_to_Create_Sphere();
      SOLARCHVISION_highlight_in_BAR_b("Sphere");
      UI_BAR_b_update = true;      
    }  
  }   


  else if (Command_CAPITAL.equals("SUPERSPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float px = 2;
      float py = 2;
      float pz = 2;      
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("px")) px = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("py")) py = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("pz")) pz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0) && (px > 0) && (py > 0) && (pz > 0)) {   
        allModel3Ds.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, px, py, pz, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "SuperSphere m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? px=? py=? pz=? deg=? r=?";
      
      UI_set_to_Create_Sphere();
      SOLARCHVISION_highlight_in_BAR_b("Sphere");
      UI_BAR_b_update = true;      
    }  
  }   

  else if (Command_CAPITAL.equals("CUSHION")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, CubePower, CubePower, 2, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Cushion m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";
      
      UI_set_to_Create_Cushion();
      SOLARCHVISION_highlight_in_BAR_b("Cushion");
      UI_BAR_b_update = true;      
    }  
  }   
          

  else if (Command_CAPITAL.equals("OCTAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dx")) dx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dy")) dy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("dz")) dz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_Octahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Octahedron m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";
      
      UI_set_to_Create_Octahedron();
      SOLARCHVISION_highlight_in_BAR_b("Octahedron");
      UI_BAR_b_update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("ICOSAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_Icosahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Icosahedron m=? tes=? lyr=? x=? y=? z=? d=? r=?";
      
      UI_set_to_Create_Icosahedron();
      SOLARCHVISION_highlight_in_BAR_b("Icosahedron");
      UI_BAR_b_update = true;            
    }  
  } 
  
  else if (Command_CAPITAL.equals("POLYGONEXTRUDE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_PolygonExtrude(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonExtrude m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";
      
      UI_set_to_Create_Extrude();
      SOLARCHVISION_highlight_in_BAR_b("Extrude");
      UI_BAR_b_update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("POLYGONHYPER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_PolygonHyper(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonHyper m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";
      
      UI_set_to_Create_Hyper();
      SOLARCHVISION_highlight_in_BAR_b("Hyper");
      UI_BAR_b_update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("POLYGONMESH")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_PolygonMesh(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, r);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonMesh m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";
      
      UI_set_to_Create_Plane();
      SOLARCHVISION_highlight_in_BAR_b("Poly");
      UI_BAR_b_update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("MESH2")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x1 == x2) || (y1 == y2) || (z1 == z2)) {   
        allModel3Ds.add_Mesh2(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh2 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";
    }  
  } 
 
  else if (Command_CAPITAL.equals("MESH3")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x3")) x3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y3")) y3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z3")) z3 = float(parameters[1]);
        }
      }
      {   
        allModel3Ds.add_Mesh3(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh3 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=?";
    }  
  }    

  else if (Command_CAPITAL.equals("MESH4")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x3")) x3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y3")) y3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z3")) z3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x4")) x4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y4")) y4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z4")) z4 = float(parameters[1]);          
        }
      }
      {   
        allModel3Ds.add_Mesh4(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh4 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=?";
    }  
  }  

  else if (Command_CAPITAL.equals("MESH5")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;    
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;          
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x3")) x3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y3")) y3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z3")) z3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x4")) x4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y4")) y4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z4")) z4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x5")) x5 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y5")) y5 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z5")) z5 = float(parameters[1]);            
        }
      }
      {   
        allModel3Ds.add_Mesh5(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh5 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=?";
    }  
  }  
  
  else if (Command_CAPITAL.equals("MESH6")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;    
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;
      float x6 = 0;
      float y6 = 0;
      float z6 = 0;         
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x1")) x1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y1")) y1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z1")) z1 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x2")) x2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y2")) y2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z2")) z2 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x3")) x3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y3")) y3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z3")) z3 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x4")) x4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y4")) y4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z4")) z4 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x5")) x5 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y5")) y5 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z5")) z5 = float(parameters[1]);            
          else if (parameters[0].toLowerCase().equals("x6")) x6 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y6")) y6 = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z6")) z6 = float(parameters[1]);         
        }
      }
      {   
        allModel3Ds.add_Mesh6(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh6 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=? x6=? y6=? z6=?";
    }  
  }    

  else if (Command_CAPITAL.equals("H_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float w = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("w")) w = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("a")) a = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (w != 0)) {
        allModel3Ds.add_H_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, d, w, a, b);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "H_Shade m=? tes=? lyr=? x=? y=? z=? d=? w=? a=? b=?";
    }  
  }
  
  else if (Command_CAPITAL.equals("V_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float h = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);

          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("d")) d = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("a")) a = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_V_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, h, d, a, b);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.FACE; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "V_Shade m=? tes=? lyr=? x=? y=? z=? d=? h=? a=? b=?";
    }  
  }  

  else if (Command_CAPITAL.equals("SOLID")) {
    if (parts.length > 1) {
      float v = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float px = 2;
      float py = 2;
      float pz = 2;
      float sx = 1;
      float sy = 1;
      float sz = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("v")) v = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("px")) px = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("py")) py = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("pz")) pz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sx")) sx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sy")) sy = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("sz")) sz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rx")) rx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("ry")) ry = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rz")) rz = float(parameters[1]);
        }
      }
      if ((px != 0) && (py != 0) && (pz != 0) && (sx != 0) && (sy != 0) && (sz != 0) && (v != 0)) {   
        allModel3Ds.add_Solid(x, y, z, px, py, pz, sx, sy, sz, rx, ry, rz, v);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.SOLID; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Solid x=? y=? z=? px=? py=? pz=? sx=? sy=? sz=? rx=? ry=? rz=? v=?";
      
      UI_set_to_Create_Solid();
      SOLARCHVISION_highlight_in_BAR_b("SLD");
      UI_BAR_b_update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("SECTION")) {
    if (parts.length > 1) {
      int t = 1;
      int i = 200;
      int j = 200;
      float w = 20;
      float h = 20;      
      float u = 0;
      float v = 0;
      float e = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("t")) t = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("i")) i = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("j")) j = int(parameters[1]);  
          else if (parameters[0].toLowerCase().equals("w")) w = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("h")) h = float(parameters[1]);          
          else if (parameters[0].toLowerCase().equals("u")) u = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("v")) v = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("e")) e = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
        }
      }
      if ((t > 0) && (i > 0) && (j > 0) && (w > 0) && (h > 0)) {   
        allModel3Ds.add_Section(t, u, v, e, r, w, h, i, j);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.SECTION; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Section t=? i=? j=? w=? h=? u=? v=? e=? r=?";
      
      UI_set_to_Create_Section();
      SOLARCHVISION_highlight_in_BAR_b("SEC");
      UI_BAR_b_update = true;      
    }  
  }

  else if (Command_CAPITAL.equals("CAMERA")) {
    if (parts.length > 1) {
      int t = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float s = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      float a = 60;
      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("t")) t = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("s")) s = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rx")) rx = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("ry")) ry = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rz")) rz = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("a")) a = float(parameters[1]);
        }
      }
      if ((s != 0) && (a != 0)) {   
        allModel3Ds.add_Camera(t, x, y, z, s, rx, ry, rz, a);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.CAMERA; 
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Camera t=? x=? y=? z=? s=? rx=? ry=? rz=? a=?";
      
      UI_set_to_Create_Camera();
      SOLARCHVISION_highlight_in_BAR_b("CAM");
      UI_BAR_b_update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("SPLINE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float[][] points = new float [0][3];
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("wgt")) wgt = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("clz")) clz = int(parameters[1]);
        }
        else {
          String[] xyz = split(parts[q], ',');
          if (xyz.length > 2) {
            float[][] newPoint = {{float(xyz[0]), float(xyz[1]), float(xyz[2])}}; 
            points = (float[][]) concat(points, newPoint);
          }
        }        
      }
      if (points.length > 1) {   
        allModel3Ds.add_Spline(m, tes, lyr, vsb, wgt, clz, points);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.CURVE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Spline m=? tes=? lyr=? xtr=? wgt=? clz=? x1,y1,z1 x2,y2,z2 etc.";
      
      UI_set_to_Create_Curve();
      SOLARCHVISION_highlight_in_BAR_b("Curve");
      UI_BAR_b_update = true;                
    }  
  }  
  
  else if (Command_CAPITAL.equals("ARC")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      float rot = 0;
      float ang = 360; // complete circle
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
               if (parameters[0].toLowerCase().equals("m")) m = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("tes")) tes = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("lyr")) lyr = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("wgt")) wgt = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("clz")) clz = int(parameters[1]);
          else if (parameters[0].toLowerCase().equals("x")) x = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("y")) y = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("z")) z = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("r")) r = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("rot")) rot = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("ang")) ang = float(parameters[1]);
          else if (parameters[0].toLowerCase().equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((r != 0) && (deg > 2)) {   
        allModel3Ds.add_Arc(m, tes, lyr, vsb, wgt, clz, x, y, z, r, deg, rot, ang);
        WIN3D.update = true;  
        Current_ObjectCategory = ObjectCategory.CURVE;
        UI_BAR_b_update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Arc m=? tes=? lyr=? xtr=? wgt=? clz=? x=? y=? z=? r=? deg=? rot=? ang=?";

      UI_set_to_Create_Curve();
      SOLARCHVISION_highlight_in_BAR_b("Curve");
      UI_BAR_b_update = true;                      
    }  
  } 
  
  else if (Command_CAPITAL.equals("PIVOT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
             if (parts[q].toLowerCase().equals("minx")) UI_set_to_View_PivotX(-1);
        else if (parts[q].toLowerCase().equals("midx")) UI_set_to_View_PivotX(0);
        else if (parts[q].toLowerCase().equals("maxx")) UI_set_to_View_PivotX(1);
        else if (parts[q].toLowerCase().equals("miny")) UI_set_to_View_PivotY(-1);
        else if (parts[q].toLowerCase().equals("midy")) UI_set_to_View_PivotY(0);
        else if (parts[q].toLowerCase().equals("maxy")) UI_set_to_View_PivotY(1);
        else if (parts[q].toLowerCase().equals("minz")) UI_set_to_View_PivotZ(-1);
        else if (parts[q].toLowerCase().equals("midz")) UI_set_to_View_PivotZ(0);
        else if (parts[q].toLowerCase().equals("maxz")) UI_set_to_View_PivotZ(1);
      }
    }
    else {
      return_message = "PIVOT minX midY maxZ or other variations";
    }    
  }
  
  else if (Command_CAPITAL.equals("VERTEX>GROUP")) {
    allModel3Ds.convert_Vertices_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("FACE>GROUP")) {
    allModel3Ds.convert_Faces_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>FACE")) {
    allModel3Ds.convert_allGroups_to_Faces();
    Current_ObjectCategory = ObjectCategory.FACE;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }    
  else if (Command_CAPITAL.equals("CURVE>GROUP")) {
    allModel3Ds.convert_Curves_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>CURVE")) {
    allModel3Ds.convert_allGroups_to_Curves();
    Current_ObjectCategory = ObjectCategory.CURVE;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }            
  else if (Command_CAPITAL.equals("CURVE>VERTEX")) {
    allModel3Ds.convert_Curves_to_Vertices();
    Current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  } 
  else if (Command_CAPITAL.equals("VERTEX>CURVE")) {
    allModel3Ds.convert_Vertices_to_Curves();
    Current_ObjectCategory = ObjectCategory.CURVE;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }               
  else if (Command_CAPITAL.equals("GROUP>VERTEX")) {
    allModel3Ds.convert_allGroups_to_Vertices();
    Current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }  
  else if (Command_CAPITAL.equals("FACE>VERTEX")) {
    allModel3Ds.convert_Faces_to_Vertices();
    Current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  } 
  else if (Command_CAPITAL.equals("VERTEX>FACE")) {
    allModel3Ds.convert_Vertices_to_Faces();
    Current_ObjectCategory = ObjectCategory.FACE;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }    
  else if (Command_CAPITAL.equals("SOLID>GROUP")) {
    allModel3Ds.convert_allSolids_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>SOLID")) {
    allModel3Ds.convert_allGroups_to_allSolids();
    Current_ObjectCategory = ObjectCategory.SOLID;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }                
  else if (Command_CAPITAL.equals("2D>GROUP")) {
    allModel3Ds.convert_allModel2Ds_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>2D")) {
    allModel3Ds.convert_allGroups_to_allModel2Ds();
    Current_ObjectCategory = ObjectCategory.MODEL2D;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("1D>GROUP")) {
    allModel3Ds.convert_allModel1Ds_to_allGroups();
    Current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>1D")) {
    allModel3Ds.convert_allGroups_to_allModel1Ds();
    Current_ObjectCategory = ObjectCategory.MODEL1D;
    WIN3D.update = true;
    UI_BAR_b_update = true;
  }              

  else if (Command_CAPITAL.equals("DISTZ")) {
    UI_set_to_View_Truck(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDZ");
    UI_BAR_b_update = true;    
  } 
  else if (Command_CAPITAL.equals("DISTC")) {
    UI_set_to_View_CameraDistance(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDS");
    UI_BAR_b_update = true;    
  } 
  else if (Command_CAPITAL.equals("DISTP")) {
    UI_set_to_View_DistMouseXY(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDM");
    UI_BAR_b_update = true;    
  } 


  else if (Command_CAPITAL.equals("SIZEALL")) {
    UI_set_to_View_AllModelSize();
    SOLARCHVISION_highlight_in_BAR_b("±SA");
    UI_BAR_b_update = true;    
  } 
  else if (Command_CAPITAL.equals("SIZESKY")) {
    UI_set_to_View_SkydomeSize();
    SOLARCHVISION_highlight_in_BAR_b("±SK");
    UI_BAR_b_update = true;    
  } 
  else if (Command_CAPITAL.equals("SIZE3D")) {
    UI_set_to_View_3DModelSize();
    SOLARCHVISION_highlight_in_BAR_b("±SZ");
    UI_BAR_b_update = true;    
  } 

  else if (Command_CAPITAL.equals("ALLVIEWPORTS")) {
    UI_set_to_Viewport(0);
    SOLARCHVISION_highlight_in_BAR_b("AllViewports");
    UI_BAR_b_update = true;    
  }   
  else if (Command_CAPITAL.equals("ENLARGE3D")) {
    UI_set_to_Viewport(1);
    SOLARCHVISION_highlight_in_BAR_b("Expand3DView");
    UI_BAR_b_update = true;    
  } 
  
  else if (Command_CAPITAL.equals("LOOKORG")) {
    UI_set_to_View_LookAtOrigin(0);
    SOLARCHVISION_highlight_in_BAR_b("LAO");
    UI_BAR_b_update = true;    
  }   
  else if (Command_CAPITAL.equals("LOOKDIR")) {
    UI_set_to_View_LookAtDirection(0);
    SOLARCHVISION_highlight_in_BAR_b("LAD");
    UI_BAR_b_update = true;    
  }   
  else if (Command_CAPITAL.equals("LOOKSEL")) {
    UI_set_to_View_LookAtSelection(0);
    SOLARCHVISION_highlight_in_BAR_b("LAS");
    UI_BAR_b_update = true;    
  }   
  
  else if (Command_CAPITAL.equals("TRUCKZ")) {
    UI_set_to_View_Truck(0);
    SOLARCHVISION_highlight_in_BAR_b("DIz");
    UI_BAR_b_update = true;
  }   
  else if (Command_CAPITAL.equals("TRUCKX")) {
    UI_set_to_View_Truck(1);
    SOLARCHVISION_highlight_in_BAR_b("DIx");
    UI_BAR_b_update = true;
  }   
  else if (Command_CAPITAL.equals("TRUCKY")) {
    UI_set_to_View_Truck(2);
    SOLARCHVISION_highlight_in_BAR_b("DIy");
    UI_BAR_b_update = true;
  }   

  else if (Command_CAPITAL.equals("TROLL")) {
    UI_set_to_View_TargetRoll(0);
    SOLARCHVISION_highlight_in_BAR_b("TRL");
    UI_BAR_b_update = true;
  }   
  else if (Command_CAPITAL.equals("TROLLZ")) {
    UI_set_to_View_TargetRoll(1);
    SOLARCHVISION_highlight_in_BAR_b("TRLz");
    UI_BAR_b_update = true;    
  }   
  else if (Command_CAPITAL.equals("TROLLXY")) {
    UI_set_to_View_TargetRoll(2);
    SOLARCHVISION_highlight_in_BAR_b("TRLxy");
    UI_BAR_b_update = true;    
  }     
  
  else if (Command_CAPITAL.equals("CROLL")) {
    UI_set_to_View_CameraRoll(0);
    SOLARCHVISION_highlight_in_BAR_b("CRL");
    UI_BAR_b_update = true;   
  }   
  else if (Command_CAPITAL.equals("CROLLZ")) {
    UI_set_to_View_CameraRoll(1);
    SOLARCHVISION_highlight_in_BAR_b("CRLz");
    UI_BAR_b_update = true;   
  }   
  else if (Command_CAPITAL.equals("CROLLXY")) {
    UI_set_to_View_CameraRoll(2);
    SOLARCHVISION_highlight_in_BAR_b("CRLxy");
    UI_BAR_b_update = true;   
  }   
  
  
  else if (Command_CAPITAL.equals("ORBIT")) {
    UI_set_to_View_Orbit(0);
    SOLARCHVISION_highlight_in_BAR_b("OR");
    UI_BAR_b_update = true;   
  }   
  else if (Command_CAPITAL.equals("ORBITZ")) {
    UI_set_to_View_Orbit(1);
    SOLARCHVISION_highlight_in_BAR_b("ORz");
    UI_BAR_b_update = true;   
  }   
  else if (Command_CAPITAL.equals("ORBITXY")) {
    UI_set_to_View_Orbit(2);
    SOLARCHVISION_highlight_in_BAR_b("ORxy");
    UI_BAR_b_update = true;   
  }
  
  else if (Command_CAPITAL.equals("LANDORBIT")) {
    UI_set_to_View_LandOrbit(0);
    SOLARCHVISION_highlight_in_BAR_b("LNOR");
    UI_BAR_b_update = true;   
  }    
  
  else if (Command_CAPITAL.equals("PAN")) {
    UI_set_to_View_Pan(0);
    SOLARCHVISION_highlight_in_BAR_b("Pan");
    UI_BAR_b_update = true;   
  }  
  else if (Command_CAPITAL.equals("PANX")) {
    UI_set_to_View_Pan(1);
    SOLARCHVISION_highlight_in_BAR_b("PanX");
    UI_BAR_b_update = true;   
  }  
  else if (Command_CAPITAL.equals("PANY")) {
    UI_set_to_View_Pan(2);
    SOLARCHVISION_highlight_in_BAR_b("PanY");
    UI_BAR_b_update = true;    
  }  

  else if (Command_CAPITAL.equals("ZOOM")) {
    UI_set_to_View_ZOOM(0);
    SOLARCHVISION_highlight_in_BAR_b("±ZM");
    UI_BAR_b_update = true;    
  }    
  else if (Command_CAPITAL.equals("NORMALZOOM")) {
    UI_set_to_View_ZOOM(1);
    SOLARCHVISION_highlight_in_BAR_b("0ZM");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("ORTHOGRAPHIC")) {
    UI_set_to_View_ProjectionType(0);
    SOLARCHVISION_highlight_in_BAR_b("P<>");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("PERSPECTIVE")) {
    UI_set_to_View_ProjectionType(1);
    SOLARCHVISION_highlight_in_BAR_b("P><");
    UI_BAR_b_update = true;    
  }    
  else if (Command_CAPITAL.equals("TOP")) {
    UI_set_to_View_3DViewPoint(0);
    SOLARCHVISION_highlight_in_BAR_b("Top");
    UI_BAR_b_update = true;    
  }    
  else if (Command_CAPITAL.equals("FRONT")) {
    UI_set_to_View_3DViewPoint(1);
    SOLARCHVISION_highlight_in_BAR_b("Front");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("LEFT")) {
    UI_set_to_View_3DViewPoint(2);
    SOLARCHVISION_highlight_in_BAR_b("Left");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("BACK")) {
    UI_set_to_View_3DViewPoint(3);
    SOLARCHVISION_highlight_in_BAR_b("Back");
    UI_BAR_b_update = true;    
  }    
  else if (Command_CAPITAL.equals("RIGHT")) {
    UI_set_to_View_3DViewPoint(4);
    SOLARCHVISION_highlight_in_BAR_b("Right");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("BOTTOM")) {
    UI_set_to_View_3DViewPoint(5);
    SOLARCHVISION_highlight_in_BAR_b("Bottom");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("S.W.")) {
    UI_set_to_View_3DViewPoint(6);
    SOLARCHVISION_highlight_in_BAR_b("S.W.");
    UI_BAR_b_update = true;    
  }    
  else if (Command_CAPITAL.equals("S.E.")) {
    UI_set_to_View_3DViewPoint(7);
    SOLARCHVISION_highlight_in_BAR_b("S.E.");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("N.E.")) {
    UI_set_to_View_3DViewPoint(8);
    SOLARCHVISION_highlight_in_BAR_b("N.E.");
    UI_BAR_b_update = true;    
  }  
  else if (Command_CAPITAL.equals("N.W.")) {
    UI_set_to_View_3DViewPoint(9);
    SOLARCHVISION_highlight_in_BAR_b("N.W.");
    UI_BAR_b_update = true;    
  }    
  

  else if (Command_CAPITAL.equals("SHADE.WIRE")) {
    WIN3D.FacesShade = SHADE.Surface_Wire;
    allModel3Ds.DisplayEdges = true; //<<<<<<<<<<<<<<<
    WIN3D.update = true;  
  }       
  else if (Command_CAPITAL.equals("SHADE.BASE")) {
    WIN3D.FacesShade = SHADE.Surface_Base;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.WHITE")) {
    WIN3D.FacesShade = SHADE.Surface_White;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.MATERIALS")) {
    WIN3D.FacesShade = SHADE.Surface_Materials;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.GLOBAL")) {
    WIN3D.FacesShade = SHADE.Global_Solar;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.REAL")) {
    WIN3D.FacesShade = SHADE.Vertex_Solar;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.SOLID")) {
    WIN3D.FacesShade = SHADE.Vertex_Solid;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.ELEVATION")) {
    WIN3D.FacesShade = SHADE.Vertex_Elevation;
    WIN3D.update = true;  
  }      
  else if (Command_CAPITAL.equals("RENDER.VIEWPORT")) {
    SOLARCHVISION_RenderViewport();            
  }     
  else if (Command_CAPITAL.equals("PREBAKE.VIEWPORT")) {
    SOLARCHVISION_PreBakeViewport();            
  }             


  else if (Command_CAPITAL.equals("LONLAT")) {
    if (parts.length > 2) {
      
      STATION.setLatitude(float(parts[2]));
      STATION.setLongitude(float(parts[1]));
      
      SOLARCHVISION_update_station(1);
    }
    else {
      return_message = "LonLat ? ?";
    }        
  }      

  
  return return_message;
}



void SOLARCHVISION_PreBakeViewport () {

  cursor(WAIT);  
  
  println("PreBaking Direct and Diffuse Models. Please wait...");  

  Camera_Variation = 0;
  
  SolarImpact_sectionType = 1; // <<<<< so that it analyzed later!

  int start_DATE_ANGLE = 0;
  int step_DATE_ANGLE = 15;
  int end_DATE_ANGLE = 360 - step_DATE_ANGLE;
  
  int start_HOUR = 4; // to make it faster. Also the images are not needed out of this period.
  int step_HOUR = 1;
  int end_HOUR = 20; // to make it faster. Also the images are not needed out of this period.

  SceneName = "Viewport_" + Viewport_Stamp();

  int pre_WIN3D_dX = WIN3D.dX; 
  int pre_WIN3D_dY = WIN3D.dY;
 
  WIN3D.dX = SolarImpact_RES1;
  WIN3D.dY = SolarImpact_RES2;
  WIN3D.R_View = float(WIN3D.dY) / float(WIN3D.dX);

  WIN3D.transform_3DViewport();
  
  //WIN3D.put_3DViewport();  //????????????

  float ScaleToFit = float(pre_WIN3D_dY) / float(WIN3D.dY); 


  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;    

  float[][] Diffuse_Matrix = new float [2][(RES1 * RES2)]; 
  
  for (int SHD = 0; SHD <= 1; SHD++) {
    for (int np = 0; np < (RES1 * RES2); np++) {
      Diffuse_Matrix[SHD][np] = 0; 
    }
  }

  int n_Map = 0; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1;
    }
  } 
  
  PImage[][] Direct_RGBA = new PImage [n_Map][2];


  int[] lastHitDirect = new int [n_Map];
  
  for (int i = 0; i < lastHitDirect.length; i++) {
    lastHitDirect[i] = 0;
  }  

  int[] lastHitDiffuse = new int [DiffuseVectors.length];
  
  for (int i = 0; i < lastHitDiffuse.length; i++) {
    lastHitDiffuse[i] = 0;
  }  


  n_Map = -1; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1; 
      
      for (int SHD = 0; SHD <= 1; SHD++) {

        Direct_RGBA[n_Map][SHD] = createImage(RES1, RES2, ARGB);
        
        Direct_RGBA[n_Map][SHD].loadPixels();
      }
    }
  }
  
  float Progress = 0;

  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    if (1 + Progress < 100 * np / float(RES1 * RES2)) { 
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }
    
    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;
  

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X * ScaleToFit, Image_Y * ScaleToFit);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];


    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);

    if (RxP[0] >= 0) {        
        
      int f = int(RxP[0]);

      float[] COL = {
        0, 0, 0, 0
      };
      
      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = SOLARCHVISION_fn_normalize(face_norm);
      
      if (SOLARCHVISION_fn_dot(face_norm, ray_direction) > 0) { // to render backing faces 
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }
      
      float Alpha = 90 - acos_ang(face_norm[2]);
      float Beta = 180 - atan2_ang(face_norm[0], face_norm[1]);

      float[] VECT = {
        0, 0, 0
      }; 

      if (abs(Alpha) > 89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = 1;
      } else if (Alpha < -89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = -1;
      } else {
        VECT[0] = sin_ang(Beta);
        VECT[1] = -cos_ang(Beta);
        VECT[2] = tan_ang(Alpha);
      }   
      
      VECT = SOLARCHVISION_fn_normalize(VECT);
      
      {
        
        for (int n_Ray = 0; n_Ray < DiffuseVectors.length; n_Ray++) { 
  
          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];
          
          ray_direction[0] = DiffuseVectors[n_Ray][0];
          ray_direction[1] = DiffuseVectors[n_Ray][1];
          ray_direction[2] = DiffuseVectors[n_Ray][2];
    
          float SkyMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(DiffuseVectors[n_Ray]), SOLARCHVISION_fn_normalize(VECT));
          //if (SkyMask <= 0) SkyMask = 0; // removes backing faces
         
          // when SHD = 0;
          Diffuse_Matrix[0][np] += SkyMask / float(DiffuseVectors.length);
         
          lastHitDiffuse[n_Ray] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDiffuse[n_Ray]);
            
          // when SHD = 1;            
          if (lastHitDiffuse[n_Ray] == 0) {
            Diffuse_Matrix[1][np] += SkyMask / float(DiffuseVectors.length);
          }
          else Diffuse_Matrix[1][np] += 0;   
        }
      }      

      
      n_Map = -1; 
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
        
        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
          n_Map += 1; 
          
          float HOUR_ANGLE = i;
    
          float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

          float[] DirectVector = {
            SunR[1], SunR[2], SunR[3]
          };

          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];
          
          ray_direction[0] = DirectVector[0];
          ray_direction[1] = DirectVector[1];
          ray_direction[2] = DirectVector[2];

          float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(DirectVector), SOLARCHVISION_fn_normalize(VECT));
          //if (SunMask <= 0) SunMask = 0; // removes backing faces 

          // when SHD = 0;
          Direct_RGBA[n_Map][0].pixels[np] = color(255 * SunMask, 255);
            
          // when SHD = 1;            
          
          lastHitDirect[n_Map] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDirect[n_Map]);
          
          if (lastHitDirect[n_Map] == 0) { 
            Direct_RGBA[n_Map][1].pixels[np] = color(255 * SunMask, 255);
          }
          else Direct_RGBA[n_Map][1].pixels[np] = color(0, 255);
        }
      }
    }
    else {
      
      n_Map = -1; 
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
        
        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
          n_Map += 1; 
          
          for (int SHD = 0; SHD <= 1; SHD++) {
    
            Direct_RGBA[n_Map][SHD].pixels[np] = color(0,0,0,0);
          
          }
        }
      }     

      for (int SHD = 0; SHD <= 1; SHD++) {

        Diffuse_Matrix[SHD][np] = FLOAT_undefined;
      
      }     
      
    }
    
  }
  
  println("Progress: 100 %");
  
  n_Map = -1; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1; 

      float HOUR_ANGLE = i;

      for (int SHD = 0; SHD <= 1; SHD++) {

        String[] STR_SHD = {
          "F", "T"
        };
        String File_Name = ShadingFolder + "/" + NearLatitude_Stamp() + "/" + SceneName;
  
        File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
  
        File_Name += "_Camera" + nf(Camera_Variation, 2);
  
        Direct_RGBA[n_Map][SHD].updatePixels();
        
        Direct_RGBA[n_Map][SHD].save(File_Name + ".PNG");
        
        println(File_Name + ".PNG");
      }
    }
  }  

  PImage[] Diffuse_RGBA = new PImage [2];

  for (int SHD = 0; SHD <= 1; SHD++) {
    
    String[] STR_SHD = {
      "F", "T"
    };
    String File_Name = ShadingFolder + "/" + NearLatitude_Stamp() + "/" + SceneName;

    File_Name += "DIF_" + STR_SHD[SHD];
    
    File_Name += "_Camera" + nf(Camera_Variation, 2);
    
    Diffuse_RGBA[SHD] = createImage(RES1, RES2, ARGB); 
    
    Diffuse_RGBA[SHD].loadPixels();

    for (int np = 0; np < (RES1 * RES2); np++) {
      
      if (is_undefined_FLOAT(Diffuse_Matrix[SHD][np]) == false) {
      
        Diffuse_RGBA[SHD].pixels[np] = color(255 * Diffuse_Matrix[SHD][np], 255);
      }
      else {
        
        Diffuse_RGBA[SHD].pixels[np] = color(0,0,0,0);
      }
    }    

    Diffuse_RGBA[SHD].updatePixels();
    
    
    Diffuse_RGBA[SHD].save(File_Name + ".PNG");
    
    println(File_Name + ".PNG");    
  }       



  cursor(ARROW);
  
  WIN3D.dX = pre_WIN3D_dX;
  WIN3D.dY = pre_WIN3D_dY;
  WIN3D.R_View = float(WIN3D.dY) / float(WIN3D.dX);
}






void SOLARCHVISION_RenderViewport () {

  println("Render started!");
  
  int PAL_TYPE = 0; 
  int PAL_DIR = 1;
  float PAL_Multiplier = 1;   

  if (Impact_TYPE == Impact_ACTIVE) {
    PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
    PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR; 
    PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
  }
  if (Impact_TYPE == Impact_PASSIVE) {  
    PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
    PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
    PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
  }     

  
  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;
  
  PImage Image_RGBA = createImage(RES1, RES2, ARGB);

  Image_RGBA.loadPixels();

  float Progress = 0;

   


  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;

    if (1 + Progress < 100 * np / float(RES1 * RES2)) { 
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];



         
  
    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);

    if (RxP[0] >= 0) {        
        
      int f = int(RxP[0]);


      float[] COL = {
        0, 0, 0, 0
      };
      
      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = SOLARCHVISION_fn_normalize(face_norm);
      
      if (SOLARCHVISION_fn_dot(face_norm, ray_direction) > 0) { // to render backing faces 
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }

      
      float Alpha = 90 - acos_ang(face_norm[2]);
      float Beta = 180 - atan2_ang(face_norm[0], face_norm[1]);

float _valuesSUM_RAD = 0;
float _valuesSUM_EFF_P = 0;
float _valuesSUM_EFF_N = 0;
int _valuesNUM = 0; 

float _values_R_dir = 1;
float _values_R_dif = 1;
float _values_E_dir = 0.1;
float _values_E_dif = 0.1;


//float[] SunR = SOLARCHVISION_SunPositionRadiation( DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);
float[] SunR = SOLARCHVISION_SunPositionRadiation(0, 12, 0);
float[] VECT = {
  0, 0, 0
}; 

if (abs(Alpha) > 89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = 1;
} else if (Alpha < -89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = -1;
} else {
  VECT[0] = sin_ang(Beta);
  VECT[1] = -cos_ang(Beta);
  VECT[2] = tan_ang(Alpha);
}   

VECT = SOLARCHVISION_fn_normalize(VECT);


float[] SunV = {
  SunR[1], SunR[2], SunR[3]
};

float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
if (SunMask <= 0) SunMask = 0; // removes backing faces 

float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));


// new trace
ray_start[0] = RxP[1];
ray_start[1] = RxP[2];
ray_start[2] = RxP[3];

ray_direction[0] = SunV[0];
ray_direction[1] = SunV[1];
ray_direction[2] = SunV[2];

//if (SOLARCHVISION_fn_dot(face_norm, ray_direction) > 0) 
{ // removes backing faces

  if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) { 
    if (_values_E_dir < 0) {
      _valuesSUM_EFF_P += -(_values_E_dir * SunMask); 
      _valuesSUM_EFF_N += -(_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    } else {
      _valuesSUM_EFF_N += (_values_E_dir * SunMask); 
      _valuesSUM_EFF_P += (_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    }

    _valuesSUM_RAD += (_values_R_dif * SkyMask); // only approximate diffuse radiation!
  } else { 
    if (_values_E_dir < 0) {
      _valuesSUM_EFF_N += -((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
    } else {
      _valuesSUM_EFF_P += ((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
    }

    _valuesSUM_RAD += ((_values_R_dir * SunMask) + (_values_R_dif * SkyMask)); // calculates total radiation
  }
}
_valuesNUM += 1;

//-----------------------------
float _valuesSUM = _valuesSUM_RAD; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//-----------------------------
      
      float _u = 0;
    
      if (is_undefined_FLOAT(_valuesSUM) == false) {
    
        if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
    
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;
      }
    
      COL = PAINT.getColorStyle(PAL_TYPE, _u);

      
      Image_RGBA.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
    }
    
    else Image_RGBA.pixels[np] = color(0,0,0,0);
  }

  Image_RGBA.updatePixels();
 
  String myFile = ScreenShotFolder + "/" + CreateStamp(1) + "Render.png";
  Image_RGBA.save(myFile);
  SOLARCHVISION_explore_output(myFile);
  println("File created:" + myFile);
  
}





float[][] DiffuseVectors;  

void SOLARCHVISION_build_SkySphere (int Tessellation) {

  //allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0,0,0, 1, Tessellation, 1, 90); // SKY
  //allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 4, 1, 90); // SKY
  allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1, 90); // SKY

  DiffuseVectors = new float[0][3];

  for (int i = 0; i < skyFaces.length; i++) {

    float x = 0;
    float y = 0;
    float z = 0;

    for (int j = 0; j < skyFaces[i].length; j++) {

      x += skyVertices[skyFaces[i][j]][0] / float(skyFaces[i].length);
      y += skyVertices[skyFaces[i][j]][1] / float(skyFaces[i].length);
      z += skyVertices[skyFaces[i][j]][2] / float(skyFaces[i].length);
      
      if (z > 0) {
        float[][] new_Vector = {{x, y, z}};
        DiffuseVectors = (float[][]) concat(DiffuseVectors, new_Vector);
      }      
    }
  }

}






void setFlag_CurrentDataSource (int i, int j, int k, int Parameter_ID, boolean flag) { 
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_flags[i][j][Parameter_ID][k] = flag; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_flags[i][j][Parameter_ID][k] = flag; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_flags[i][j][Parameter_ID][k] = flag; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_flags[i][j][Parameter_ID][k] = flag; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_flags[i][j][Parameter_ID][k] = flag; 
  }   

}  

void setValue_CurrentDataSource (int i, int j, int k, int Parameter_ID, float value) { 
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_values[i][j][Parameter_ID][k] = value; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_values[i][j][Parameter_ID][k] = value; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_values[i][j][Parameter_ID][k] = value; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k] = value; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k] = value; 
  }   

}  


float getValue_CurrentDataSource (int i, int j, int k, int Parameter_ID) { 
  
  float return_value = FLOAT_undefined;
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_values[i][j][Parameter_ID][k]; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_values[i][j][Parameter_ID][k]; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_values[i][j][Parameter_ID][k]; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k]; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k]; 
  }   

  return return_value;
}  


int getStart_CurrentDataSource () {
  
  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_start;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_start;
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_start;
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_start;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_start;
  }
  
  return return_value;
}

int getEnd_CurrentDataSource () {
  
  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_end;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_end;
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_end;
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_end;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_end;
  }
  
  return return_value;
}

String getReference_CurrentDataSource () {
  
  String return_value = "";

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = STATION.getFilename_CWEEDS() + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/";
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value  = "Environment and Climate Change Canada website at http://climate.weather.gc.ca/climate_data";
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = STATION.getFilename_TMYEPW() + ".epw";
  }    
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = nf(TIME_Year, 4) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + nf(TIME_Hour, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + CurrentLayer_name + "_000-384.xml" + ", Environment and Climate Change Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/";
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = "Environment and Climate Change Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/";
  }
  
  return return_value;
}  



void SOLARCHVISION_setDataFlags (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();
  // setting the flags
  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
          if (is_undefined_FLOAT(getValue_CurrentDataSource(i, j, k, l)) == false) {
            setFlag_CurrentDataSource(i, j, k, l, true);
          }
        }
      }
    }
  }  
  
  CurrentDataSource = keep_CurrentDataSource;
}

void SOLARCHVISION_postProcess_fillGaps (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  

  for (int l = 0; l < numberOfLayers; l++) {

    for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
      float pre_v = FLOAT_undefined;
      int pre_num = 0;

      for (int j = 0; j < 365; j++) { 

        for (int i = 0; i < 24; i++) {
          
          if (is_undefined_FLOAT(getValue_CurrentDataSource(i, j, k, l))) {
            if (is_undefined_FLOAT(pre_v) == false) {
              pre_num += 1;

              float next_v = FLOAT_undefined;
              int next_i = i;
              int next_j = j;
              int next_num = 0;
              while ((next_num < MAX_SEARCH) && (is_undefined_FLOAT(next_v))) {
                next_num += 1;
                next_i += 1;
                if (next_i == 24) {
                  next_i -= 24;
                  next_j += 1;
                }
                if (next_j == 365) {
                  next_j = 0;
                }
                if (is_undefined_FLOAT(getValue_CurrentDataSource(next_i, next_j, k, l)) == false) {
                  next_v = getValue_CurrentDataSource(next_i, next_j, k, l);

                  if (l == LAYER_winddir.id) {
                    if ((next_v - pre_v) > 180) next_v -= 360;
                    if ((next_v - pre_v) < -180) next_v += 360;
                  }
                }
              }
              if (next_num < MAX_SEARCH) {
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360);
                else setValue_CurrentDataSource(i, j, k, l, (next_num * pre_v + pre_num * next_v) / (pre_num + next_num));

                float interpolation_pow = pow(2.0, Interpolation_Weight);

                setValue_CurrentDataSource(i, j, k, l, (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow)));
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, (getValue_CurrentDataSource(i, j, k, l) + 360) % 360);
              }
            }
          } else {
            pre_v = getValue_CurrentDataSource(i, j, k, l);
            pre_num = 0;
          }

        }
      }

    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}






void SOLARCHVISION_postProcess_solarsUsingCloud (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
    for (int j = 0; j < 365; j++) { 
      for (int i = 0; i < 24; i++) {
        
        float CL = getValue_CurrentDataSource(i, j, k, LAYER_cloudcover.id);
        
        if (is_undefined_FLOAT(CL) == false) {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, CL);

          setValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id, SunR[4]);

          setValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id, SunR[5]);

          setValue_CurrentDataSource(i, j, k, LAYER_glohorrad.id, SunR[4] * SunR[3] + SunR[5]);
        }
          
      }
    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_solarEffects (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();


  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
        
        float T     = getValue_CurrentDataSource(i, j, k, LAYER_drybulb.id);
        float R_dir = getValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id);
        float R_dif = getValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id);

        if ((is_undefined_FLOAT(T) == false) && (is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) {

          setValue_CurrentDataSource(i, j, k, LAYER_direffect.id, (18 - T) * R_dir);
          setValue_CurrentDataSource(i, j, k, LAYER_difeffect.id, (18 - T) * R_dif);

        }
      }
    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_climaticSolarForecast () {

  int num_count = (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start);

  for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
    for (int j_for = 0; j_for < ENSEMBLE_FORECAST_maxDays; j_for++) { 
      int j = ((j_for + TIME_BeginDay) % 365);
      for (int i = 0; i < 24; i++) {
        if (is_undefined_FLOAT(ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k])) {
        } else {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);

          ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = SunR[4];

          ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = SunR[5];

          ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = SunR[4] * SunR[3] + SunR[5];

          //---------------------------------------------------------------------

          float Forecast_CC = ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k];
          float Forecast_AP = ENSEMBLE_FORECAST_values[i][j][LAYER_pressure.id][k];

          float CC_epsilon = 1.0; // defines a range for finding near previous results: 1.0 results in e.g. 2 < CC < 4 for CC at 3  
          float AP_epsilon = 50.0;

          float _valuesSUM_DIR = 0;
          float _valuesSUM_DIF = 0;
          float _valuesSUM_GLO = 0;
          float sum_count = 0;

          float process_add_days = 11;

          for (int q = 0; q < num_count; q++) {

            for (int j_ADD = 0; j_ADD < process_add_days; j_ADD++) { 

              int now_i = i;
              int now_j = int(j + (j_ADD - int(0.5 * process_add_days)) + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }


              if ((is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q])) || (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]))) {
              } else {
                float CC_dist = abs(Forecast_CC - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q]);
                float AP_dist = abs(Forecast_AP - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]);
                if ((CC_dist < CC_epsilon) && (AP_dist < AP_epsilon)) {

                  float _weight;

                  _weight = 1; 
                  _weight *= pow(abs(1 - pow(CC_dist/CC_epsilon, 2)), 2); // to add more wights to closer cases
                  _weight *= pow(abs(1 - pow(AP_dist/AP_epsilon, 2)), 2);

                  sum_count += _weight;

                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q])) {
                  } else _valuesSUM_DIR += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q]; 
                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q])) {
                  } else _valuesSUM_DIF += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q]; 
                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q])) {
                  } else _valuesSUM_GLO += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q];
                }
              }
            }
          }

          if (sum_count != 0) {
            _valuesSUM_DIR /= sum_count;
            _valuesSUM_DIF /= sum_count;
            _valuesSUM_GLO /= sum_count;

            ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = _valuesSUM_DIR;
            ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = _valuesSUM_DIF;
            ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = _valuesSUM_GLO;
          } else {
            println("Cannot find simillar conditions in climate file at i:", i, ", j:", j, ", k:", k);
          }

        }
      }
    }
  }
}




void SOLARCHVISION_postProcess_developDATA (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;  
  
  float keep_STUDY_PerDays = STUDY.PerDays;
  int keep_STUDY_JoinDays = STUDY.JoinDays;
  
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.PerDays = 1;
    STUDY.JoinDays = 1;
  }

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();
  
  int count_k = 1 + DATA_end - DATA_start; 
  if (count_k > 0) {
  
    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float RAIN, T, WS, R_dir, R_dif;
  
    float[] _valuesSUM; 
    _valuesSUM = new float [count_k];
  
    for (int k = 0; k < count_k; k++) {
      _valuesSUM[k] = FLOAT_undefined;
    }
  
    for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) { 
      for (int j_ADD = 0; j_ADD < STUDY.JoinDays; j_ADD++) {
        for (int k = 0; k < count_k; k++) {
          for (int i = 0; i < 24; i++) {
  
            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY.PerDays + (j_ADD - int(roundTo(0.5 * STUDY.JoinDays, 1))) + TIME_BeginDay + 365) % 365;
  
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }
  
            int next_i = now_i + 12;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i >= 24) {
              next_i = next_i - 24; 
              next_j += 1; 
              if (next_j >= 365) {
                next_j = next_j % 365;
              }
            }
  
  
            int pre_i = now_i - 12;
            int pre_j = now_j;
            int pre_k = now_k;
            if (pre_i < 0) {
              pre_i = pre_i + 24; 
              pre_j -= 1; 
              if (pre_j < 0) {
                pre_j = (pre_j + 365) % 365;
              }
            }       

  
            setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, FLOAT_undefined);
  
            T = FLOAT_undefined;
            R_dir = FLOAT_undefined;
            R_dif = FLOAT_undefined;
  
            if ((i == 0) && (j == STUDY.j_Start)) _valuesSUM[now_k] = 0; 
  
  
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
            
            if (is_undefined_FLOAT(Pa)) {
              R_dir = FLOAT_undefined;
            } else {
              R_dir = Pa;
            }
            
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
            
            if (is_undefined_FLOAT(Pa)) {
              R_dif = FLOAT_undefined;
            } else {
              R_dif = Pa;
            }
            
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);
            
            if (is_undefined_FLOAT(Pa)) {
              T = FLOAT_undefined;
            } else {
              T = Pa;
            }
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
            
            if (is_undefined_FLOAT(Pa)) {
              WS = FLOAT_undefined;
            } else {
              WS = Pa;
            }        
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_precipitation.id);
            Pb = getValue_CurrentDataSource(next_i, next_j, now_k, LAYER_precipitation.id);
            
            if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb))) {
              RAIN = FLOAT_undefined;
            } else {
              RAIN = Pb - Pa;
              //RAIN = Pa - Pb;
  
              if (T <= 0) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Lewis
              //if ((T < 5) && (T > -5)) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Mojtaba
            }    
  
  
            float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);
            float HOUR_ANGLE = now_i; 
  
            float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
  
  
  
  
  
            if (Develop_Option == DEV_OP_00) {  
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                if (Materials_DirectArea_Flags[now_i][now_j] == -1) {
                  _valuesSUM[now_k] = FLOAT_undefined;
                } else {
                  _valuesSUM[now_k] = 0.001 * (R_dir * Materials_DirectArea_Data[Materials_Selection][now_i][now_j] + R_dif * Materials_DiffuseArea_Data[Materials_Selection][now_i][now_j]);
                }
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.5;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "KW";
              LAYER_developed.descriptions[Language_EN] = "Direct radiation on surfaces with material #" + String.valueOf(Materials_Selection);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }         
  
  
            if (Develop_Option == DEV_OP_01) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;
  
  
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                _valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_02) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                _valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * _valuesSUM[now_k]);
              }
  
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_03) {
              float Alpha = asin_ang(SunR[3]);
              float Beta = atan2_ang(SunR[2], SunR[1]) + 90;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                _valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }         
  
            if (Develop_Option == DEV_OP_04) {
              float Alpha = asin_ang(SunR[3]);
              float Beta = atan2_ang(SunR[2], SunR[1]) + 90;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                _valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_05) {
  
              if (is_undefined_FLOAT(T) == false) { 
                _valuesSUM[now_k] += (T - 18) / 24;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 1.0;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = -1;
              LAYER_developed.unit = "°C";
              LAYER_developed.descriptions[Language_EN] = "Accumulated degree day (based on 18°C)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_06) {
  
              _valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = 1; _count <= num_count; _count++) {
  
                int plus_i = - (_count - 1);
  
                int new_k = k;
                int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }
  
                float T_new = FLOAT_undefined;
  
                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                if (is_undefined_FLOAT(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }            
  
                if (is_undefined_FLOAT(T_new) == false) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  _valuesSUM[now_k] += _weight * T_new;
                }
              } 
  
              if (sum_count != 0) {
                _valuesSUM[now_k] /= sum_count;
              } else {
                _valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
  
              _valuesSUM[now_k] = 0;
  
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }     
  
  
            if (Develop_Option == DEV_OP_07) {
  
              _valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = 1; _count <= ceil ( (num_count + 1) / 2); _count++) {
                for (int dir_count = -1; dir_count <= 1; dir_count += 2) {
  
                  int plus_i = dir_count * (_count - 1);
  
                  int new_k = k;
                  int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                  int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                  if (new_j >= 365) {
                    new_j = new_j % 365;
                  }
                  if (now_j < 0) {
                    new_j = (new_j + 365) % 365;
                  }
  
                  float T_new = FLOAT_undefined;
                  
                  Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                  if (is_undefined_FLOAT(Pa)) {
                    T_new = FLOAT_undefined;
                  } else {
                    T_new = Pa;
                  }            
  
                  if (is_undefined_FLOAT(T_new) == false) {
                    float _weight = (num_count - _count + 1);
                    if (STUDY.TrendJoinType == 1) _weight = 1;
                    sum_count += _weight;
                    _valuesSUM[now_k] += _weight * T_new;
                  }
                }
              } 
  
              if (sum_count != 0) {
                _valuesSUM[now_k] /= sum_count;
              } else {
                _valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
  
              _valuesSUM[now_k] = 0;
  
  
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }           
  
            if (Develop_Option == DEV_OP_08) {
  
              _valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = num_count; _count > 0; _count--) {
  
                int plus_i = _count - 1;
  
                int new_k = k;
                int new_i = ((i + plus_i) + 24 * floor((i + plus_i) / 24.0)) % 24;
                int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }
  
                float T_new = FLOAT_undefined;
  
                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                if (is_undefined_FLOAT(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }            
  
                if (is_undefined_FLOAT(T_new) == false) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  _valuesSUM[now_k] += _weight * T_new;
                }
              } 
  
              if (sum_count != 0) {
                _valuesSUM[now_k] /= sum_count;
              } else {
                _valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
  
              _valuesSUM[now_k] = 0;
  
 
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_09) {
  
              if (is_undefined_FLOAT(RAIN) == false) { 
                _valuesSUM[now_k] = RAIN;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = 0; //-20.0 / (1.0 * STUDY.LevelPix); // so that we can have two views on probabilites above and below zero.
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/12hours";
              LAYER_developed.descriptions[Language_EN] = "12-hour Surface Accumulated Precipitation";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_10) {
  
              if (is_undefined_FLOAT(RAIN) == false) { 
                _valuesSUM[now_k] = RAIN;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.0; //4.0;
              LAYER_developed.V_offset = 0; 
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/h";
              LAYER_developed.descriptions[Language_EN] = "Hourly Surface Precipitation (interpolated)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_11) {
  
              if (is_undefined_FLOAT(WS) == false) { 
  
                _valuesSUM[now_k] = 0.5 * 1.23 * 1 * pow(WS / 3.6, 3); 
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.05;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Wind power";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }    
  
  
  
  
  
  
            if ((Develop_Option == DEV_OP_02) || (Develop_Option == DEV_OP_04)) {
  
              if ((i == 23) && (Develop_DayHour == 1)) {
                for (int l = i + 1 - 24; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
                }
                //STUDY.SumInterval = 24;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/day";
  
                _valuesSUM[now_k] = 0;
              }
  
              if (((i == 11) || (i == 23)) && (Develop_DayHour == 2)) {
                for (int l = i + 1 - 12; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
                }
                //STUDY.SumInterval = 12;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/12hours";
  
                _valuesSUM[now_k] = 0;
              }   
  
              if (((i == 5) || (i == 11) || (i == 17) || (i == 23)) && (Develop_DayHour == 3)) {
                for (int l = i + 1 - 6; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, _valuesSUM[now_k]);
                }
                //STUDY.SumInterval = 6;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/6hours";
  
                _valuesSUM[now_k] = 0;
              }
            }
          }
        }
      }
    }
  }
  
  println("developDATA updated!");

  DevelopData_update = false;  

  STUDY.PerDays = keep_STUDY_PerDays;
  STUDY.JoinDays = keep_STUDY_JoinDays;
 
  CurrentDataSource = keep_CurrentDataSource; 
}






