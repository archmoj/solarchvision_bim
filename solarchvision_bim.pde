import processing.pdf.*;

String SceneName = "";

String SOLARCHVISION_version = "2026";
String BaseFolder = "/home/solarch/org/solarchvision_bim";

String RunStamp = nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
String ProjectName = "Revision_" + RunStamp;
String HoldStamp = "";

String Subfolder_exportMaps = "maps/";


class solarchvision_STATION {

  private final static String CLASS_STAMP = "STATION";

  private float elevation = 0;
  private float latitude = 0;
  private float longitude = 0;
  private float timelong = 0;
  private String code = "";
  private String city = "";
  private String province = "";
  private String country = "";
  private String filename_NAEFS = "";
  private String filename_CWEEDS = "";
  private String filename_TMYEPW = "";


  public float getElevation () { return this.elevation; }
  public float getLatitude () { return this.latitude; }
  public float getLongitude () { return this.longitude; }
  public float getTimelong () { return this.timelong; }
  public String getCode () { return this.code; }
  public String getCity () { return this.city; }
  public String getProvince () { return this.province; }
  public String getCountry () { return this.country; }
  public String getFilename_NAEFS () { return this.filename_NAEFS; }
  public String getFilename_CWEEDS () { return this.filename_CWEEDS; }
  public String getFilename_TMYEPW () { return this.filename_TMYEPW; }


  public void setElevation (float elevation) {
    this.elevation = elevation;
  }
  public void setLatitude (float latitude) {
    this.latitude = latitude;
  }
  public void setLongitude (float longitude) {
    this.longitude = longitude;
  }
  public void setTimelong (float timelong) {
    this.timelong = timelong;
  }
  public void setCode (String code) {
    this.code = code;
  }
  public void setCity (String city) {
    this.city = city;
  }
  public void setProvince (String province) {
    this.province = province;
  }
  public void setCountry (String country) {
    this.country = country;
  }
  public void setFilename_NAEFS (String filename_NAEFS) {
    this.filename_NAEFS = filename_NAEFS;
  }
  public void setFilename_CWEEDS (String filename_CWEEDS) {
    this.filename_CWEEDS = filename_CWEEDS;
  }
  public void setFilename_TMYEPW (String filename_TMYEPW) {
    this.filename_TMYEPW = filename_TMYEPW;
  }

  public solarchvision_STATION () {

  }

  public solarchvision_STATION (String code, String city, String province, String country,
                         float latitude, float longitude, float timelong, float elevation,
                         String filename_NAEFS, String filename_CWEEDS, String filename_TMYEPW) {

    this.code = code;
    this.city = city;
    this.province = province;
    this.country = country;

    this.filename_NAEFS = filename_NAEFS;
    this.filename_CWEEDS = filename_CWEEDS;
    this.filename_TMYEPW = filename_TMYEPW;

    this.elevation = elevation;
    this.latitude = latitude;
    this.longitude = longitude;
    this.timelong = timelong;
  }


  public void to_XML (XML xml) {

    XML child = xml.addChild(this.CLASS_STAMP);

    XML_setString(child, "code", this.getCode());
    XML_setString(child, "city", this.getCity());
    XML_setString(child, "province", this.getProvince());
    XML_setString(child, "country", this.getCountry());

    XML_setFloat(child, "elevation", this.getElevation());
    XML_setFloat(child, "latitude", this.getLatitude());
    XML_setFloat(child, "longitude", this.getLongitude());
    XML_setFloat(child, "timelong", this.getTimelong());

    XML_setString(child, "filename_NAEFS", this.getFilename_NAEFS());
    XML_setString(child, "filename_CWEEDS", this.getFilename_CWEEDS());
    XML_setString(child, "filename_TMYEPW", this.getFilename_TMYEPW());
  }


  public void from_XML (XML xml) {

    XML child = xml.getChild(this.CLASS_STAMP);

    this.setCode(XML_getString(child, "code"));
    this.setCity(XML_getString(child, "city"));
    this.setProvince(XML_getString(child, "province"));
    this.setCountry(XML_getString(child, "country"));

    this.setElevation(XML_getFloat(child, "elevation"));
    this.setLatitude(XML_getFloat(child, "latitude"));
    this.setLongitude(XML_getFloat(child, "longitude"));
    this.setTimelong(XML_getFloat(child, "timelong"));

    this.setFilename_NAEFS(XML_getString(child, "filename_NAEFS"));
    this.setFilename_CWEEDS(XML_getString(child, "filename_CWEEDS"));
    this.setFilename_TMYEPW(XML_getString(child, "filename_TMYEPW"));
  }
}

solarchvision_STATION STATION = new solarchvision_STATION(
  //"", "Montreal", "QC", "CA", 45.47, -73.75, -75, 36, "MONTREAL_DORVAL_QC_CA", "CAN_QC_MONTREAL-INTL-A_7025251_CWEEDS2011_1998-2017", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"
  "", "Toronto", "ON", "CA", 43.67, -79.63, -75, 173, "TORONTO_PEARSON_INTL_ON_CA", "CAN_ON_TORONTO-INTL-A_6158731_CWEEDS2011_1998-2017", "CAN_ON_Toronto.716240_CWEC"
  //"", "Vancouver", "BC", "CA", 49.18, -123.17, -120, 2, "VANCOUVER_INTL_BC_CA", "CAN_BC_VANCOUVER-INTL-A_1108395_CWEEDS2011_1998-2017", "CAN_BC_Vancouver.718920_CWEC"
);

class solarchvision_OBJECTTYPE {

  private final static String CLASS_STAMP = "OBJECTTYPE";

  private final static int LANDPOINT = 0;
  private final static int MODEL1D = 1;
  private final static int MODEL2D = 2;
  private final static int GROUP = 3;
  private final static int FACE = 4;
  private final static int VERTEX = 5;
  private final static int SOFTVERTEX = 6;
  private final static int SOLID = 7;
  private final static int SECTION = 8;
  private final static int CAMERA = 9;
  private final static int CURVE = 10;

}

solarchvision_OBJECTTYPE ObjectCategory = new solarchvision_OBJECTTYPE();


class solarchvision_WINDOWTYPE {

  private final static String CLASS_STAMP = "WINDOWTYPE";

  private final static int SKY2D    = -2;
  private final static int LandGap  = -1;
  private final static int LandMesh = 0;
  private final static int STUDY    = 1;
  private final static int WORLD    = 2;
  private final static int WIN3D    = 3;
  private final static int OBJ3D    = 4;
  private final static int RAD3D    = 5;
  private final static int HTML     = 6;
  private final static int SHADOW   = 7;

}

solarchvision_WINDOWTYPE TypeWindow = new solarchvision_WINDOWTYPE();



class solarchvision_CREATE {

  private final static String CLASS_STAMP = "CREATE";

  private final static int Nothing    = 0;
  private final static int Plane      = 1;
  private final static int Poly       = 2;
  private final static int Extrude    = 3;
  private final static int Tri        = 4;
  private final static int Hyper      = 5;
  private final static int House1     = 6;
  private final static int House2     = 7;
  private final static int House3     = 8;
  private final static int SuperOBJ   = 9;
  private final static int Parametric = 10;
  private final static int Person     = 11;
  private final static int Plant      = 12;
  private final static int Model1Ds   = 13;
  private final static int Face       = 14;
  private final static int Vertex     = 15;
  private final static int Curve      = 16;
  private final static int Solid      = 17;
  private final static int Section    = 18;
  private final static int Camera     = 19;

}

solarchvision_CREATE CREATE = new solarchvision_CREATE();


int CreateObject = CREATE.Nothing;

int current_ObjectCategory = ObjectCategory.GROUP;

int current_Material = 7;
int current_Tessellation = 0;
int current_Layer = 0;
int current_Visibility = 1;
int current_Weight = 0;
int current_Closed = 0;


class solarchvision_DATATYPE {

  private final static String CLASS_STAMP = "DATATYPE";

  private final static int SATELLITE_GOES = 0;
  private final static int FORECAST_HRDPS = 1;
  private final static int FORECAST_RDPS  = 2;
  private final static int FORECAST_GDPS  = 3;

}

solarchvision_DATATYPE DataType = new solarchvision_DATATYPE();


int WMS_type = DataType.FORECAST_GDPS; // <<<<<<<<<<<<<

final int TROPO_deltaTime = 1;
final int TROPO_timeSteps = 24;




float Interpolation_Weight = 0.5;// 0 = linear distance interpolation, 1 = square distance interpolation, 5 = nearest

final int Impact_ACTIVE = 0; // internal
final int Impact_PASSIVE = 1; // internal
final int numberOfImpactVariations = 2; // internal

int Impact_TYPE = Impact_PASSIVE;

final int PlotImpacts_CYCLES_ACTIVE = 0;
final int PlotImpacts_CYCLES_PASSIVE = 1;
final int PlotImpacts_SUNPATH_ACTIVE = 2;
final int PlotImpacts_SUNPATH_PASSIVE = 3;
final int PlotImpacts_GLOBAL_ACTIVE = 4;
final int PlotImpacts_GLOBAL_PASSIVE = 5;
final int PlotImpacts_WIND_ACTIVE = 6;
final int PlotImpacts_WIND_PASSIVE = 7;
final int PlotImpacts_URBAN_ACTIVE = 8;
final int PlotImpacts_URBAN_PASSIVE = 9;
final int PlotImpacts_FROMSUN_ACTIVE = 10;
final int PlotImpacts_FROMSUN_PASSIVE = 11;


float CubePower = 16; //8;
float StarPower = 0.25;

final float FLOAT_e = 2.7182818284;

final double DOUBLE_r_Earth = 6367470.0; //6373000.0;
final float FLOAT_r_Earth = (float) DOUBLE_r_Earth;

float CrustDepth = 1000; // 1000m .The actual crust ranges from 5–70 km

float EyeLevel = 1.5; // 1.5 abouve ground - applied for setting cameras - intrenal!

float GlobalAlbedo = 0; // 0-100

float BIOSPHERE_drawResolution = 5.0; //2.5; // 5: 5 degrees

float Planetary_Magnification = 4.0; // <<<<<<<<<<


boolean FRAME_record_AUTO = false;
boolean FRAME_record_IMG = false;
boolean FRAME_click_IMG = false;
boolean FRAME_drag_IMG = false;


//-------------------------------


int CLIMATIC_SolarForecast = 0; //                                   Used for solar radiation only
int CLIMATIC_WeatherForecast = 0; // 0:linear 1:average 2:sky-based. Used for some parameters namely: air temperature, humidity

int SOLARCHVISION_automated = 0; //0: User interface, 1: Automatic

int SOLARCHVISION_pixel_H = 400;
int SOLARCHVISION_pixel_W = 724;

float MessageSize = 16.0;
int SOLARCHVISION_pixel_A = 24; // menu bar
int SOLARCHVISION_pixel_B = 44; // 3D tool bar
int SOLARCHVISION_pixel_C = 72; // time bar
int SOLARCHVISION_pixel_D = 72; // command bar

String[] skyScenario_Title = {
  "", "All data", "Cloudy\nPattern", "Partly Cloudy\nPattern", "Sunny\nPattern"
};
String[] skyScenario_FileTXT = {
  "", "", "Overcast sky", "Scattered sky", "Clear sky"
};

final int filter_HOURLY = 0;
final int filter_DAILY = 1;

int IMPACTS_displayDay = 0; // 0:total 1:day-1 2:day-2 etc.

final int numberOfLanguages = 2;
final int Language_EN = 0;
final int Language_FR = 1;
int Language_Active = Language_EN;


final float FLOAT_huge = 1000000000;
final float FLOAT_tiny = 0.05; // don't use very tiny values that could result is shading problems at the intersection of faces

final String STRING_undefined = "N/A";
final float FLOAT_undefined = 2000000000; // it must be a positive big number that is not included in any data
final float FLOAT_max_defined = 0.95 * FLOAT_undefined;

boolean is_defined (float a) {
  if (a < FLOAT_max_defined) {
    return true;
  }
  return false;
}

boolean is_undefined (float a) {
  return !is_defined(a);
}


PrintWriter[] FILE_outputRaw;
PrintWriter[] FILE_outputNorms;
PrintWriter[] FILE_outputProbs;

String[] Files_CLIMATE_TMYEPW;
String[] Files_CLIMATE_CWEEDS;
String[] Files_CLIMATE_CLMREC;
String[] Files_ENSEMBLE_OBSERVED;
String[] Files_ENSEMBLE_FORECAST;

String Folder_CLIMATE_TMYEPW;
String Folder_CLIMATE_CWEEDS;
String Folder_CLIMATE_CLMREC;
String Folder_ENSEMBLE_OBSERVED;
String Folder_ENSEMBLE_FORECAST;
String Folder_GRIB2;
String Folder_GEOMET;

String Folder_Wgrib2Temp;

String Folder_Coordinates;

String Folder_Land;
String Folder_People;
String Folder_Trees;
String Folder_Export;
String Folder_Project;
String Folder_Graphics;
String Folder_Export3D;
String Folder_ViewsFromSky;
String Folder_ScreenShots;
String Folder_Shadings;





class solarchvision_OperatingSystem {

  private final static String CLASS_STAMP = "OperatingSystem";

  String[] getFiles (String _Folder) {
    //println(_Folder);
    String[] filenames = new String[0];
    File dir = new File(_Folder);
    if (dir.exists() && dir.isDirectory()) {
      filenames = concat(filenames, dir.list());
      if (filenames != null) {
        for (int i = 0; i < filenames.length; i++) {
          //println(filenames[i]);
        }
      }
    }
    return filenames;
  }

  String getFilenameFromPath (String path) {
    File file = new File(path);
    return split(file.getName(),'.')[0]; // using the first text before dot
  }
}
solarchvision_OperatingSystem OPESYS = new solarchvision_OperatingSystem();



class solarchvision_TIME {

  private final static String CLASS_STAMP = "TIME";

  private int modelRun = 0; //12;

  private int hour = this.modelRun; //hour();
  private int year = year();
  private int month = month(); //1;
  private int day = day(); //21;

  private int beginDay;
  private float date;

  final int interval = 1; //dT


  final String[][] WORDS = {
    {
      "", ""
    }
    ,
    {
      "at hour", "à l'heure"
    }
    ,
    {
      "day", "jour"
    }
    ,
    {
      "month", "mois"
    }
    ,
    {
      "year", "année"
    }
    ,
    {
      "date", "date"
    }
  };


  final String[][] namesOfMonths = {
    {
      "January", "janvier"
    }
    ,
    {
      "February", "février"
    }
    ,
    {
      "March", "mars"
    }
    ,
    {
      "April", "avril"
    }
    ,
    {
      "May", "mai"
    }
    ,
    {
      "June", "juin"
    }
    ,
    {
      "July", "juillet"
    }
    ,
    {
      "August", "août"
    }
    ,
    {
      "September", "septembre"
    }
    ,
    {
      "October", "octobre"
    }
    ,
    {
      "November", "novembre"
    }
    ,
    {
      "December", "décembre"
    }
  };

  private final int[] lengthOfMonths = {
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  };

  private int[] monthFromDate = new int [365];
  private int[] dayFromDate = new int [365];
  private String[] MM = new String [365];
  private String[] MMDD = new String [365];
  private String[][] dayOfYear = new String [365][numberOfLanguages];

  int safeDate(float date_IN) {
    return floor(0.001 + (365 + date_IN) % 365);
  }

  int getMonth_fromDate(float date_IN) {
     return this.monthFromDate[safeDate(date_IN)];
  }

  int getDay_fromDate(float date_IN) {
     return this.dayFromDate[safeDate(date_IN)];
  }

  String getDayText(float date_IN) {
    return this.dayOfYear[safeDate(date_IN)][Language_Active];
  }

  String getMMDD(float date_IN) {
    return this.MMDD[safeDate(date_IN)];
  }

  String getMM(float date_IN) {
    return this.MM[safeDate(date_IN)];
  }

  solarchvision_TIME () { // constructor
    this.createCalendar();
  }

  void createCalendar () {
    int k = 285;

    for (int i = 0; i < 12; i++) {
      for (int j = 0; j < this.lengthOfMonths[i]; j++) {
        k += 1;
        if (k == 365) k = 0;

        this.monthFromDate[k] = i + 1;
        this.dayFromDate[k] = j + 1;

        this.MM[k] = nf(i + 1, 2);
        this.MMDD[k] = nf(i + 1, 2) + nf(j + 1, 2);

        for (int l = 0; l < numberOfLanguages; l++) {
          this.dayOfYear[k][l] = this.namesOfMonths[i][l] + " " + nf(j + 1, 0);
        }
      }
    }
  }

  int convert2Day (int Date_Angle) {
    int DAY = (Date_Angle + 360) % 360;
    if (DAY >=  31) DAY++;
    if (DAY >=  62) DAY++;
    if (DAY >=  93) DAY++;
    if (DAY >= 124) DAY++;
    if (DAY >= 155) DAY++;
    DAY = DAY % 365;
    return DAY;
  }

  int convert2Date (int month, int day) {
    int k = 0;
    for (int i = 0; i < (month - 1); i++) {
      for (int j = 0; j < this.lengthOfMonths[i]; j++) {
        k += 1;
        if (k == 365) k = 0;
      }
    }
    k += day - 1;

    k = k % 365;
    return k;
  }

  void updateDate () {
    this.month = this.getMonth_fromDate(this.date);
    this.day = this.getDay_fromDate(this.date);
    this.hour = int(24 * (this.date - int(this.date)));
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "modelRun", this.modelRun);
    XML_setInt(parent, "year", this.year);
    XML_setInt(parent, "month", this.month);
    XML_setInt(parent, "day", this.day);
    XML_setInt(parent, "hour", this.hour);
    XML_setInt(parent, "beginDay", this.beginDay);
    XML_setFloat(parent, "date", this.date);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.modelRun = XML_getInt(parent, "modelRun");
    this.year = XML_getInt(parent, "year");
    this.month = XML_getInt(parent, "month");
    this.day = XML_getInt(parent, "day");
    this.hour = XML_getInt(parent, "hour");
    this.beginDay = XML_getInt(parent, "beginDay");
    this.date = XML_getFloat(parent, "date");
  }

}

solarchvision_TIME TIME = new solarchvision_TIME();



class solarchvision_Functions {

  private final static String CLASS_STAMP = "Functions";

  final float EPSILON_DIRECTION = 0.001; // to detect parallels.
  final float EPSILON_POSITION = 0.0001; // to detect intersections i.e. in the world coordinate.




  float asin_ang (float a) {
    return ((asin(a)) * 180/PI);
  }

  float acos_ang (float a) {
    return ((acos(a)) * 180/PI);
  }

  float atan_ang (float a) {
    return ((atan(a)) * 180/PI);
  }

  float atan2_ang (float a, float b) {
    return ((atan2(a, b)) * 180/PI);
  }


  float sin_ang (float a) {
    return sin(a * PI / 180);
  }

  float cos_ang (float a) {
    return cos(a * PI / 180);
  }

  float tan_ang (float a) {
    return tan(a * PI / 180);
  }




  float roundTo (float a, float b) {
    float a_floor = (floor (a / (1.0 * b))) * b;
    float a_ceil =  (ceil (a / (1.0 * b))) * b;
    float c;
    if ((a - a_floor) > (a_ceil - a)) {
      c = a_ceil;
    } else {
      c = a_floor;
    }
    return c;
  }


  float[] convert_lonlat2XY (double lon0, double lat0, double lon, double lat) {

    double du = ((lon - lon0) / 180.0) * (PI * DOUBLE_r_Earth);
    double dv = ((lat - lat0) / 180.0) * (PI * DOUBLE_r_Earth);

    float x = (float) du * this.cos_ang((float) lat);
    float y = (float) dv;

    float[] XY = {x, y};

    return XY;
  }


  float lon_lat_dist (double lon1, double lat1, double lon2, double lat2) {

    float dLon = (float) (lon2 - lon1);
    float dLat = (float) (lat2 - lat1);

    float a = this.sin_ang(dLon / 2.0);
    float b = this.sin_ang(dLat / 2.0) * this.sin_ang(dLat / 2.0) +
              this.cos_ang((float) lat1) * this.cos_ang((float) lat2) * a * a;

    return 2 * atan2(sqrt(b), sqrt(1 - b)) * (float) DOUBLE_r_Earth;
  }

  float[] vec_scale (float[] a, float b) {

    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b * a[i];
    }

    return d;
  }

  float[] vec3_scale (float[] a, float b) {

    float[] d = {b * a[0], b * a[1], b * a[2]};

    return d;
  }

  float[] vec_sum (float[] a, float[] b) {

    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b[i] + a[i];
    }

    return d;
  }

  float[] vec3_sum (float[] a, float[] b) {

    float[] d = {b[0] + a[0], b[1] + a[1], b[2] + a[2]};

    return d;
  }

  float[] vec_diff (float[] a, float[] b) {

    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b[i] - a[i];
    }

    return d;
  }

  float[] vec3_diff (float[] a, float[] b) {

    float[] d = {b[0] - a[0], b[1] - a[1], b[2] - a[2]};

    return d;
  }

  float vec_dist (float[] a, float[] b) {

    return this.vec_mag(this.vec_diff(a, b));
  }

  float vec3_dist (float[] a, float[] b) {

    return this.vec3_mag(this.vec3_diff(a, b));
  }


  float vec_mag (float[] a) {

    float d = 0;
    for (int i = a.length - 1; i > -1 ; --i) {
      d += pow(a[i], 2);
    }
    d = pow(d, 0.5);

    return d;
  }

  float vec3_mag (float[] a) {

    return pow(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], 0.5);
  }

  float[] vec_unit (float[] a) {

    float d = this.vec_mag(a);

    float[] b = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      if (d != 0) b[i] = a[i] / d;
      else b[i] = 0;
    }
    return b;
  }

  float[] vec3_unit (float[] a) {

    float d = this.vec3_mag(a);

    float[] b = new float[3];
    for (int i = 0; i < 3; i++) {
      if (d != 0) b[i] = a[i] / d;
      else b[i] = 0;
    }
    return b;
  }

  float vec_dot (float[] a, float b[]) {
    float d = 0;
    for (int i = a.length - 1; i > -1; --i) {
      d += a[i] * b[i];
    }
    return d;
  }

  float vec2_dot (float x1, float y1, float x2, float y2) {
    return x1 * x2 + y1 * y2;
  }

  float vec3_dot (float[] a, float b[]) {

    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  float[] vec3_cross (float[] a, float b[]) {

    float[] c = new float [3];

    c[0] = a[1] * b[2] - a[2] * b[1];
    c[1] = a[2] * b[0] - a[0] * b[2];
    c[2] = a[0] * b[1] - a[1] * b[0];

    return c;
  }

  float[] centroid (float[][] a) {

    float[] b = a[0]; // initializing to the first node

    // adding other nodes
    for (int i = a.length - 1; i > 0; --i) { // not the first one!
      for (int j = b.length - 1; j > -1; --j) {
        b[j] += a[i][j];
      }
    }

    // dividing to the number of nodes
    for (int j = b.length - 1; j > -1; --j) {
      b[j] /= float(a.length);
    }

    return b;
  }


  float bilinear (float f_00, float f_10, float f_11, float f_01, float x, float y) {

    float f_xy = f_00 * (1 - x) * (1 - y) + f_10 * x * (1 - y) + f_01 * (1 - x) * y + f_11 * x * y;

    return f_xy;
  }


  boolean isInside_Triangle (float[] P, float[] A, float[] B, float[] C) {

    float pX = P[0] - C[0];
    float pY = P[1] - C[1];
    float pZ = P[2] - C[2];

    float aX = A[0] - C[0];
    float aY = A[1] - C[1];
    float aZ = A[2] - C[2];

    float bX = B[0] - C[0];
    float bY = B[1] - C[1];
    float bZ = B[2] - C[2];

    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);

    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;

    return ((u >= 0) && (v >= 0) && (u + v <= 1));
  }


  boolean isInside_Quadrangle (float[] P, float[] A, float[] B, float[] C, float[] D) {

    float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]),
                 0.25 * (A[1] + B[1] + C[1] + D[1]),
                 0.25 * (A[2] + B[2] + C[2] + D[2])};

    float pX = P[0] - G[0];
    float pY = P[1] - G[1];
    float pZ = P[2] - G[2];

    float aX = A[0] - G[0];
    float aY = A[1] - G[1];
    float aZ = A[2] - G[2];

    float bX = B[0] - G[0];
    float bY = B[1] - G[1];
    float bZ = B[2] - G[2];

    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);

    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;

    boolean result = ((u >= 0) && (v >= 0) && (u + v <= 1));

    if (result == false) {

      float cX = C[0] - G[0];
      float cY = C[1] - G[1];
      float cZ = C[2] - G[2];

      float CC = cX * cX + cY * cY + cZ * cZ; // this.vec3_dot(c, c);
      float CP = cX * pX + cY * pY + cZ * pZ; // this.vec3_dot(c, p);
      float BC = bX * cX + bY * cY + bZ * cZ; // this.vec3_dot(b, c);

      r = (BB * CC - BC * BC); if (r == 0.0) return false;
      u = (CC * BP - BC * CP) / r;
      v = (BB * CP - BC * BP) / r;

      result = ((u >= 0) && (v >= 0) && (u + v <= 1));

      if (result == false) {

        float dX = D[0] - G[0];
        float dY = D[1] - G[1];
        float dZ = D[2] - G[2];

        float CD = cX * dX + cY * dY + cZ * dZ; // this.vec3_dot(c, d);
        float DD = dX * dX + dY * dY + dZ * dZ; // this.vec3_dot(d, d);
        float DP = dX * pX + dY * pY + dZ * pZ; // this.vec3_dot(d, p);

        r = (CC * DD - CD * CD); if (r == 0.0) return false;
        u = (DD * CP - CD * DP) / r;
        v = (CC * DP - CD * CP) / r;

        result = ((u >= 0) && (v >= 0) && (u + v <= 1));

        if (result == false) {

          float DA = dX * aX + dY * aY + dZ * aZ; // this.vec3_dot(d, a);

          r = (DD * AA - DA * DA); if (r == 0.0) return false;
          u = (AA * DP - DA * AP) / r;
          v = (DD * AP - DA * DP) / r;

          result = ((u >= 0) && (v >= 0) && (u + v <= 1));
        }
      }
    }

    return result;
  }

  boolean isInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // good for rectangular surfaces namely for selecting allModel2Ds, etc.

    float pX = P[0] - O[0];
    float pY = P[1] - O[1];
    float pZ = P[2] - O[2];

    float aX = A[0] - O[0];
    float aY = A[1] - O[1];
    float aZ = A[2] - O[2];

    float bX = B[0] - O[0];
    float bY = B[1] - O[1];
    float bZ = B[2] - O[2];

    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);

    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;

    return ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1));
  }

  float[] uvInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // copy of the function above but it returns u and v

    float pX = P[0] - O[0];
    float pY = P[1] - O[1];
    float pZ = P[2] - O[2];

    float aX = A[0] - O[0];
    float aY = A[1] - O[1];
    float aZ = A[2] - O[2];

    float bX = B[0] - O[0];
    float bY = B[1] - O[1];
    float bZ = B[2] - O[2];

    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);

    float[] result = {0, 0};

    float r = (AA * BB - AB * AB); if (r == 0.0) return result;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;

    result[0] = u;
    result[1] = v;

    return result;
  }


  float[][] getSubFace (float[][] base_Vertices, int tessellation, int n) {

    float[][] return_vertices = {
    };

    int totalNumberOfSubs = 1;
    if (tessellation > 0) totalNumberOfSubs = base_Vertices.length * int(this.roundTo(pow(4, tessellation - 1), 1));

    if ((tessellation <= 0) || (n < 0) || (n >= totalNumberOfSubs)) {
      return_vertices = new float [base_Vertices.length][3];

      for (int j = 0; j < base_Vertices.length; j++) {
        return_vertices[j] = base_Vertices[j];
      }
    } else {
      return_vertices = new float [4][3];

      int div = base_Vertices.length;

      int the_first = n % div;
      int the_next = (the_first + 1) % div;
      int the_previous = (the_first + div - 1) % div;

      float[] A = {
        0, 0, 0
      };
      float[] B = {
        0, 0, 0
      };
      float[] C = {
        0, 0, 0
      };
      float[] D = {
        0, 0, 0
      };

      for (int i = 0; i < 3; i++) {

        A[i] = base_Vertices[the_first][i];
        B[i] = 0.5 * (A[i] + base_Vertices[the_next][i]);
        D[i] = 0.5 * (A[i] + base_Vertices[the_previous][i]);

        for (int j = 0; j < base_Vertices.length; j++) {
          C[i] += base_Vertices[j][i] / (1.0 * base_Vertices.length);
        }
      }

      if (tessellation == 1) {
        return_vertices[0] = A;
        return_vertices[1] = B;
        return_vertices[2] = C;
        return_vertices[3] = D;
      } else {

        int section = n / div;
        int res = int(this.roundTo(pow(2, tessellation - 1), 1));
        int u = section / res;
        int v = section % res;

        float x1 = (1.0 * u) / (1.0 * res);
        float y1 = (1.0 * v) / (1.0 * res);
        float x2 = (1.0 * (u + 1)) / (1.0 * res);
        float y2 = (1.0 * (v + 1)) / (1.0 * res);

        float[] P0 = {
          0, 0, 0
        };
        float[] P1 = {
          0, 0, 0
        };
        float[] P2 = {
          0, 0, 0
        };
        float[] P3 = {
          0, 0, 0
        };

        for (int i = 0; i < 3; i++) {
          P0[i] = this.bilinear(A[i], B[i], C[i], D[i], x1, y1);
          P1[i] = this.bilinear(A[i], B[i], C[i], D[i], x2, y1);
          P2[i] = this.bilinear(A[i], B[i], C[i], D[i], x2, y2);
          P3[i] = this.bilinear(A[i], B[i], C[i], D[i], x1, y2);
        }

        //return_vertices[0] = P0;
        //return_vertices[1] = P1;
        //return_vertices[2] = P2;
        //return_vertices[3] = P3;

        //to rotate tri-grid cells:

        int d = ((u % 2) + ((v + 1) % 2)) % 2;
        if (d == 0) {
          return_vertices[0] = P0;
          return_vertices[1] = P1;
          return_vertices[2] = P2;
          return_vertices[3] = P3;
        } else {
          return_vertices[0] = P1;
          return_vertices[1] = P2;
          return_vertices[2] = P3;
          return_vertices[3] = P0;
        }
      }
    }

    return return_vertices;
  }


  boolean is_zero (float val) {
    return (abs(val) < this.EPSILON_POSITION);
  }

  boolean is_zero (float val, float tolerance) {
    return (abs(val) < tolerance);
  }

  boolean arePointsClose(float[] point1, float[] point2) {
    return this.is_zero(this.vec3_mag(this.vec3_diff(point1, point2)), this.EPSILON_POSITION);
  }

  boolean are3PointsIn1Line(float[] point1, float[] point2, float[] point3) {

    return this.is_zero(1.0 - abs(this.vec3_dot(
                                  this.vec3_unit(this.vec3_diff(point1, point2)),
                                  this.vec3_unit(this.vec3_diff(point2, point3)))), this.EPSILON_DIRECTION);
  }

  float[] calculateTriangleNormal(float[] point1, float[] point2, float[] point3) {
    return this.vec3_unit(this.vec3_cross(
                          this.vec3_diff(point1, point2),
                          this.vec3_diff(point2, point3)));
  }


  float[] calculatePolygonNormal(float[][] polygonVertices) {

    float[] polygonNormal = {0, 0, 0};

    int n = polygonVertices.length;

    for (int i = 0; i < n; i++) {
      int i1 = (i + 1) % n;
      int i2 = (i + 2) % n;

      if (false == are3PointsIn1Line(polygonVertices[i],
                                     polygonVertices[i1],
                                     polygonVertices[i2])) {

        polygonNormal = calculateTriangleNormal(polygonVertices[i],
                                                polygonVertices[i1],
                                                polygonVertices[i2]);

        break;
      }
    }

    return polygonNormal;
  }


  boolean isPointInPolygon(float[] point, float[][] polygon_vertices) {

    float[] polygon_normal = calculatePolygonNormal(polygon_vertices);


    int i, next_i;

    // fisrt check at each vertex, if equal to any we return ture
    for (i = 0; i < polygon_vertices.length; i++) {

      if (true == this.is_zero(this.vec3_mag(this.vec3_diff(point, polygon_vertices[i])))) {
        return true;
      }
    }

    float sumAngles = 0.0;
    for (i = 0; i < polygon_vertices.length; i++) {
      next_i = (i + 1) % polygon_vertices.length;

      float[] AM = this.vec3_diff(point, polygon_vertices[i]);
      float[] BM = this.vec3_diff(point, polygon_vertices[next_i]);

      float divisor = this.vec3_mag(AM) * this.vec3_mag(BM);
      if (divisor > 0.0) {

        float acosine = this.vec3_dot(AM, BM) / divisor;
        if (acosine < -1.0) acosine = -1.0;
        else if (acosine > 1.0) acosine = 1.0;

        float angle = acos(acosine); // returns between 0 and PI
        if (false == Float.isNaN(angle)){
          if (this.vec3_dot(this.vec3_cross(AM, BM), polygon_normal) < 0) {
            angle = -angle;
          }
          sumAngles += angle;
        }
      }
    }

    float remainder = (abs(sumAngles) / (2.0 * PI)) % 2.0;
    if (remainder < 0.9999 || remainder > 1.0001) {
      return false;
    }
    return true;
  }



  float[][] cleanShape_removeDuplicateVertices (float[][] vertices_IN) {

    float[][] vertices_OUT =  new float[0][3];
    int n = vertices_IN.length;
    for (int i = 0; i < n; i++) {
      int prev_i = (i - 1 + n) % n;

      if (false == this.is_zero(this.vec3_mag(this.vec3_diff(vertices_IN[i], vertices_IN[prev_i])), 0.001)) { // i.e. 1mm tolerance, here

        float[][] newVertex = {{vertices_IN[i][0], vertices_IN[i][1], vertices_IN[i][2]}};
        vertices_OUT = (float[][]) concat(vertices_OUT, newVertex);
      }
    }

    return vertices_OUT;
  }



  float[][] cleanShape_joinParallelSegments (float[][] vertices_IN) {

    float[][] vertices_OUT =  new float[0][3];
    int n = vertices_IN.length;
    for (int i = 0; i < n; i++) {
      int prev_i = (i - 1 + n) % n;
      int next_i = (i + 1) % n;

      if (false == are3PointsIn1Line(vertices_IN[prev_i],
                                     vertices_IN[i],
                                     vertices_IN[next_i])) {

        float[][] newVertex = {{vertices_IN[i][0], vertices_IN[i][1], vertices_IN[i][2]}};
        vertices_OUT = (float[][]) concat(vertices_OUT, newVertex);
      }
    }

    return vertices_OUT;
  }



  float[][] optimizeVertices (float[][] vertices_IN) {
    float[][] vertices_TMP = this.cleanShape_removeDuplicateVertices(vertices_IN);
    float[][] vertices_OUT = this.cleanShape_joinParallelSegments(vertices_TMP);

    return vertices_OUT;
  };




  float calculatePolygonArea(float[][] polygonVertices) {

   float[] sumVect = {0, 0, 0};

    for (int i = 0; i < polygonVertices.length; i++) {
      int next_i = (i + 1) % polygonVertices.length;

      float[] A = this.vec3_cross(polygonVertices[i], polygonVertices[next_i]);
      float[] B = sumVect;

      sumVect = this.vec3_sum(A, B);
    }

    return 0.5 * this.vec3_mag(sumVect); // unit m2
  }


  boolean isPointOnSegment(float[] point, float[] pStart, float[] pEnd) {

    float L1 = this.vec3_mag(this.vec3_diff(pStart, point));
    float L2 = this.vec3_mag(this.vec3_diff(point, pEnd));
    float L3 = this.vec3_mag(this.vec3_diff(pStart, pEnd));

    return this.is_zero(L3 -(L2 + L1), this.EPSILON_POSITION);
  }


  float[] getBetween(float[] point1, float[] point2, float ratio) {

    return this.vec3_sum(this.vec3_scale(point1, ratio), this.vec3_scale(point2, 1.0 - ratio));
  }

  float[] intersect_segmentXsegment (float[] A1, float[] A2, float[] B1, float[] B2) {

    float[] nullPoint = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    if (arePointsClose(A1, B1)) return getBetween(A1, B1, 0.5);
    if (arePointsClose(A1, B2)) return getBetween(A1, B2, 0.5);
    if (arePointsClose(A2, B1)) return getBetween(A2, B1, 0.5);
    if (arePointsClose(A2, B2)) return getBetween(A2, B2, 0.5);

    if (isPointOnSegment(A1, B1, B2)) return A1;
    if (isPointOnSegment(A2, B1, B2)) return A2;
    if (isPointOnSegment(B1, A1, A2)) return B1;
    if (isPointOnSegment(B2, A1, A2)) return B2;

    float[] Axis_A = this.vec3_unit(this.vec3_diff(A1, A2));
    float[] Axis_B = this.vec3_unit(this.vec3_diff(B1, B2));

    if (true == this.is_zero(1 - Math.abs(this.vec3_dot(this.vec3_unit(Axis_A), this.vec3_unit(Axis_B))), this.EPSILON_DIRECTION)) {

      return nullPoint;
    }

    float[] cross_vect = this.vec3_cross(Axis_A, Axis_B);
    float cross_dist = this.vec3_mag(cross_vect);

    if (this.is_zero(cross_dist)) {

      return nullPoint;
    }

    float rA = this.vec3_dot(this.vec3_cross(this.vec3_diff(B1, A1), Axis_B), cross_vect) / (cross_dist * cross_dist);
    float rB = this.vec3_dot(this.vec3_cross(this.vec3_diff(B1, A1), Axis_A), cross_vect) / (cross_dist * cross_dist);

    float[] result_A = this.vec3_sum(A1, this.vec3_scale(Axis_A, rA));
    float[] result_B = this.vec3_sum(B1, this.vec3_scale(Axis_B, rB));



    if (false == this.is_zero(this.vec3_mag(this.vec3_diff(result_A, result_B)), this.EPSILON_POSITION)) {

      return nullPoint;
    }

    float[] result_AxB = getBetween(result_A , result_B, 0.5);

    if (false == isPointOnSegment(result_AxB, A1, A2)) return nullPoint;
    if (false == isPointOnSegment(result_AxB, B1, B2)) return nullPoint;

    return result_AxB;
  }








  int[][] reduceDegreePolygon (float[][] polygon_vertices) {

    int maximumDegree = 3;

    int[][] allDiagonals = new int[0][2]; // start, end
    float[] allDiagonals_dist = new float[0];
    float[] intersectionPoint;

    int i, j, k, q;
    int i2, j2;
    float[] A, B, A2, B2;

    int n = polygon_vertices.length;

    for (i = 0; i < n; i++) {

      int next_i = (i + 1) % n;
      int prev_i = (i - 1 + n) % n;

      for (j = i + 1; j < n; j++) {

        if ((j != prev_i) && (j != next_i)) {

          A = polygon_vertices[i];
          B = polygon_vertices[j];

          boolean diagonalRejected = false;

          float[] lEdgeMiddle = this.vec3_scale(this.vec_sum(A, B), 0.5);
          if (false == isPointInPolygon(lEdgeMiddle, polygon_vertices)) {
            diagonalRejected = true;
          }
          else {

            for (k = 0; k < n; k++) {

              int next_k = (k + 1) % n;

              if ((i != k) && (i != next_k) &&
                  (j != k) && (j != next_k)) {

                A2 = polygon_vertices[k];
                B2 = polygon_vertices[next_k];

                intersectionPoint = intersect_segmentXsegment(A, B, A2, B2);

                if (is_defined(intersectionPoint[0])) {
                  diagonalRejected = true;
                  break;
                }
              }
            }
          }

          if (false == diagonalRejected) {

            float dist = this.vec3_mag(this.vec3_diff(A, B));

            int[][] newDiagonal = {{i, j}};
            allDiagonals = (int[][]) concat(allDiagonals, newDiagonal);

            float[] newDiagonal_dist = {dist};
            allDiagonals_dist = (float[]) concat(allDiagonals_dist, newDiagonal_dist);

          }

        }
      }
    }


    // ascending sort:
    for (k = 0; k < allDiagonals.length; k++) {
      for (q = k + 1; q < allDiagonals.length; q++) {
        if (allDiagonals_dist[k] > allDiagonals_dist[q]) {
          float tmp_float = allDiagonals_dist[k];
          allDiagonals_dist[k] = allDiagonals_dist[q];
          allDiagonals_dist[q] = tmp_float;

          for (j = 0; k < 2; j++) {
            int tmp_int = allDiagonals[k][j];
            allDiagonals[k][j] = allDiagonals[q][j];
            allDiagonals[q][j] = tmp_int;
          }

        }
      }
    }


    for (k = 0; k < allDiagonals.length; k++) {

      i = allDiagonals[k][0]; // start
      j = allDiagonals[k][1]; // end
      A = polygon_vertices[i];
      B = polygon_vertices[j];

      for (q = allDiagonals.length - 1 ; q > k; q--) { // reversed loop required.

        i2 = allDiagonals[q][0]; // start
        j2 = allDiagonals[q][1]; // end
        A2 = polygon_vertices[i2];
        B2 = polygon_vertices[j2];

        if ((i != i2) && (i != j2) &&
            (j != i2) && (j != j2)) {

          intersectionPoint = intersect_segmentXsegment(A, B, A2, B2);

          if (is_defined(intersectionPoint[0])) {
            int[][] startList = (int[][]) subset(allDiagonals, 0, q);
            int[][] endList = (int[][]) subset(allDiagonals, q + 1);
            allDiagonals = (int[][]) concat(startList, endList); // remove this diagonal
          }
        }

      }
    }


    int[][] faces = new int[1][n];
    for (k = 0; k < n; k++) {
      faces[0][n] = k;
    }

    int vertexID;

    for (k = 0; k < allDiagonals.length; k++) {
      int v1 = allDiagonals[k][0]; // start
      int v2 = allDiagonals[k][1]; // end

      int ID_1st = -1;
      int ID_2nd = -1;
      for (i = 0; i < faces.length; i++) {

        if (faces[i].length > maximumDegree) {

          for (j = 0; j < faces[i].length; j++) {
            vertexID = faces[i][j];
                 if (v1 == vertexID) ID_1st = j;
            else if (v2 == vertexID) ID_2nd = j;
          }

          if ((-1 != ID_1st) && (-1 != ID_2nd)) {
            // we found the face to devide by the diagonal

            int[][] newFace1 = new int[0][0];
            int[][] newFace2 = new int[0][0];

            for (j = 0; j < faces[i].length; j++) {
              vertexID = faces[i][j];

              int[][] newItem = {{vertexID}};

              if ((j <= ID_1st) || (j >= ID_2nd)) {
                newFace1 = (int[][]) concat(newFace1, newItem); // pushing vertexID
              }

              if ((j >= ID_1st) && (j <= ID_2nd)) {
                newFace2 = (int[][]) concat(newFace2, newItem); // pushing vertexID
              }

            }

            int[][] startList = (int[][]) subset(faces, 0, i);
            int[][] endList = (int[][]) subset(faces, i + 1);
            faces = (int[][]) concat(startList, endList); // remove this face

            faces = (int[][]) concat(faces, newFace1); // pushing 1st new face
            faces = (int[][]) concat(faces, newFace2); // pushing 2st new face
            i--; // since we added 2 faces and removed one
            break;
          }
        }
      }
    }

    return faces;
  }





  float EquationOfTime (float DateAngle) {
    return 0.01 * (9.87 * this.sin_ang(2 * DateAngle) - 7.53 * this.cos_ang(DateAngle) - 1.5 * this.sin_ang(DateAngle));
  }

  float correctHourAngle (float DateAngle, float HourAngleOrigin) {
    return EquationOfTime(DateAngle) + HourAngleOrigin;
  }

  float[] SunPositionRadiation (float DateAngle, float HourAngleOrigin, float CloudCover) {
    float HourAngle = correctHourAngle(DateAngle, HourAngleOrigin);

    float Declination = 23.45 * this.sin_ang(DateAngle - 180.0);

    float a = this.sin_ang(Declination);
    float b = this.cos_ang(Declination) * -this.cos_ang(15.0 * HourAngleOrigin);
    float c = this.cos_ang(Declination) *  this.sin_ang(15.0 * HourAngleOrigin);

    float x = c;
    float y = -(a * this.cos_ang(STATION.getLatitude()) + b * this.sin_ang(STATION.getLatitude()));
    float z = -a * this.sin_ang(STATION.getLatitude()) + b * this.cos_ang(STATION.getLatitude());

    float Io = 1367.0; // W/m²
    Io = Io * (1.0 - (0.0334 * this.sin_ang(DateAngle)));

    float ALT_ = (this.asin_ang(z)) * PI / 180;
    float ALT_true = ALT_ + 0.061359 * (0.1594 + 1.1230 * ALT_ + 0.065656 * ALT_ * ALT_) / (1 + 28.9344 * ALT_ + 277.3971 * ALT_ * ALT_);

    float PPo = pow(FLOAT_e, (-STATION.getElevation() / 8435.2));
    float Bb = ((this.sin_ang (ALT_true * 180 / PI)) + (0.50572 * pow((57.29578 * ALT_true + 6.07995), -1.6364)));
    float m = PPo / Bb;

    float StationTurbidity;

    StationTurbidity = (2.0 - 0.2) * (0.1 * CloudCover) + 0.2;

    float AtmosphereRatio;
    if (z < 0.01) AtmosphereRatio = 0.0;
    else AtmosphereRatio = pow(FLOAT_e, (-m * StationTurbidity));

    float Idirect = Io * AtmosphereRatio; // Optical air mass: global Meteorological Database for Engineers, Planners and Education; Version 5.00 - Edition 2003

    float Idiffuse;
    if (z < 0.01) Idiffuse = 0.0;
    else Idiffuse = ((0.5 + 0.5 * (0.1 * CloudCover)) * z * (Io - Idirect)) / (1.0 - 1.4 * z * log(Idirect / Io));

    float[] return_array = {
      0, x, y, z, Idirect, Idiffuse
    };
    return return_array;
  }

  float[] SunPosition (float Latitude, float DateAngle, float HourAngleOrigin) {
    float HourAngle = correctHourAngle(DateAngle, HourAngleOrigin);

    float Declination = 23.45 * this.sin_ang(DateAngle - 180.0);

    float a = this.sin_ang(Declination);
    float b = this.cos_ang(Declination) * -this.cos_ang(15.0 * HourAngle);
    float c = this.cos_ang(Declination) *  this.sin_ang(15.0 * HourAngle);

    float x = c;
    float y = -(a * this.cos_ang(Latitude) + b * this.sin_ang(Latitude));
    float z = -a * this.sin_ang(Latitude) + b * this.cos_ang(Latitude);

    float[] return_array = {
      0, x, y, z
    };
    return return_array;
  }

  float Sunrise (float Latitude, float DateAngle) {

    float a = 0;

    float Declination = 23.5 * this.sin_ang(DateAngle - 180.0);

    float q = -(this.tan_ang(Declination) * this.tan_ang(Latitude));
    if (q > 1.0) {
      a = 0.0;
    } else if (q < -1.0) {
      a = 24.0;
    } else a = this.acos_ang(q) / 15.0;

    return (a - EquationOfTime(DateAngle));
  }

  float Sunset (float Latitude, float DateAngle) {

    return 24.0 - this.Sunrise(Latitude, DateAngle) - 2 * EquationOfTime(DateAngle);
  }

  float DayTime (float Latitude, float DateAngle) {
    return abs((this.Sunset(Latitude, DateAngle)) - (this.Sunrise(Latitude, DateAngle)));
  }

}

solarchvision_Functions funcs = new solarchvision_Functions();




class solarchvision_UITASK {

  private final static String CLASS_STAMP = "UITASK";

  int num = 0;

  int LandOrbit_Pan_TargetRollZ = num++;
  int LookAtDirection = num++;
  int DistMouseXY_TargetRollXY_TargetRollZ = num++;
  int PanY_TargetRollXY_TargetRollZ = num++;
  int PanX_TargetRollXY_TargetRollZ = num++;
  int Pan_TargetRoll = num++;
  int CameraDistance_TargetRollXY_TargetRollZ = num++;
  int CameraRoll_Pan = num++;
  int CameraRollXY_CameraRollZ = num++;
  int TargetRoll_Pan = num++;
  int TargetRollXY_TargetRollZ = num++;
  int AllModelSize = num++;
  int SkydomeSize = num++;
  int Truck_Orbit = num++;
  int ModelSize_Pan_TargetRoll = num++;
  int Pan_Height = num++;
  int Zoom_Orbit_Pan = num++;
  int RectSelect = num++;
  int PickSelect = num++;
  int Create = num++;
  int Move = num++;
  int Scale = num++;
  int Rotate = num++;
  int Seed_Material = num++;
  int Tessellation = num++;
  int Layer = num++;
  int Visibility = num++;
  int Weight = num++;
  int DegreeMax = num++;
  int BranchTilt = num++;
  int BranchTwist = num++;
  int BranchRatio = num++;
  int TreeBase = num++;
  int TrunkSize = num++;
  int LeafSize = num++;
  int Model1DsProps = num++;
  int Pivot = num++;
  int Normal = num++;
  int FirstVertex = num++;
  int Drop = num++;
  int GetLength = num++;
  int PowerX = num++;
  int PowerY = num++;
  int PowerZ = num++;
  int PowerAll = num++;

}

solarchvision_UITASK UITASK = new solarchvision_UITASK();
















int numberOfLayers = 0;

class solarchvision_LAYER {

  private final static String CLASS_STAMP = "LAYER";

  public int id;

  public String unit = "";
  public String name = "";
  public String[] descriptions = new String [numberOfLanguages];

  public float V_scale = 1;
  public float V_offset = 0;
  public float V_belowLine = 0;

  solarchvision_LAYER (float V_scale, float V_offset, float V_belowLine, String unit, String description_EN, String description_FR, String name) {

    this.V_scale = V_scale;
    this.V_offset = V_offset;
    this.V_belowLine = V_belowLine;
    this.unit = unit;
    this.name = name;
    this.descriptions[Language_EN] = description_EN;
    this.descriptions[Language_FR] = description_FR;

    this.id = numberOfLayers;
    numberOfLayers++;
  }

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP + "_" + nf(this.id, 0));

    XML parent = xml.addChild(this.CLASS_STAMP + "_" + nf(this.id, 0));

    XML_setInt(parent, "id", this.id);

    XML_setString(parent, "unit", this.unit);
    XML_setString(parent, "name", this.name);
    XML_setString(parent, "description_EN", this.descriptions[Language_EN]);
    XML_setString(parent, "description_FR", this.descriptions[Language_FR]);

    XML_setFloat(parent, "V_scale", this.V_scale);
    XML_setFloat(parent, "V_offset", this.V_offset);
    XML_setFloat(parent, "V_belowLine", this.V_belowLine);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP + "_" + nf(this.id, 0));

    XML parent = xml.getChild(this.CLASS_STAMP + "_" + nf(this.id, 0));

    this.id = XML_getInt(parent, "id");

    this.unit = XML_getString(parent, "unit");
    this.name = XML_getString(parent, "name");
    this.descriptions[Language_EN] = XML_getString(parent, "description_EN");
    this.descriptions[Language_FR] = XML_getString(parent, "description_FR");

    this.V_scale = XML_getFloat(parent, "V_scale");
    this.V_offset = XML_getFloat(parent, "V_offset");
    this.V_belowLine = XML_getFloat(parent, "V_belowLine");
  }


}

solarchvision_LAYER LAYER_windspd200hPa = new solarchvision_LAYER(
  0.5,
  0,
  0,
  "knots",
  "Wind Speed at 200 hPa",
  "Vitesse du vent à 200 hPa",
  "WIND-200HPA"
);

solarchvision_LAYER LAYER_thicknesses_1000_500 = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotentiel Difference",
  "Différence de géopotentiel",
  "LAYER-1000-500HPA"
);


solarchvision_LAYER LAYER_heightp500hPa = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotential at 500 hPa",
  "Géopotentiel à 500 hPa",
  "HGT-500HPA"
);

solarchvision_LAYER LAYER_ceilingsky = new solarchvision_LAYER(
  0.01,
  0,
  0,
  "m",
  "Ceiling height",
  "Hauteur sous plafond",
  ""
);


solarchvision_LAYER LAYER_cloudcover = new solarchvision_LAYER(
  10.0,
  0,
  0,
  "tenth",
  "Total Cloud Cover",
  "Couvert nuageux total",
  "TCDC"
);

solarchvision_LAYER LAYER_winddir = new solarchvision_LAYER(
  100.0 / 360.0,
  0,
  0,
  "°",
  "Surface Wind Direction",
  "Direction du vent à la surface",
  "WDIR-SFC"
);

solarchvision_LAYER LAYER_windspd = new solarchvision_LAYER(
  2.5,
  0,
  0,
  "km/h",
  "Surface Wind Speed",
  "Vitesse du vent à la surface",
  "WIND-SFC"
);

solarchvision_LAYER LAYER_pressure = new solarchvision_LAYER(
  2.0,
  -1000,
  1,
  "hPa",
  "Mean Sea level Pressure",
  "Pression moyenne au niveau de la mer",
  "MSLP"
);

solarchvision_LAYER LAYER_drybulb = new solarchvision_LAYER(
  2.5,
  0,
  1,
  "°C",
  "Surface Air Temperature",
  "Température de l'air à la surface",
  "TMP-SFC"
);

solarchvision_LAYER LAYER_relhum = new solarchvision_LAYER(
  1.0,
  0,
  0,
  "%",
  "Surface Relative Humidity",
  "Humidité relative à la surface",
  "RELH-SFC"
);

solarchvision_LAYER LAYER_dirnorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Direct normal radiation",
  "Rayonnement direct normal",
  ""
);

solarchvision_LAYER LAYER_difhorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Diffuse horizontal radiation",
  "Diffus rayonnement horizontal",
  ""
);

solarchvision_LAYER LAYER_glohorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Global horizontal radiation",
  "Rayonnement global horizontal",
  ""
);

solarchvision_LAYER LAYER_direffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Direct normal effect <18°C<",
  "Effet direct normal <18°C<",
  ""
);

solarchvision_LAYER LAYER_difeffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Diffuse normal effect <18°C<",
  "Effet diffus normal <18°C<",
  ""
);

solarchvision_LAYER LAYER_precipitation = new solarchvision_LAYER(
  4.0,
  0,
  0,
  "mm",
  "Surface Accumulated Precipitation",
  "Précipitations accumulées à la surface",
  "APCP-SFC"
);

solarchvision_LAYER LAYER_developed = new solarchvision_LAYER(
  1,
  0,
  0,
  "",
  "",
  "",
  ""
);




solarchvision_LAYER[] allLayers = {
  LAYER_windspd200hPa,
  LAYER_thicknesses_1000_500,
  LAYER_heightp500hPa,
  LAYER_ceilingsky,
  LAYER_cloudcover,
  LAYER_winddir,
  LAYER_windspd,
  LAYER_pressure,
  LAYER_drybulb,
  LAYER_relhum,
  LAYER_dirnorrad,
  LAYER_difhorrad,
  LAYER_glohorrad,
  LAYER_direffect,
  LAYER_difeffect,
  LAYER_precipitation,
  LAYER_developed
};


int DevelopLayer_id = 0;
int CurrentLayer_id = 0;
String CurrentLayer_unit = allLayers[0].unit;
String CurrentLayer_name = allLayers[0].name;
String[] CurrentLayer_descriptions = {allLayers[0].descriptions[Language_EN],
                                      allLayers[0].descriptions[Language_FR]};

void changeCurrentLayerTo (int new_id) {

  STUDY.V_scale = allLayers[new_id].V_scale;
  STUDY.V_offset = allLayers[new_id].V_offset;
  STUDY.V_belowLine = allLayers[new_id].V_belowLine;

  DevelopLayer_id = new_id;
  CurrentLayer_id = new_id;

  CurrentLayer_unit = allLayers[new_id].unit;
  CurrentLayer_name = allLayers[new_id].name;
  CurrentLayer_descriptions[Language_EN] = allLayers[new_id].descriptions[Language_EN];
  CurrentLayer_descriptions[Language_FR] = allLayers[new_id].descriptions[Language_FR];

}





int ENSEMBLE_FORECAST_maxDays = 16; // Constant
int ENSEMBLE_OBSERVED_maxDays = 3; // Variable


int CLIMATE_TMYEPW_start = 1;
int CLIMATE_TMYEPW_end = 1;

int CLIMATE_CWEEDS_start = 1970;
int CLIMATE_CWEEDS_end = 2017;

int CLIMATE_CLMREC_start = 2000;
int CLIMATE_CLMREC_end = year();

int ENSEMBLE_FORECAST_start = 1;
int ENSEMBLE_FORECAST_end = 43; // NAEFS:1-43, Note we will append REPS/HRDPS or other scenarions at the end  of this list

int ENSEMBLE_OBSERVED_numNearest = 3;  // <<<<<<<<

int ENSEMBLE_OBSERVED_start = 1;
int ENSEMBLE_OBSERVED_end = ENSEMBLE_OBSERVED_numNearest;

int[] nearest_Station_ENSEMBLE_OBSERVED_id = new int [ENSEMBLE_OBSERVED_numNearest];
float[] nearest_Station_ENSEMBLE_OBSERVED_dist = new float [ENSEMBLE_OBSERVED_numNearest];

int nearest_Station_CLMREC_id = -1;
float nearest_Station_CLMREC_dist = FLOAT_undefined;



int SampleYear_Start = 1980;
int SampleYear_End = year();

int SampleMember_Start = 1;
int SampleMember_End = 43;

int SampleStation_Start = 1;
int SampleStation_End = ENSEMBLE_OBSERVED_numNearest;

float[][][][] CLIMATE_TMYEPW_values;
boolean[][][][] CLIMATE_TMYEPW_flags;

float[][][][] CLIMATE_CWEEDS_values;
boolean[][][][] CLIMATE_CWEEDS_flags;

float[][][][] CLIMATE_CLMREC_values;
boolean[][][][] CLIMATE_CLMREC_flags;

float[][][][] ENSEMBLE_FORECAST_values;
boolean[][][][] ENSEMBLE_FORECAST_flags;

float[][][][] ENSEMBLE_OBSERVED_values;
boolean[][][][] ENSEMBLE_OBSERVED_flags;


boolean CLIMATE_TMYEPW_load = true;
boolean CLIMATE_CWEEDS_load = false;
boolean CLIMATE_CLMREC_load = false;
boolean ENSEMBLE_FORECAST_load = false;
boolean ENSEMBLE_OBSERVED_load = false;


int[] GRIB2_TGL_Selected = {
  1, 0, 0, 0
}; // for levels above ground level
int GRIB2_TGL_number = GRIB2_TGL_Selected.length;


int GRIB2_Year;
int GRIB2_Month;
int GRIB2_Day;
int GRIB2_ModelRun;

int AERIAL_num = 4 * (1 + 6 + 12); // the number of nearest points on the path we want to extract the data

float AERIAL_Center_Longitude = FLOAT_undefined;
float AERIAL_Center_Latitude = FLOAT_undefined;

float[][] AERIAL_Locations;

float[][][][] AERIAL_Data;
int[][][][] AERIAL_Flags;

int GRIB2_Hour_Start = 0;
int GRIB2_Hour_End = 30; //48;
int GRIB2_Hour_Step = 1; //1;

int GRIB2_Layer_Start = 4; //_cloudcover;
int GRIB2_Layer_End = 8; //_drybulb;
int GRIB2_Layer_Step = 1;

int GRIB2_Hour;
int GRIB2_Layer;




String[][] GRIB2_Domains = {
  {
    "GEPS", "ensemble/naefs/grib2/raw", "CMC_naefs-geps-raw", "latlon1p0x1p0", "_allmbrs.grib2", "100"
  }
  , {
    "REPS", "ensemble/reps/15km/grib2/raw", "CMC-reps-srpe-raw", "ps15km", "_allmbrs.grib2", "15"
  }
  , {
    "GDPS", "model_gem_global/25km/grib2/lat_lon", "CMC_glb", "latlon.24x.24", ".grib2", "20"
  }
  , {
    "RDPS", "model_gem_regional/10km/grib2", "CMC_reg", "ps10km", ".grib2", "10"
  }
  , {
    "HRDPS", "model_hrdps/east/grib2", "CMC_hrdps_east", "ps2.5km", "-00.grib2", "2.5"
  }
  , {
    "RDWPS", "model_wave/great_lakes/superior/grib2", "CMC_rdwps_lake-superior", "latlon0.05x0.08", ".grib2", "5"
  }
};


//int GRIB2_DomainSelection = 0; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!
//int GRIB2_DomainSelection = 1; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!
//int GRIB2_DomainSelection = 2; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 3; int GRIB2_maxScenarios = 1;
int GRIB2_DomainSelection = 4; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 5; int GRIB2_maxScenarios = 1; // not working now!

{
  ENSEMBLE_FORECAST_end += GRIB2_maxScenarios;
}


int AERIAL_graphOption = 0;


final int DEV_OP_00 = 8;
final int DEV_OP_01 = 6;
final int DEV_OP_02 = 5;
final int DEV_OP_03 = 7;
final int DEV_OP_04 = 4;
final int DEV_OP_05 = 3;
final int DEV_OP_06 = 10;
final int DEV_OP_07 = 9;
final int DEV_OP_08 = 11;
final int DEV_OP_09 = 0;
final int DEV_OP_10 = 1;
final int DEV_OP_11 = 2;

int Develop_Option = DEV_OP_06; //between 0 - 11...
int Develop_DayHour = 0; //0:accumulative 1:daily(24h) 2:per12h 3:per6h <should be zero to work well with current menues>

boolean DevelopData_update = true;

float Develop_AngleInclination = 45; // 90 = horizontal surface, 0 = Vertical surface
float Develop_AngleOrientation = 0; // 0 = South, 90 = East
































class solarchvision_SHADE {

  private final static String CLASS_STAMP = "SHADE";

  private final static int Surface_Wire = -1;
  private final static int Surface_Base = 0;
  private final static int Surface_White = 1;
  private final static int Surface_Materials = 2;
  private final static int Global_Solar = 3;
  private final static int Vertex_Solar = 4;
  private final static int Vertex_Solid = 5;
  private final static int Vertex_Elevation = 6;

  private final static int Options_num = 7;



  float[] vertexRender_Surface_White (int c) {

    float[] COL = {
      c, c, c, c
    };

    return COL;
  }

  float[] vertexRender_Surface_Materials (int mt) {

    float[] COL = {
      allMaterials.Color[mt][0], allMaterials.Color[mt][1], allMaterials.Color[mt][2], allMaterials.Color[mt][3]
    };

    return COL;
  }


  float[] vertexRender_Vertex_Solar (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float _u = this.vertexU_Vertex_Solar(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);

    float[] COL = {0,0,0,0}; // default color for undefined values

    if (is_defined(_u)) {
      COL = PAINT.getColorStyle(PAL_type, _u);
    }

    return COL;
  }


  float vertexU_Vertex_Solar (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float val = this.get_SolarImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);

    float _u = FLOAT_undefined;

    if (is_defined(val)) {

      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * val);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * val);

      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
    }

    return _u;
  }


  float get_SolarImpact_atXYZ (float x, float y, float z) {

    float v = FLOAT_undefined;

    int q = this.findID_SolarImpact_atXYZ(x, y, z);

    if (q >= 0) {
      v = VertexSolar_amounts[Impact_TYPE][IMPACTS_displayDay][q];
    }

    return v;
  }


  int findID_SolarImpact_atXYZ (float x, float y, float z) {

    int n = -1;

    for (int q = 0; q < VertexSolar_XYZ.length; q++) {

      if (x == VertexSolar_XYZ[q][0]) {
      if (y == VertexSolar_XYZ[q][1]) {
      if (z == VertexSolar_XYZ[q][2]) {
        n = q;
        break;
      }
      }
      }
    }

    return n;
  }





  float[] vertexRender_Vertex_Solid (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float _u = this.vertexU_Vertex_Solid(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);

    float[] COL = PAINT.getColorStyle(PAL_type, _u);

    return COL;
  }


  float vertexU_Vertex_Solid (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    allSolidImpacts.complex = 0;
    float val = allSolidImpacts.get_Impact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);

    float _u = 0.5 + 0.5 * (PAL_multiplier * val);

    if (PAL_direction == -1) _u = 1 - _u;
    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_direction == 2) _u =  0.5 * _u;

    return _u;
  }


  float[] vertexRender_Vertex_Elevation (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float _u = this.vertexU_Vertex_Elevation(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);

    float[] COL = PAINT.getColorStyle(PAL_type, _u);

    return COL;
  }

  float vertexU_Vertex_Elevation (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float _u = 0.5 + 0.5 * (PAL_multiplier * VERTEX_now[2]);

    if (PAL_direction == -1) _u = 1 - _u;
    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_direction == 2) _u =  0.5 * _u;

    return _u;
  }


  float[] vertexRender_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_type, int PAL_direction, float PAL_multiplier) {

    float _u = this.vertexU_Global_Solar(VERTEX_now, VERTEX_prev, VERTEX_next, PAL_type, PAL_direction, PAL_multiplier);

    float[] COL = {63,63,63,127}; // default color for undefined values

    if (is_defined(_u)) {
      COL = PAINT.getColorStyle(PAL_type, _u);
    }

    return COL;
  }

  float vertexU_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_type, int PAL_direction, float PAL_multiplier) {

    PVector U = new PVector(VERTEX_next[0] - VERTEX_now[0], VERTEX_next[1] - VERTEX_now[1], VERTEX_next[2] - VERTEX_now[2]);
    PVector V = new PVector(VERTEX_prev[0] - VERTEX_now[0], VERTEX_prev[1] - VERTEX_now[1], VERTEX_prev[2] - VERTEX_now[2]);
    PVector UV = U.cross(V);
    float[] W = {
      UV.x, UV.y, UV.z
    };
    W = funcs.vec3_unit(W);

    float Alpha = funcs.asin_ang(W[2]);
    float Beta = funcs.atan2_ang(W[1], W[0]) + 90;

    int a = int((Alpha + 90) / Sky3D.stp_slp);
    int b = int(Beta / Sky3D.stp_dir);

    if (a < 0) a += int(180 / Sky3D.stp_slp);
    if (b < 0) b += int(360 / Sky3D.stp_dir);
    if (a > int(180 / Sky3D.stp_slp)) a -= int(180 / Sky3D.stp_slp);
    if (b > int(360 / Sky3D.stp_dir)) b -= int(360 / Sky3D.stp_dir);

    float valuesSUM = GlobalSolar[Impact_TYPE][IMPACTS_displayDay][a][b];

    float _u = FLOAT_undefined;

    if (is_defined(valuesSUM)) {

      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);

      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
    }

    return _u;
  }



  int get_PAL_type () {

    int PAL_type = 0;

    if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
        (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

      if (Impact_TYPE == Impact_ACTIVE) PAL_type = allFaces.ACTIVE_pallet_CLR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_type = allFaces.PASSIVE_pallet_CLR;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_type = allSolids.pallet_CLR;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_type = Land3D.pallet_CLR;
    }

    return PAL_type;
  }


  int get_PAL_direction () {

    int PAL_direction = 1;

    if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
        (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

      if (Impact_TYPE == Impact_ACTIVE) PAL_direction = allFaces.ACTIVE_pallet_DIR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_direction = allFaces.PASSIVE_pallet_DIR;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_direction = allSolids.pallet_DIR;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_direction = Land3D.pallet_DIR;
    }

    return PAL_direction;
  }


  float get_PAL_multiplier () {

    float PAL_multiplier = 1;

    if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
        (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = allFaces.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = allFaces.PASSIVE_pallet_MLT;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_multiplier = allSolids.pallet_MLT;
    }

    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_multiplier = Land3D.pallet_MLT;
    }

    return PAL_multiplier;
  }


}

solarchvision_SHADE SHADE = new solarchvision_SHADE();






class solarchvision_WIN3D {

  private final static String CLASS_STAMP = "WIN3D";

  // scales
  float scale;
  // (top-left) corner
  int cX = SOLARCHVISION_pixel_W;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  // width and height
  int dX = SOLARCHVISION_pixel_W;
  int dY = SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);

  float position_X = 0;
  float position_Y = 5;
  float position_Z = 60;
  float position_T = 1.0;

  float rotation_X = 90; //90; //75; //0;
  float rotation_Y = 0;
  float rotation_Z = 90; //0; //180; //135;
  float rotation_T = 5.0;

  float Zoom = 90.0; //60.0; // / (SOLARCHVISION_pixel_H / 300.0);

  int ViewType = 1; // 0: Ortho 1: Perspective

  boolean update = true;
  boolean include = true;

  boolean fullPeriod_IMG = false;
  boolean record_IMG = false;
  boolean record_AUTO = false;

  float ImageScale = 1.0;

  float CAM_x;
  float CAM_y;
  float CAM_z;
  float CAM_fov;
  float CAM_dist;

  float CAM_clipNear = 0.01;
  float CAM_clipFar = 2000000000.0;

  float refScale = 100; // it improves displaying the shaded scene!

  int currentCamera = 0; // 0 = Free Viewport | etc.= Saved Viewport

  int UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  int UI_OptionXorY = 0; // 0-1
  int UI_TaskModifyParameter = 0; //to modify objects with several parameters e.g. allModel1Ds


  int FacesShade = SHADE.Surface_Materials; //Shade_Surface_White; // <<<<<


  PGraphics graphics;

  void put_3DViewport () {

    if (this.ViewType == 1) {

      float aspect = 1.0 / this.view_R;

      float zFar = this.CAM_dist * this.CAM_clipFar;
      float zNear = this.CAM_dist * this.CAM_clipNear;

      this.graphics.perspective(this.CAM_fov, aspect, zNear, zFar);

      this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
    } else {

      float ZOOM = WIN3D.Orthographic_ZOOM();

      this.graphics.ortho(ZOOM * this.dX * -1, ZOOM * this.dX * 1, ZOOM  * this.dY * -1, ZOOM  * this.dY * 1, 0.00001, 100000);

      this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
    }

    this.graphics.translate(this.position_X * this.scale, this.position_Y * this.scale, this.position_Z * this.scale);

    this.graphics.rotateX(this.rotation_X * PI / 180);
    this.graphics.rotateZ(this.rotation_Z * PI / 180);
  }



  void drawView () {

    if (this.update) {
      if (Select3D.update_BoundingBox) {
        Select3D.calculate_BoundingBox();
      }

      if (this.record_IMG) this.ImageScale = 1; //2; //3;
      else this.ImageScale = 1;

      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;
      //////////////////////////////////

      if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P3D);
      }

      int firstDay = IMPACTS_displayDay;
      int lastDay = IMPACTS_displayDay;

      int firstImpact = Impact_TYPE;
      int lastImpact = Impact_TYPE;

      if (this.fullPeriod_IMG) {
        this.fullPeriod_IMG = false;

        firstDay = 0;
        lastDay = STUDY.j_End;

        firstImpact = 0;
        lastImpact = numberOfImpactVariations - 1;
      }

      int keep_Impact_TYPE = Impact_TYPE;
      int keep_IMPACTS_displayDay = IMPACTS_displayDay;
      for (IMPACTS_displayDay = lastDay; IMPACTS_displayDay >= firstDay; IMPACTS_displayDay--) {
        for (Impact_TYPE = lastImpact; Impact_TYPE >= firstImpact; Impact_TYPE--) {

          this.graphics.beginDraw();

          this.scale = this.dY / this.refScale; // fits field of view to window's height

          this.graphics.background(233);

          this.graphics.fill(127);
          this.graphics.strokeWeight(0);

          this.graphics.pushMatrix();

          this.graphics.hint(ENABLE_DEPTH_TEST);

          WIN3D.record_last3DViewport();

          WIN3D.transform_3DViewport();

          WIN3D.put_3DViewport();

          Sky3D.draw(TypeWindow.WIN3D);

          Sun3D.drawPattern(TypeWindow.WIN3D, 0, 0, 0, 0.975 * Sky3D.scale);

          Sun3D.drawPath(TypeWindow.WIN3D, 0, 0, 0, 0.975 * Sky3D.scale);

          Sun3D.drawGrid(TypeWindow.WIN3D, 0, 0, 0, 0.975 * Sky3D.scale, 0, 360);

          Sun3D.draw();

          Moon3D.draw();

          Earth3D.draw(TypeWindow.WIN3D);

          Land3D.draw(TypeWindow.WIN3D);

          Tropo3D.draw(TypeWindow.WIN3D, STUDY.i_Start, STUDY.i_End);

          allFaces.draw(TypeWindow.WIN3D);

          allCurves.draw(TypeWindow.WIN3D);

          allPoints.draw();

          allModel1Ds.draw(TypeWindow.WIN3D);

          allWindRoses.draw();

          allSections.draw(TypeWindow.WIN3D);

          allCameras.draw();

          allSolids.draw();

          allSolidImpacts.draw_lines();

          allSolidImpacts.draw_points();

          allModel2Ds.draw(TypeWindow.WIN3D);

          allWindFlows.draw(TypeWindow.WIN3D);

          WIN3D.draw_AERIAL();

          this.graphics.hint(DISABLE_DEPTH_TEST);

          if ((this.record_IMG) || (this.record_AUTO)) {
          }
          else {
            WIN3D.draw_referencePivot();
          }

          this.graphics.popMatrix();


          this.drawPallet();

          this.graphics.endDraw();

          if ((this.record_IMG) || (this.record_AUTO)) {
            String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP));

            if (Impact_TYPE == Impact_ACTIVE) {
              myFile += "_RAD";
            }
            if (Impact_TYPE == Impact_PASSIVE) {
              myFile += "_EFF";
            }
            myFile += "_" + importedObjectName;
            myFile += ".jpg";

            this.graphics.save(myFile);
            println("File created:" + myFile);
          }
        }
      }
      IMPACTS_displayDay = keep_IMPACTS_displayDay;
      Impact_TYPE = keep_Impact_TYPE;

      imageMode(CORNER);
      image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);



      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;

      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;
      //////////////////////////////////

      if (this.ImageScale != 1) {
        this.graphics = createGraphics(this.dX, this.dY, P3D);
        this.updated();
      } else {
        this.updated();

        SOLARCHVISION_draw_Perspective_Internally();
      }

    }
  }



  void draw_referencePivot () {


    this.graphics.strokeWeight(3);
    this.graphics.stroke(127, 0, 255, 127);
    this.graphics.fill(127, 0, 255, 127);

    float[] P = Select3D.getPivot();

    float x = P[0];
    float y = P[1];
    float z = P[2];


    this.graphics.pushMatrix();
    this.graphics.translate(x * this.scale, -y * this.scale, z * this.scale);

    //this.graphics.sphere(1); // <<<<<< size

    this.graphics.popMatrix();

    this.graphics.strokeWeight(0);
  }



  void drawPallet () {

    boolean draw_pal = false;

    int PAL_type = 0;
    int PAL_direction = 1;
    float PAL_multiplier = 1;

    if ((this.FacesShade == SHADE.Global_Solar) ||
        (this.FacesShade == SHADE.Vertex_Solar)) {

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = allFaces.ACTIVE_pallet_CLR;
        PAL_direction = allFaces.ACTIVE_pallet_DIR;
        PAL_multiplier = allFaces.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = allFaces.PASSIVE_pallet_CLR;
        PAL_direction = allFaces.PASSIVE_pallet_DIR;
        PAL_multiplier = allFaces.PASSIVE_pallet_MLT;
      }

      draw_pal = true;
    }

    if (this.FacesShade == SHADE.Vertex_Elevation) {

      PAL_type = Land3D.pallet_CLR;
      PAL_direction = Land3D.pallet_DIR;
      PAL_multiplier = Land3D.pallet_MLT;

      draw_pal = true;
    }

    if (this.FacesShade == SHADE.Vertex_Solid) {

      PAL_type = allSolids.pallet_CLR;
      PAL_direction = allSolids.pallet_DIR;
      PAL_multiplier = allSolids.pallet_MLT;

      draw_pal = true;
    }

    if (draw_pal) {

      float the_scale = 1;

      if (this.ViewType == 1) {
        the_scale *= (0.5 / tan(0.5 * this.CAM_fov));
      } else {
        float ZOOM = WIN3D.Orthographic_ZOOM();
        the_scale *= (0.5 / ZOOM);
      }

      this.graphics.pushMatrix();

      this.CAM_fov = this.Zoom * PI / 180;

      this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);

      if (this.ViewType == 1) {

        float aspect = 1.0 / this.view_R;

        float zFar = this.CAM_dist * 1000;
        float zNear = this.CAM_dist * 0.001;

        this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
      } else {

        float ZOOM = WIN3D.Orthographic_ZOOM();

        this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
      }

      float pal_length = 1 * SOLARCHVISION_pixel_H * this.ImageScale / the_scale;

      float y1 = -0.2 * (pal_length / 11.0) + (0.4 * this.dY / the_scale);
      float y2 = y1 + 0.4 * (pal_length / 11.0);

      float txtSize = y2 - y1;

      float y = 0.5 * (y1 + y2) - 0.1 * txtSize;

      for (int q = 0; q < 11; q++) {

        float x1 = -0.5 * pal_length + q * (pal_length / 11.0);
        float x2 = x1 + (pal_length / 11.0);

        float x = 0.5 * (x1 + x2);

        float _u = 0.2 * q - 0.5;

        if ((this.FacesShade == SHADE.Global_Solar) ||
            (this.FacesShade == SHADE.Vertex_Solar)) {

          if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
        }

        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_type, _u);

        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

        this.graphics.strokeWeight(0);

        this.graphics.beginShape();
        this.graphics.vertex(x1, y1, 0);
        this.graphics.vertex(x1, y2, 0);
        this.graphics.vertex(x2, y2, 0);
        this.graphics.vertex(x2, y1, 0);
        this.graphics.endShape(CLOSE);

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }

        this.graphics.textSize(txtSize);
        this.graphics.textAlign(CENTER, CENTER);



        if ((this.FacesShade == SHADE.Global_Solar) ||
            (this.FacesShade == SHADE.Vertex_Solar)) {

          if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), x, y, 0);
          if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), x, y, 0);
        }

        if (this.FacesShade == SHADE.Vertex_Elevation) {
          this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), x, y, 0);
        }

        if (this.FacesShade == SHADE.Vertex_Solid) {
          this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), x, y, 0);
        }
      }

      this.graphics.noStroke();
      this.graphics.fill(0);

      this.graphics.textAlign(LEFT, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(" kW/m²", 0.5 * pal_length, y, 0);
      if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(" %kW°C/m²", 0.5 * pal_length, y, 0);

      String txt = "SOLARCHVISION ";

      if (Impact_TYPE == Impact_ACTIVE) txt += "active model ";
      if (Impact_TYPE == Impact_PASSIVE) txt += "passive model ";

      if (IMPACTS_displayDay != 0) {
        txt += TIME.getDayText((IMPACTS_displayDay - 1) * STUDY.perDays + 286 + TIME.beginDay);
      }
      else {
        txt += TIME.getDayText( STUDY.j_Start    * STUDY.perDays + 286 + TIME.beginDay) + " - ";
        txt += TIME.getDayText((STUDY.j_End - 1) * STUDY.perDays + 286 + TIME.beginDay);
      }

      txt += ", 3D-model: " + importedObjectName;

      this.graphics.textAlign(CENTER, CENTER);
      this.graphics.text(txt, 0, y1 - 1.0 * txtSize, 0);

      this.graphics.popMatrix();
    }
  }







  void draw_AERIAL () {
    this.graphics.sphereDetail(6, 4);

    if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {
      for (int n = 0; n < AERIAL_num; n++) {

        float _tgl = AERIAL_Locations[n][2];
        float _lat = AERIAL_Locations[n][1];
        float _lon = AERIAL_Locations[n][0];
        if (_lon > 180) _lon -= 360; // << important!

        double du = ((_lon - AERIAL_Center_Longitude) / 180.0) * (PI * DOUBLE_r_Earth);
        double dv = ((_lat - AERIAL_Center_Latitude) / 180.0) * (PI * DOUBLE_r_Earth);

        float x = 0.1 * (float) du * funcs.cos_ang((float) AERIAL_Center_Latitude); // <<<<<<<<<<<<<<<<<<<< 0.1
        float y = 0.1 * (float) dv;                                           // <<<<<<<<<<<<<<<<<<<< 0.1
        float z = _tgl - HeightAboveGround;

        if (AERIAL_graphOption == 0) {
          //-----------------------------
          int PAL_type = 6; //12;
          int PAL_direction = -1;
          float PAL_multiplier = 1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o++) {

            float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];

            if (is_defined(_val)) {

              float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              float[] COL = PAINT.getColorStyle(PAL_type, _u);

              this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
              this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
              //this.graphics.noFill();

              this.graphics.strokeWeight(0); // 2; <<<<<<<<<

              float R = 5;
              /*
               this.graphics.beginShape();
               for (float teta = 0; teta < 360; teta += 360.0 / 6.0) {
               this.graphics.vertex((x + R * funcs.cos_ang(teta)) * OBJECTS_scale * this.scale, (y + R * funcs.sin_ang(teta)) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
               }
               this.graphics.endShape(CLOSE);
               */
              this.graphics.pushMatrix();
              this.graphics.translate(x * OBJECTS_scale * this.scale, y * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.sphere(R);
              this.graphics.popMatrix();
            }
          }
        }

        if (AERIAL_graphOption == 1) {

          //-----------------------------
          int PAL_type = 1;//12;
          int PAL_direction = 1;//-1;
          float PAL_multiplier = 0.1;//1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o++) {

            //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
            float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

            if (is_defined(_val)) {

              float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
              float D_teta = 15;
              float R = 5.0 * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

              float R_in = 0.0 * R;
              float x1 = (R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta)));
              float y1 = (R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta)));
              float x2 = (R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta)));
              float y2 = (R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)));

              float x4 = (R * funcs.cos_ang(90 - (teta - 0.5 * D_teta)));
              float y4 = (R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta)));
              float x3 = (R * funcs.cos_ang(90 - (teta + 0.5 * D_teta)));
              float y3 = (R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)));

              //float ox = -0.5 * (R * funcs.cos_ang(90 - teta));
              //float oy = -0.5 * (R * -funcs.sin_ang(90 - teta));
              //float ox = -1 * (R * funcs.cos_ang(90 - teta));
              //float oy = -1 * (R * -funcs.sin_ang(90 - teta));
              float ox = -2 * (R * funcs.cos_ang(90 - teta)) / 3.0;
              float oy = -2 * (R * -funcs.sin_ang(90 - teta)) / 3.0;

              float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              float[] COL = PAINT.getColorStyle(PAL_type, _u);

              this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
              //this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
              this.graphics.noFill();

              this.graphics.strokeWeight(2); // 0; <<<<<<<<<

              this.graphics.beginShape();
              this.graphics.vertex((x + x1 + ox) * OBJECTS_scale * this.scale, (y + y1 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x2 + ox) * OBJECTS_scale * this.scale, (y + y2 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x3 + ox) * OBJECTS_scale * this.scale, (y + y3 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x4 + ox) * OBJECTS_scale * this.scale, (y + y4 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.endShape(CLOSE);
            }
          }
        }
      }
    }
  }




  void keyPressed (KeyEvent e) {

    if (e.isAltDown()) {
    } else if (e.isControlDown()) {
      if (key == CODED) {
        switch(keyCode) {
        }
      } else {
        switch(key) {
        case '.' :
          this.position_X = 0;
          this.position_Y = 0;
          //this.Zoom = 60;
          this.revise();
          ROLLOUT.revise();
          break;


        case ' ' :
          allSolarImpacts.render_Shadows_selectedSections();
          this.revise();
          break;

        case ENTER :
          allSolarImpacts.calculate_Impact_selectedSections();
          this.revise();
          break;
        }
      }
    }

    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

      if (key == CODED) {
        switch(keyCode) {

        case DOWN :
          WIN3D.rotateZ_3DViewport_around_Selection(this.rotation_T);
          this.revise();
          ROLLOUT.revise();
          break;

        case LEFT :
          WIN3D.rotateXY_3DViewport_around_Selection(-this.rotation_T);
          this.revise();
          ROLLOUT.revise();
          break;

        case RIGHT :
          WIN3D.rotateXY_3DViewport_around_Selection(this.rotation_T);
          this.revise();
          ROLLOUT.revise();
          break;

        case UP :
          WIN3D.rotateZ_3DViewport_around_Selection(-this.rotation_T);
          this.revise();
          ROLLOUT.revise();
          break;

        case 33:
          this.currentCamera += 1;
          if (this.currentCamera > allCameras.num - 1) this.currentCamera = 0;
          WIN3D.apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();

          this.revise();
          ROLLOUT.revise();
          break;

        case 34:
          this.currentCamera -= 1;
          if (this.currentCamera < 0) this.currentCamera = allCameras.num - 1;
          WIN3D.apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();

          this.revise();
          ROLLOUT.revise();
          break;


        case 155: // INSERT
          Select3D.deselectAll();

          this.revise();
          ROLLOUT.revise();
          break;
        }
      } else {
        switch(key) {

        case TAB:
          if (e.isShiftDown() == true) {
            Impact_TYPE = (Impact_TYPE + 1) % numberOfImpactVariations;
            if (this.FacesShade == SHADE.Global_Solar) GlobalSolar_rebuild_array = true;
            if (this.FacesShade == SHADE.Vertex_Solar) VertexSolar_rebuild_array = true;

            this.revise();
            ROLLOUT.revise();
          }
          break;

        case DELETE:
          Delete3D.selection();

          this.revise();
          ROLLOUT.revise();

          break;

        case ',' :
          if (this.ViewType == 1) {
            this.position_Z += this.position_T * OBJECTS_scale;
            this.revise();
            ROLLOUT.revise();
          } else {
            this.Zoom /= pow(2.0, 0.25);
            this.revise();
            ROLLOUT.revise();
          }
          break;

        case '.' :
          if (this.ViewType == 1) {
            this.position_Z -= this.position_T * OBJECTS_scale;
            this.revise();
            ROLLOUT.revise();
          } else {
            this.Zoom *= pow(2.0, 0.25);
            this.revise();
            ROLLOUT.revise();
          }
          break;

        case '0' :
          if (this.ViewType == 1) {
            this.position_Z += this.position_T * OBJECTS_scale;
            this.revise();
            ROLLOUT.revise();
          } else {
            this.Zoom /= pow(2.0, 0.25);
            this.revise();
            ROLLOUT.revise();
          }
          break;

        case '5' :
          WIN3D.look_3DViewport_towards_Selection();
          this.revise();
          ROLLOUT.revise();
          break;

        case '4' :
          this.rotation_Z += this.rotation_T;
          WIN3D.reverseTransform_3DViewport();
          this.revise();
          ROLLOUT.revise();
          break;
        case '6' :
          this.rotation_Z -= this.rotation_T;
          WIN3D.reverseTransform_3DViewport();
          this.revise();
          ROLLOUT.revise();
          break;
        case '8' :
          this.rotation_X -= this.rotation_T;
          WIN3D.reverseTransform_3DViewport();
          this.revise();
          ROLLOUT.revise();
          break;
        case '2' :
          this.rotation_X += this.rotation_T;
          WIN3D.reverseTransform_3DViewport();
          this.revise();
          ROLLOUT.revise();
          break;

        case '1' :
          this.position_X += this.position_T * OBJECTS_scale;
          this.revise();
          ROLLOUT.revise();
          break;
        case '3' :
          this.position_X -= this.position_T * OBJECTS_scale;
          this.revise();
          ROLLOUT.revise();
          break;
        case '9' :
          this.position_Y += this.position_T * OBJECTS_scale;
          this.revise();
          ROLLOUT.revise();
          break;
        case '7' :
          this.position_Y -= this.position_T * OBJECTS_scale;
          this.revise();
          ROLLOUT.revise();
          break;


        case '*' :
          WIN3D.move_3DViewport_towards_Selection(2.0);
          this.revise();
          ROLLOUT.revise();
          break;
        case '/' :
          WIN3D.move_3DViewport_towards_Selection(0.5);
          this.revise();
          ROLLOUT.revise();
          break;


        case '+' :
          this.Zoom = 2 * funcs.atan_ang((1.0 / 1.1) * funcs.tan_ang(0.5 * this.Zoom));
          this.revise();
          ROLLOUT.revise();
          break;
        case '-' :
          this.Zoom = 2 * funcs.atan_ang((1.1 / 1.0) * funcs.tan_ang(0.5 * this.Zoom));
          this.revise();
          ROLLOUT.revise();
          break;

        case ']' :
          IMPACTS_displayDay += 1;
          if (IMPACTS_displayDay > STUDY.j_End) IMPACTS_displayDay = 0;
          this.revise();
          ROLLOUT.revise();
          break;
        case '[' :
          IMPACTS_displayDay -= 1;
          if (IMPACTS_displayDay < 0) IMPACTS_displayDay = STUDY.j_End;
          this.revise();
          ROLLOUT.revise();
          break;


        case ENTER:
          if (this.FacesShade == SHADE.Global_Solar) GlobalSolar_rebuild_array = true;
          if (this.FacesShade == SHADE.Vertex_Solar) VertexSolar_rebuild_array = true;
          this.revise();
          ROLLOUT.revise();
          break;

        case ' ':
          SOLARCHVISION_RecordFrame();
          ROLLOUT.revise();
          break;

        }

      }
    }
  }


  float Orthographic_ZOOM () {

    float ZOOM = 0.5 * this.Zoom * PI / 180;

    ZOOM *= pow(pow(this.position_X, 2) + pow(this.position_Y, 2) + pow(this.position_Z, 2), 0.5);

    ZOOM /= this.refScale;

    return ZOOM;
  }



  void look_3DViewport_towards_Direction (float Image_X, float Image_Y) {

    WIN3D.lookXY_3DViewport_towards_Direction(Image_X, Image_Y);
    WIN3D.lookZ_3DViewport_towards_Direction(Image_X, Image_Y);
  }

  void lookXY_3DViewport_towards_Direction (float Image_X, float Image_Y) {

    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;

    float[] ray_end = WIN3D.calculate_Click3D(0, 0);
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;

    float[] P = WIN3D.calculate_Click3D(Image_X, Image_Y);

    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;


    this.rotation_Z += funcs.atan2_ang((yB - yO), (xB - xO)) - funcs.atan2_ang((yA - yO), (xA - xO));

    WIN3D.reverseTransform_3DViewport();
  }


  void lookZ_3DViewport_towards_Direction (float Image_X, float Image_Y) {

    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;

    float[] ray_end = WIN3D.calculate_Click3D(0, 0);
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;

    float[] P = WIN3D.calculate_Click3D(Image_X, Image_Y);

    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;

    this.rotation_X += funcs.atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - funcs.atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));

    WIN3D.reverseTransform_3DViewport();
  }


  void look_3DViewport_towards_Selection () {

    WIN3D.lookXY_3DViewport_towards_Selection();
    WIN3D.lookZ_3DViewport_towards_Selection();
  }

  void lookXY_3DViewport_towards_Selection () {

    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;

    float[] ray_end = WIN3D.calculate_Click3D(0, 0);
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;

    float[] P = Select3D.getPivot();

    float xB = P[0];
    float yB = P[1];
    float zB = P[2];


    this.rotation_Z += funcs.atan2_ang((yB - yO), (xB - xO)) - funcs.atan2_ang((yA - yO), (xA - xO));

    WIN3D.reverseTransform_3DViewport();
  }


  void lookZ_3DViewport_towards_Selection () {

    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;

    float[] ray_end = WIN3D.calculate_Click3D(0, 0);
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;

    float[] P = Select3D.getPivot();

    float xB = P[0];
    float yB = P[1];
    float zB = P[2];

    this.rotation_X += funcs.atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - funcs.atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));

    WIN3D.reverseTransform_3DViewport();
  }

  void move_3DViewport_towards_Mouse (float t) {

    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;

    float Image_X = mouseX - (this.cX + 0.5 * this.dX);
    float Image_Y = mouseY - (this.cY + 0.5 * this.dY);

    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);
    float xO = ray_end[0] / OBJECTS_scale;
    float yO = ray_end[1] / OBJECTS_scale;
    float zO = ray_end[2] / OBJECTS_scale;

    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;

    float xB = xO + t * dx;
    float yB = yO + t * dy;
    float zB = zO + t * dz;

    this.CAM_x = xB * OBJECTS_scale;
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;

    WIN3D.reverseTransform_3DViewport();


    //this.position_T *= t; // just to adjust panning better
  }

  void move_3DViewport_towards_Selection (float t) {

    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;

    float[] P = Select3D.getPivot();

    float xO = P[0];
    float yO = P[1];
    float zO = P[2];

    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;

    float xB = xO + t * dx;
    float yB = yO + t * dy;
    float zB = zO + t * dz;

    this.CAM_x = xB * OBJECTS_scale;
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;

    WIN3D.reverseTransform_3DViewport();


    //this.position_T *= t; // just to adjust panning better
  }

  void rotateZ_3DViewport_around_Selection (float t) {

    this.rotation_X += t;

    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;

    float[] P = Select3D.getPivot();

    float xO = P[0];
    float yO = P[1];
    float zO = P[2];

    float xB = xA - xO;
    float yB = yA - yO;
    float zB = zA - zO;

    // rotate to make it on yz plane

    float xC = xB * funcs.cos_ang(-this.rotation_Z) - yB * funcs.sin_ang(-this.rotation_Z);
    float yC = xB * funcs.sin_ang(-this.rotation_Z) + yB * funcs.cos_ang(-this.rotation_Z);
    float zC = zB;

    // rotate it on yz plane

    float xD = xC;
    float yD = yC * funcs.cos_ang(t) - zC * funcs.sin_ang(t);
    float zD = yC * funcs.sin_ang(t) + zC * funcs.cos_ang(t);

    // rotate to back from yz plane

    float xE = xD * funcs.cos_ang(this.rotation_Z) - yD * funcs.sin_ang(this.rotation_Z);
    float yE = xD * funcs.sin_ang(this.rotation_Z) + yD * funcs.cos_ang(this.rotation_Z);
    float zE = zD;

    float xF = xE + xO;
    float yF = yE + yO;
    float zF = zE + zO;

    this.CAM_x = xF * OBJECTS_scale;
    this.CAM_y = yF * OBJECTS_scale;
    this.CAM_z = zF * OBJECTS_scale;

    WIN3D.reverseTransform_3DViewport();
  }


  void rotateXY_3DViewport_around_Selection (float t) {

    this.rotation_Z += t;

    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;

    float[] P = Select3D.getPivot();

    float xO = P[0];
    float yO = P[1];
    float zO = P[2];

    float dx = xA - xO;
    float dy = yA - yO;

    float xB = xO + dx * funcs.cos_ang(t) - dy * funcs.sin_ang(t);
    float yB = yO + dx * funcs.sin_ang(t) + dy * funcs.cos_ang(t);
    float zB = zA;

    this.CAM_x = xB * OBJECTS_scale;
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;

    WIN3D.reverseTransform_3DViewport();
  }


  void rotateXY_3DViewport_around_LandIntersection (float t) {

    float Image_X = SOLARCHVISION_X_click1 - (this.cX + 0.5 * this.dX);
    float Image_Y = SOLARCHVISION_Y_click1 - (this.cY + 0.5 * this.dY);

    float[] ray_direction = new float [3];

    float[] ray_start = {
      this.CAM_x, this.CAM_y, this.CAM_z
    };

    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (this.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];


    float[] RxP = Land3D.intersect(ray_start, ray_direction);

    if (RxP[0] >= 0) {

      float xO = RxP[1] / OBJECTS_scale;
      float yO = RxP[2] / OBJECTS_scale;
      float zO = RxP[3] / OBJECTS_scale;

      float xA = ray_start[0];
      float yA = ray_start[1];
      float zA = ray_start[2];

      float dx = xA - xO;
      float dy = yA - yO;

      this.rotation_Z += t;

      float xB = xO + dx * funcs.cos_ang(t) - dy * funcs.sin_ang(t);
      float yB = yO + dx * funcs.sin_ang(t) + dy * funcs.cos_ang(t);
      float zB = zA;

      this.CAM_x = xB * OBJECTS_scale;
      this.CAM_y = yB * OBJECTS_scale;
      this.CAM_z = zB * OBJECTS_scale;

      WIN3D.reverseTransform_3DViewport();
    }
  }


  void reverseTransform_3DViewport () { // computing this.position_X, this.position_Y and this.position_Z from new set of camera start and end points.

    float px, py, pz;

    px = this.CAM_x;
    py = this.CAM_y;
    pz = this.CAM_z;

    float CAM_x1, CAM_y1, CAM_z1;

    CAM_z1 = pz;
    CAM_x1 = px * funcs.cos_ang(-this.rotation_Z) - py * funcs.sin_ang(-this.rotation_Z);
    CAM_y1 = px * funcs.sin_ang(-this.rotation_Z) + py * funcs.cos_ang(-this.rotation_Z);

    px = CAM_x1;
    py = CAM_y1;
    pz = CAM_z1;

    CAM_x1 = px;
    CAM_y1 = py * funcs.cos_ang(-this.rotation_X) - pz * funcs.sin_ang(-this.rotation_X);
    CAM_z1 = py * funcs.sin_ang(-this.rotation_X) + pz * funcs.cos_ang(-this.rotation_X);


    float CAM_x2, CAM_y2, CAM_z2;

    this.CAM_fov = this.Zoom * PI / 180;

    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);

    CAM_x2 = 0;
    CAM_y2 = 0;
    CAM_z2 = this.CAM_dist;

    CAM_x2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_y2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_z2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);


    this.position_X = CAM_x2 - CAM_x1;
    this.position_Y = -(CAM_y2 - CAM_y1);
    this.position_Z = CAM_z2 - CAM_z1;
  }


  void record_last3DViewport () {

    allCameras.set_posX(this.currentCamera, this.position_X);
    allCameras.set_posY(this.currentCamera, this.position_Y);
    allCameras.set_posZ(this.currentCamera, this.position_Z);
    allCameras.set_posT(this.currentCamera, this.position_T);
    allCameras.set_rotX(this.currentCamera, this.rotation_X);
    allCameras.set_rotY(this.currentCamera, this.rotation_Y);
    allCameras.set_rotZ(this.currentCamera, this.rotation_Z);
    allCameras.set_rotT(this.currentCamera, this.rotation_T);
    allCameras.set_zoom(this.currentCamera, this.Zoom);
    allCameras.set_type(this.currentCamera, this.ViewType);
  }


  void apply_currentCamera () {

    this.position_X = allCameras.get_posX(this.currentCamera);
    this.position_Y = allCameras.get_posY(this.currentCamera);
    this.position_Z = allCameras.get_posZ(this.currentCamera);
    this.position_T = allCameras.get_posT(this.currentCamera);
    this.rotation_X = allCameras.get_rotX(this.currentCamera);
    this.rotation_Y = allCameras.get_rotY(this.currentCamera);
    this.rotation_Z = allCameras.get_rotZ(this.currentCamera);
    this.rotation_T = allCameras.get_rotT(this.currentCamera);
    this.Zoom       = allCameras.get_zoom(this.currentCamera);
    this.ViewType   = allCameras.get_type(this.currentCamera);
  }


  void transform_3DViewport () {

    this.CAM_fov = this.Zoom * PI / 180;

    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);

    this.CAM_x = 0;
    this.CAM_y = 0;
    this.CAM_z = this.CAM_dist;


    this.CAM_x *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_y *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_z *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);

    this.CAM_x -= this.position_X;
    this.CAM_y += this.position_Y;
    this.CAM_z -= this.position_Z;

    float px, py, pz;

    px = this.CAM_x;
    py = this.CAM_y * funcs.cos_ang(this.rotation_X) - this.CAM_z * funcs.sin_ang(this.rotation_X);
    pz = this.CAM_y * funcs.sin_ang(this.rotation_X) + this.CAM_z * funcs.cos_ang(this.rotation_X);

    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;

    pz = this.CAM_z;
    px = this.CAM_x * funcs.cos_ang(this.rotation_Z) - this.CAM_y * funcs.sin_ang(this.rotation_Z);
    py = this.CAM_x * funcs.sin_ang(this.rotation_Z) + this.CAM_y * funcs.cos_ang(this.rotation_Z);

    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;

    //println("Camera:", nf(this.CAM_x,0,4), nf(this.CAM_y,0,4), nf(this.CAM_z,0,4));
  }



  float[] calculate_Click3D (float Image_X, float Image_Y) {

    float PNT_x = FLOAT_undefined;
    float PNT_y = FLOAT_undefined;
    float PNT_z = FLOAT_undefined;

    if (this.ViewType == 1) {

      PNT_z = 0.5/ tan(0.5 * PI / 3.0); //100; // for perspective: any value the plane we need the results on!

      PNT_x = PNT_z * Image_X / ((0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale);
      PNT_y = PNT_z * -Image_Y / ((0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale);
    } else {
      float ZOOM = this.Orthographic_ZOOM();

      PNT_z = (0.5 * this.refScale) / tan(0.5 * PI / 3.0); // for orthographic: should be this.

      PNT_x = ZOOM * Image_X / (0.5 * this.scale);
      PNT_y = ZOOM * -Image_Y / (0.5 * this.scale);
    }

    float px, py, pz;

    px = PNT_x;
    py = PNT_y * funcs.cos_ang(-this.rotation_X) - PNT_z * funcs.sin_ang(-this.rotation_X);
    pz = PNT_y * funcs.sin_ang(-this.rotation_X) + PNT_z * funcs.cos_ang(-this.rotation_X);

    PNT_x = px;
    PNT_y = py;
    PNT_z = pz;

    pz = PNT_z;
    px = PNT_x * funcs.cos_ang(this.rotation_Z) - PNT_y * funcs.sin_ang(this.rotation_Z);
    py = PNT_x * funcs.sin_ang(this.rotation_Z) + PNT_y * funcs.cos_ang(this.rotation_Z);

    PNT_x = px;
    PNT_y = py;
    PNT_z = pz;

    PNT_x += this.CAM_x;
    PNT_y += this.CAM_y;
    PNT_z -= this.CAM_z;

    float[] return_array = {
      PNT_x, PNT_y, -PNT_z
    };

    return return_array;
  }




  float[] calculate_Perspective_Internally (float x, float y, float z) {

    float Image_X = FLOAT_undefined;
    float Image_Y = FLOAT_undefined;
    float Image_Z = -FLOAT_undefined; // negative so that it automatically illuminated by Draw function


    float px, py, pz;

    x -= this.CAM_x;
    y -= this.CAM_y;
    z += this.CAM_z;

    pz = z;
    px = x * funcs.cos_ang(-this.rotation_Z) - y * funcs.sin_ang(-this.rotation_Z);
    py = x * funcs.sin_ang(-this.rotation_Z) + y * funcs.cos_ang(-this.rotation_Z);

    x = px;
    y = py;
    z = pz;

    px = x;
    py = y * funcs.cos_ang(this.rotation_X) - z * funcs.sin_ang(this.rotation_X);
    pz = y * funcs.sin_ang(this.rotation_X) + z * funcs.cos_ang(this.rotation_X);

    x = px;
    y = py;
    z = pz;


    if (z > 0) {
      if (this.ViewType == 1) {

        Image_X = (x / z) * (0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale;
        Image_Y = -(y / z) * (0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale;
        Image_Z = z;
      } else {

        float ZOOM = this.Orthographic_ZOOM();

        Image_X = (x / ZOOM) * (0.5 * this.scale);
        Image_Y = -(y / ZOOM) * (0.5 * this.scale);
        Image_Z = z;
      }
    }

    float[] theValues = {
      Image_X, Image_Y, Image_Z
    };

    return theValues;
  }




  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setFloat(parent, "CAM_x", this.CAM_x);
    XML_setFloat(parent, "CAM_y", this.CAM_y);
    XML_setFloat(parent, "CAM_z", this.CAM_z);
    XML_setFloat(parent, "CAM_fov", this.CAM_fov);
    XML_setFloat(parent, "CAM_dist", this.CAM_dist);
    XML_setFloat(parent, "CAM_clipNear", this.CAM_clipNear);
    XML_setFloat(parent, "CAM_clipFar", this.CAM_clipFar);
    XML_setInt(parent, "currentCamera", this.currentCamera);

    XML_setFloat(parent, "refScale", this.refScale);
    XML_setFloat(parent, "position_X", this.position_X);
    XML_setFloat(parent, "position_Y", this.position_Y);
    XML_setFloat(parent, "position_Z", this.position_Z);
    XML_setFloat(parent, "position_T", this.position_T);
    XML_setFloat(parent, "rotation_X", this.rotation_X);
    XML_setFloat(parent, "rotation_Y", this.rotation_Y);
    XML_setFloat(parent, "rotation_Z", this.rotation_Z);
    XML_setFloat(parent, "rotation_T", this.rotation_T);
    XML_setFloat(parent, "Zoom", this.Zoom);
    XML_setInt(parent, "ViewType", this.ViewType);
    XML_setInt(parent, "FacesShade", this.FacesShade);

    XML_setInt(parent, "UI_CurrentTask", this.UI_CurrentTask);
    XML_setInt(parent, "UI_OptionXorY", this.UI_OptionXorY);
    XML_setInt(parent, "UI_TaskModifyParameter", this.UI_TaskModifyParameter);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.CAM_x = XML_getFloat(parent, "CAM_x");
    this.CAM_y = XML_getFloat(parent, "CAM_y");
    this.CAM_z = XML_getFloat(parent, "CAM_z");
    this.CAM_fov = XML_getFloat(parent, "CAM_fov");
    this.CAM_dist = XML_getFloat(parent, "CAM_dist");
    this.CAM_clipNear = XML_getFloat(parent, "CAM_clipNear");
    this.CAM_clipFar = XML_getFloat(parent, "CAM_clipFar");
    this.currentCamera = XML_getInt(parent, "currentCamera");

    this.refScale = XML_getFloat(parent, "refScale");
    this.position_X = XML_getFloat(parent, "position_X");
    this.position_Y = XML_getFloat(parent, "position_Y");
    this.position_Z = XML_getFloat(parent, "position_Z");
    this.position_T = XML_getFloat(parent, "position_T");
    this.rotation_X = XML_getFloat(parent, "rotation_X");
    this.rotation_Y = XML_getFloat(parent, "rotation_Y");
    this.rotation_Z = XML_getFloat(parent, "rotation_Z");
    this.rotation_T = XML_getFloat(parent, "rotation_T");
    this.Zoom = XML_getFloat(parent, "Zoom");
    this.ViewType = XML_getInt(parent, "ViewType");
    this.FacesShade = XML_getInt(parent, "FacesShade");

    this.UI_CurrentTask = XML_getInt(parent, "UI_CurrentTask");
    this.UI_OptionXorY = XML_getInt(parent, "UI_OptionXorY");
    this.UI_TaskModifyParameter = XML_getInt(parent, "UI_TaskModifyParameter");
  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_WIN3D WIN3D = new solarchvision_WIN3D();



class solarchvision_WORLD {

  private final static String CLASS_STAMP = "WORLD";

  // scales
  float sX = 1;
  float sY = 1;
  // offsets
  float oX = 0;
  float oY = 0;
  // (top-left) corner
  int cX = 0;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  // width and height
  int dX = SOLARCHVISION_pixel_W;
  int dY = SOLARCHVISION_pixel_H;

  boolean update = true;
  boolean include = true;


  int numMaps;
  int Zoom = 6; //1:A 2:B 3:C 4:D 5:E and 6:L <<<

  boolean autoView = true;

  boolean record_IMG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;

  float ImageScale = 1.0;

  String ViewFolder;

  PImage ViewImage;

  PGraphics graphics;

  int VIEW_id = 0;



  String[][] VIEW_Name;
  float[][] VIEW_BoundariesX;
  float[][] VIEW_BoundariesY;
  int[] VIEW_displayGrid;
  String[] VIEW_Filenames;

  int displayAll_SWOB = 0; // 0-2
  int displayAll_NAEFS = 0; // 0-2
  int displayAll_CWEEDS = 0; // 0-2
  int displayAll_CLMREC = 0; // 0-2
  int displayAll_TMYEPW = 1; // 0-2

  boolean displayNear_SWOB = false;
  boolean displayNear_NAEFS = false;
  boolean displayNear_CWEEDS = false;
  boolean displayNear_CLMREC = false;
  boolean displayNear_TMYEPW = false;

  void listAllImages () {

    this.VIEW_Filenames = sort(OPESYS.getFiles(this.ViewFolder));

    this.numMaps = this.VIEW_Filenames.length;

    this.VIEW_Name = new String [this.numMaps][2];

    this.VIEW_BoundariesX = new float [this.numMaps][2];
    this.VIEW_BoundariesY = new float [this.numMaps][2];

    this.VIEW_displayGrid = new int [this.numMaps];

    for (int i = 0; i < this.numMaps; i++) {
      String MapFilename = this.ViewFolder + "/" + this.VIEW_Filenames[i];

      String[] Parts = split(this.VIEW_Filenames[i], '_');

      this.VIEW_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.VIEW_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.VIEW_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.VIEW_BoundariesY[i][1] =  float(Parts[4]) * 0.001;

      this.VIEW_Name[i][0] = Parts[5];
      this.VIEW_Name[i][1] = Parts[6];

      float a = (this.VIEW_BoundariesY[i][1] - this.VIEW_BoundariesY[i][0]) / 2;
      if (a < 1) a = 1;
      this.VIEW_displayGrid[i] = int(a);
    }
  }


  int FindGoodViewport (float pointLongitude, float pointLatitude) {

    int return_VIEWPORT = this.VIEW_id;

    if (this.autoView) {

      float d1 = FLOAT_undefined;
      float d2 = FLOAT_undefined;

      for (int i = 0; i < this.numMaps; i++) {

        boolean check_it = false;

        String started_with = this.VIEW_Filenames[i].substring(0, 1);

        if (this.Zoom == 1) {
          if (started_with.equals("A")) check_it = true;
        } else if (this.Zoom == 2) {
          if (started_with.equals("B")) check_it = true;
        } else if (this.Zoom == 3) {
          if (started_with.equals("C")) check_it = true;
        } else if (this.Zoom == 4) {
          if (started_with.equals("D")) check_it = true;
        } else if (this.Zoom == 5) {
          if (started_with.equals("E")) check_it = true;
        } else {
          check_it = true;
        }

        if (check_it) {

          if (isInside(pointLongitude, pointLatitude, this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1])) {
            float d_Center = dist(pointLongitude, pointLatitude, 0.5 * (this.VIEW_BoundariesX[i][0] + this.VIEW_BoundariesX[i][1]), 0.5 * (this.VIEW_BoundariesY[i][0] + this.VIEW_BoundariesY[i][1]));
            float d_Size = dist(this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1]);

            if (d2 > 0.95 * d_Size) {
              if (d1 > d_Center) {
                d1 = d_Center;
                d2 = d_Size;

                return_VIEWPORT = i;
              }
            }
          }
        }
      }
    }

    if (return_VIEWPORT != this.VIEW_id) {
      this.loadImages(return_VIEWPORT);

      if (Earth3D.displaySurface) {
        SOLARCHVISION_view_changed();
      }
    }

    return (return_VIEWPORT);
  }


  void loadImages (int n) {

    println("Loading:", this.ViewFolder + "/" + this.VIEW_Filenames[n]);

    this.ViewImage = loadImage(this.ViewFolder + "/" + this.VIEW_Filenames[n]);
  }


  void drawView () {

    if (this.update) {

      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_IMG) this.ImageScale = 1; //2;
      else this.ImageScale = 1;

      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;
      //////////////////////////////////

      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }

      this.graphics.background(0, 0, 0);

      this.graphics.image(this.ViewImage, 0, 0, this.dX, this.dY);

      this.oX = this.VIEW_BoundariesX[this.VIEW_id][0] + 180;
      this.oY = this.VIEW_BoundariesY[this.VIEW_id][1] - 90;

      this.sX = (this.VIEW_BoundariesX[this.VIEW_id][1] - this.VIEW_BoundariesX[this.VIEW_id][0]) / 360.0;
      this.sY = (this.VIEW_BoundariesY[this.VIEW_id][1] - this.VIEW_BoundariesY[this.VIEW_id][0]) / 180.0;

      float _lon1 = this.VIEW_BoundariesX[this.VIEW_id][0];
      float _lon2 = this.VIEW_BoundariesX[this.VIEW_id][1];
      float _lat1 = this.VIEW_BoundariesY[this.VIEW_id][0];
      float _lat2 = this.VIEW_BoundariesY[this.VIEW_id][1];

      int x_point1 = int(this.dX * (( 1 * (_lon1 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point1 = int(this.dY * ((-1 * (_lat1 - this.oY) / 180.0) + 0.5) / this.sY);
      int x_point2 = int(this.dX * (( 1 * (_lon2 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point2 = int(this.dY * ((-1 * (_lat2 - this.oY) / 180.0) + 0.5) / this.sY);



      Tropo3D.draw(TypeWindow.WORLD, STUDY.i_Start, STUDY.i_End);


      float R_station = 2 * this.ImageScale;
      if (this.VIEW_displayGrid[this.VIEW_id] == 1) R_station = 5;

      this.graphics.ellipseMode(CENTER);

      for (int n = 0; n < AERIAL_num; n++) {

        //try {

        if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {

          float _lat = AERIAL_Locations[n][1];
          float _lon = AERIAL_Locations[n][0];
          if (_lon > 180) _lon -= 360; // << important!

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.pushMatrix();
          this.graphics.translate(x_point, y_point);

          if (AERIAL_graphOption == 0) {
            //-----------------------------
            int PAL_type = 6; //12;
            int PAL_direction = -1;
            float PAL_multiplier = 1.0 / 30.0;
            //-----------------------------

            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {

                float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];

                if (is_defined(_val)) {

                  float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;

                  float[] COL = PAINT.getColorStyle(PAL_type, _u);

                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                    this.graphics.strokeWeight(0);
                    this.graphics.ellipse(0, 0, R_station, R_station);
                  }

                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);

                    _u = 0.5 + 0.5 * (PAL_multiplier * _val);

                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }
                    if (is_defined(_val)) this.graphics.text(nf(int(funcs.roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }

          if (AERIAL_graphOption == 1) {

            //-----------------------------
            int PAL_type = 1;//12;
            int PAL_direction = 1;//-1;
            float PAL_multiplier = 0.1;//1.0 / 30.0;
            //-----------------------------

            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {

                //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
                float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

                if (is_defined(_val)) {

                  float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
                  float D_teta = 15;
                  float R = 0.25 * R_station * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

                  float R_in = 0.0 * R;
                  float x1 = (R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y1 = (R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x2 = (R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y2 = (R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;

                  float x4 = (R * funcs.cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y4 = (R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x3 = (R * funcs.cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y3 = (R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;

                  //float ox = -0.5 * (R * funcs.cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -0.5 * (R * -funcs.sin_ang(90 - teta)) * this.ImageScale;
                  //float ox = -1 * (R * funcs.cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -1 * (R * -funcs.sin_ang(90 - teta)) * this.ImageScale;
                  float ox = -2 * (R * funcs.cos_ang(90 - teta)) / 3.0 * this.ImageScale;
                  float oy = -2 * (R * -funcs.sin_ang(90 - teta)) / 3.0 * this.ImageScale;

                  float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;

                  float[] COL = PAINT.getColorStyle(PAL_type, _u);

                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                    this.graphics.strokeWeight(0);
                    //this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    this.graphics.quad(x1 + ox, y1 + oy, x2 + ox, y2 + oy, x3 + ox, y3 + oy, x4 + ox, y4 + oy);
                  }

                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);

                    _u = 0.5 + 0.5 * (PAL_multiplier * _val);

                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }
                    if (is_defined(_val)) this.graphics.text(nf(int(funcs.roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }

          this.graphics.popMatrix();
        }
        //}
        //catch (Exception e) {
        //}
      }




      {
        float _lat = STATION.getLatitude();
        float _lon = STATION.getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

        this.graphics.strokeWeight(3 * this.ImageScale);
        this.graphics.stroke(0, 0, 127, 255);
        this.graphics.noFill();

        this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
      }

      for ( int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

        nearest_Station_ENSEMBLE_OBSERVED_id[q] = -1;
        nearest_Station_ENSEMBLE_OBSERVED_dist[q] = FLOAT_undefined;

        for (int f = 0; f < SWOB_Coordinates.length; f++) {
          boolean draw_info = false;

          if (this.displayAll_SWOB != 0) draw_info = true;

          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude();
          if (_lon > 180) _lon -= 360; // << important!

          if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
          if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
          if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
          if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false;

          if (draw_info) {

            float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
            float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

            this.graphics.strokeWeight(0);
            this.graphics.stroke(191, 0, 0, 191);
            this.graphics.fill(191, 0, 0, 191);
            this.graphics.ellipse(x_point, y_point, R_station, R_station);

            if (this.displayAll_SWOB > 1) {
              this.graphics.strokeWeight(0);
              this.graphics.stroke(0);
              this.graphics.fill(0);
              this.graphics.textAlign(RIGHT, CENTER);
              this.graphics.textSize(MessageSize * this.ImageScale);
              this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
            }
          }

          float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

          if (nearest_Station_ENSEMBLE_OBSERVED_dist[q] > d) {

            int added_before = 0;

            for (int p = 0; p < q; p++) {
              if (nearest_Station_ENSEMBLE_OBSERVED_id[p] == f) added_before = 1;
            }

            if (added_before == 0) {
              nearest_Station_ENSEMBLE_OBSERVED_dist[q] = d;
              nearest_Station_ENSEMBLE_OBSERVED_id[q] = f;
            }
          }

        }

        if (this.displayNear_SWOB) {
          int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude();
          if (_lon > 180) _lon -= 360; // << important!

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.strokeWeight(0);
          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.textAlign(RIGHT, CENTER);
          this.graphics.textSize(MessageSize * this.ImageScale);
          this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
          //println(SWOB_Coordinates[f].getCode());
        }

      }



      int nearest_WORLD_NAEFS = -1;
      float nearest_WORLD_NAEFS_dist = FLOAT_undefined;

      for (int f = 0; f < NAEFposition_Ts.length; f++) {
        boolean draw_info = false;

        if (this.displayAll_NAEFS != 0) draw_info = true;

        float _lat = NAEFposition_Ts[f].getLatitude();
        float _lon = NAEFposition_Ts[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false;

        if (draw_info) {

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.strokeWeight(0);
          this.graphics.stroke(0, 63, 0, 127);
          this.graphics.fill(0, 63, 0, 127);

          this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);

          if (this.displayAll_NAEFS > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(RIGHT, CENTER);
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(NAEFposition_Ts[f].getCity(), x_point, y_point);
          }
        }

        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

        if (nearest_WORLD_NAEFS_dist > d) {
          nearest_WORLD_NAEFS_dist = d;
          nearest_WORLD_NAEFS = f;
        }
      }

      if (this.displayNear_NAEFS) {
        int f = nearest_WORLD_NAEFS;

        float _lat = NAEFposition_Ts[f].getLatitude();
        float _lon = NAEFposition_Ts[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(NAEFposition_Ts[f].getCity(), x_point, y_point);
        //println(NAEFposition_Ts[f].getCity());
      }


      int nearest_WORLD_CWEEDS = -1;
      float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;

      for (int f = 0; f < CWEEDS_coordinates.length; f++) {
        boolean draw_info = false;

        if (this.displayAll_CWEEDS != 0) draw_info = true;

        float _lat = CWEEDS_coordinates[f].getLatitude();
        float _lon = CWEEDS_coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false;

        if (draw_info) {

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);

          if (this.displayAll_CWEEDS > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(RIGHT, CENTER);
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(CWEEDS_coordinates[f].getCity(), x_point, y_point);
          }
        }

        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

        if (nearest_WORLD_CWEEDS_dist > d) {
          nearest_WORLD_CWEEDS_dist = d;
          nearest_WORLD_CWEEDS = f;
        }
      }

      if (this.displayNear_CWEEDS) {
        int f = nearest_WORLD_CWEEDS;

        float _lat = CWEEDS_coordinates[f].getLatitude();
        float _lon = CWEEDS_coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CWEEDS_coordinates[f].getCity(), x_point, y_point);
        //println(CWEEDS_coordinates[f].getCity());
      }


      int nearest_WORLD_CLMREC = -1;
      float nearest_WORLD_CLMREC_dist = FLOAT_undefined;

      for (int f = 0; f < CLMREC_Coordinates.length; f++) {
        boolean draw_info = false;

        if (this.displayAll_CLMREC != 0) draw_info = true;

        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false;

        if (draw_info) {

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.strokeWeight(1 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 0.5 * R_station, 0.5 * R_station);

          if (this.displayAll_CLMREC > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(RIGHT, CENTER);
            this.graphics.textSize(0.5 * MessageSize * this.ImageScale);
            this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
          }
        }

        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

        if (nearest_WORLD_CLMREC_dist > d) {
          nearest_WORLD_CLMREC_dist = d;
          nearest_WORLD_CLMREC = f;
        }
      }

      if (this.displayNear_CLMREC) {
        int f = nearest_WORLD_CLMREC;

        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
        //println(CLMREC_Coordinates[f].getCity());
      }

      int nearest_WORLD_TMYEPW = -1;
      float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;

      for (int f = 0; f < TMYEPW_Coordinates.length; f++) {
        boolean draw_info = false;

        if (this.displayAll_TMYEPW != 0) draw_info = true;

        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false;

        if (draw_info) {

          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(255, 0, 0, 127);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);

          if (this.displayAll_TMYEPW > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(RIGHT, CENTER);
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
          }
        }

        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

        if (nearest_WORLD_TMYEPW_dist > d) {
          nearest_WORLD_TMYEPW_dist = d;
          nearest_WORLD_TMYEPW = f;
        }
      }

      if (this.displayNear_TMYEPW) {
        int f = nearest_WORLD_TMYEPW;

        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;

        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
        //println(TMYEPW_Coordinates[f].getCity());
      }


      this.graphics.strokeWeight(0);


      if (this.record_PDF) {
        endRecord();

        String myFile = MAKE_Filename(createStamp(0, CLASS_STAMP)) + ".pdf";
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();

        if ((this.record_IMG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".jpg";
          this.graphics.save(myFile);
          println("File created:" + myFile);
        }

        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }


      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;
      //////////////////////////////////

      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.updated();
      } else {
        this.updated();
      }


      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;
    }
  }


  void keyPressed (KeyEvent e) {

    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
      switch(key) {
      case '`' :
        this.Zoom = (this.Zoom - 1 + 6) % 6;
        this.VIEW_id = this.FindGoodViewport(LocationLON, LocationLAT);
        this.revise();
        break;

      case '~' :
        this.Zoom = (this.Zoom + 1) % 6;
        this.VIEW_id = this.FindGoodViewport(LocationLON, LocationLAT);
        this.revise();
        break;

      }
    }
  }

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "Zoom", this.Zoom);

    XML_setInt(parent, "displayAll_SWOB", this.displayAll_SWOB);
    XML_setInt(parent, "displayAll_NAEFS", this.displayAll_NAEFS);
    XML_setInt(parent, "displayAll_CWEEDS", this.displayAll_CWEEDS);
    XML_setInt(parent, "displayAll_CLMREC", this.displayAll_CLMREC);
    XML_setInt(parent, "displayAll_TMYEPW", this.displayAll_TMYEPW);

    XML_setBoolean(parent, "displayNear_SWOB", this.displayNear_SWOB);
    XML_setBoolean(parent, "displayNear_NAEFS", this.displayNear_NAEFS);
    XML_setBoolean(parent, "displayNear_CWEEDS", this.displayNear_CWEEDS);
    XML_setBoolean(parent, "displayNear_CLMREC", this.displayNear_CLMREC);
    XML_setBoolean(parent, "displayNear_TMYEPW", this.displayNear_TMYEPW);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.Zoom = XML_getInt(parent, "Zoom");

    this.displayAll_SWOB = XML_getInt(parent, "displayAll_SWOB");
    this.displayAll_NAEFS = XML_getInt(parent, "displayAll_NAEFS");
    this.displayAll_CWEEDS = XML_getInt(parent, "displayAll_CWEEDS");
    this.displayAll_CLMREC = XML_getInt(parent, "displayAll_CLMREC");
    this.displayAll_TMYEPW = XML_getInt(parent, "displayAll_TMYEPW");

    this.displayNear_SWOB = XML_getBoolean(parent, "displayNear_SWOB");
    this.displayNear_NAEFS = XML_getBoolean(parent, "displayNear_NAEFS");
    this.displayNear_CWEEDS = XML_getBoolean(parent, "displayNear_CWEEDS");
    this.displayNear_CLMREC = XML_getBoolean(parent, "displayNear_CLMREC");
    this.displayNear_TMYEPW = XML_getBoolean(parent, "displayNear_TMYEPW");
  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }

}

solarchvision_WORLD WORLD = new solarchvision_WORLD();



class solarchvision_STUDY {

  private final static String CLASS_STAMP = "STUDY";

  int SORT_pallet_CLR = -1;
  int SORT_pallet_DIR = -1;
  float SORT_pallet_MLT = 2;

  int PROB_pallet_CLR = -1;
  int PROB_pallet_DIR = 1;
  float PROB_pallet_MLT = 0.5;

  int ACTIVE_pallet_CLR = 19; //15; //14;
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1; //2;

  int PASSIVE_pallet_CLR = 1;
  int PASSIVE_pallet_DIR = 1;
  float PASSIVE_pallet_MLT = 0.2;


  int cX = 0;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + SOLARCHVISION_pixel_H;
  int dX = 2 * SOLARCHVISION_pixel_W;
  int dY = 1 * SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);
  float view_S;

  boolean update = true;
  boolean include = true;

  boolean record_IMG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;


  int i_Start = 0;
  int i_End = 23;

  int j_Start = 0; // constant
  int j_End = 12; //8; //6; //2; //16; // Variable

  float perDays = 30.5; //1; //45; //61; //30.5;
  int joinDays = 30; //1; //30;//perDays; // it should be set up to 1 in order to plot only one day

  boolean PrintTtitle = true;

  float T_scale = 0.5;
  float U_scale = 18.0 / float(j_End - j_Start);

  float V_scale;
  float V_offset;
  float V_belowLine;

  int skyScenario = 1; // 1: all scenarios, 2: Total Cloud Cover < 0.33, 3: middle range, 4: Total Cloud Cover > 0.66
  int filter = filter_DAILY;

  int TrendJoinHours = 24; //48;
  int TrendJoinType = -1; // -1: increasing weights, +1: equal weights

  boolean export_info_node = false;
  boolean export_info_norm = false;
  boolean export_info_prob = false;


  float X_control;
  float Y_control;


  float position_X = 0;
  float position_Y = 0;

  float O_scale = 50.0;
  float W_scale = 3.0;

  float rect_scale = 0.005;
  float rect_offset_x = 0.5;

  boolean impact_summary = false;

  int ImpactLayer = 7; // 4 = Median

  int PlotImpacts = PlotImpacts_GLOBAL_PASSIVE;

  boolean Impacts_update = true;

  boolean displayRaws = false;
  boolean displaySorted = true;
  boolean displayNormals = true;
  boolean displayProbs = false;

  int sumInterval = 4;
  float LevelPix = 8;

  color color_data_raws = color(0, 0, 0);

  int plotSetup = 0;

  float ImageScale = 1.0;

  int Impact_TYPE = 1;

  PGraphics graphics;

  boolean isInHourlyRange (float i) {
    boolean result = true;
    if (this.i_Start <= this.i_End) {
      result = false;
      if ((this.i_Start <= i) && (i <= (this.i_End + 24) % 24)) result = true;
    } else {
      result = true;
      if ((this.i_Start > i) && (i > (this.i_End + 24) % 24)) result = false;
    }
    return result;
  }


  void keyPressed (KeyEvent e) {

    if (e.isAltDown()) {
    } else if (e.isControlDown()) {
      if (key == CODED) {
        switch(keyCode) {
          case UP :
          changeCurrentLayerTo((CurrentLayer_id + 1) % numberOfLayers);
          this.revise();
          ROLLOUT.revise();
          break;

          case DOWN :
          changeCurrentLayerTo((CurrentLayer_id + numberOfLayers - 1) % numberOfLayers);
          this.revise();
          ROLLOUT.revise();
          break;

          case RIGHT :
          this.PlotImpacts = (this.PlotImpacts + 1) % 11;
          this.revise();
          ROLLOUT.revise();
          break;

          case LEFT :
          this.PlotImpacts = (this.PlotImpacts - 1 + 11) % 11;
          this.revise();
          ROLLOUT.revise();
          break;

          case 16: // PAGE_UP
          if(!e.isShiftDown()) {
            STUDY.plotSetup = -2 + (2 + STUDY.plotSetup + 1) % 10;
            this.revise();
            ROLLOUT.revise();
          }
          break;

          case 11: // PAGE_DOWN
          if(!e.isShiftDown()) {
            STUDY.plotSetup = -2 + (2 + STUDY.plotSetup - 1 + 10) % 10;
            this.revise();
            ROLLOUT.revise();
          }
          break;
        }
      } else {
        switch(key) {
        case ';':
          this.impact_summary = !(this.impact_summary);
          this.revise();
          ROLLOUT.revise();
          break;

        case '?' :
          STUDY.refreshDateTabs();
          DevelopData_update = true;
          UI_timeBar.revise();
          this.revise();
          ROLLOUT.revise();
          break;

        case '"' :
          this.V_scale *= pow(2.0, (1.0 / 2.0));
          this.revise();
          ROLLOUT.revise();
          break;
        case '\'' :
          this.V_scale *= pow(0.5, (1.0 / 2.0));
          this.revise();
          ROLLOUT.revise();
          break;
        }
      }
    }

    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

      if (key != CODED) {
        switch(key) {

        case '>' :
          this.joinDays += 2;
          if (this.joinDays > 365) this.joinDays = 365;
          DevelopData_update = true;
          UI_timeBar.revise();
          this.revise();
          WIN3D.revise();
          ROLLOUT.revise();
          break;
        case '<' :
          this.joinDays -= 2;
          if (this.joinDays < 1) this.joinDays = 1;
          DevelopData_update = true;
          UI_timeBar.revise();
          this.revise();
          WIN3D.revise();
          ROLLOUT.revise();
          break;

        case ')' :
          this.j_End += 1;
          if (this.j_End > this.j_Start + 61) this.j_End -= 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) {
           this.perDays = int(365 / float(this.j_End - this.j_Start));
           }
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.perDays = 1;
           }
           */
          DevelopData_update = true;

          VertexSolar_rebuild_array = true;
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;
          allSections.resize_solarImpact_array();

          UI_timeBar.revise();
          this.revise();
          ROLLOUT.revise();
          break;

        case '(' :
          this.j_End -= 1;
          if (this.j_End <= this.j_Start) this.j_End += 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) {
           this.perDays = int(365 / float(this.j_End - this.j_Start));
           }
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.perDays = 1;
           }
           */
          DevelopData_update = true;

          VertexSolar_rebuild_array = true;
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;
          allSections.resize_solarImpact_array();

          UI_timeBar.revise();
          this.revise();
          ROLLOUT.revise();
          break;          

        case 'S' :
          this.skyScenario = 1 + (-1 + this.skyScenario + 1) % 4;
          DevelopData_update = true;
          this.revise();
          WIN3D.revise();
          ROLLOUT.revise();
          break;
        case 's' :
          this.skyScenario = 1 + (-1 + this.skyScenario - 1 + 4) % 4;
          DevelopData_update = true;
          this.revise();
          WIN3D.revise();
          ROLLOUT.revise();
          break;

        case 'V' :
          this.displayRaws = !this.displayRaws;
          this.revise();
          ROLLOUT.revise();
          break;
        case 'v' :
          this.displayRaws = !this.displayRaws;
          this.revise();
          ROLLOUT.revise();
          break;

        case 'm' :
          this.displaySorted = !this.displaySorted;
          this.revise();
          ROLLOUT.revise();
          break;
        case 'M' :
          this.displaySorted = !this.displaySorted;
          this.revise();
          ROLLOUT.revise();
          break;

        case 'n' :
          this.displayNormals = !this.displayNormals;
          this.revise();
          ROLLOUT.revise();
          break;
        case 'N' :
          this.displayNormals = !this.displayNormals;
          this.revise();
          ROLLOUT.revise();
          break;

        case 'b' :
          this.displayProbs = !this.displayProbs;
          this.revise();
          ROLLOUT.revise();
          break;
        case 'B' :
          this.displayProbs = !this.displayProbs;
          this.revise();
          ROLLOUT.revise();
          break;

        case '{' :
          if (this.LevelPix < 32) this.LevelPix *= pow(2.0, (1.0 / 1.0));
          this.revise();
          ROLLOUT.revise();
          break;
        case '}' :
          if (this.LevelPix > 2) this.LevelPix *= pow(0.5, (1.0 / 1.0));
          this.revise();
          ROLLOUT.revise();
          break;

        case '[' :
          if (this.sumInterval > 24) this.sumInterval -= 24;
          if (this.sumInterval > 6) this.sumInterval -= 6;
          else if (this.sumInterval > 1) this.sumInterval -= 1;
          if (this.sumInterval == 5) this.sumInterval = 4;
          this.revise();
          ROLLOUT.revise();
          break;
        case ']' :
          if (this.sumInterval < 6) this.sumInterval += 1;
          else if (this.sumInterval < 24) this.sumInterval += 6;
          else this.sumInterval += 24;
          if (this.sumInterval == 5) this.sumInterval = 6;
          this.revise();
          ROLLOUT.revise();
          break;

        }
      }
    }
  }



  void drawTimeGrid (float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {
    this.graphics.strokeWeight(this.T_scale * 1);

    float Shift_DOWN = 0;
    if (this.V_belowLine != 0) Shift_DOWN = -75;

    for (int i = 100; i >= Shift_DOWN; i -= 25) {
      if (-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1) != 0) {
        this.graphics.stroke(0, 63);
        this.graphics.fill(0, 63);
      } else {
        this.graphics.stroke(0);
        this.graphics.fill(0);
      }

      float y = -i * this.view_S;

      this.graphics.line(this.j_Start * sx_Plot, y, this.j_End * sx_Plot, y);

      if ((i >= 0) || (this.V_belowLine != 0)) {
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textSize(sx_Plot * 0.150 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.text(((nf(-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1), 0, 1)) + CurrentLayer_unit), -5, y);
        //this.graphics.text(((String.valueOf(int(-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1)))) + CurrentLayer_unit), -5, y);
      }
    }

    this.graphics.stroke(0, 63);
    this.graphics.fill(0, 63);
    for (int i = this.j_Start; i <= this.j_End; i++) {
      if (i < this.j_End) {
        int j_step = 3;
        for (int j = j_step; j <= 24; j += j_step) {

          float x = (i + j / 24.0) * sx_Plot;

          if (j != 24) {
            this.graphics.line(x, -5 * this.view_S, x, 5 * this.view_S);
          } else {
            this.graphics.line(x, -105 * this.view_S, x, (5 - Shift_DOWN) * this.view_S);
          }
        }
      }
    }

    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER);

    for (int i = this.j_Start; i < this.j_End; i++) {
      if (this.U_scale >= 0.75) {

        float x = (i - ((0 - 12) / 24.0)) * sx_Plot;
        float y = 0.1 * sx_Plot / this.U_scale;
        float h = sx_Plot * 0.15 / this.U_scale;

        this.graphics.textSize(h);
        this.graphics.text("12:00", x, y);
      }
    }

    this.drawInfo(sx_Plot, this.V_belowLine);
  }



  void drawPositionGrid (float x_Plot, float y_Plot, float sx_Plot, float sy_Plot, int fill_back) {
    this.graphics.strokeWeight(this.T_scale * 1);

    if (fill_back != 0) {
      for (int i = this.j_Start; i < this.j_End; i++) {

        float x1 = (i + this.rect_offset_x) * sx_Plot;
        float y1 = 0;
        float h = 2 * 90 * this.rect_scale * sx_Plot;

        this.graphics.stroke(223);
        this.graphics.fill(223);
        this.graphics.ellipse(x1, y1, h, h);
      }
    }

    for (int i = this.j_Start; i < this.j_End; i++) {
      for (int t = 0; t < 360; t += 15) {

        if ((t % 45) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.fill(0, 63);
        } else {

          this.graphics.stroke(0);
          this.graphics.fill(0);
        }
        int r = 0;
        if ((t % 45) != 0) r = 15;

        float x1 = (i + this.rect_offset_x + r * this.rect_scale * funcs.cos_ang(t)) * sx_Plot;
        float x2 = (i + this.rect_offset_x + 90 * this.rect_scale * funcs.cos_ang(t)) * sx_Plot;
        float y1 = -(r * this.rect_scale * funcs.sin_ang(t)) * sx_Plot;
        float y2 = -(90 * this.rect_scale * funcs.sin_ang(t)) * sx_Plot;

        this.graphics.line(x1, y1, x2, y2);


        if (((t + 45) % 90) == 0) {
          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.150 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);

          String txt = "";
          switch((360 + 90 - t) % 360) {
          case 0 :
            txt = "N";
            break;
          case 45 :
            txt = "NE";
            break;
          case 90 :
            txt = "E";
            break;
          case 135 :
            txt = "SE";
            break;
          case 180 :
            txt = "S";
            break;
          case 225 :
            txt = "SW";
            break;
          case 270 :
            txt = "W";
            break;
          case 315 :
            txt = "NW";
            break;
          }

          float x = (i + this.rect_offset_x + 100 * this.rect_scale * funcs.cos_ang(t)) * sx_Plot;
          float y = -(100 * this.rect_scale * funcs.sin_ang(t)) * sx_Plot;

          this.graphics.text(txt, x, y);
        }
      }

      float impact_scale = 1;
      if ((this.PlotImpacts == PlotImpacts_WIND_ACTIVE) || (this.PlotImpacts == PlotImpacts_WIND_PASSIVE)) impact_scale = LAYER_windspd.V_scale * 45 / 50.0;

      for (int r = 90; r > 0; r -= 15) {
        if ((r % 90) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.noFill();
        } else {
          this.graphics.stroke(0);
          this.graphics.noFill();
        }

        float x1 = (i + this.rect_offset_x) * sx_Plot;
        float y1 = 0;
        float h = 2 * r * this.rect_scale * sx_Plot;

        this.graphics.ellipse(x1, y1, h, h);

        int t = 90;
        if (t == 90) {

          float x = (i + this.rect_offset_x + r * this.rect_scale * funcs.cos_ang(t)) * sx_Plot;
          float y = -(r * this.rect_scale * funcs.sin_ang(t)) * sx_Plot;

          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.150 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);
          this.graphics.text(nf(int(r / impact_scale), 1), x, y);
        }
      }
    }
  }


  void drawDailyGrid (float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {

    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER);

    for (int j = this.j_Start; j < this.j_End; j++) {
      if ((this.U_scale >= 0.75) || (((j - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {

        float x = (j - ((0 - 12) / 24.0)) * sx_Plot;
        float y = -1.2 * sx_Plot / this.U_scale;
        float h = sx_Plot * 0.2 / this.U_scale;

        this.graphics.textSize(h);
        this.graphics.text(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay), x, y + h);
        if (this.joinDays > 1) {
          this.graphics.text(("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s"), x, y);
        }
      }
    }

    this.drawInfo(sx_Plot, 1);
  }


  void drawInfo (float sx_Plot, float V_belowLine) {
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
    this.graphics.textAlign(RIGHT, TOP);

    String txt = STATION.getCity();

    if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
      txt += "\n(" + nf(TIME.year, 4) + "_" + nf(TIME.month, 2) + "_" + nf(TIME.day, 2) + "_" + nf(TIME.hour, 2) + ")";
    }

    //this.graphics.text(txt, -1.0 * sx_Plot / this.U_scale, -1.25 * sx_Plot / this.U_scale);

    switch(this.skyScenario) {
    case 1 :
      this.graphics.stroke(0, 0, 0);
      this.graphics.fill(0, 0, 0);
      break;
    case 2 :
      this.graphics.stroke(0, 0, 255);
      this.graphics.fill(0, 0, 255);
      break;
    case 3 :
      this.graphics.stroke(0, 127, 0);
      this.graphics.fill(0, 127, 0);
      break;
    case 4 :
      this.graphics.stroke(255, 0, 0);
      this.graphics.fill(255, 0, 0);
      break;
    }

    this.graphics.textAlign(RIGHT, TOP);

    this.graphics.text(skyScenario_Title[this.skyScenario], -1 * sx_Plot / this.U_scale, -0.25 * sx_Plot / this.U_scale);
  }



  void drawData (float[] Ax_LINES, float[] Ay_LINES, float[] Bx_LINES, float[] By_LINES) {
    //this.graphics.stroke(this.color_data_raws);
    //this.graphics.fill(this.color_data_raws);
    //this.graphics.strokeWeight(this.T_scale * 1);

    this.graphics.stroke(0, PAINT.getOpacity(this.O_scale));
    this.graphics.fill(0, PAINT.getOpacity(this.O_scale));
    this.graphics.strokeWeight(this.T_scale * 0.5);

    for (int i = 0; i < Ax_LINES.length; i++) {
      this.graphics.line(Ax_LINES[i], Ay_LINES[i], Bx_LINES[i], By_LINES[i]);
    }
  }


  void drawProbs (int i, int j, float[] valuesSUM, float[] valuesNUM, float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {

    //println("view_S=", this.view_S);
    //println("LevelPix=", this.LevelPix);

    //float _pix = 100.0 * this.view_S / this.LevelPix;
    float _pix = 90.0 * this.view_S / this.LevelPix;

    //println("_pix=", _pix);


    int PAL_type = this.PROB_pallet_CLR;
    int PAL_direction = this.PROB_pallet_DIR;
    float PAL_multiplier = this.PROB_pallet_MLT;

    float txt_max_width = (this.sumInterval * this.view_S * 100 / 24.0) * this.U_scale;
    float txt_max_height = _pix;
    float txt_size = 1;
    if (txt_max_height > txt_max_width) {
      txt_size = 0.9 * txt_max_width;
    }
    else {
      txt_size = 0.9 * txt_max_height;
    }
    this.graphics.textSize(txt_size);


    this.graphics.rectMode(CORNER);
    this.graphics.textAlign(CENTER, CENTER);

    float min_V = FLOAT_undefined;
    float max_V = -FLOAT_undefined;

    for (int k = 0; k < valuesSUM.length; k++) {
      if (is_defined(valuesSUM[k])) {
        if (min_V > valuesSUM[k]) min_V = valuesSUM[k];
        if (max_V < valuesSUM[k]) max_V = valuesSUM[k];
      }
    }

    if ((is_defined(min_V)) && (is_defined(-max_V))) {
      int min_b = int(funcs.roundTo((min_V * abs(sy_Plot)), _pix) / _pix);
      int max_b = int(funcs.roundTo((max_V * abs(sy_Plot)), _pix) / _pix);

      if (CurrentLayer_id == LAYER_winddir.id) min_b = 0;

      int[] probs;
      int totalProbs = 0;

      probs = new int [floor(max_b - min_b) + 1];

      for (int k = 0; k < valuesSUM.length; k++) {
        if (is_defined(valuesSUM[k])) {
          float the_value = valuesSUM[k];

          if (CurrentLayer_id == LAYER_winddir.id) {
            if (funcs.roundTo((the_value * abs(sy_Plot)), _pix) >= (360 * abs(sy_Plot))) the_value -= 360;
          }

          int h = int(funcs.roundTo((funcs.roundTo((the_value * abs(sy_Plot)), _pix) / _pix) - min_b, 1));

          if (h < 0) h = 0;
          else if (h > probs.length - 1) h = probs.length - 1;
          probs[h] += 1;
          totalProbs += 1;
        }
      }

      if (totalProbs != 0) {
        for (int n = 0; n < probs.length; n++) {
          float prob_V = 1.0 * probs[n] / totalProbs;

          //if (int(funcs.roundTo(100 * prob_V, 1)) > 0) {
          if ((100 * prob_V) > 0) {

            float _u = PAL_multiplier * prob_V;

            if (PAL_direction == -1) _u = 1 - _u;
            if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_direction == 2) _u =  0.5 * _u;

            float[] COL = PAINT.getColorStyle(PAL_type, _u);

            float w = (this.sumInterval * this.view_S * 100 / 24.0) * this.U_scale;
            float h = _pix * 1.5;

            float x1 = (j + ((i + 1) / 24.0)) * sx_Plot;
            float y1 = -(min_b + n + 0.5) * h;

            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.noStroke();
            this.graphics.rect(x1 - w, y1, w, h);

            if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
              this.graphics.fill(127);
              this.graphics.noStroke();
            } else {
              this.graphics.fill(255);
              this.graphics.stroke(255);
              this.graphics.strokeWeight(2);
            }

            this.graphics.text((String.valueOf(int(funcs.roundTo(100 * prob_V, 1)))), x1 - 0.5 * w, y1 + 0.5 * h - 0.25 * txt_size);

            if ((this.export_info_prob) && (this.displayProbs)) {
              FILE_outputProbs[(j - this.j_Start)].print(nfs((min_b + n) * _pix / abs(sy_Plot) - this.V_offset, 5, 5) + ":\t" + nf(100 * prob_V, 3, 3) + "\t");
            }

          }
        }

        if ((this.export_info_prob) && (this.displayProbs)) {
          FILE_outputProbs[(j - this.j_Start)].println("");
        }
      }
    }

    float pal_length = 400;
    float pal_ox = 700;
    float pal_oy = (50 * this.V_belowLine) + 40;

    for (int q = 0; q < 11; q++) {
      float prob_V = 10 * q / 100.0;

      float _u = PAL_multiplier * prob_V;

      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_type, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

      this.graphics.strokeWeight(0);

      this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }

      this.graphics.textSize(15.0 * this.view_S);
      this.graphics.textAlign(CENTER, CENTER);

      float x = (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S;
      float y = (10 + pal_oy - 0.05 * 20) * this.view_S;

      this.graphics.text((String.valueOf(int(funcs.roundTo(100 * prob_V, 1)))), x, y);
    }
  }


  void drawSorted (int i, int j, float[] valuesA, float[] valuesB, float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {

    int PAL_type = this.SORT_pallet_CLR;
    int PAL_direction = this.SORT_pallet_DIR;
    float PAL_multiplier = this.SORT_pallet_MLT;

    float[] sortedvaluesA = sort(valuesA);
    int num_sortedvaluesA = 0;
    for (int l = 0; l < sortedvaluesA.length; l++) {
      if (is_defined(sortedvaluesA[l])) {
        num_sortedvaluesA += 1;
      } else break;
    }

    float[] sortedvaluesB = sort(valuesB);
    int num_sortedvaluesB = 0;
    for (int l = 0; l < sortedvaluesB.length; l++) {
      if (is_defined(sortedvaluesB[l])) {
        num_sortedvaluesB += 1;
      } else break;
    }

    int num_sortedvaluesAB = min(num_sortedvaluesA, num_sortedvaluesB);

    for (int l = 0; l < (num_sortedvaluesAB - 1); l++) {
      float sort_V = 1.1 * (0.5 - ((num_sortedvaluesAB - (l + 1)) / float(num_sortedvaluesAB)));

      float _u = 0.5 + 0.5 * (PAL_multiplier * sort_V);

      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_type, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

      this.graphics.strokeWeight(this.T_scale * 0.0);
      //this.graphics.rect((j + ((i + 1) / 24.0)) * sx_Plot, sortedvaluesA[l] * sy_Plot, -(1 * 100 / 24.0) * this.U_scale, (sortedvaluesA[(l + 1)] - sortedvaluesA[l]) * sy_Plot);

      float P1x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P2x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P3x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
      float P4x = (j + ((i + 1.5) / 24.0)) * sx_Plot;

      float P1y = sortedvaluesA[l] * sy_Plot;
      float P2y = sortedvaluesA[(l + 1)] * sy_Plot;
      float P3y = sortedvaluesB[(l + 1)] * sy_Plot;
      float P4y = sortedvaluesB[l] * sy_Plot;

      this.graphics.quad(P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y);
      /*
      this.graphics.stroke(255);
       this.graphics.strokeWeight(this.T_scale * 0.5);
       this.graphics.line(P1x, P1y, P4x, P4y);
       this.graphics.line(P2x, P2y, P3x, P3y);
       */
    }

    String[] _txt = {
      "MIN", "", "25%", "", "MED", "", "75%", "", "MAX"
    };
    float pal_length = 400;
    float pal_ox = 700;
    float pal_oy = (50 * this.V_belowLine) + 40;

    for (int q = 0; q < 9; q++) {
      float sort_V = 1.1 * (q - 4) / 8.0;

      float _u = 0.5 + 0.5 * (PAL_multiplier * sort_V);

      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;

      float[] COL = PAINT.getColorStyle(PAL_type, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

      //this.graphics.strokeWeight(0.0);
      this.graphics.stroke(255);
      this.graphics.strokeWeight(0.5);
      this.graphics.rect((pal_ox + q * (pal_length / 9.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 9.0) * this.view_S, 20 * this.view_S);

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }

      this.graphics.textSize(15.0 * this.view_S);
      this.graphics.textAlign(CENTER, CENTER);
      this.graphics.text(_txt[q], (25 + pal_ox + q * (pal_length / 9.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
    }
  }


  void drawNormals (int i, int j, float[] valuesA, float[] valuesB, float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {
    float[] NormalsA = SOLARCHVISION_NORMAL(valuesA);
    float[] NormalsB = SOLARCHVISION_NORMAL(valuesB);

    if (CurrentLayer_id == LAYER_winddir.id) {
      float[] XvaluesA;
      float[] YvaluesA;
      XvaluesA = new float [valuesA.length];
      YvaluesA = new float [valuesA.length];

      for (int l = 0; l < valuesA.length; l++) {
        if (is_defined(valuesA[l])) {
          XvaluesA[l] = funcs.cos_ang(90 - valuesA[l]);
          YvaluesA[l] = funcs.sin_ang(90 - valuesA[l]);
        } else {
          XvaluesA[l] = FLOAT_undefined;
          YvaluesA[l] = FLOAT_undefined;
        }
      }

      float[] X_NormalsA = SOLARCHVISION_NORMAL(XvaluesA);
      float[] Y_NormalsA = SOLARCHVISION_NORMAL(YvaluesA);

      for (int l = 0; l < NormalsA.length; l++) {
        if (is_defined(NormalsA[l])) {
          NormalsA[l] = 90 - funcs.atan2_ang(Y_NormalsA[l], X_NormalsA[l]);
          if (NormalsA[l] < 0) NormalsA[l] += 360;
        }

        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsA[l] = FLOAT_undefined;
        }
      }

      float[] XvaluesB;
      float[] YvaluesB;
      XvaluesB = new float [valuesB.length];
      YvaluesB = new float [valuesB.length];

      for (int l = 0; l < valuesB.length; l++) {
        if (is_defined(valuesB[l])) {
          XvaluesB[l] = funcs.cos_ang(90 - valuesB[l]);
          YvaluesB[l] = funcs.sin_ang(90 - valuesB[l]);
        } else {
          XvaluesB[l] = FLOAT_undefined;
          YvaluesB[l] = FLOAT_undefined;
        }
      }

      float[] X_NormalsB = SOLARCHVISION_NORMAL(XvaluesB);
      float[] Y_NormalsB = SOLARCHVISION_NORMAL(YvaluesB);

      for (int l = 0; l < NormalsB.length; l++) {
        if (is_defined(NormalsB[l])) {
          NormalsB[l] = 90 - funcs.atan2_ang(Y_NormalsB[l], X_NormalsB[l]);
          if (NormalsB[l] < 0) NormalsB[l] += 360;
        }

        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsB[l] = FLOAT_undefined;
        }
      }
    }
    int _OPACITY = 191;

    for (int l = 0; l < 9; l++) {


      if (l == STAT_N_Middle) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 191, 0);
        this.graphics.fill(0, 191, 0);
      } else if (l == STAT_N_MidHigh) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(191, 0, 0);
        this.graphics.fill(191, 0, 0);
      } else if (l == STAT_N_MidLow) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 191);
        this.graphics.fill(0, 0, 191);
      } else if (l == STAT_N_Max) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(255, 127, 127);
        this.graphics.fill(255, 127, 127);
      } else if (l == STAT_N_Min) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 127, 255);
        this.graphics.fill(127, 127, 255);
      } else if (l == STAT_N_M50) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 127, 0);
        this.graphics.fill(0, 127, 0);
      } else if (l == STAT_N_M75) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 0, 0);
        this.graphics.fill(127, 0, 0);
      } else if (l == STAT_N_M25) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 127);
        this.graphics.fill(0, 0, 127);
      } else {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 0);
        this.graphics.fill(0, 0, 0);
      }



      if (l == this.ImpactLayer) {
       this.graphics.strokeWeight(this.T_scale * 4);
       this.graphics.stroke(127, 127, 127, _OPACITY);
       this.graphics.fill(127, 127, 127, _OPACITY);
      }




      float z_l = 60; //l;
      if (l == STAT_N_M75) z_l = 61;
      if (l == STAT_N_M50) z_l = 61;
      if (l == STAT_N_M25) z_l = 61;
      if (l == STAT_N_Ave) z_l = 62;

      if ((is_defined(NormalsA[l])) && (is_defined(NormalsB[l]))) {

        float x1 = (j + ((i + 0.5) / 24.0)) * sx_Plot;
        float y1 = NormalsA[l] * sy_Plot;
        float x2 = (j + ((i + 0.5 + TIME.interval) / 24.0)) * sx_Plot;
        float y2 = NormalsB[l] * sy_Plot;

        this.graphics.line(x1, y1, x2, y2);
      }

      if ((this.export_info_norm) && (this.displayNormals)) {
        if (is_defined(NormalsA[l])) FILE_outputNorms[(j - this.j_Start)].print(nfs(NormalsA[l] - this.V_offset, 5, 5) + "\t");
        else FILE_outputNorms[(j - this.j_Start)].print("[undefined]\t");
      }
    }
    if ((this.export_info_norm) && (this.displayNormals)) FILE_outputNorms[(j - this.j_Start)].println();
  }



  void plotHourly (float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {

    int DATA_start = getStart_CurrentDataSource();
    int DATA_end = getEnd_CurrentDataSource();
    String DATA_reference = getReference_CurrentDataSource();

    this.graphics.pushMatrix();
    this.graphics.translate(x_Plot, y_Plot);

    this.color_data_raws = color(0, 0, 63, PAINT.getOpacity(this.O_scale));

    this.drawTimeGrid(x_Plot, y_Plot, sx_Plot, sy_Plot);

    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0];
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k;
    if (count_k < 0) count_k = 0;


    if (this.PrintTtitle) {

      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.strokeWeight(this.T_scale * 0);

      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER);

      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);

      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(LEFT, CENTER);
      this.graphics.text((CurrentLayer_descriptions[Language_Active]), 0, 1.0 * sx_Plot / this.U_scale);
    }

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;

    float[] valuesA;
    float[] valuesB;
    valuesA = new float [count_k * this.joinDays];
    valuesB = new float [count_k * this.joinDays];

    float[] valuesSUM;
    float[] valuesNUM;
    int _interval = 0;
    valuesSUM = new float [count_k * this.joinDays];
    valuesNUM = new float [count_k * this.joinDays];

    for (int k = 0; k < count_k; k++) {
      for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
        valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
        valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
        valuesSUM[(k * this.joinDays + j_ADD)] = 0; // Note: must be initialized to zero; not undefined.
        valuesNUM[(k * this.joinDays + j_ADD)] = 0;
      }
    }

    float[] Ax_LINES = new float [0];
    float[] Ay_LINES = new float [0];
    float[] Bx_LINES = new float [0];
    float[] By_LINES = new float [0];

    FILE_outputRaw = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputNorms = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputProbs = new PrintWriter [(this.j_End - this.j_Start)];

    String Main_name = MAKE_MainName();

    for (int j = this.j_Start; j < this.j_End; j++) {

      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.textAlign(CENTER, CENTER);

      if ((this.U_scale >= 0.75) || (((j - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {

        float x = (j - ((0 - 12) / 24.0)) * sx_Plot;
        float y = -1.4 * sx_Plot / this.U_scale;
        float h = sx_Plot * 0.2 / this.U_scale;

        this.graphics.textSize(h);
        this.graphics.text(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay), x, y + h);
        if (this.joinDays > 1) {
          this.graphics.text(("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s"), x, y);
        }
      }

      String _FilenamesAdd = "";
      if (this.joinDays > 1) {
        _FilenamesAdd = ("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s");
      }
      if ((this.export_info_node) && (this.displayRaws)) {
        FILE_outputRaw[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_node_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputRaw[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly data");

        FILE_outputRaw[(j - this.j_Start)].print("Hour\t");
        for (int k = 0; k < count_k; k++) {
          FILE_outputRaw[(j - this.j_Start)].print(nf(k, 4) + "        \t");
        }
        FILE_outputRaw[(j - this.j_Start)].println("");
      }
      if ((this.export_info_norm) && (this.displayNormals)) {
        FILE_outputNorms[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_norm_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputNorms[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly normal");
        FILE_outputNorms[(j - this.j_Start)].print("Hour\t");
        for (int l = 0; l < 9; l++) {
          FILE_outputNorms[(j - this.j_Start)].print(STAT_N_Title[l] + "\t");
        }
        FILE_outputNorms[(j - this.j_Start)].println("");
      }
      if ((this.export_info_prob) && (this.displayProbs)) {
        FILE_outputProbs[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_prob_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputProbs[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly probabilities");

        FILE_outputProbs[(j - this.j_Start)].print("Hour:\t");
        FILE_outputProbs[(j - this.j_Start)].println("");
      }

      for (int i = 0; i < 24; i++) {
        if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.export_info_norm) && (this.displayNormals)) FILE_outputNorms[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.export_info_prob) && (this.displayProbs)) FILE_outputProbs[(j - this.j_Start)].print(nf(i, 2) + "\t");

        for (int k = 0; k < count_k; k++) {
          for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {

            valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
            valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
            valuesSUM[(k * this.joinDays + j_ADD)] = 0;
            valuesNUM[(k * this.joinDays + j_ADD)] = 1;

            float[] COL = PAINT.getColorStyle(COLOR_STYLE_Current, (1.0 * k / (1 + DATA_end - DATA_start)));
            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);


            int now_k = k + start_k;
            int now_i = i;
            int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;


            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }

            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, CurrentLayer_id);

            if (is_undefined(Pa)) {
              valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;

              if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
            } else {
              int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);

              if (memberCount == 1) {
                valuesA[(k * this.joinDays + j_ADD)] = Pa;
                valuesA[(k * this.joinDays + j_ADD)] += this.V_offset;

                valuesSUM[(k * this.joinDays + j_ADD)] += valuesA[(k * this.joinDays + j_ADD)];
                valuesNUM[(k * this.joinDays + j_ADD)] += 1;

                if ((this.export_info_node) && (this.displayRaws)) {
                  if (is_defined(valuesA[(k * this.joinDays + j_ADD)])) {
                    FILE_outputRaw[(j - this.j_Start)].print(nfs(valuesA[(k * this.joinDays + j_ADD)] - this.V_offset, 5, 5) + "\t");
                  }
                  else {
                    FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
                  }
                }

                if (next_k < (1 + DATA_end - DATA_start)) {

                  Pb = getValue_CurrentDataSource(next_i, next_j, next_k, CurrentLayer_id);

                  if (is_undefined(Pb)) {
                    valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    valuesB[(k * this.joinDays + j_ADD)] = Pb;
                    valuesB[(k * this.joinDays + j_ADD)] += this.V_offset;

                    if (this.displayRaws) {
                      if ((CurrentLayer_id == LAYER_winddir.id) && (abs(valuesB[(k * this.joinDays + j_ADD)] - valuesA[(k * this.joinDays + j_ADD)]) > 180)) {
                      } else {
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, valuesA[(k * this.joinDays + j_ADD)] * sy_Plot);

                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, valuesB[(k * this.joinDays + j_ADD)] * sy_Plot);
                      }
                    }
                  }
                }
              } else {
                if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print("not_the_case\t");
              }
            }
          }
        }


        if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].println();

        if (this.displayProbs) {
          _interval += 1;
          if ((_interval % this.sumInterval) == 0) {
            for (int k = 0; k < count_k; k++) {
              for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
                valuesSUM[(k * this.joinDays + j_ADD)] += valuesA[(k * this.joinDays + j_ADD)];
                valuesNUM[(k * this.joinDays + j_ADD)] += 1;

                if (valuesNUM[(k * this.joinDays + j_ADD)] != 0) {
                  valuesSUM[(k * this.joinDays + j_ADD)] /= valuesNUM[(k * this.joinDays + j_ADD)];
                }
                else {
                  valuesSUM[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
                }
              }
            }

            this.drawProbs(i, j, valuesSUM, valuesNUM, x_Plot, y_Plot, sx_Plot, sy_Plot);
          }
        }

        if (this.displaySorted) {
          this.drawSorted(i, j, valuesA, valuesB, x_Plot, y_Plot, sx_Plot, sy_Plot);
        }

        if (this.displayNormals) {
          this.drawNormals(i, j, valuesA, valuesB, x_Plot, y_Plot, sx_Plot, sy_Plot);
        }
      }

      if ((this.export_info_node) && (this.displayRaws)) {
        FILE_outputRaw[(j - this.j_Start)].flush();
        FILE_outputRaw[(j - this.j_Start)].close();
      }

      if ((this.export_info_norm) && (this.displayNormals)) {
        FILE_outputNorms[(j - this.j_Start)].flush();
        FILE_outputNorms[(j - this.j_Start)].close();
      }

      if ((this.export_info_prob) && (this.displayProbs)) {
        FILE_outputProbs[(j - this.j_Start)].flush();
        FILE_outputProbs[(j - this.j_Start)].close();
      }


    }

    if (this.displayRaws) {
      this.drawData(Ax_LINES, Ay_LINES, Bx_LINES, By_LINES);
    }

    this.graphics.popMatrix();
  }


  void setupPlot () {
    if ((this.plotSetup == -2) || (this.plotSetup == -1)) {
      int keep_TIME_BeginDay = TIME.beginDay;
      float keep_STUDY_perDays = this.perDays;
      int keep_joinDays = this.joinDays;
      int keep_STUDY_j_Start = this.j_Start;
      int keep_STUDY_j_End = this.j_End;
      float keep_STUDY_U_scale = this.U_scale;
      int keep_STUDY_PlotImpacts = this.PlotImpacts;
      int keep_STUDY_Impact_TYPE = this.Impact_TYPE;

      TIME.beginDay = 183; //0; // 183: to put the summer diagram on the left similar to the YC book
      this.perDays = 183;
      this.joinDays = 5;
      this.j_Start = 0;
      this.j_End = 2;
      this.U_scale = 18.0 / float(this.j_End - this.j_Start);
      this.PlotImpacts = (this.plotSetup == -1) ? PlotImpacts_CYCLES_PASSIVE : PlotImpacts_CYCLES_ACTIVE;
      this.Impact_TYPE = (this.plotSetup == -1) ? Impact_PASSIVE : Impact_ACTIVE;

      float scale = (FrameVariation == 2) ? 1 : 0.65;
      this.plotImpact(0, 0 * this.view_S, scale * (100.0 * this.U_scale * this.view_S), scale * (-1.0 * this.V_scale * this.view_S));

      TIME.beginDay = keep_TIME_BeginDay;
      this.perDays = keep_STUDY_perDays;
      this.joinDays = keep_joinDays;
      this.j_Start = keep_STUDY_j_Start;
      this.j_End = keep_STUDY_j_End;
      this.U_scale = keep_STUDY_U_scale;
      this.PlotImpacts = keep_STUDY_PlotImpacts;
      this.Impact_TYPE = keep_STUDY_Impact_TYPE;
    }


    if (this.plotSetup == 0) {

      if (FrameVariation == 2) {

        for (int p = 0; p < 3; p++) {
          this.ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3) + p;

          this.plotImpact(0, (150 - p * 300) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
        }
        this.ImpactLayer = pre_STUDY_ImpactLayer;

      } else {
        this.plotImpact(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
    }


    if (this.plotSetup == 1) {
      int keep_PlotImpacts = this.PlotImpacts;
      int keep_CurrentLayer_id = CurrentLayer_id;

      if (FrameVariation == 2) {
        this.PlotImpacts = PlotImpacts_URBAN_ACTIVE;
        this.plotImpact(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        this.PlotImpacts = PlotImpacts_GLOBAL_ACTIVE;
        this.plotImpact(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      changeCurrentLayerTo(LAYER_dirnorrad.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      changeCurrentLayerTo(LAYER_cloudcover.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.PlotImpacts = keep_PlotImpacts;
      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 2) {
      int keep_PlotImpacts = this.PlotImpacts;
      int keep_CurrentLayer_id = CurrentLayer_id;

      if (FrameVariation == 2) {
        this.PlotImpacts = PlotImpacts_URBAN_PASSIVE;
        this.plotImpact(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        this.PlotImpacts = PlotImpacts_GLOBAL_PASSIVE;
        this.plotImpact(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      changeCurrentLayerTo(LAYER_direffect.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      changeCurrentLayerTo(LAYER_drybulb.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.PlotImpacts = keep_PlotImpacts;
      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 3) {
      int keep_PlotImpacts = this.PlotImpacts;
      int keep_CurrentLayer_id = CurrentLayer_id;

      if (FrameVariation == 2) {
        this.PlotImpacts = PlotImpacts_WIND_PASSIVE;
        this.plotImpact(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        changeCurrentLayerTo(LAYER_drybulb.id);
        this.plotHourly(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.PlotImpacts = PlotImpacts_WIND_ACTIVE;
      this.plotImpact(0, ((FrameVariation == 2) ? 150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      changeCurrentLayerTo(LAYER_windspd.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.PlotImpacts = keep_PlotImpacts;
      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 4) {
      int keep_ImpactLayer = this.ImpactLayer;
      int keep_PlotImpacts = this.PlotImpacts;
      int keep_CurrentLayer_id = CurrentLayer_id;
      boolean keep_displaySorted = this.displaySorted;
      boolean keep_displayNormals = this.displayNormals;
      boolean keep_displayRaws = this.displayRaws;
      boolean keep_displayProbs = this.displayProbs;

      if (FrameVariation == 2) {
        this.PlotImpacts = PlotImpacts_GLOBAL_PASSIVE;

        this.ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3);
        this.plotImpact(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        this.ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3) + 2;
        this.plotImpact(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      changeCurrentLayerTo(LAYER_drybulb.id);

      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false;
      this.plotHourly(0, ((FrameVariation == 2) ? 150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.ImpactLayer = keep_ImpactLayer;
      this.PlotImpacts = keep_PlotImpacts;
      changeCurrentLayerTo(keep_CurrentLayer_id);
      this.displaySorted = keep_displaySorted;
      this.displayNormals = keep_displayNormals;
      this.displayRaws = keep_displayRaws;
      this.displayProbs = keep_displayProbs;
    }


    if (this.plotSetup == 5) {
      int keep_skyScenario = this.skyScenario;
      int keep_CurrentLayer_id = CurrentLayer_id;

      changeCurrentLayerTo(LAYER_drybulb.id);

      if (FrameVariation == 2) {
        this.skyScenario = 1;
        this.plotHourly(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.skyScenario = 4;
      this.plotHourly(0, ((FrameVariation == 2) ? -150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      if (FrameVariation == 2) {
        this.skyScenario = 3;
        this.plotHourly(0, 150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.skyScenario = 2;
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.skyScenario = keep_skyScenario;
      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 6) {
      int keep_skyScenario = this.skyScenario;
      int keep_CurrentLayer_id = CurrentLayer_id;

      changeCurrentLayerTo(LAYER_windspd.id);

      if (FrameVariation == 2) {
        this.skyScenario = 1;
        this.plotHourly(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.skyScenario = 4;
      this.plotHourly(0, ((FrameVariation == 2) ? -150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      if (FrameVariation == 2) {
        this.skyScenario = 3;
        this.plotHourly(0, 150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      this.skyScenario = 2;
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.skyScenario = keep_skyScenario;
      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 7) {
      int keep_CurrentLayer_id = CurrentLayer_id;

      if (FrameVariation == 2) {
        changeCurrentLayerTo(LAYER_pressure.id);
        this.plotHourly(0, -450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        changeCurrentLayerTo(LAYER_windspd.id);
        this.plotHourly(0, -150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      changeCurrentLayerTo(LAYER_relhum.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 150 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      changeCurrentLayerTo(LAYER_drybulb.id);
      this.plotHourly(0, ((FrameVariation == 2) ? 450 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      changeCurrentLayerTo(keep_CurrentLayer_id);
    }


    if (this.plotSetup == 8) {
      int keep_CurrentLayer_id = CurrentLayer_id;

      this.PlotImpacts = PlotImpacts_GLOBAL_PASSIVE;
      this.plotImpact(0, ((FrameVariation == 2) ? -450 : -150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      this.PlotImpacts = PlotImpacts_SUNPATH_PASSIVE;
      this.plotImpact(0, ((FrameVariation == 2) ? -150 : 150) * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

      if (FrameVariation == 2) {
        changeCurrentLayerTo(LAYER_dirnorrad.id);
        this.plotHourly(0, 150 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));

        changeCurrentLayerTo(LAYER_difhorrad.id);
        this.plotHourly(0, 450 * this.view_S, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S));
      }

      changeCurrentLayerTo(keep_CurrentLayer_id);
    }
  }


  void drawView () {

    cursor(WAIT);


    if (this.update) {

      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_IMG) this.ImageScale = 1; //2;
      else this.ImageScale = 1;

      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;
      this.T_scale *= this.ImageScale;
      //////////////////////////////////

      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }

      DrawnFrame += 1;
      //println("frame:", DrawnFrame);

      if (DevelopData_update) {
        if (CurrentLayer_id == LAYER_developed.id) {
          SOLARCHVISION_postProcess_developDATA(CurrentDataSource);

        }
      }


      this.view_S = (this.dX / 2100.0);
      this.U_scale = 18.0 / float(this.j_End - this.j_Start);


      this.position_X = -0.333 * this.dX;

      this.position_Y = 1.0 * this.dY;


      this.graphics.background(255);

      this.graphics.blendMode(BLEND);

      this.graphics.strokeJoin(ROUND);

      this.graphics.textFont(SOLARCHVISION_font);

      this.graphics.strokeWeight(0);

      //this.graphics.translate(this.position_X * -0.25, this.position_Y * 0.5);
      this.graphics.translate(this.position_X * -0.425, this.position_Y * 0.5);

      this.setupPlot();

      //this.graphics.translate(this.position_X * 0.25, this.position_Y * 0.5);
      this.graphics.translate(this.position_X * 0.425, this.position_Y * 0.5);

      this.graphics.strokeWeight(this.T_scale * 1);

      this.graphics.stroke(63);
      this.graphics.fill(63);
      this.graphics.textAlign(CENTER, CENTER);

      String txt = "SOLARCHVISION post-processing";

      if (CurrentDataSource == dataID_CLIMATE_TMYEPW) txt += " based on typical-year data for Building Energy Simulation";  //"(TMYEPW - U.S. Department of Energy)";
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) txt += " based on long-term Canadian Weather Energy and Engineering Datasets (CWEEDS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) txt += " based on Environment and Climate Change Canada's Climate website";
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) txt += " based on the North American Ensemble Forecast System (NAEFS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) txt += " based on real-time Surface Weather Observation (SWOB - Environment and Climate Change Canada)";

      //txt += ", www.solarchvision.com";

      this.graphics.textSize(this.dX * 0.01);
      ///this.graphics.text(txt, this.dX * 0.55, this.dY * -0.1666 / this.view_R, 0);

      if (this.record_PDF) {
        endRecord();

        String myFile = MAKE_Filename(createStamp(0, CLASS_STAMP)) + ".pdf";
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();

        if ((this.record_IMG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".jpg";
          this.graphics.save(myFile);
          println("File created:" + myFile);
        }

        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }

      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;
      this.T_scale /= this.ImageScale;
      //////////////////////////////////

      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.updated(); //1;
      } else {
        this.updated();
      }


      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;
    }

    this.export_info_node = false;
    this.export_info_norm = false;
    this.export_info_prob = false;

    cursor(ARROW);
  }


  void refreshDateTabs () {
    if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) ||
        (CurrentDataSource == dataID_CLIMATE_CLMREC) ||
        (CurrentDataSource == dataID_CLIMATE_TMYEPW)) {

      if (this.perDays == 1) {
        this.perDays = int(365 / float(this.j_End - this.j_Start));
      } else {
        this.perDays = 1;
      }
    }
    if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
      this.perDays = 1;
    }
    if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
      if (this.perDays == 1) {
        this.perDays = int(ENSEMBLE_OBSERVED_maxDays / float(this.j_End - this.j_Start));
      } else {
        this.perDays = 1;
      }
    }
  }



  void plotImpact (float x_Plot, float y_Plot, float sx_Plot, float sy_Plot) {

    this.graphics.pushMatrix();
    this.graphics.translate(x_Plot, y_Plot);

    float keep_STUDY_perDays = this.perDays;
    int keep_STUDY_joinDays = this.joinDays;

    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
        (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {

      this.perDays = 1;
      this.joinDays = 1;
    }

    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0];
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k;
    if (count_k < 0) count_k = 0;


    if ((this.PlotImpacts == PlotImpacts_WIND_ACTIVE) || (this.PlotImpacts == PlotImpacts_WIND_PASSIVE)) {

      allWindRoses.resize_Image_array();

      int RES = allWindRoses.RES;

      allWindRoses.renderedRES = RES;

      if (this.PlotImpacts == PlotImpacts_WIND_ACTIVE) this.Impact_TYPE = Impact_ACTIVE;
      if (this.PlotImpacts == PlotImpacts_WIND_PASSIVE) this.Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;

      float[] values_W_dir;
      float[] values_W_spd;
      float[] values_W_tmp;
      values_W_dir = new float [count_k];
      values_W_spd = new float [count_k];
      values_W_tmp = new float [count_k];

      for (int k = 0; k < count_k; k++) {
        values_W_dir[k] = FLOAT_undefined;
        values_W_spd[k] = FLOAT_undefined;
        values_W_tmp[k] = FLOAT_undefined;
      }

      int PAL_type = 0;
      int PAL_direction = 1;

      if (this.Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        //PAL_type = this.ACTIVE_pallet_CLR; PAL_direction = this.ACTIVE_pallet_DIR;
        PAL_type = 12;
        PAL_direction = -1;
      }

      float PAL_multiplier = 1;
      if (this.Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0;
      if (this.Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 1.0 / 30.0;

      for (int j = this.j_Start; j < this.j_End; j++) {

        PGraphics WIND_graphics = createGraphics(RES, RES);
        WIND_graphics.beginDraw();
        //WIND_graphics.background(255);
        WIND_graphics.translate(0.5 * RES, 0.5 * RES);

        for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
          for (int i = 0; i < 24; i++) {
            if (this.isInHourlyRange(i)) {

              for (int k = 0; k < count_k; k++) {

                values_W_dir[k] = FLOAT_undefined;
                values_W_spd[k] = FLOAT_undefined;
                values_W_tmp[k] = FLOAT_undefined;

                int _plot = 1;

                if (_plot == 1) {

                  int now_k = k + start_k;
                  int now_i = i;
                  int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);

                  if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc)) {
                    values_W_dir[k] = FLOAT_undefined;
                    values_W_spd[k] = FLOAT_undefined;
                    values_W_tmp[k] = FLOAT_undefined;
                  } else {
                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);

                    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;

                    if (memberCount == 1) {

                      values_W_dir[k] = Pa;
                      values_W_spd[k] = Pb;
                      values_W_tmp[k] = Pc;

                      float T = values_W_tmp[k];
                      float teta = values_W_dir[k];
                      float D_teta = 15;
                      float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (values_W_spd[k] / 50.0);

                      float R_in = 0; //0.75 * R;
                      float x1 = R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y1 = R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x2 = R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y2 = R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));

                      float x4 = R * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y4 = R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x3 = R * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y3 = R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));

                      float _u = 0;

                      if (this.Impact_TYPE == Impact_ACTIVE) {

                        float _s = (this.O_scale / 100) * 255 / (0.333 * count_k);

                        if (this.skyScenario > 1) _s *= 3; // to improve visibility of those cases.

                        _s /= float(this.joinDays);

                        if (_s < 10) _s = 10;

                        WIND_graphics.stroke(0, _s);
                        WIND_graphics.fill(0, _s);

                        WIND_graphics.strokeWeight(this.T_scale * 0);
                      }
                      if (this.Impact_TYPE == Impact_PASSIVE) {
                        _u = 0.5 + 0.5 * (PAL_multiplier * T);

                        if (PAL_direction == -1) _u = 1 - _u;
                        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                        if (PAL_direction == 2) _u =  0.5 * _u;

                        float[] COL = PAINT.getColorStyle(PAL_type, _u);

                        WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

                        WIND_graphics.strokeWeight(this.T_scale * 2);
                        WIND_graphics.noFill();
                      }

                      WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    }
                  }
                }
              }
            }
          }
        }
        WIND_graphics.endDraw();
        allWindRoses.Image[j + 1] = WIND_graphics;
      }




      PGraphics total_WIND_graphics = createGraphics(RES, RES);
      total_WIND_graphics.beginDraw();
      //total_WIND_graphics.background(255);
      total_WIND_graphics.translate(0.5 * RES, 0.5 * RES);

      for (int j = this.j_Start; j < this.j_End; j++) {
        for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
          for (int i = 0; i < 24; i++) {
            if (this.isInHourlyRange(i)) {

              for (int k = 0; k < count_k; k++) {

                values_W_dir[k] = FLOAT_undefined;
                values_W_spd[k] = FLOAT_undefined;
                values_W_tmp[k] = FLOAT_undefined;

                int _plot = 1;

                if (_plot == 1) {

                  int now_k = k + start_k;
                  int now_i = i;
                  int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);

                  if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc)) {
                    values_W_dir[k] = FLOAT_undefined;
                    values_W_spd[k] = FLOAT_undefined;
                    values_W_tmp[k] = FLOAT_undefined;
                  } else {
                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);

                    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;

                    if (memberCount == 1) {

                      values_W_dir[k] = Pa;
                      values_W_spd[k] = Pb;
                      values_W_tmp[k] = Pc;

                      float T = values_W_tmp[k];
                      float teta = values_W_dir[k];
                      float D_teta = 15;
                      float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (values_W_spd[k] / 50.0);

                      float R_in = 0; //0.75 * R;
                      float x1 = R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y1 = R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x2 = R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y2 = R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));

                      float x4 = R * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y4 = R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x3 = R * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y3 = R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));

                      float _u = 0;

                      if (this.Impact_TYPE == Impact_ACTIVE) {

                        float _s = (this.O_scale / 100) * 255 / (0.333 * count_k) / (this.j_End - this.j_Start);

                        if (this.skyScenario > 1) _s *= 3; // to improve visibility of those cases.

                        _s /= float(this.joinDays);

                        if (_s < 10) _s = 10;

                        total_WIND_graphics.stroke(0, _s);
                        total_WIND_graphics.fill(0, _s);

                        total_WIND_graphics.strokeWeight(this.T_scale * 0);
                      }
                      if (this.Impact_TYPE == Impact_PASSIVE) {
                        _u = 0.5 + 0.5 * (PAL_multiplier * T);

                        if (PAL_direction == -1) _u = 1 - _u;
                        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                        if (PAL_direction == 2) _u =  0.5 * _u;

                        float[] COL = PAINT.getColorStyle(PAL_type, _u);
                        total_WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

                        total_WIND_graphics.strokeWeight(this.T_scale * 2);
                        total_WIND_graphics.noFill();
                      }

                      total_WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    }
                  }
                }
              }
            }
          }
        }
      }
      total_WIND_graphics.endDraw();
      allWindRoses.Image[0] = total_WIND_graphics;

      for (int j = this.j_Start - 1; j < this.j_End; j++) {
        if ((j != -1) || (this.impact_summary)) {
          this.graphics.strokeWeight(this.T_scale * 0);
          this.graphics.stroke(223);
          this.graphics.fill(223);
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.strokeWeight(this.T_scale * 2);
          this.graphics.stroke(255);
          this.graphics.noFill();
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.imageMode(CENTER);
          this.graphics.image(allWindRoses.Image[j + 1], (j + 100 * this.rect_scale) * sx_Plot, 0, int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));
        }
      }

      this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);

      if (this.impact_summary) {
        int j = -1; // << to put the summary graph before the daily graphs

        int keep_STUDY_j_Start = this.j_Start;
        int keep_STUDY_j_End = this.j_End;
        this.j_Start = j;
        this.j_End = j + 1;
        this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);
        this.j_Start = keep_STUDY_j_Start;
        this.j_End = keep_STUDY_j_End;

        this.graphics.strokeWeight(this.T_scale * 2);
        this.graphics.stroke(0);
        this.graphics.noFill();
        this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
      }

      if (this.Impact_TYPE != Impact_ACTIVE) {

        float pal_length = 400;
        float pal_ox = 700;
        float pal_oy = 110;
        for (int q = 0; q < 11; q++) {
          float _u = 0;

          if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.1 * q;

          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;

          float[] COL = PAINT.getColorStyle(PAL_type, _u);
          this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
          this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

          this.graphics.strokeWeight(0);
          this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

          if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
            this.graphics.stroke(127);
            this.graphics.fill(127);
            this.graphics.strokeWeight(0);
          } else {
            this.graphics.stroke(255);
            this.graphics.fill(255);
            this.graphics.strokeWeight(2);
          }

          this.graphics.textSize(15.0 * this.view_S);
          this.graphics.textAlign(CENTER, CENTER);

          if (this.Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(0.2 * (q - 5) / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        }
      }


      if (this.PrintTtitle) {

        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP);
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP);
        if (this.Impact_TYPE == Impact_ACTIVE) {
          this.graphics.text(("Wind direction and speed"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
        if (this.Impact_TYPE == Impact_PASSIVE) {
          this.graphics.text(("Wind direction and speed with air temperature"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
      }

      if (allWindRoses.displayImage) {
        SOLARCHVISION_view_changed();
      }
    }




    if ((this.PlotImpacts == PlotImpacts_URBAN_ACTIVE) || (this.PlotImpacts == PlotImpacts_URBAN_PASSIVE)) {

      if (this.Impacts_update) {

        allSolarImpacts.calculate_Impact_CurrentPreBaked();

        int RES1 = allSolarImpacts.RES1;
        int RES2 = allSolarImpacts.RES2;

        if (this.PlotImpacts == PlotImpacts_URBAN_ACTIVE) this.Impact_TYPE = Impact_ACTIVE;
        if (this.PlotImpacts == PlotImpacts_URBAN_PASSIVE) this.Impact_TYPE = Impact_PASSIVE;

        float Pa = FLOAT_undefined;
        float Pb = FLOAT_undefined;
        float Pc = FLOAT_undefined;
        float Pd = FLOAT_undefined;

        float values_R_dir;
        float values_R_dif;

        float values_E_dir;
        float values_E_dif;

        int now_k = 0;
        int now_i = 0;
        int now_j = 0;

        int PAL_type = 0;
        int PAL_direction = 1;
        float PAL_multiplier = 1;

        if (this.Impact_TYPE == Impact_ACTIVE) {
          PAL_type = allFaces.ACTIVE_pallet_CLR;
          PAL_direction = allFaces.ACTIVE_pallet_DIR;
          PAL_multiplier = allFaces.ACTIVE_pallet_MLT;
        }
        if (this.Impact_TYPE == Impact_PASSIVE) {
          PAL_type = allFaces.PASSIVE_pallet_CLR;
          PAL_direction = allFaces.PASSIVE_pallet_DIR;
          PAL_multiplier = allFaces.PASSIVE_pallet_MLT;
        }

        int l = this.ImpactLayer;

        for (int j = this.j_Start; j < this.j_End; j++) {

          now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }


          this.graphics.strokeWeight(this.T_scale * 0);
          this.graphics.stroke(223);
          this.graphics.fill(223);
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.strokeWeight(this.T_scale * 2);
          this.graphics.stroke(255);
          this.graphics.noFill();
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.imageMode(CENTER);
          this.graphics.image(allSolarImpacts.Image[this.Impact_TYPE][j + 1], (j + 100 * this.rect_scale) * sx_Plot, 0, int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));

          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.textAlign(CENTER, CENTER);
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);

          String scenario_text = "";
          //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
          //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
          //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.9 * sx_Plot / this.U_scale);
        }

        ////////////////////////////
        this.impact_summary = true;
        ////////////////////////////

        if (this.impact_summary) {
          int j = -1; // << to put the summary graph before the daily graphs

          this.graphics.strokeWeight(this.T_scale * 0);
          this.graphics.stroke(223);
          this.graphics.fill(223);
          //this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.strokeWeight(this.T_scale * 2);
          this.graphics.stroke(0);
          this.graphics.noFill();
          //this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);

          this.graphics.imageMode(CENTER);
          //this.graphics.image(allSolarImpacts.Image[this.Impact_TYPE][j + 1], (j + 100 * this.rect_scale) * sx_Plot, - (p * sx_Plot / this.U_scale), int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));

          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.textAlign(CENTER, CENTER);
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        }

        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, 0.9 * sx_Plot / this.U_scale);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(0);

        if (this.Impact_TYPE == Impact_ACTIVE) {
          this.graphics.text(STAT_N_Title[l], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
        }
        if (this.Impact_TYPE == Impact_PASSIVE) {
          this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
        }
        //?? French


        float pal_length = 400;
        float pal_ox = 700;
        float pal_oy = 110;
        for (int q = 0; q < 11; q++) {
          float _u = 0;

          if (this.Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
          if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;

          float[] COL = PAINT.getColorStyle(PAL_type, _u);
          this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
          this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

          this.graphics.strokeWeight(0);
          this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

          if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
            this.graphics.stroke(127);
            this.graphics.fill(127);
            this.graphics.strokeWeight(0);
          } else {
            this.graphics.stroke(255);
            this.graphics.fill(255);
            this.graphics.strokeWeight(2);
          }

          this.graphics.textSize(15.0 * this.view_S);
          this.graphics.textAlign(CENTER, CENTER);
          if (this.Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
          if (this.Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        }

        if (this.PrintTtitle) {

          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.strokeWeight(this.T_scale * 0);

          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(RIGHT, TOP);
          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);


          String Model_Description = "";


          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(LEFT, TOP);
          if (this.Impact_TYPE == Impact_ACTIVE) {
            this.graphics.text((Model_Description + "Analysis of Active Potentials (kW/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
            //?? French
          }
          if (this.Impact_TYPE == Impact_PASSIVE) {
            this.graphics.text((Model_Description + "Analysis of Passive Potentials (%kW°C/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
            //?? French
          }
        }
      }

      if (allSolarImpacts.displayImage) {
        SOLARCHVISION_view_changed();
      }

    }



    if ((this.PlotImpacts == PlotImpacts_GLOBAL_ACTIVE) || (this.PlotImpacts == PlotImpacts_GLOBAL_PASSIVE)) {

      if (GlobalSolar_rebuild_array) {
        GlobalSolar_resize_array();
      }

      if (this.PlotImpacts == PlotImpacts_GLOBAL_ACTIVE) this.Impact_TYPE = Impact_ACTIVE;
      if (this.PlotImpacts == PlotImpacts_GLOBAL_PASSIVE) this.Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      int PAL_type = 0;
      int PAL_direction = 1;

      if (this.Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
      }

      float PAL_multiplier = 1;
      if (this.Impact_TYPE == Impact_ACTIVE) PAL_multiplier = this.ACTIVE_pallet_MLT;
      if (this.Impact_TYPE == Impact_PASSIVE) PAL_multiplier = this.PASSIVE_pallet_MLT;


      int l = this.ImpactLayer;

      float[][] TOTALvaluesSUM_RAD = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
      float[][] TOTALvaluesSUM_EFF_P = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
      float[][] TOTALvaluesSUM_EFF_N = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
      int[][] TOTALvaluesNUM = new int [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];

      for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) {
        for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
          TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
          TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
          TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
          TOTALvaluesNUM[a][b] = 0;
        }
      }

      for (int j = this.j_Start; j < this.j_End; j++) {

        now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / this.joinDays);
            int j_ADD = nk % this.joinDays;

            for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) {
              float Alpha = a * Sky3D.stp_slp;
              for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
                float Beta = b * Sky3D.stp_dir;

                float valuesSUM_RAD = 0;
                float valuesSUM_EFF_P = 0;
                float valuesSUM_EFF_N = 0;
                int valuesNUM = 0;


                for (int i = 0; i < 24; i++) {
                  if (this.isInHourlyRange(i)) {
                    float HOUR_ANGLE = i;
                    float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                    if (SunR[3] > 0) {

                      now_k = k + start_k;
                      now_i = i;
                      now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;

                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }

                      Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                      Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                      Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                      Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                      if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
                        values_R_dir = FLOAT_undefined;
                        values_R_dif = FLOAT_undefined;
                        values_E_dir = FLOAT_undefined;
                        values_E_dif = FLOAT_undefined;
                      } else {

                        int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);

                        if (memberCount == 1) {
                          values_R_dir = 0.001 * Pa;
                          values_R_dif = 0.001 * Pb;
                          values_E_dir = 0.001 * Pc;
                          values_E_dif = 0.001 * Pd;

                          if (is_undefined(valuesSUM_RAD)) {
                            valuesSUM_RAD = 0;
                            valuesSUM_EFF_P = 0;
                            valuesSUM_EFF_N = 0;
                            valuesNUM = 0;
                          } else {

                            if (values_E_dir < 0) {
                              valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                            } else {
                              valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                            }

                            valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_R_dir, values_R_dif, Alpha, Beta, GlobalAlbedo);

                            valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }


                if (valuesNUM != 0) {
                  //float valuesMUL = funcs.DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);
                  //float valuesMUL = int(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                  float valuesMUL = funcs.roundTo(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);

                  valuesSUM_RAD *= valuesMUL;
                  valuesSUM_EFF_P *= valuesMUL;
                  valuesSUM_EFF_N *= valuesMUL;

                  if (TOTALvaluesNUM[a][b] == 0) {
                    TOTALvaluesSUM_RAD[a][b] = 0;
                    TOTALvaluesSUM_EFF_P[a][b] = 0;
                    TOTALvaluesSUM_EFF_N[a][b] = 0;
                  }

                  TOTALvaluesSUM_RAD[a][b] += valuesSUM_RAD;
                  TOTALvaluesSUM_EFF_P[a][b] += valuesSUM_EFF_P;
                  TOTALvaluesSUM_EFF_N[a][b] += valuesSUM_EFF_N;
                  TOTALvaluesNUM[a][b] += 1;
                } else {
                  valuesSUM_RAD = FLOAT_undefined;
                  valuesSUM_EFF_P = FLOAT_undefined;
                  valuesSUM_EFF_N = FLOAT_undefined;
                }


                float AVERAGE, PERCENTAGE, COMPARISON;

                AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
                if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N));
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


                float valuesSUM = FLOAT_undefined;
                if (this.Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                if (this.Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON;

                //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> valuesSUM_RAD:", valuesSUM_RAD, "COMPARISON:", COMPARISON);

                if (is_defined(valuesSUM)) {

                  float _u = 0;

                  if (this.Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
                  if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);

                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;

                  //float[] COL = PAINT.getColorStyle(PAL_type, _u);
                  float[] COL = PAINT.getColorStyle(PAL_type, funcs.roundTo(_u, 0.1));
                  this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                  this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);


                  this.graphics.strokeWeight(0);

                  float x1 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float y1 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float x2 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float y2 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;

                  float x3 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float y3 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float x4 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                  float y4 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;

                  this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                }
              }
            }

            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(CENTER, CENTER);
            this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);

            String scenario_text = "";
            //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / this.U_scale);
          }
        }
      }



      if (this.impact_summary) {

        int j = -1; // << to put the summary graph before the daily graphs

        for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) {
          float Alpha = a * Sky3D.stp_slp;
          for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
            float Beta = b * Sky3D.stp_dir;

            if (TOTALvaluesNUM[a][b] != 0) {
              TOTALvaluesSUM_RAD[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
              TOTALvaluesSUM_EFF_P[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
              TOTALvaluesSUM_EFF_N[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
            } else {
              TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
              TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
              TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]);
            if ((TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]) / (1.0 * (TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]));
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


            float valuesSUM = FLOAT_undefined;
            if (this.Impact_TYPE == Impact_ACTIVE) valuesSUM = TOTALvaluesSUM_RAD[a][b];
            if (this.Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON;

            //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> (TOTAL) valuesSUM_RAD:", TOTALvaluesSUM_RAD[a][b], "COMPARISON:", COMPARISON);

            if (is_defined(valuesSUM)) {

              float _u = 0;

              if (this.Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
              if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);

              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              //float[] COL = PAINT.getColorStyle(PAL_type, _u);
              float[] COL = PAINT.getColorStyle(PAL_type, funcs.roundTo(_u, 0.1));
              this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
              this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

              this.graphics.strokeWeight(0);

              float x1 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float y1 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float x2 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float y2 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;

              float x3 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float y3 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float x4 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
              float y4 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;

              this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
            }
          }
        }

        this.graphics.strokeWeight(this.T_scale * 2);
        this.graphics.stroke(0);
        this.graphics.noFill();
        this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);


        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textAlign(CENTER, CENTER);
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);

        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / this.U_scale);

        int keep_STUDY_j_Start = this.j_Start;
        int keep_STUDY_j_End = this.j_End;
        this.j_Start = j;
        this.j_End = j + 1;
        this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);
        this.j_Start = keep_STUDY_j_Start;
        this.j_End = keep_STUDY_j_End;
      }


      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, 0.9 * sx_Plot / this.U_scale);

      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER);
      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.strokeWeight(0);
      if (this.Impact_TYPE == Impact_ACTIVE) {
        this.graphics.text(STAT_N_Title[l], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      //?? French

      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 110;
      for (int q = 0; q < 11; q++) {
        float _u = 0;

        if (this.Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

        this.graphics.strokeWeight(0);
        this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }

        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);
        if (this.Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        if (this.Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
      }


      if (this.PrintTtitle) {

        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP);

        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);


        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP);
        if (this.Impact_TYPE == Impact_ACTIVE) {
          this.graphics.text(("Solar radiation on hemisphere (kW/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
        if (this.Impact_TYPE == Impact_PASSIVE) {
          this.graphics.text(("Solar effects on hemisphere (%kW°C/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
      }

      this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);
    }


    if ((this.PlotImpacts == PlotImpacts_SUNPATH_ACTIVE) || (this.PlotImpacts == PlotImpacts_SUNPATH_PASSIVE)) {
      if (this.PlotImpacts == PlotImpacts_SUNPATH_ACTIVE) this.Impact_TYPE = Impact_ACTIVE;
      if (this.PlotImpacts == PlotImpacts_SUNPATH_PASSIVE) this.Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      int PAL_type = 0;
      int PAL_direction = 1;

      if (this.Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
      }

      float PAL_multiplier = 1;
      if (this.Impact_TYPE == Impact_ACTIVE) PAL_multiplier = this.ACTIVE_pallet_MLT;
      if (this.Impact_TYPE == Impact_PASSIVE) PAL_multiplier = this.PASSIVE_pallet_MLT;

      this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);

      int l = this.ImpactLayer;

      for (int j = this.j_Start; j < this.j_End; j++) {

        now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

        float sunrise = funcs.Sunrise(STATION.getLatitude(), DATE_ANGLE);
        float sunset = funcs.Sunset(STATION.getLatitude(), DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
          if (nk != -1) {
            int k = int(nk / this.joinDays);
            int j_ADD = nk % this.joinDays;

            float valuesSUM_RAD = 0;
            float valuesSUM_EFF = 0;
            int valuesNUM = 0;

            for (int i = 0; i < 24; i++) {
              if (this.isInHourlyRange(i)) {
                if ((i+0.5 >= sunrise) && (i+0.5 <= sunset)) {

                  float HOUR_ANGLE = i;
                  float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                  float Alpha = 90 - funcs.acos_ang(SunR[3]);
                  float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                  if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
                    values_R_dir = FLOAT_undefined;
                    values_R_dif = FLOAT_undefined;
                    values_E_dir = FLOAT_undefined;
                    values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);

                    if (memberCount == 1) {
                      values_R_dir = 0.001 * Pa;
                      values_R_dif = 0.001 * Pb;
                      values_E_dir = 0.001 * Pc;
                      values_E_dif = 0.001 * Pd;

                      if (is_undefined(valuesSUM_RAD)) {
                        valuesSUM_RAD = 0;
                        valuesSUM_EFF = 0;
                        valuesNUM = 0;
                      } else {
                        valuesSUM_RAD = (values_R_dir); // direct beam radiation
                        valuesSUM_EFF = (values_E_dir); // direct beam effect
                        valuesNUM = 1;
                      }
                    }
                  }

                  float valuesSUM = FLOAT_undefined;
                  if (this.Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                  if (this.Impact_TYPE == Impact_PASSIVE) valuesSUM = valuesSUM_EFF;

                  if (is_defined(valuesSUM)) {

                    float _u = 0;

                    if (this.Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * valuesSUM);
                    if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * valuesSUM);

                    if (PAL_direction == -1) _u = 1 - _u;
                    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_direction == 2) _u =  0.5 * _u;

                    float[] COL = PAINT.getColorStyle(PAL_type, _u);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

                    this.graphics.strokeWeight(0);

                    this.graphics.ellipse((j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot, 0.075 * sx_Plot, 0.075 * sx_Plot);

                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2);
                    }

                    this.graphics.textSize(this.view_S * 4.0 * this.U_scale);

                    this.graphics.textAlign(CENTER, CENTER);
                    if (this.Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf(valuesSUM, 1, 1), (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot);
                    if (this.Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(valuesSUM), 1), (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot);
                  }
                }
              }
            }

            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(CENTER, CENTER);
            this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);

            String scenario_text = "";
            //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95  * sx_Plot / this.U_scale);
          }
        }
      }

      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, 0.9 * sx_Plot / this.U_scale);

      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER);
      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.strokeWeight(0);
      if (this.Impact_TYPE == Impact_ACTIVE) {
        this.graphics.text(STAT_N_Title[l], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      //?? French


      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 110;
      for (int q = 0; q < 11; q++) {
        float _u = 0;

        if (this.Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (this.Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

        this.graphics.strokeWeight(0);
        this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }

        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);

        if (this.Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf(0.1 * q / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        if (this.Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
      }


      if (this.PrintTtitle) {

        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP);

        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);


        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP);
        if (this.Impact_TYPE == Impact_ACTIVE) {
          this.graphics.text(("Direct solar radiation (kWh/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
        if (this.Impact_TYPE == Impact_PASSIVE) {
          this.graphics.text(("Direct solar effects (kWh°C/m²)"), 0, 1.1 * sx_Plot / this.U_scale);
          //?? French
        }
      }

    }



    if ((this.PlotImpacts == PlotImpacts_FROMSUN_ACTIVE) || (this.PlotImpacts == PlotImpacts_FROMSUN_PASSIVE)) {

      if (this.PlotImpacts == PlotImpacts_FROMSUN_ACTIVE) this.Impact_TYPE = Impact_ACTIVE;
      if (this.PlotImpacts == PlotImpacts_FROMSUN_PASSIVE) this.Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      int PAL_type = 0;
      int PAL_direction = 1;

      if (this.Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (this.Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
      }

      float PAL_multiplier = 1;
      if (this.Impact_TYPE == Impact_ACTIVE) PAL_multiplier = this.ACTIVE_pallet_MLT;
      if (this.Impact_TYPE == Impact_PASSIVE) PAL_multiplier = this.PASSIVE_pallet_MLT;

      this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);


      for (int j = this.j_Start; j < this.j_End; j++) {

        now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

        for (int i = 0; i < 24; i++) {
          //for (int i = 10; i <= 14; i += 2) {
          //for (int i = 12; i <= 12; i += 2) {

          float HOUR_ANGLE = i;
          float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

          float Alpha = 90 - funcs.acos_ang(SunR[3]);
          float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);

          now_i = i;
          now_j = int(j * this.perDays + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }


          int RES1 = SKY2D_X_View;
          int RES2 = SKY2D_Y_View;


          { // Direct

            this.graphics.endDraw();
            ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
            PImage Image_RGBA = SKY2D_graphics.get();
            this.graphics.beginDraw();


            Image_RGBA.save(Folder_ViewsFromSky + "/" + "Direct" + nf(j,2) + nf(i,2) + ".png");


            this.graphics.imageMode(CENTER);
            this.graphics.image(Image_RGBA, (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot, RES1, RES2);
            this.graphics.imageMode(CORNER);
            /*
            if (allMaterials.DirectArea_Flags[now_i][now_j] == -1) {

              allMaterials.DirectArea_Flags[now_i][now_j] = 1;

              for (int mt = 0; mt < allMaterials.Number; mt++) {
                allMaterials.DirectArea_Data[mt][now_i][now_j] = 0;
              }

              if ((i+0.5 >= sunrise) && (i+0.5 <= sunset)) {

                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;

                  color COL = Image_RGBA.get(Image_X, Image_Y);

                  int COL_A = COL >> 24 & 0xFF;

                  if (COL_A != 0) {
                    int COL_R = COL >> 16 & 0xFF;
                    int COL_G = COL >> 8 & 0xFF;
                    int COL_B = COL & 0xFF;

                    for (int mt = 0; mt < allMaterials.Number; mt++) {

                      if ((COL_R == allMaterials.Color[mt][1]) && (COL_G == allMaterials.Color[mt][2]) && (COL_B == allMaterials.Color[mt][3])) {
                        allMaterials.DirectArea_Data[mt][now_i][now_j] += 1;
                      }
                    }
                  }
                }

                for (int mt = 0; mt < allMaterials.Number; mt++) {
                  allMaterials.DirectArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2) ; //???

                  if (allMaterials.Selection == mt) println("Direct:", mt, now_i, now_j, allMaterials.DirectArea_Data[mt][now_i][now_j]);
                }


              }
            }
            */
          }

           /*
           { // Diffuse
              this.graphics.endDraw();
              ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
              PImage Image_RGBA = SKY2D_graphics.get();
              this.graphics.beginDraw();

             if (allMaterials.DiffuseArea_Flags[now_i][now_j] == -1) {

               allMaterials.DiffuseArea_Flags[now_i][now_j] = 1;

               for (int mt = 0; mt < allMaterials.Number; mt++) {
                 allMaterials.DiffuseArea_Data[mt][now_i][now_j] = 0;
               }

               int num_diffuse_views = 0;

               for (int vNo = 0; vNo < skyVertices.length; vNo++) {

                 float skyAngle_Alpha = funcs.asin_ang(skyVertices[vNo][2]);
                 float skyAngle_Beta = funcs.atan2_ang(skyVertices[vNo][1], skyVertices[vNo][0]) + 90;

                 if (skyAngle_Alpha >= 0) {

                   num_diffuse_views += 1;

                   PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-skyAngle_Alpha,0,skyAngle_Beta);

                   //this.graphics.imageMode(CENTER);
                   //this.graphics.image(Image_RGBA, (j + this.rect_offset_x + (90 - skyAngle_Alpha) * this.rect_scale * (funcs.cos_ang(skyAngle_Beta - 90))) * sx_Plot, -((90 - skyAngle_Alpha) * this.rect_scale * (funcs.sin_ang(skyAngle_Beta - 90))) * sx_Plot, RES1, RES2);
                   //this.graphics.imageMode(CORNER);

                   for (int np = 0; np < (RES1 * RES2); np++) {
                     int Image_X = np % RES1;
                     int Image_Y = np / RES1;

                     color COL = Image_RGBA.get(Image_X, Image_Y);

                     int COL_A = COL >> 24 & 0xFF;

                     if (COL_A != 0) {
                       int COL_R = COL >> 16 & 0xFF;
                       int COL_G = COL >> 8 & 0xFF;
                       int COL_B = COL & 0xFF;

                       for (int mt = 0; mt < allMaterials.Number; mt++) {

                         if ((COL_R == allMaterials.Color[mt][1]) && (COL_G == allMaterials.Color[mt][2]) && (COL_B == allMaterials.Color[mt][3])) {
                           allMaterials.DiffuseArea_Data[mt][now_i][now_j] += 1;
                         }
                       }
                     }
                   }

                 }
               }
               for (int mt = 0; mt < allMaterials.Number; mt++) {
                 allMaterials.DiffuseArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2); //???
                 allMaterials.DiffuseArea_Data[mt][now_i][now_j] *= 2.0 / float(num_diffuse_views); // note: multiply by 2 to have a area equal to roof!

                 if (allMaterials.Selection == mt) println("Diffuse:", mt, now_i, now_j, allMaterials.DiffuseArea_Data[mt][now_i][now_j]);
               }

               //---------------------------------------------
               // applying calculated diffuse model at this time for the rest of year.
               for (int mt = 0; mt < allMaterials.Number; mt++) {
                 for (int loop_i = 0; loop_i < 24; loop_i++) {
                   for (int loop_j = 0; loop_j < 365; loop_j++) {
                     allMaterials.DiffuseArea_Data[mt][loop_i][loop_j] = allMaterials.DiffuseArea_Data[mt][now_i][now_j];
                     allMaterials.DiffuseArea_Flags[loop_i][loop_j] = 1;
                   }
                 }
               }
               //---------------------------------------------
             }
           }
           */


        }

      }

      if (this.PrintTtitle) {

        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP);

        this.graphics.text(("Solar perspectives"), 0, 1.1 * sx_Plot / this.U_scale);
      }
    }


    if ((this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) || (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE)) {

      int l = this.ImpactLayer;

      int target_window = TypeWindow.STUDY;

      Sun3D.drawPattern(TypeWindow.STUDY, x_Plot, y_Plot, 0, sx_Plot);

      if (this.j_End == 2) {
        for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

          float ox = (j + STUDY.rect_offset_x) * sx_Plot;

          Sun3D.drawGrid(TypeWindow.STUDY, ox + x_Plot, y_Plot, 0, sx_Plot, j * 180 - 90, j * 180 + 90);

        }
      }

      this.drawPositionGrid(x_Plot, y_Plot, sx_Plot, sy_Plot, 0);

      String scenario_text = "";
      //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, 0.9 * sx_Plot / this.U_scale);

      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER);
      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.strokeWeight(0);
      if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) {
        this.graphics.text(STAT_N_Title[l], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) {
        this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], -0.3 * sx_Plot / this.U_scale, 1.2 * sx_Plot / this.U_scale);
      }
      //?? French

      int PAL_type = 0;
      int PAL_direction = 1;

      if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
      }

      float PAL_multiplier = 1;
      if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) PAL_multiplier = this.ACTIVE_pallet_MLT;
      if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) PAL_multiplier = this.PASSIVE_pallet_MLT;

      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 110;

      if (this.j_End == 2) {
        pal_ox = (FrameVariation == 2) ? 700 : 380;
        pal_oy = (FrameVariation == 2) ? -375 : 275;
      }

      for (int q = 0; q < 11; q++) {
        float _u = 0;

        if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) _u = 0.1 * q;
        if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) _u = 0.2 * q - 0.5;

        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;

        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

        this.graphics.strokeWeight(0);
        this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, -pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }

        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);
        if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) this.graphics.text(nf(0.1 * q / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 - pal_oy - 0.05 * 20) * this.view_S);
        if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 - pal_oy - 0.05 * 20) * this.view_S);
      }


      if (this.PrintTtitle) {

        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP);

        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, -1.2 * sx_Plot / this.U_scale);

        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(CENTER, TOP);
        if (this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) {
          this.graphics.text(("Direct solar radiation (kWh/m²)"), (pal_ox + 5 * (pal_length / 11.0)) * this.view_S + (pal_length / 11.0) * this.view_S, -pal_oy * this.view_S + 25 * this.view_S);
          //?? French
        }
        if (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE) {
          this.graphics.text(("Direct solar effects (kWh°C/m²)"), (pal_ox + 5 * (pal_length / 11.0)) * this.view_S + (pal_length / 11.0) * this.view_S, -pal_oy * this.view_S + 25 * this.view_S);
          //?? French
        }
      }

    }





    if ((this.PlotImpacts == PlotImpacts_CYCLES_ACTIVE) || (this.PlotImpacts == PlotImpacts_CYCLES_PASSIVE)) {
    } else {
      this.drawDailyGrid(x_Plot, y_Plot, sx_Plot, sy_Plot);
    }

    keep_STUDY_perDays = this.perDays;
    this.joinDays = keep_STUDY_joinDays;




    this.graphics.popMatrix();
  }




  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "i_Start", this.i_Start);
    XML_setInt(parent, "i_End", this.i_End);
    XML_setInt(parent, "j_Start", this.j_Start);
    XML_setInt(parent, "j_End", this.j_End);
    XML_setFloat(parent, "perDays", this.perDays);
    XML_setInt(parent, "joinDays", this.joinDays);

    XML_setFloat(parent, "T_scale", this.T_scale);
    XML_setFloat(parent, "U_scale", this.U_scale);

    XML_setInt(parent, "skyScenario", this.skyScenario);
    XML_setInt(parent, "filter", this.filter);
    XML_setInt(parent, "TrendJoinHours", this.TrendJoinHours);
    XML_setInt(parent, "TrendJoinType", this.TrendJoinType);
    XML_setBoolean(parent, "export_info_node", this.export_info_node);
    XML_setBoolean(parent, "export_info_norm", this.export_info_norm);
    XML_setBoolean(parent, "export_info_prob", this.export_info_prob);
    XML_setInt(parent, "SORT_pallet_CLR", this.SORT_pallet_CLR);
    XML_setInt(parent, "SORT_pallet_DIR", this.SORT_pallet_DIR);
    XML_setFloat(parent, "SORT_pallet_MLT", this.SORT_pallet_MLT);
    XML_setInt(parent, "PROB_pallet_CLR", this.PROB_pallet_CLR);
    XML_setInt(parent, "PROB_pallet_DIR", this.PROB_pallet_DIR);
    XML_setFloat(parent, "PROB_pallet_MLT", this.PROB_pallet_MLT);
    XML_setInt(parent, "ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    XML_setInt(parent, "ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    XML_setFloat(parent, "ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    XML_setInt(parent, "PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    XML_setInt(parent, "PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    XML_setFloat(parent, "PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);

    XML_setFloat(parent, "O_scale", this.O_scale);
    XML_setFloat(parent, "W_scale", this.W_scale);
    XML_setFloat(parent, "rect_scale", this.rect_scale);
    XML_setFloat(parent, "rect_offset_x", this.rect_offset_x);

    XML_setBoolean(parent, "impact_summary", this.impact_summary);
    XML_setInt(parent, "ImpactLayer", this.ImpactLayer);
    XML_setInt(parent, "PlotImpacts", this.PlotImpacts);
    XML_setBoolean(parent, "Impacts_update", this.Impacts_update);

    XML_setBoolean(parent, "displayRaws", this.displayRaws);
    XML_setBoolean(parent, "displaySorted", this.displaySorted);
    XML_setBoolean(parent, "displayNormals", this.displayNormals);
    XML_setBoolean(parent, "displayProbs", this.displayProbs);
    XML_setInt(parent, "sumInterval", this.sumInterval);
    XML_setFloat(parent, "LevelPix", this.LevelPix);
    XML_setInt(parent, "plotSetup", this.plotSetup);
    XML_setInt(parent, "Impact_TYPE", this.Impact_TYPE);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.i_Start = XML_getInt(parent, "i_Start");
    this.i_End = XML_getInt(parent, "i_End");
    this.j_Start = XML_getInt(parent, "j_Start");
    this.j_End = XML_getInt(parent, "j_End");
    this.perDays = XML_getFloat(parent, "perDays");
    this.joinDays = XML_getInt(parent, "joinDays");

    this.T_scale = XML_getFloat(parent, "T_scale");
    this.U_scale = XML_getFloat(parent, "U_scale");
    this.skyScenario = XML_getInt(parent, "skyScenario");
    this.filter = XML_getInt(parent, "filter");
    this.TrendJoinHours = XML_getInt(parent, "TrendJoinHours");
    this.TrendJoinType = XML_getInt(parent, "TrendJoinType");
    this.export_info_node = XML_getBoolean(parent, "export_info_node");
    this.export_info_norm = XML_getBoolean(parent, "export_info_norm");
    this.export_info_prob = XML_getBoolean(parent, "export_info_prob");
    this.SORT_pallet_CLR = XML_getInt(parent, "SORT_pallet_CLR");
    this.SORT_pallet_DIR = XML_getInt(parent, "SORT_pallet_DIR");
    this.SORT_pallet_MLT = XML_getFloat(parent, "SORT_pallet_MLT");
    this.PROB_pallet_CLR = XML_getInt(parent, "PROB_pallet_CLR");
    this.PROB_pallet_DIR = XML_getInt(parent, "PROB_pallet_DIR");
    this.PROB_pallet_MLT = XML_getFloat(parent, "PROB_pallet_MLT");
    this.ACTIVE_pallet_CLR = XML_getInt(parent, "ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = XML_getInt(parent, "ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = XML_getFloat(parent, "ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = XML_getInt(parent, "PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = XML_getInt(parent, "PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = XML_getFloat(parent, "PASSIVE_pallet_MLT");


    this.O_scale = XML_getFloat(parent, "O_scale");
    this.W_scale = XML_getFloat(parent, "W_scale");
    this.rect_scale = XML_getFloat(parent, "rect_scale");
    this.rect_offset_x = XML_getFloat(parent, "rect_offset_x");

    this.impact_summary = XML_getBoolean(parent, "impact_summary");
    this.ImpactLayer = XML_getInt(parent, "ImpactLayer");
    this.PlotImpacts = XML_getInt(parent, "PlotImpacts");
    this.Impacts_update = XML_getBoolean(parent, "Impacts_update");

    this.displayRaws = XML_getBoolean(parent, "displayRaws");
    this.displaySorted = XML_getBoolean(parent, "displaySorted");
    this.displayNormals = XML_getBoolean(parent, "displayNormals");
    this.displayProbs = XML_getBoolean(parent, "displayProbs");
    this.sumInterval = XML_getInt(parent, "sumInterval");
    this.LevelPix = XML_getFloat(parent, "LevelPix");
    this.plotSetup = XML_getInt(parent, "plotSetup");
    this.Impact_TYPE = XML_getInt(parent, "Impact_TYPE");
  }


  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_STUDY STUDY = new solarchvision_STUDY();








String[][] allRollouts = {
  {
    "Period & Scenarios", "Time", "Ranges", "Filters"
  }
  ,
  {
    "Location & Data", "Point", "Stations", "Weather"
  }
  ,
  {
    "Geometries & Space", "Create", "Modify", "Solid", "Surface", "Fractal Tree", "Environment", "Viewport", "Simulation", "Other"
  }
  ,
  {
    "Illustration Options", "2D-Layers", "2D-Colors", "3D-Solar", "3D-Spatial", "Selection"
  }
  ,
  {
    "Post-Processing", "Interpolation", "Developed", "Impacts"
  }
  ,
  {
    "Export Products", "Data", "Media"
  }
};


class solarchvision_ROLLOUT {

  private final static String CLASS_STAMP = "ROLLOUT";

  int cX = 2 * SOLARCHVISION_pixel_W;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  int dX = 1 * SOLARCHVISION_pixel_H;
  int dY = 2 * SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);
  float view_S = SOLARCHVISION_pixel_H / 325.0; //1; //0.75; // ?????

  boolean update = true;
  boolean include = true;

  int parent = 0; // 0: Time, 1: Location, 2: Geometry, etc.
  int child = 1; // number of the category inside e.g. 1, 2, ...


  void drawView () {

    stroke(255);
    fill(255);
    strokeWeight(0);
    rect(this.cX, this.cY, this.dX, this.dY);


    float h = 20 * this.view_S;

    STUDY.X_control = this.cX;
    STUDY.Y_control = this.cY;

    STUDY.X_control += 307.5 * this.view_S;
    STUDY.Y_control += 7.5 * this.view_S;

    if (this.parent >= allRollouts.length) {
      this.parent = allRollouts.length - 1;
    }

    if (this.child >= allRollouts[this.parent].length) {
      this.child = allRollouts[this.parent].length - 1;
    }

    if (this.parent < allRollouts.length) {

      for (int i = 0; i < allRollouts.length; i++) {

        float cx = this.cX + (150 * (i % 2) + 5) * this.view_S;
        float cy = STUDY.Y_control;
        float cr = 6.75 * this.view_S;

        textAlign(LEFT, CENTER);

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 150 * this.view_S, cy + cr)) {
          this.parent = i;
          this.child = 1; // <<<<<

          this.revise();
        }

        if (i == this.parent) {
          strokeWeight(2);
          stroke(63);
          fill(191);
          rect(cx - 2.5 * this.view_S, cy - 5 * this.view_S, 150 * this.view_S, 2 * 7.5 * this.view_S);
          strokeWeight(0);

          stroke(0);
          fill(0);
          textSize(15 * this.view_S);
        } else {
          stroke(127);
          fill(127);
          textSize(15 * this.view_S);
        }

        text(nf(i + 1, 0) + ":" + allRollouts[i][0], cx, cy);

        if (i % 2 == 1) STUDY.Y_control += 15 * this.view_S;
      }

      noStroke();
      fill(127);
      rect(this.cX, STUDY.Y_control, this.dX, 17.5 * ceil((allRollouts[this.parent].length - 1) / 3.0) * this.view_S);

      STUDY.Y_control += 5 * this.view_S;

      for (int i = 1; i < allRollouts[this.parent].length; i++) {

        float cr = 6.75 * this.view_S;
        float cx = this.cX + (100 * ((i - 1) % 3) + 10) * this.view_S;
        float cy = STUDY.Y_control + 0.5 * cr;

        textAlign(LEFT, CENTER);

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 100 * this.view_S, cy + cr)) {
          this.child = i;

          this.revise();
        }

        if (i == this.child) {
          noStroke();
          fill(63);
          rect(cx, cy - cr, 100 * this.view_S, cr * 2);

          stroke(255, 0, 0);
          fill(255, 127, 0);
          textSize(15 * this.view_S);
        } else {
          stroke(255);
          fill(255);
          textSize(12.5 * this.view_S);
        }

        text("[" + nf(i, 0) + "]" + allRollouts[this.parent][i], cx, cy);

        if (i % 3 == 0) STUDY.Y_control += 15 * this.view_S;
      }

      if (allRollouts[this.parent].length % 3 != 1) STUDY.Y_control += 15 * this.view_S;

      STUDY.Y_control += 15 * this.view_S;
    }



    if (this.parent == 0) { // Period & Scenarios

      if (this.child == 1) { // Time

        STUDY.joinDays = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Join days", STUDY.joinDays, 1, 64, -2), 1));
        STUDY.j_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Number of days to plot", STUDY.j_End, 1, 61, 1), 1));

        TIME.beginDay = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Plot start date", TIME.beginDay, 0, 364, 1), 1));

        //TIME.date = this.Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Solar date", TIME.date, 0, 364.5, 0.5);
        TIME.date = int(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Solar date", TIME.date, 0, 364, 1));

        TIME.day = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast day", TIME.day, 1, 31, 1), 1));
        TIME.month = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast month", TIME.month, 1, 12, 1), 1));
        TIME.year = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast year", TIME.year, 1953, 2100, 1), 1));

        ENSEMBLE_OBSERVED_maxDays = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Forecast/Obs_maxDays", ENSEMBLE_OBSERVED_maxDays, 0, 31, 1), 1));
      }

      if (this.child == 2) { // Ranges
        STUDY.i_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start hour", STUDY.i_Start, 0, 23, 1), 1));
        STUDY.i_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End hour", STUDY.i_End, 0, 23, 1), 1));

        SampleYear_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start year", SampleYear_Start, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
        SampleYear_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End year", SampleYear_End, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));

        SampleMember_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start member", SampleMember_Start, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));
        SampleMember_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End member", SampleMember_End, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));

        SampleStation_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start station", SampleStation_Start, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));
        SampleStation_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End station", SampleStation_End, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));


      }

      if (this.child == 3) { // Filters

        STUDY.skyScenario = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Sky status", STUDY.skyScenario, 1, 4, 1), 1));
        STUDY.filter = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Hourly/daily filter", STUDY.filter, 0, 1, 1), 1));
      }
    } else if (this.parent == 1) { // Location & data


      if (this.child == 1) { // Point

        //WORLD.autoView = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Auto Fit", WORLD.autoView, 0, 1, 1), 1));
        //WORLD.VIEW_id = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Viewport", WORLD.VIEW_id, 0, WORLD.numMaps - 1, 1), 1));

        LocationLAT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Latitude", LocationLAT, -85, 85, LocationLAT_step);
        LocationLON = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Longitude", LocationLON, -180, 180, LocationLON_step);
        //LocationELE = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Elevation", LocationELE, -100, 8000, LocationELE_step);

        LocationLAT_step = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Latitude_step", LocationLAT_step, 0.001, 10, -2);
        LocationLON_step = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Longitude_step", LocationLON_step, 0.001, 10, -2);
        //LocationELE_step = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Elevation_step", LocationELE_step, 0.125, 1024, -2);

      }

      if (this.child == 2) { // Stations

        WORLD.displayAll_TMYEPW = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "displayAll_TMYEPW", WORLD.displayAll_TMYEPW, 0, 2, 1), 1));
        //WORLD.displayNear_TMYEPW = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_TMYEPW", WORLD.displayNear_TMYEPW, 0, 1, 1), 1));

        WORLD.displayAll_CWEEDS = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "displayAll_CWEEDS", WORLD.displayAll_CWEEDS, 0, 2, 1), 1));
        //WORLD.displayNear_CWEEDS = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_CWEEDS", WORLD.displayNear_CWEEDS, 0, 1, 1), 1));

        WORLD.displayAll_CLMREC = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "displayAll_CLMREC", WORLD.displayAll_CLMREC, 0, 2, 1), 1));
        //WORLD.displayNear_CLMREC = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_CLMREC", WORLD.displayNear_CLMREC, 0, 1, 1), 1));

        WORLD.displayAll_SWOB = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "displayAll_SWOB", WORLD.displayAll_SWOB, 0, 2, 1), 1));
        //WORLD.displayNear_SWOB = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_SWOB", WORLD.displayNear_SWOB, 0, 1, 1), 1));

        WORLD.displayAll_NAEFS = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "displayAll_NAEFS", WORLD.displayAll_NAEFS, 0, 2, 1), 1));
        //WORLD.displayNear_NAEFS = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_NAEFS", WORLD.displayNear_NAEFS, 0, 1, 1), 1));
      }

      if (this.child == 3) { // Weather

        //ENSEMBLE_FORECAST_load = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_FORECAST_load", ENSEMBLE_FORECAST_load, 0, 1, 1), 1));
        //ENSEMBLE_OBSERVED_load = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_OBSERVED_load", ENSEMBLE_OBSERVED_load, 0, 1, 1), 1));
        //CLIMATE_CLMREC_load = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CLMREC_load", CLIMATE_CLMREC_load, 0, 1, 1), 1));
        //CLIMATE_CWEEDS_load = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CWEEDS_load", CLIMATE_CWEEDS_load, 0, 1, 1), 1));
        //CLIMATE_TMYEPW_load = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_TMYEPW_load", CLIMATE_TMYEPW_load, 0, 1, 1), 1));

        GRIB2_Hour_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Start", GRIB2_Hour_Start, 0, 48, 1), 1));
        GRIB2_Hour_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_End", GRIB2_Hour_End, 0, 48, 1), 1));
        GRIB2_Hour_Step = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Step", GRIB2_Hour_Step, 1, 24, 1), 1));

        GRIB2_Layer_Start = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Start", GRIB2_Layer_Start, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_End = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_End", GRIB2_Layer_End, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_Step = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Step", GRIB2_Layer_Step, 1, numberOfLayers, 1), 1));
      }

    } else if (this.parent == 2) { // Geometries & Space
      if (this.child == 1) { // Create

        //addToLastGroup = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "addToLastGroup", addToLastGroup, 0, 1, 1), 1));

        User3D.default_Material = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Material", User3D.default_Material, -1, 8, 1), 1));
        User3D.default_Tessellation = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Tessellation", User3D.default_Tessellation, 0, 6, 1), 1));
        User3D.default_Layer = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Layer", User3D.default_Layer, 0, 16, 1), 1));
        User3D.default_Visibility = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Visibility", User3D.default_Visibility, -1, 1, 1), 1));
        User3D.default_Weight = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "3D-create.Weight" , User3D.default_Weight, -20, 20, 1), 1));
        User3D.default_Closed = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "3D-create.Closed" , User3D.default_Closed, 0, 1, 1), 1));

        User3D.create_Orientation = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Orientation", User3D.create_Orientation, 0, 360, 15);

        User3D.create_Length = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Length", User3D.create_Length, -50, 150, -2), 0.5);
        User3D.create_Width = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Width", User3D.create_Width, -50, 150, -2), 0.5);
        User3D.create_Height = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Height", User3D.create_Height, -50, 150, -2), 0.5);

        User3D.create_Volume = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Volume", User3D.create_Volume, 0, 25000, 1000);

        User3D.create_Snap = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Snap", User3D.create_Snap, 0, 1, 1), 1));
      }

      if (this.child == 2) { // Modify

        User3D.modify_OpenningDepth = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.OpenningDepth", User3D.modify_OpenningDepth, -10, 10, 0.1);
        User3D.modify_OpenningArea = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.OpenningArea", User3D.modify_OpenningArea, 0, 1, 0.05);
        User3D.modify_OpenningDeviation = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.OpenningDeviation", User3D.modify_OpenningDeviation, 0, 1, 0.05);

        User3D.modify_TessellateRows = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.TessellateRows", User3D.modify_TessellateRows, 1, 100, 1), 1));
        User3D.modify_TessellateColumns = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.TessellateColumns", User3D.modify_TessellateColumns, 1, 100, 1), 1));

        User3D.modify_OffsetAmount = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.OffsetAmount", User3D.modify_OffsetAmount, 0, 25, 0.001);

        User3D.modify_WeldTreshold = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-modify.WeldTreshold", User3D.modify_WeldTreshold, 0, 10, 0.001);

        Select3D.softPower = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.softPower", Select3D.softPower, 0.125, 8, -2);
        Select3D.softRadius = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.softRadius", Select3D.softRadius, 0.01, 100, -2);

        Select3D.posVector = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.posVector", Select3D.posVector, 0, 3, 1), 1));
        Select3D.rotVector =  int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.rotVector", Select3D.rotVector, 0, 2, 1), 1));
        Select3D.scaleVector =  int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.scaleVector", Select3D.scaleVector, 0, 3, 1), 1));

        Select3D.posValue = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.posValue", Select3D.posValue, -50, 50, 1), 1));
        Select3D.rotValue = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.rotValue", Select3D.rotValue, -180, 180, 5), 5));
        Select3D.scaleValue = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.scaleValue", Select3D.scaleValue, -8, 8, 0.5), 0.5));

        Select3D.alignX = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.alignX", Select3D.alignX, -1, 1, 1), 1));
        Select3D.alignY = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.alignY", Select3D.alignY, -1, 1, 1), 1));
        Select3D.alignZ = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.alignZ", Select3D.alignZ, -1, 1, 1), 1));
      }

      if (this.child == 3) { // Solid

        //User3D.create_powRnd = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "powRnd" , User3D.create_powRnd, 0, 1, 1), 1));
        User3D.create_powAll = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.powAll", User3D.create_powAll, 0.5, CubePower, -2);
        User3D.create_powX = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.powX", User3D.create_powX, 0.5, CubePower, -2);
        User3D.create_powY = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.powY", User3D.create_powY, 0.5, CubePower, -2);
        User3D.create_powZ = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.powZ", User3D.create_powZ, 0.5, CubePower, -2);
      }

      if (this.child == 4) { // Surface

        User3D.create_SphereDegree = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.SphereDegree", User3D.create_SphereDegree, 0, 5, 1), 1));

        User3D.create_CylinderDegree = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.CylinderDegree", User3D.create_CylinderDegree, 3, 36, 1), 1));

        User3D.create_PolyDegree = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.PolyDegree", User3D.create_PolyDegree, 3, 36, 1), 1));

        User3D.create_Parametric_Type = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Parametric_Type", User3D.create_Parametric_Type, 0, 7, 1), 1));
        User3D.create_Person_Type = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Person_Type", User3D.create_Person_Type, 0, allModel2Ds.num_files_PEOPLE, 1), 1));
        User3D.create_Plant_Type = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Plant_Type", User3D.create_Plant_Type, 0, allModel2Ds.num_files_TREES, 1), 1));
      }

      if (this.child == 5) { // Fractal Tree

        User3D.create_Model1D_Type = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Type", User3D.create_Model1D_Type, 0, 0, 1), 1));
        User3D.create_Model1D_DegreeMax = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.DegreeMax", User3D.create_Model1D_DegreeMax, 0, 12, 1), 1));
        User3D.create_Model1D_Seed = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.Seed", User3D.create_Model1D_Seed, -1, 32767, 1), 1));
        User3D.create_Model1D_TrunkSize = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.TrunkSize", User3D.create_Model1D_TrunkSize, 0, 10, 0.1), 0.1);
        User3D.create_Model1D_LeafSize = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.LeafSize", User3D.create_Model1D_LeafSize, 0, 1, 0.01), 0.1);

        User3D.create_Model1D_BranchTilt = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.BranchTilt", User3D.create_Model1D_BranchTilt, 0, 360, 5), 0.1);
        User3D.create_Model1D_BranchTwist = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.BranchTwist", User3D.create_Model1D_BranchTwist, 0, 360, 5), 0.1);
        User3D.create_Model1D_BranchRatio = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.BranchRatio", User3D.create_Model1D_BranchRatio, 0.05, 1, 0.05), 0.01);
        User3D.create_Model1D_TreeBase = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-create.TreeBase", User3D.create_Model1D_TreeBase, 0, 4, 0.1), 0.01);
      }

      if (this.child == 6) { // Environment

        //Land3D.loadTextures = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.loadTextures", Land3D.loadTextures, 0, 1, 1), 1));
        //Land3D.loadMesh = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.loadMesh", Land3D.loadMesh, 0, 1, 1), 1));
        //Land3D.skipStart = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.skipStart", Land3D.skipStart, 0, Land3D.num_rows - 1, 1), 1));
        //Land3D.skipEnd = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.skipEnd", Land3D.skipEnd, 0, Land3D.num_rows - 1, 1), 1));
        //Land3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displaySurface", Land3D.displaySurface, 0, 1, 1), 1));
        //Land3D.displayTexture = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayTexture", Land3D.displayTexture, 0, 1, 1), 1));
        //Land3D.displayPoints = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayPoints", Land3D.displayPoints, 0, 1, 1), 1));
        //Land3D.displayDepth = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayDepth", Land3D.displayDepth, 0, 1, 1), 1));

        //allModel2Ds.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel2Ds.displayAll", allModel2Ds.displayAll, 0, 1, 1), 1));
        //allModel1Ds.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel1Ds.displayAll", allModel1Ds.displayAll, 0, 1, 1), 1));
        //allModel1Ds.displayLeaves = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel1Ds.displayLeaves", allModel1Ds.displayLeaves, 0, 1, 1), 1));
        //allCurves.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allCurves.displayAll", allCurves.displayAll, 0, 1, 1), 1));
        //allFaces.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.displayAll", allFaces.displayAll, 0, 1, 1), 1));

        //allSolids.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.displayAll", allSolids.displayAll, 0, 1, 1), 1));

        //allSections.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSections.displayAll", allSections.displayAll, 0, 1, 1), 1));




        //allWindRoses.displayImage = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.displayImage", allWindRoses.displayImage, 0, 1, 1), 1));

        allWindRoses.scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.scale", allWindRoses.scale, 50, 3200, -2);
        allWindRoses.RES = int(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.resolution", allWindRoses.RES, 200, 600, 100));



        //Sky3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.displaySurface", Sky3D.displaySurface, 0, 1, 1), 1));

        //Sun3D.displayPath = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayPath", Sun3D.displayPath, 0, 1, 1), 1));
        //Sun3D.displayPattern = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayPattern", Sun3D.displayPattern, 0, 1, 1), 1));
      }


      if (this.child == 7) { // Viewport

        WIN3D.currentCamera = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "currentCamera", WIN3D.currentCamera, 0, allCameras.num, 1), 1));

        WIN3D.CAM_clipNear = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Camera_clipNear", WIN3D.CAM_clipNear, 0.01, 100, -2);
        WIN3D.CAM_clipFar = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Camera_clipFar", WIN3D.CAM_clipFar, 1000, 2000000000, -2);

        //WIN3D.FacesShade = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0,1,0, "FacesShade", WIN3D.FacesShade, 0, SHADE.Options_num - 1, 1), 1));

        //allPoints.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Create3D.displayVertices", allPoints.displayAll, 0, 1, 1), 1));
        //allFaces.displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Create3D.displayEdges", allFaces.displayEdges, 0, 1, 1), 1));
        //allFaces.displayNormals = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Create3D.displayNormals", allFaces.displayNormals, 0, 1, 1), 1));

        //allCameras.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allCameras.displayAll", allCameras.displayAll, 0, 1, 1), 1));
      }


      if (this.child == 8) { // Simulation

        IMPACTS_displayDay = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "IMPACTS_displayDay", IMPACTS_displayDay, 0, STUDY.j_End - STUDY.j_Start, 1), 1));

        //allSolarImpacts.displayImage = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolarImpacts.displayImage", allSolarImpacts.displayImage, 0, 1, 1), 1));
        //allSolidImpacts.displayImage = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.displayImage", allSolidImpacts.displayImage, 0, 1, 1), 1));

        allSolarImpacts.sectionType = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolarImpacts.sectionType", allSolarImpacts.sectionType, 0, 3, 1), 1));
        allSolidImpacts.sectionType = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.sectionType", allSolidImpacts.sectionType, 0, 3, 1), 1));


        allSolidImpacts.Grade = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Grade", allSolidImpacts.Grade, 0.0001, 64.0, -2);
        allSolidImpacts.Power = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Power", allSolidImpacts.Power, 0.0001, 64.0, -2);
        allSolidImpacts.R[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.R[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.R[allSolidImpacts.sectionType], -360, 360, -2);
        allSolidImpacts.Z[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Z[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.Z[allSolidImpacts.sectionType], -1000, 1000, -2);
        allSolidImpacts.positionStep = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.positionStep", allSolidImpacts.positionStep, 5, 80, -2);

        allSolidImpacts.U[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.U[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.U[allSolidImpacts.sectionType], 0.125, 3200, -2);
        allSolidImpacts.V[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.V[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.V[allSolidImpacts.sectionType], 0.125, 3200, -2);
        allSolidImpacts.X[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.X[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.X[allSolidImpacts.sectionType], -10000, 10000, -2);
        allSolidImpacts.Y[allSolidImpacts.sectionType] = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Y[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.Y[allSolidImpacts.sectionType], -10000, 10000, -2);


        allSolidImpacts.WindSpeed = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.WindSpeed (m/s)", allSolidImpacts.WindSpeed, 1, 16, -2);
        allSolidImpacts.WindDirection = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.WindDirection", allSolidImpacts.WindDirection, 0, 360, 15);


        allSolidImpacts.Process_subDivisions = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.Process_subDivisions", allSolidImpacts.Process_subDivisions, 0, 3, 1), 1));

        //allSolidImpacts.displayPoints = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.displayPoints", allSolidImpacts.displayPoints, 0, 1, 1), 1));
        //allSolidImpacts.displayLines = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.displayLines", allSolidImpacts.displayLines, 0, 1, 1), 1));

        //allWindFlows.displayAll = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allWindFlows.displayAll", allWindFlows.displayAll, 0, 1, 1), 1));
      }

      if (this.child == 9) { // Other

        allFaces.displayTessellation = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "3D-create.displayTessellation", allFaces.displayTessellation, 0, 4, 1), 1));

        Land3D.displayTessellation = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land.displayTessellation", Land3D.displayTessellation, 0, 4, 1), 1));

        Sky3D.displayTessellation = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky.displayTessellation", Sky3D.displayTessellation, 0, 4, 1), 1));
        Sky3D.scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky.scale", Sky3D.scale, 1, 4000000, -2);

        BIOSPHERE_drawResolution = funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Biosphere_drawResolution", BIOSPHERE_drawResolution, 1, 10, 1), 1);

        //Tropo3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.displaySurface", Tropo3D.displaySurface, 0, 1, 1), 1));
        //Tropo3D.displayTexture = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.displayTexture", Tropo3D.displayTexture, 0, 1, 1), 1));

        //Earth3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.displaySurface", Earth3D.displaySurface, 0, 1, 1), 1));
        //Earth3D.displayTexture = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.displayTexture", Earth3D.displayTexture, 0, 1, 1), 1));

        //Moon3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.displaySurface", Moon3D.displaySurface, 0, 1, 1), 1));
        //Moon3D.displayTexture = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.displayTexture", Moon3D.displayTexture, 0, 1, 1), 1));

        //Sun3D.displaySurface = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displaySurface", Sun3D.displaySurface, 0, 1, 1), 1));
        //Sun3D.displayTexture = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayTexture", Sun3D.displayTexture, 0, 1, 1), 1));

        Planetary_Magnification = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Planetary_Magnification", Planetary_Magnification, 1, 100, 1.0);

        OBJECTS_scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Objects_scale", OBJECTS_scale, 0.0000001, 1000000, -2);
      }

    } else if (this.parent == 3) { // Display Options

      if (this.child == 1) { // 2D-Layers
        STUDY.plotSetup = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Diagram setup", STUDY.plotSetup, -2, 8, 1), 1));

        //STUDY.update = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Redraw scene", STUDY.update, 0, 1, 1), 1));

        changeCurrentLayerTo(int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Layer", CurrentLayer_id, 0, (numberOfLayers - 1), 1), 1)));

        //STUDY.V_scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "V_scale[" + nf(CurrentLayer_id, 2) + "]", STUDY.V_scale, 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));
        STUDY.V_scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Scale (" + allLayers[CurrentLayer_id].descriptions[Language_EN] + ")", STUDY.V_scale, 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));

        //STUDY.displayRaws = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw data", STUDY.displayRaws, 0, 1, 1), 1));
        //STUDY.displaySorted = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw sorted", STUDY.displaySorted, 0, 1, 1), 1));
        //STUDY.displayNormals = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw statistics", STUDY.displayNormals, 0, 1, 1), 1));
        //STUDY.displayProbs = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw probabilities", STUDY.displayProbs, 0, 1, 1), 1));
        STUDY.sumInterval = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities interval", STUDY.sumInterval, 1, 24, 1), 1));
        STUDY.LevelPix = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities range", STUDY.LevelPix, 2, 32, -2), 1));
      }

      if (this.child == 2) { // 2D-Colors

        //COLOR_STYLE_Current = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Hourly color scheme", COLOR_STYLE_Current, -1, (COLOR_STYLE_Number - 1), 1), 1));

        STUDY.ACTIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_CLR", STUDY.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.ACTIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_DIR", STUDY.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        STUDY.ACTIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_MLT", STUDY.ACTIVE_pallet_MLT, 0.125, 8, -2);

        STUDY.PASSIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_CLR", STUDY.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.PASSIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_DIR", STUDY.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        STUDY.PASSIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_MLT", STUDY.PASSIVE_pallet_MLT, 0.125, 8, -2);

        STUDY.SORT_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.SORT_pallet_CLR", STUDY.SORT_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.SORT_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.SORT_pallet_DIR", STUDY.SORT_pallet_DIR, -2, 2, 2), 1));
        STUDY.SORT_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.SORT_pallet_MLT", STUDY.SORT_pallet_MLT, 0.125, 8, -2);

        STUDY.PROB_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PROB_pallet_CLR", STUDY.PROB_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.PROB_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PROB_pallet_DIR", STUDY.PROB_pallet_DIR, -2, 2, 2), 1));
        STUDY.PROB_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PROB_pallet_MLT", STUDY.PROB_pallet_MLT, 0.125, 8, -2);

        STUDY.O_scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Windose opacity scale", STUDY.O_scale, 1, 100, -pow(2.0, (1.0 / 4.0)));
      }

      if (this.child == 3) { // 3D-Solar

        allFaces.ACTIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_CLR", allFaces.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allFaces.ACTIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_DIR", allFaces.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        allFaces.ACTIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_MLT", allFaces.ACTIVE_pallet_MLT, 0.125, 8, -2);

        allFaces.PASSIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_CLR", allFaces.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allFaces.PASSIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_DIR", allFaces.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        allFaces.PASSIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_MLT", allFaces.PASSIVE_pallet_MLT, 0.125, 8, -2);

        Sky3D.ACTIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_CLR", Sky3D.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.ACTIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_DIR", Sky3D.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        Sky3D.ACTIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_MLT", Sky3D.ACTIVE_pallet_MLT, 0.125, 8, -2);

        Sky3D.PASSIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_CLR", Sky3D.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.PASSIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_DIR", Sky3D.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        Sky3D.PASSIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_MLT", Sky3D.PASSIVE_pallet_MLT, 0.125, 8, -2);

        Sun3D.ACTIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_CLR", Sun3D.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sun3D.ACTIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_DIR", Sun3D.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        Sun3D.ACTIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_MLT", Sun3D.ACTIVE_pallet_MLT, 0.125, 8, -2);

        Sun3D.PASSIVE_pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_CLR", Sun3D.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sun3D.PASSIVE_pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_DIR", Sun3D.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        Sun3D.PASSIVE_pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_MLT", Sun3D.PASSIVE_pallet_MLT, 0.125, 8, -2);
      }




      if (this.child == 4) { // 3D-Solid

        allSolids.pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_CLR", allSolids.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allSolids.pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_DIR", allSolids.pallet_DIR, -2, 2, 2), 1));
        allSolids.pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_MLT", allSolids.pallet_MLT, 0.0001, 64, -2);

        Land3D.pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_CLR", Land3D.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Land3D.pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_DIR", Land3D.pallet_DIR, -2, 2, 2), 1));
        Land3D.pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_MLT", Land3D.pallet_MLT, 0.001, 0.5, -2);

        allWindFlows.pallet_CLR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_CLR", allWindFlows.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allWindFlows.pallet_DIR = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_DIR", allWindFlows.pallet_DIR, -2, 2, 2), 1));
        allWindFlows.pallet_MLT = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_MLT", allWindFlows.pallet_MLT, 0.01, 1.0, -2);
      }


      if (this.child == 5) { // Selection

        //Select3D.Group_displayPivot = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Group_displayPivot", Select3D.Group_displayPivot, 0, 1, 1), 1));
        //Select3D.displayReferencePivot = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.displayReferencePivot", Select3D.displayReferencePivot, 0, 1, 1), 1));
        //Select3D.Group_displayBox = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Group_displayBox", Select3D.Group_displayBox, 0, 1, 1), 1));
        //Select3D.Group_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Group_displayEdges", Select3D.Group_displayEdges, 0, 1, 1), 1));

        //Select3D.Face_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Face_displayEdges", Select3D.Face_displayEdges, 0, 1, 1), 1));
        //Select3D.Face_displayVertexCount = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Face_displayVertexCount", Select3D.Face_displayVertexCount, 0, 1, 1), 1));
        //Select3D.Curve_displayVertexCount = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Curve_displayVertexCount", Select3D.Curve_displayVertexCount, 0, 1, 1), 1));
        //Select3D.Vertex_displayVertices = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Vertex_displayVertices", Select3D.Vertex_displayVertices, 0, 1, 1), 1));
        //Select3D.Curve_displayVertices = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Curve_displayVertices", Select3D.Curve_displayVertices, 0, 1, 1), 1));

        //Select3D.Model2D_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Model2D_displayEdges", Select3D.Model2D_displayEdges, 0, 1, 1), 1));
        //Select3D.Model1D_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Model1D_displayEdges", Select3D.Model1D_displayEdges, 0, 1, 1), 1));

        //Select3D.Solid_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Solid_displayEdges", Select3D.Solid_displayEdges, 0, 1, 1), 1));

        //Select3D.Section_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Section_displayEdges", Select3D.Section_displayEdges, 0, 1, 1), 1));

        //Select3D.Camera_displayEdges = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.Camera_displayEdges", Select3D.Camera_displayEdges, 0, 1, 1), 1));

        //Select3D.LandPoint_displayPoints = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-select.LandPoint_displayPoints", Select3D.LandPoint_displayPoints, 0, 1, 1), 1));
      }
    } else if (this.parent == 4) { // Post-Processing

      if (this.child == 1) { // Interpolation

        Interpolation_Weight = this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Interpolation_Weight", Interpolation_Weight, 0, 5, 0.5);
        CLIMATIC_SolarForecast = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based solar forecast", CLIMATIC_SolarForecast, 0, 1, 1), 1));
        CLIMATIC_WeatherForecast = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based temperature forecast", CLIMATIC_WeatherForecast, 0, 2, 1), 1));
      }
      if (this.child == 2) { // Developed
        Develop_Option = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_Option", Develop_Option, 0, 11, 1), 1));
        Develop_DayHour = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_DayHour", Develop_DayHour, 0, 3, 1), 1));

        STUDY.TrendJoinHours = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Trend period hours", STUDY.TrendJoinHours, 1, 24 * 16, 1), 1));
        STUDY.TrendJoinType = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Weighted/equal trend", STUDY.TrendJoinType, -1, 1, 2), 1));

        Develop_AngleInclination = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Inclination angle", Develop_AngleInclination, 0, 90, 5), 1));
        Develop_AngleOrientation = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Orientation angle", Develop_AngleOrientation, 0, 360, 15), 1));
      }
      if (this.child == 3) { // Impacts
        CurrentDataSource = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impact Source", CurrentDataSource, 0, MAXIMUM_dataID, 1), 1));
        STUDY.ImpactLayer = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impact Min/50%/Max", STUDY.ImpactLayer, 0, 8, 1), 1));
        //STUDY.Impacts_update = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "update impacts", STUDY.Impacts_update, 0, 1, 1), 1));
      }
    } else if (this.parent == 5) { // Export Products

      if (this.child == 1) { // Data

        //STUDY.export_info_node = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII data", STUDY.export_info_node, 0, 1, 1), 1));
        //STUDY.export_info_norm = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII statistics", STUDY.export_info_norm, 0, 1, 1), 1));
        //STUDY.export_info_prob = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII probabilities", STUDY.export_info_prob, 0, 1, 1), 1));


        User3D.export_Scale = this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.Scale", User3D.export_Scale, .001, 1000, -0.1);
        User3D.export_FlipZYaxis = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.FlipZYaxis", User3D.export_FlipZYaxis, 0, 1, 1), 1));

        User3D.export_PrecisionVertex = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.PrecisionVertex", User3D.export_PrecisionVertex, 0, 6, 1), 1));
        User3D.export_PrecisionVtexture = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.PrecisionVtexture", User3D.export_PrecisionVtexture, 0, 6, 1), 1));
        User3D.export_PolyToPoly = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.PolyToPoly", User3D.export_PolyToPoly, 0, 1, 1), 1));

        //User3D.export_MaterialLibrary = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.MaterialLibrary", User3D.export_MaterialLibrary, 0, 1, 1), 1));
        //User3D.export_BackSides = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.BackSides", User3D.export_BackSides, 0, 1, 1), 1));
        //User3D.export_PalletResolution = boolean(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "3D-export.PalletResolution", User3D.export_PalletResolution, 32, 2048, -2), 1));
      }

      if (this.child == 2) { // Media

        allSolidImpacts.record_IMG = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in JPG", allSolidImpacts.record_IMG, 0, 1, 1), 1));
        allSolidImpacts.record_PDF = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in PDF", allSolidImpacts.record_PDF, 0, 1, 1), 1));

        allSolarImpacts.record_IMG = int(funcs.roundTo(this.Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record Solar Analysis in JPG", allSolarImpacts.record_IMG, 0, 1, 1), 1));
      }

    }

    if (this.include) {
      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, this.cX, this.cY, this.cX + this.dX, this.cY + this.dY)) {
        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      }
    }
  }


  float Spinner (float x, float y, int update1, int update2, int update3, String caption, float v, float min_v, float max_v, float stp_v) {

    float new_value = v;

    if (new_value < min_v) new_value = min_v;
    if (new_value > max_v) new_value = max_v;

    float cx, cy, cr;
    float w1, w2, h, o, t_o;

    //w1 = 32.5 * ROLLOUT.view_S;
    //w2 = 142.5 * ROLLOUT.view_S;

    w1 = 100 * ROLLOUT.view_S;
    w2 = 200 * ROLLOUT.view_S;

    h = 16 * ROLLOUT.view_S;
    o = 2 * ROLLOUT.view_S;
    t_o = h * ROLLOUT.view_S / 8.0;

    STUDY.Y_control += 25 * ROLLOUT.view_S; //(h + 2 * o) * 1.25;

    strokeWeight(0);
    stroke(0);
    fill(0);
    rect(x + o, y - (h / 2) - o, 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
    rect(x + o, y - (h / 2) - o + 0.5 * (h + 2 * o), 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
    stroke(255);
    fill(255);
    cx = x + o + 0.25 * (h + 2 * o);
    cy = y - (h / 2) - o + 0.25 * (h + 2 * o);
    cr = 0.25 * (h + 2 * o);
    triangle(cx + cr * funcs.cos_ang(270), cy + 0.75 * cr * funcs.sin_ang(270), cx + 0.75 * cr * funcs.cos_ang(30), cy + 0.75 * cr * funcs.sin_ang(30), cx + 0.75 * cr * funcs.cos_ang(150), cy + 0.75 * cr * funcs.sin_ang(150));

    if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr)) {
      if (mouseButton == LEFT) {

        if (stp_v < 0) {
          new_value *= abs(stp_v);
        } else {
          new_value += abs(stp_v);
        }
      } else if (mouseButton == RIGHT) {

        new_value = max_v;
      }
    }

    cy += 2 * cr;
    triangle(cx + cr * funcs.cos_ang(90), cy + 0.75 * cr * funcs.sin_ang(90), cx + 0.75 * cr * funcs.cos_ang(210), cy + 0.75 * cr * funcs.sin_ang(210), cx + 0.75 * cr * funcs.cos_ang(330), cy + 0.75 * cr * funcs.sin_ang(330));

    if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr)) {

      if (mouseButton == LEFT) {

        if (stp_v < 0) {
          new_value /= abs(stp_v);
        } else {
          new_value -= abs(stp_v);
        }
      } else if (mouseButton == RIGHT) {

        new_value = min_v;
      }
    }

    if (new_value < min_v) new_value = min_v;
    if (new_value > max_v) new_value = max_v;



    strokeWeight(0);
    stroke(191);
    fill(191);
    rect(x - (w1 + w2) - o, y - (h / 2) - o, (w1 + w2) + 2 * o, h + 2 * o);

    stroke(255);
    fill(255);
    rect(x - w1, y - (h / 2), w1, h);

    float q = 0;

    if (max_v - min_v > 0.001) {
      q = (new_value - min_v) / (max_v - min_v);
    }

    if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x - w1, y - (h / 2), x, y + (h / 2))) {

      q = 1;

      if (max_v - min_v > 0.001) {
        q = (SOLARCHVISION_X_clicked - (x - w1)) / w1;
      }

      new_value = min_v + q * (max_v - min_v);

      if (new_value < min_v) new_value = max_v;
      if (new_value > max_v) new_value = min_v;

      ROLLOUT.revise();
    }

    strokeWeight(0);
    stroke(191, 255, 191);
    fill(191, 255, 191);
    rect(x - w1, y - (h / 2), q * w1, h);


    strokeWeight(2);
    stroke(0);
    noFill();
    rect(x - w1, y - (h / 2), w1, h);

    strokeWeight(0);
    stroke(0);
    fill(0);
    textSize(1.0 * h);
    textAlign(RIGHT, CENTER);
    if ((new_value == int(new_value)) || (new_value >= 100)) {
      text(String.valueOf(int(new_value)), x - t_o, y - t_o);
    } else {
      text(nf(new_value, 0, 0), x - t_o, y - t_o);
    }


    strokeWeight(0);
    stroke(0);
    fill(0);
    //textSize(1.0 * h);
    textSize(0.85 * h);
    //textAlign(RIGHT, CENTER); text(caption + ":", x - w1 - t_o, y - t_o);
    textAlign(LEFT, CENTER);
    text(caption + ":", x - w1 - w2 + t_o, y - t_o);

    if (new_value != v) {
      if (update1 != 0) STUDY.revise();
      if (update2 != 0) WIN3D.revise();
      if (update3 != 0) WORLD.revise();
    }

    return new_value;
  }


  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_ROLLOUT ROLLOUT = new solarchvision_ROLLOUT();








float[][]   VertexSolar_XYZ;
float[][][] VertexSolar_amounts;

boolean VertexSolar_rebuild_array = true;
boolean GlobalSolar_rebuild_array = true;

float[][][][] GlobalSolar;





int SavedScreenShots = 0;

String createStamp (int increment, String CLASS_STAMP) {

  SavedScreenShots += increment;


  String txt = "";

  if (CLASS_STAMP == "WIN3D") {
    txt += "CAM" + nf(WIN3D.currentCamera, 2) + "_";
  }
  else {
    txt += "IMG" + nf(SavedScreenShots, 4) + "_";
  }

  txt += STATION.getCity() + "_";

  if (IMPACTS_displayDay != 0) {
    txt += TIME.getMM((IMPACTS_displayDay - 1) * STUDY.perDays + 286 + TIME.beginDay);
  }
  else {
    txt += TIME.getMM( STUDY.j_Start    * STUDY.perDays + 286 + TIME.beginDay) + "-" +
           TIME.getMM((STUDY.j_End - 1) * STUDY.perDays + 286 + TIME.beginDay);
  }

  return txt;
}



void SOLARCHVISION_RecordFrame () {

  saveFrame(Folder_ScreenShots + "/" + createStamp(1, "Screen") + ".jpg");
}



String MAKE_Filename (String beginName) {

  String My_Filenames = Folder_ScreenShots + "/" + beginName;

  return My_Filenames;
}



String MAKE_MainName () {

  String s = "";

  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) s = nf(TIME.year, 2) + nf(TIME.month, 2) + nf(TIME.day, 2) + "_" + nf(STUDY.j_End, 0) + "dayFORECAST_";

  return s;
}

String getFilename_SolidImpact () {

  return Folder_Graphics + "/" + nf(TIME.year, 2) + "-" + nf(TIME.month, 2) + "-" + nf(TIME.day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/Solid" + nf(allSolidImpacts.sectionType, 0) + "h" + nf(int(funcs.roundTo(allSolidImpacts.Z[allSolidImpacts.sectionType], 1)), 4) + "r" + nf(int(funcs.roundTo(allSolidImpacts.R[allSolidImpacts.sectionType], 1)), 3) + "p" + nf(allSolidImpacts.Power, 2, 2).replace(".", "_") + "m" + nf(allSolidImpacts.Grade, 2, 2).replace(".", "_");
}

String getFilename_SolarImpact () {

  return Folder_Graphics + "/" + nf(TIME.year, 2) + "-" + nf(TIME.month, 2) + "-" + nf(TIME.day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/Solar" + nf(allSolarImpacts.sectionType, 0) + "h" + nf(int(funcs.roundTo(allSolarImpacts.Z, 1)), 4) + "r" + nf(int(funcs.roundTo(allSolarImpacts.R, 1)), 3);
}

float HeightAboveGround = 0; //2.5; // <<<<<<<<<


float LocationLAT = 0.0;
float LocationLON = 0.0;
float LocationELE = 0.0;

float LocationLAT_step = 0.01;
float LocationLON_step = 0.01;
float LocationELE_step = 1.0;

int save_frame_number = 0;


int COLOR_STYLE_Current = 0;
int COLOR_STYLE_Number = 20; //6;



final int dataID_ENSEMBLE_OBSERVED = 0;
final int dataID_ENSEMBLE_FORECAST = 1; // also used for Aerial
final int dataID_CLIMATE_CWEEDS = 2;
final int dataID_CLIMATE_CLMREC = 3;
final int dataID_CLIMATE_TMYEPW = 4;
final int MAXIMUM_dataID = dataID_CLIMATE_TMYEPW;


int CurrentDataSource = dataID_CLIMATE_TMYEPW;

final String[] databaseString = {
  "SWOB", "NAEFS", "CWEEDS", "CLMREC", "TMY"
};


int DrawnFrame = 0;

int SOLARCHVISION_X_clicked = -1;
int SOLARCHVISION_Y_clicked = -1;

int SOLARCHVISION_X_click1 = -1;
int SOLARCHVISION_Y_click1 = -1;
int SOLARCHVISION_X_click2 = -1;
int SOLARCHVISION_Y_click2 = -1;



int Camera_Variation = 0; // 1;







class solarchvision_Materials {

  int Number = 11; //256; // 0, 1, 2, ... , 10

  int Selection = 1; //2; // yellow

  float[][][] DirectArea_Data = new float [this.Number][24][365];
  int[][] DirectArea_Flags = new int [24][365];

  float[][][] DiffuseArea_Data = new float [this.Number][24][365];
  int[][] DiffuseArea_Flags = new int [24][365];

  int[][] Color = new int [this.Number][4]; // ARGB
  {
    {
      int[] COL = {
        255, 255, 127, 0
      };
      this.Color[0] = COL;
    }
    {
      int[] COL = {
        255, 255, 0, 0
      };
      this.Color[1] = COL;
    }
    {
      int[] COL = {
        255, 255, 255, 0
      };
      this.Color[2] = COL;
    }
    {
      int[] COL = {
        255, 0, 255, 0
      };
      this.Color[3] = COL;
    }
    {
      int[] COL = {
        255, 0, 255, 255
      };
      this.Color[4] = COL;
    }
    {
      int[] COL = {
        255, 0, 0, 255
      };
      this.Color[5] = COL;
    }
    {
      int[] COL = {
        255, 255, 0, 255
      };
      this.Color[6] = COL;
    }
    {
      int[] COL = {
        255, 255, 255, 255
      };
      this.Color[7] = COL;
    }
    {
      //int[] COL = {255, 63, 63, 63};
      int[] COL = {
        63, 63, 63, 63
      };
      this.Color[8] = COL;
    }
    {
      //int[] COL = {255, 127, 127, 127};
      int[] COL = {
        127, 127, 127, 127
      };
      this.Color[9] = COL;
    }
    {
      //int[] COL = {255, 191, 191, 191};
      int[] COL = {
        191, 191, 191, 191
      };
      this.Color[10] = COL;
    }

    {
      for (int mt = 11; mt < this.Number; mt++) {
        int[] COL = {
          255, int(random(256)), int(random(256)), int(random(256))
        };
        this.Color[mt] = COL;
      }
    }
  }

  void empty_DirectArea () {

    for (int mt = 0; mt < this.Number; mt++) {
      for (int i = 0; i < 24; i++) {
        for (int j = 0; j < 365; j++) {
          this.DirectArea_Data[mt][i][j] = FLOAT_undefined;
          this.DirectArea_Flags[i][j] = -1;
        }
      }
    }
  }

  void empty_DiffuseArea () {

    for (int mt = 0; mt < this.Number; mt++) {
      for (int i = 0; i < 24; i++) {
        for (int j = 0; j < 365; j++) {
          this.DiffuseArea_Data[mt][i][j] = FLOAT_undefined;
          this.DiffuseArea_Flags[i][j] = -1;
        }
      }
    }
  }

}

solarchvision_Materials allMaterials = new solarchvision_Materials();




class solarchvision_Faces {

  private final static String CLASS_STAMP = "Faces";

  solarchvision_Faces () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = true;
  boolean displayNormals = false;
  boolean displayEdges = true;

  int displayTessellation = 2;

  int ACTIVE_pallet_CLR = 19; //15; //14;
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1;

  int PASSIVE_pallet_CLR = 1;
  int PASSIVE_pallet_DIR = 1;
  float PASSIVE_pallet_MLT = 0.2;


  int[][] nodes;
  int[][] options;

  void makeEmpty (int n) {

    this.nodes = new int [n][0];
    this.options = new int [n][6];

    if (allGroups != null) {
      for (int q = 0; q < allGroups.num; q++) {
        allGroups.Faces[q][0] = 0;
        allGroups.Faces[q][1] = -1;
      }
    }

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Faces();
    }

    SOLARCHVISION_model_changed();
  }


  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }

  int getVisibility (int n) {
    return this.options[n][3];
  }

  int getWeight (int n) {
    return this.options[n][4];
  }

  int getClose (int n) {
    return this.options[n][5];
  }

  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }

  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }

  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }

  void setClose (int n, int close) {
    this.options[n][5] = close;
  }


  void beginNewFace () {

    int[] newFace_nodes = {};

    this.create(newFace_nodes);

  }

  void add_VertexToLastFace (float x, float y, float z) {

    int n = this.nodes.length - 1;

    int[] newVertex = {
      allPoints.create(x, y, z)
    };

    this.nodes[n] = (int[]) concat(this.nodes[n], newVertex);

  }




  int create (int[] f) {

    int[][] newFace_options = {
      {
        current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
      }
    };

    this.options =  (int[][]) concat(this.options, newFace_options);

    int[][] newFace_nodes = {
      f
    };

    this.nodes = (int[][]) concat(this.nodes, newFace_nodes);


    if (allGroups.num > 0) allGroups.Faces[allGroups.num - 1][1] = this.nodes.length - 1;

    return(this.nodes.length - 1);
  }










  void draw (int target_window) {

    if (this.displayAll) {

      if (target_window == TypeWindow.WIN3D) {

        if (this.displayNormals) {

          for (int f = 0; f < this.nodes.length; f++) {

            int vsb = this.getVisibility(f);

            if (vsb > 0) {

              float[][] base_Vertices = new float [this.nodes[f].length][3];
              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];
                base_Vertices[j][0] = allPoints.getX(vNo);
                base_Vertices[j][1] = allPoints.getY(vNo);
                base_Vertices[j][2] = allPoints.getZ(vNo);
              }

              float G_x0 = 0;
              float G_y0 = 0;
              float G_z0 = 0;

              float G_x1 = 0;
              float G_y1 = 0;
              float G_z1 = 0;

              float n = float(base_Vertices.length);

              for (int s = 0; s < base_Vertices.length; s++) {

                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;

                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
                PVector UV = U.cross(V);
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);

                float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
                float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
                float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;

                float x1 = (base_Vertices[s][0] + W[0]) * OBJECTS_scale * WIN3D.scale;
                float y1 = (base_Vertices[s][1] + W[1]) * OBJECTS_scale * WIN3D.scale;
                float z1 = (base_Vertices[s][2] + W[2]) * OBJECTS_scale * WIN3D.scale;

                G_x0 += x0 / n;
                G_y0 += y0 / n;
                G_z0 += z0 / n;

                G_x1 += x1 / n;
                G_y1 += y1 / n;
                G_z1 += z1 / n;
              }

              WIN3D.graphics.strokeWeight(3);
              WIN3D.graphics.stroke(127, 255, 127);
              WIN3D.graphics.line(G_x0, -G_y0, G_z0, G_x1, -G_y1, G_z1);

              WIN3D.graphics.strokeWeight(1);
              WIN3D.graphics.stroke(0, 127, 0);

              for (int s = 0; s < base_Vertices.length; s++) {

                float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
                float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
                float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;

                WIN3D.graphics.line(x0, -y0, z0, G_x1, -G_y1, G_z1);
              }
            }
          }
        }

        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0, 0, 0);
        if (this.displayEdges == false) WIN3D.graphics.noStroke();

        int PAL_type = SHADE.get_PAL_type();
        int PAL_direction = SHADE.get_PAL_direction();
        float PAL_multiplier = SHADE.get_PAL_multiplier();

        for (int f = 0; f < this.nodes.length; f++) {

          int vsb = this.getVisibility(f);

          if (vsb > 0) {

            if (WIN3D.FacesShade == SHADE.Surface_Base) {

              WIN3D.graphics.fill(255, 255, 255);

              WIN3D.graphics.beginShape();

              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];

                WIN3D.graphics.vertex(allPoints.getX(vNo) * OBJECTS_scale * WIN3D.scale,
                                     -allPoints.getY(vNo) * OBJECTS_scale * WIN3D.scale,
                                      allPoints.getZ(vNo) * OBJECTS_scale * WIN3D.scale);
              }

              WIN3D.graphics.endShape(CLOSE);
            } else {

              int mt = this.getMaterial(f);

              int tessellation = this.getTessellation(f);

              int totalNumberOfSubs = 1;
              if (this.getMaterial(f) == 0) {
                tessellation += this.displayTessellation;
              }
              if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

              float[][] base_Vertices = new float [this.nodes[f].length][3];
              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];
                base_Vertices[j][0] = allPoints.getX(vNo);
                base_Vertices[j][1] = allPoints.getY(vNo);
                base_Vertices[j][2] = allPoints.getZ(vNo);
              }

              for (int n = 0; n < totalNumberOfSubs; n++) {

                float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

                WIN3D.graphics.beginShape();

                for (int s = 0; s < subFace.length; s++) {

                  if (WIN3D.FacesShade != SHADE.Surface_Wire) {

                    float[] COL = {
                      255, 255, 255, 255
                    };

                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;

                      COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {

                      COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {

                      COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {

                      COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                      COL = SHADE.vertexRender_Surface_Materials(mt);
                    }

                    if (WIN3D.FacesShade == SHADE.Surface_White) {
                      COL = SHADE.vertexRender_Surface_White(255);
                    }

                    WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                  } else {
                    WIN3D.graphics.noFill();
                  }

                  WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale,
                                       -subFace[s][1] * OBJECTS_scale * WIN3D.scale,
                                        subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                }

                WIN3D.graphics.endShape(CLOSE);
              }
            }
          }
        }
      }


      if (target_window == TypeWindow.OBJ3D) {

        int Create_Face_Texture = 0;

        if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solid) ||
            (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {
          Create_Face_Texture = 1;
        }

        if (Create_Face_Texture == 0) {

          if (User3D.export_MaterialLibrary) {

            int[] used_Materials = new int [allMaterials.Number];

            for (int i = 0; i < used_Materials.length; i++) {
              used_Materials[i] = 0;
            }

            for (int f = 0; f < this.nodes.length; f++) {

              int mt = this.getMaterial(f);

              used_Materials[mt] += 1;
            }

            for (int mt = 0; mt < allMaterials.Number; mt++) {

              if (used_Materials[mt] != 0) {

                float a = allMaterials.Color[mt][0] / 255.0;
                float r = allMaterials.Color[mt][1] / 255.0;
                float g = allMaterials.Color[mt][2] / 255.0;
                float b = allMaterials.Color[mt][3] / 255.0;

                mtlOutput.println("newmtl SurfaceMaterial" + nf(mt, 0));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // ambient
                mtlOutput.println("\tKd " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                mtlOutput.println("\td " + nf(a, 0, 3)); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr " + nf(a, 0, 3)); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
              }
            }
          }


          for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

            if (allGroups.getStart_Face(OBJ_ID) <= allGroups.getStop_Face(OBJ_ID)) {

              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {

                num_vertices_added = 0;

                for (int _turn = 1; _turn < 4; _turn++) {

                  if (_turn == 3) {
                    if (User3D.export_PolyToPoly == 1) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_ID, 0) + "_side" + nf(back_or_front, 0));
                    }
                  }

                  int prev_mt = -1;

                  for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

                    if (_turn == 3) {
                      if (User3D.export_MaterialLibrary) {
                        int mt = this.getMaterial(f);
                        if (prev_mt != mt) {
                          objOutput.println("usemtl SurfaceMaterial" + nf(mt, 0));
                          prev_mt = mt;
                        }
                      }
                    }

                    int tessellation = this.getTessellation(f);

                    int totalNumberOfSubs = 1;
                    if (this.getMaterial(f) == 0) {
                      tessellation += this.displayTessellation;
                    }

                    if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

                    float[][] base_Vertices = new float [this.nodes[f].length][3];
                    for (int j = 0; j < this.nodes[f].length; j++) {
                      int vNo = this.nodes[f][j];
                      base_Vertices[j][0] = allPoints.getX(vNo);
                      base_Vertices[j][1] = allPoints.getY(vNo);
                      base_Vertices[j][2] = allPoints.getZ(vNo);
                    }

                    for (int n = 0; n < totalNumberOfSubs; n++) {

                      float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

                      for (int s = 0; s < subFace.length; s++) {

                        if (_turn == 1) {
                          SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                        }

                        if (_turn == 2) {

                          float t = PI / float(subFace.length);

                          float u = 0.5 * cos((2 * s + 1) * t) / cos(t) + 0.5;
                          float v = 0.5 * sin((2 * s + 1) * t) / cos(t) + 0.5;

                          SOLARCHVISION_OBJprintVtexture(u, v, 0);
                        }
                      }


                      if (_turn == 3) {

                        num_vertices_added += subFace.length;

                        if (User3D.export_PolyToPoly == 0) {
                          obj_lastGroupNumber += 1;
                          objOutput.println("g Object3D_" + nf(OBJ_ID, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                        }

                        obj_lastFaceNumber += 1;

                        objOutput.print("f ");
                        if (back_or_front == 1) {
                          for (int s = 0; s < subFace.length; s++) {
                            String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                            String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);
                            objOutput.print(n_txt + "/" + m_txt);
                            if (s < subFace.length - 1) {
                              objOutput.print(" ");
                            }
                          }
                        } else {
                          for (int s = subFace.length - 1; s >= 0; s--) {
                            String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                            String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);
                            objOutput.print(n_txt + "/" + m_txt);
                            if (s > 0) {
                              objOutput.print(" ");
                            }
                          }
                        }
                        objOutput.println("");
                      }
                    }
                  }
                }

                obj_lastVertexNumber += num_vertices_added;
                obj_lastVtextureNumber += num_vertices_added;
              }
            }
          }
        } else {

          int PAL_type = SHADE.get_PAL_type();
          int PAL_direction = SHADE.get_PAL_direction();
          float PAL_multiplier = SHADE.get_PAL_multiplier();

          String the_filename = "";
          String TEXTURE_path = "";

          if (User3D.export_MaterialLibrary) {

            the_filename = "shadePallet.bmp";

            TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

            println("Saving texture:", TEXTURE_path);

            int RES1 = User3D.export_PalletResolution;
            int RES2 = User3D.export_PalletResolution / 16;

            PImage pallet_Texture = createImage(RES1, RES2, ARGB);


            pallet_Texture.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              float _val = (Image_X / (0.5 * RES1)) - 1;

              float _u = 0.5 + _val;

              if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                  (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
              }

              float[] COL = PAINT.getColorStyle(PAL_type, _u);

              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }

            pallet_Texture.updatePixels();

            pallet_Texture.save(TEXTURE_path);



            mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

            //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map

          }


          for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

            if (allGroups.getStart_Face(OBJ_ID) <= allGroups.getStop_Face(OBJ_ID)) {

              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {

                num_vertices_added = 0;

                for (int _turn = 1; _turn < 4; _turn++) {

                  int CurrentFaceTextureNumber = -1;

                  if (_turn == 3) {

                    if (User3D.export_PolyToPoly == 1) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_ID, 0) + "_side" + nf(back_or_front, 0));
                    }

                    if (User3D.export_MaterialLibrary) {

                      objOutput.println("usemtl " +  the_filename.replace('.', '_'));

                    }
                  }

                  for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

                    int tessellation = this.getTessellation(f);

                    int totalNumberOfSubs = 1;
                    if (this.getMaterial(f) == 0) {
                      tessellation += this.displayTessellation;
                    }

                    if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

                    float x1 = 0;
                    float y1 = 0;
                    float z1 = 0;

                    float x2 = 0;
                    float y2 = 0;
                    float z2 = 0;

                    float x3 = 0;
                    float y3 = 0;
                    float z3 = 0;

                    float x4 = 0;
                    float y4 = 0;
                    float z4 = 0;

                    float[][] base_Vertices = new float [this.nodes[f].length][3];
                    for (int j = 0; j < this.nodes[f].length; j++) {
                      int vNo = this.nodes[f][j];
                      base_Vertices[j][0] = allPoints.getX(vNo);
                      base_Vertices[j][1] = allPoints.getY(vNo);
                      base_Vertices[j][2] = allPoints.getZ(vNo);
                    }

                    for (int n = 0; n < totalNumberOfSubs; n++) {

                      float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

                      CurrentFaceTextureNumber += 1;

                      if (_turn == 1) {

                        if (User3D.export_MaterialLibrary) {

                          for (int s = 0; s < subFace.length; s++) {

                            float[] COL = {
                              255, 255, 255, 255
                            };

                            if (s == 0) {
                              x1 = subFace[s][0];
                              y1 = subFace[s][1];
                              z1 = subFace[s][2];
                            }
                            if (s == 1) {
                              x2 = subFace[s][0];
                              y2 = subFace[s][1];
                              z2 = subFace[s][2];
                            }
                            if (s == 2) {
                              x3 = subFace[s][0];
                              y3 = subFace[s][1];
                              z3 = subFace[s][2];
                            }
                            if (s == 3) {
                              x4 = subFace[s][0];
                              y4 = subFace[s][1];
                              z4 = subFace[s][2];
                            }
                          }

                        }

                        SOLARCHVISION_OBJprintVertex(x1, y1, z1);
                        SOLARCHVISION_OBJprintVertex(x2, y2, z2);
                        SOLARCHVISION_OBJprintVertex(x3, y3, z3);
                        SOLARCHVISION_OBJprintVertex(x4, y4, z4);
                      }

                      if (_turn == 2) {

                        for (int s = 0; s < subFace.length; s++) {

                          float _u = 0;

                          if (WIN3D.FacesShade == SHADE.Global_Solar) {
                            int s_next = (s + 1) % subFace.length;
                            int s_prev = (s + subFace.length - 1) % subFace.length;

                            if (back_or_front == 0) {
                              int s_temp = s_next;
                              s_next = s_prev;
                              s_prev = s_temp;
                            }

                            _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                          }

                          if (WIN3D.FacesShade == SHADE.Vertex_Solar) {

                            _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }

                          if (WIN3D.FacesShade == SHADE.Vertex_Solid) {

                            _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }

                          if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {

                            _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }


                          float u0 = 0.5 * (_u + 0.5);

                          if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                              (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

                            if (Impact_TYPE == Impact_ACTIVE) {
                              u0 = _u;
                            }
                          }

                          if (u0 > 1) u0 = 1;
                          if (u0 < 0) u0 = 0;

                          SOLARCHVISION_OBJprintVtexture(u0, 0.5, 0);
                        }


                      }

                      if (_turn == 3) {

                        num_vertices_added += 4;

                        if (User3D.export_PolyToPoly == 0) {
                          obj_lastGroupNumber += 1;
                          objOutput.println("g Object3D_" + nf(OBJ_ID, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                        }

                        String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                        String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                        String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                        String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                        String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                        String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                        String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                        String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

                        obj_lastFaceNumber += 1;
                        if (back_or_front == 1) {
                          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                        } else {
                          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                        }
                      }
                    }
                  }
                }

                obj_lastVertexNumber += num_vertices_added;
                obj_lastVtextureNumber += num_vertices_added;
              }
            }
          }
        }
      }

      if (target_window == TypeWindow.HTML) {

        int Create_Face_Texture = 0;

        if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solid) ||
            (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {

          Create_Face_Texture = 1;
        }

        int PAL_type = SHADE.get_PAL_type();
        int PAL_direction = SHADE.get_PAL_direction();
        float PAL_multiplier = SHADE.get_PAL_multiplier();

        String the_filename = "";
        String TEXTURE_path = "";

        if (User3D.export_MaterialLibrary) {

          if (Create_Face_Texture == 0) {

            int[] used_Materials = new int [allMaterials.Number];

            for (int i = 0; i < used_Materials.length; i++) {
              used_Materials[i] = 0;
            }

            for (int f = 0; f < this.nodes.length; f++) {

              int mt = this.getMaterial(f);

              used_Materials[mt] += 1;
            }

            for (int mt = 0; mt < allMaterials.Number; mt++) {

              if (used_Materials[mt] != 0) {

                htmlOutput.println("\t\t\t\t<Appearance DEF='SurfaceMaterial" + nf(mt, 0) + "'>");
                htmlOutput.print  ("\t\t\t\t\t<Material");
                htmlOutput.print  (" transparency='" + nf(1 - allMaterials.Color[mt][0] / 255.0, 0, 3) + "'");
                htmlOutput.print  (" diffuseColor='" + nf(allMaterials.Color[mt][1] / 255.0, 0, 3) + " " +
                                                       nf(allMaterials.Color[mt][2] / 255.0, 0, 3) + " " +
                                                       nf(allMaterials.Color[mt][3] / 255.0, 0, 3) + "'");
                htmlOutput.println("></Material>");
                htmlOutput.println("\t\t\t\t</Appearance>");

              }
            }

          } else {

            the_filename = "shadePallet.bmp";

            TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

            htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
            htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
            htmlOutput.println("\t\t\t\t</Appearance>");

            println("Saving texture:", TEXTURE_path);

            int RES1 = User3D.export_PalletResolution;
            int RES2 = User3D.export_PalletResolution / 16;

            PImage pallet_Texture = createImage(RES1, RES2, ARGB);

            pallet_Texture.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              float _val = (Image_X / (0.5 * RES1)) - 1;

              float _u = 0.5 + _val;

              if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                  (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

                if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
              }

              float[] COL = PAINT.getColorStyle(PAL_type, _u);

              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }

            pallet_Texture.updatePixels();

            pallet_Texture.save(TEXTURE_path);

          }
        }


        for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

          if (allGroups.getStart_Face(OBJ_ID) <= allGroups.getStop_Face(OBJ_ID)) {

            htmlOutput.println("\t\t\t\t<group>");

            for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

              if (this.nodes[f].length > 2) {

                int mt = this.getMaterial(f);

                int tessellation = this.getTessellation(f);

                int totalNumberOfSubs = 1;
                if (this.getMaterial(f) == 0) {
                  tessellation += this.displayTessellation;
                }

                if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

                float[][] base_Vertices = new float [this.nodes[f].length][3];
                for (int j = 0; j < this.nodes[f].length; j++) {
                  int vNo = this.nodes[f][j];
                  base_Vertices[j][0] = allPoints.getX(vNo);
                  base_Vertices[j][1] = allPoints.getY(vNo);
                  base_Vertices[j][2] = allPoints.getZ(vNo);
                }

                for (int n = 0; n < totalNumberOfSubs; n++) {

                  float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

                  for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {

                    htmlOutput.println("\t\t\t\t\t<shape>");

                    if (Create_Face_Texture == 0) {
                      htmlOutput.println("\t\t\t\t\t\t<Appearance USE='SurfaceMaterial" + nf(mt, 0) + "'></Appearance>");
                    }
                    else {
                      htmlOutput.println("\t\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");
                    }


                    htmlOutput.print  ("\t\t\t\t\t\t<IndexedFaceSet");

                    htmlOutput.print  (" coordIndex='");
                    for (int q = 0; q < subFace.length; q++) {
                      if (q > 0) {
                        htmlOutput.print(" ");
                      }
                      htmlOutput.print(nf(q, 0));
                    }
                    htmlOutput.println(" -1'>");

                    htmlOutput.print  ("\t\t\t\t\t\t\t<Coordinate point='");
                    for (int q = 0; q < subFace.length; q++) {
                      if (q > 0) {
                        htmlOutput.print(",");
                      }
                      int s = q;
                      if (back_or_front == 0) {
                        s = subFace.length - 1 - q;
                      }

                      htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " +
                                       nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " +
                                       nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                    }
                    htmlOutput.println("'></Coordinate>");






                    if (Create_Face_Texture == 1) {

                      htmlOutput.print  ("\t\t\t\t\t\t\t<TextureCoordinate point='");
                      for (int q = 0; q < subFace.length; q++) {
                        if (q > 0) {
                          htmlOutput.print(",");
                        }
                        int s = q;
                        if (back_or_front == 0) {
                          s = subFace.length - 1 - q;
                        }

                        float _u = 0;


                        if (WIN3D.FacesShade == SHADE.Global_Solar) {
                          int s_next = (s + 1) % subFace.length;
                          int s_prev = (s + subFace.length - 1) % subFace.length;

                          if (back_or_front == 0) {
                            int s_temp = s_next;
                            s_next = s_prev;
                            s_prev = s_temp;
                          }

                          _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                        }

                        if (WIN3D.FacesShade == SHADE.Vertex_Solar) {

                          _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }

                        if (WIN3D.FacesShade == SHADE.Vertex_Solid) {

                          _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }

                        if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {

                          _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }


                        float u0 = 0.5 * (_u + 0.5);

                        if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                            (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

                          if (Impact_TYPE == Impact_ACTIVE) {
                            u0 = _u;
                          }
                        }

                        if (u0 > 1) u0 = 1;
                        if (u0 < 0) u0 = 0;

                        SOLARCHVISION_HTMLprintVtexture(u0, 0.5);
                      }

                      htmlOutput.println("'></TextureCoordinate>");
                    }


                    htmlOutput.println("\t\t\t\t\t\t</IndexedFaceSet>");

                    htmlOutput.println("\t\t\t\t\t</shape>");

                  }
                }
              }
            }
            htmlOutput.println("\t\t\t\t</group>");
          }
        }
      }


      if (target_window == TypeWindow.RAD3D) {

        int[] used_Materials = new int [allMaterials.Number];

        for (int i = 0; i < used_Materials.length; i++) {
          used_Materials[i] = 0;
        }

        for (int f = 0; f < this.nodes.length; f++) {

          int mt = this.getMaterial(f);

          used_Materials[mt] += 1;
        }

        for (int mt = 0; mt < allMaterials.Number; mt++) {

          if (used_Materials[mt] != 0) {

            float a = allMaterials.Color[mt][0] / 255.0;
            float r = allMaterials.Color[mt][1] / 255.0;
            float g = allMaterials.Color[mt][2] / 255.0;
            float b = allMaterials.Color[mt][3] / 255.0;

            radOutput.println("void plastic " + "SurfaceMaterial" + nf(mt, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 " + nf(r, 0, User3D.export_PrecisionVtexture) + " " +
                                     nf(g, 0, User3D.export_PrecisionVtexture) + " " +
                                     nf(b, 0, User3D.export_PrecisionVtexture) + " 0 0");

          }
        }

        for (int f = 0; f < this.nodes.length; f++) {

          if (this.nodes[f].length > 2) {

            int mt = this.getMaterial(f);

            int tessellation = this.getTessellation(f);

            int totalNumberOfSubs = 1;
            if (this.getMaterial(f) == 0) {
              tessellation += this.displayTessellation;
            }

            if ((this.nodes[f].length > 4) && (tessellation == 0)) { // don't need it for triangles
              tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
            }

            if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

            float[][] base_Vertices = new float [this.nodes[f].length][3];
            for (int j = 0; j < this.nodes[f].length; j++) {
              int vNo = this.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }

            for (int n = 0; n < totalNumberOfSubs; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {

                if (back_or_front == 1) {

                  radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");

                  radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[1][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[2][2], 0, User3D.export_PrecisionVertex));

                  if (subFace.length == 4) {

                    radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                    radOutput.println("0");
                    radOutput.println("0");
                    radOutput.println("9");

                    radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                  }


                } else {

                  radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");

                  radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " +
                                          nf(subFace[1][2], 0, User3D.export_PrecisionVertex));

                  if (subFace.length == 4) {

                    radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                    radOutput.println("0");
                    radOutput.println("0");
                    radOutput.println("9");

                    radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " +
                                            nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                  }
                }
              }
            }

            radOutput.println();
          }
        }
      }
    }
  }





  void castShadows () {

    if (this.displayAll) {

      for (int f = 0; f < this.nodes.length; f++) {

        int vsb = this.getVisibility(f);

        if (vsb > 0) {

          int  mt = this.getMaterial(f);
          if (allMaterials.Color[mt][0] > 127) {

            int tessellation = this.getTessellation(f);

            int totalNumberOfSubs = 1;
            if (this.getMaterial(f) == 0) {
              tessellation += this.displayTessellation;
            }
            if (tessellation > 0) totalNumberOfSubs = this.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

            float[][] base_Vertices = new float [this.nodes[f].length][3];
            for (int g = 0; g < this.nodes[f].length; g++) {
              int vNo = this.nodes[f][g];
              base_Vertices[g][0] = allPoints.getX(vNo);
              base_Vertices[g][1] = allPoints.getY(vNo);
              base_Vertices[g][2] = allPoints.getZ(vNo);
            }

            for (int n = 0; n < totalNumberOfSubs; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);
              float[][] subFace_Rotated = subFace;

              for (int s = 0; s < subFace_Rotated.length; s++) {
                if (allSolarImpacts.sectionType == 2) {
                  float a = subFace_Rotated[s][0];
                  float b = -subFace_Rotated[s][1];
                  float c = subFace_Rotated[s][2];

                  subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
                  subFace_Rotated[s][1] = c;
                  subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);
                } else if (allSolarImpacts.sectionType == 3) {
                }
              }

              SHADOW_graphics.beginShape();

              for (int s = 0; s < subFace_Rotated.length; s++) {

                float z = subFace_Rotated[s][2] - allSolarImpacts.Z;
                float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                if (z >= 0) {

                  if (allSolarImpacts.sectionType == 1) {
                    float px = x;
                    float py = y;

                    x = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                    y = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                  }

                  SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                } else {
                  int s_next = (s + 1) % subFace_Rotated.length;
                  int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;

                  float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.Z;
                  float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                  float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                  if (z_prev > 0) {
                    float ratio = z_prev / (z_prev - z);

                    float x_trim = x_prev * (1 - ratio) + x * ratio;
                    float y_trim = y_prev * (1 - ratio) + y * ratio;

                    if (allSolarImpacts.sectionType == 1) {
                      float px = x_trim;
                      float py = y_trim;

                      x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                      y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                    }

                    SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                  }

                  float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.Z;
                  float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                  float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                  if (z_next > 0) {
                    float ratio = z_next / (z_next - z);

                    float x_trim = x_next * (1 - ratio) + x * ratio;
                    float y_trim = y_next * (1 - ratio) + y * ratio;

                    if (allSolarImpacts.sectionType == 1) {
                      float px = x_trim;
                      float py = y_trim;

                      x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                      y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                    }

                    SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                  }
                }
              }

              SHADOW_graphics.endShape(CLOSE);
            }
          }
        }
      }
    }
  }



  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.nodes.length][7];

    for (int f = 0; f < this.nodes.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
      hitPoint[f][4] = FLOAT_undefined;
      hitPoint[f][5] = FLOAT_undefined;
      hitPoint[f][6] = FLOAT_undefined;
    }

    for (int f = 0; f < this.nodes.length; f++) {

      int n = this.nodes[f].length;

      if (n > 2) {

        int vsb = this.getVisibility(f);

        if (vsb > 0) {

          float X_intersect = FLOAT_undefined;
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};

          boolean InPoly = false;

          if (n < 5) { // works if n==3 or n==4

            float[] A = allPoints.getPosition(this.nodes[f][0]);
            float[] B = allPoints.getPosition(this.nodes[f][1]);
            float[] C = allPoints.getPosition(this.nodes[f][n - 2]);
            float[] D = allPoints.getPosition(this.nodes[f][n - 1]);

            float[] AC = funcs.vec3_diff(A, C);
            float[] BD = funcs.vec3_diff(B, D);

            face_norm = funcs.vec3_cross(AC, BD);

            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] +
                                        (A[1] + B[1] + C[1] + D[1]) * face_norm[1] +
                                        (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

            float R = -funcs.vec3_dot(ray_dir, face_norm);

            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {

                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                float[] P = {X_intersect, Y_intersect, Z_intersect};

                if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

              }
            }
          }
          else {

            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            };
            for (int j = 0; j < n; j++) {
              tmpFace[j] = this.nodes[f][j];
              G[0] += allPoints.getX(tmpFace[j]) / float(n);
              G[1] += allPoints.getY(tmpFace[j]) / float(n);
              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
            }

            for (int j = 0; j < n; j++) {

              int j_next = (j + 1) % n;

              float[] A = {
                allPoints.getX(this.nodes[f][j]),
                allPoints.getY(this.nodes[f][j]),
                allPoints.getZ(this.nodes[f][j])
              };

              float[] B = {
                allPoints.getX(this.nodes[f][j_next]),
                allPoints.getY(this.nodes[f][j_next]),
                allPoints.getZ(this.nodes[f][j_next])
              };

              float[] AG = funcs.vec3_diff(A, G);
              float[] BG = funcs.vec3_diff(B, G);

              face_norm = funcs.vec3_cross(AG, BG);

              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] +
                                                 (A[1] + B[1] + G[1]) * face_norm[1] +
                                                 (A[2] + B[2] + G[2]) * face_norm[2]);

              float R = -funcs.vec3_dot(ray_dir, face_norm);

              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {

                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                  float[] P = {X_intersect, Y_intersect, Z_intersect};

                  InPoly = funcs.isInside_Triangle(P, A, B, G);

                }
              }

              if (InPoly) break;
            }
          }

          if (InPoly) {
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
            hitPoint[f][4] = face_norm[0];
            hitPoint[f][5] = face_norm[1];
            hitPoint[f][6] = face_norm[2];
          }

        }
      }
    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.nodes.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
        return_point[5] = hitPoint[f][4];
        return_point[6] = hitPoint[f][5];
        return_point[7] = hitPoint[f][6];

      }

    }

    return return_point;
  }



  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "ni", this.nodes.length);
    for (int i = 0; i < this.nodes.length; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);
      String txt = "";
      for (int j = 0; j < this.nodes[i].length; j++) {
        txt += nf(this.nodes[i][j], 0);
        if (j < this.nodes[i].length - 1) txt += ",";
      }
      XML_setContent(child, txt);

      XML_setInt(child, "material", this.getMaterial(i));
      XML_setInt(child, "tessellation", this.getTessellation(i));
      XML_setInt(child, "layer", this.getLayer(i));
      XML_setInt(child, "visibility", this.getVisibility(i));
      XML_setInt(child, "weight", this.getWeight(i));
      XML_setInt(child, "close", this.getClose(i));
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);
    XML_setBoolean(parent, "displayNormals", this.displayNormals);
    XML_setBoolean(parent, "displayEdges", this.displayEdges);
    XML_setInt(parent, "displayTessellation", this.displayTessellation);

    XML_setInt(parent, "ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    XML_setInt(parent, "ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    XML_setFloat(parent, "ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    XML_setInt(parent, "PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    XML_setInt(parent, "PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    XML_setFloat(parent, "PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);
  }

  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = XML_getInt(parent, "ni");

    this.makeEmpty(ni);
    this.nodes = new int [0][0];

    XML[] children = parent.getChildren("item");

    for (int i = 0; i < ni; i++) {
      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");
      int nj = parts.length;
      int[][] newItem = new int [1][nj];
      for (int j = 0; j < nj; j++) {
        newItem[0][j] = int(parts[j]);
      }
      this.nodes = (int[][]) concat(this.nodes, newItem);

      this.setMaterial(i, children[i].getInt("material"));
      this.setTessellation(i, children[i].getInt("tessellation"));
      this.setLayer(i, children[i].getInt("layer"));
      this.setVisibility(i, children[i].getInt("visibility"));
      this.setWeight(i, children[i].getInt("weight"));
      this.setClose(i, children[i].getInt("close"));
    }

    this.displayAll = XML_getBoolean(parent, "displayAll");
    this.displayNormals = XML_getBoolean(parent, "displayNormals");
    this.displayEdges = XML_getBoolean(parent, "displayEdges");
    this.displayTessellation = XML_getInt(parent, "displayTessellation");

    this.ACTIVE_pallet_CLR = XML_getInt(parent, "ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = XML_getInt(parent, "ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = XML_getFloat(parent, "ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = XML_getInt(parent, "PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = XML_getInt(parent, "PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = XML_getFloat(parent, "PASSIVE_pallet_MLT");
  }

}

solarchvision_Faces allFaces = new solarchvision_Faces();

class solarchvision_Curves {

  private final static String CLASS_STAMP = "Curves";

  solarchvision_Curves () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = true;

  int[][] nodes;
  int[][] options;

  void makeEmpty (int n) {

    this.nodes = new int [n][0];
    this.options = new int [n][6];

    if (allGroups != null) {
      for (int q = 0; q < allGroups.num; q++) {
        allGroups.Curves[q][0] = 0;
        allGroups.Curves[q][1] = -1;
      }
    }

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Curves();
    }

    SOLARCHVISION_model_changed();
  }

  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }

  int getVisibility (int n) {
    return this.options[n][3];
  }

  int getWeight (int n) {
    return this.options[n][4];
  }

  int getClose (int n) {
    return this.options[n][5];
  }

  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }

  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }

  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }

  void setClose (int n, int close) {
    this.options[n][5] = close;
  }



  void beginNewCurve () {

    int[] newCurve_nodes = {};

    this.create(newCurve_nodes);
  }


  void add_VertexToLastCurve (float x, float y, float z) {

    int n = this.nodes.length - 1;

    int[] newVertex = {
      allPoints.create(x, y, z)
    };

    this.nodes[n] = (int[]) concat(this.nodes[n], newVertex);

  }


  int create (int[] f) {

    {

      int[][] newCurve_options = {
        {
          current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
        }
      };

      this.options =  (int[][]) concat(this.options, newCurve_options);

      int[][] newCurve_nodes = {
        f
      };

      this.nodes = (int[][]) concat(this.nodes, newCurve_nodes);
    }

    if (allGroups.num > 0) allGroups.Curves[allGroups.num - 1][1] = this.nodes.length - 1;

    return(this.nodes.length - 1);
  }


  void add_Spline (int m, int tes, int lyr, int vsb, int wgt, int clz, float[][] points) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    int[] newCurve_nodes = new int[points.length];

    for (int i = 0; i < points.length; i++) {
      newCurve_nodes[i] = allPoints.create(points[i][0], points[i][1], points[i][2]);
    }

    this.create(newCurve_nodes);
  }


  void add_Arc (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot, float TotalAngle) {

    float AngleStep = TotalAngle / float(n);
    int EndOfLoop = n;
    if (TotalAngle % 360 == 0) {
      EndOfLoop -= 1;
      clz = 1; // for right closing of a circle
    }

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;


    int[] newCurve_nodes = {
      allPoints.create(cx + r * funcs.cos_ang(0), cy + r * funcs.sin_ang(0), cz)
    };
    for (int i = 1; i <= EndOfLoop; i++) {
      float t = i * AngleStep + rot;
      int[] f = {
        allPoints.create(cx + r * funcs.cos_ang(t), cy + r * funcs.sin_ang(t), cz)
      };
      newCurve_nodes = concat(newCurve_nodes, f);
    }

    this.create(newCurve_nodes);
  }



  void draw (int target_window) {

    if (allFaces.displayAll) {

      if (target_window == TypeWindow.WIN3D) {

        WIN3D.graphics.strokeWeight(3);

        WIN3D.graphics.noFill();

        for (int f = 0; f < this.nodes.length; f++) {

          int vsb = this.getVisibility(f);

          if (vsb > 0) {

            int mt = this.getMaterial(f);

            float[] COL = {
              allMaterials.Color[mt][0], allMaterials.Color[mt][1], allMaterials.Color[mt][2], allMaterials.Color[mt][3]
            };

            float weight = 0.1 * this.getWeight(f);

            WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);

            int tessellation = int(pow(2, this.getTessellation(f)));

            float[][] base_Vertices = new float [this.nodes[f].length][3];
            for (int j = 0; j < this.nodes[f].length; j++) {
              int vNo = this.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }


            WIN3D.graphics.beginShape();

            int div = base_Vertices.length;

            for (int j = 0; j < base_Vertices.length; j++) {

              int drawSegment = 1;

              int nA = j % div;
              int nB = (j + 1)  % div;
              int nB_after = (j + 2) % div;
              int nA_before = (j - 1 + div) % div;

              if (this.getClose(f) == 0) { // if not closed

                if (nB_after < nB) nB_after = nB;
                if (nA_before > nA) nA_before = nA;

                if (j == base_Vertices.length - 1) drawSegment = 0;
              }

              if (drawSegment == 1) {

                for (int q = 0; q <= tessellation; q++) {

                  float[] P = {0, 0, 0};

                  for (int i = 0; i < 3; i++) {
                    P[i] = ((tessellation - q) * base_Vertices[nA][i] + q * base_Vertices[nB][i]) / float(tessellation);
                  }


                  float[] ANG_start = {0, 0, 0};
                  float[] ANG_end = {0, 0, 0};

                  for (int i = 0; i < 3; i++) {
                    ANG_start[i] = base_Vertices[nA][i] - base_Vertices[nA_before][i];

                    ANG_end[i] = base_Vertices[nB][i] - base_Vertices[nB_after][i];
                  }

                  if ((ANG_start[0] != 0) || (ANG_start[1] != 0) || (ANG_start[2] != 0)) {
                    ANG_start = funcs.vec3_unit(ANG_start);
                  }
                  if ((ANG_end[0] != 0) || (ANG_end[1] != 0) || (ANG_end[2] != 0)) {
                    ANG_end = funcs.vec3_unit(ANG_end);
                  }


                  float dist_start = dist(P[0], P[1], P[2], base_Vertices[nA][0], base_Vertices[nA][1], base_Vertices[nA][2]);
                  float dist_end = dist(P[0], P[1], P[2], base_Vertices[nB][0], base_Vertices[nB][1], base_Vertices[nB][2]);

                  for (int i = 0; i < 3; i++) {
                    ANG_start[i] *= dist_start;
                    ANG_end[i] *= dist_end;
                  }

                  for (int i = 0; i < 3; i++) {
                    P[i] += weight * ((tessellation - q) * ANG_start[i] + q * ANG_end[i]) / float(tessellation);
                  }



                  WIN3D.graphics.vertex(P[0] * OBJECTS_scale * WIN3D.scale, -(P[1] * OBJECTS_scale * WIN3D.scale), P[2] * OBJECTS_scale * WIN3D.scale);

                }
              }

            }

            if (this.getClose(f) == 0) { // if not closed
              WIN3D.graphics.endShape();
            }
            else {
              WIN3D.graphics.endShape(CLOSE);
            }


          }
        }

        WIN3D.graphics.strokeWeight(0);
      }
    }
  }




  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.nodes.length][7];

    for (int f = 0; f < this.nodes.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
      hitPoint[f][4] = FLOAT_undefined;
      hitPoint[f][5] = FLOAT_undefined;
      hitPoint[f][6] = FLOAT_undefined;
    }

    for (int f = 0; f < this.nodes.length; f++) {

      int n = this.nodes[f].length;

      if (n > 2) {

        int vsb = this.getVisibility(f);

        if (vsb > 0) {

          float X_intersect = FLOAT_undefined;
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};

          boolean InPoly = false;

          if (n < 5) { // works if n==3 or n==4

            float[] A = allPoints.getPosition(this.nodes[f][0]);
            float[] B = allPoints.getPosition(this.nodes[f][1]);
            float[] C = allPoints.getPosition(this.nodes[f][n - 2]);
            float[] D = allPoints.getPosition(this.nodes[f][n - 1]);

            float[] AC = funcs.vec3_diff(A, C);
            float[] BD = funcs.vec3_diff(B, D);

            face_norm = funcs.vec3_cross(AC, BD);

            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] +
                                        (A[1] + B[1] + C[1] + D[1]) * face_norm[1] +
                                        (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

            float R = -funcs.vec3_dot(ray_dir, face_norm);

            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {

                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                float[] P = {X_intersect, Y_intersect, Z_intersect};

                if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

              }
            }
          }
          else {

            int[] tmpCurve = new int[n];
            float[] G = {
              0, 0, 0
            };
            for (int j = 0; j < n; j++) {
              tmpCurve[j] = this.nodes[f][j];
              G[0] += allPoints.getX(tmpCurve[j]) / float(n);
              G[1] += allPoints.getY(tmpCurve[j]) / float(n);
              G[2] += allPoints.getZ(tmpCurve[j]) / float(n);
            }

            for (int j = 0; j < n; j++) {

              int j_next = (j + 1) % n;

              float[] A = {
                allPoints.getX(this.nodes[f][j]),
                allPoints.getY(this.nodes[f][j]),
                allPoints.getZ(this.nodes[f][j])
              };

              float[] B = {
                allPoints.getX(this.nodes[f][j_next]),
                allPoints.getY(this.nodes[f][j_next]),
                allPoints.getZ(this.nodes[f][j_next])
              };

              float[] AG = funcs.vec3_diff(A, G);
              float[] BG = funcs.vec3_diff(B, G);

              face_norm = funcs.vec3_cross(AG, BG);

              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] +
                                                 (A[1] + B[1] + G[1]) * face_norm[1] +
                                                 (A[2] + B[2] + G[2]) * face_norm[2]);

              float R = -funcs.vec3_dot(ray_dir, face_norm);

              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {

                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                  float[] P = {X_intersect, Y_intersect, Z_intersect};

                  InPoly = funcs.isInside_Triangle(P, A, B, G);

                }
              }

              if (InPoly) break;
            }
          }

          if (InPoly) {
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
            hitPoint[f][4] = face_norm[0];
            hitPoint[f][5] = face_norm[1];
            hitPoint[f][6] = face_norm[2];
          }

        }
      }
    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.nodes.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
        return_point[5] = hitPoint[f][4];
        return_point[6] = hitPoint[f][5];
        return_point[7] = hitPoint[f][6];

      }

    }

    return return_point;
  }





  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "ni", this.nodes.length);
    for (int i = 0; i < this.nodes.length; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);
      String txt = "";
      for (int j = 0; j < this.nodes[i].length; j++) {
        txt += nf(this.nodes[i][j], 0);
        if (j < this.nodes[i].length - 1) txt += ",";
      }
      XML_setContent(child, txt);

      XML_setInt(child, "material", this.getMaterial(i));
      XML_setInt(child, "tessellation", this.getTessellation(i));
      XML_setInt(child, "layer", this.getLayer(i));
      XML_setInt(child, "visibility", this.getVisibility(i));
      XML_setInt(child, "weight", this.getWeight(i));
      XML_setInt(child, "close", this.getClose(i));
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);

  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = XML_getInt(parent, "ni");

    this.makeEmpty(ni);
    this.nodes = new int [0][0];

    XML[] children = parent.getChildren("item");

    for (int i = 0; i < ni; i++) {
      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");
      int nj = parts.length;
      int[][] newItem = new int [1][nj];
      for (int j = 0; j < nj; j++) {
        newItem[0][j] = int(parts[j]);
      }
      this.nodes = (int[][]) concat(this.nodes, newItem);

      this.setMaterial(i, children[i].getInt("material"));
      this.setTessellation(i, children[i].getInt("tessellation"));
      this.setLayer(i, children[i].getInt("layer"));
      this.setVisibility(i, children[i].getInt("visibility"));
      this.setWeight(i, children[i].getInt("weight"));
      this.setClose(i, children[i].getInt("close"));
    }

    this.displayAll = XML_getBoolean(parent, "displayAll");

  }

}

solarchvision_Curves allCurves = new solarchvision_Curves();


class solarchvision_Groups {

  private final static String CLASS_STAMP = "Groups";

  solarchvision_Groups () { // constructor
    makeEmpty(0);
  }

  int num;
  int[][] Curves;
  int[][] Faces;
  int[][] Solids;
  int[][] Model1Ds;
  int[][] Model2Ds;
  float[][] Pivots;

  void makeEmpty (int n) {

    this.num = n;
    this.Model1Ds = new int [n][2];
    this.Model2Ds = new int [n][2];
    this.Faces = new int [n][2];
    this.Curves = new int [n][2];
    this.Solids = new int [n][2];
    this.Pivots = new float [n][9];

    if (Select3D != null) {
      Select3D.deselect_Groups();
    }

    SOLARCHVISION_model_changed();
  }



  int getStart_Curve (int n) {
    return this.Curves[n][0];
  }

  int getStop_Curve (int n) {
    return this.Curves[n][1];
  }

  int getStart_Face (int n) {
    return this.Faces[n][0];
  }

  int getStop_Face (int n) {
    return this.Faces[n][1];
  }

  int getStart_Solid (int n) {
    return this.Solids[n][0];
  }

  int getStop_Solid (int n) {
    return this.Solids[n][1];
  }

  int getStart_Model1D (int n) {
    return this.Model1Ds[n][0];
  }

  int getStop_Model1D (int n) {
    return this.Model1Ds[n][1];
  }

  int getStart_Model2D (int n) {
    return this.Model2Ds[n][0];
  }

  int getStop_Model2D (int n) {
    return this.Model2Ds[n][1];
  }

  void setStart_Curve (int n, int t) {
    this.Curves[n][0] = t;
  }

  void setStop_Curve (int n, int t) {
    this.Curves[n][1] = t;
  }

  void setStart_Face (int n, int t) {
    this.Faces[n][0] = t;
  }

  void setStop_Face (int n, int t) {
    this.Faces[n][1] = t;
  }

  void setStart_Solid (int n, int t) {
    this.Solids[n][0] = t;
  }

  void setStop_Solid (int n, int t) {
    this.Solids[n][1] = t;
  }

  void setStart_Model1D (int n, int t) {
    this.Model1Ds[n][0] = t;
  }

  void setStop_Model1D (int n, int t) {
    this.Model1Ds[n][1] = t;
  }

  void setStart_Model2D (int n, int t) {
    this.Model2Ds[n][0] = t;
  }

  void setStop_Model2D (int n, int t) {
    this.Model2Ds[n][1] = t;
  }


  void inserted_nFaces (int n, int fromFace, int howMany) {
    for (int i = n + 1; i < this.num; i++) {
      this.setStart_Face(i, this.getStart_Face(i) + howMany);
      this.setStop_Face(i, this.getStop_Face(i) + howMany);
    }

    this.setStop_Face(n, this.getStop_Face(n) + howMany); // because adding the faces also changes the end pointer of the same object

    for (int k = 0; k < Select3D.Face_ids.length; k++) {
      if (Select3D.Face_ids[k] != 0) {
        if (Select3D.Face_ids[k] > fromFace) {
          Select3D.Face_ids[k] += howMany;
        }
      }
    }
  }


  int beginNewGroup (float x, float y, float z, float sx, float sy, float sz, float rx, float ry, float rz) {

    float[][] newObject_Pivots = {
      {
        x, y, z, sx, sy, sz, rx, ry, rz
      }
    };
    this.Pivots = (float[][]) concat(this.Pivots, newObject_Pivots);

    int[][] newObject_allModel1Ds = {
      {
        allModel1Ds.num, -1
      }
    }; // i.e. null because start > end
    this.Model1Ds = (int[][]) concat(this.Model1Ds, newObject_allModel1Ds);

    int[][] newObject_allModel2Ds = {
      {
        allModel2Ds.num, -1
      }
    }; // i.e. null because start > end
    this.Model2Ds = (int[][]) concat(this.Model2Ds, newObject_allModel2Ds);

    int[][] newObject_allSolids = {
      {
        allSolids.DEF.length, -1
      }
    }; // i.e. null because start > end
    this.Solids = (int[][]) concat(this.Solids, newObject_allSolids);

    int[][] newObject_Faces = {
      {
        allFaces.nodes.length, -1
      }
    }; // i.e. null because start > end
    this.Faces = (int[][]) concat(this.Faces, newObject_Faces);

    int[][] newObject_Curves = {
      {
        allCurves.nodes.length, -1
      }
    }; // i.e. null because start > end
    this.Curves = (int[][]) concat(this.Curves, newObject_Curves);



    this.num += 1;

    return(this.num - 1);
  }






  void group_Selection (int createNewGroup) { // if this option == 0 then the objects are added to the last group


    boolean run_process = false;

    if (current_ObjectCategory == ObjectCategory.SOLID) run_process = true;
    if (current_ObjectCategory == ObjectCategory.FACE) run_process = true;
    if (current_ObjectCategory == ObjectCategory.CURVE) run_process = true;
    if (current_ObjectCategory == ObjectCategory.MODEL2D) run_process = true;
    if (current_ObjectCategory == ObjectCategory.MODEL1D) run_process = true;

    if (run_process) {

      if (createNewGroup == 1) {
        float x = Select3D.BoundingBox[1 + Select3D.alignX][0];
        float y = Select3D.BoundingBox[1 + Select3D.alignX][1];
        float z = Select3D.BoundingBox[1 + Select3D.alignX][2];

        float rot = User3D.create_Orientation;
        if (rot == 360) rot = WIN3D.rotation_Z;

        this.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
      }


      boolean pre_addToLastGroup = addToLastGroup;
      addToLastGroup = true;

      if (current_ObjectCategory == ObjectCategory.MODEL1D) {

        for (int o = 0; o < Select3D.Model1D_ids.length; o++) {

          int OBJ_ID = Select3D.Model1D_ids[o];

          float x = allModel1Ds.getX(OBJ_ID);
          float y = allModel1Ds.getY(OBJ_ID);
          float z = allModel1Ds.getZ(OBJ_ID);
          float d = allModel1Ds.getScale(OBJ_ID);
          float rot = allModel1Ds.getRotation(OBJ_ID);
          float tilt = allModel1Ds.getBranchTilt(OBJ_ID);
          float twist = allModel1Ds.getBranchTwist(OBJ_ID);
          float ratio = allModel1Ds.getBranchRatio(OBJ_ID);
          float base = allModel1Ds.getTreeBase(OBJ_ID);

          int n = allModel1Ds.getType(OBJ_ID);
          int dMax = allModel1Ds.getDegreeMax(OBJ_ID);
          int seed = allModel1Ds.getSeed(OBJ_ID);
          float trunkSize = allModel1Ds.getTrunkSize(OBJ_ID);
          float leafSize = allModel1Ds.getLeafSize(OBJ_ID);

          allModel1Ds.create(n, seed, dMax, x, y, z, d, rot, tilt, twist, ratio, base, trunkSize, leafSize);
        }
      }

      if (current_ObjectCategory == ObjectCategory.MODEL2D) {

        for (int o = 0; o < Select3D.Model2D_ids.length; o++) {

          int OBJ_ID = Select3D.Model2D_ids[o];

          float x = allModel2Ds.getX(OBJ_ID);
          float y = allModel2Ds.getY(OBJ_ID);
          float z = allModel2Ds.getZ(OBJ_ID);
          float s = allModel2Ds.getS(OBJ_ID);

          int n = allModel2Ds.MAP[OBJ_ID];
          if (allModel2Ds.isTree(n)) {
            allModel2Ds.create("TREES", n, x, y, z, s);
          } else {
            allModel2Ds.create("PEOPLE", n, x, y, z, s);
          }
        }
      }


      if (current_ObjectCategory == ObjectCategory.SOLID) {

        for (int o = 0; o < Select3D.Solid_ids.length; o++) {

          int OBJ_ID = Select3D.Solid_ids[o];

          float Solid_posX = allSolids.get_posX(OBJ_ID);
          float Solid_posY = allSolids.get_posY(OBJ_ID);
          float Solid_posZ = allSolids.get_posZ(OBJ_ID);
          float Solid_powX = allSolids.get_powX(OBJ_ID);
          float Solid_powY = allSolids.get_powY(OBJ_ID);
          float Solid_powZ = allSolids.get_powZ(OBJ_ID);
          float Solid_scaleX = allSolids.get_scaleX(OBJ_ID);
          float Solid_scaleY = allSolids.get_scaleY(OBJ_ID);
          float Solid_scaleZ = allSolids.get_scaleZ(OBJ_ID);
          float Solid_rotX = allSolids.get_rotX(OBJ_ID);
          float Solid_rotY = allSolids.get_rotY(OBJ_ID);
          float Solid_rotZ = allSolids.get_rotZ(OBJ_ID);
          float Solid_value = allSolids.get_value(OBJ_ID);

          allSolids.create(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
        }
      }




      if (current_ObjectCategory == ObjectCategory.FACE) {

        for (int o = 0; o < Select3D.Face_ids.length; o++) {

          int f = Select3D.Face_ids[o];

          int number_of_Vertices_before = allPoints.getLength();

          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

          if ((0 <= f) && (f < allFaces.nodes.length)) {

            int[] newFace_nodes = {
            };

            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];

              int vertex_listed = -1;

              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }

              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);

                int[] newVertexAdded = {
                  allPoints.create(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

                vertex_listed = PolymeshVertices_OLD.length - 1;
              }

              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };

              newFace_nodes = concat(newFace_nodes, new_vertexItem);
            }

            current_Material = allFaces.getMaterial(f);
            current_Tessellation = allFaces.getTessellation(f);
            current_Layer = allFaces.getLayer(f);
            current_Visibility = allFaces.getVisibility(f);

            allFaces.create(newFace_nodes);
          }
        }
      }


      if (current_ObjectCategory == ObjectCategory.CURVE) {

        for (int o = 0; o < Select3D.Curve_ids.length; o++) {

          int f = Select3D.Curve_ids[o];

          int number_of_Vertices_before = allPoints.getLength();

          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

          if ((0 <= f) && (f < allCurves.nodes.length)) {

            int[] newCurve_nodes = {
            };

            for (int j = 0; j < allCurves.nodes[f].length; j++) {
              int vNo = allCurves.nodes[f][j];

              int vertex_listed = -1;

              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }

              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);

                int[] newVertexAdded = {
                  allPoints.create(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

                vertex_listed = PolymeshVertices_OLD.length - 1;
              }

              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };

              newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
            }

            current_Material = allCurves.getMaterial(f);
            current_Tessellation = allCurves.getTessellation(f);
            current_Layer = allCurves.getLayer(f);
            current_Visibility = allCurves.getVisibility(f);
            current_Weight = allCurves.getWeight(f);
            current_Closed = allCurves.getClose(f);

            allCurves.create(newCurve_nodes);
          }
        }
      }



      addToLastGroup = pre_addToLastGroup;


      Delete3D.selection();


      Select3D.Group_ids = new int [1];
      Select3D.Group_ids[0] = this.num - 1;

      SOLARCHVISION_switch_category(ObjectCategory.GROUP);
    }
  }



  void ungroup_Selection () {

    if (current_ObjectCategory == ObjectCategory.GROUP) {

      Select3D.Group_ids = sort(Select3D.Group_ids);


      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        this.Faces[OBJ_ID][0] = 0;
        this.Faces[OBJ_ID][1] = -1;

        this.Curves[OBJ_ID][0] = 0;
        this.Curves[OBJ_ID][1] = -1;

        this.Model1Ds[OBJ_ID][0] = 0;
        this.Model1Ds[OBJ_ID][1] = -1;

        this.Model2Ds[OBJ_ID][0] = 0;
        this.Model2Ds[OBJ_ID][1] = -1;

        this.Solids[OBJ_ID][0] = 0;
        this.Solids[OBJ_ID][1] = -1;
      }

      Delete3D.selection();
    }
  }


  void dettachFromGroups_Selection () {

    this.group_Selection(1);
    this.ungroup_Selection();
  }


  void deleteEmptyGroups_Scene () {

    int pre_current_ObjectCategory = current_ObjectCategory;

    SOLARCHVISION_switch_category(ObjectCategory.GROUP);


    Select3D.deselect_Groups();

    for (int OBJ_ID = 0; OBJ_ID < this.num; OBJ_ID++) {

      if ((0 <= this.Faces   [OBJ_ID][0]) && (this.Faces   [OBJ_ID][0] <= this.Faces   [OBJ_ID][1])) continue;
      if ((0 <= this.Curves  [OBJ_ID][0]) && (this.Curves  [OBJ_ID][0] <= this.Curves  [OBJ_ID][1])) continue;
      if ((0 <= this.Model1Ds[OBJ_ID][0]) && (this.Model1Ds[OBJ_ID][0] <= this.Model1Ds[OBJ_ID][1])) continue;
      if ((0 <= this.Model2Ds[OBJ_ID][0]) && (this.Model2Ds[OBJ_ID][0] <= this.Model2Ds[OBJ_ID][1])) continue;
      if ((0 <= this.Solids  [OBJ_ID][0]) && (this.Solids  [OBJ_ID][0] <= this.Solids  [OBJ_ID][1])) continue;

      int[] emptyGroup = {
        OBJ_ID
      };

      Select3D.Group_ids = concat(Select3D.Group_ids, emptyGroup);
    }

    Delete3D.selection();

    current_ObjectCategory = pre_current_ObjectCategory;
  }





  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);
    XML_setInt(parent, "ni", this.num);

    for (int i = 0; i < this.num; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);

      XML_setString(child, "Model1Ds",
                    nf(this.getStart_Model1D(i), 0) + "|" +
                    nf(this.getStop_Model1D(i), 0));

      XML_setString(child, "Model2Ds",
                    nf(this.getStart_Model2D(i), 0) + "|" +
                    nf(this.getStop_Model2D(i), 0));

      XML_setString(child, "Faces",
                    nf(this.getStart_Face(i), 0) + "|" +
                    nf(this.getStop_Face(i), 0));

      XML_setString(child, "Curves",
                    nf(this.getStart_Curve(i), 0) + "|" +
                    nf(this.getStop_Curve(i), 0));

      XML_setString(child, "Solids",
                    nf(this.getStart_Solid(i), 0) + "|" +
                    nf(this.getStop_Solid(i), 0));

      String txt = "";
      for (int j = 0; j < 9; j++) {
        txt += nf(this.Pivots[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 < 9) txt += ",";
      }
      XML_setContent(child, txt);

    }
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = XML_getInt(parent, "ni");

    this.makeEmpty(ni);

    XML[] children = parent.getChildren("item");
    for (int i = 0; i < ni; i++) {

      {
        String[] parts = split(XML_getString(children[i], "Model1Ds"), "|");
        this.setStart_Model1D(i, int(parts[0]));
        this.setStop_Model1D(i, int(parts[1]));
      }

      {
        String[] parts = split(XML_getString(children[i], "Model2Ds"), "|");
        this.setStart_Model2D(i, int(parts[0]));
        this.setStop_Model2D(i, int(parts[1]));
      }

      {
        String[] parts = split(XML_getString(children[i], "Faces"), "|");
        this.setStart_Face(i, int(parts[0]));
        this.setStop_Face(i, int(parts[1]));
      }

      {
        String[] parts = split(XML_getString(children[i], "Curves"), "|");
        this.setStart_Curve(i, int(parts[0]));
        this.setStop_Curve(i, int(parts[1]));
      }

      {
        String[] parts = split(XML_getString(children[i], "Solids"), "|");
        this.setStart_Solid(i, int(parts[0]));
        this.setStop_Solid(i, int(parts[1]));
      }



      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");
      for (int j = 0; j < 9; j++) {
        this.Pivots[i][j] = float(parts[j]);
      }
    }
  }

}

solarchvision_Groups allGroups = new solarchvision_Groups();



class solarchvision_SolidImpacts {

  private final static String CLASS_STAMP = "SolidImpacts";

  boolean displayPoints = false;
  boolean displayLines = true;

  int complex = 0; // INTERNAL! 0:simple 1:complex


  float[] X = {
    0, 0, 0, 0
  };
  float[] Y = {
    0, 0, 0, 0
  };

  float[] Z = {
    0, 0.1, 0, 0
  }; // <<<

  float[] R = {
    0, 0, 0, 0
  };

  float[] U = {
    100, 100, 100, 100
  }; // i.e. 100m
  float[] V = {
    100, 100, 100, 100
  }; // i.e. 100m

  int RES1 = 200; //400;
  int RES2 = 200; //400;

  PImage Image = createImage(this.RES1, this.RES2, ARGB);



  boolean displayImage = true;
  int sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

  float positionStep = 1.25;


  int record_PDF = 0;
  int record_IMG = 0;

  float WindSpeed = 5; // (5m/s = 18 km/h)
  float WindDirection = 180.0;

  float Power = 1.0; //2.0; //3.0; // 1/2/3
  float Grade = 0.02; //1.0; //0.1; //10.0; //contour lines




  float get_Impact_atXYZ (float x, float y, float z) {

    float v = 0;

    if (this.complex == 0) {
      v = this.calculate_Impact_atXYZ_simple(x, y, z);
    } else {
      v = this.calculate_Impact_atXYZ_complex(x, y, z);
    }

    return v;
  }



  float calculate_Impact_atXYZ_simple (float x, float y, float z) {

    float val = 1;

    for (int n = 0; n < allSolids.DEF.length; n++) {

      float r = allSolids.get_value(n);
      float d = allSolids.get_Distance(n, x, y, z);

      //d *= pow(d, this.Power);
      d *= pow(d, this.Power / float(allSolids.DEF.length));

      if (val < 0) val *= abs(d - r);
      else {
        val *= d - r;
      }
    }

    if (allSolids.DEF.length > 0) {
      float val_sign = 1;
      if (val < 0) {
        val_sign = -1;
        val = abs(val);
      }
      val = pow(val, 1.0 / float(allSolids.DEF.length));
      val *= val_sign;
    }

    return val;
  }



  float calculate_Impact_atXYZ_complex (float x, float y, float z) {

    float deltaX = this.WindSpeed * funcs.cos_ang(this.WindDirection);
    float deltaY = this.WindSpeed * funcs.sin_ang(this.WindDirection);

    float[] val = {
      1, 1
    };

    for (int o = 0; o < 2; o++) {

      for (int n = 0; n < allSolids.DEF.length; n++) {

        float r = allSolids.get_value(n);
        float d = allSolids.get_Distance(n, x + o * deltaX, y + o * deltaY, z);

        //d *= pow(d, this.Power);
        d *= pow(d, this.Power / float(allSolids.DEF.length));

        if (val[o] < 0) val[o] *= abs(d - r);
        else {
          val[o] *= d - r;
        }
      }

      if (allSolids.DEF.length > 0) {
        float val_sign = 1;
        if (val[o] < 0) {
          val_sign = -1;
          val[o] = abs(val[o]);
        }
        val[o] = pow(val[o], 1.0 / float(allSolids.DEF.length));
        val[o] *= val_sign;
      }
    }

    return val[1] - val[0];
  }


  void calculate_Impact_selectedSections () {

    for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Section_ids[o];

      this.sectionType = allSections.get_type(f);
      this.RES1        = allSections.get_res1(f);
      this.RES2        = allSections.get_res2(f);

      this.X[this.sectionType] = allSections.getX(f);
      this.Y[this.sectionType] = allSections.getY(f);
      this.Z[this.sectionType] = allSections.getZ(f);
      this.R[this.sectionType] = allSections.getR(f);
      this.U[this.sectionType] = allSections.getU(f);
      this.V[this.sectionType] = allSections.getV(f);

      {
        if ((this.Image.width != this.RES1) || (this.Image.height != this.RES2)) {
          this.Image = createImage(this.RES1, this.RES2, ARGB);

          allSections.SolidImpact[f] = createImage(this.RES1, this.RES2, ARGB);
        }

        this.calculate_Impact_CurrentSection();

        allSections.SolidImpact[f].copy(this.Image, 0, 0, this.RES1, this.RES2, 0, 0, this.RES1, this.RES2);
      }
    }

  }


  float[] traceContour2D (int tracecomplex, float epsilon, float x, float y, float z, float dx, float dy, float dz, float v) {

    float t_max = FLOAT_undefined;
    float t_min = FLOAT_undefined;
    float t_equ = 0; //FLOAT_undefined;

    float v_max = FLOAT_undefined;
    float v_min = FLOAT_undefined;
    float v_equ = FLOAT_undefined;

    float x_max = FLOAT_undefined;
    float x_min = FLOAT_undefined;
    float x_equ = x + dx; //FLOAT_undefined;

    float y_max = FLOAT_undefined;
    float y_min = FLOAT_undefined;
    float y_equ = y + dy; //FLOAT_undefined;

    float z_max = FLOAT_undefined;
    float z_min = FLOAT_undefined;
    float z_equ = z + dz; //FLOAT_undefined;

    float min_dist = FLOAT_undefined;

    float r = epsilon;

    float t = funcs.atan2_ang(dy, dx);

    //for (int test_t = -180; test_t < 180; test_t += 5) {
    for (int test_t = -150; test_t <= 150; test_t += 5) { // <<<<

      float a = r * funcs.cos_ang(t + test_t);
      float b = r * funcs.sin_ang(t + test_t);
      float c = 0;

      if (this.sectionType == 1) {
        float Qx = a * funcs.cos_ang(-this.R[this.sectionType]) - b * funcs.sin_ang(-this.R[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(-this.R[this.sectionType]) + b * funcs.cos_ang(-this.R[this.sectionType]));
        float Qz = c;

        a = Qx;
        b = Qy;
        c = Qz;
      } else if (this.sectionType == 2) {
        float Qx = a * funcs.cos_ang(this.R[this.sectionType]) - c * funcs.sin_ang(this.R[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(this.R[this.sectionType]) + c * funcs.cos_ang(this.R[this.sectionType]));
        float Qz = -b;

        a = Qx;
        b = Qy;
        c = Qz;
      } else if (this.sectionType == 3) {
        float Qx = a * funcs.cos_ang(90 - this.R[this.sectionType]) - c * funcs.sin_ang(90 - this.R[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(90 - this.R[this.sectionType]) + c * funcs.cos_ang(90 - this.R[this.sectionType]));
        float Qz = -b;

        a = Qx;
        b = Qy;
        c = Qz;
      }

      float test_x = x + a;
      float test_y = y + b;
      float test_z = z + c;

      float test_v = this.get_Impact_atXYZ(test_x, test_y, test_z);

      if ((test_v < v_min) || (is_undefined(v_min))) {
        v_min = test_v;
        t_min = test_t;
        x_min = test_x;
        y_min = test_y;
        z_min = test_z;
      }
      if ((test_v > v_max) || (is_undefined(v_max))) {
        v_max = test_v;
        t_max = test_t;
        x_max = test_x;
        y_max = test_y;
        z_max = test_z;
      }

      //if (((abs(test_v - v) < min_dist) && (funcs.vec2_dot(test_x - x, test_y - y, dx, dy) >= 0)) || (is_undefined(v_equ)))  {
      if ((abs(test_v - v) < min_dist) || (is_undefined(v_equ))) {
        //if (funcs.vec2_dot(test_x - x, test_y - y, dx, dy) >= 0) {

        min_dist = abs(test_v - v);

        v_equ = test_v;
        t_equ = test_t;
        x_equ = test_x;
        y_equ = test_y;
        z_equ = test_z;
        //}
      }
    }


    float the_X = 0, the_Y = 0, the_Z = 0, the_T = 0;

    if (tracecomplex == 0) {
      the_X = x_equ;
      the_Y = y_equ;
      the_Z = z_equ;
      the_T = t_equ;
    }
    if (tracecomplex == -1) {
      the_X = x_min;
      the_Y = y_min;
      the_Z = z_min;
      the_T = t_min;
    }
    if (tracecomplex == 1) {
      the_X = x_max;
      the_Y = y_max;
      the_Z = z_max;
      the_T = t_max;
    }

    float[] return_array = {
      the_X, the_Y, the_Z, funcs.cos_ang(t + the_T), funcs.sin_ang(t + the_T), 0
    };

    return return_array;
  }


  float[][] traceContour3D (float epsilon, float x, float y, float z, float v) {

    float tz_max = FLOAT_undefined;
    float tz_min = FLOAT_undefined;
    float tz_equ = FLOAT_undefined;

    float txy_max = FLOAT_undefined;
    float txy_min = FLOAT_undefined;
    float txy_equ = FLOAT_undefined;

    float v_max = FLOAT_undefined;
    float v_min = FLOAT_undefined;
    float v_equ = FLOAT_undefined;

    float x_max = FLOAT_undefined;
    float x_min = FLOAT_undefined;
    float x_equ = FLOAT_undefined;

    float y_max = FLOAT_undefined;
    float y_min = FLOAT_undefined;
    float y_equ = FLOAT_undefined;

    float z_max = FLOAT_undefined;
    float z_min = FLOAT_undefined;
    float z_equ = FLOAT_undefined;

    float min_dist = FLOAT_undefined;

    float r = epsilon;

    for (int test_tz = -90; test_tz <= 90; test_tz += 30) { // in the space
      //for (int test_tz = 0; test_tz <= 0; test_tz += 30) { // on the surface!

      float c = r * funcs.sin_ang(test_tz);

      for (int test_txy = -180; test_txy < 180; test_txy += 15) {

        float a = r * funcs.cos_ang(test_tz) * funcs.cos_ang(test_txy);
        float b = r * funcs.cos_ang(test_tz) * funcs.sin_ang(test_txy);


        float test_x = x + a;
        float test_y = y + b;
        float test_z = z + c;

        float test_v = this.get_Impact_atXYZ(test_x, test_y, test_z);

        if ((test_v < v_min) || (is_undefined(v_min))) {
          v_min = test_v;
          tz_min = test_tz;
          txy_min = test_txy;
          x_min = test_x;
          y_min = test_y;
          z_min = test_z;
        }
        if ((test_v > v_max) || (is_undefined(v_max))) {
          v_max = test_v;
          tz_max = test_tz;
          txy_max = test_txy;
          x_max = test_x;
          y_max = test_y;
          z_max = test_z;
        }

        if ((abs(test_v - v) < min_dist) || (is_undefined(v_equ))) {

          min_dist = abs(test_v - v);

          v_equ = test_v;
          tz_equ = test_tz;
          txy_equ = test_txy;
          x_equ = test_x;
          y_equ = test_y;
          z_equ = test_z;
        }
      }
    }

    float[][] return_array = {
      {
        x_min, y_min, z_min, v_min
      }
      , {
        x_equ, y_equ, z_equ, v_equ
      }
      , {
        x_max, y_max, z_max, v_max
      }
    };

    return return_array;
  }





  float[][] Contours_U1Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  float[][] Contours_V1Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  float[][] Contours_V2Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  int[][] Contours_U1Lines = {
    {
      0, 0
    }
  };
  int[][] Contours_V1Lines = {
    {
      0, 0
    }
  };
  int[][] Contours_V2Lines = {
    {
      0, 0
    }
  };

  int Process_subDivisions = 1; //1; // 0,1,2,3

  float deltaStep = 0.05;
  float deltaLines = 0.1 * this.deltaStep;


  void calculate_Impact_CurrentSection () {

    if (this.sectionType != 0) {

      cursor(WAIT);

      this.Contours_U1Vertices = new float [1][4];
      this.Contours_U1Vertices[0][0] = 0;
      this.Contours_U1Vertices[0][1] = 0;
      this.Contours_U1Vertices[0][2] = 0;
      this.Contours_U1Vertices[0][3] = 0;

      this.Contours_V1Vertices = new float [1][4];
      this.Contours_V1Vertices[0][0] = 0;
      this.Contours_V1Vertices[0][1] = 0;
      this.Contours_V1Vertices[0][2] = 0;
      this.Contours_V1Vertices[0][3] = 0;

      this.Contours_V2Vertices = new float [1][4];
      this.Contours_V2Vertices[0][0] = 0;
      this.Contours_V2Vertices[0][1] = 0;
      this.Contours_V2Vertices[0][2] = 0;
      this.Contours_V2Vertices[0][3] = 0;

      this.Contours_U1Lines = new int [1][2];
      this.Contours_U1Lines[0][0] = 0;
      this.Contours_U1Lines[0][1] = 0;

      this.Contours_V1Lines = new int [1][2];
      this.Contours_V1Lines[0][0] = 0;
      this.Contours_V1Lines[0][1] = 0;

      this.Contours_V2Lines = new int [1][2];
      this.Contours_V2Lines[0][0] = 0;
      this.Contours_V2Lines[0][1] = 0;


      int PAL_type = allSolids.pallet_CLR;
      int PAL_direction = allSolids.pallet_DIR;
      float PAL_multiplier = allSolids.pallet_MLT;

      this.Image.loadPixels();

      float Section_X = this.X[this.sectionType];
      float Section_Y = this.Y[this.sectionType];
      float Section_Z = this.Z[this.sectionType];
      float Section_R = this.R[this.sectionType];
      float Section_U = this.U[this.sectionType];
      float Section_V = this.V[this.sectionType];

      int Section_complex = this.sectionType;
      int Section_RES1 = this.RES1;
      int Section_RES2 = this.RES2;

      float[][] ImageVertex = allSections.getCorners(Section_complex, Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_RES1, Section_RES2);

      float[] SectionCorner_A = ImageVertex[1];
      float[] SectionCorner_B = ImageVertex[2];
      float[] SectionCorner_C = ImageVertex[3];
      float[] SectionCorner_D = ImageVertex[4];

      for (int i = 0; i < this.RES1; i++) {
        for (int j = 0; j < this.RES2; j++) {

          float x = funcs.bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(this.RES1), 1 - j / float(this.RES2));
          float y = funcs.bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(this.RES1), 1 - j / float(this.RES2));
          float z = funcs.bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(this.RES1), 1 - j / float(this.RES2));

          this.complex = 0;
          float val = this.get_Impact_atXYZ(x, y, z);

          float g =      funcs.roundTo(this.Grade * val, this.deltaStep) - 0.5 * this.deltaStep;
          float g_line = funcs.roundTo(this.Grade * val, this.deltaLines);

          float _u = PAL_multiplier * val + 0.5;

          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;

          float[] COL = PAINT.getColorStyle(PAL_type, _u);

          if ((this.Process_subDivisions == 1) || (this.Process_subDivisions == 2)) {
            //if ((g == g_line) && (g != 0)) {
            if ((abs(g - g_line) < 0.001) && (g != 0)) {
              COL[0] = 0;
              COL[1] = 0;//255;
              COL[2] = 0;//255;
              COL[3] = 0;//255;
            }
          }

          if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {

            if ((abs(g - g_line) < 0.0001) && (g != 0) && (g_line <= 1)) {
              //if ((g_line > 1 - this.deltaLines) && (g_line <= 1)) { // not sure!

              float dx = 1;
              float dy = 0;
              float dz = 0;

              float[] test_point_dir = {
                x, y, z, dx, dy, dz
              };

              trace_U1Line(test_point_dir, g_line, 100);
            }
          }

          this.Image.pixels[i + j * this.RES1] = color(COL[1], COL[2], COL[3], COL[0]);
        }
      }

      this.Image.updatePixels();

      if (this.record_IMG == 1) {
        String myFile = getFilename_SolidImpact() + ".jpg";
        this.Image.save(myFile);
        println("File created:" + myFile);
      }



      if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {
        /*
         for (int k = 1; k < this.Contours_U1Vertices.length; k++) {

         float x = this.Contours_U1Vertices[k][0];
         float y = this.Contours_U1Vertices[k][1];
         float z = this.Contours_U1Vertices[k][2];

         float val = this.Contours_U1Vertices[k][3]; //this.get_Impact_atXYZ(x, y, z);

         float g =      funcs.roundTo(this.Grade * val, this.deltaStep) - 0.5 * this.deltaStep;
         float g_line = funcs.roundTo(this.Grade * val, this.deltaLines);

         float dx = 1;
         float dy = 0;
         float dz = 0;

         float[] test_point_dir = {x, y, z, dx, dy, dz};

         // making the first VVertex on the UVertice
         {
         float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade}};
         this.Contours_V1Vertices = (float[][]) concat(this.Contours_V1Vertices, newVertex);
         }

         // making the first WVertex on the UVertice
         {
         float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade}};
         this.Contours_V2Vertices = (float[][]) concat(this.Contours_V2Vertices, newVertex);
         }


         trace_V1Line(test_point_dir, g_line, 100);
         }
         */
      }

      if (this.record_PDF == 1) {

        String myFile = getFilename_SolidImpact() + ".pdf";

        PGraphics pdf = createGraphics(this.RES1, this.RES2, PDF, myFile);

        pdf.beginDraw();

        pdf.image(this.Image, 0, 0, this.RES1, this.RES2);

        if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {
          if (this.displayLines) {

            for (int U_or_V_or_W = 0; U_or_V_or_W < 3; U_or_V_or_W++) {

              if (U_or_V_or_W == 0) {
                pdf.strokeWeight(0.25);
                pdf.stroke(255, 0, 0);
                pdf.fill(255, 0, 0);
              }
              if (U_or_V_or_W == 1) {
                pdf.strokeWeight(0.25);
                pdf.stroke(0, 255, 0);
                pdf.fill(0, 255, 0);
              }
              if (U_or_V_or_W == 2) {
                pdf.strokeWeight(0.25);
                pdf.stroke(0, 0, 255);
                pdf.fill(0, 0, 255);
              }

              int q_num = 0;
              if (U_or_V_or_W == 0) {
                q_num = this.Contours_U1Lines.length;
              }
              if (U_or_V_or_W == 1) {
                q_num = this.Contours_V1Lines.length;
              }
              if (U_or_V_or_W == 2) {
                q_num = this.Contours_V2Lines.length;
              }

              for (int q = 1; q < q_num; q++) {

                float[] i = {
                  0, 0
                };
                float[] j = {
                  0, 0
                };

                for (int p = 0; p < 2; p++) {

                  int n = 0;
                  float x0 = 0, y0 = 0, z0 = 0;

                  if (U_or_V_or_W == 0) {
                    n = this.Contours_U1Lines[q][p];
                    x0 = this.Contours_U1Vertices[n][0];
                    y0 = this.Contours_U1Vertices[n][1];
                    z0 = this.Contours_U1Vertices[n][2];
                  }
                  if (U_or_V_or_W == 1) {
                    n = this.Contours_V1Lines[q][p];
                    x0 = this.Contours_V1Vertices[n][0];
                    y0 = this.Contours_V1Vertices[n][1];
                    z0 = this.Contours_V1Vertices[n][2];
                  }
                  if (U_or_V_or_W == 2) {
                    n = this.Contours_V2Lines[q][p];
                    x0 = this.Contours_V2Vertices[n][0];
                    y0 = this.Contours_V2Vertices[n][1];
                    z0 = this.Contours_V2Vertices[n][2];
                  }

                  float r = 0;

                  if (this.sectionType == 1) {
                    r = -this.R[this.sectionType];
                  } else if (this.sectionType == 2) {
                    r = this.R[this.sectionType];
                  } else if (this.sectionType == 3) {
                    r = -this.R[this.sectionType];
                  }

                  float x = x0 * funcs.cos_ang(r) - y0 * funcs.sin_ang(r);
                  float y = x0 * funcs.sin_ang(r) + y0 * funcs.cos_ang(r);
                  float z = z0;

                  float a = 0;
                  float b = 0;

                  if (this.sectionType == 1) {
                    a = x;
                    b = -y;
                  } else if (this.sectionType == 2) {
                    a = x;
                    b = -z;
                  } else if (this.sectionType == 3) {
                    a = -y;
                    b = -z;
                  }

                  i[p] = this.RES1 * ((a - this.X[this.sectionType]) / this.U[this.sectionType] + 0.5);
                  j[p] = this.RES2 * ((b + this.Y[this.sectionType]) / this.V[this.sectionType] + 0.5);
                }

                pdf.line(i[0], j[0], i[1], j[1]);
              }
            }
          }

          if (this.displayPoints) {
            pdf.strokeWeight(0.5);
            pdf.stroke(255, 127, 0);
            pdf.noFill();
            pdf.ellipseMode(CENTER);

            for (int n = 1; n < this.Contours_U1Vertices.length; n++) {

              float x0 = this.Contours_U1Vertices[n][0];
              float y0 = this.Contours_U1Vertices[n][1];
              float z0 = this.Contours_U1Vertices[n][2];

              float r = 0;

              if (this.sectionType == 1) {
                r = -this.R[this.sectionType];
              } else if (this.sectionType == 2) {
                r = this.R[this.sectionType];
              } else if (this.sectionType == 3) {
                r = -this.R[this.sectionType];
              }

              float x = x0 * funcs.cos_ang(r) - y0 * funcs.sin_ang(r);
              float y = x0 * funcs.sin_ang(r) + y0 * funcs.cos_ang(r);
              float z = z0;

              float a = 0;
              float b = 0;

              if (this.sectionType == 1) {
                a = x;
                b = -y;
              } else if (this.sectionType == 2) {
                a = x;
                b = -z;
              } else if (this.sectionType == 3) {
                a = -y;
                b = -z;
              }

              float i = this.RES1 * ((a - this.X[this.sectionType]) / this.U[this.sectionType] + 0.5);
              float j = this.RES2 * ((b + this.Y[this.sectionType]) / this.V[this.sectionType] + 0.5);

              pdf.ellipse(i, j, 1, 1);
            }

            pdf.strokeWeight(0);
          }
        }


        pdf.dispose();

        pdf.endDraw();

        println("File created:" + myFile);
      }

      cursor(ARROW);
    }
  }



  void draw_lines () {

    if (this.displayLines) {

      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(255, 0, 0);
      WIN3D.graphics.fill(255, 0, 0);

      for (int q = 1; q < this.Contours_U1Lines.length; q++) {

        int n1 = this.Contours_U1Lines[q][0];
        int n2 = this.Contours_U1Lines[q][1];

        float x1 = this.Contours_U1Vertices[n1][0];
        float y1 = this.Contours_U1Vertices[n1][1];
        float z1 = this.Contours_U1Vertices[n1][2];

        float x2 = this.Contours_U1Vertices[n2][0];
        float y2 = this.Contours_U1Vertices[n2][1];
        float z2 = this.Contours_U1Vertices[n2][2];

        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }

      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(0, 255, 0);
      WIN3D.graphics.fill(0, 255, 0);

      for (int q = 1; q < this.Contours_V1Lines.length; q++) {

        int n1 = this.Contours_V1Lines[q][0];
        int n2 = this.Contours_V1Lines[q][1];

        float x1 = this.Contours_V1Vertices[n1][0];
        float y1 = this.Contours_V1Vertices[n1][1];
        float z1 = this.Contours_V1Vertices[n1][2];

        float x2 = this.Contours_V1Vertices[n2][0];
        float y2 = this.Contours_V1Vertices[n2][1];
        float z2 = this.Contours_V1Vertices[n2][2];

        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }

      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(255, 0, 0);
      WIN3D.graphics.fill(255, 0, 0);

      for (int q = 1; q < this.Contours_V2Lines.length; q++) {

        int n1 = this.Contours_V2Lines[q][0];
        int n2 = this.Contours_V2Lines[q][1];

        float x1 = this.Contours_V2Vertices[n1][0];
        float y1 = this.Contours_V2Vertices[n1][1];
        float z1 = this.Contours_V2Vertices[n1][2];

        float x2 = this.Contours_V2Vertices[n2][0];
        float y2 = this.Contours_V2Vertices[n2][1];
        float z2 = this.Contours_V2Vertices[n2][2];

        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }

      WIN3D.graphics.strokeWeight(0);
    }
  }

  void draw_points () {
    if (this.displayPoints) {

      WIN3D.graphics.strokeWeight(0);
      WIN3D.graphics.stroke(255, 127, 0);
      WIN3D.graphics.fill(255, 127, 0);

      float R = 1; //0.2;

      for (int n = 1; n < this.Contours_U1Vertices.length; n++) {

        float x = this.Contours_U1Vertices[n][0];
        float y = this.Contours_U1Vertices[n][1];
        float z = this.Contours_U1Vertices[n][2];

        WIN3D.graphics.pushMatrix();
        WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.sphere(R);
        WIN3D.graphics.popMatrix();
      }
    }
  }

  float MinimumDistance_traceU = 1.0;
  float MinimumDistance_traceV = 0.25;

  void trace_U1Line (float[] test_point_dir, float g_line, int n_Tries) {

    int point_prev = 0;
    int point_next = 0;

    for (int n = 0; n < n_Tries; n++) {

      float[][] preVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };

      if (point_prev == 0) {
        float nearestPointDist = FLOAT_undefined;
        int nearestPointNum = 0;

        for (int q = 1; q < this.Contours_U1Vertices.length; q++) {
          //if (preVertex[0][3] == this.Contours_U1Vertices[q][3]) {
          if (preVertex[0][3] - this.Contours_U1Vertices[q][3] < 0.0001) {

            float d = dist(preVertex[0][0], preVertex[0][1], preVertex[0][2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);

            if (nearestPointDist > d) {
              nearestPointDist = d;
              nearestPointNum = q;
            }
          }
        }

        if (nearestPointDist < 0.5) {  //i.e. 0.5m
          point_prev = nearestPointNum;

          test_point_dir[0] = this.Contours_U1Vertices[point_prev][0];
          test_point_dir[1] = this.Contours_U1Vertices[point_prev][1];
          test_point_dir[2] = this.Contours_U1Vertices[point_prev][2];
        }
      }

      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      test_point_dir = this.traceContour2D(0, MinimumDistance_traceU, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / this.Grade);
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

      float[][] newVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };
      point_next = 0;

      float nearestPointDist = FLOAT_undefined;
      int nearestPointNum = 0;

      int next_point_existed = 0;

      for (int q = 1; q < this.Contours_U1Vertices.length; q++) {
        //if (newVertex[0][3] == this.Contours_U1Vertices[q][3]) {
        if (abs(newVertex[0][3] - this.Contours_U1Vertices[q][3]) < 0.0001) {

          float d = dist(newVertex[0][0], newVertex[0][1], newVertex[0][2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);

          if ((nearestPointDist > d) && (point_prev != q)) {
            nearestPointDist = d;
            nearestPointNum = q;
          }
        }
      }

      if (nearestPointDist < MinimumDistance_traceU) {
        point_next = nearestPointNum;

        test_point_dir[0] = this.Contours_U1Vertices[point_next][0];
        test_point_dir[1] = this.Contours_U1Vertices[point_next][1];
        test_point_dir[2] = this.Contours_U1Vertices[point_next][2];

        next_point_existed = 1;
      }


      if (point_next == 0) {

        this.Contours_U1Vertices = (float[][]) concat(this.Contours_U1Vertices, newVertex);
        point_next = this.Contours_U1Vertices.length - 1;
      }

      if ((point_prev != 0) && (point_next != 0)) {
        int[][] newU1Line = {
          {
            point_prev, point_next
          }
        };
        this.Contours_U1Lines = (int[][]) concat(this.Contours_U1Lines, newU1Line);

        point_prev = point_next;
      }

      if (next_point_existed == 1) {
        break; // when reaching an existing line
      }
    }
  }

  void trace_V1Line (float[] test_point_dir, float g_line, int n_Tries) {

    int point_prev = this.Contours_V1Vertices.length - 1; // the last added point
    int point_next = 0;

    for (int n = 0; n < n_Tries; n++) {

      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      test_point_dir = this.traceContour2D(-1, MinimumDistance_traceV, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / this.Grade);
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

      float[][] newVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };

      point_next = 0;

      {
        this.Contours_V1Vertices = (float[][]) concat(this.Contours_V1Vertices, newVertex);
        point_next = this.Contours_V1Vertices.length - 1;
      }

      if ((point_prev != 0) && (point_next != 0)) {
        int[][] newV1Line = {
          {
            point_prev, point_next
          }
        };
        this.Contours_V1Lines = (int[][]) concat(this.Contours_V1Lines, newV1Line);

        float val_new = this.get_Impact_atXYZ(test_point_dir[0], test_point_dir[1], test_point_dir[2]);
        float g_new =      funcs.roundTo(this.Grade * val_new, this.deltaStep) - 0.5 * this.deltaStep;
        float g_line_new = funcs.roundTo(this.Grade * val_new, this.deltaLines);

        if (g_line - g_line_new >= this.deltaStep) {


          float nearestPointDist = FLOAT_undefined;
          int nearestPointNum = 0;

          for (int q = 1; q < this.Contours_U1Vertices.length; q++) {

            //if (abs(g_line_new / this.Grade - this.Contours_U1Vertices[q][3]) < 0.0001) {
            if (g_line - g_line_new < 2 * this.deltaStep) {

              float d = dist(test_point_dir[0], test_point_dir[1], test_point_dir[2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);

              if (nearestPointDist > d) {
                nearestPointDist = d;
                nearestPointNum = q;
              }
            }
          }

          if (nearestPointDist < MinimumDistance_traceU) {

            int q = nearestPointNum;

            float[][] endVertex = {
              {
                this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2], this.Contours_U1Vertices[q][3]
              }
            };
            this.Contours_V2Vertices = (float[][]) concat(this.Contours_V2Vertices, endVertex);

            int[][] newV2Line = {
              {
                this.Contours_V2Vertices.length - 2, this.Contours_V2Vertices.length - 1
              }
            }; // last two WVertices
            this.Contours_V2Lines = (int[][]) concat(this.Contours_V2Lines, newV2Line);
          }


          break; // when reaching the area outside contour level
        }

        point_prev = point_next;
      }
    }
  }

  float[][] Wind_Vertices = new float [0][4]; // keeping values at the 4th member
  int[][] Wind_Lines = new int [0][2];

  void calculate_WindFlow () {

    cursor(WAIT);

    this.Wind_Vertices = new float [0][4];

    this.Wind_Lines = new int [0][2];




    float deltaX = -this.WindSpeed * funcs.cos_ang(this.WindDirection);
    float deltaY = -this.WindSpeed * funcs.sin_ang(this.WindDirection);
    float deltaZ = 0;

    /*

     float Section_X = this.X[this.sectionType];
     float Section_Y = this.Y[this.sectionType];
     float Section_Z = this.Z[this.sectionType];
     float Section_R = this.R[this.sectionType];
     float Section_U = this.U[this.sectionType];
     float Section_V = this.V[this.sectionType];

     int Section_complex = this.sectionType;
     int Section_RES1 = this.RES1;
     int Section_RES2 = this.RES2;

     float[][] ImageVertex = allSections.getCorners(Section_complex, Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_RES1, Section_RES2);

     float[] SectionCorner_A = ImageVertex[1];
     float[] SectionCorner_B = ImageVertex[2];
     float[] SectionCorner_C = ImageVertex[3];
     float[] SectionCorner_D = ImageVertex[4];

     for (int i = 0; i < this.RES1; i += 10) {
     for (int j = 0; j < this.RES2; j += 10) {

     float x = funcs.bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(this.RES1), 1 - j / float(this.RES2));
     float y = funcs.bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(this.RES1), 1 - j / float(this.RES2));
     float z = funcs.bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(this.RES1), 1 - j / float(this.RES2));

     */


    for (float z = 2.5; z <= 30; z += 5.0) {
      for (float y = -80; y <= 80; y += 5.0) {
        for (float x = -80; x <= 80; x += 5.0) {



          float[] test_point = {
            x, y, z
          };


          int num_steps = 1; //1; //4;

          for (int n = 0; n < num_steps; n++) {

            this.complex = 0;
            float inside_or_outside = this.get_Impact_atXYZ(test_point[0], test_point[1], test_point[2]);

            if (inside_or_outside > 0) {

              this.complex = 1;
              float val = this.get_Impact_atXYZ(test_point[0], test_point[1], test_point[2]);


              float MinimumDistance_trace = 1 / float(num_steps);

              //-----------------------------------------------------------------------------------------------------------------------------------------
              float[][] tracedPoints = this.traceContour3D(MinimumDistance_trace, test_point[0], test_point[1], test_point[2], val);
              //-----------------------------------------------------------------------------------------------------------------------------------------

              float[] point_min = tracedPoints[0];
              //float[] point_equ = tracedPoints[1];
              //float[] point_max = tracedPoints[2];

              float[] v1 = {
                deltaX, deltaY, deltaZ
              };

              float[] v2 = {
                point_min[0] - x, point_min[1] - y, point_min[2] - z
              };

              float acceleration = -this.WindSpeed * (point_min[3] - val);

              float dx = v1[0] + v2[0] * acceleration;
              float dy = v1[1] + v2[1] * acceleration;
              float dz = v1[2] + v2[2] * acceleration;

              //float scale = 1.0 / float(num_steps);
              float scale = 0.1 / float(num_steps); // <<<<<<<<<<<<<<<<<<<<

              float x1 = test_point[0] - 0.5 * dx * scale;
              float y1 = test_point[1] - 0.5 * dy * scale;
              float z1 = test_point[2] - 0.5 * dz * scale;

              float x2 = test_point[0] + 0.5 * dx * scale;
              float y2 = test_point[1] + 0.5 * dy * scale;
              float z2 = test_point[2] + 0.5 * dz * scale;


              float AB = (dist(x1, y1, z1, x2, y2, z2) / scale - this.WindSpeed) / this.WindSpeed;

              int point_prev = 0;
              int point_next = 0;

              {
                float[][] newVertex = {
                  {
                    x1, y1, z1, AB
                  }
                };
                this.Wind_Vertices = (float[][]) concat(this.Wind_Vertices, newVertex);

                point_prev = this.Wind_Vertices.length - 1;
              }


              {
                float[][] newVertex = {
                  {
                    x2, y2, z2, AB
                  }
                };
                this.Wind_Vertices = (float[][]) concat(this.Wind_Vertices, newVertex);

                point_next = this.Wind_Vertices.length - 1;
              }

              if ((point_prev != 0) && (point_next != 0)) {
                int[][] newU1Line = {
                  {
                    point_prev, point_next
                  }
                };
                this.Wind_Lines = (int[][]) concat(this.Wind_Lines, newU1Line);

                point_prev = point_next;
              }


              test_point[0] = x2;
              test_point[1] = y2;
              test_point[2] = z2;
            }
          }
        }
      }
    }

    cursor(ARROW);

    allWindFlows.displayAll = true;
    ROLLOUT.revise();
  }




  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setFloat(parent, this.CLASS_STAMP + ".WindSpeed", this.WindSpeed);
    XML_setFloat(parent, this.CLASS_STAMP + ".WindDirection", this.WindDirection);
    XML_setFloat(parent, this.CLASS_STAMP + ".Power", this.Power);
    XML_setBoolean(parent, this.CLASS_STAMP + ".displayPoints", this.displayPoints);
    XML_setBoolean(parent, this.CLASS_STAMP + ".displayLines", this.displayLines);

    XML_setInt(parent, this.CLASS_STAMP + ".RES1", this.RES1);
    XML_setInt(parent, this.CLASS_STAMP + ".RES2", this.RES2);
    XML_setFloat(parent, this.CLASS_STAMP + ".Grade", this.Grade);
    XML_setBoolean(parent, this.CLASS_STAMP + ".displayImage", this.displayImage);
    XML_setInt(parent, this.CLASS_STAMP + ".sectionType", this.sectionType);
    XML_setFloat(parent, this.CLASS_STAMP + ".positionStep", this.positionStep);
    XML_setInt(parent, this.CLASS_STAMP + ".Process_subDivisions", this.Process_subDivisions);
    XML_setFloat(parent, this.CLASS_STAMP + ".deltaStep", this.deltaStep);
    XML_setFloat(parent, this.CLASS_STAMP + ".deltaLines", this.deltaLines);
    XML_setFloat(parent, this.CLASS_STAMP + ".MinimumDistance_traceU", this.MinimumDistance_traceU);
    XML_setFloat(parent, this.CLASS_STAMP + ".MinimumDistance_traceV", this.MinimumDistance_traceV);

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Z");
      int ni = this.Z.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Z[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".R");
      int ni = this.R.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.R[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".U");
      int ni = this.U.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.U[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".V");
      int ni = this.V.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.V[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".X");
      int ni = this.X.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.X[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Y");
      int ni = this.Y.length;
      XML_setInt(child, "ni", ni);
      String txt = "";
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Y[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) txt += ",";
      }
      XML_setContent(child, txt);
    }

  }



  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.WindSpeed = XML_getFloat(parent, this.CLASS_STAMP + ".WindSpeed");
    this.WindDirection = XML_getFloat(parent, this.CLASS_STAMP + ".WindDirection");
    this.Power = XML_getFloat(parent, this.CLASS_STAMP + ".Power");

    this.displayPoints = XML_getBoolean(parent, this.CLASS_STAMP + ".displayPoints");
    this.displayLines = XML_getBoolean(parent, this.CLASS_STAMP + ".displayLines");

    this.RES1 = XML_getInt(parent, this.CLASS_STAMP + ".RES1");
    this.RES2 = XML_getInt(parent, this.CLASS_STAMP + ".RES2");
    this.Grade = XML_getFloat(parent, this.CLASS_STAMP + ".Grade");
    this.displayImage = XML_getBoolean(parent, this.CLASS_STAMP + ".displayImage");
    this.sectionType = XML_getInt(parent, this.CLASS_STAMP + ".sectionType");
    this.positionStep = XML_getFloat(parent, this.CLASS_STAMP + ".positionStep");
    this.Process_subDivisions = XML_getInt(parent, this.CLASS_STAMP + ".Process_subDivisions");
    this.deltaStep = XML_getFloat(parent, this.CLASS_STAMP + ".deltaStep");
    this.deltaLines = XML_getFloat(parent, this.CLASS_STAMP + ".deltaLines");
    this.MinimumDistance_traceU = XML_getFloat(parent, this.CLASS_STAMP + ".MinimumDistance_traceU");
    this.MinimumDistance_traceV = XML_getFloat(parent, this.CLASS_STAMP + ".MinimumDistance_traceV");

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Z");

      int ni = XML_getInt(child, "ni");
      this.Z = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.Z[i] = float(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".R");

      int ni = XML_getInt(child, "ni");
      this.R = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.R[i] = float(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".U");

      int ni = XML_getInt(child, "ni");
      this.U = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.U[i] = float(parts[i]);
      }
    }

    {
        XML child = xml.getChild(this.CLASS_STAMP + ".V");

      int ni = XML_getInt(child, "ni");
      this.V = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.V[i] = float(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".X");

      int ni = XML_getInt(child, "ni");
      this.X = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.X[i] = float(parts[i]);
      }
    }


    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Y");

      int ni = XML_getInt(child, "ni");
      this.Y = new float [ni];
      String txt = XML_getContent(child);
      String[] parts = split(txt, ",");
      for (int i = 0; i < ni; i++) {
        this.Y[i] = float(parts[i]);
      }
    }
  }
}

solarchvision_SolidImpacts allSolidImpacts = new solarchvision_SolidImpacts();





class solarchvision_SolarImpacts {

  private final static String CLASS_STAMP = "SolarImpacts";

  boolean rebuild_Image_array = true;

  PImage[][] Image;

  boolean displayImage = false;

  int sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

  float Y = 0;
  float X = 0;
  float Z = 0;
  float R = 0; // North is up by default
  float U = 500; // i.e. 500 = 500m
  float V = 500; // i.e. 500 = 500m

  int RES1 = 100; //200;
  int RES2 = 100; //200;



  int record_IMG = 0;

  void resize_Image_array () {

    this.Image = new PImage [2][(1 + STUDY.j_End - STUDY.j_Start)];

    for (int i = 0; i < this.Image.length; i++) {
      for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) { // total image at j = -1

        this.Image[i][j + 1] = createImage(2, 2, RGB); // empty and small
      }
    }

    allSolarImpacts.rebuild_Image_array = false;
  }


  void calculate_Impact_CurrentPreBaked () {

    if (allSolarImpacts.rebuild_Image_array) {
      this.resize_Image_array();
    }

    if (this.sectionType != 0) {

      cursor(WAIT);

      int[] startK_endK = get_startK_endK();
      int start_k = startK_endK[0];
      int end_k = startK_endK[1];
      int count_k = 1 + end_k - start_k;
      if (count_k < 0) count_k = 0;


      int RES1 = this.RES1;
      int RES2 = this.RES2;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float values_R_dir;
      float values_R_dif;

      float values_E_dir;
      float values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      for (int p = 0; p < 1; p++) {
        int l = STUDY.ImpactLayer;

        PImage[] total_Image_RGBA = new PImage[2];
        for (int q = 0; q < numberOfImpactVariations; q++) {
          total_Image_RGBA[q] = createImage(RES1, RES2, RGB);
        }

        float[][][][] total_Matrix_ARGB;
        total_Matrix_ARGB = new float [2][4][RES1][RES2];

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          for (int q = 0; q < numberOfImpactVariations; q++) {
            total_Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
          }
        }

        for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

          now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

          int DATE_ANGLE_approximate = int((DATE_ANGLE + 15) / 30) * 30;
          if (DATE_ANGLE_approximate == 360) DATE_ANGLE_approximate = 0;

          //println(DATE_ANGLE, DATE_ANGLE_approximate);

          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

          //println("j =", j);
          //println(Normals_COL_N);

          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays;

              float[][][][] Matrix_ARGB;

              Matrix_ARGB = new float [2][4][RES1][RES2];

              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;

                for (int q = 0; q < numberOfImpactVariations; q++) {
                  Matrix_ARGB[q][0][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][1][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][2][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][3][Image_X][Image_Y] = FLOAT_undefined;
                }
              }

              PImage[] Image_RGBA = new PImage[2];
              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q] = createImage(RES1, RES2, RGB);
              }

              int valuesNUM = 0;

              for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not available out of this period.
                if (STUDY.isInHourlyRange(i)) {

                  float HOUR_ANGLE = i;
                  float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                  if (SunR[3] > 0) {

                    now_k = k + start_k;
                    now_i = i;
                    now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                    if (now_j >= 365) {
                      now_j = now_j % 365;
                    }
                    if (now_j < 0) {
                      now_j = (now_j + 365) % 365;
                    }

                    Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                    Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                    Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                    Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                    if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
                      values_R_dir = FLOAT_undefined;
                      values_R_dif = FLOAT_undefined;
                      values_E_dir = FLOAT_undefined;
                      values_E_dif = FLOAT_undefined;
                    } else {

                      int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);

                      if (memberCount == 1) {
                        values_R_dir = 0.001 * Pa;
                        values_R_dif = 0.001 * Pb;
                        values_E_dir = 0.001 * Pc;
                        values_E_dif = 0.001 * Pd;

                        for (int RAD_TYPE = 0; RAD_TYPE <= 1; RAD_TYPE++) {
                          float RAD_VALUE = 0;
                          float EFF_VALUE = 0;
                          if (RAD_TYPE == 0) {
                            RAD_VALUE = values_R_dir;
                            EFF_VALUE = values_E_dir;
                          } else {
                            //float MULT_dif = 2.0;
                            float MULT_dif = FLOAT_e; // 2.718

                            RAD_VALUE = values_R_dif * MULT_dif;
                            EFF_VALUE = values_E_dif * MULT_dif;
                          }

                          PImage[] Shadings = new PImage [2];
                          for (int SHD = 0; SHD <= 1; SHD++) {
                            String[] STR_SHD = {
                              "F", "T"
                            };
                            String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

                            if (RAD_TYPE == 0) {
                              File_Name += nf(DATE_ANGLE_approximate, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);
                            } else {
                              File_Name += "DIF_" + STR_SHD[SHD];
                            }

                            File_Name += "_Camera" + nf(Camera_Variation, 2) + ".png";


                            println(File_Name);
                            Shadings[SHD]  = loadImage(File_Name);
                          }

                          for (int np = 0; np < (RES1 * RES2); np++) {
                            int Image_X = np % RES1;
                            int Image_Y = np / RES1;

                            for (int q = 0; q < numberOfImpactVariations; q++) {
                              if (is_undefined(Matrix_ARGB[q][0][Image_X][Image_Y])) {

                                Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
                              }
                            }

                            color COL0 = Shadings[0].get(Image_X, Image_Y);
                            color COL1 = Shadings[1].get(Image_X, Image_Y);
                            //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                            float COL_V0 = (COL0 >> 8 & 0xFF) / 255.0;
                            float COL_V1 = (COL1 >> 8 & 0xFF) / 255.0;

                            float COL_Alpha = (COL1 >> 24 & 0xFF);

                            Matrix_ARGB[Impact_ACTIVE][0][Image_X][Image_Y] = COL_Alpha;
                            Matrix_ARGB[Impact_PASSIVE][0][Image_X][Image_Y] = COL_Alpha;

                            Matrix_ARGB[Impact_ACTIVE][2][Image_X][Image_Y] += RAD_VALUE * COL_V1;

                            if (EFF_VALUE < 0) {
                              Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] -= EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] -= EFF_VALUE * (COL_V0 - COL_V1);
                            } else {
                              Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] += EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] += EFF_VALUE * (COL_V0 - COL_V1);
                            }

                            if (np == 0) valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }
              }

              float valuesMUL = 0;

              if (valuesNUM != 0) {
                //valuesMUL = funcs.DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);
                //valuesMUL = int(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                valuesMUL = funcs.roundTo(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);
              }


              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q].loadPixels();
              }

              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;

                for (int q = 0; q < numberOfImpactVariations; q++) {

                  float Image_A = Matrix_ARGB[q][0][Image_X][Image_Y] * valuesMUL;
                  float Image_R = Matrix_ARGB[q][1][Image_X][Image_Y] * valuesMUL;
                  float Image_G = Matrix_ARGB[q][2][Image_X][Image_Y] * valuesMUL;
                  float Image_B = Matrix_ARGB[q][3][Image_X][Image_Y] * valuesMUL;

                  total_Matrix_ARGB[q][0][Image_X][Image_Y] += Image_A;
                  total_Matrix_ARGB[q][1][Image_X][Image_Y] += Image_R;
                  total_Matrix_ARGB[q][2][Image_X][Image_Y] += Image_G;
                  total_Matrix_ARGB[q][3][Image_X][Image_Y] += Image_B;

                  float[] _c = {
                    0, 0, 0, 0
                  };

                  float _u = 0;

                  float valuesSUM = FLOAT_undefined;

                  int PAL_type = 0;
                  int PAL_direction = 1;
                  float PAL_multiplier = 1;

                  if (q == Impact_ACTIVE) {
                    valuesSUM = Image_G;

                    PAL_type = allFaces.ACTIVE_pallet_CLR;
                    PAL_direction = allFaces.ACTIVE_pallet_DIR;
                    PAL_multiplier = allFaces.ACTIVE_pallet_MLT;

                    //_u = 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                    //_u = (0.1 * PAL_multiplier * valuesSUM);
                    _u = (0.2 * PAL_multiplier * valuesSUM);
                  }

                  if (q == Impact_PASSIVE) {
                    float AVERAGE, PERCENTAGE, COMPARISON;

                    AVERAGE = (Image_B - Image_R);
                    if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R));
                    else PERCENTAGE = 0.0;
                    COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

                    valuesSUM = COMPARISON;

                    PAL_type = allFaces.PASSIVE_pallet_CLR;
                    PAL_direction = allFaces.PASSIVE_pallet_DIR;
                    PAL_multiplier = allFaces.PASSIVE_pallet_MLT;

                    //_u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                    _u = 0.5 + 0.5 * (0.2 * PAL_multiplier * valuesSUM);
                  }


                  //if ((Image_X == RES1 / 2) && (Image_Y == RES2 / 2)) println("Image Processing: <CENTER> valuesSUM =", valuesSUM);
                  //if ((Image_X == RES1 - 1) && (Image_Y == RES2 - 1)) println("Image Processing: <CORNER> valuesSUM =", valuesSUM);

                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;

                  _c = PAINT.getColorStyle(PAL_type, _u);

                  if (Image_A != 0) Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
                  else Image_RGBA[q].pixels[np] = color(223, 223, 223);
                }
              }

              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q].updatePixels();


                //if (Camera_Variation == 0) {
                this.Image[q][j + 1] = Image_RGBA[q];
                if (this.record_IMG == 1) {
                  String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(j + 1, 0) + ".jpg";
                  this.Image[q][j + 1].save(myFile);
                  println("File created:" + myFile);
                }
                //}
              }
            }
          }
        }

        {
          int j = -1; // << to put the summary graph before the daily graphs

          for (int q = 0; q < numberOfImpactVariations; q++) {
            total_Image_RGBA[q].loadPixels();
          }

          for (int np = 0; np < (RES1 * RES2); np++) {
            int Image_X = np % RES1;
            int Image_Y = np / RES1;

            for (int q = 0; q < numberOfImpactVariations; q++) {

              float Image_A = total_Matrix_ARGB[q][0][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_R = total_Matrix_ARGB[q][1][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_G = total_Matrix_ARGB[q][2][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_B = total_Matrix_ARGB[q][3][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));

              float[] _c = {
                0, 0, 0, 0
              };

              float _u = 0;

              float valuesSUM = FLOAT_undefined;

              int PAL_type = 0;
              int PAL_direction = 1;
              float PAL_multiplier = 1;

              if (q == Impact_ACTIVE) {
                valuesSUM = Image_G;

                PAL_type = allFaces.ACTIVE_pallet_CLR;
                PAL_direction = allFaces.ACTIVE_pallet_DIR;
                PAL_multiplier = allFaces.ACTIVE_pallet_MLT;

                //_u = 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                //_u = (0.1 * PAL_multiplier * valuesSUM);
                _u = (0.2 * PAL_multiplier * valuesSUM);
              }

              if (q == Impact_PASSIVE) {
                float AVERAGE, PERCENTAGE, COMPARISON;

                AVERAGE = (Image_B - Image_R);
                if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R));
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

                valuesSUM = COMPARISON;

                PAL_type = allFaces.PASSIVE_pallet_CLR;
                PAL_direction = allFaces.PASSIVE_pallet_DIR;
                PAL_multiplier = allFaces.PASSIVE_pallet_MLT;

                //_u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                _u = 0.5 + 0.5 * (0.2 * PAL_multiplier * valuesSUM);
              }

              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              _c = PAINT.getColorStyle(PAL_type, _u);

              if (Image_A != 0) total_Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
              else total_Image_RGBA[q].pixels[np] = color(223, 223, 223);
            }
          }

          for (int q = 0; q < numberOfImpactVariations; q++) {

            total_Image_RGBA[q].updatePixels();

            //if (Camera_Variation == 0) {
            this.Image[q][0] = total_Image_RGBA[q];
            if (this.record_IMG == 1) {
              String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(0, 0) + ".jpg";
              this.Image[q][0].save(myFile);
              println("File created:" + myFile);
            }
            //}
          }
        }
      }

      cursor(ARROW);
    }
  }



  void render_Shadows_selectedSections () {

    for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Section_ids[o];

      this.sectionType = allSections.get_type(f);
      this.RES1 = allSections.get_res1(f);
      this.RES2 = allSections.get_res2(f);

      this.X = allSections.getX(f);
      this.Y = allSections.getY(f);
      this.Z = allSections.getZ(f) + 0.1; // <<
      this.R = allSections.getR(f);
      this.U = allSections.getU(f);
      this.V = allSections.getV(f);

      SceneName = "Section_" + Section_Stamp();

      SOLARCHVISION_castShadows_CurrentSection();
    }

    this.displayImage = true;
    allSolidImpacts.displayImage = false;
    ROLLOUT.revise();
  }




  void calculate_Impact_selectedSections () {

    for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Section_ids[o];

      this.sectionType = allSections.get_type(f);
      this.RES1        = allSections.get_res1(f);
      this.RES2        = allSections.get_res2(f);

      this.X = allSections.getX(f);
      this.Y = allSections.getY(f);
      this.Z = allSections.getZ(f) + 0.1; // <<
      this.R = allSections.getR(f);
      this.U = allSections.getU(f);
      this.V = allSections.getV(f);

      SceneName = "Section_" + Section_Stamp();

      this.calculate_Impact_CurrentPreBaked();


      for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) {
        for (int q = 0; q < numberOfImpactVariations; q++) {
          allSections.SolarImpact[f][j + 1][q] = createImage(this.RES1, this.RES2, RGB);

          allSections.SolarImpact[f][j + 1][q].copy(this.Image[q][j + 1], 0, 0, this.RES1, this.RES2, 0, 0, this.RES1, this.RES2);
        }
      }
    }
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displayImage", this.displayImage);

    XML_setFloat(parent, "X", this.X);
    XML_setFloat(parent, "Y", this.Y);
    XML_setFloat(parent, "Z", this.Z);
    XML_setFloat(parent, "R", this.R);
    XML_setFloat(parent, "U", this.U);
    XML_setFloat(parent, "V", this.V);

    XML_setInt(parent, "RES1", this.RES1);
    XML_setInt(parent, "RES2", this.RES2);

    XML_setInt(parent, "sectionType", this.sectionType);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displayImage = XML_getBoolean(parent, "displayImage");

    this.X = XML_getFloat(parent, "X");
    this.Y = XML_getFloat(parent, "Y");
    this.Z = XML_getFloat(parent, "Z");
    this.R = XML_getFloat(parent, "R");
    this.U = XML_getFloat(parent, "U");
    this.V = XML_getFloat(parent, "V");

    this.RES1 = XML_getInt(parent, "RES1");
    this.RES2 = XML_getInt(parent, "RES2");
    this.sectionType = XML_getInt(parent, "sectionType");
  }


}

solarchvision_SolarImpacts allSolarImpacts = new solarchvision_SolarImpacts();






class solarchvision_Edit3D {

  private final static String CLASS_STAMP = "Edit3D";

  void selection (int p) {

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curves(p);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Faces(p);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds(p);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds(p);
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Cameras(p);
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solids(p);
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Sections(p);
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Groups(p);
    }

  }




  void Faces (int p) {

    for (int o = Select3D.Face_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Face_ids[o];

      int f = OBJ_ID;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allFaces.getMaterial(f);
        n += p;
        if (n > 8) n = 0;
        if (n < 0) n = 8;
        allFaces.setMaterial(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allFaces.getTessellation(f);
        n += p;
        if (n > 4) n = 0;
        if (n < 0) n = 4;
        allFaces.setTessellation(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Layer) {
        int n = allFaces.getLayer(f);
        n += p;
        if (n > 16) n = 0;
        if (n < 0) n = 16;
        allFaces.setLayer(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
        int n = allFaces.getVisibility(f);
        n += p;
        if (n > 2) n = 0;
        if (n < 0) n = 2;
        allFaces.setVisibility(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Weight) {
        int n = allFaces.getWeight(f);
        n += p;
        if (n > 20) n = -20;
        if (n < -20) n = 20;
        allFaces.setWeight(f, n);
      }
    }
  }

  void Curves (int p) {

    for (int o = Select3D.Curve_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Curve_ids[o];

      int f = OBJ_ID;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allCurves.getMaterial(f);
        n += p;
        if (n > 8) n = 0;
        if (n < 0) n = 8;
        allCurves.setMaterial(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allCurves.getTessellation(f);
        n += p;
        if (n > 4) n = 0;
        if (n < 0) n = 4;
        allCurves.setTessellation(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Layer) {
        int n = allCurves.getLayer(f);
        n += p;
        if (n > 16) n = 0;
        if (n < 0) n = 16;
        allCurves.setLayer(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
        int n = allCurves.getVisibility(f);
        n += p;
        if (n > 2) n = 0;
        if (n < 0) n = 2;
        allCurves.setVisibility(f, n);
      }

      if (WIN3D.UI_CurrentTask == UITASK.Weight) {
        int n = allCurves.getWeight(f);
        n += p;
        if (n > 20) n = -20;
        if (n < -20) n = 20;
        allCurves.setWeight(f, n);
      }
    }
  }




  void Groups (int p) {

    for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Group_ids[o];

      for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {
        if ((0 <= f) && (f < allFaces.nodes.length)) {

          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
            int n = allFaces.getMaterial(f);
            n += p;
            if (n > 8) n = 0;
            if (n < 0) n = 8;
            allFaces.setMaterial(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
            int n = allFaces.getTessellation(f);
            n += p;
            if (n > 4) n = 0;
            if (n < 0) n = 4;
            allFaces.setTessellation(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Layer) {
            int n = allFaces.getLayer(f);
            n += p;
            if (n > 16) n = 0;
            if (n < 0) n = 16;
            allFaces.setLayer(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
            int n = allFaces.getVisibility(f);
            n += p;
            if (n > 2) n = 0;
            if (n < 0) n = 2;
            allFaces.setVisibility(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Weight) {
            int n = allFaces.getWeight(f);
            n += p;
            if (n > 20) n = -20;
            if (n < -20) n = 20;
            allFaces.setWeight(f, n);
          }
        }
      }

      for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {
        if ((0 <= f) && (f < allCurves.nodes.length)) {

          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
            int n = allCurves.getMaterial(f);
            n += p;
            if (n > 8) n = 0;
            if (n < 0) n = 8;
            allCurves.setMaterial(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
            int n = allCurves.getTessellation(f);
            n += p;
            if (n > 4) n = 0;
            if (n < 0) n = 4;
            allCurves.setTessellation(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Layer) {
            int n = allCurves.getLayer(f);
            n += p;
            if (n > 16) n = 0;
            if (n < 0) n = 16;
            allCurves.setLayer(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
            int n = allCurves.getVisibility(f);
            n += p;
            if (n > 2) n = 0;
            if (n < 0) n = 2;
            allCurves.setVisibility(f, n);
          }

          if (WIN3D.UI_CurrentTask == UITASK.Weight) {
            int n = allCurves.getWeight(f);
            n += p;
            if (n > 20) n = -20;
            if (n < -20) n = 20;
            allCurves.setWeight(f, n);
          }
        }
      }
    }
  }




  void Model1Ds (int p) {

    for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model1D_ids[o];

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {

        allModel1Ds.setSeed(OBJ_ID, allModel1Ds.getSeed(OBJ_ID) + p);
      }
      if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) {
        int q = allModel1Ds.getDegreeMax(OBJ_ID);

        q += p;

        if (q < 0) q = 0;
        if (q > 12) q = 12;

        allModel1Ds.setDegreeMax(OBJ_ID, q);

        User3D.create_Model1D_DegreeMax = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.BranchTilt) {
        float q = allModel1Ds.getBranchTilt(OBJ_ID);

        q += p * 5;

        allModel1Ds.setBranchTilt(OBJ_ID, q);

        User3D.create_Model1D_BranchTilt = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.BranchTwist) {
        float q = allModel1Ds.getBranchTwist(OBJ_ID);

        q += p * 5;

        allModel1Ds.setBranchTwist(OBJ_ID, q);

        User3D.create_Model1D_BranchTwist = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.BranchRatio) {
        float q = allModel1Ds.getBranchRatio(OBJ_ID);

        q += 0.02 * p;

        if (q < 0.1) q = 0.1;
        if (q > 1.0) q = 1.0;

        allModel1Ds.setBranchRatio(OBJ_ID, q);

        User3D.create_Model1D_BranchRatio = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.TreeBase) {
        float q = allModel1Ds.getTreeBase(OBJ_ID);

        q += 0.02 * p;

        if (q < 0.0) q = 0.0;
        if (q > 4.0) q = 4.0;

        allModel1Ds.setTreeBase(OBJ_ID, q);

        User3D.create_Model1D_TreeBase = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) {
        float q = allModel1Ds.getTrunkSize(OBJ_ID);

        q += 0.02 * p;

        if (q < 0) q = 0;

        allModel1Ds.setTrunkSize(OBJ_ID, q);

        User3D.create_Model1D_TrunkSize = q;
        ROLLOUT.revise();
      }
      if (WIN3D.UI_CurrentTask == UITASK.LeafSize) {
        float q = allModel1Ds.getLeafSize(OBJ_ID);

        q += 0.02 * p;

        if (q < 0) q = 0;

        allModel1Ds.setLeafSize(OBJ_ID, q);

        User3D.create_Model1D_LeafSize = q;
        ROLLOUT.revise();
      }
    }
  }



  void Model2Ds (int p) {
    for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model2D_ids[o];

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {

        int n = allModel2Ds.MAP[OBJ_ID];
        int sign_n = 1;
        if (n < 0) sign_n = -1;

        n = abs(n);

        int n1 = allModel2Ds.num_files_PEOPLE;
        int n2 = allModel2Ds.num_files_PEOPLE + allModel2Ds.num_files_TREES;

        if (allModel2Ds.isTree(n)) { // case: trees

          n += p;

          if (n > n2) {
            n = n1 + 1;
            sign_n *= -1;
          }
          if (n < n1 + 1) {
            n = n2;
            sign_n *= -1;
          }
        }
        else { // case: people

          n += p;

          if (n > n1) {
            n = 1;
            sign_n *= -1;
          }
          if (n < 1) {
            n = n1;
            sign_n *= -1;
          }
        }

        n *= sign_n;

        allModel2Ds.MAP[OBJ_ID] = n;
      }
    }
  }


  void Cameras (int p) {

    for (int o = Select3D.Camera_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Camera_ids[o];

      int f = OBJ_ID;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allCameras.get_type(f);
        n += p;
        if (n > 1) n = 0;
        if (n < 0) n = 1;
        allCameras.set_type(f, n);

        if (f == WIN3D.currentCamera) WIN3D.ViewType = allCameras.get_type(f);
      }
    }
  }

  void Sections (int p) {

    boolean allSolids_updated = false;

    for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Section_ids[o];

      int f = OBJ_ID;

      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
        int n = allSections.get_type(f);
        n += p;
        if (n > 3) n = 0;
        if (n < 0) n = 3;
        allSections.set_type(f, n);

        allSolids_updated = true;
      }

      if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
        int n = allSections.get_res1(f);
        if (p > 0) n *= 2;
        if (p < 0) n /= 2;

        if (n > 1600) n = 100;
        if (n < 100) n = 1600;
        allSections.set_res1(f, n);

        allSections.set_res2(f, n); // also modifying the other one

        println("RES:", n);

        allSolids_updated = true;
      }

    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }


  void Solids (int p) {

    boolean allSolids_updated = false;

    for (int o = Select3D.Solid_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Solid_ids[o];

      int f = OBJ_ID;

      if ((WIN3D.UI_CurrentTask == UITASK.PowerX) ||  (WIN3D.UI_CurrentTask == UITASK.PowerY) ||  (WIN3D.UI_CurrentTask == UITASK.PowerZ) ||  (WIN3D.UI_CurrentTask == UITASK.PowerAll)) {


        float Solid_powX = allSolids.get_powX(f);
        float Solid_powY = allSolids.get_powY(f);
        float Solid_powZ = allSolids.get_powZ(f);


        float n = 2;

        if (WIN3D.UI_CurrentTask == UITASK.PowerX) n = Solid_powX;
        if (WIN3D.UI_CurrentTask == UITASK.PowerY) n = Solid_powY;
        if (WIN3D.UI_CurrentTask == UITASK.PowerZ) n = Solid_powZ;
        if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
          n = Solid_powX;
        }

        if (p > 0) n *= 2;
        if (p < 0) n /= 2;

        if (n > CubePower) n = StarPower;
        if (n < StarPower) n = CubePower;

        if (WIN3D.UI_CurrentTask == UITASK.PowerX) Solid_powX = n;
        if (WIN3D.UI_CurrentTask == UITASK.PowerY) Solid_powY = n;
        if (WIN3D.UI_CurrentTask == UITASK.PowerZ) Solid_powZ = n;
        if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
          Solid_powX = n;
          Solid_powY = n;
          Solid_powZ = n;
        }

        allSolids.updatePowers(f, Solid_powX, Solid_powY, Solid_powZ);

        allSolids_updated = true;
      }
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }




}

solarchvision_Edit3D Edit3D = new solarchvision_Edit3D();



class solarchvision_Scale3D {

  private final static String CLASS_STAMP = "Scale3D";

  void selection (float x0, float y0, float z0, float sx, float sy, float sz) {

    float[] O = Select3D.translateOutside_ReferencePivot(x0, y0, z0);

    x0 = O[0];
    y0 = O[1];
    z0 = O[2];

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      this.LandPoints(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
      this.softSelection(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      this.Vertices(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curves(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Faces(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Groups(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solids(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Cameras(x0, y0, z0, sx, sy, sz);
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Sections(sx, sy);
    }

  }


  void LandPoints (float x0, float y0, float z0, float sx, float sy, float sz) {

    for (int q = 0; q < Select3D.LandPoint_ids.length; q++) {

      int f = Select3D.LandPoint_ids[q];

      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;

      float x = Land3D.Mesh[i][j][0];
      float y = Land3D.Mesh[i][j][1];
      float z = Land3D.Mesh[i][j][2];

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      Land3D.Mesh[i][j][0] = x;
      Land3D.Mesh[i][j][1] = y;
      Land3D.Mesh[i][j][2] = z;

    }

    SOLARCHVISION_model_changed();
  }


  void softSelection (float x0, float y0, float z0, float sx, float sy, float sz) {

    for (int q = 0; q < Select3D.softSelection_ids.length; q++) {

      int f = Select3D.softSelection_ids[q];

      float v = Select3D.softSelection_values[q];

      float x = allPoints.getX(f) - x0;
      float y = allPoints.getY(f) - y0;
      float z = allPoints.getZ(f) - z0;

      allPoints.setX(f, (x0 + sx * x) * v + (x0 + x) * (1 - v));
      allPoints.setY(f, (y0 + sy * y) * v + (y0 + y) * (1 - v));
      allPoints.setZ(f, (z0 + sz * z) * v + (z0 + z) * (1 - v));
    }

    SOLARCHVISION_model_changed();
  }


  void Vertices (float x0, float y0, float z0, float sx, float sy, float sz) {

    for (int q = 0; q < Select3D.Vertex_ids.length; q++) {

      int f = Select3D.Vertex_ids[q];

      float x = allPoints.getX(f);
      float y = allPoints.getY(f);
      float z = allPoints.getZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allPoints.setX(f, x);
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }

    SOLARCHVISION_model_changed();
  }



  void Curves (float x0, float y0, float z0, float sx, float sy, float sz) {

    int[] CurveVertices = Select3D.get_Curve_Vertices();

    for (int q = 0; q < CurveVertices.length; q++) {

      int f = CurveVertices[q];

      float x = allPoints.getX(f);
      float y = allPoints.getY(f);
      float z = allPoints.getZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allPoints.setX(f, x);
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }

    SOLARCHVISION_model_changed();
  }


  void Faces (float x0, float y0, float z0, float sx, float sy, float sz) {

    int[] FaceVertices = Select3D.get_Face_Vertices();

    for (int q = 0; q < FaceVertices.length; q++) {

      int f = FaceVertices[q];

      float x = allPoints.getX(f);
      float y = allPoints.getY(f);
      float z = allPoints.getZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allPoints.setX(f, x);
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }

    SOLARCHVISION_model_changed();
  }


  void Solids (float x0, float y0, float z0, float sx, float sy, float sz) {

    boolean allSolids_updated = false;

    for (int q = 0; q < Select3D.Solid_ids.length; q++) {

      int f = Select3D.Solid_ids[q];

      float x = allSolids.get_posX(f);
      float y = allSolids.get_posY(f);
      float z = allSolids.get_posZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allSolids.updatePosition(f, x, y, z);

      allSolids.Scale(f, sx, sy, sz);

      allSolids_updated = true;
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Sections (float sx, float sy) {

    for (int q = 0; q < Select3D.Section_ids.length; q++) {

      int f = Select3D.Section_ids[q];

      allSections.setU(f, allSections.getU(f) * sx);
      allSections.setV(f, allSections.getV(f) * sy);
    }

    allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Cameras (float x0, float y0, float z0, float sx, float sy, float sz) {

    // swapping y and z vectors to match camera's local coordinate
    float tmp = sz;
    sz = sy;
    sy = tmp;

    for (int q = 0; q < Select3D.Camera_ids.length; q++) {

      int f = Select3D.Camera_ids[q];

      float x = allCameras.get_posX(f) - x0;
      float y = allCameras.get_posY(f) - y0;
      float z = allCameras.get_posZ(f) - z0;

      allCameras.set_posX(f, x0 + sx * x);
      allCameras.set_posY(f, y0 + sy * y);
      allCameras.set_posZ(f, z0 + sz * z);

      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }

    SOLARCHVISION_model_changed();
  }


  void Model1Ds (float x0, float y0, float z0, float sx, float sy, float sz) {

    for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Model1D_ids[o];

      float x = allModel1Ds.getX(f);
      float y = allModel1Ds.getY(f);
      float z = allModel1Ds.getZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allModel1Ds.setX(f, x);
      allModel1Ds.setY(f, y);
      allModel1Ds.setZ(f, z);

      allModel1Ds.magS(f, sz);
    }

    SOLARCHVISION_model_changed();
  }


  void Model2Ds (float x0, float y0, float z0, float sx, float sy, float sz) {

    int n1 = allModel2Ds.num_files_PEOPLE;

    for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Model2D_ids[o];

      float x = allModel2Ds.getX(f);
      float y = allModel2Ds.getY(f);
      float z = allModel2Ds.getZ(f);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allModel2Ds.setX(f, x);
      allModel2Ds.setY(f, y);
      allModel2Ds.setZ(f, z);


      int n = allModel2Ds.MAP[f];

      if (allModel2Ds.isTree(n)) { // does not scale poeple!
        allModel2Ds.magS(f, sz);
      }
    }

    SOLARCHVISION_model_changed();
  }


  void Groups (float x0, float y0, float z0, float sx, float sy, float sz) {

    int[] PolymeshVertices = Select3D.get_Group_Vertices();

    for (int q = 0; q < PolymeshVertices.length; q++) {

      int n = PolymeshVertices[q];

      float x = allPoints.getX(n);
      float y = allPoints.getY(n);
      float z = allPoints.getZ(n);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allPoints.setX(n, x);
      allPoints.setY(n, y);
      allPoints.setZ(n, z);
    }

    boolean allSolids_updated = false;

    for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Group_ids[o];

      {
        float x = allGroups.Pivots[OBJ_ID][0];
        float y = allGroups.Pivots[OBJ_ID][1];
        float z = allGroups.Pivots[OBJ_ID][2];

        float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;

        float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allGroups.Pivots[OBJ_ID][0] = x;
        allGroups.Pivots[OBJ_ID][1] = y;
        allGroups.Pivots[OBJ_ID][2] = z;

        // ???????
        //allGroups.Pivots[OBJ_ID][3] *= sx;
        //allGroups.Pivots[OBJ_ID][4] *= sy;
        //allGroups.Pivots[OBJ_ID][5] *= sz;
        // ???????
      }


      for (int f = allGroups.getStart_Model1D(OBJ_ID); f <= allGroups.getStop_Model1D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {

          float x = allModel1Ds.getX(f);
          float y = allModel1Ds.getY(f);
          float z = allModel1Ds.getZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allModel1Ds.setX(f, x);
          allModel1Ds.setY(f, y);
          allModel1Ds.setZ(f, z);

          allModel1Ds.magS(f, sz);
        }
      }


      for (int f = allGroups.getStart_Model2D(OBJ_ID); f <= allGroups.getStop_Model2D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {

          float x = allModel2Ds.getX(f);
          float y = allModel2Ds.getY(f);
          float z = allModel2Ds.getZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allModel2Ds.setX(f, x);
          allModel2Ds.setY(f, y);
          allModel2Ds.setZ(f, z);

          int n = allModel2Ds.MAP[f];

          if (allModel2Ds.isTree(n)) { // does not scale poeple!
            allModel2Ds.magS(f, sz);
          }
        }
      }

      for (int f = allGroups.getStart_Solid(OBJ_ID); f <= allGroups.getStop_Solid(OBJ_ID); f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {

          float x = allSolids.get_posX(f);
          float y = allSolids.get_posY(f);
          float z = allSolids.get_posZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allSolids.updatePosition(f, x, y, z);

          allSolids.Scale(f, sx, sy, sz);

          allSolids_updated = true;
        }
      }
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }

}

solarchvision_Scale3D Scale3D = new solarchvision_Scale3D();





class solarchvision_Rotate3D {

  private final static String CLASS_STAMP = "Rotate3D";

  void selection (float x0, float y0, float z0, float r, int the_Vector) {

    r *= PI / 180; // <<<<<<<<

    float[] A = Select3D.translateInside_ReferencePivot(0, 0, 0);
    float[] B = Select3D.translateInside_ReferencePivot(x0, y0, z0);

    x0 = B[0] - A[0];
    y0 = B[1] - A[1];
    z0 = B[2] - A[2];

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      this.LandPoints(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
      this.softSelection(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      this.Vertices(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curves(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Faces(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solids(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Cameras(x0, y0, z0, r, the_Vector);
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Sections(r);
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Groups(r, the_Vector);
    }
  }


  void softSelection (float x0, float y0, float z0, float r, int the_Vector) {

    for (int q = 0; q < Select3D.softSelection_ids.length; q++) {

      int f = Select3D.softSelection_ids[q];

      float v = Select3D.softSelection_values[q];

      float x = allPoints.getX(f) - x0;
      float y = allPoints.getY(f) - y0;
      float z = allPoints.getZ(f) - z0;

      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r * v) - y * sin(r * v)));
        allPoints.setY(f, y0 + (x * sin(r * v) + y * cos(r * v)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r * v) + x * cos(r * v)));
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r * v) - x * sin(r * v)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x));
        allPoints.setY(f, y0 + (y * cos(r * v) - z * sin(r * v)));
        allPoints.setZ(f, z0 + (y * sin(r * v) + z * cos(r * v)));
      }
    }

    SOLARCHVISION_model_changed();
  }



  void LandPoints (float x0, float y0, float z0, float r, int the_Vector) {

    for (int q = 0; q < Select3D.LandPoint_ids.length; q++) {

      int f = Select3D.LandPoint_ids[q];

      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;

      float x = Land3D.Mesh[i][j][0] - x0;
      float y = Land3D.Mesh[i][j][1] - y0;
      float z = Land3D.Mesh[i][j][2] - z0;

      if (the_Vector == 2) {
        Land3D.Mesh[i][j][0] = x0 + (x * cos(r) - y * sin(r));
        Land3D.Mesh[i][j][1] = y0 + (x * sin(r) + y * cos(r));
        Land3D.Mesh[i][j][2] = z0 + (z);
      } else if (the_Vector == 1) {
        Land3D.Mesh[i][j][0] = x0 + (z * sin(r) + x * cos(r));
        Land3D.Mesh[i][j][1] = y0 + (y);
        Land3D.Mesh[i][j][2] = z0 + (z * cos(r) - x * sin(r));
      } else if (the_Vector == 0) {
        Land3D.Mesh[i][j][0] = x0 + (x);
        Land3D.Mesh[i][j][1] = y0 + (y * cos(r) - z * sin(r));
        Land3D.Mesh[i][j][2] = z0 + (y * sin(r) + z * cos(r));
      }
    }

    SOLARCHVISION_model_changed();
  }




  void Vertices (float x0, float y0, float z0, float r, int the_Vector) {

    for (int q = 0; q < Select3D.Vertex_ids.length; q++) {

      int f = Select3D.Vertex_ids[q];

      float x = allPoints.getX(f) - x0;
      float y = allPoints.getY(f) - y0;
      float z = allPoints.getZ(f) - z0;

      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r)));
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r)));
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x));
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }

    SOLARCHVISION_model_changed();
  }


  void Curves (float x0, float y0, float z0, float r, int the_Vector) {

    int[] CurveVertices = Select3D.get_Curve_Vertices();

    for (int q = 0; q < CurveVertices.length; q++) {

      int f = CurveVertices[q];

      float x = allPoints.getX(f) - x0;
      float y = allPoints.getY(f) - y0;
      float z = allPoints.getZ(f) - z0;

      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r)));
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r)));
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x));
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }

    SOLARCHVISION_model_changed();
  }


  void Faces (float x0, float y0, float z0, float r, int the_Vector) {

    int[] FaceVertices = Select3D.get_Face_Vertices();

    for (int q = 0; q < FaceVertices.length; q++) {

      int f = FaceVertices[q];

      float x = allPoints.getX(f) - x0;
      float y = allPoints.getY(f) - y0;
      float z = allPoints.getZ(f) - z0;

      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r)));
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r)));
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x));
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }

    SOLARCHVISION_model_changed();
  }


  void Solids (float x0, float y0, float z0, float r, int the_Vector) {

    boolean allSolids_updated = false;

    for (int q = 0; q < Select3D.Solid_ids.length; q++) {

      int f = Select3D.Solid_ids[q];

      float Solid_posX = allSolids.get_posX(f);
      float Solid_posY = allSolids.get_posY(f);
      float Solid_posZ = allSolids.get_posZ(f);


      float x = Solid_posX - x0;
      float y = Solid_posY - y0;
      float z = Solid_posZ - z0;

      if (the_Vector == 2) {
        allSolids.updatePosition(f, x0 + (x * cos(r) - y * sin(r)), y0 + (x * sin(r) + y * cos(r)), z0 + (z));

        allSolids.RotateZ(f, r * 180 / PI);
      } else if (the_Vector == 1) {
        allSolids.updatePosition(f, x0 + (z * sin(r) + x * cos(r)), y0 + (y), z0 + (z * cos(r) - x * sin(r)));

        allSolids.RotateY(f, r * 180 / PI);
      } else if (the_Vector == 0) {
        allSolids.updatePosition(f, x0 + (x), y0 + (y * cos(r) - z * sin(r)), z0 + (y * sin(r) + z * cos(r)));

        allSolids.RotateX(f, r * 180 / PI);
      }

      allSolids_updated = true;
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Sections (float r) {

    for (int q = 0; q < Select3D.Section_ids.length; q++) {

      int f = Select3D.Section_ids[q];

      allSections.setR(f, allSections.getR(f) + r * 180.0 / PI);
    }

    allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Cameras (float x0, float y0, float z0, float r, int the_Vector) {

    // swapping y and z vectors to match camera's local coordinate
    if (the_Vector == 2) the_Vector = 1;
    else if (the_Vector == 1) the_Vector = 2;

    for (int q = 0; q < Select3D.Camera_ids.length; q++) {

      int f = Select3D.Camera_ids[q];

      float x = allCameras.get_posX(f) - x0;
      float y = allCameras.get_posY(f) - y0;
      float z = allCameras.get_posZ(f) - z0;

      if (the_Vector == 2) {
        allCameras.set_posX(f, x0 + (x * cos(r) - y * sin(r)));
        allCameras.set_posY(f, y0 + (x * sin(r) + y * cos(r)));
        allCameras.set_posZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allCameras.set_posX(f, x0 + (z * sin(r) + x * cos(r)));
        allCameras.set_posY(f, y0 + (y));
        allCameras.set_posZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allCameras.set_posX(f, x0 + (x));
        allCameras.set_posY(f, y0 + (y * cos(r) - z * sin(r)));
        allCameras.set_posZ(f, z0 + (y * sin(r) + z * cos(r)));
      }

      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }

    SOLARCHVISION_model_changed();
  }



  void Model1Ds (float x0, float y0, float z0, float r, int the_Vector) {

    for (int q = 0; q < Select3D.Model1D_ids.length; q++) {

      int f = Select3D.Model1D_ids[q];

      float x = allModel1Ds.getX(f) - x0;
      float y = allModel1Ds.getY(f) - y0;
      float z = allModel1Ds.getZ(f) - z0;

      if (the_Vector == 2) {
        allModel1Ds.setX(f, x0 + (x * cos(r) - y * sin(r)));
        allModel1Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allModel1Ds.setZ(f, z0 + (z));

        allModel1Ds.setRotation(f, allModel1Ds.getRotation(f) - r); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      } else if (the_Vector == 1) {
        allModel1Ds.setX(f, x0 + (z * sin(r) + x * cos(r)));
        allModel1Ds.setY(f, y0 + (y));
        allModel1Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allModel1Ds.setX(f, x0 + (x));
        allModel1Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allModel1Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }

    SOLARCHVISION_model_changed();
  }


  void Model2Ds (float x0, float y0, float z0, float r, int the_Vector) {

    for (int q = 0; q < Select3D.Model2D_ids.length; q++) {

      int f = Select3D.Model2D_ids[q];

      float x = allModel2Ds.getX(f) - x0;
      float y = allModel2Ds.getY(f) - y0;
      float z = allModel2Ds.getZ(f) - z0;

      if (the_Vector == 2) {
        allModel2Ds.setX(f, x0 + (x * cos(r) - y * sin(r)));
        allModel2Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allModel2Ds.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allModel2Ds.setX(f, x0 + (z * sin(r) + x * cos(r)));
        allModel2Ds.setY(f, y0 + (y));
        allModel2Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allModel2Ds.setX(f, x0 + (x));
        allModel2Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allModel2Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }

    SOLARCHVISION_model_changed();
  }



  void Groups (float r, int the_Vector) {

    int[] PolymeshVertices = Select3D.get_Group_Vertices();

    for (int q = 0; q < PolymeshVertices.length; q++) {

      int n = PolymeshVertices[q];

      float x = allPoints.getX(n);
      float y = allPoints.getY(n);
      float z = allPoints.getZ(n);

      float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

      x = A[0];
      y = A[1];
      z = A[2];

      {
        float a = x;
        float b = y;
        float c = z;

        if (the_Vector == 2) {
          a = x * cos(r) - y * sin(r);
          b = x * sin(r) + y * cos(r);
          c = z;
        } else if (the_Vector == 1) {
          a = z * sin(r) + x * cos(r);
          b = y;
          c = z * cos(r) - x * sin(r);
        } else if (the_Vector == 0) {
          a = x;
          b = y * cos(r) - z * sin(r);
          c = y * sin(r) + z * cos(r);
        }

        x = a;
        y = b;
        z = c;
      }

      float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allPoints.setX(n, x);
      allPoints.setY(n, y);
      allPoints.setZ(n, z);
    }






    boolean allSolids_updated = false;

    for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Group_ids[o];

      {
        float x = allGroups.Pivots[OBJ_ID][0];
        float y = allGroups.Pivots[OBJ_ID][1];
        float z = allGroups.Pivots[OBJ_ID][2];

        float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        {
          float a = x;
          float b = y;
          float c = z;

          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r);
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r);
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }

          x = a;
          y = b;
          z = c;
        }

        float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allGroups.Pivots[OBJ_ID][0] = x;
        allGroups.Pivots[OBJ_ID][1] = y;
        allGroups.Pivots[OBJ_ID][2] = z;

        if (the_Vector == 2) {
          allGroups.Pivots[OBJ_ID][8] += r * 180.0 / PI;
        } else if (the_Vector == 1) {
          allGroups.Pivots[OBJ_ID][7] += r * 180.0 / PI;
        } else if (the_Vector == 0) {
          allGroups.Pivots[OBJ_ID][6] += r * 180.0 / PI;
        }
      }


      for (int f = allGroups.getStart_Model1D(OBJ_ID); f <= allGroups.getStop_Model1D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {

          float x = allModel1Ds.getX(f);
          float y = allModel1Ds.getY(f);
          float z = allModel1Ds.getZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r);
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r);
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }

            x = a;
            y = b;
            z = c;
          }

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allModel1Ds.setX(f, x);
          allModel1Ds.setY(f, y);
          allModel1Ds.setZ(f, z);


          if (the_Vector == 2) {
            //allModel1Ds.setRotation(f, allModel1Ds.getRotation(f) + r); // <<<<<<<<<
          } else if (the_Vector == 1) {
          } else if (the_Vector == 0) {
          }
        }
      }

      for (int f = allGroups.getStart_Model2D(OBJ_ID); f <= allGroups.getStop_Model2D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {

          float x = allModel2Ds.getX(f);
          float y = allModel2Ds.getY(f);
          float z = allModel2Ds.getZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r);
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r);
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }

            x = a;
            y = b;
            z = c;
          }

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allModel2Ds.setX(f, x);
          allModel2Ds.setY(f, y);
          allModel2Ds.setZ(f, z);
        }
      }

      for (int f = allGroups.getStart_Solid(OBJ_ID); f <= allGroups.getStop_Solid(OBJ_ID); f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {

          float x = allSolids.get_posX(f);
          float y = allSolids.get_posY(f);
          float z = allSolids.get_posZ(f);

          float[] A = Select3D.translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r);
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r);
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }

            x = a;
            y = b;
            z = c;
          }

          float[] B = Select3D.translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];


          allSolids.updatePosition(f, x, y, z);

          // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Note: these rotations could be translated to locals to avoid problems!
          if (the_Vector == 2) {
            allSolids.RotateZ(f, r * 180 / PI);
          } else if (the_Vector == 1) {
            allSolids.RotateY(f, r * 180 / PI);
          } else if (the_Vector == 0) {
            allSolids.RotateX(f, r * 180 / PI);
          }

          allSolids_updated = true;
        }
      }
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }

}

solarchvision_Rotate3D Rotate3D = new solarchvision_Rotate3D();






class solarchvision_Move3D {

  private final static String CLASS_STAMP = "Move3D";

  void selection (float dx, float dy, float dz) {
    /*
    float[] A = Select3D.translateInside_ReferencePivot(0, 0, 0);
    float[] B = Select3D.translateInside_ReferencePivot(dx, dy, dz);

    dx = B[0] - A[0];
    dy = B[1] - A[1];
    dz = B[2] - A[2];
    */


    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      this.LandPoints(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
      this.softSelection(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      this.Vertices(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curves(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Faces(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solids(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Sections(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Cameras(dx, dy, dz);
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Groups(dx, dy, dz);
    }
  }



  void LandPoints (float dx, float dy, float dz) {

    for (int q = 0; q < Select3D.LandPoint_ids.length; q++) {

      int f = Select3D.LandPoint_ids[q];

      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;

      Land3D.Mesh[i][j][0] += dx;
      Land3D.Mesh[i][j][1] += dy;
      Land3D.Mesh[i][j][2] += dz;
    }

    SOLARCHVISION_model_changed();
  }


  void softSelection (float dx, float dy, float dz) {

    for (int q = 0; q < Select3D.softSelection_ids.length; q++) {

      int f = Select3D.softSelection_ids[q];

      float v = Select3D.softSelection_values[q];

      allPoints.move(f, dx * v, dy * v, dz * v);
    }

    SOLARCHVISION_model_changed();
  }


  void Vertices (float dx, float dy, float dz) {

    for (int q = 0; q < Select3D.Vertex_ids.length; q++) {

      int f = Select3D.Vertex_ids[q];

      allPoints.move(f, dx, dy, dz);
    }

    SOLARCHVISION_model_changed();
  }


  void Curves (float dx, float dy, float dz) {

    int[] CurveVertices = Select3D.get_Curve_Vertices();

    for (int q = 0; q < CurveVertices.length; q++) {

      int f = CurveVertices[q];

      allPoints.move(f, dx, dy, dz);
    }

    SOLARCHVISION_model_changed();
  }


  void Faces (float dx, float dy, float dz) {

    int[] FaceVertices = Select3D.get_Face_Vertices();

    for (int q = 0; q < FaceVertices.length; q++) {

      int f = FaceVertices[q];

      allPoints.move(f, dx, dy, dz);
    }
  }


  void Model1Ds (float dx, float dy, float dz) {

    for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Model1D_ids[o];

      allModel1Ds.move(f, dx, dy, dz);
    }

    SOLARCHVISION_model_changed();
  }



  void Model2Ds (float dx, float dy, float dz) {

    for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

      int f = Select3D.Model2D_ids[o];

      allModel2Ds.move(f, dx, dy, dz);
    }

    SOLARCHVISION_model_changed();
  }


  void Solids (float dx, float dy, float dz) {

    boolean allSolids_updated = false;

    for (int q = 0; q < Select3D.Solid_ids.length; q++) {

      int f = Select3D.Solid_ids[q];

      float Solid_posX = allSolids.get_posX(f);
      float Solid_posY = allSolids.get_posY(f);
      float Solid_posZ = allSolids.get_posZ(f);

      allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

      allSolids_updated = true;
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Sections (float dx, float dy, float dz) {

    for (int q = 0; q < Select3D.Section_ids.length; q++) {

      int f = Select3D.Section_ids[q];

      allSections.move(f, dx, dy, dz);
    }

    allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }


  void Cameras (float dx, float dy, float dz) {

    // swapping y and z vectors to match camera's local coordinate
    float tmp = dz;
    dz = dy;
    dy = tmp;

    for (int q = 0; q < Select3D.Camera_ids.length; q++) {

      int f = Select3D.Camera_ids[q];

      allCameras.move(f, dx, dy, dz);

      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }

    SOLARCHVISION_model_changed();
  }

  void Groups (float dx, float dy, float dz) {

    int[] PolymeshVertices = Select3D.get_Group_Vertices();

    for (int q = 0; q < PolymeshVertices.length; q++) {

      int n = PolymeshVertices[q];

      allPoints.move(n, dx, dy, dz);
    }

    boolean allSolids_updated = false;

    for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Group_ids[o];

      {
        allGroups.Pivots[OBJ_ID][0] += dx;
        allGroups.Pivots[OBJ_ID][1] += dy;
        allGroups.Pivots[OBJ_ID][2] += dz;
      }

      for (int f = allGroups.getStart_Model1D(OBJ_ID); f <= allGroups.getStop_Model1D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {

          allModel1Ds.move(f, dx, dy, dz);
        }
      }

      for (int f = allGroups.getStart_Model2D(OBJ_ID); f <= allGroups.getStop_Model2D(OBJ_ID); f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {

          allModel2Ds.move(f, dx, dy, dz);
        }
      }

      for (int f = allGroups.getStart_Solid(OBJ_ID); f <= allGroups.getStop_Solid(OBJ_ID); f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {

          float Solid_posX = allSolids.get_posX(f);
          float Solid_posY = allSolids.get_posY(f);
          float Solid_posZ = allSolids.get_posZ(f);

          allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

          allSolids_updated = true;
        }
      }
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }

}

solarchvision_Move3D Move3D = new solarchvision_Move3D();




class solarchvision_Drop3D {

  private final static String CLASS_STAMP = "Drop3D";

  void selection () {

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds();
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds();
    }

  }





  void Model1Ds () {

    for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model1D_ids[o];

      float x = allModel1Ds.getX(OBJ_ID);
      float y = allModel1Ds.getY(OBJ_ID);
      float z = allModel1Ds.getZ(OBJ_ID);

      float[] ray_start = {
        x, y, z
      };

      float[] ray_direction = {
        0, 0, -1
      };

      float[] RxP = new float [8];

      if (WIN3D.UI_TaskModifyParameter == 0) {
        RxP = Land3D.intersect(ray_start, ray_direction);
      } else if (WIN3D.UI_TaskModifyParameter == 1) {
        RxP = allFaces.intersect(ray_start, ray_direction);
      } else {
        RxP[0] = -1; // undefined
      }

      if (RxP[0] >= 0) {
        allModel1Ds.setX(OBJ_ID, RxP[1]);
        allModel1Ds.setY(OBJ_ID, RxP[2]);
        allModel1Ds.setZ(OBJ_ID, RxP[3]);
      } else {
        ray_direction[2] = 1; // <<<< going upwards

        if (WIN3D.UI_TaskModifyParameter == 0) {
          RxP = Land3D.intersect(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 2) {
          RxP = allFaces.intersect(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] >= 0) {
          allModel1Ds.setX(OBJ_ID, RxP[1]);
          allModel1Ds.setY(OBJ_ID, RxP[2]);
          allModel1Ds.setZ(OBJ_ID, RxP[3]);
        }
      }
    }

    SOLARCHVISION_model_changed();
  }



  void Model2Ds () {

    for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model2D_ids[o];

      float x = allModel2Ds.getX(OBJ_ID);
      float y = allModel2Ds.getY(OBJ_ID);
      float z = allModel2Ds.getZ(OBJ_ID);

      float[] ray_start = {
        x, y, z
      };

      float[] ray_direction = {
        0, 0, -1
      };

      float[] RxP = new float [8];

      if (WIN3D.UI_TaskModifyParameter == 0) {
        RxP = Land3D.intersect(ray_start, ray_direction);
      } else if (WIN3D.UI_TaskModifyParameter == 1) {
        RxP = allFaces.intersect(ray_start, ray_direction);
      } else {
        RxP[0] = -1; // undefined
      }

      if (RxP[0] >= 0) {
        allModel2Ds.setX(OBJ_ID, RxP[1]);
        allModel2Ds.setY(OBJ_ID, RxP[2]);
        allModel2Ds.setZ(OBJ_ID, RxP[3]);
      } else {
        ray_direction[2] = 1; // <<<< going upwards

        if (WIN3D.UI_TaskModifyParameter == 0) {
          RxP = Land3D.intersect(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 2) {
          RxP = allFaces.intersect(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] >= 0) {
          allModel2Ds.setX(OBJ_ID, RxP[1]);
          allModel2Ds.setY(OBJ_ID, RxP[2]);
          allModel2Ds.setZ(OBJ_ID, RxP[3]);
        }
      }
    }

    SOLARCHVISION_model_changed();
  }


}

solarchvision_Drop3D Drop3D = new solarchvision_Drop3D();












class solarchvision_Clone3D {

  private final static String CLASS_STAMP = "Clone3D";

  void selection (boolean produce_same_variation) {

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1Ds(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2Ds(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Faces(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curves(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solids(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Sections(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Cameras(produce_same_variation);
    }

    if (current_ObjectCategory == ObjectCategory.GROUP)  {
      this.Groups(produce_same_variation);
    }
  }



  void Model1Ds (boolean produce_same_variation) {

    int number_of_allModel1Ds_before = allModel1Ds.num;

    for (int o = 0; o < Select3D.Model1D_ids.length; o++) {

      int OBJ_ID = Select3D.Model1D_ids[o];

      float x = allModel1Ds.getX(OBJ_ID);
      float y = allModel1Ds.getY(OBJ_ID);
      float z = allModel1Ds.getZ(OBJ_ID);
      float d = allModel1Ds.getScale(OBJ_ID);
      float rot = allModel1Ds.getRotation(OBJ_ID);
      float tilt = allModel1Ds.getBranchTilt(OBJ_ID);
      float twist = allModel1Ds.getBranchTwist(OBJ_ID);
      float ratio = allModel1Ds.getBranchRatio(OBJ_ID);
      float base = allModel1Ds.getTreeBase(OBJ_ID);

      int n = allModel1Ds.getType(OBJ_ID);
      int dMax = allModel1Ds.getDegreeMax(OBJ_ID);
      int seed = allModel1Ds.getSeed(OBJ_ID);
      float trunkSize = allModel1Ds.getTrunkSize(OBJ_ID);
      float leafSize = allModel1Ds.getLeafSize(OBJ_ID);

      if (produce_same_variation == false) randomSeed(millis());
      allModel1Ds.create(n, seed, dMax, x, y, z, d, rot, tilt, twist, ratio, base, trunkSize, leafSize);
    }

    // selecting new objetcs

    Select3D.deselect_Model1Ds();

    for (int o = number_of_allModel1Ds_before; o < allModel1Ds.num; o++) {

      int[] newlyAddedallModel1Ds = {o};

      Select3D.Model1D_ids = concat(Select3D.Model1D_ids, newlyAddedallModel1Ds);
    }

    SOLARCHVISION_selection_changed();
  }


  void Model2Ds (boolean produce_same_variation) {

    int number_of_allModel2Ds_before = allModel2Ds.num;

    for (int o = 0; o < Select3D.Model2D_ids.length; o++) {

      int OBJ_ID = Select3D.Model2D_ids[o];

      float x = allModel2Ds.getX(OBJ_ID);
      float y = allModel2Ds.getY(OBJ_ID);
      float z = allModel2Ds.getZ(OBJ_ID);
      float s = allModel2Ds.getS(OBJ_ID);

      int n = allModel2Ds.MAP[OBJ_ID];
      if (allModel2Ds.isTree(n)) {
        if (produce_same_variation == false) n = 0; // this makes it random
        allModel2Ds.create("TREES", n, x, y, z, s);
      } else {
        if (produce_same_variation == false) n = 0; // this makes it random
        allModel2Ds.create("PEOPLE", n, x, y, z, s);
      }
    }

    // selecting new objetcs

    Select3D.deselect_Model2Ds();

    for (int o = number_of_allModel2Ds_before; o < allModel2Ds.num; o++) {

      int[] newlyAddedallModel2Ds = {o};

      Select3D.Model2D_ids = concat(Select3D.Model2D_ids, newlyAddedallModel2Ds);
    }

    SOLARCHVISION_selection_changed();
  }


  void Faces (boolean produce_same_variation) {

    int number_of_Faces_before = allFaces.nodes.length;

    for (int o = 0; o < Select3D.Face_ids.length; o++) {

      int f = Select3D.Face_ids[o];

      int number_of_Vertices_before = allPoints.getLength();

      int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
      int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

      if ((0 <= f) && (f < allFaces.nodes.length)) {

        int[] newFace_nodes = {
        };

        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];

          int vertex_listed = -1;

          for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
            if (vNo == PolymeshVertices_OLD[q]) {
              vertex_listed = q;
              break;
            }
          }

          if (vertex_listed == -1) {
            int[] newVertexListed = {
              vNo
            };
            PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

            float x = allPoints.getX(vNo);
            float y = allPoints.getY(vNo);
            float z = allPoints.getZ(vNo);

            int[] newVertexAdded = {
              allPoints.create(x, y, z)
            };
            PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

            vertex_listed = PolymeshVertices_OLD.length;
          }

          //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);

          int[] new_vertexItem = {
            number_of_Vertices_before + vertex_listed - 1
          };

          newFace_nodes = concat(newFace_nodes, new_vertexItem);
        }

        current_Material = allFaces.getMaterial(f);
        current_Tessellation = allFaces.getTessellation(f);
        current_Layer = allFaces.getLayer(f);
        current_Visibility = allFaces.getVisibility(f);

        allFaces.create(newFace_nodes);
      }
    }


    // selecting new objetcs

    Select3D.Face_ids = new int [0];

    for (int o = number_of_Faces_before; o < allFaces.nodes.length; o++) {

      int[] newlyAddedFace = {o};

      Select3D.Face_ids = concat(Select3D.Face_ids, newlyAddedFace);
    }

    SOLARCHVISION_selection_changed();
  }


  void Curves (boolean produce_same_variation) {

    int number_of_Curves_before = allCurves.nodes.length;

    for (int o = 0; o < Select3D.Curve_ids.length; o++) {

      int f = Select3D.Curve_ids[o];

      int number_of_Vertices_before = allPoints.getLength();

      int[] PolymeshVertices_OLD = new int [0];  // keeps the list of exiting vertex numbers
      int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

      if ((0 <= f) && (f < allCurves.nodes.length)) {

        int[] newCurve_nodes = {
        };

        for (int j = 0; j < allCurves.nodes[f].length; j++) {
          int vNo = allCurves.nodes[f][j];

          int vertex_listed = -1;

          for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
            if (vNo == PolymeshVertices_OLD[q]) {
              vertex_listed = q;
              break;
            }
          }

          if (vertex_listed == -1) {
            int[] newVertexListed = {
              vNo
            };
            PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

            float x = allPoints.getX(vNo);
            float y = allPoints.getY(vNo);
            float z = allPoints.getZ(vNo);

            int[] newVertexAdded = {
              allPoints.create(x, y, z)
            };
            PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

            vertex_listed = PolymeshVertices_OLD.length;
          }

          //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);

          int[] new_vertexItem = {
            number_of_Vertices_before + vertex_listed - 1
          };

          newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
        }

        current_Material = allCurves.getMaterial(f);
        current_Tessellation = allCurves.getTessellation(f);
        current_Layer = allCurves.getLayer(f);
        current_Visibility = allCurves.getVisibility(f);
        current_Weight = allCurves.getWeight(f);
        current_Closed = allCurves.getClose(f);

        allCurves.create(newCurve_nodes);
      }
    }


    // selecting new objetcs

    Select3D.Curve_ids = new int [0];

    for (int o = number_of_Curves_before; o < allCurves.nodes.length; o++) {

      int[] newlyAddedCurve = {o};

      Select3D.Curve_ids = concat(Select3D.Curve_ids, newlyAddedCurve);
    }

    SOLARCHVISION_selection_changed();
  }


  void Solids (boolean produce_same_variation) {

    int number_of_Solid_before = allSolids.DEF.length;

    for (int o = 0; o < Select3D.Solid_ids.length; o++) {

      int OBJ_ID = Select3D.Solid_ids[o];

      float Solid_posX = allSolids.get_posX(OBJ_ID);
      float Solid_posY = allSolids.get_posY(OBJ_ID);
      float Solid_posZ = allSolids.get_posZ(OBJ_ID);
      float Solid_powX = allSolids.get_powX(OBJ_ID);
      float Solid_powY = allSolids.get_powY(OBJ_ID);
      float Solid_powZ = allSolids.get_powZ(OBJ_ID);
      float Solid_scaleX = allSolids.get_scaleX(OBJ_ID);
      float Solid_scaleY = allSolids.get_scaleY(OBJ_ID);
      float Solid_scaleZ = allSolids.get_scaleZ(OBJ_ID);
      float Solid_rotX = allSolids.get_rotX(OBJ_ID);
      float Solid_rotY = allSolids.get_rotY(OBJ_ID);
      float Solid_rotZ = allSolids.get_rotZ(OBJ_ID);
      float Solid_value = allSolids.get_value(OBJ_ID);

      allSolids.create(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
    }

    // selecting new objetcs

    Select3D.deselect_Solids();

    for (int o = number_of_Solid_before; o < allSolids.DEF.length; o++) {

      int[] newlyAddedSolid = {o};

      Select3D.Solid_ids = concat(Select3D.Solid_ids, newlyAddedSolid);
    }

    SOLARCHVISION_selection_changed();
  }

  void Sections (boolean produce_same_variation) {

    int number_of_Section_before = allSections.num;

    for (int o = 0; o < Select3D.Section_ids.length; o++) {

      int OBJ_ID = Select3D.Section_ids[o];

      float Section_X = allSections.getX(OBJ_ID);
      float Section_Y = allSections.getY(OBJ_ID);
      float Section_Z = allSections.getZ(OBJ_ID);
      float Section_R = allSections.getR(OBJ_ID);
      float Section_U = allSections.getU(OBJ_ID);
      float Section_V = allSections.getV(OBJ_ID);

      int Section_Type = allSections.get_type(OBJ_ID);
      int Section_RES1 = allSections.get_res1(OBJ_ID);
      int Section_RES2 = allSections.get_res2(OBJ_ID);

      allSections.create(Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_Type, Section_RES1, Section_RES2);
    }

    // selecting new objetcs

    Select3D.deselect_Sections();

    for (int o = number_of_Section_before; o < allSections.num; o++) {

      int[] newlyAddedSection = {o};

      Select3D.Section_ids = concat(Select3D.Section_ids, newlyAddedSection);
    }

    SOLARCHVISION_selection_changed();
  }


  void Cameras (boolean produce_same_variation) {

    int number_of_Camera_before = allCameras.num;

    for (int o = 0; o < Select3D.Camera_ids.length; o++) {

      int OBJ_ID = Select3D.Camera_ids[o];

      float Camera_pX = allCameras.get_posX(OBJ_ID);
      float Camera_pY = allCameras.get_posY(OBJ_ID);
      float Camera_pZ = allCameras.get_posZ(OBJ_ID);
      float Camera_pT = allCameras.get_posT(OBJ_ID);
      float Camera_rX = allCameras.get_rotX(OBJ_ID);
      float Camera_rY = allCameras.get_rotY(OBJ_ID);
      float Camera_rZ = allCameras.get_rotZ(OBJ_ID);
      float Camera_rT = allCameras.get_rotT(OBJ_ID);
      float Camera_zoom = allCameras.get_zoom(OBJ_ID);
      int   Camera_type = allCameras.get_type(OBJ_ID);

      allCameras.create(Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_zoom, Camera_type);
    }

    // selecting new objetcs

    Select3D.deselect_Cameras();

    for (int o = number_of_Camera_before; o < allCameras.num; o++) {

      int[] newlyAddedCamera = {o};

      Select3D.Camera_ids = concat(Select3D.Camera_ids, newlyAddedCamera);
    }

    SOLARCHVISION_selection_changed();
  }


  void Groups (boolean produce_same_variation) {

    int SOLID_added = 0;

    int number_of_allGroups_before = allGroups.num;

    for (int o = 0; o < Select3D.Group_ids.length; o++) {

      int OBJ_ID = Select3D.Group_ids[o];

      if ((0 <= allGroups.getStart_Face(OBJ_ID)) && (allGroups.getStart_Face(OBJ_ID) <= allGroups.getStop_Face(OBJ_ID))) {

        int number_of_Vertices_before = allPoints.getLength();

        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

        int new_OBJ_ID = allGroups.num - 1;

        for (int j = 0; j < allGroups.Pivots[OBJ_ID].length; j++) {
          allGroups.Pivots[new_OBJ_ID][j] = allGroups.Pivots[OBJ_ID][j];
        }

        if ((0 <= allGroups.getStop_Model1D(OBJ_ID)) && (allGroups.getStart_Model1D(OBJ_ID) <= allGroups.getStop_Model1D(OBJ_ID))) {
          for (int q = allGroups.getStart_Model1D(OBJ_ID); q <= allGroups.getStop_Model1D(OBJ_ID); q++) {

            float x = allModel1Ds.getX(q);
            float y = allModel1Ds.getY(q);
            float z = allModel1Ds.getZ(q);

            float d = allModel1Ds.getScale(q);
            float rot = allModel1Ds.getRotation(q);

            float tilt = allModel1Ds.getBranchTilt(q);
            float twist = allModel1Ds.getBranchTwist(q);
            float ratio = allModel1Ds.getBranchRatio(q);
            float base = allModel1Ds.getBranchRatio(q);

            int n = allModel1Ds.getType(q);

            int dMax = allModel1Ds.getDegreeMax(q);

            int seed = allModel1Ds.getSeed(q);

            float trunkSize = allModel1Ds.getTrunkSize(q);

            float leafSize = allModel1Ds.getLeafSize(q);

            if (produce_same_variation == false) {
              randomSeed(millis());

              rot = floor(random(360));
              seed = int(random(32767));
            }
            allModel1Ds.create(n, seed, dMax, x, y, z, d, rot, tilt, twist, ratio, base, trunkSize, leafSize);
          }
        }

        if ((0 <= allGroups.getStop_Model2D(OBJ_ID)) && (allGroups.getStart_Model2D(OBJ_ID) <= allGroups.getStop_Model2D(OBJ_ID))) {
          for (int q = allGroups.getStart_Model2D(OBJ_ID); q <= allGroups.getStop_Model2D(OBJ_ID); q++) {

            float x = allModel2Ds.getX(q);
            float y = allModel2Ds.getY(q);
            float z = allModel2Ds.getZ(q);
            float s = allModel2Ds.getS(q);

            int n = allModel2Ds.MAP[q];

            if (allModel2Ds.isTree(n)) {
              if (produce_same_variation == false) n = 0; // this makes it random
              allModel2Ds.create("TREES", n, x, y, z, s);
            } else {
              if (produce_same_variation == false) n = 0; // this makes it random
              allModel2Ds.create("PEOPLE", n, x, y, z, s);
            }
          }
        }


        if ((0 <= allGroups.getStop_Solid(OBJ_ID)) && (allGroups.getStart_Solid(OBJ_ID) <= allGroups.getStop_Solid(OBJ_ID))) {
          for (int q = allGroups.getStart_Solid(OBJ_ID); q <= allGroups.getStop_Solid(OBJ_ID); q++) {

            float Solid_posX = allSolids.get_posX(q);
            float Solid_posY = allSolids.get_posY(q);
            float Solid_posZ = allSolids.get_posZ(q);
            float Solid_powX = allSolids.get_powX(q);
            float Solid_powY = allSolids.get_powY(q);
            float Solid_powZ = allSolids.get_powZ(q);
            float Solid_scaleX = allSolids.get_scaleX(q);
            float Solid_scaleY = allSolids.get_scaleY(q);
            float Solid_scaleZ = allSolids.get_scaleZ(q);
            float Solid_rotX = allSolids.get_rotX(q);
            float Solid_rotY = allSolids.get_rotY(q);
            float Solid_rotZ = allSolids.get_rotZ(q);
            float Solid_value = allSolids.get_value(q);

            allSolids.create(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

            SOLID_added += 1;
          }
        }



        int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

        for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

          if ((0 <= f) && (f < allFaces.nodes.length)) {

            int[] newFace_nodes = {
            };

            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];

              int vertex_listed = -1;

              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }

              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);

                int[] newVertexAdded = {
                  allPoints.create(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

                vertex_listed = PolymeshVertices_OLD.length - 1;
              }

              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };

              newFace_nodes = concat(newFace_nodes, new_vertexItem);
            }

            current_Material = allFaces.getMaterial(f);
            current_Tessellation = allFaces.getTessellation(f);
            current_Layer = allFaces.getLayer(f);
            current_Visibility = allFaces.getVisibility(f);

            allFaces.create(newFace_nodes);

            println("newFace_nodes");
            println(newFace_nodes);
          }
        }
      }

      if ((0 <= allGroups.getStart_Curve(OBJ_ID)) && (allGroups.getStart_Curve(OBJ_ID) <= allGroups.getStop_Curve(OBJ_ID))) {

        int number_of_Vertices_before = allPoints.getLength();

        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

        int new_OBJ_ID = allGroups.num - 1;

        for (int j = 0; j < allGroups.Pivots[OBJ_ID].length; j++) {
          allGroups.Pivots[new_OBJ_ID][j] = allGroups.Pivots[OBJ_ID][j];
        }

        if ((0 <= allGroups.getStop_Model1D(OBJ_ID)) && (allGroups.getStart_Model1D(OBJ_ID) <= allGroups.getStop_Model1D(OBJ_ID))) {
          for (int q = allGroups.getStart_Model1D(OBJ_ID); q <= allGroups.getStop_Model1D(OBJ_ID); q++) {

            float x = allModel1Ds.getX(q);
            float y = allModel1Ds.getY(q);
            float z = allModel1Ds.getZ(q);

            float d = allModel1Ds.getScale(q);
            float rot = allModel1Ds.getRotation(q);

            float tilt = allModel1Ds.getBranchTilt(q);
            float twist = allModel1Ds.getBranchTwist(q);
            float ratio = allModel1Ds.getBranchRatio(q);
            float base = allModel1Ds.getBranchRatio(q);

            int n = allModel1Ds.getType(q);

            int dMax = allModel1Ds.getDegreeMax(q);

            int seed = allModel1Ds.getSeed(q);

            float trunkSize = allModel1Ds.getTrunkSize(q);

            float leafSize = allModel1Ds.getLeafSize(q);

            if (produce_same_variation == false) {
              randomSeed(millis());

              rot = floor(random(360));
              seed = int(random(32767));
            }
            allModel1Ds.create(n, seed, dMax, x, y, z, d, rot, tilt, twist, ratio, base, trunkSize, leafSize);
          }
        }

        if ((0 <= allGroups.getStop_Model2D(OBJ_ID)) && (allGroups.getStart_Model2D(OBJ_ID) <= allGroups.getStop_Model2D(OBJ_ID))) {
          for (int q = allGroups.getStart_Model2D(OBJ_ID); q <= allGroups.getStop_Model2D(OBJ_ID); q++) {

            float x = allModel2Ds.getX(q);
            float y = allModel2Ds.getY(q);
            float z = allModel2Ds.getZ(q);
            float s = allModel2Ds.getS(q);

            int n = allModel2Ds.MAP[q];

            if (allModel2Ds.isTree(n)) {
              if (produce_same_variation == false) n = 0; // this makes it random
              allModel2Ds.create("TREES", n, x, y, z, s);
            } else {
              if (produce_same_variation == false) n = 0; // this makes it random
              allModel2Ds.create("PEOPLE", n, x, y, z, s);
            }
          }
        }

        if ((0 <= allGroups.getStop_Solid(OBJ_ID)) && (allGroups.getStart_Solid(OBJ_ID) <= allGroups.getStop_Solid(OBJ_ID))) {
          for (int q = allGroups.getStart_Solid(OBJ_ID); q <= allGroups.getStop_Solid(OBJ_ID); q++) {

            float Solid_posX = allSolids.get_posX(q);
            float Solid_posY = allSolids.get_posY(q);
            float Solid_posZ = allSolids.get_posZ(q);
            float Solid_powX = allSolids.get_powX(q);
            float Solid_powY = allSolids.get_powY(q);
            float Solid_powZ = allSolids.get_powZ(q);
            float Solid_scaleX = allSolids.get_scaleX(q);
            float Solid_scaleY = allSolids.get_scaleY(q);
            float Solid_scaleZ = allSolids.get_scaleZ(q);
            float Solid_rotX = allSolids.get_rotX(q);
            float Solid_rotY = allSolids.get_rotY(q);
            float Solid_rotZ = allSolids.get_rotZ(q);
            float Solid_value = allSolids.get_value(q);

            allSolids.create(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

            SOLID_added += 1;
          }
        }


        int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers

        for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {

          if ((0 <= f) && (f < allCurves.nodes.length)) {

            int[] newCurve_nodes = {
            };

            for (int j = 0; j < allCurves.nodes[f].length; j++) {
              int vNo = allCurves.nodes[f][j];

              int vertex_listed = -1;

              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }

              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);

                int[] newVertexAdded = {
                  allPoints.create(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

                vertex_listed = PolymeshVertices_OLD.length - 1;
              }

              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };

              newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
            }

            current_Material = allCurves.getMaterial(f);
            current_Tessellation = allCurves.getTessellation(f);
            current_Layer = allCurves.getLayer(f);
            current_Visibility = allCurves.getVisibility(f);
            current_Weight = allCurves.getWeight(f);
            current_Closed = allCurves.getClose(f);

            allCurves.create(newCurve_nodes);
          }
        }
      }
    }



    // selecting new objetcs

    Select3D.deselect_Groups();

    for (int o = number_of_allGroups_before; o < allGroups.num; o++) {

      int[] newlyAddedGroup = {o};

      Select3D.Group_ids = concat(Select3D.Group_ids, newlyAddedGroup);
    }


    if (SOLID_added != 0) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_selection_changed();
  }

}

solarchvision_Clone3D Clone3D = new solarchvision_Clone3D();









class solarchvision_Delete3D {

  private final static String CLASS_STAMP = "Delete3D";

  void selection () {

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      Delete3D.selected_Cameras();
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      Delete3D.selected_Sections();
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      Delete3D.selected_Model1Ds();
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      Delete3D.selected_Model2Ds();
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      Delete3D.selected_Solids();
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      Delete3D.selected_Faces();
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      Delete3D.selected_Curves();
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      Delete3D.selected_Groups();
    }

    if ((current_ObjectCategory == ObjectCategory.VERTEX) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.GROUP)) {

      Delete3D.isolatedVertices_Selection();
    }

    Select3D.deselectAll(); // important to deselect
  }

  void selected_Cameras () {

    Select3D.Camera_ids = sort(Select3D.Camera_ids);

    for (int o = Select3D.Camera_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Camera_ids[o];

      {
        float[][] startList = (float[][]) subset(allCameras.options, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allCameras.options, OBJ_ID + 1);

        allCameras.options = (float[][]) concat(startList, endList);
      }

      {
        int[] startList = (int[]) subset(allCameras.Type, 0, OBJ_ID);
        int[] endList = (int[]) subset(allCameras.Type, OBJ_ID + 1);

        allCameras.Type = (int[]) concat(startList, endList);
      }

      allCameras.num -= 1;

      if (OBJ_ID == WIN3D.currentCamera) {

        WIN3D.currentCamera = 0;

        SOLARCHVISION_modify_Viewport_Title();
      }
    }

    if (allCameras.num == 0) {
      allCameras.add_first();
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Sections () {

    Select3D.Section_ids = sort(Select3D.Section_ids);

    for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Section_ids[o];

      {
        float[][] startList = (float[][]) subset(allSections.f_data, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allSections.f_data, OBJ_ID + 1);

        allSections.f_data = (float[][]) concat(startList, endList);
      }

      {
        int[][] startList = (int[][]) subset(allSections.i_data, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allSections.i_data, OBJ_ID + 1);

        allSections.i_data = (int[][]) concat(startList, endList);
      }

      {
        PImage[] startList = (PImage[]) subset(allSections.SolidImpact, 0, OBJ_ID);
        PImage[] endList = (PImage[]) subset(allSections.SolidImpact, OBJ_ID + 1);

        allSections.SolidImpact = (PImage[]) concat(startList, endList);
      }

      {
        PImage[][][] startList = (PImage[][][]) subset(allSections.SolarImpact, 0, OBJ_ID);
        PImage[][][] endList = (PImage[][][]) subset(allSections.SolarImpact, OBJ_ID + 1);

        allSections.SolarImpact = (PImage[][][]) concat(startList, endList);
      }

      allSections.num -= 1;
    }

    SOLARCHVISION_model_changed();
  }





  void selected_Model1Ds () {

    Select3D.Model1D_ids = sort(Select3D.Model1D_ids);

    for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model1D_ids[o];

      for (int q = 0; q < allGroups.num; q++) {

        if ((allGroups.Model1Ds[q][0] <= OBJ_ID) && (OBJ_ID <= allGroups.Model1Ds[q][1])) {
          if (allGroups.Model1Ds[q][1] >= 0) allGroups.Model1Ds[q][1] -= 1;
        } else if (allGroups.Model1Ds[q][0] > OBJ_ID) {
          if (allGroups.Model1Ds[q][0] >= 0) allGroups.Model1Ds[q][0] -= 1;
          if (allGroups.Model1Ds[q][1] >= 0) allGroups.Model1Ds[q][1] -= 1;
        }
      }


      {
        float[][] startList = (float[][]) subset(allModel1Ds.f_data, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allModel1Ds.f_data, OBJ_ID + 1);

        allModel1Ds.f_data = (float[][]) concat(startList, endList);
      }

      {
        int[][] startList = (int[][]) subset(allModel1Ds.i_data, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allModel1Ds.i_data, OBJ_ID + 1);

        allModel1Ds.i_data = (int[][]) concat(startList, endList);
      }

      allModel1Ds.num -= 1;
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Model2Ds () {

    Select3D.Model2D_ids = sort(Select3D.Model2D_ids);

    for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Model2D_ids[o];

      for (int q = 0; q < allGroups.num; q++) {

        if ((allGroups.Model2Ds[q][0] <= OBJ_ID) && (OBJ_ID <= allGroups.Model2Ds[q][1])) {
          if (allGroups.Model2Ds[q][1] >= 0) allGroups.Model2Ds[q][1] -= 1;
        } else if (allGroups.Model2Ds[q][0] > OBJ_ID) {
          if (allGroups.Model2Ds[q][0] >= 0) allGroups.Model2Ds[q][0] -= 1;
          if (allGroups.Model2Ds[q][1] >= 0) allGroups.Model2Ds[q][1] -= 1;
        }
      }


      {
        float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allModel2Ds.XYZS, OBJ_ID + 1);

        allModel2Ds.XYZS = (float[][]) concat(startList, endList);
      }

      {
        int[] startList = (int[]) subset(allModel2Ds.MAP, 0, OBJ_ID);
        int[] endList = (int[]) subset(allModel2Ds.MAP, OBJ_ID + 1);

        allModel2Ds.MAP = (int[]) concat(startList, endList);
      }

      allModel2Ds.num -= 1;
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Solids () {

    Select3D.Solid_ids = sort(Select3D.Solid_ids);

    for (int o = Select3D.Solid_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Solid_ids[o];

      for (int q = 0; q < allGroups.num; q++) {

        if ((allGroups.Solids[q][0] <= OBJ_ID) && (OBJ_ID <= allGroups.Solids[q][1])) {
          if (allGroups.Solids[q][1] >= 0) allGroups.Solids[q][1] -= 1;
        } else if (allGroups.Solids[q][0] > OBJ_ID) {
          if (allGroups.Solids[q][0] >= 0) allGroups.Solids[q][0] -= 1;
          if (allGroups.Solids[q][1] >= 0) allGroups.Solids[q][1] -= 1;
        }
      }


      {
        float[][] startList = (float[][]) subset(allSolids.DEF, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allSolids.DEF, OBJ_ID + 1);

        allSolids.DEF = (float[][]) concat(startList, endList);
      }
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Faces () {

    Select3D.Face_ids = sort(Select3D.Face_ids);

    for (int o = Select3D.Face_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Face_ids[o];

      for (int q = 0; q < allGroups.num; q++) {

        if ((allGroups.Faces[q][0] <= OBJ_ID) && (OBJ_ID <= allGroups.Faces[q][1])) {
          if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
        } else if (allGroups.Faces[q][0] > OBJ_ID) {
          if (allGroups.Faces[q][0] >= 0) allGroups.Faces[q][0] -= 1;
          if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
        }
      }


      {
        int[][] startList = (int[][]) subset(allFaces.nodes, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allFaces.nodes, OBJ_ID + 1);

        allFaces.nodes = (int[][]) concat(startList, endList);
      }

      {
        int[][] startList = (int[][]) subset(allFaces.options, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allFaces.options, OBJ_ID + 1);

        allFaces.options = (int[][]) concat(startList, endList);
      }
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Curves () {

    Select3D.Curve_ids = sort(Select3D.Curve_ids);

    for (int o = Select3D.Curve_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Curve_ids[o];

      for (int q = 0; q < allGroups.num; q++) {

        if ((allGroups.Curves[q][0] <= OBJ_ID) && (OBJ_ID <= allGroups.Curves[q][1])) {
          if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
        } else if (allGroups.Curves[q][0] > OBJ_ID) {
          if (allGroups.Curves[q][0] >= 0) allGroups.Curves[q][0] -= 1;
          if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
        }
      }


      {
        int[][] startList = (int[][]) subset(allCurves.nodes, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allCurves.nodes, OBJ_ID + 1);

        allCurves.nodes = (int[][]) concat(startList, endList);
      }

      {
        int[][] startList = (int[][]) subset(allCurves.options, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allCurves.options, OBJ_ID + 1);

        allCurves.options = (int[][]) concat(startList, endList);
      }
    }

    SOLARCHVISION_model_changed();
  }


  void selected_Groups () {

    /////////////////////////////
    //SOLARCHVISION_hold_project();
    /////////////////////////////

    Select3D.convert_Groups_to_Vertices(); // finding vertices so that we could delete the isolated ones later

    Select3D.Group_ids = sort(Select3D.Group_ids);

    boolean allSolids_updated = false;

    for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = Select3D.Group_ids[o];

      int startFace = allGroups.getStart_Face(OBJ_ID);
      int endFace = allGroups.getStop_Face(OBJ_ID);

      {

        if ((0 <= startFace) && (startFace <= endFace)) {

          for (int i = OBJ_ID + 1; i < allGroups.num; i++) {
            for (int j = 0; j < 2; j++) {
              allGroups.Faces[i][j] -= 1 + endFace - startFace;

              if (allGroups.Faces[i][j] < 0) allGroups.Faces[i][j] = 0;
            }
          }
        }

        int[][] startList = (int[][]) subset(allGroups.Faces, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allGroups.Faces, OBJ_ID + 1);

        allGroups.Faces = (int[][]) concat(startList, endList);
      }

      if ((0 <= startFace) && (startFace <= endFace)) {
        {
          int[][] startList = (int[][]) subset(allFaces.nodes, 0, startFace);
          int[][] endList = (int[][]) subset(allFaces.nodes, endFace + 1);

          allFaces.nodes = (int[][]) concat(startList, endList);
        }

        {
          int[][] startList = (int[][]) subset(allFaces.options, 0, startFace);
          int[][] endList = (int[][]) subset(allFaces.options, endFace + 1);

          allFaces.options = (int[][]) concat(startList, endList);
        }
      }


      int startCurve = allGroups.getStart_Curve(OBJ_ID);
      int endCurve = allGroups.getStop_Curve(OBJ_ID);

      {

        if ((0 <= startCurve) && (startCurve <= endCurve)) {

          for (int i = OBJ_ID + 1; i < allGroups.num; i++) {
            for (int j = 0; j < 2; j++) {
              allGroups.Curves[i][j] -= 1 + endCurve - startCurve;

              if (allGroups.Curves[i][j] < 0) allGroups.Curves[i][j] = 0;
            }
          }
        }

        int[][] startList = (int[][]) subset(allGroups.Curves, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allGroups.Curves, OBJ_ID + 1);

        allGroups.Curves = (int[][]) concat(startList, endList);
      }

      if ((0 <= startCurve) && (startCurve <= endCurve)) {
        {
          int[][] startList = (int[][]) subset(allCurves.nodes, 0, startCurve);
          int[][] endList = (int[][]) subset(allCurves.nodes, endCurve + 1);

          allCurves.nodes = (int[][]) concat(startList, endList);
        }

        {
          int[][] startList = (int[][]) subset(allCurves.options, 0, startCurve);
          int[][] endList = (int[][]) subset(allCurves.options, endCurve + 1);

          allCurves.options = (int[][]) concat(startList, endList);
        }
      }


      int startModel1Ds = allGroups.getStart_Model1D(OBJ_ID);
      int endModel1Ds = allGroups.getStop_Model1D(OBJ_ID);

      {

        if ((0 <= startModel1Ds) && (startModel1Ds <= endModel1Ds)) {

          for (int i = OBJ_ID + 1; i < allGroups.num; i++) {

            for (int j = 0; j < 2; j++) {

              allGroups.Model1Ds[i][j] -= 1 + endModel1Ds - startModel1Ds;

              if (allGroups.Model1Ds[i][j] < 0) allGroups.Model1Ds[i][j] = 0;
            }
          }
        }

        int[][] startList = (int[][]) subset(allGroups.Model1Ds, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allGroups.Model1Ds, OBJ_ID + 1);

        allGroups.Model1Ds = (int[][]) concat(startList, endList);
      }

      if ((0 <= startModel1Ds) && (startModel1Ds <= endModel1Ds)) {

        {
          float[][] startList = (float[][]) subset(allModel1Ds.f_data, 0, startModel1Ds);
          float[][] endList = (float[][]) subset(allModel1Ds.f_data, endModel1Ds + 1);

          allModel1Ds.f_data = (float[][]) concat(startList, endList);
        }

        {
          int[][] startList = (int[][]) subset(allModel1Ds.i_data, 0, startModel1Ds);
          int[][] endList = (int[][]) subset(allModel1Ds.i_data, endModel1Ds + 1);

          allModel1Ds.i_data = (int[][]) concat(startList, endList);
        }

        allModel1Ds.num = allModel1Ds.f_data.length;
      }

      int startModel2Ds = allGroups.getStart_Model2D(OBJ_ID);
      int endModel2Ds = allGroups.getStop_Model2D(OBJ_ID);

      {

        if ((0 <= startModel2Ds) && (startModel2Ds <= endModel2Ds)) {

          for (int i = OBJ_ID + 1; i < allGroups.num; i++) {

            for (int j = 0; j < 2; j++) {

              allGroups.Model2Ds[i][j] -= 1 + endModel2Ds - startModel2Ds;

              if (allGroups.Model2Ds[i][j] < 0) allGroups.Model2Ds[i][j] = 0;
            }
          }
        }

        int[][] startList = (int[][]) subset(allGroups.Model2Ds, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allGroups.Model2Ds, OBJ_ID + 1);

        allGroups.Model2Ds = (int[][]) concat(startList, endList);
      }

      if ((0 <= startModel2Ds) && (startModel2Ds <= endModel2Ds)) {

        {
          float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, startModel2Ds);
          float[][] endList = (float[][]) subset(allModel2Ds.XYZS, endModel2Ds + 1);

          allModel2Ds.XYZS = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allModel2Ds.MAP, 0, startModel2Ds);
          int[] endList = (int[]) subset(allModel2Ds.MAP, endModel2Ds + 1);

          allModel2Ds.MAP = (int[]) concat(startList, endList);
        }

        allModel2Ds.num = allModel2Ds.XYZS.length;
      }

      int startSolid = allGroups.getStart_Solid(OBJ_ID);
      int endSolid = allGroups.getStop_Solid(OBJ_ID);

      {
        if ((0 <= startSolid) && (startSolid <= endSolid)) {
          for (int i = OBJ_ID + 1; i < allGroups.num; i++) {

            for (int j = 0; j < 2; j++) {
              allGroups.Solids[i][j] -= 1 + endSolid - startSolid;

              if (allGroups.Solids[i][j] < 0) allGroups.Solids[i][j] = 0;
            }
          }
        }

        int[][] startList = (int[][]) subset(allGroups.Solids, 0, OBJ_ID);
        int[][] endList = (int[][]) subset(allGroups.Solids, OBJ_ID + 1);

        allGroups.Solids = (int[][]) concat(startList, endList);
      }

      if ((0 <= startSolid) && (startSolid <= endSolid)) {

        float[][] startList = (float[][]) subset(allSolids.DEF, 0, startSolid);
        float[][] endList = (float[][]) subset(allSolids.DEF, endSolid + 1);

        allSolids.DEF = (float[][]) concat(startList, endList);

        allSolids_updated = true;
      }


      {
        float[][] startList = (float[][]) subset(allGroups.Pivots, 0, OBJ_ID);
        float[][] endList = (float[][]) subset(allGroups.Pivots, OBJ_ID + 1);

        allGroups.Pivots = (float[][]) concat(startList, endList);
      }

      allGroups.num -= 1;
    }

    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();

    SOLARCHVISION_model_changed();
  }





  void isolatedVertices_Selection () {

    Select3D.Vertex_ids = sort(Select3D.Vertex_ids);

    for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

      int vNo = Select3D.Vertex_ids[o];

      int found = -1;

      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {

              found = 1;
            }

            if (found != -1) break;
          }

          if (found != -1) break;
        }
      }

      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {

              found = 1;
            }

            if (found != -1) break;
          }

          if (found != -1) break;
        }
      }


      if (found == -1) {

        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {

              allFaces.nodes[i][j] -= 1;
            }
          }
        }

        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {

              allCurves.nodes[i][j] -= 1;
            }
          }
        }

        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);

        allVertices = (float[][]) concat(startList, endList);
      }
    }

    Select3D.deselect_Vertices();

    SOLARCHVISION_model_changed();
  }


  void isolatedVertices_Scene () {

    for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) {

      int found = -1;

      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }

      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }

      if (found == -1) {
        {
          float[][] startList = (float[][]) subset(allVertices, 0, vNo);
          float[][] endList = (float[][]) subset(allVertices, vNo + 1);

          allVertices = (float[][]) concat(startList, endList);
        }

        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {

              allFaces.nodes[i][j] -= 1;
            }
          }
        }

        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {

              allCurves.nodes[i][j] -= 1;
            }
          }
        }
      }


    }

    Select3D.deselect_Vertices();

    SOLARCHVISION_model_changed();
  }

}

solarchvision_Delete3D Delete3D = new solarchvision_Delete3D();















class solarchvision_Select3D {

  private final static String CLASS_STAMP = "Select3D";

  int posVector = 2; // 0:X, 1:Y, 2:Z, 3: All
  int rotVector = 2; // 0:X, 1:Y, 2:Z
  int scaleVector = 2; // 0:X, 1:Y, 2:Z, 3:All

  float posValue = 0;
  float rotValue = 0;
  float scaleValue = 0;

  int alignX = 0;
  int alignY = 0;
  int alignZ = 0;


  boolean displayReferencePivot = true;

  boolean Group_displayPivot = true;
  boolean Group_displayEdges = false;
  boolean Group_displayBox = true;

  boolean Face_displayEdges = true;
  boolean Face_displayVertexCount = false;
  boolean Curve_displayVertexCount = false;
  boolean Vertex_displayVertices = true;
  boolean Curve_displayVertices = true;


  boolean Model2D_displayEdges = true;
  boolean Model1D_displayEdges = true;
  boolean Solid_displayEdges = true;
  boolean Section_displayEdges = true;
  boolean Camera_displayEdges = true;
  boolean LandPoint_displayPoints = true;

  int[] LandPoint_ids = new int[0];
  int[] Camera_ids = new int[0];
  int[] Section_ids = new int[0];
  int[] Solid_ids = new int[0];
  int[] Model1D_ids = new int[0];
  int[] Model2D_ids = new int[0];
  int[] Group_ids = new int[0];
  int[] Face_ids = new int[0];
  int[] Vertex_ids = new int[0];
  int[] Curve_ids = new int[0];

  int[] softSelection_ids = new int[0];
  float[] softSelection_values = new float[0];

  float softPower = 1;
  float softRadius = 2; // 2 = 2m


  float[][] BoundingBox = {
    {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
    , {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
    , {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
  }; // [min|mid|max]






  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Face_ids.length][7];

    for (int o = 0; o < this.Face_ids.length; o++) {
      hitPoint[o][0] = FLOAT_undefined;
      hitPoint[o][1] = FLOAT_undefined;
      hitPoint[o][2] = FLOAT_undefined;
      hitPoint[o][3] = FLOAT_undefined;
      hitPoint[o][4] = FLOAT_undefined;
      hitPoint[o][5] = FLOAT_undefined;
      hitPoint[o][6] = FLOAT_undefined;
    }


    for (int o = 0; o < this.Face_ids.length; o++) {

      int f = this.Face_ids[o];

      if (f > 0) {

        int n = allFaces.nodes[f].length;

        if (n > 2) {

          int vsb = allFaces.getVisibility(f);

          if (vsb > 0) {

            float X_intersect = FLOAT_undefined;
            float Y_intersect = FLOAT_undefined;
            float Z_intersect = FLOAT_undefined;
            float dist2intersect = FLOAT_undefined;
            float[] face_norm = {0,0,0};

            boolean InPoly = false;

            if (n < 5) { // works if n==3 or n==4

              float[] A = allPoints.getPosition(allFaces.nodes[f][0]);
              float[] B = allPoints.getPosition(allFaces.nodes[f][1]);
              float[] C = allPoints.getPosition(allFaces.nodes[f][n - 2]);
              float[] D = allPoints.getPosition(allFaces.nodes[f][n - 1]);

              float[] AC = funcs.vec3_diff(A, C);
              float[] BD = funcs.vec3_diff(B, D);

              face_norm = funcs.vec3_cross(AC, BD);

              float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] +
                                          (A[1] + B[1] + C[1] + D[1]) * face_norm[1] +
                                          (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

              float R = -funcs.vec3_dot(ray_dir, face_norm);

              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {

                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                  float[] P = {X_intersect, Y_intersect, Z_intersect};

                  if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                  else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

                }
              }
            }
            else {

              int[] tmpFace = new int[n];
              float[] G = {
                0, 0, 0
              };
              for (int j = 0; j < n; j++) {
                tmpFace[j] = allFaces.nodes[f][j];
                G[0] += allPoints.getX(tmpFace[j]) / float(n);
                G[1] += allPoints.getY(tmpFace[j]) / float(n);
                G[2] += allPoints.getZ(tmpFace[j]) / float(n);
              }

              for (int j = 0; j < n; j++) {

                int j_next = (j + 1) % n;

                float[] A = {
                  allPoints.getX(allFaces.nodes[f][j]),
                  allPoints.getY(allFaces.nodes[f][j]),
                  allPoints.getZ(allFaces.nodes[f][j])
                };

                float[] B = {
                  allPoints.getX(allFaces.nodes[f][j_next]),
                  allPoints.getY(allFaces.nodes[f][j_next]),
                  allPoints.getZ(allFaces.nodes[f][j_next])
                };

                float[] AG = funcs.vec3_diff(A, G);
                float[] BG = funcs.vec3_diff(B, G);

                face_norm = funcs.vec3_cross(AG, BG);

                float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] +
                                                   (A[1] + B[1] + G[1]) * face_norm[1] +
                                                   (A[2] + B[2] + G[2]) * face_norm[2]);

                float R = -funcs.vec3_dot(ray_dir, face_norm);

                if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                  dist2intersect = FLOAT_huge;
                }
                else {
                  dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

                  //if (dist2intersect > 0) {
                  if (dist2intersect > FLOAT_tiny) {

                    X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                    Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                    Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                    float[] P = {X_intersect, Y_intersect, Z_intersect};

                    InPoly = funcs.isInside_Triangle(P, A, B, G);

                  }
                }

                if (InPoly) break;
              }
            }

            if (InPoly) {
              hitPoint[f][0] = X_intersect;
              hitPoint[f][1] = Y_intersect;
              hitPoint[f][2] = Z_intersect;
              hitPoint[f][3] = dist2intersect;
              hitPoint[f][4] = face_norm[0];
              hitPoint[f][5] = face_norm[1];
              hitPoint[f][6] = face_norm[2];
            }

          }
        }
      }
    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int o = 0; o < this.Face_ids.length; o++) {

      if (pre_dist > hitPoint[o][3]) {

        pre_dist = hitPoint[o][3];

        return_point[0] = o;
        return_point[1] = hitPoint[o][0];
        return_point[2] = hitPoint[o][1];
        return_point[3] = hitPoint[o][2];
        return_point[4] = hitPoint[o][3];
        return_point[5] = hitPoint[o][4];
        return_point[6] = hitPoint[o][5];
        return_point[7] = hitPoint[o][6];

      }

    }

    return return_point;
  }


  private boolean update_BoundingBox = true; // internal

  void revise_BoundingBox () {
    this.update_BoundingBox = true;
  }

  void calculate_BoundingBox () {

    this.update_BoundingBox = false;

    int keep_selection_alignX = this.alignX;
    int keep_selection_alignY = this.alignY;
    int keep_selection_alignZ = this.alignZ;

    this.alignX = 0; // apply the centre
    this.alignY = 0; // apply the centre
    this.alignZ = 0; // apply the centre

    int[] theVertices = new int [0];

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      theVertices = this.Camera_ids;
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      theVertices = this.Section_ids;
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      theVertices = this.Solid_ids;
    }

    if ((current_ObjectCategory == ObjectCategory.VERTEX) ||
        (current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {

      theVertices = this.Vertex_ids;
    }
    if (current_ObjectCategory == ObjectCategory.FACE) {
      theVertices = this.get_Face_Vertices();
    }
    if (current_ObjectCategory == ObjectCategory.CURVE) {
      theVertices = this.get_Curve_Vertices();
    }
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      theVertices = this.get_Group_Vertices();
    }
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      theVertices = this.Model2D_ids;
    }
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      theVertices = this.Model1D_ids;
    }
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      theVertices = this.LandPoint_ids;
    }

    float posX = 0;
    float posY = 0;
    float posZ = 0;

    float scaleX = 1;
    float scaleY = 1;
    float scaleZ = 1;

    float rotX = 0;
    float rotY = 0;
    float rotZ = 0;

    if (current_ObjectCategory == ObjectCategory.GROUP) {

      if (this.Group_ids.length > 0) {

        for (int o = 0; o < this.Group_ids.length - 1; o++) {

          int OBJ_ID = this.Group_ids[o];

          posX += allGroups.Pivots[OBJ_ID][0] / this.Group_ids.length;
          posY += allGroups.Pivots[OBJ_ID][1] / this.Group_ids.length;
          posZ += allGroups.Pivots[OBJ_ID][2] / this.Group_ids.length;

        }
      }
    }


    for (int i = 0; i < 3; i++) {
      float ratio = 0.5 * i;
      this.BoundingBox[i][0] = posX;
      this.BoundingBox[i][1] = posY;
      this.BoundingBox[i][2] = posZ;

      this.BoundingBox[i][3] = scaleX;
      this.BoundingBox[i][4] = scaleY;
      this.BoundingBox[i][5] = scaleZ;

      this.BoundingBox[i][6] = rotX;
      this.BoundingBox[i][7] = rotY;
      this.BoundingBox[i][8] = rotZ;
    }


    float posX_min = FLOAT_undefined;
    float posY_min = FLOAT_undefined;
    float posZ_min = FLOAT_undefined;

    float posX_max = -FLOAT_undefined;
    float posY_max = -FLOAT_undefined;
    float posZ_max = -FLOAT_undefined;



    for (int q = 0; q < theVertices.length; q++) {

      float x = 0;
      float y = 0;
      float z = 0;

      if (current_ObjectCategory == ObjectCategory.CAMERA) {
        int n = theVertices[q];

        if (n < allCameras.num) {

          float Camera_pX = allCameras.get_posX(n);
          float Camera_pY = allCameras.get_posY(n);
          float Camera_pZ = allCameras.get_posZ(n);
          float Camera_pT = allCameras.get_posT(n);
          float Camera_rX = allCameras.get_rotX(n);
          float Camera_rY = allCameras.get_rotY(n);
          float Camera_rZ = allCameras.get_rotZ(n);
          float Camera_rT = allCameras.get_rotT(n);
          float Camera_zoom = allCameras.get_zoom(n);
          int   Camera_type = allCameras.get_type(n);

          float[][] ImageVertex = allCameras.getCorners(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_zoom);

          // the first vertex is the Camera point
          x = ImageVertex[0][0];
          y = ImageVertex[0][1];
          z = ImageVertex[0][2];
        }
      }

      if (current_ObjectCategory == ObjectCategory.SECTION) {
        int n = theVertices[q];

        if (n < allSections.num) {

          float Section_X = allSections.getX(n);
          float Section_Y = allSections.getY(n);
          float Section_Z = allSections.getZ(n);
          float Section_R = allSections.getR(n);
          float Section_U = allSections.getU(n);
          float Section_V = allSections.getV(n);

          int Section_Type = allSections.get_type(n);
          int Section_RES1 = allSections.get_res1(n);
          int Section_RES2 = allSections.get_res2(n);

          float[][] ImageVertex = allSections.getCorners(Section_Type, Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_RES1, Section_RES2);

          // the first vertex is the center of Section plane
          x = ImageVertex[0][0];
          y = ImageVertex[0][1];
          z = ImageVertex[0][2];
        }
      }

      if (current_ObjectCategory == ObjectCategory.SOLID) {
        int n = theVertices[q];

        if (n < allSolids.DEF.length) {

          float Solid_posX = allSolids.get_posX(n);
          float Solid_posY = allSolids.get_posY(n);
          float Solid_posZ = allSolids.get_posZ(n);
          float Solid_powX = allSolids.get_powX(n);
          float Solid_powY = allSolids.get_powY(n);
          float Solid_powZ = allSolids.get_powZ(n);
          float Solid_scaleX = allSolids.get_scaleX(n);
          float Solid_scaleY = allSolids.get_scaleY(n);
          float Solid_scaleZ = allSolids.get_scaleZ(n);
          float Solid_rotX = allSolids.get_rotX(n);
          float Solid_rotY = allSolids.get_rotY(n);
          float Solid_rotZ = allSolids.get_rotZ(n);
          float Solid_value = allSolids.get_value(n);

          float[][] ImageVertex = allSolids.getCorners(0, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

          // the first vertex is the center of Solid plane
          x = ImageVertex[0][0];
          y = ImageVertex[0][1];
          z = ImageVertex[0][2];
        }
      }


      if ((current_ObjectCategory == ObjectCategory.GROUP) ||
          (current_ObjectCategory == ObjectCategory.FACE) ||
          (current_ObjectCategory == ObjectCategory.CURVE) ||
          (current_ObjectCategory == ObjectCategory.VERTEX) ||
          (current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {

        int n = theVertices[q];

        x = allPoints.getX(n);
        y = allPoints.getY(n);
        z = allPoints.getZ(n);
      }
      if (current_ObjectCategory == ObjectCategory.MODEL2D) {
        int n = theVertices[q];

        x = allModel2Ds.getX(n);
        y = allModel2Ds.getY(n);
        z = allModel2Ds.getZ(n);
      }
      if (current_ObjectCategory == ObjectCategory.MODEL1D) {
        int n = theVertices[q];

        x = allModel1Ds.getX(n);
        y = allModel1Ds.getY(n);
        z = allModel1Ds.getZ(n);
      }
      if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
        int n = theVertices[q];

        int OBJ_ID = n;

        int the_i = OBJ_ID / Land3D.num_columns;
        int the_j = OBJ_ID % Land3D.num_columns;

        x = Land3D.Mesh[the_i][the_j][0];
        y = Land3D.Mesh[the_i][the_j][1];
        z = Land3D.Mesh[the_i][the_j][2];

      }




      float[] A = this.translateOutside_ReferencePivot(x, y, z);

      x = A[0];
      y = A[1];
      z = A[2];


      if (posX_min > x) posX_min = x;
      if (posY_min > y) posY_min = y;
      if (posZ_min > z) posZ_min = z;

      if (posX_max < x) posX_max = x;
      if (posY_max < y) posY_max = y;
      if (posZ_max < z) posZ_max = z;
    }

    if (is_defined(posX_min) &&
        is_defined(posY_min) &&
        is_defined(posZ_min) &&
        is_defined(-posX_max) &&
        is_defined(-posY_max) &&
        is_defined(-posZ_max)) {

      float dx = posX;
      float dy = posY;
      float dz = posZ;

      posX_min += dx;
      posY_min += dy;
      posZ_min += dz;

      posX_max += dx;
      posY_max += dy;
      posZ_max += dz;

      for (int i = 0; i < 3; i++) {
        float ratio = 0.5 * i;
        this.BoundingBox[i][0] = (1 - ratio) * posX_min + ratio * posX_max;
        this.BoundingBox[i][1] = (1 - ratio) * posY_min + ratio * posY_max;
        this.BoundingBox[i][2] = (1 - ratio) * posZ_min + ratio * posZ_max;

        this.BoundingBox[i][3] = scaleX;
        this.BoundingBox[i][4] = scaleY;
        this.BoundingBox[i][5] = scaleZ;

        this.BoundingBox[i][6] = rotX;
        this.BoundingBox[i][7] = rotY;
        this.BoundingBox[i][8] = rotZ;
      }
    }



    this.alignX = keep_selection_alignX;
    this.alignY = keep_selection_alignY;
    this.alignZ = keep_selection_alignZ;
  }



  void save_current_BoundingBox () {

    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 9; j++) {
        saved_BoundingBox[i][j] = this.BoundingBox[i][j];
      }
    }

    saved_alignX = this.alignX;
    saved_alignY = this.alignY;
    saved_alignZ = this.alignZ;
  }


  void apply_saved_BoundingBox () {

    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 9; j++) {
        this.BoundingBox[i][j] = saved_BoundingBox[i][j];
      }
    }

    this.alignX = saved_alignX;
    this.alignY = saved_alignY;
    this.alignZ = saved_alignZ;
  }


  void apply_origin_ReferenceBox () {

    for (int i = 0; i < 3; i++) {
      this.BoundingBox[i][0] = 0;
      this.BoundingBox[i][1] = 0;
      this.BoundingBox[i][2] = 0;
      this.BoundingBox[i][3] = 1;
      this.BoundingBox[i][4] = 1;
      this.BoundingBox[i][5] = 1;
      this.BoundingBox[i][6] = 0;
      this.BoundingBox[i][7] = 0;
      this.BoundingBox[i][8] = 0;
    }

    //this.alignX = 0;
    //this.alignY = 0;
    //this.alignZ = 0;
  }




  void reset_selectedRefValues () {

    this.posValue = 0;
    this.rotValue = 0;
    this.scaleValue = 0;
  }




  float[] translateInside_ReferencePivot (float a, float b, float c) {


    float rotX = this.BoundingBox[1 + this.alignX][6];
    float rotY = this.BoundingBox[1 + this.alignY][7];
    float rotZ = this.BoundingBox[1 + this.alignZ][8];

    float y1 = b * funcs.cos_ang(rotX) - c * funcs.sin_ang(rotX);
    float z1 = b * funcs.sin_ang(rotX) + c * funcs.cos_ang(rotX);
    float x1 = a;

    a = x1;
    b = y1;
    c = z1;

    float z2 = c * funcs.cos_ang(rotY) - a * funcs.sin_ang(rotY);
    float x2 = c * funcs.sin_ang(rotY) + a * funcs.cos_ang(rotY);
    float y2 = b;

    a = x2;
    b = y2;
    c = z2;

    float x = a * funcs.cos_ang(rotZ) - b * funcs.sin_ang(rotZ);
    float y = a * funcs.sin_ang(rotZ) + b * funcs.cos_ang(rotZ);
    float z = c;

    x *= this.BoundingBox[1 + this.alignX][3];
    y *= this.BoundingBox[1 + this.alignY][4];
    z *= this.BoundingBox[1 + this.alignZ][5];

    x += this.BoundingBox[1 + this.alignX][0];
    y += this.BoundingBox[1 + this.alignY][1];
    z += this.BoundingBox[1 + this.alignZ][2];

    float[] return_array = {
      x, y, z
    };

    return return_array;
  }



  float[] translateOutside_ReferencePivot (float a, float b, float c) {

    a -= this.BoundingBox[1 + this.alignX][0];
    b -= this.BoundingBox[1 + this.alignY][1];
    c -= this.BoundingBox[1 + this.alignZ][2];

    a /= this.BoundingBox[1 + this.alignX][3];
    b /= this.BoundingBox[1 + this.alignY][4];
    c /= this.BoundingBox[1 + this.alignZ][5];



    float rotX = this.BoundingBox[1 + this.alignX][6];
    float rotY = this.BoundingBox[1 + this.alignY][7];
    float rotZ = this.BoundingBox[1 + this.alignZ][8];

    float x1 = a * funcs.cos_ang(-rotZ) - b * funcs.sin_ang(-rotZ);
    float y1 = a * funcs.sin_ang(-rotZ) + b * funcs.cos_ang(-rotZ);
    float z1 = c;

    a = x1;
    b = y1;
    c = z1;

    float z2 = c * funcs.cos_ang(-rotY) - a * funcs.sin_ang(-rotY);
    float x2 = c * funcs.sin_ang(-rotY) + a * funcs.cos_ang(-rotY);
    float y2 = b;

    a = x2;
    b = y2;
    c = z2;

    float y = b * funcs.cos_ang(-rotX) - c * funcs.sin_ang(-rotX);
    float z = b * funcs.sin_ang(-rotX) + c * funcs.cos_ang(-rotX);
    float x = a;


    float[] return_array = {
      x, y, z
    };

    return return_array;
  }




  float[] getPivot () {

    float posX = this.BoundingBox[1][0];
    float posY = this.BoundingBox[1][1];
    float posZ = this.BoundingBox[1][2];

    float x = this.BoundingBox[1 + this.alignX][0];
    float y = this.BoundingBox[1 + this.alignY][1];
    float z = this.BoundingBox[1 + this.alignZ][2];

    {
      int keep_selection_alignX = this.alignX;
      int keep_selection_alignY = this.alignY;
      int keep_selection_alignZ = this.alignZ;

      this.alignX = 0; // apply the centre
      this.alignY = 0; // apply the centre
      this.alignZ = 0; // apply the centre

      float[] A = this.translateInside_ReferencePivot(x - posX, y - posY, z - posZ);

      x = A[0];
      y = A[1];
      z = A[2];

      this.alignX = keep_selection_alignX;
      this.alignY = keep_selection_alignY;
      this.alignZ = keep_selection_alignZ;
    }

    float[] return_array = {
      x, y, z
    };

    return return_array;
  }



  void selectPick (float[] RxP) {

    if (addNewSelectionToPreviousSelection == 0) this.deselectAll();


    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.LandPoint_ids.length - 1; o >= 0; o--) {
          if (this.LandPoint_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.LandPoint_ids, 0, found_at);
        int[] endList = (int[]) subset(this.LandPoint_ids, found_at + 1);

        this.LandPoint_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.LandPoint_ids = (int[]) concat(this.LandPoint_ids, newObject_id);
      }
    }


    if (current_ObjectCategory == ObjectCategory.MODEL1D) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
          if (this.Model1D_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Model1D_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Model1D_ids, found_at + 1);

        this.Model1D_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Model1D_ids = (int[]) concat(this.Model1D_ids, newObject_id);
      }
    }


    if (current_ObjectCategory == ObjectCategory.MODEL2D) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
          if (this.Model2D_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Model2D_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Model2D_ids, found_at + 1);

        this.Model2D_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Model2D_ids = (int[]) concat(this.Model2D_ids, newObject_id);
      }
    }


    if (current_ObjectCategory == ObjectCategory.GROUP) {

      int f = int(RxP[0]);

      int OBJ_ID = 0;

      for (int i = 0; i < allGroups.num; i++) {
        if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
          OBJ_ID = i;
          break;
        }
      }

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Group_ids.length - 1; o >= 0; o--) {
          if (this.Group_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Group_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Group_ids, found_at + 1);

        this.Group_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Group_ids = (int[]) concat(this.Group_ids, newObject_id);
      }
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Face_ids.length - 1; o >= 0; o--) {
          if (this.Face_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Face_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Face_ids, found_at + 1);

        this.Face_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Face_ids = (int[]) concat(this.Face_ids, newObject_id);
      }
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
          if (this.Curve_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Curve_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Curve_ids, found_at + 1);

        this.Curve_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Curve_ids = (int[]) concat(this.Curve_ids, newObject_id);
      }
    }


    if (current_ObjectCategory == ObjectCategory.VERTEX) {

      int f = int(RxP[0]);

      int OBJ_ID = 0;
      float min_dist = FLOAT_undefined;

      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];

        float x = allPoints.getX(vNo);
        float y = allPoints.getY(vNo);
        float z = allPoints.getZ(vNo);

        float now_dist = dist(x, y, z, RxP[1], RxP[2], RxP[3]);

        if (min_dist > now_dist) {
          min_dist = now_dist;
          OBJ_ID = vNo;
        }
      }


      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Vertex_ids.length - 1; o >= 0; o--) {
          if (this.Vertex_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Vertex_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Vertex_ids, found_at + 1);

        this.Vertex_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Vertex_ids = (int[]) concat(this.Vertex_ids, newObject_id);
      }
    }



    if (current_ObjectCategory == ObjectCategory.SOLID) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Solid_ids.length - 1; o >= 0; o--) {
          if (this.Solid_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Solid_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Solid_ids, found_at + 1);

        this.Solid_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Solid_ids = (int[]) concat(this.Solid_ids, newObject_id);
      }
    }



    if (current_ObjectCategory == ObjectCategory.SECTION) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Section_ids.length - 1; o >= 0; o--) {
          if (this.Section_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Section_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Section_ids, found_at + 1);

        this.Section_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Section_ids = (int[]) concat(this.Section_ids, newObject_id);
      }
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {

      int OBJ_ID = int(RxP[0]);

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = this.Camera_ids.length - 1; o >= 0; o--) {
          if (this.Camera_ids[o] == OBJ_ID) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Camera_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Camera_ids, found_at + 1);

        this.Camera_ids = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_ID
        };

        this.Camera_ids = (int[]) concat(this.Camera_ids, newObject_id);
      }

    }


    SOLARCHVISION_selection_changed();
  }


  void selectRect (float corner1x, float corner1y, float corner2x, float corner2y) {

    if (addNewSelectionToPreviousSelection == 0) this.deselectAll();


    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {

      for (int OBJ_ID = 0; OBJ_ID < Land3D.num_rows * Land3D.num_columns; OBJ_ID++) {

        int i = OBJ_ID / Land3D.num_columns;
        int j = OBJ_ID % Land3D.num_columns;

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int k = 0; k < 1; k++) { // just a loop to make those break commands relevant!

          float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
          float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
          float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }
        }



        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.LandPoint_ids.length - 1; o >= 0; o--) {
              if (this.LandPoint_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.LandPoint_ids, 0, found_at);
            int[] endList = (int[]) subset(this.LandPoint_ids, found_at + 1);

            this.LandPoint_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.LandPoint_ids = (int[]) concat(this.LandPoint_ids, newObject_id);
          }
        }
      }
    }



    if (current_ObjectCategory == ObjectCategory.MODEL1D) {

      for (int OBJ_ID = 0; OBJ_ID < allModel1Ds.Faces.length; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        int f = OBJ_ID;

        for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

          int vNo = allModel1Ds.Faces[f][j];

          float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
          float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
              if (this.Model1D_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Model1D_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Model1D_ids, found_at + 1);

            this.Model1D_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Model1D_ids = (int[]) concat(this.Model1D_ids, newObject_id);
          }
        }
      }
    }



    if (current_ObjectCategory == ObjectCategory.GROUP) {

      for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (allGroups.getStart_Face(OBJ_ID) <= allGroups.getStop_Face(OBJ_ID)) {

          if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
          if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

          for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {
            if ((0 <= f) && (f < allFaces.nodes.length)) {

              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                int vNo = allFaces.nodes[f][j];

                float x = allPoints.getX(vNo) * OBJECTS_scale;
                float y = allPoints.getY(vNo) * OBJECTS_scale;
                float z = -allPoints.getZ(vNo) * OBJECTS_scale;

                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
                    if (mouseButton == RIGHT) {
                      include_OBJ_in_newSelection = 1;
                      break_loops = 1;
                    }
                  } else {
                    if (mouseButton == LEFT) {
                      include_OBJ_in_newSelection = 0;
                      break_loops = 1;
                    }
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }

                if (break_loops == 1) break;
              }

              if (break_loops == 1) break;
            }
          }
        }

        if (allGroups.getStart_Curve(OBJ_ID) <= allGroups.getStop_Curve(OBJ_ID)) {

          if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
          if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

          for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {
            if ((0 <= f) && (f < allCurves.nodes.length)) {

              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                int vNo = allCurves.nodes[f][j];

                float x = allPoints.getX(vNo) * OBJECTS_scale;
                float y = allPoints.getY(vNo) * OBJECTS_scale;
                float z = -allPoints.getZ(vNo) * OBJECTS_scale;

                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
                    if (mouseButton == RIGHT) {
                      include_OBJ_in_newSelection = 1;
                      break_loops = 1;
                    }
                  } else {
                    if (mouseButton == LEFT) {
                      include_OBJ_in_newSelection = 0;
                      break_loops = 1;
                    }
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }

                if (break_loops == 1) break;
              }

              if (break_loops == 1) break;
            }
          }
        }

        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Group_ids.length - 1; o >= 0; o--) {
              if (this.Group_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Group_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Group_ids, found_at + 1);

            this.Group_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Group_ids = (int[]) concat(this.Group_ids, newObject_id);
          }
        }
      }
    }


    if (current_ObjectCategory == ObjectCategory.FACE) {

      for (int OBJ_ID = 0; OBJ_ID < allFaces.nodes.length; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int j = 0; j < allFaces.nodes[OBJ_ID].length; j++) {
          int vNo = allFaces.nodes[OBJ_ID][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }



        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Face_ids.length - 1; o >= 0; o--) {
              if (this.Face_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Face_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Face_ids, found_at + 1);

            this.Face_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Face_ids = (int[]) concat(this.Face_ids, newObject_id);
          }
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {

      for (int OBJ_ID = 0; OBJ_ID < allCurves.nodes.length; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int j = 0; j < allCurves.nodes[OBJ_ID].length; j++) {
          int vNo = allCurves.nodes[OBJ_ID][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }



        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
              if (this.Curve_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Curve_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Curve_ids, found_at + 1);

            this.Curve_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Curve_ids = (int[]) concat(this.Curve_ids, newObject_id);
          }
        }
      }
    }


    if (current_ObjectCategory == ObjectCategory.VERTEX) {

      for (int OBJ_ID = 0; OBJ_ID < allPoints.getLength(); OBJ_ID++) {

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        float x = allPoints.getX(OBJ_ID) * OBJECTS_scale;
        float y = allPoints.getY(OBJ_ID) * OBJECTS_scale;
        float z = -allPoints.getZ(OBJ_ID) * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
            }
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
          }
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Vertex_ids.length - 1; o >= 0; o--) {
              if (this.Vertex_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Vertex_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Vertex_ids, found_at + 1);

            this.Vertex_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Vertex_ids = (int[]) concat(this.Vertex_ids, newObject_id);
          }
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {

      for (int f = 0; f < allModel2Ds.Faces.length; f++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        int OBJ_ID = f / allModel2Ds.num_visualFaces;

        //println(f, OBJ_ID);

        for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

          int vNo = allModel2Ds.Faces[f][j];

          float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
          float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
              if (this.Model2D_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }


          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Model2D_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Model2D_ids, found_at + 1);

            this.Model2D_ids = (int[]) concat(startList, endList);
          }



          if (use_it == 1) {

            int[] newObject_id = {
              OBJ_ID
            };

            this.Model2D_ids = (int[]) concat(this.Model2D_ids, newObject_id);

            // skip the same object's drawn faces
            f += allModel2Ds.num_visualFaces - (f % allModel2Ds.num_visualFaces) - 1;
          }
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {

      for (int f = 0; f < allSolids.Faces.length; f++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        int OBJ_ID = f / allSolids.num_visualFaces;

        //println(f, OBJ_ID);

        for (int j = 0; j < allSolids.Faces[f].length; j++) {

          int vNo = allSolids.Faces[f][j];

          float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
          float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Solid_ids.length - 1; o >= 0; o--) {
              if (this.Solid_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }


          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Solid_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Solid_ids, found_at + 1);

            this.Solid_ids = (int[]) concat(startList, endList);
          }



          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Solid_ids = (int[]) concat(this.Solid_ids, newObject_id);

            // skip the same object's drawn faces
            f += allSolids.num_visualFaces - (f % allSolids.num_visualFaces) - 1;
          }
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {

      for (int OBJ_ID = 0; OBJ_ID < allSections.Faces.length; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        int f = OBJ_ID;

        for (int j = 0; j < allSections.Faces[f].length; j++) {

          int vNo = allSections.Faces[f][j];

          float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
          float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Section_ids.length - 1; o >= 0; o--) {
              if (this.Section_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Section_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Section_ids, found_at + 1);

            this.Section_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Section_ids = (int[]) concat(this.Section_ids, newObject_id);
          }
        }
      }
    }


    if (current_ObjectCategory == ObjectCategory.CAMERA) {

      for (int OBJ_ID = 0; OBJ_ID < allCameras.Faces.length; OBJ_ID++) {

        int break_loops = 0;

        int include_OBJ_in_newSelection = -1;

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        int f = OBJ_ID;

        for (int j = 0; j < allCameras.Faces[f].length; j++) {

          int vNo = allCameras.Faces[f][j];

          float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
          float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y)) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }

            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        }


        if (include_OBJ_in_newSelection == 1) {

          int found_at = -1;

          int use_it = 0; // 0:nothing 1:add -1:subtract

          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;

          if (addNewSelectionToPreviousSelection != 0) {

            for (int o = this.Camera_ids.length - 1; o >= 0; o--) {
              if (this.Camera_ids[o] == OBJ_ID) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }

          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Camera_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Camera_ids, found_at + 1);

            this.Camera_ids = (int[]) concat(startList, endList);
          }

          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_ID
            };

            this.Camera_ids = (int[]) concat(this.Camera_ids, newObject_id);
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }





  void deselect_LandPoints () {
    this.LandPoint_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Vertices () {
    this.Vertex_ids = new int [0];

    this.deselect_softSelection();

    SOLARCHVISION_selection_changed();
  }

  void deselect_softSelection () {
    this.softSelection_ids = new int [0];
    this.softSelection_values = new float [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Faces () {
    this.Face_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Curves () {
    this.Curve_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Solids () {
    this.Solid_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Cameras () {
    this.Camera_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Sections () {
    this.Section_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Model1Ds () {
    this.Model1D_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }


  void deselect_Model2Ds () {
    this.Model2D_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }

  void deselect_Groups () {
    this.Group_ids = new int [0];

    SOLARCHVISION_selection_changed();
  }


  void deselectAll () {

    this.deselect_LandPoints();
    this.deselect_Cameras();
    this.deselect_Sections();
    this.deselect_Solids();
    this.deselect_Model1Ds();
    this.deselect_Model2Ds();
    this.deselect_Faces();
    this.deselect_Curves();
    this.deselect_Vertices();
    this.deselect_Groups();

    SOLARCHVISION_selection_changed();
  }

  void selectAll () {

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      this.LandPoint_ids = new int [Land3D.num_rows * Land3D.num_columns];
      for (int i = 0; i < this.LandPoint_ids.length; i++) {
        this.LandPoint_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1D_ids = new int [allModel1Ds.num];
      for (int i = 0; i < this.Model1D_ids.length; i++) {
        this.Model1D_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2D_ids = new int [allModel2Ds.num];
      for (int i = 0; i < this.Model2D_ids.length; i++) {
        this.Model2D_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Group_ids = new int [allGroups.num];
      for (int i = 0; i < this.Group_ids.length; i++) {
        this.Group_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Face_ids = new int [allFaces.nodes.length];
      for (int i = 0; i < this.Face_ids.length; i++) {
        this.Face_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      this.Vertex_ids = new int [allPoints.getLength()];
      for (int i = 0; i < this.Vertex_ids.length; i++) {
        this.Vertex_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curve_ids = new int [allCurves.nodes.length];
      for (int i = 0; i < this.Curve_ids.length; i++) {
        this.Curve_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solid_ids = new int [allSolids.DEF.length];
      for (int i = 0; i < this.Solid_ids.length; i++) {
        this.Solid_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Section_ids = new int [allSections.num];
      for (int i = 0; i < this.Section_ids.length; i++) {
        this.Section_ids[i] = i;
      }
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Camera_ids = new int [allCameras.num];
      for (int i = 0; i < this.Camera_ids.length; i++) {
        this.Camera_ids[i] = i;
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void invertSelection () {

    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      int[] pre_Selection_LandPoint_ids = sort(this.LandPoint_ids);

      this.LandPoint_ids = new int [0];

      for (int i = 0; i < Land3D.num_rows * Land3D.num_columns; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_LandPoint_ids.length; j++) {

          if (pre_Selection_LandPoint_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_LandPoint_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.LandPoint_ids = concat(this.LandPoint_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      int[] pre_Selection_Model1D_ids = sort(this.Model1D_ids);

      this.Model1D_ids = new int [0];

      for (int i = 0; i < allModel1Ds.num; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Model1D_ids.length; j++) {

          if (pre_Selection_Model1D_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Model1D_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Model1D_ids = concat(this.Model1D_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      int[] pre_Selection_Model2D_ids = sort(this.Model2D_ids);

      this.Model2D_ids = new int [0];

      for (int i = 0; i < allModel2Ds.num; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Model2D_ids.length; j++) {

          if (pre_Selection_Model2D_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Model2D_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Model2D_ids = concat(this.Model2D_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      int[] pre_Selection_Group_ids = sort(this.Group_ids);

      this.Group_ids = new int [0];

      for (int i = 0; i < allGroups.num; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Group_ids.length; j++) {

          if (pre_Selection_Group_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Group_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Group_ids = concat(this.Group_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      int[] pre_Selection_Face_ids = sort(this.Face_ids);

      this.Face_ids = new int [0];

      for (int i = 0; i < allFaces.nodes.length; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Face_ids.length; j++) {

          if (pre_Selection_Face_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Face_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Face_ids = concat(this.Face_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {
      int[] pre_Selection_Curve_ids = sort(this.Curve_ids);

      this.Curve_ids = new int [0];

      for (int i = 0; i < allCurves.nodes.length; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Curve_ids.length; j++) {

          if (pre_Selection_Curve_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Curve_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Curve_ids = concat(this.Curve_ids, new_Item);
        }
      }
    }


    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      int[] pre_Selection_Vertex_ids = sort(this.Vertex_ids);

      this.Vertex_ids = new int [0];

      for (int i = 0; i < allPoints.getLength(); i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Vertex_ids.length; j++) {

          if (pre_Selection_Vertex_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Vertex_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Vertex_ids = concat(this.Vertex_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      int[] pre_Selection_Solid_ids = sort(this.Solid_ids);

      this.Solid_ids = new int [0];

      for (int i = 0; i < allSolids.DEF.length; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Solid_ids.length; j++) {

          if (pre_Selection_Solid_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Solid_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Solid_ids = concat(this.Solid_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      int[] pre_Selection_Section_ids = sort(this.Section_ids);

      this.Section_ids = new int [0];

      for (int i = 0; i < allSections.num; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Section_ids.length; j++) {

          if (pre_Selection_Section_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Section_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Section_ids = concat(this.Section_ids, new_Item);
        }
      }
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      int[] pre_Selection_Camera_ids = sort(this.Camera_ids);

      this.Camera_ids = new int [0];

      for (int i = 0; i < allCameras.num; i++) {
        int found = -1;

        for (int j = 0; j < pre_Selection_Camera_ids.length; j++) {

          if (pre_Selection_Camera_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Camera_ids[j] > i) {
            break;
          }
        }

        if (found == -1) {
          int[] new_Item = {
            i
          };

          this.Camera_ids = concat(this.Camera_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }









  void selectLast () {

    if (current_ObjectCategory == ObjectCategory.SECTION) {
      this.Section_ids = new int [0];

      if (allSections.num > 0) {
        int[] new_Item = {allSections.num - 1};
        this.Section_ids = concat(this.Section_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      this.Camera_ids = new int [0];

      if (allCameras.num > 0) {
        int[] new_Item = {allCameras.num - 1};
        this.Camera_ids = concat(this.Camera_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.Solid_ids = new int [0];

      if (allSolids.DEF.length > 0) {
        int[] new_Item = {allSolids.DEF.length - 1};
        this.Solid_ids = concat(this.Solid_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      this.Model1D_ids = new int [0];

      if (allModel1Ds.num > 0) {
        int[] new_Item = {allModel1Ds.num - 1};
        this.Model1D_ids = concat(this.Model1D_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      this.Model2D_ids = new int [0];

      if (allModel2Ds.num > 0) {
        int[] new_Item = {allModel2Ds.num - 1};
        this.Model2D_ids = concat(this.Model2D_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.GROUP) {
      this.Group_ids = new int [0];

      if (allGroups.num > 0) {
        int[] new_Item = {allGroups.num - 1};
        this.Group_ids = concat(this.Group_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {
      this.Face_ids = new int [0];

      if (allFaces.nodes.length > 0) {
        int[] new_Item = {allFaces.nodes.length - 1};
        this.Face_ids = concat(this.Face_ids, new_Item);
      }
    }

    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      this.Vertex_ids = new int [0];

      if (allPoints.getLength() > 0) {
        int[] new_Item = {allPoints.getLength() - 1};
        this.Vertex_ids = concat(this.Vertex_ids, new_Item);
      }
    }


    if (current_ObjectCategory == ObjectCategory.CURVE) {
      this.Curve_ids = new int [0];

      if (allCurves.nodes.length > 0) {
        int[] new_Item = {allCurves.nodes.length - 1};
        this.Curve_ids = concat(this.Curve_ids, new_Item);
      }
    }

    SOLARCHVISION_selection_changed();
  }



  float softSelectionFunction (float d_min) {

    float v = 0;

    if (d_min < this.softRadius) {
      v = pow(funcs.cos_ang(90 * d_min / this.softRadius), this.softPower);
    }

    return v;
  }


  void convert_Model1Ds_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Model1D_ids.length; i++) {

      int f = this.Model1D_ids[i];

      for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

        if ((allGroups.getStart_Model1D(OBJ_ID) <= f) && (f <= allGroups.getStop_Model1D(OBJ_ID))) {

          int previously_added = 0;
          for (int q = 0; q < this.Group_ids.length; q++) {
            if (this.Group_ids[q] == OBJ_ID) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_ID
            };
            this.Group_ids = concat(this.Group_ids, new_Item);
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }

  void convert_Model2Ds_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Model2D_ids.length; i++) {

      int f = this.Model2D_ids[i];

      for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

        if ((allGroups.getStart_Model2D(OBJ_ID) <= f) && (f <= allGroups.getStop_Model2D(OBJ_ID))) {

          int previously_added = 0;
          for (int q = 0; q < this.Group_ids.length; q++) {
            if (this.Group_ids[q] == OBJ_ID) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_ID
            };
            this.Group_ids = concat(this.Group_ids, new_Item);
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Solids_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Solid_ids.length; i++) {

      int f = this.Solid_ids[i];

      for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

        if ((allGroups.getStart_Solid(OBJ_ID) <= f) && (f <= allGroups.getStop_Solid(OBJ_ID))) {

          int previously_added = 0;
          for (int q = 0; q < this.Group_ids.length; q++) {


            if (this.Group_ids[q] == OBJ_ID) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_ID
            };
            this.Group_ids = concat(this.Group_ids, new_Item);
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }

  void convert_Faces_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Face_ids.length; i++) {

      int f = this.Face_ids[i];

      for (int j = 0; j < allFaces.nodes[f].length; j++) {

        for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

          if ((allGroups.getStart_Face(OBJ_ID) <= f) && (f <= allGroups.getStop_Face(OBJ_ID))) {

            int previously_added = 0;
            for (int q = 0; q < this.Group_ids.length; q++) {
              if (this.Group_ids[q] == OBJ_ID) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_ID
              };
              this.Group_ids = concat(this.Group_ids, new_Item);
            }
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }

  void convert_Curves_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Curve_ids.length; i++) {

      int f = this.Curve_ids[i];

      for (int j = 0; j < allCurves.nodes[f].length; j++) {

        for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

          if ((allGroups.getStart_Curve(OBJ_ID) <= f) && (f <= allGroups.getStop_Curve(OBJ_ID))) {

            int previously_added = 0;
            for (int q = 0; q < this.Group_ids.length; q++) {
              if (this.Group_ids[q] == OBJ_ID) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_ID
              };
              this.Group_ids = concat(this.Group_ids, new_Item);
            }
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }



  void convert_Vertices_to_Groups () {

    this.Group_ids = new int [0];

    for (int i = 0; i < this.Vertex_ids.length; i++) {

      int vNo = this.Vertex_ids[i];

      for (int f = 0; f < allFaces.nodes.length; f++) {

        for (int j = 0; j < allFaces.nodes[f].length; j++) {

          if (allFaces.nodes[f][j] == vNo) {

            for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

              if ((allGroups.getStart_Face(OBJ_ID) <= f) && (f <= allGroups.getStop_Face(OBJ_ID))) {

                int previously_added = 0;
                for (int q = 0; q < this.Group_ids.length; q++) {
                  if (this.Group_ids[q] == OBJ_ID) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_ID
                  };
                  this.Group_ids = concat(this.Group_ids, new_Item);
                }
              }
            }
          }
        }
      }

      for (int f = 0; f < allCurves.nodes.length; f++) {

        for (int j = 0; j < allCurves.nodes[f].length; j++) {

          if (allCurves.nodes[f][j] == vNo) {

            for (int OBJ_ID = 0; OBJ_ID < allGroups.num; OBJ_ID++) {

              if ((allGroups.getStart_Curve(OBJ_ID) <= f) && (f <= allGroups.getStop_Curve(OBJ_ID))) {

                int previously_added = 0;
                for (int q = 0; q < this.Group_ids.length; q++) {
                  if (this.Group_ids[q] == OBJ_ID) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_ID
                  };
                  this.Group_ids = concat(this.Group_ids, new_Item);
                }
              }
            }
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Vertices_to_Faces () {

    this.Face_ids = new int [0];

    for (int i = 0; i < this.Vertex_ids.length; i++) {

      int vNo = this.Vertex_ids[i];

      for (int f = 0; f < allFaces.nodes.length; f++) {

        for (int j = 0; j < allFaces.nodes[f].length; j++) {

          if (allFaces.nodes[f][j] == vNo) {

            int previously_added = 0;
            for (int q = 0; q < this.Face_ids.length; q++) {
              if (this.Face_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              this.Face_ids = concat(this.Face_ids, new_Item);
            }
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Vertices_to_Curves () {

    this.Curve_ids = new int [0];

    for (int i = 0; i < this.Vertex_ids.length; i++) {

      int vNo = this.Vertex_ids[i];

      for (int f = 0; f < allCurves.nodes.length; f++) {

        for (int j = 0; j < allCurves.nodes[f].length; j++) {

          if (allCurves.nodes[f][j] == vNo) {

            int previously_added = 0;
            for (int q = 0; q < this.Curve_ids.length; q++) {
              if (this.Curve_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              this.Curve_ids = concat(this.Curve_ids, new_Item);
            }
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }

  void convert_Groups_to_Model1Ds () {

    this.Model1D_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Model1D(OBJ_ID); f <= allGroups.getStop_Model1D(OBJ_ID); f++) {

        int previously_added = 0;
        for (int q = 0; q < this.Model1D_ids.length; q++) {
          if (this.Model1D_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          this.Model1D_ids = concat(this.Model1D_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Groups_to_Model2Ds () {

    this.Model2D_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Model2D(OBJ_ID); f <= allGroups.getStop_Model2D(OBJ_ID); f++) {

        int previously_added = 0;
        for (int q = 0; q < this.Model2D_ids.length; q++) {
          if (this.Model2D_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          this.Model2D_ids = concat(this.Model2D_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }



  void convert_Groups_to_Solids () {

    this.Solid_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Solid(OBJ_ID); f <= allGroups.getStop_Solid(OBJ_ID); f++) {

        int previously_added = 0;
        for (int q = 0; q < this.Solid_ids.length; q++) {
          if (this.Solid_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          this.Solid_ids = concat(this.Solid_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }



  void convert_Groups_to_Faces () {

    this.Face_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

        int previously_added = 0;
        for (int q = 0; q < this.Face_ids.length; q++) {
          if (this.Face_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          this.Face_ids = concat(this.Face_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Groups_to_Curves () {

    this.Curve_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {

        int previously_added = 0;
        for (int q = 0; q < this.Curve_ids.length; q++) {
          if (this.Curve_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          this.Curve_ids = concat(this.Curve_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }



  void convert_Groups_to_Vertices () {

    this.Vertex_ids = new int [0];

    for (int i = 0; i < this.Group_ids.length; i++) {

      int OBJ_ID = this.Group_ids[i];

      for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

        for (int j = 0; j < allFaces.nodes[f].length; j++) {

          int vNo = allFaces.nodes[f][j];

          int previously_added = 0;
          for (int q = 0; q < this.Vertex_ids.length; q++) {
            if (this.Vertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            this.Vertex_ids = concat(this.Vertex_ids, new_Item);
          }
        }
      }

      for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {

        for (int j = 0; j < allCurves.nodes[f].length; j++) {

          int vNo = allCurves.nodes[f][j];

          int previously_added = 0;
          for (int q = 0; q < this.Vertex_ids.length; q++) {
            if (this.Vertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            this.Vertex_ids = concat(this.Vertex_ids, new_Item);
          }
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Faces_to_Vertices () {

    this.Vertex_ids = new int [0];

    for (int i = 0; i < this.Face_ids.length; i++) {

      int f = this.Face_ids[i];

      for (int j = 0; j < allFaces.nodes[f].length; j++) {

        int vNo = allFaces.nodes[f][j];

        int previously_added = 0;
        for (int q = 0; q < this.Vertex_ids.length; q++) {
          if (this.Vertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          this.Vertex_ids = concat(this.Vertex_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }


  void convert_Curves_to_Vertices () {

    this.Vertex_ids = new int [0];

    for (int i = 0; i < this.Curve_ids.length; i++) {

      int f = this.Curve_ids[i];

      for (int j = 0; j < allCurves.nodes[f].length; j++) {

        int vNo = allCurves.nodes[f][j];

        int previously_added = 0;
        for (int q = 0; q < this.Vertex_ids.length; q++) {
          if (this.Vertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          this.Vertex_ids = concat(this.Vertex_ids, new_Item);
        }
      }
    }

    SOLARCHVISION_selection_changed();
  }




  void convert_Vertex_to_softSelection () {

    int[] keep_selection_Vertex_ids = this.Vertex_ids;

    this.convert_Vertices_to_Groups();

    this.convert_Groups_to_Vertices();

    this.softSelection_ids = new int[this.Vertex_ids.length];
    this.softSelection_values = new float[this.Vertex_ids.length];

    for (int q = 0; q < this.Vertex_ids.length; q++) {

      int n = this.Vertex_ids[q];

      float d_min = FLOAT_undefined;

      for (int p = 0; p < keep_selection_Vertex_ids.length; p++) {

        int m = keep_selection_Vertex_ids[p];

        float d = dist(allPoints.getX(m), allPoints.getY(m), allPoints.getZ(m), allPoints.getX(n), allPoints.getY(n), allPoints.getZ(n));

        if (d_min > d) {
          d_min = d;
        }
      }

      this.softSelection_values[q] = this.softSelectionFunction(d_min);
    }

    this.softSelection_ids = this.Vertex_ids;

    this.Vertex_ids = keep_selection_Vertex_ids;

    SOLARCHVISION_selection_changed();
  }



  void selectNearVertices () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      if (current_ObjectCategory == ObjectCategory.GROUP) {

        this.convert_Groups_to_Vertices();
      }

      if (current_ObjectCategory == ObjectCategory.FACE) {

        this.convert_Faces_to_Vertices();
      }

      if (current_ObjectCategory == ObjectCategory.CURVE) {

        this.convert_Curves_to_Vertices();
      }

      this.Vertex_ids = sort(this.Vertex_ids);

      int[] pre_Selection_Vertex_ids = this.Vertex_ids;

      for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) {

        int isNearEnough = -1;

        for (int i = 0; i < pre_Selection_Vertex_ids.length; i++) {

          int q = pre_Selection_Vertex_ids[i];

          int found = -1;

          for (int j = 0; j < this.Vertex_ids.length; j++) {

            if (vNo == this.Vertex_ids[j]) {

              found = 1;

              break;
            }
          }

          if (found == -1) {

            float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

            if (d <= User3D.modify_WeldTreshold) {

              isNearEnough = 1;

              break;
            }
          }
        }


        if (isNearEnough == 1) {

          int[] newVertex_id = {
            vNo
          };

          this.Vertex_ids = concat(this.Vertex_ids, newVertex_id);
        }
      }

      SOLARCHVISION_selection_changed();
    }
  }


  void isolatedVertices_Scene () {

    this.Vertex_ids = new int [0];

    for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) {

      int found = -1;

      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }

      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }

      if (found == -1) {

        int[] newIsolatedVertex = {
          vNo
        };

        this.Vertex_ids = concat(this.Vertex_ids, newIsolatedVertex);


      }
    }

    SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
  }









  int[] get_Face_Vertices () {

    int[] FaceVertices = new int [0];

    for (int o = this.Face_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = this.Face_ids[o];

      int f = OBJ_ID;

      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];

        int vertex_listed = -1;

        for (int q = 0; q < FaceVertices.length; q++) {
          if (vNo == FaceVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }

        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          FaceVertices = concat(FaceVertices, newVertexListed);
        }
      }
    }


    return FaceVertices;
  }


  int[] get_Curve_Vertices () {

    int[] CurveVertices = new int [0];

    for (int o = this.Curve_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = this.Curve_ids[o];

      int f = OBJ_ID;

      for (int j = 0; j < allCurves.nodes[f].length; j++) {
        int vNo = allCurves.nodes[f][j];

        int vertex_listed = -1;

        for (int q = 0; q < CurveVertices.length; q++) {
          if (vNo == CurveVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }

        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          CurveVertices = concat(CurveVertices, newVertexListed);
        }
      }
    }

    return CurveVertices;
  }



  int[] get_Group_Vertices () {

    int[] PolymeshVertices = new int [0];

    for (int o = this.Group_ids.length - 1; o >= 0; o--) {

      int OBJ_ID = this.Group_ids[o];

      for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {

        if ((0 <= f) && (f < allFaces.nodes.length)) {
          for (int j = 0; j < allFaces.nodes[f].length; j++) {

            int vNo = allFaces.nodes[f][j];

            int vertex_listed = -1;

            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }

            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }



      for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {

        if ((0 <= f) && (f < allCurves.nodes.length)) {
          for (int j = 0; j < allCurves.nodes[f].length; j++) {

            int vNo = allCurves.nodes[f][j];

            int vertex_listed = -1;

            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }

            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
    }

    return PolymeshVertices;
  }



  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "posVector", this.posVector);
    XML_setInt(parent, "rotVector", this.rotVector);
    XML_setInt(parent, "scaleVector", this.scaleVector);
    XML_setFloat(parent, "posValue", this.posValue);
    XML_setFloat(parent, "rotValue", this.rotValue);
    XML_setFloat(parent, "scaleValue", this.scaleValue);
    XML_setInt(parent, "alignX", this.alignX);
    XML_setInt(parent, "alignY", this.alignY);
    XML_setInt(parent, "alignZ", this.alignZ);

    XML_setBoolean(parent, "Face_displayEdges", this.Face_displayEdges);
    XML_setBoolean(parent, "Face_displayVertexCount", this.Face_displayVertexCount);
    XML_setBoolean(parent, "Curve_displayVertexCount", this.Curve_displayVertexCount);
    XML_setBoolean(parent, "Vertex_displayVertices", this.Vertex_displayVertices);
    XML_setBoolean(parent, "Curve_displayVertices", this.Curve_displayVertices);
    XML_setBoolean(parent, "Group_displayPivot", this.Group_displayPivot);
    XML_setBoolean(parent, "displayReferencePivot", this.displayReferencePivot);
    XML_setBoolean(parent, "Group_displayEdges", this.Group_displayEdges);
    XML_setBoolean(parent, "Group_displayBox", this.Group_displayBox);
    XML_setBoolean(parent, "Model2D_displayEdges", this.Model2D_displayEdges);
    XML_setBoolean(parent, "Model1D_displayEdges", this.Model1D_displayEdges);
    XML_setBoolean(parent, "Solid_displayEdges", this.Solid_displayEdges);
    XML_setBoolean(parent, "Section_displayEdges", this.Section_displayEdges);
    XML_setBoolean(parent, "Camera_displayEdges", this.Camera_displayEdges);
    XML_setBoolean(parent, "LandPoint_displayPoints", this.LandPoint_displayPoints);

    XML_setFloat(parent, "softPower", this.softPower);
    XML_setFloat(parent, "softRadius", this.softRadius);

    {
      String txt = "";
      int ni = LandPoint_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.LandPoint_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_LandPoints", txt);
    }

    {
      String txt = "";
      int ni = Model1D_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Model1D_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Model1Ds", txt);
    }


    {
      String txt = "";
      int ni = Model2D_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Model2D_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Model2Ds", txt);
    }

    {
      String txt = "";
      int ni = Group_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Group_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Groups", txt);
    }

    {
      String txt = "";
      int ni = Face_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Face_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Faces", txt);
    }


    {
      String txt = "";
      int ni = Curve_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Curve_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Curves", txt);
    }


    {
      String txt = "";
      int ni = Solid_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Solid_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Solids", txt);
    }

    {
      String txt = "";
      int ni = Section_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Section_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Sections", txt);
    }

    {
      String txt = "";
      int ni = Camera_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Camera_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Cameras", txt);
    }



    {
      String txt = "";
      int ni = Vertex_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.Vertex_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "selected_Points", txt);
    }


    {
      String txt = "";
      int ni = softSelection_ids.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.softSelection_ids[i], 0);
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "softSelection_ids", txt);
    }


    {
      String txt = "";
      int ni = softSelection_values.length;
      for (int i = 0; i < ni; i++) {
        txt += nf(this.softSelection_values[i], 0, 4).replace("|", "."); // <<<<
        if (i < ni - 1) txt += "|";
      }
      XML_setString(parent, "softSelection_values", txt);
    }

  }




  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.posVector = XML_getInt(parent, "posVector");
    this.rotVector = XML_getInt(parent, "rotVector");
    this.scaleVector = XML_getInt(parent, "scaleVector");
    this.posValue = XML_getFloat(parent, "posValue");
    this.rotValue = XML_getFloat(parent, "rotValue");
    this.scaleValue = XML_getFloat(parent, "scaleValue");
    this.alignX = XML_getInt(parent, "alignX");
    this.alignY = XML_getInt(parent, "alignY");
    this.alignZ = XML_getInt(parent, "alignZ");

    this.displayReferencePivot = XML_getBoolean(parent, "displayReferencePivot");
    this.Group_displayPivot = XML_getBoolean(parent, "Group_displayPivot");
    this.Group_displayEdges = XML_getBoolean(parent, "Group_displayEdges");
    this.Group_displayBox = XML_getBoolean(parent, "Group_displayBox");
    this.Face_displayEdges = XML_getBoolean(parent, "Face_displayEdges");
    this.Face_displayVertexCount = XML_getBoolean(parent, "Face_displayVertexCount");
    this.Curve_displayVertexCount = XML_getBoolean(parent, "Curve_displayVertexCount");
    this.Vertex_displayVertices = XML_getBoolean(parent, "Vertex_displayVertices");
    this.Curve_displayVertices = XML_getBoolean(parent, "Curve_displayVertices");
    this.Model2D_displayEdges = XML_getBoolean(parent, "Model2D_displayEdges");
    this.Model1D_displayEdges = XML_getBoolean(parent, "Model1D_displayEdges");
    this.Solid_displayEdges = XML_getBoolean(parent, "Solid_displayEdges");
    this.Section_displayEdges = XML_getBoolean(parent, "Section_displayEdges");
    this.Camera_displayEdges = XML_getBoolean(parent, "Camera_displayEdges");
    this.LandPoint_displayPoints = XML_getBoolean(parent, "LandPoint_displayPoints");

    this.softPower = XML_getFloat(parent, "softPower");
    this.softRadius = XML_getFloat(parent, "softRadius");


    {
      String txt = XML_getString(parent, "selected_LandPoints");
      if (txt.equals("")) {
        this.LandPoint_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.LandPoint_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.LandPoint_ids[i] = int(parts[i]);
        }
      }
    }

    {
      String txt = XML_getString(parent, "selected_Model1Ds");
      if (txt.equals("")) {
        this.Model1D_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Model1D_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Model1D_ids[i] = int(parts[i]);
        }
      }
    }

    {
      String txt = XML_getString(parent, "selected_Model2Ds");
      if (txt.equals("")) {
        this.Model2D_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Model2D_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Model2D_ids[i] = int(parts[i]);
        }
      }
    }

    {
      String txt = XML_getString(parent, "selected_Groups");
      if (txt.equals("")) {
        this.Group_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Group_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Group_ids[i] = int(parts[i]);
        }
      }
    }

    {
      String txt = XML_getString(parent, "selected_Faces");
      if (txt.equals("")) {
        this.Face_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Face_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Face_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "selected_Curves");
      if (txt.equals("")) {
        this.Curve_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Curve_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Curve_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "selected_Solids");
      if (txt.equals("")) {
        this.Solid_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Solid_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Solid_ids[i] = int(parts[i]);
        }
      }
    }



    {
      String txt = XML_getString(parent, "selected_Sections");
      if (txt.equals("")) {
        this.Section_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Section_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Section_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "selected_Cameras");
      if (txt.equals("")) {
        this.Camera_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Camera_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Camera_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "selected_Points");
      if (txt.equals("")) {
        this.Vertex_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.Vertex_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.Vertex_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "softSelection_ids");
      if (txt.equals("")) {
        this.softSelection_ids = new int[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.softSelection_ids = new int[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.softSelection_ids[i] = int(parts[i]);
        }
      }
    }


    {
      String txt = XML_getString(parent, "softSelection_values");
      if (txt.equals("")) {
        this.softSelection_values = new float[0];
      }
      else {
        String[] parts = split(txt, "|");
        this.softSelection_values = new float[parts.length];
        for (int i = 0; i < parts.length; i++) {
          this.softSelection_values[i] = float(parts[i]);
        }
      }
    }


  }

}

solarchvision_Select3D Select3D = new solarchvision_Select3D();


float[][] saved_BoundingBox = Select3D.BoundingBox;

int saved_alignX = Select3D.alignX;
int saved_alignY = Select3D.alignY;
int saved_alignZ = Select3D.alignZ;


int addNewSelectionToPreviousSelection = 0; // internal

boolean addToLastGroup = false; // internal



float pre_TIME_Date;
int pre_TIME_Hour;
int pre_TIME_Day;
int pre_TIME_Month;
int pre_TIME_Year;

int pre_SampleYear_Start;
int pre_SampleYear_End;
int pre_SampleMember_Start;
int pre_SampleMember_End;
int pre_SampleStation_Start;
int pre_SampleStation_End;

int pre_STUDY_joinDays;
int pre_STUDY_i_Start;
int pre_STUDY_i_End;
int pre_STUDY_j_End;
int pre_STUDY_Setup;

int pre_IMPACTS_displayDay;
int pre_CurrentDataSource;

int pre_CLIMATIC_SolarForecast;
int pre_CLIMATIC_WeatherForecast;

boolean pre_CLIMATE_TMYEPW_load;
boolean pre_CLIMATE_CWEEDS_load;
boolean pre_CLIMATE_CLMREC_load;
boolean pre_ENSEMBLE_FORECAST_load;
boolean pre_ENSEMBLE_OBSERVED_load;

boolean pre_Land3D_loadMesh;
boolean pre_Land3D_loadTextures;

float pre_LocationLAT;
float pre_LocationLON;

boolean pre_WORLD_autoView;

boolean pre_Selection_Model1D_displayEdges;
boolean pre_Selection_Model2D_displayEdges;

boolean pre_Selection_Solid_displayEdges;
boolean pre_Selection_Section_displayEdges;
boolean pre_Selection_Camera_displayEdges;

boolean pre_Selection_LandPoint_displayPoints;

float pre_Selection_softPower;
float pre_Selection_softRadius;

float pre_Selection_posValue;
float pre_Selection_rotValue;
float pre_Selection_scaleValue;

int pre_Selection_alignX;
int pre_Selection_alignY;
int pre_Selection_alignZ;

boolean pre_Selection_displayReferencePivot;

boolean pre_Selection_Group_displayPivot;
boolean pre_Selection_Group_displayEdges;
boolean pre_Selection_Group_displayBox;

boolean pre_Selection_Face_displayEdges;
boolean pre_Selection_Face_displayVertexCount;
boolean pre_Selection_Curve_displayVertexCount;
boolean pre_Selection_Vertex_displayVertices;
boolean pre_Selection_Curve_displayVertices;

int pre_WIN3D_currentCamera;

int pre_WIN3D_FacesShade;

int pre_Create3D_Tessellation;

boolean pre_allPoints_displayAll;
boolean pre_allFaces_displayEdges;
boolean pre_allFaces_displayNormals;

int pre_Develop_Option;

int pre_STUDY_ImpactLayer;
int pre_STUDY_CurrentLayer_id;

int pre_STUDY_SkyScenario;
int pre_STUDY_PlotImpacts;

int pre_allSolids_pallet_CLR;
int pre_allSolids_pallet_DIR;
float pre_allSolids_pallet_MLT;

float pre_allSolidImpacts_Grade;
float pre_allSolidImpacts_Power;
float[] pre_allSolidImpacts_Rotation = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_Elevation = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_U_scale = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_V_scale = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_sU_offset = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_sV_offset = {
  0, 0, 0, 0
};

float pre_allSolidImpacts_Wspd;
float pre_allSolidImpacts_Wdir;

boolean pre_allSolidImpacts_displayPoints;
boolean pre_allSolidImpacts_displayLines;

int pre_allSolidImpacts_Process_subDivisions;

boolean pre_WindFlow_display;

float pre_USER_create_powAll;


class solarchvision_MESSAGE {

  private final static String CLASS_STAMP = "MESSAGE";

  int cX = 0;
  int cY = 495;
  int dX = 1848;
  int dY = int(2 * MessageSize);
}

solarchvision_MESSAGE MESSAGE = new solarchvision_MESSAGE();


void setup () {
  size(1848, 1016, P2D);
  //size(2 * SOLARCHVISION_pixel_W + ROLLOUT.dX, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + SOLARCHVISION_pixel_D, P2D);

  SOLARCHVISION_draw_frameIcon();

  TIME.date = (286 + TIME.convert2Date(TIME.month, TIME.day)) % 365; // 0 presents March 21, 286 presents Jan.01, 345 presents March.01
  //if (TIME.hour >= 12) TIME.date += 0.5;

  allMaterials.empty_DirectArea();
  allMaterials.empty_DiffuseArea();

  VertexSolar_resize_array();
  GlobalSolar_resize_array();

  Tropo3D.resize_images();

  Earth3D.resize_images();

  Sun3D.load_images();
  Moon3D.load_images();

  WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

  WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);

  STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);

  SKY2D_graphics = createGraphics(SKY2D_X_View, SKY2D_Y_View, P3D);

  SOLARCHVISION_loadDefaultFontStyle();

  changeCurrentLayerTo(8); // pointing to air temperature variable i.e. on the list of allLayers

  frameRate(8);

  loop();
}



int Last_initializationStep = 1000;
int InitializationStep = 0;

void draw () {

  //println("frameCount:", frameCount);


  if (frameCount == 1) {

    background(223);

    SOLARCHVISION_update_folders();

    float cr;

    cr = SOLARCHVISION_pixel_W / 4.0;
    //PImage SOLARCHVISION_logo = loadImage(BaseFolder + "/input/images/logo/SOLARCHVISION.jpg");
    //imageMode(CENTER);
    //image(SOLARCHVISION_logo, 0.5 * width, 0.5 * height - 0.75 * MessageSize - cr + (0.075 * cr), 3.05 * cr, 3.05 * cr);
    imageMode(CORNER);

    strokeWeight(1);
    stroke(0);
    noFill();


    ellipseMode(CENTER);

    strokeWeight(0);
    stroke(191);
    fill(191);
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    SOLARCHVISION_draw_logo(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 1, 1);
    strokeWeight(2);
    stroke(0);
    noFill();
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 0, 1);
    SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 0, 2);
    strokeWeight(2);
    stroke(0);
    noFill();
    ellipse(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);
    stroke(191);
    fill(191);
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    SOLARCHVISION_draw_logo(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, -1, 1);
    strokeWeight(2);
    stroke(0);
    noFill();
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);

    stroke(255);
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(3 * MessageSize);
    text(SOLARCHVISION_version + " model integrations (BIM-6D)", 0.5 * width, 0.05 * height);

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(3 * MessageSize);
    text("SOLARCHVISION", 0.5 * width, 0.6 * height);

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(1.5 * MessageSize);
    text("Raz, Mehr, Mehraz solarch studio\n1998-" + SOLARCHVISION_version + "\nAuthor: Mojtaba Samimi\nwww.solarchvision.com", 0.5 * width, 0.75 * height);

    textAlign(CENTER, CENTER);
    textSize(1.25 * MessageSize);
  } else if (frameCount == 2) {
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("WORLD.listAllImages", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 3) {
    WORLD.listAllImages();
    WORLD.loadImages(WORLD.VIEW_id); // to load the globe image into memory

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Model2Ds.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 4) {
    allModel2Ds.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("inputCoordinates_SWOB", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 5) {
    inputCoordinates_SWOB();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("inputCoordinates_NAEFS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 6) {
    inputCoordinates_NAEFS();
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("inputCoordinates_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 7) {
    inputCoordinates_CWEEDS();
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("inputCoordinates_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 8) {
    inputCoordinates_CLMREC();
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("inputCoordinates_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 9) {
    inputCoordinates_TMYEPW();
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("TIME.updateDate", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 10) {
    TIME.updateDate();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_station(start)", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 11) {
    SOLARCHVISION_update_station(1);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_CLIMATE_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 12) {
    SOLARCHVISION_update_station(2);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_CLIMATE_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 13) {
    SOLARCHVISION_update_station(3);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_CLIMATE_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 14) {
    SOLARCHVISION_update_station(4);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_ENSEMBLE_OBSERVED", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 15) {
    SOLARCHVISION_update_station(5);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("update_ENSEMBLE_FORECAST", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 16) {
    SOLARCHVISION_update_station(6);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Land3D.update_mesh", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 17) {
    SOLARCHVISION_update_station(7);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Earth3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 18) {
    Earth3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Tropo3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 19) {
    Tropo3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("build_SkySphere", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 20) {

    SOLARCHVISION_build_SkySphere(1); //1 - 3
    GlobalSolar_resize_array();
    VertexSolar_resize_array();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);

    stroke(255); fill(255); text("Please wait while integrating the models.", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);

    MESSAGE.dX = 2 * SOLARCHVISION_pixel_W;

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;

    UI_menuBar.revise();
    UI_toolBar.revise();
    UI_timeBar.revise();
    UI_commandBar.revise();

    InitializationStep = frameCount;
    Last_initializationStep = frameCount;
  } else {

    if (ROLLOUT.include) {
      if (ROLLOUT.update) {
        ROLLOUT.updated();

        pre_SampleYear_Start = SampleYear_Start;
        pre_SampleYear_End = SampleYear_End;
        pre_SampleMember_Start = SampleMember_Start;
        pre_SampleMember_End = SampleMember_End;
        pre_SampleStation_Start = SampleStation_Start;
        pre_SampleStation_End = SampleStation_End;
        pre_STUDY_joinDays = STUDY.joinDays;
        pre_STUDY_i_Start = STUDY.i_Start;
        pre_STUDY_i_End = STUDY.i_End;
        pre_STUDY_j_End = STUDY.j_End;
        pre_IMPACTS_displayDay = IMPACTS_displayDay;
        pre_STUDY_Setup = STUDY.plotSetup;
        pre_CurrentDataSource = CurrentDataSource;
        pre_TIME_Year = TIME.year;
        pre_TIME_Month = TIME.month;
        pre_TIME_Day = TIME.day;
        pre_TIME_Date = TIME.date;
        pre_TIME_Hour = TIME.hour;
        pre_CLIMATIC_SolarForecast = CLIMATIC_SolarForecast;
        pre_CLIMATIC_WeatherForecast = CLIMATIC_WeatherForecast;

        pre_CLIMATE_TMYEPW_load = CLIMATE_TMYEPW_load;
        pre_CLIMATE_CWEEDS_load = CLIMATE_CWEEDS_load;
        pre_CLIMATE_CLMREC_load = CLIMATE_CLMREC_load;
        pre_ENSEMBLE_FORECAST_load = ENSEMBLE_FORECAST_load;
        pre_ENSEMBLE_OBSERVED_load = ENSEMBLE_OBSERVED_load;

        pre_LocationLAT = LocationLAT;
        pre_LocationLON = LocationLON;

        pre_WORLD_autoView = WORLD.autoView;

        pre_Land3D_loadMesh = Land3D.loadMesh;
        pre_Land3D_loadTextures = Land3D.loadTextures;

        pre_allSolids_pallet_CLR = allSolids.pallet_CLR;
        pre_allSolids_pallet_DIR = allSolids.pallet_DIR;
        pre_allSolids_pallet_MLT = allSolids.pallet_MLT;

        pre_USER_create_powAll = User3D.create_powAll;

        pre_allSolidImpacts_U_scale = allSolidImpacts.U;
        pre_allSolidImpacts_V_scale = allSolidImpacts.V;

        pre_allSolidImpacts_sU_offset = allSolidImpacts.X;
        pre_allSolidImpacts_sV_offset = allSolidImpacts.Y;

        pre_allSolidImpacts_Grade = allSolidImpacts.Grade;
        pre_allSolidImpacts_Power = allSolidImpacts.Power;
        pre_allSolidImpacts_Rotation[allSolidImpacts.sectionType] = allSolidImpacts.R[allSolidImpacts.sectionType];
        pre_allSolidImpacts_Elevation[allSolidImpacts.sectionType] = allSolidImpacts.Z[allSolidImpacts.sectionType];

        pre_allSolidImpacts_Wspd = allSolidImpacts.WindSpeed;
        pre_allSolidImpacts_Wdir = allSolidImpacts.WindDirection;

        pre_allSolidImpacts_Process_subDivisions = allSolidImpacts.Process_subDivisions;

        pre_allSolidImpacts_displayPoints = allSolidImpacts.displayPoints;
        pre_allSolidImpacts_displayLines = allSolidImpacts.displayLines;

        pre_WindFlow_display = allWindFlows.displayAll;



        pre_Selection_Solid_displayEdges = Select3D.Solid_displayEdges;

        pre_Selection_Section_displayEdges = Select3D.Section_displayEdges;

        pre_Selection_Camera_displayEdges = Select3D.Camera_displayEdges;

        pre_Selection_LandPoint_displayPoints = Select3D.LandPoint_displayPoints;

        pre_Selection_Model1D_displayEdges = Select3D.Model1D_displayEdges;
        pre_Selection_Model2D_displayEdges = Select3D.Model2D_displayEdges;
        pre_allPoints_displayAll = allPoints.displayAll;
        pre_allFaces_displayEdges = allFaces.displayEdges;
        pre_allFaces_displayNormals = allFaces.displayNormals;

        pre_Selection_softPower = Select3D.softPower;
        pre_Selection_softRadius = Select3D.softRadius;


        pre_Selection_posValue = Select3D.posValue;
        pre_Selection_rotValue = Select3D.rotValue;
        pre_Selection_scaleValue = Select3D.scaleValue;

        pre_Selection_alignX = Select3D.alignX;
        pre_Selection_alignY = Select3D.alignY;
        pre_Selection_alignZ = Select3D.alignZ;

        pre_Selection_displayReferencePivot = Select3D.displayReferencePivot;

        pre_Selection_Group_displayPivot = Select3D.Group_displayPivot;
        pre_Selection_Group_displayEdges = Select3D.Group_displayEdges;
        pre_Selection_Group_displayBox = Select3D.Group_displayBox;

        pre_Selection_Face_displayEdges = Select3D.Face_displayEdges;
        pre_Selection_Face_displayVertexCount = Select3D.Face_displayVertexCount;
        pre_Selection_Curve_displayVertexCount = Select3D.Curve_displayVertexCount;
        pre_Selection_Vertex_displayVertices = Select3D.Vertex_displayVertices;
        pre_Selection_Curve_displayVertices = Select3D.Curve_displayVertices;

        pre_WIN3D_currentCamera = WIN3D.currentCamera;

        pre_WIN3D_FacesShade = WIN3D.FacesShade;

        pre_Create3D_Tessellation = allFaces.displayTessellation;

        pre_STUDY_ImpactLayer = STUDY.ImpactLayer;

        pre_Develop_Option = Develop_Option;

        pre_STUDY_CurrentLayer_id = CurrentLayer_id;

        pre_STUDY_SkyScenario = STUDY.skyScenario;

        pre_STUDY_PlotImpacts = STUDY.PlotImpacts;

        ROLLOUT.drawView();

        if (pre_STUDY_PlotImpacts != STUDY.PlotImpacts) {
          STUDY.revise();

          SOLARCHVISION_view_changed();
        }

        if (pre_SampleYear_Start != SampleYear_Start) {
          UI_timeBar.revise();
        }
        if (pre_SampleYear_End != SampleYear_End) {
          UI_timeBar.revise();
        }

        if (pre_SampleMember_Start != SampleMember_Start) {
          UI_timeBar.revise();
        }

        if (pre_SampleMember_End != SampleMember_End) {
          UI_timeBar.revise();
        }

        if (pre_SampleStation_Start != SampleStation_Start) {
          UI_timeBar.revise();
        }

        if (pre_SampleStation_End != SampleStation_End) {
          UI_timeBar.revise();
        }

        if (pre_STUDY_joinDays != STUDY.joinDays) {
          UI_timeBar.revise();
        }

        if (pre_STUDY_i_Start != STUDY.i_Start) {
          UI_timeBar.revise();
        }

        if (pre_STUDY_i_End != STUDY.i_End) {
          UI_timeBar.revise();
        }


        if (pre_STUDY_j_End != STUDY.j_End) {
          UI_timeBar.revise();

          VertexSolar_rebuild_array = true;
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;

          allSections.resize_solarImpact_array();
        }

        if (pre_IMPACTS_displayDay != IMPACTS_displayDay) {
          UI_timeBar.revise();
        }

        if (pre_TIME_Date != TIME.date) {
          UI_timeBar.revise();

          TIME.updateDate();
          ROLLOUT.drawView();
        }

        if ((pre_TIME_Year != TIME.year) ||
            (pre_TIME_Month != TIME.month) ||
            (pre_TIME_Day != TIME.day) ||
            (pre_TIME_Hour != TIME.hour) ||
            (pre_CLIMATIC_SolarForecast != CLIMATIC_SolarForecast) ||
            (pre_CLIMATIC_WeatherForecast != CLIMATIC_WeatherForecast)) {

          UI_timeBar.revise();

          TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
          TIME.hour = int(24 * (TIME.date - int(TIME.date)));
          TIME.date = (TIME.hour / 24.0) + (286 + TIME.convert2Date(TIME.month, TIME.day)) % 365;
          println("DATE:", TIME.date, "\tHOUR:", TIME.hour);
          update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

          ROLLOUT.drawView();
        }



        if (pre_CLIMATE_TMYEPW_load != CLIMATE_TMYEPW_load) update_CLIMATE_TMYEPW();
        if (pre_CLIMATE_CWEEDS_load != CLIMATE_CWEEDS_load) update_CLIMATE_CWEEDS();
        if (pre_CLIMATE_CLMREC_load != CLIMATE_CLMREC_load) update_CLIMATE_CLMREC();
        if (pre_ENSEMBLE_OBSERVED_load != ENSEMBLE_OBSERVED_load) SOLARCHVISION_update_ENSEMBLE_OBSERVED();
        if (pre_ENSEMBLE_FORECAST_load != ENSEMBLE_FORECAST_load) update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

        if (pre_WORLD_autoView != WORLD.autoView) {
          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
        }



        if ((pre_LocationLAT != LocationLAT) ||
            (pre_LocationLON != LocationLON)) {

          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
          WORLD.revise();
        }




        if (pre_Land3D_loadMesh != Land3D.loadMesh) {
          Land3D.update_mesh();
          SOLARCHVISION_model_changed();
        }

        if (pre_Land3D_loadTextures != Land3D.loadTextures) {
          Land3D.update_textures();
          SOLARCHVISION_model_changed();
        }



        if (pre_Selection_Camera_displayEdges != Select3D.Camera_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Section_displayEdges != Select3D.Section_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Solid_displayEdges != Select3D.Solid_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_LandPoint_displayPoints != Select3D.LandPoint_displayPoints) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Model1D_displayEdges != Select3D.Model1D_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Model2D_displayEdges != Select3D.Model2D_displayEdges) {
          SOLARCHVISION_view_changed();
        }


        if (pre_Selection_softPower != Select3D.softPower) {
          Select3D.convert_Vertex_to_softSelection();
        }

        if (pre_Selection_softRadius != Select3D.softRadius) {
          Select3D.convert_Vertex_to_softSelection();
        }


        if (pre_Selection_alignX != Select3D.alignX) {
          SOLARCHVISION_selection_changed();
        }

        if (pre_Selection_alignY != Select3D.alignY) {
          SOLARCHVISION_selection_changed();
        }

        if (pre_Selection_alignZ != Select3D.alignZ) {
          SOLARCHVISION_selection_changed();
        }

        if (pre_Selection_posValue != Select3D.posValue) {

          float d = Select3D.posValue - pre_Selection_posValue;

          float dx = d;
          float dy = d;
          float dz = d;

          int the_Vector = Select3D.posVector;

          if (the_Vector == 0) {
            dy = 0;
            dz = 0;
          }
          if (the_Vector == 1) {
            dz = 0;
            dx = 0;
          }
          if (the_Vector == 2) {
            dx = 0;
            dy = 0;
          }

          Move3D.selection(dx, dy, dz);

          SOLARCHVISION_model_changed();
        }
        if (pre_Selection_rotValue != Select3D.rotValue) {

          float[] P = Select3D.getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float r = Select3D.rotValue - pre_Selection_rotValue;

          int the_Vector = Select3D.rotVector;

          Rotate3D.selection(x0, y0, z0, r, the_Vector);

          SOLARCHVISION_model_changed();
        }
        if (pre_Selection_scaleValue != Select3D.scaleValue) {

          float[] P = Select3D.getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float s = pow(2.0, Select3D.scaleValue - pre_Selection_scaleValue);

          float sx = s;
          float sy = s;
          float sz = s;

          int the_Vector = Select3D.scaleVector;

          if (the_Vector == 0) {
            sy = 1;
            sz = 1;
          }
          if (the_Vector == 1) {
            sz = 1;
            sx = 1;
          }
          if (the_Vector == 2) {
            sx = 1;
            sy = 1;
          }

          Scale3D.selection(x0, y0, z0, sx, sy, sz);

          SOLARCHVISION_model_changed();
        }


        if (pre_Selection_displayReferencePivot != Select3D.displayReferencePivot) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Group_displayPivot != Select3D.Group_displayPivot) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Group_displayEdges != Select3D.Group_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Group_displayBox != Select3D.Group_displayBox) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Face_displayEdges != Select3D.Face_displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Face_displayVertexCount != Select3D.Face_displayVertexCount) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Curve_displayVertexCount != Select3D.Curve_displayVertexCount) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Vertex_displayVertices != Select3D.Vertex_displayVertices) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Selection_Curve_displayVertices != Select3D.Curve_displayVertices) {
          SOLARCHVISION_view_changed();
        }


        if (pre_WIN3D_currentCamera != WIN3D.currentCamera) {
          WIN3D.apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();

          SOLARCHVISION_view_changed();
        }


        if (pre_WIN3D_FacesShade != WIN3D.FacesShade) {
          SOLARCHVISION_view_changed();
        }

        if (pre_Create3D_Tessellation != allFaces.displayTessellation) {
          SOLARCHVISION_view_changed();
        }


        if (pre_USER_create_powAll != User3D.create_powAll) {
          User3D.create_powX = User3D.create_powAll;
          User3D.create_powY = User3D.create_powAll;
          User3D.create_powZ = User3D.create_powAll;

          ROLLOUT.revise();
        }


        if (pre_allSolids_pallet_CLR != allSolids.pallet_CLR) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolids_pallet_DIR != allSolids.pallet_DIR) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolids_pallet_MLT != allSolids.pallet_MLT) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_Grade != allSolidImpacts.Grade) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolidImpacts_Power != allSolidImpacts.Power) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolidImpacts_Rotation[allSolidImpacts.sectionType] != allSolidImpacts.R[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolidImpacts_Elevation[allSolidImpacts.sectionType] != allSolidImpacts.Z[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_U_scale[allSolidImpacts.sectionType] != allSolidImpacts.U[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_V_scale[allSolidImpacts.sectionType] != allSolidImpacts.V[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_sU_offset[allSolidImpacts.sectionType] != allSolidImpacts.X[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolidImpacts_sV_offset[allSolidImpacts.sectionType] != allSolidImpacts.Y[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_Wspd != allSolidImpacts.WindSpeed) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }
        if (pre_allSolidImpacts_Wdir != allSolidImpacts.WindDirection) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }


        if (pre_allSolidImpacts_Process_subDivisions != allSolidImpacts.Process_subDivisions) {
          allSolidImpacts.calculate_Impact_selectedSections();

          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_displayPoints != allSolidImpacts.displayPoints) {
          SOLARCHVISION_view_changed();
        }

        if (pre_allSolidImpacts_displayLines != allSolidImpacts.displayLines) {
          SOLARCHVISION_view_changed();
        }

        if (pre_allPoints_displayAll != allPoints.displayAll) {
          SOLARCHVISION_view_changed();
        }

        if (pre_allFaces_displayEdges != allFaces.displayEdges) {
          SOLARCHVISION_view_changed();
        }

        if (pre_allFaces_displayNormals != allFaces.displayNormals) {
          SOLARCHVISION_view_changed();
        }

        if (pre_WindFlow_display != allWindFlows.displayAll) {
          SOLARCHVISION_view_changed();
        }

        if (STUDY.plotSetup != pre_STUDY_Setup) {
          STUDY.Impacts_update = true;
          UI_timeBar.updated();
        }

        if (CurrentDataSource != pre_CurrentDataSource) {
          STUDY.Impacts_update = true;
          UI_timeBar.updated();
        }
      }
    }



    if (FRAME_record_AUTO) {
      if (STUDY.update) FRAME_record_IMG = true;
      if (WIN3D.update) FRAME_record_IMG = true;
      if (WORLD.update) FRAME_record_IMG = true;
      //if (UI_menuBar.update) FRAME_record_IMG = true;
      //if (UI_toolBar.update) FRAME_record_IMG = true;
      //if (UI_timeBar.update) FRAME_record_IMG = true;
    }




    int Illustrations_Animate = 0;

    //if ((STUDY.update == false) && (WIN3D.update == false)) {
    if (STUDY.update == false) {
      //Illustrations_Animate = 1;
    }

    if (STUDY.include) {
      if (STUDY.update) {

        STUDY.drawView();
      }
    }
    STUDY.updated();

    if (STUDY.record_PDF == false) {
      /*
       if (Illustrations_Animate != 0) {
       GRIB2_Layer = GRIB2_Layer_Start;

       GRIB2_Hour = GRIB2_Hour_Start;

       int d = (GRIB2_Hour_End - GRIB2_Hour_Start) / GRIB2_Hour_Step;

       if (d > 1) {

       GRIB2_Hour += GRIB2_Hour_Step * (frameCount % d);

       if (GRIB2_Hour > GRIB2_Hour_End) GRIB2_Hour = GRIB2_Hour_Start;

       WORLD.revise();
       WIN3D.revise(); // <<<<<<<<<<<
       }
       }
       */

      if (WORLD.include) {
        if (WORLD.update) {

          WORLD.drawView();
        }
      }

      if (WORLD.record_PDF == false) {
        if (WIN3D.include) {
          if (WIN3D.update) {

            SOLARCHVISION_regenerate_desired_bakings();

            WIN3D.drawView();
          }
        }

        if(updateBars) {
          updateBars = false;
          UI_menuBar.revise();
          UI_toolBar.revise();
          UI_timeBar.revise();
          UI_commandBar.revise();
        }

        if (UI_menuBar.update) {
          UI_menuBar.draw();
        }

        if (UI_toolBar.update) {
          UI_toolBar.draw();
        }

        if (UI_timeBar.update) {
          UI_timeBar.draw();
        }

        if (UI_commandBar.update) {
          UI_commandBar.draw();
        }



        if (FRAME_record_IMG) {
          SOLARCHVISION_RecordFrame();
          FRAME_record_IMG = false;
        }
      } else {
        WORLD.record_PDF = false;
      }
    } else {
      STUDY.record_PDF = false;
    }


    //WIN3D.updated();
    //WORLD.updated();
    //STUDY.updated();

    //noLoop(); // <<<<<<<<<<<<

  }
}

void SOLARCHVISION_find_which_bakings_to_regenerate () {

  if (WIN3D.FacesShade == SHADE.Global_Solar) {
    GlobalSolar_rebuild_array = true;
  }
  if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
    VertexSolar_rebuild_array = true;
  }
  if (allSolarImpacts.displayImage) {
    allSolarImpacts.rebuild_Image_array = true;
  }
  if (allWindRoses.displayImage) {
    allWindRoses.rebuild_Image_array = true;
  }
}



void SOLARCHVISION_regenerate_desired_bakings () {

  if (VertexSolar_rebuild_array) {
    SOLARCHVISION_calculate_VertexSolar_array();
  }

  if (GlobalSolar_rebuild_array) {
    SOLARCHVISION_calculate_GlobalSolar_array();
  }

}







class solarchvision_PAINT {

  private final static String CLASS_STAMP = "PAINT";


  int getOpacity (float O_scale) {
    int k = int(O_scale * 0.01 * 256);
    if (k > 255) k = 255;
    if (k < 0) k = 0;

    return k;
  }

  float[] WBGRW (float _variable) {
    _variable *= 600.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };

    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = v;
      COL[3] = v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }

    return COL;
  }

  float[] BGR (float _variable) {
    _variable *= 400.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };

    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }

    return COL;
  }

  float[] DBGR (float _variable) {
    _variable *= 500.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }

    return COL;
  }

  float[] DWBGR (float _variable) {
    _variable *= 600.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }

    return COL;
  }

  float[] DWYR (float _variable) {
    _variable *= 400.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255 - 0.5 * v;
      COL[2] = 0;
      COL[3] = 0;
    } else {
      COL[1] = 127;
      COL[2] = 0;
      COL[3] = 0;
    }

    return COL;
  }


  float[] VDWBGR (float _variable) {
    _variable *= 700.0;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable - 0) * 2.55);
      COL[1] = (255 - v);
      COL[2] = 0;
      COL[3] = (255 - v);
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 700) {
      v = ((_variable - 600) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }

    return COL;
  }

  float[] DRYWCBD (float _variable) {

    _variable *= 1.5;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable <= -2.75) {
      COL[1] = 63;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else if (_variable < 1) {
      v = (_variable * 255);
      COL[1] = 255 - v;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 2) {
      v = ((_variable - 1) * 255);
      COL[1] = 0;
      COL[2] = 255 - v;
      COL[3] = 255;
    } else if (_variable < 2.75) {
      v = ((_variable - 2) * 255);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255 - v;
    } else {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 63;
    }

    return COL;
  }


  float[] DBCW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }

    float r, g, b;
    r = COL[3];
    g = COL[2];
    b = COL[1];
    COL[1] = r;
    COL[2] = g;
    COL[3] = b;

    return COL;
  }

  float[] DRYW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }

    return COL;
  }

  float[] WYRD (float _variable) {
    _variable *= -3;

    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }

    return COL;
  }


  float[] getColorStyle (int COLOR_STYLE_Current, float j) {
    float[] c = {
      255, 0, 0, 0
    };

    if (COLOR_STYLE_Current == 0) {
      c[0] = PAINT.getOpacity(STUDY.O_scale);
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == 19) {
      float[] COL = this.DWYR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 18) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 17) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    } else if (COLOR_STYLE_Current == 16) {
      float[] COL = this.DBCW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 15) {
      float[] COL = this.DRYW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 14) {
      float[] COL = this.DBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 13) {
      float[] COL = this.DWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 12) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 11) {
      float[] COL = this.BGR(j);
      c[0] = 127;
      c[1] = 255 - 0.5 * COL[1];
      c[2] = 255 - 0.5 * COL[2];
      c[3] = 255 - 0.5 * COL[3];
    } else if (COLOR_STYLE_Current == 10) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 9) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 8) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 7) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 6) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 4) {
      float[] COL = this.VDWBGR(j);
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 3) {
      float[] COL = this.VDWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 2) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 5) {
      c[0] = 255;
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == -1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    }


    return c;
  }
}

solarchvision_PAINT PAINT = new solarchvision_PAINT();









int STAT_N_MidLow = 0;
int STAT_N_Middle = 1;
int STAT_N_MidHigh = 2;

int STAT_N_M25 = 3;
int STAT_N_M50 = 4;
int STAT_N_M75 = 5;

int STAT_N_Min = 6;
int STAT_N_Ave = 7;
int STAT_N_Max = 8;

String[] STAT_N_Title = {
  "Mid-Low",
  "Middle",
  "Mid-High",

  "25th Percentile",
  "50th P.(Median)",
  "75th Percentile",

  "Minimum",
  "Average",
  "Maximum"
};

int[] STAT_reverse_N;
{
  STAT_reverse_N = new int [9];
  STAT_reverse_N[STAT_N_MidLow] = STAT_N_MidHigh;
  STAT_reverse_N[STAT_N_Middle] = STAT_N_Middle;
  STAT_reverse_N[STAT_N_MidHigh] = STAT_N_MidLow;
  STAT_reverse_N[STAT_N_M25] = STAT_N_M75;
  STAT_reverse_N[STAT_N_M50] = STAT_N_M50;
  STAT_reverse_N[STAT_N_M75] = STAT_N_M25;
  STAT_reverse_N[STAT_N_Min] = STAT_N_Max;
  STAT_reverse_N[STAT_N_Ave] = STAT_N_Ave;
  STAT_reverse_N[STAT_N_Max] = STAT_N_Min;
}

float[] SOLARCHVISION_NORMAL (float[] _values) {

  float[] weight_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  float[] return_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };

  int NV = 0; // the number of values without counting undefined values
  float _weight = 0;

  _values = sort(_values);
  for (int i = 0; i < _values.length; i++) {
    if (is_defined(_values[i])) NV += 1;
  }

  if (NV > 0) {
    for (int i = 0; i < NV; i++) {
      if (is_defined(_values[i])) {
        _weight = 1;
        weight_array[STAT_N_Ave] += _weight;
        return_array[STAT_N_Ave] += _values[i];

        _weight = (0.5 * (NV + 1)) - abs((0.5 * (NV + 1)) - (i + 1));
        weight_array[STAT_N_Middle] += _weight;
        return_array[STAT_N_Middle] += _values[i] * _weight;

        _weight = (i + 1);
        weight_array[STAT_N_MidHigh] += _weight;
        return_array[STAT_N_MidHigh] += _values[i] * _weight;

        _weight = (NV + 1 - i);
        weight_array[STAT_N_MidLow] += _weight;
        return_array[STAT_N_MidLow] += _values[i] * _weight;
      }
    }

    return_array[STAT_N_Ave] /= weight_array[STAT_N_Ave];
    return_array[STAT_N_Middle] /= weight_array[STAT_N_Middle];
    return_array[STAT_N_MidHigh] /= weight_array[STAT_N_MidHigh];
    return_array[STAT_N_MidLow] /= weight_array[STAT_N_MidLow];

    return_array[STAT_N_Max] = _values[(NV - 1)];
    return_array[STAT_N_Min] = _values[0];

    if ((NV % 2) == 1) {

      return_array[STAT_N_M50] = _values[(floor(NV / 2))];
    } else {

      return_array[STAT_N_M50] = 0.5 * (_values[(floor(NV / 2))] + _values[(floor(NV / 2) - 1)]);
    }

    int q;

    q = int(funcs.roundTo((NV * 0.75), 1));
    if (q > NV - 1) q = NV - 1;
    return_array[STAT_N_M75] = _values[q];

    q = int(funcs.roundTo((NV * 0.25), 1));
    if (q < 0) q = 0;
    return_array[STAT_N_M25] = _values[q];
  } else {
    for (int i = 0; i < return_array.length; i++) {
      return_array[i] = FLOAT_undefined;
    }
  }

  return return_array;
}



int SOLARCHVISION_filter (int dataID, int cloudCover_id, int type_of_filter, int scenario_of_sky, int now_i, int now_j, int now_k) {

  float total_sky = 0;
  int num_sky = 0;

  int start_q = now_i;
  int end_q = now_i;

  if (type_of_filter == filter_DAILY) {
    start_q = 0;
    end_q = 23;
  }

  for (int q = start_q; q <= end_q; q++) {
    float _sky = FLOAT_undefined;
    if (dataID == dataID_ENSEMBLE_OBSERVED)      _sky = ENSEMBLE_OBSERVED_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_ENSEMBLE_FORECAST) _sky = ENSEMBLE_FORECAST_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CWEEDS)    _sky = CLIMATE_CWEEDS_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CLMREC)    _sky = CLIMATE_CLMREC_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_TMYEPW)    _sky = CLIMATE_TMYEPW_values   [q][now_j][cloudCover_id][now_k];
    else {
      println("ERROR: This dataID is not declared:", dataID);
    }

    if (is_undefined(_sky)) {
    } else {
      total_sky += _sky;
      num_sky += 1;
    }
  }


  int _return = 0;

  if (num_sky != 0) {
    total_sky /= num_sky;

    if (scenario_of_sky == 1) _return = 1;
    else if ((scenario_of_sky == 4) && (total_sky <= 3.33)) _return = 1;
    else if ((scenario_of_sky == 3) && (total_sky > 3.33) && (total_sky <= 6.66)) _return = 1;
    else if ((scenario_of_sky == 2) && (total_sky > 6.66)) _return = 1;
  }

  return _return;
}


int[] SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS (float[] _values) {

  float[] _normals = SOLARCHVISION_NORMAL(_values);

  int[] return_array = new int [9];

  for (int l = 0; l < 9; l++) {
    return_array[l] = -1;
    if (is_defined(_normals[l])) {

      float _dist = FLOAT_undefined;

      for (int i = 0; i < _values.length; i++) {
        if (_dist > abs(_normals[l] - _values[i])) {
          _dist = abs(_normals[l] - _values[i]);
          return_array[l] = i;
        }
      }
    } else return_array[l] = -1;
  }

  return return_array;
}


int[] SOLARCHVISION_PROCESS_DAILY_SCENARIOS (int start_k, int end_k, int j, float DATE_ANGLE) {

  int count_k = 1 + end_k - start_k;
  if (count_k < 0) count_k = 0;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  float[] valuesSUM_RAD;
  float[] valuesSUM_EFF;
  float[] valuesNUM;
  valuesSUM_RAD = new float [(count_k * STUDY.joinDays)];
  valuesSUM_EFF = new float [(count_k * STUDY.joinDays)];
  valuesNUM = new float [(count_k * STUDY.joinDays)];

  for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {
    for (int k = 0; k < count_k; k++) {
      valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] = FLOAT_undefined;
      valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] = FLOAT_undefined;
      valuesNUM[(k * STUDY.joinDays + j_ADD)] = 0;
    }
  }

  for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {

    for (int k = 0; k < count_k; k++) {

      for (int i = 0; i < 24; i++) {

        float HOUR_ANGLE = i;
        float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

        int now_k = k + start_k;
        int now_i = i;
        int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
        Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
        Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
        Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

        if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
        } else {

          int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);

          if (memberCount == 1) {
            values_R_dir = 0.001 * Pa;
            values_R_dif = 0.001 * Pb;
            values_E_dir = 0.0001 * Pc;
            values_E_dif = 0; //0.0001 * Pd;

            if (is_undefined(valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)])) {
              valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] = 0;
              valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] = 0;
              valuesNUM[(k * STUDY.joinDays + j_ADD)] = 0;
            }

            valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] += ((values_R_dir * SunR[3]) + (values_R_dif)); // calculates total horizontal radiation
            valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] += ((values_E_dir * SunR[3]) + (values_E_dif)); // calculates total horizontal effects
            valuesNUM[(k * STUDY.joinDays + j_ADD)] += 1;
          }
        }
      }
    }
  }

  if (Impact_TYPE == Impact_PASSIVE)
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(valuesSUM_EFF);
  else
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(valuesSUM_RAD);
}

























int FrameVariation = 0;

void SOLARCHVISION_update_frame_layout () {

  if (FrameVariation == 0) {

    STUDY.include = true;
    WIN3D.include = true;
    WORLD.include = true;

    WIN3D.cX = SOLARCHVISION_pixel_W;;
    WIN3D.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WIN3D.dX = SOLARCHVISION_pixel_W;
    WIN3D.dY = SOLARCHVISION_pixel_H;
    WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

    WORLD.cX = 0;
    WORLD.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WORLD.dX = SOLARCHVISION_pixel_W;
    WORLD.dY = SOLARCHVISION_pixel_H;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + SOLARCHVISION_pixel_H;
    STUDY.dX = 2 * SOLARCHVISION_pixel_W;
    STUDY.dY = 1 * SOLARCHVISION_pixel_H;
    STUDY.view_R = float(STUDY.dY) / float(STUDY.dX);
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 1) {

    STUDY.include = false;
    WIN3D.include = true;
    WORLD.include = false;

    WIN3D.cX = 0;
    WIN3D.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WIN3D.dX = 2 * SOLARCHVISION_pixel_W;
    WIN3D.dY = 2 * SOLARCHVISION_pixel_H;
    WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);
  } else if (FrameVariation == 2) {

    STUDY.include = true;
    WIN3D.include = false;
    WORLD.include = false;

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    STUDY.dX = 2 * SOLARCHVISION_pixel_W;
    STUDY.dY = 2 * SOLARCHVISION_pixel_H;
    STUDY.view_R = float(STUDY.dY) / float(STUDY.dX);
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 3) {

    STUDY.include = false;
    WIN3D.include = false;
    WORLD.include = true;

    WORLD.cX = 0;
    WORLD.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WORLD.dX = 2 * SOLARCHVISION_pixel_W;
    WORLD.dY = 2 * SOLARCHVISION_pixel_H;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);
  }

  WORLD.revise();
  WIN3D.revise();
  STUDY.revise();
}




void keyPressed (KeyEvent e) {

  //println("key: " + key);
  //println("keyCode: " + keyCode);

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;

      if ((UI_menuBar.selected_parent != -1) || (UI_menuBar.selected_child != 0)) {

        UI_menuBar.selected_parent = -1;
        UI_menuBar.selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_pixel_A);
      }

      addNewSelectionToPreviousSelection = 0;


      if (typeUserCommand == 0) {

        UI_commandBar.updated();

        STUDY.keyPressed(e);
        WORLD.keyPressed(e);
        WIN3D.keyPressed(e);
      }
      else {

        UI_commandBar.revise();

        COMIN_keyPressed(e);
      }


      if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

        if (key != CODED) {
          switch(key) {

            case TAB:
              if (e.isShiftDown() != true) {
                typeUserCommand = (typeUserCommand + 1) % 2;
                UI_commandBar.revise();
              }
              break;
          }

        }
      }

      if ((STUDY.update) || (WORLD.update) || (WIN3D.update) || (ROLLOUT.update)) redraw();
    }
  }
}

void keyReleased () {

  addNewSelectionToPreviousSelection = 0;
}

































void SOLARCHVISION_export_objects_SCR () {

  String fileBasename = ProjectName;

  String scrFilename = Folder_Export3D + "/" + fileBasename + ".scr";

  PrintWriter scrOutput = createWriter(scrFilename);

  scrOutput.println("-osnap off");

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if ((allFaces.nodes[f].length == 3) || (allFaces.nodes[f].length == 4)) {

      scrOutput.println("3dface");

      for (int j = 0; j < allFaces.nodes[f].length; j++) {

        float x = allPoints.getX(allFaces.nodes[f][j]);
        float y = allPoints.getY(allFaces.nodes[f][j]);
        float z = allPoints.getZ(allFaces.nodes[f][j]);

        scrOutput.println(nf(x, 0, User3D.export_PrecisionVertex) + "," + nf(y, 0, User3D.export_PrecisionVertex) + "," + nf(z, 0, User3D.export_PrecisionVertex));
      }
      scrOutput.println();
      scrOutput.println();
    }
  }

  for (int f = 0; f < allCurves.nodes.length; f++) {

    scrOutput.println("line");

    for (int j = 0; j < allCurves.nodes[f].length; j++) {

      float x = allPoints.getX(allCurves.nodes[f][j]);
      float y = allPoints.getY(allCurves.nodes[f][j]);
      float z = allPoints.getZ(allCurves.nodes[f][j]);

      scrOutput.println(nf(x, 0, User3D.export_PrecisionVertex) + "," + nf(y, 0, User3D.export_PrecisionVertex) + "," + nf(z, 0, User3D.export_PrecisionVertex));
    }

    if (allCurves.getMaterial(f) == 1) {
      scrOutput.println("c");
    }
    else {
      scrOutput.println();
    }
  }

  scrOutput.println("zoom e");

  scrOutput.flush();
  scrOutput.close();

  println("End of scripting lines and meshes.");

  println("File created:" + scrFilename);
}


PrintWriter radOutput;

void SOLARCHVISION_export_objects_RAD () {

  String fileBasename = ProjectName;

  String radFilename = Folder_Export3D + "/" + fileBasename + ".rad";

  radOutput = createWriter(radFilename);

  radOutput.println("#SOLARCHVISION");
  radOutput.println();



  Land3D.draw(TypeWindow.RAD3D);

  allFaces.draw(TypeWindow.RAD3D);



  for (int i = 15; i < 180; i += 15) {
    radOutput.println("!gensky -ang " + nf(i, 0) + " 45 +s -trb 4.0");
  }

  radOutput.flush();
  radOutput.close();

  println("End of creating rad file.");

  println("File created:" + radFilename);


  String batFilename = radFilename.replace(".rad", ".bat");
  PrintWriter batOutput = createWriter(batFilename);

  String Command1 = "oconv " + radFilename;
  String octFilename = radFilename.replace(".rad", ".oct");
  Command1 += " > " + octFilename;
  batOutput.println(Command1);

  String Command2 = "rvu";

  //Command2 += " -vtl"; //parallel
  Command2 += " -vtv"; //perspective
  //Command2 += " -vth"; //hemispherical
  //Command2 += " -vtc"; //cylindrical
  //Command2 += " -vta"; //angular
  //Command2 += " -vts"; //stereographic

  Command2 += " -vv " + nf(WIN3D.Zoom, 0, 0);
  Command2 += " -vh " + nf(2 * funcs.atan_ang((WIN3D.dX / float(WIN3D.dY)) * funcs.tan_ang(0.5 * WIN3D.Zoom)), 0, 0);

  Command2 += " -vp " + nf(WIN3D.CAM_x / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_y / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_z / OBJECTS_scale, 0, 0);

  float dx = funcs.cos_ang(90 - WIN3D.rotation_X) * funcs.cos_ang(90 - WIN3D.rotation_Z);
  float dy = funcs.cos_ang(90 - WIN3D.rotation_X) * funcs.sin_ang(90 - WIN3D.rotation_Z);
  float dz = funcs.sin_ang(90 - WIN3D.rotation_X);

  Command2 += " -vd " + nf(-dx , 0, 0) + " " + nf(dy, 0, 0) + " " + nf(-dz, 0, 0);

  float ux = 0;
  float uy = 0;
  float uz = 1;
  if (abs(dz) > 0.99) {
    ux = funcs.cos_ang(90 + WIN3D.rotation_Z);
    uy = funcs.sin_ang(90 + WIN3D.rotation_Z);
    uz = 0;
  }
  Command2 += " -vu " + nf(ux, 0, 0) + " " + nf(uy, 0, 0) + " " + nf(uz, 0, 0);







  Command2 += " -av 0.5 0.5 0.5";
  Command2 += " -pe 0.001";
  Command2 += " -ab 1";
  Command2 += " " + octFilename.replace('/', char(92));
  batOutput.println(Command2);

  batOutput.println("cmd /k"); // leave command prompt open

  batOutput.flush();
  batOutput.close();


}



PrintWriter htmlOutput;

void SOLARCHVISION_export_objects_HTML () {

  String fileBasename = ProjectName;

  String htmlFilename = Folder_Export3D + "/" + fileBasename + ".html";

  htmlOutput = createWriter(htmlFilename);

  htmlOutput.println("<html>");
  htmlOutput.println("\t<head>");
  htmlOutput.println("\t\t<title>" + ProjectName + "</title>");
  htmlOutput.println("\t\t<script type='text/javascript' src='https://www.x3dom.org/download/x3dom.js'></script>");
  htmlOutput.println("\t\t<link rel='stylesheet' type='text/css' href='https://www.x3dom.org/download/x3dom.css'></link>");
  htmlOutput.println("\t</head>");
  htmlOutput.println("\t<body>");
  htmlOutput.println("\t\t<x3d width='900px' height='600px'>");
  htmlOutput.println("\t\t\t<scene>");

  htmlOutput.println("\t\t\t\t<viewpoint position='0 0 100'></Viewpoint>");
/*
{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM00'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM01'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_X * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM02'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM03'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_X * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM04'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM05'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}
*/


  Earth3D.draw(TypeWindow.HTML);

  Land3D.draw(TypeWindow.HTML);

  Tropo3D.draw(TypeWindow.HTML, STUDY.i_Start, STUDY.i_End);

  allSections.draw(TypeWindow.HTML);

  allModel2Ds.draw(TypeWindow.HTML);

  allFaces.draw(TypeWindow.HTML);





  htmlOutput.println("\t\t\t</scene>");
  htmlOutput.println("\t\t</x3d>");

/*
  htmlOutput.println("\t\t<div id='camera_buttons' style='display: block;'>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM00').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM00<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM01').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM01<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM02').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM02<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM03').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM03<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM04').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM04<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM05').setAttribute('set_bind","true');\" style='border: none; background: transparent; display: block'>CAM05<br><img src='camera.png'></button>");
  htmlOutput.println("\t\t</div>");
*/

  htmlOutput.println("\t</body>");
  htmlOutput.println("</html>");

  htmlOutput.flush();
  htmlOutput.close();

  println("End of creating html file.");

  println("File created:" + htmlFilename);

}



void SOLARCHVISION_export_objects_OBJ_timeSeries () {

  int keep_STUDY_i_Start = STUDY.i_Start;

  for (int i = 0; i < 24; i++) {

    STUDY.i_Start = i;

    SOLARCHVISION_find_which_bakings_to_regenerate();
    SOLARCHVISION_regenerate_desired_bakings();


    SOLARCHVISION_export_objects_OBJ("_" + nf(i, 2));

  }

  STUDY.i_Start = keep_STUDY_i_Start;
}



void SOLARCHVISION_export_objects_OBJ_dateSeries () {

  int keep_IMPACTS_displayDay = IMPACTS_displayDay;

  for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {

    IMPACTS_displayDay = j;

    SOLARCHVISION_export_objects_OBJ("_" + nf(j, 3));

  }

  IMPACTS_displayDay = keep_IMPACTS_displayDay;
}




PrintWriter mtlOutput;
PrintWriter objOutput;


int obj_lastVertexNumber;
int obj_lastVtextureNumber;
int obj_lastFaceNumber;
int obj_lastGroupNumber;



int num_vertices_added = 0;

void SOLARCHVISION_export_objects_OBJ (String suffix) {

  String fileBasename = ProjectName + suffix;

  String objFilename = Folder_Export3D + "/" + fileBasename + ".obj";
  String mtlFilename = Folder_Export3D + "/" + fileBasename + ".mtl";


  if (User3D.export_MaterialLibrary) {
    mtlOutput = createWriter(mtlFilename);
    mtlOutput.println("#SOLARCHVISION");
  }

  objOutput = createWriter(objFilename);
  objOutput.println("#SOLARCHVISION");
  if (User3D.export_MaterialLibrary) {
    objOutput.println("mtllib " + fileBasename + ".mtl");
  }

  obj_lastVertexNumber = 0;
  obj_lastVtextureNumber = 0;
  obj_lastFaceNumber = 0;
  obj_lastGroupNumber = 0;






  Earth3D.draw(TypeWindow.OBJ3D);

  Land3D.draw(TypeWindow.OBJ3D);

  Tropo3D.draw(TypeWindow.OBJ3D, STUDY.i_Start, STUDY.i_End);

  allSections.draw(TypeWindow.OBJ3D);

  allModel1Ds.draw(TypeWindow.OBJ3D);

  allModel2Ds.draw(TypeWindow.OBJ3D);

  allFaces.draw(TypeWindow.OBJ3D);

  allWindFlows.draw(TypeWindow.OBJ3D);

  Sky3D.draw(TypeWindow.OBJ3D);

  if (Sun3D.displayPattern) {

    float keep_STUDY_perDays = STUDY.perDays;
    int keep_STUDY_joinDays = STUDY.joinDays;
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
        (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      STUDY.perDays = 1;
      STUDY.joinDays = 1;
    }

    float previous_DATE = TIME.date;

    Sun3D.drawCycles(TypeWindow.STUDY, 0, 0, 0, 0.975 * Sky3D.scale);

    STUDY.perDays = keep_STUDY_perDays;
    STUDY.joinDays = keep_STUDY_joinDays;
    TIME.date = previous_DATE;
    TIME.updateDate();
  }

  if (User3D.export_MaterialLibrary) {
    mtlOutput.flush();
    mtlOutput.close();
  }

  objOutput.flush();
  objOutput.close();


  println("End of exporting the mesh.");

  println("File created:" + objFilename);
}

void SOLARCHVISION_OBJprintVertex (float x, float y, float z) {

  float a = x * User3D.export_Scale;
  float b = y * User3D.export_Scale;
  float c = z * User3D.export_Scale;

  if (User3D.export_FlipZYaxis == 0) {

    objOutput.println("v " + nf(a, 0, User3D.export_PrecisionVertex) + " " +  nf(b, 0, User3D.export_PrecisionVertex) + " " +  nf(c, 0, User3D.export_PrecisionVertex));
  } else {

    objOutput.println("v " + nf(-a, 0, User3D.export_PrecisionVertex) + " " +  nf(c, 0, User3D.export_PrecisionVertex) + " " +  nf(b, 0, User3D.export_PrecisionVertex));
  }
}



void SOLARCHVISION_OBJprintVtexture (float u, float v, float w) {

  objOutput.println("vt " + nf(u, 0, User3D.export_PrecisionVtexture) + " " + nf(v, 0, User3D.export_PrecisionVtexture) + " " + nf(w, 0, User3D.export_PrecisionVtexture));
}


void SOLARCHVISION_HTMLprintVtexture (float u, float v) {

  htmlOutput.print(nf(u, 0, User3D.export_PrecisionVtexture) + " " + nf(v, 0, User3D.export_PrecisionVtexture));
}


String importedObjectName = "";

void SOLARCHVISION_import_objects_OBJ (String FileName, int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz) {

  if (m == -1) current_Material = 0;
  else current_Material = m;

  int[] importVerticeNumber = {
    0
  };

  String[] FileALL = loadStrings(FileName);

  importedObjectName = OPESYS.getFilenameFromPath(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  float Progress = 0;

  for (int f = 0; f < FileALL.length; f++) {

    if (1 + Progress < 100 * f / float(FileALL.length)) {
      Progress = 100 * f / float(FileALL.length);
      println("Progress:", int(Progress), "%");
    }

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("g")) {
      if (m == -1) current_Material = 1 + (current_Material % 8);

      if (addToLastGroup == false) allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      int[] v = {
        allPoints.create(x, y, z)
      };

      importVerticeNumber = concat(importVerticeNumber, v);
    }

    if (parts[0].toLowerCase().equals("f")) {

      //println(parts);

      int FaceDegree = parts.length - 1; // if we don't have space at the end of the line.

      if (parts[FaceDegree].equals("")) {  // if we have 1 space at the end of the line.
        FaceDegree -= 1;
      }

      int[] newFace = new int [FaceDegree];

      for (int n = 0; n < newFace.length; n++) {

        String[] the_numbers = split(parts[n + 1], '/');

        int vertexNumber = int(the_numbers[0]);

        if (vertexNumber > 0) {
          newFace[n] = importVerticeNumber[vertexNumber];
        } else if (vertexNumber < 0) { // for negative numbering
          newFace[n] = allPoints.getLength() - abs(vertexNumber);
        } else { // case 0
        }
      }

      //println(newFace);

      allFaces.create(newFace);
    }
  }

  println("Progress: 100 %");
}






float SOLARCHVISION_import_objects_asParametricBox_OBJ (String FileName, int m, float cx, float cy, float cz, float sx, float sy, float sz) {

  float[][] importVertices = {
    {
    }
  };

  String[] FileALL = loadStrings(FileName);

  importedObjectName = OPESYS.getFilenameFromPath(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      float[][] v = {
        {
          x, y, z
        }
      };

      importVertices = (float[][]) concat(importVertices, v);
    }
  }

  float min_X = FLOAT_undefined;
  float max_X = -FLOAT_undefined;
  float min_Y = FLOAT_undefined;
  float max_Y = -FLOAT_undefined;
  float min_Z = FLOAT_undefined;
  float max_Z = -FLOAT_undefined;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    if (min_X > x) min_X = x;
    if (max_X < x) max_X = x;
    if (min_Y > y) min_Y = y;
    if (max_Y < y) max_Y = y;
    if (min_Z > z) min_Z = z;
    if (max_Z < z) max_Z = z;
  }

  float cen_X = 0.5 * (min_X + max_X);
  float cen_Y = 0.5 * (min_Y + max_Y);
  float cen_Z = 0.5 * (min_Z + max_Z);

  float R_out = 0;
  float X_out = 0;
  float Y_out = 0;
  float Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    float r = dist(cen_X, cen_Y, cen_Z, x, y, z);

    if (R_out < r) {
      R_out = r;

      X_out = x;
      Y_out = y;
      Z_out = z;
    }
  }

  float T_out = funcs.atan2_ang(Y_out, X_out);

  X_out = 0;
  Y_out = 0;
  Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = (importVertices[vNo][0] - cen_X) * funcs.cos_ang(-T_out) - (importVertices[vNo][1] - cen_Y) * funcs.sin_ang(-T_out);
    float y = (importVertices[vNo][0] - cen_X) * funcs.sin_ang(-T_out) + (importVertices[vNo][1] - cen_Y) * funcs.cos_ang(-T_out);
    float z = importVertices[vNo][2];

    if (X_out < abs(x)) X_out = abs(x);
    if (Y_out < abs(y)) Y_out = abs(y);
    if (Z_out < abs(z)) Z_out = abs(z);
  }

  //Create3D.add_Box_Core(m, cen_X,cen_Y,cen_Z, X_out,Y_out,Z_out, T_out);
  allSolids.create(cen_X, cen_Y, cen_Z, CubePower, CubePower, CubePower, X_out, Y_out, Z_out, 0, 0, T_out, 1);

  return min_Z;
}












void SOLARCHVISION_deleteAll () {

  allModel1Ds.makeEmpty(0);
  allModel2Ds.makeEmpty(0);

  allCurves.makeEmpty(0);
  allFaces.makeEmpty(0);

  allPoints.makeEmpty(0);

  allSolids.makeEmpty(0);
  allSections.makeEmpty(0);
  allCameras.makeEmpty(0);

  allGroups.makeEmpty(0);

}





void SOLARCHVISION_model_added () {

  Select3D.selectLast();

  SOLARCHVISION_selection_changed();
}

void SOLARCHVISION_model_changed () {
  SOLARCHVISION_view_changed();
}


void SOLARCHVISION_view_changed () {
  WIN3D.revise();
}


void SOLARCHVISION_selection_changed () {

  Select3D.reset_selectedRefValues();

  Select3D.revise_BoundingBox();

  SOLARCHVISION_view_changed();
}


void SOLARCHVISION_switch_category (int a) {

  current_ObjectCategory = a;

  UI_toolBar.revise();

  SOLARCHVISION_selection_changed();
}




























float OBJECTS_scale = 1.0;


int SKY2D_X_View = 50;
int SKY2D_Y_View = 50;
float SKY2D_ZOOM = 5;
PGraphics SKY2D_graphics;


void ViewFromTheSky (float SKY2D_position_X, float SKY2D_position_Y, float SKY2D_position_Z, float SKY2D_rotation_X, float SKY2D_rotation_Y, float SKY2D_rotation_Z) {

  SKY2D_graphics.beginDraw();

  SKY2D_graphics.background(233);

  SKY2D_graphics.ortho(SKY2D_X_View / -SKY2D_ZOOM, SKY2D_X_View / SKY2D_ZOOM, SKY2D_Y_View / -SKY2D_ZOOM, SKY2D_Y_View / SKY2D_ZOOM, 0.00001, 100000);

  SKY2D_graphics.translate(0, 1.0 * SKY2D_Y_View, 0); // << IMPORTANT!

  SKY2D_graphics.translate(SKY2D_position_X, SKY2D_position_Y, SKY2D_position_Z);
  SKY2D_graphics.rotateX(SKY2D_rotation_X * PI / 180);
  SKY2D_graphics.rotateY(SKY2D_rotation_Y * PI / 180);
  SKY2D_graphics.rotateZ(SKY2D_rotation_Z * PI / 180);

  SKY2D_graphics.hint(ENABLE_DEPTH_TEST);

  Land3D.draw(TypeWindow.SKY2D);

  for (int f = 0; f < allFaces.nodes.length; f++) {

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      color c = color(0, 0, 0);

      int mt = allFaces.getMaterial(f);
      c = color(allMaterials.Color[mt][1], allMaterials.Color[mt][2], allMaterials.Color[mt][3], allMaterials.Color[mt][0]);

      SKY2D_graphics.stroke(c);
      SKY2D_graphics.fill(c);

      int tessellation = allFaces.getTessellation(f);

      int totalNumberOfSubs = 1;
      if (allFaces.getMaterial(f) == 0) {
        tessellation += allFaces.displayTessellation;
      }
      if (tessellation > 0) totalNumberOfSubs = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }

      for (int n = 0; n < totalNumberOfSubs; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

        SKY2D_graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {

          SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
        }

        SKY2D_graphics.endShape(CLOSE);
      }
    }
  }

  SKY2D_graphics.endDraw();
}






















int getLocationTimeZone () {
  return int(funcs.roundTo(STATION.getLongitude() / 15, 15));
}


int[] getNow_inUTC () {

  int LocationTimeZone = getLocationTimeZone();

  int CurrentYear = year();
  int CurrentMonth = month();
  int CurrentDay = day();
  int CurrentHour = hour();


  // converting from local time to global time

  if (LocationTimeZone > 0) {
    CurrentHour -= LocationTimeZone;

    if (CurrentHour < 0) {
      CurrentHour += 24;
      CurrentDay -= 1;

      if (CurrentDay < 1) {

        CurrentMonth -= 1;

        if (CurrentMonth < 1) {
          CurrentMonth = 12;
          CurrentYear -= 1;
        }

        CurrentDay = TIME.lengthOfMonths[CurrentMonth - 1];
      }
    }
  }
  else if (LocationTimeZone < 0) {
    CurrentHour += abs(LocationTimeZone);

    if (CurrentHour > 23) {
      CurrentHour -= 24;
      CurrentDay += 1;

      if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) {
        CurrentDay = 1;
        CurrentMonth += 1;

        if (CurrentMonth > 12) {
          CurrentMonth = 1;
          CurrentYear += 1;
        }
      }
    }
  }

  int[] return_array = {CurrentYear, CurrentMonth, CurrentDay, CurrentHour};

  return return_array;
}






class solarchvision_Tropo3D {

  private final static String CLASS_STAMP = "Tropo3D";


  boolean displaySurface = false;
  boolean displayTexture = true;

  String[] Filenames;
  PImage[] Map;

  float[][] BoundariesX;
  float[][] BoundariesY;


  void resize_images () {

    this.Filenames = new String [TROPO_timeSteps];
    this.Map = new PImage [TROPO_timeSteps];

    this.BoundariesX = new float[TROPO_timeSteps][2];
    this.BoundariesY = new float[TROPO_timeSteps][2];

    for (int i = 0; i < TROPO_timeSteps; i++) {

      this.Filenames[i] = "";
      this.Map[i] = createImage(2, 2, RGB); // empty and small

      this.BoundariesX[i][0] = 0;
      this.BoundariesX[i][1] = 0;
      this.BoundariesY[i][0] = 0;
      this.BoundariesY[i][1] = 0;

    }
  }


  void load_images () {

    String[] allFilenames = sort(OPESYS.getFiles(Folder_GEOMET));



    int LocationTimeZone = getLocationTimeZone();

    int[] rightNow = getNow_inUTC();

    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];

    for (int i = 0; i < TROPO_timeSteps; i++) {

      CurrentHour += 1;

      if (CurrentHour > 23) {
        CurrentHour -= 24;
        CurrentDay += 1;

        if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) {
          CurrentDay = 1;
          CurrentMonth += 1;

          if (CurrentMonth > 12) {
            CurrentMonth = 1;
            CurrentYear += 1;
          }
        }
      }



      for (int q = 0; q < allFilenames.length; q++) {

        String[] Parts = split(allFilenames[q], '_');

        //if (Parts[0].equals(nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2))) {
        if (Parts[0].equals(nf((CurrentHour + LocationTimeZone) % 24, 2))) {

          this.Filenames[i] = allFilenames[q];

          this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
          this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
          this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
          this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;

          println("Loading:", Folder_GEOMET + "/" + this.Filenames[i]);

          this.Map[i] = loadImage(Folder_GEOMET + "/" + this.Filenames[i]);

          break;
        }
      }

    }

    SOLARCHVISION_view_changed();
  }


  void download_images () {

    int LocationTimeZone = getLocationTimeZone();

    int[] rightNow = getNow_inUTC();

    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];

    for (int i = 0; i < TROPO_timeSteps; i++) {

      if (WMS_type == DataType.SATELLITE_GOES) {

        CurrentHour -= 1;

        if (CurrentHour < 0) {
          CurrentHour += 24;
          CurrentDay -= 1;

          if (CurrentDay < 0) {

            CurrentMonth -= 1;

            if (CurrentMonth < 0) {
              CurrentMonth = 12;
              CurrentYear -= 1;
            }

            CurrentDay = TIME.lengthOfMonths[CurrentMonth - 1];
          }
        }

      }
      else {

        CurrentHour += 1;

        if (CurrentHour > 23) {
          CurrentHour -= 24;
          CurrentDay += 1;

          if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) {
            CurrentDay = 1;
            CurrentMonth += 1;

            if (CurrentMonth > 12) {
              CurrentMonth = 1;
              CurrentYear += 1;
            }
          }
        }

      }
      String the_service = "";

      if (WMS_type == DataType.SATELLITE_GOES) {
        the_service = "https://mesonet.agron.iastate.edu/cgi-bin/wms/goes/east_vis.cgi";
      }
      else {
        the_service = "https://geo.weather.gc.ca/geomet/";
      }


      String the_link = the_service + "?SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&FORMAT=image%2Fpng&TRANSPARENT=true";


      String ParameterStamp = "";

      if (WMS_type == DataType.SATELLITE_GOES) {
        ParameterStamp = "";
      }
      else {
        ParameterStamp = "_NT&STYLES=CLOUD"; // Cloud cover
        //ParameterStamp = "_GZ&STYLES=DEFAULT"; // Geopotential height (Value range mapping)
        //ParameterStamp = "_UU&STYLES=WINDSPEED"; // Windspeed in knots
        //ParameterStamp = "_UU&STYLES=WINDSPEEDKMH"; // Windspeed in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROWKMH"; // Wind arrows in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROW"; // Wind arrows in knots
        //ParameterStamp = "_TT&STYLES=TEMPERATURE"; // Air temperature
        //ParameterStamp = "_TT&STYLES=TEMPSUMMER"; // Air temperaturesummer range
        //ParameterStamp = "_TT&STYLES=TEMPWINTER"; // Air temperaturewinter range
        //ParameterStamp = "_ES&STYLES=DEWPOINTDEP"; // Dew point depression
        //ParameterStamp = "_P0&STYLES=PRESSURE"; // Surface pressure
        //ParameterStamp = "_PN&STYLES=PRESSURE4_LINE"; // Sea level pressure contour 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURE4"; // Sea level pressure 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURESEAHIGH"; // Sea level pressure high range
        //ParameterStamp = "_PN&STYLES=PRESSURESEALOW"; // Sea level pressure low range
        //ParameterStamp = "_PR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_PR&STYLES=CAPA24"; // Precipitations in millimeters (CaPA24)
        //ParameterStamp = "_RT&STYLES=PRECIPRTMMH"; // Rate of precipitations in millimeters per hour
        //ParameterStamp = "_RN&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_FR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_SN&STYLES=PRECIPSNOW"; // Precipitations in centimeters
        //ParameterStamp = "_I0&STYLES=TEMPSOIL"; // Soil Temperature
        //ParameterStamp = "_I1&STYLES=WATERCONTENT"; // Water content
        //ParameterStamp = "_I2&STYLES=ICECONTENT"; // Soil volumetric ice content
        //ParameterStamp = "_I3&STYLES=WATERRETAINED"; // Water retained on the vegetation
        //ParameterStamp = "_I4&STYLES=WATERRETAINED"; // Water retained in the snow pack
        //ParameterStamp = "_I5&STYLES=SNOWMASS"; // Snow mass
        //ParameterStamp = "_I8&STYLES=ICETHICK"; // Sea ice thickness

        //ParameterStamp = "_WGE&STYLES=MS2KTSGUST"; // Windgust estimate intervals in knots
        //ParameterStamp = "_WGE&STYLES=MS2KTS"; // Windspeed estimate in knots
        //ParameterStamp = "_WGE&STYLES=MS2KMH"; // Windspeed estimate in km/h

        //ParameterStamp = "_WGN&STYLES=MS2KTSGUST"; // Windgust minimum intervals in knots
        //ParameterStamp = "_WGN&STYLES=MS2KTS"; // Windspeed minimum in knots
        //ParameterStamp = "_WGN&STYLES=MS2KMH"; // Windspeed minimum in km/h

        //ParameterStamp = "_WGX&STYLES=MS2KTSGUST"; // Windgust maximum intervals in knots
        //ParameterStamp = "_WGX&STYLES=MS2KTS"; // Windspeed maximum in knots
        //ParameterStamp = "_WGX&STYLES=MS2KMH"; // Windspeed maximum in km/h
      }



      String DomainStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        DomainStamp = "east_vis_1km";
      }
      else if (WMS_type == DataType.FORECAST_HRDPS) {
        DomainStamp = "HRDPS.CONTINENTAL";
      }
      else if (WMS_type == DataType.FORECAST_RDPS) {
        DomainStamp = "RDPS.ETA";
      }
      else if (WMS_type == DataType.FORECAST_GDPS) {
        DomainStamp = "GDPS.ETA";
      }

      this.BoundariesX[i][0] = STATION.getLongitude() - 15;
      this.BoundariesX[i][1] = STATION.getLongitude() + 15;
      this.BoundariesY[i][0] = STATION.getLatitude() - 15 * funcs.cos_ang(STATION.getLatitude());
      this.BoundariesY[i][1] = STATION.getLatitude() + 15 * funcs.cos_ang(STATION.getLatitude());



      int RES1 = 1200; // 1800;
      int RES2 = 600; // 900;


      the_link += "&LAYERS=" + DomainStamp + ParameterStamp + "&WIDTH=" + nf(RES1, 0) + "&HEIGHT=" + nf(RES2, 0);
      the_link += "&SRS=EPSG%3A4326&BBOX=";
      the_link += nf(this.BoundariesX[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesX[i][1], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][1], 0, 3);

      int the_hour = i * TROPO_deltaTime;

      String timeStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        timeStamp = "&date=" + nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "&time=" + nf(CurrentHour, 2) + ":00";
      }
      else {
        timeStamp = nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "T" + nf(CurrentHour, 2);
      }

      //the_link += "%26time%3D" + timeStamp +"%3A22%3A00Z";
      the_link += "%26time%3D" + timeStamp +"%3A00Z";

      this.Map[i] = createImage(2, 2, RGB); // empty and small

      //String FN = nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2) + "_";
      String FN = nf((CurrentHour + LocationTimeZone) % 24, 2) + "_";
      FN += nf(int(funcs.roundTo(-1000 * this.BoundariesX[i][0], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo( 1000 * this.BoundariesY[i][0], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo(-1000 * this.BoundariesX[i][1], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo( 1000 * this.BoundariesY[i][1], 1)), 6) + "_";
      FN += ".png";

      String the_target = Folder_GEOMET + "/" + FN;

      File dir = new File(the_target);
      if (!dir.isFile()) {

        boolean new_file_downloaded = false;

        println("Try downloading: " + the_link);

        try {
          saveBytes(the_target, loadBytes(the_link));

          new_file_downloaded = true;
        }

        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }

        if (new_file_downloaded) {

          if (ParameterStamp.equals("_NT&STYLES=CLOUD")) {
            println("image processing cloud layer");

            PImage img = loadImage(the_target);
            img.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;

              float COL_A = (COL >> 24 & 0xFF);

              if (COL_A == 0) {
                img.pixels[np] = color(0,0);
              }
              else {
                float COL_V = (COL >> 16 & 0xFF);
                img.pixels[np] = color(255 - 0.125 * COL_V, COL_V);
              }
            }
            img.updatePixels();
            img.save(the_target);
          }




          if (WMS_type == DataType.SATELLITE_GOES) {
            println("image processing cloud layer");

            PImage img = loadImage(the_target);

            img.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;

              float COL_V = (COL >> 16 & 0xFF);

              float N = 3; //3.5; //4;

              if (COL_V < 255 / N) {
                img.pixels[np] = color(191,191,255,255); //color(0,0);
              }
              else {
                img.pixels[np] = color((255 - COL_V) * N / (N - 1), 255);
              }
            }
            img.updatePixels();
            img.save(the_target);
          }

        }

      }
    }

    Tropo3D.load_images();
  }






  void draw (int target_window, int start_hour, int end_hour) {

    ///////////////////////////////// for now we only use the first image
    end_hour = start_hour;
    /////////////////////////////////


    boolean proceed = true;

    if ((displaySurface == false) || (displayTexture == false)) {
      proceed = false;
    }

    if (target_window == TypeWindow.STUDY) {
      proceed = false;
    }

    if (proceed) {

      for (int n_Map = start_hour; n_Map <= end_hour; n_Map++) {

        if (this.Filenames[n_Map].equals("")) { // not to display empty images
          } else {

          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ3D)) {

            if (User3D.export_MaterialLibrary) {

              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='TropoSphere" + nf(n_Map, 0) + "'>");
              }

              if (target_window == TypeWindow.OBJ3D) {

                mtlOutput.println("newmtl TropoSphere" + nf(n_Map, 0));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
              }

              if (Tropo3D.displayTexture) {

                String old_Texture_path = Folder_GEOMET + "/" + this.Filenames[n_Map];

                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

                String new_Texture_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));

                if (target_window == TypeWindow.OBJ3D) {

                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
                }

                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                }

              }
            }

            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t</Appearance>");
            }

            if (target_window == TypeWindow.OBJ3D) {

              if (User3D.export_PolyToPoly == 1) {
                obj_lastGroupNumber += 1;
                objOutput.println("g TropoSphere" + nf(n_Map, 0));
              }

              if (User3D.export_MaterialLibrary) {
                objOutput.println("usemtl TropoSphere" + nf(n_Map, 0));
              }
            }

          }


          float OffsetX = this.BoundariesX[n_Map][0] + 180;
          float OffsetY = this.BoundariesY[n_Map][1] - 90;

          float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
          float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;

          float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
          float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);

          float delta_Alpha = -BIOSPHERE_drawResolution;
          float delta_Beta = -BIOSPHERE_drawResolution;

          float r = FLOAT_r_Earth + 10000;


          num_vertices_added = 0;

          int end_turn = 1;
          if (target_window == TypeWindow.OBJ3D) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {

            int f = 0;
            for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
              for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
                f += 1;

                float[][] subFace = new float [4][7];

                for (int s = 0; s < 4; s++) {

                  float a = Alpha;
                  float b = Beta;

                  if ((s == 2) || (s == 3)) {
                    a += delta_Alpha;
                  }

                  if ((s == 1) || (s == 2)) {
                    b += delta_Beta;
                  }

                  float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a);
                  float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
                  float z0 = r * funcs.sin_ang(a);

                  float _lon = b - CEN_lon;
                  float _lat = a - CEN_lat;

                  if (Tropo3D.displayTexture) {
                    // calculating u and v
                    subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5);
                    subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
                  }

                  // rotating to location coordinates
                  float tb = -STATION.getLongitude();
                  float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
                  float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
                  float z1 = z0;

                  float ta = 90 - STATION.getLatitude();
                  float x2 = x1;
                  float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
                  float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);

                  // move it down!
                  z2 -= FLOAT_r_Earth;

                  subFace[s][0] = x2;
                  subFace[s][1] = y2;
                  subFace[s][2] = z2;

                  subFace[s][5] = a;
                  subFace[s][6] = b;
                }

                boolean UVs_OK = true;

                for (int s = 0; s < subFace.length; s++) {
                  if (subFace[s][3] < 0) UVs_OK = false;
                  if (subFace[s][3] > 1) UVs_OK = false;
                  if (subFace[s][4] < 0) UVs_OK = false;
                  if (subFace[s][4] > 1) UVs_OK = false;
                }

                if (UVs_OK) {

                  if (target_window == TypeWindow.WORLD) {
                    WORLD.graphics.beginShape();
                    WORLD.graphics.noStroke();
                    if (Tropo3D.displayTexture) {
                      WORLD.graphics.texture(this.Map[n_Map]);
                    }

                    for (int s = 0; s < subFace.length; s++) {

                      float _lat = subFace[s][5];
                      float _lon = subFace[s][6];
                      if (_lon > 180) _lon -= 360; // << important!

                      float x_point = WORLD.dX * (( 1 * (_lon - WORLD.oX) / 360.0) + 0.5) / WORLD.sX;
                      float y_point = WORLD.dY * ((-1 * (_lat - WORLD.oY) / 180.0) + 0.5) / WORLD.sY;

                      WORLD.graphics.vertex(x_point, y_point,
                                            subFace[s][3] * this.Map[n_Map].width,
                                            subFace[s][4] * this.Map[n_Map].height);
                    }

                    WORLD.graphics.endShape(CLOSE);

                  }


                  if (target_window == TypeWindow.HTML) {

                    htmlOutput.println("\t\t\t\t<shape>");

                    if (n_Map != -1) {
                      htmlOutput.println("\t\t\t\t\t<Appearance USE='TropoSphere" + nf(n_Map, 0) + "'></Appearance>");
                    }

                    htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided

                    htmlOutput.print  (" coordIndex='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(" ");
                      }
                      htmlOutput.print(nf(s, 0));
                    }
                    htmlOutput.println(" -1'>");

                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(",");
                      }

                      htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                    }
                    htmlOutput.println("'></Coordinate>");

                  }

                  if (target_window == TypeWindow.WIN3D) {

                    WIN3D.graphics.strokeWeight(1);

                    WIN3D.graphics.beginShape();
                    WIN3D.graphics.noStroke();
                    if (Tropo3D.displayTexture) {
                      WIN3D.graphics.texture(this.Map[n_Map]);
                    }
                  }


                  for (int s = 0; s < subFace.length; s++) {

                    float x = subFace[s][0];
                    float y = subFace[s][1];
                    float z = subFace[s][2];
                    float u = subFace[s][3];
                    float v = subFace[s][4];

                    if (u > 1) u = 1;
                    if (u < 0) u = 0;
                    if (v > 1) v = 1;
                    if (v < 0) v = 0;



                    if (target_window == TypeWindow.WIN3D) {

                      WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale,
                                           -y * OBJECTS_scale * WIN3D.scale,
                                            z * OBJECTS_scale * WIN3D.scale,
                                            u * this.Map[n_Map].width,
                                            v * this.Map[n_Map].height);
                    }

                    if (target_window == TypeWindow.OBJ3D) {

                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(x, y, z);
                      }

                      if (_turn == 2) {

                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }

                      if (_turn == 3) {
                        obj_lastVertexNumber += 1;
                        obj_lastVtextureNumber += 1;
                      }
                    }

                    if (target_window == TypeWindow.HTML) {

                      if (n_Map != -1) {

                        if (s == 0) {
                          htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                        }
                        if (s > 0) {
                          htmlOutput.print(",");
                        }

                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                        SOLARCHVISION_HTMLprintVtexture(u, v);

                        if (s == subFace.length - 1) {
                          htmlOutput.println("'></TextureCoordinate>");
                        }
                      }

                    }

                  }


                  if (target_window == TypeWindow.HTML) {

                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

                    htmlOutput.println("\t\t\t\t</shape>");

                  }

                  if (target_window == TypeWindow.WIN3D) {

                    WIN3D.graphics.endShape(CLOSE);
                  }

                  if (target_window == TypeWindow.OBJ3D) {

                    String n1_txt = nf(obj_lastVertexNumber - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber - 0, 0);

                    String m1_txt = nf(obj_lastVtextureNumber - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - 0, 0);

                    if (User3D.export_PolyToPoly == 0) {
                      if (_turn == 3) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g TropoSphere" + nf(n_Map, 0) + "_" + nf(f, 0));
                      }
                    }

                    if (_turn == 3) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (User3D.export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }
                  }
                }

              }
            }
          }
        }
      }
    }
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displaySurface", this.displaySurface);
    XML_setBoolean(parent, "displayTexture", this.displayTexture);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displaySurface = XML_getBoolean(parent, "displaySurface");
    this.displayTexture = XML_getBoolean(parent, "displayTexture");
  }
}

solarchvision_Tropo3D Tropo3D = new solarchvision_Tropo3D();



class solarchvision_Sky3D {

  private final static String CLASS_STAMP = "Sky3D";

  boolean displaySurface = false;
  int displayTessellation = 3; //3;
  float scale = 4000000; //25000; //10000; //10km:Troposphere 25km:Ozone layer 100km:Karman line.


  int ACTIVE_pallet_CLR = 18; //-1; //7; //8;
  int ACTIVE_pallet_DIR = 1; //-1;
  float ACTIVE_pallet_MLT = 0.5; //1; //0.25;

  int PASSIVE_pallet_CLR = 18;
  int PASSIVE_pallet_DIR = -1;
  float PASSIVE_pallet_MLT = 0.2;

  float stp_slp;
  float stp_dir;
  int num_slp;
  int num_dir;

  float calculatedResolution = 2.5; //1, 2.5, 5


  void draw (int target_window) {

    boolean proceed = true;

    if (this.displaySurface == false) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {
      proceed = false;
    }


    if (proceed) {

      int PAL_type = 0;
      int PAL_direction = 1;
      float PAL_multiplier = 1;

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
        PAL_multiplier = this.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
        PAL_multiplier = this.PASSIVE_pallet_MLT;
      }

      if (target_window == TypeWindow.OBJ3D) {

        if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

          String the_filename = "";
          String TEXTURE_path = "";

          if (User3D.export_MaterialLibrary) {

            the_filename = "skyPatternPallet.bmp";

            TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

            println("Saving texture:", TEXTURE_path);

            int RES1 = User3D.export_PalletResolution;
            int RES2 = User3D.export_PalletResolution / 16;

            PImage pallet_Texture = createImage(RES1, RES2, ARGB);


            pallet_Texture.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              float _val = (Image_X / (0.5 * RES1)) - 1;

              float _u = 0.5 + _val;

              if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

              float[] COL = PAINT.getColorStyle(PAL_type, _u);

              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }

            pallet_Texture.updatePixels();

            pallet_Texture.save(TEXTURE_path);


            mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

            //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
          }

          obj_lastGroupNumber += 1;
          objOutput.println("g skyPattern");

          if (User3D.export_MaterialLibrary) {
            objOutput.println("usemtl " +  the_filename.replace('.', '_'));
          }

          num_vertices_added = 0;

          for (int _turn = 1; _turn < 4; _turn++) {

            for (int f = 0; f < skyFaces.length; f++) {

              int tessellation = 0;

              int totalNumberOfSubs = 1;
              tessellation = Sky3D.displayTessellation;
              if (tessellation > 0) totalNumberOfSubs = skyFaces[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

              float[][] base_Vertices = new float [skyFaces[f].length][3];
              for (int j = 0; j < skyFaces[f].length; j++) {
                int vNo = skyFaces[f][j];
                base_Vertices[j][0] = skyVertices[vNo][0];
                base_Vertices[j][1] = skyVertices[vNo][1];
                base_Vertices[j][2] = skyVertices[vNo][2];
              }

              for (int n = 0; n < totalNumberOfSubs; n++) {

                float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

                for (int j = 0; j < subFace.length; j++) {
                  subFace[j] = funcs.vec3_unit(subFace[j]);
                }



                for (int s = 0; s < subFace.length; s++) {

                  int s_next = (s + 1) % subFace.length;
                  int s_prev = (s + subFace.length - 1) % subFace.length;

                  float x = subFace[s][0] * Sky3D.scale * WIN3D.scale;
                  float y = subFace[s][1] * Sky3D.scale * WIN3D.scale;
                  float z = subFace[s][2] * Sky3D.scale * WIN3D.scale;

                  float _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);


                  if (_turn == 1) {

                    SOLARCHVISION_OBJprintVertex(x, y, z);
                  }

                  if (_turn == 2) {
                    float u1 = 0.5 * (_u + 0.5);

                    if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                        (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

                      if  (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                    }

                    if (u1 > 0.999) u1 = 0.999;
                    if (u1 < 0.001) u1 = 0.001;

                    SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
                  }

                  if (_turn == 3) {
                    num_vertices_added += 1;
                  }
                }

                if (_turn == 3) {
                  String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                  String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                  String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                  String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                  String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                  String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                  String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                  String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                  if (User3D.export_BackSides) {
                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                  }
                }
              }
            }
          }

          obj_lastVertexNumber += num_vertices_added;
          obj_lastVtextureNumber += num_vertices_added;
        }
      }

      if (target_window == TypeWindow.WIN3D) {

        if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
            (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

          for (int f = 0; f < skyFaces.length; f++) {

            int tessellation = 0;

            int totalNumberOfSubs = 1;
            tessellation = this.displayTessellation;
            if (tessellation > 0) totalNumberOfSubs = skyFaces[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

            float[][] base_Vertices = new float [skyFaces[f].length][3];
            for (int j = 0; j < skyFaces[f].length; j++) {
              int vNo = skyFaces[f][j];
              base_Vertices[j][0] = skyVertices[vNo][0];
              base_Vertices[j][1] = skyVertices[vNo][1];
              base_Vertices[j][2] = skyVertices[vNo][2];
            }

            for (int n = 0; n < totalNumberOfSubs; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

              for (int j = 0; j < subFace.length; j++) {
                subFace[j] = funcs.vec3_unit(subFace[j]);
              }

              WIN3D.graphics.beginShape();

              for (int s = 0; s < subFace.length; s++) {

                int s_next = (s + 1) % subFace.length;
                int s_prev = (s + subFace.length - 1) % subFace.length;

                float[] COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);

                WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                WIN3D.graphics.vertex(subFace[s][0] * this.scale * WIN3D.scale,
                                     -subFace[s][1] * this.scale * WIN3D.scale,
                                      subFace[s][2] * this.scale * WIN3D.scale);
              }

              WIN3D.graphics.endShape(CLOSE);
            }
          }
        } else {

          color c = color(191, 191, 255);

          WIN3D.graphics.noStroke();

          if (WIN3D.FacesShade == SHADE.Surface_Materials) {
            WIN3D.graphics.fill(c);
            //WIN3D.graphics.noFill();
          } else {
            WIN3D.graphics.fill(c);
          }

          for (int f = 0; f < skyFaces.length; f++) {

            WIN3D.graphics.beginShape();

            for (int j = 0; j < skyFaces[f].length; j++) {
              int vNo = skyFaces[f][j];
              WIN3D.graphics.vertex(skyVertices[vNo][0] * this.scale * WIN3D.scale,
                                   -skyVertices[vNo][1] * this.scale * WIN3D.scale,
                                    skyVertices[vNo][2] * this.scale * WIN3D.scale);
            }

            WIN3D.graphics.endShape(CLOSE);
          }
        }

      }
    }
  }

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displaySurface", this.displaySurface);
    XML_setInt(parent, "displayTessellation", this.displayTessellation);
    XML_setFloat(parent, "scale", this.scale);
    XML_setInt(parent, "ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    XML_setInt(parent, "ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    XML_setFloat(parent, "ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    XML_setInt(parent, "PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    XML_setInt(parent, "PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    XML_setFloat(parent, "PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);

    XML_setFloat(parent, "stp_slp", this.stp_slp);
    XML_setFloat(parent, "stp_dir", this.stp_dir);
    XML_setInt(parent, "num_slp", this.num_slp);
    XML_setInt(parent, "num_dir", this.num_dir);

    XML_setFloat(parent, "calculatedResolution", this.calculatedResolution);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displaySurface = XML_getBoolean(parent, "displaySurface");
    this.displayTessellation = XML_getInt(parent, "displayTessellation");
    this.scale = XML_getFloat(parent, "scale");
    this.ACTIVE_pallet_CLR = XML_getInt(parent, "ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = XML_getInt(parent, "ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = XML_getFloat(parent, "ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = XML_getInt(parent, "PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = XML_getInt(parent, "PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = XML_getFloat(parent, "PASSIVE_pallet_MLT");

    this.stp_slp = XML_getFloat(parent, "stp_slp");
    this.stp_dir = XML_getFloat(parent, "stp_dir");
    this.num_slp = XML_getInt(parent, "num_slp");
    this.num_dir = XML_getInt(parent, "num_dir");

    this.calculatedResolution = XML_getFloat(parent, "calculatedResolution");
  }
}

solarchvision_Sky3D Sky3D = new solarchvision_Sky3D();



class solarchvision_Sun3D {

  private final static String CLASS_STAMP = "Sun3D";

  int ACTIVE_pallet_CLR = 15;
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1;

  int PASSIVE_pallet_CLR = 18;
  int PASSIVE_pallet_DIR = -1;
  float PASSIVE_pallet_MLT = 0.2;

  boolean displayGrid = true;
  boolean displayPath = true;
  boolean displayPattern = true; //false;

  boolean displaySurface = false;
  boolean displayTexture = true;

  String Filename = BaseFolder + "/input/images/sun/Sun.jpg";

  PImage Map;

  void load_images () {
    Map = loadImage(Filename);
  }

  void draw () {
    if (this.displaySurface) {

      WIN3D.graphics.noStroke();

      float OffsetX = 0;
      float OffsetY = 0;

      float ScaleX = 1;
      float ScaleY = 1;

      float CEN_lon = 0;
      float CEN_lat = 0;

      float delta_Alpha = -5;
      float delta_Beta = -10;

      float r = 696.0 * Planetary_Magnification; // * 1000000; // multiply this later
      float d = 150000.0; // * 1000000; // multiply this later

      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

          float[][] subFace = new float [4][5];

          for (int s = 0; s < 4; s++) {

            float a = Alpha;
            float b = Beta;

            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }

            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }

            float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a);
            float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
            float z0 = r * funcs.sin_ang(a);

            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;

            if (this.displayTexture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5);
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }

            // rotating to location coordinates

            float tb = 0;
            float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
            float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
            float z1 = z0;

            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
            float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);

            // scale it here!
            x2 *= 1000000.0;
            y2 *= 1000000.0;
            z2 *= 1000000.0;

            // move it to scale here!
            y2 += 1000000.0 * d * funcs.sin_ang(-STATION.getLatitude());
            z2 += 1000000.0 * d * funcs.cos_ang(-STATION.getLatitude());

            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }

          WIN3D.graphics.beginShape();

          if (this.displayTexture) {
            WIN3D.graphics.texture(this.Map);
          }

          for (int s = 0; s < subFace.length; s++) {

            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale,
                                 -subFace[s][1] * OBJECTS_scale * WIN3D.scale,
                                  subFace[s][2] * OBJECTS_scale * WIN3D.scale,
                                  subFace[s][3] * this.Map.width,
                                  subFace[s][4] * this.Map.height);
          }

          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }








  void drawGrid (int target_window, float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath, int start_j, int end_j) {
    if (target_window == TypeWindow.STUDY) {
      s_SunPath *= 0.65; // TODO: why do we need this?
    }

    if (this.displayGrid) {

      if (target_window == TypeWindow.WIN3D) {

        WIN3D.graphics.pushMatrix();
        WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);

        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
      }

      if (target_window == TypeWindow.STUDY) {

        STUDY.graphics.pushMatrix();
        STUDY.graphics.translate(x_SunPath, y_SunPath);

        STUDY.graphics.strokeWeight(1);
        STUDY.graphics.stroke(0);
      }

      for (float j = start_j; j <= end_j; j += 30) {

        float HOUR_step = 0.1;
        for (float i = 0; i <= 24; i += HOUR_step) {

          float[] SunA = funcs.SunPosition(STATION.getLatitude(), j, i);
          float[] SunB = funcs.SunPosition(STATION.getLatitude(), j, i + HOUR_step);

          if ((SunA[3] > 0) || (SunB[3] > 0)) {

            if (target_window == TypeWindow.WIN3D) {

              WIN3D.graphics.line(SunA[1] * s_SunPath * WIN3D.scale,
                                 -SunA[2] * s_SunPath * WIN3D.scale,
                                  SunA[3] * s_SunPath * WIN3D.scale,
                                  SunB[1] * s_SunPath * WIN3D.scale,
                                 -SunB[2] * s_SunPath * WIN3D.scale,
                                  SunB[3] * s_SunPath * WIN3D.scale);
            }

            if (target_window == TypeWindow.STUDY) {

              float A_Alpha = 90 - funcs.acos_ang(SunA[3]);
              float A_Beta = 180 - funcs.atan2_ang(SunA[1], SunA[2]);

              float B_Alpha = 90 - funcs.acos_ang(SunB[3]);
              float B_Beta = 180 - funcs.atan2_ang(SunB[1], SunB[2]);

              STUDY.graphics.line((90 - A_Alpha) * (funcs.cos_ang(A_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                 -(90 - A_Alpha) * (funcs.sin_ang(A_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                  (90 - B_Alpha) * (funcs.cos_ang(B_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                 -(90 - B_Alpha) * (funcs.sin_ang(B_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0);
            }
          }
        }
      }

      for (float i = 0; i <= 24; i += 1) {
        float DATE_step = 1;
        for (float j = start_j; j <= end_j; j += DATE_step) {

          float[] SunA = funcs.SunPosition(STATION.getLatitude(), j, i);
          float[] SunB = funcs.SunPosition(STATION.getLatitude(),  j + DATE_step, i);

          if ((SunA[3] > 0) || (SunB[3] > 0)) {

            if (target_window == TypeWindow.WIN3D) {

              WIN3D.graphics.line(SunA[1] * s_SunPath * WIN3D.scale,
                                 -SunA[2] * s_SunPath * WIN3D.scale,
                                  SunA[3] * s_SunPath * WIN3D.scale,
                                  SunB[1] * s_SunPath * WIN3D.scale,
                                 -SunB[2] * s_SunPath * WIN3D.scale,
                                  SunB[3] * s_SunPath * WIN3D.scale);
            }

            if (target_window == TypeWindow.STUDY) {

              float A_Alpha = 90 - funcs.acos_ang(SunA[3]);
              float A_Beta = 180 - funcs.atan2_ang(SunA[1], SunA[2]);

              float B_Alpha = 90 - funcs.acos_ang(SunB[3]);
              float B_Beta = 180 - funcs.atan2_ang(SunB[1], SunB[2]);

              STUDY.graphics.line((90 - A_Alpha) * (funcs.cos_ang(A_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                 -(90 - A_Alpha) * (funcs.sin_ang(A_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                  (90 - B_Alpha) * (funcs.cos_ang(B_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0,
                                 -(90 - B_Alpha) * (funcs.sin_ang(B_Beta - 90)) * s_SunPath * STUDY.view_S / 90.0);
            }
          }
        }
      }

      if (target_window == TypeWindow.WIN3D) {
        WIN3D.graphics.popMatrix();
      }

      if (target_window == TypeWindow.STUDY) {
        STUDY.graphics.popMatrix();
      }
    }

  }




  void drawPath (int target_window, float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) {

    if (this.displayPath) {

      float keep_STUDY_perDays = STUDY.perDays;
      int keep_STUDY_joinDays = STUDY.joinDays;
      if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
          (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {

        STUDY.perDays = 1;
        STUDY.joinDays = 1;
      }

      float previous_DATE = TIME.date;




      int TES_hour = 4; // 1 = every 1 hour, 4 = every 15 minutes

      int PAL_type = 0;
      int PAL_direction = 1;

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
      }

      float PAL_multiplier = 1;
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = this.PASSIVE_pallet_MLT;



      WIN3D.graphics.pushMatrix();
      WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);

      WIN3D.graphics.strokeWeight(0);
      WIN3D.graphics.stroke(0, 0, 0);
      WIN3D.graphics.fill(0, 0, 0);

      WIN3D.graphics.line(-1 * s_SunPath, 0, 0, 1 * s_SunPath, 0, 0);
      WIN3D.graphics.line(0, -1 * s_SunPath, 0, 0, 1 * s_SunPath, 0);

      WIN3D.graphics.stroke(255, 255, 0);



      int[] startK_endK = get_startK_endK();
      int start_k = startK_endK[0];
      int end_k = startK_endK[1];
      int count_k = 1 + end_k - start_k;
      if (count_k < 0) count_k = 0;

      for (int p = 0; p < 1; p++) {

        int l = STUDY.ImpactLayer;

        int DATE_step = 1;

        int J_START = STUDY.j_Start;
        int J_END = STUDY.j_End;

        if (IMPACTS_displayDay > 0) {
          J_START = IMPACTS_displayDay - 1;
          J_END = IMPACTS_displayDay;
        }

        for (int j = J_START; j < J_END; j += DATE_step) {

          int now_k = 0;
          int now_i1 = 0;
          int now_i2 = 0;
          int now_j = 0;

          now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

          //println(j, now_j, DATE_ANGLE);

          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays;

              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
                if (STUDY.isInHourlyRange(i)) {

                  float HOUR_ANGLE = i;
                  float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                  now_k = k + start_k;

                  now_i1 = floor(i);
                  now_i2 = (1 + now_i1) % 24;
                  float i_ratio = i - now_i1;

                  now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  float Pa1 = FLOAT_undefined;
                  float Pa2 = FLOAT_undefined;

                  if (Impact_TYPE == Impact_ACTIVE) {

                    Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
                    Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);

                  }

                  if (Impact_TYPE == Impact_PASSIVE) {

                    Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
                    Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);

                  }

                  if ((is_undefined(Pa1)) && (is_undefined(Pa2))) {
                  } else {

                    float sun_V = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * sun_V);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * sun_V);

                    if (PAL_direction == -1) _u = 1 - _u;
                    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_direction == 2) _u =  0.5 * _u;

                    float[] COL = PAINT.getColorStyle(PAL_type, _u);

                    WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                    WIN3D.graphics.strokeWeight(0.01 * WIN3D.dY);

                    float[] SunA = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE - 0.5 * (1.0 / float(TES_hour)));
                    float[] SunB = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE + 0.5 * (1.0 / float(TES_hour)));

                    if ((SunA[3] > 0) || (SunB[3] > 0)) {

                      float x1 = SunA[1] * WIN3D.scale * s_SunPath;
                      float y1 = SunA[2] * WIN3D.scale * s_SunPath;
                      float z1 = SunA[3] * WIN3D.scale * s_SunPath;

                      float x2 = SunB[1] * WIN3D.scale * s_SunPath;
                      float y2 = SunB[2] * WIN3D.scale * s_SunPath;
                      float z2 = SunB[3] * WIN3D.scale * s_SunPath;

                      WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
                    }
                  }
                }
              }
            }
          }
        }
      }

      WIN3D.graphics.popMatrix();



      STUDY.perDays = keep_STUDY_perDays;
      STUDY.joinDays = keep_STUDY_joinDays;
      TIME.date = previous_DATE;
      TIME.updateDate();
    }
  }



  void drawPattern (int target_window, float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) {

    if (this.displayPattern) {

      float keep_STUDY_perDays = STUDY.perDays;
      int keep_STUDY_joinDays = STUDY.joinDays;
      if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
          (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {

        STUDY.perDays = 1;
        STUDY.joinDays = 1;
      }

      float previous_DATE = TIME.date;

      this.drawCycles(target_window, x_SunPath, y_SunPath, z_SunPath, s_SunPath);

      STUDY.perDays = keep_STUDY_perDays;
      STUDY.joinDays = keep_STUDY_joinDays;
      TIME.date = previous_DATE;
      TIME.updateDate();
    }
  }



  void drawCycles (int target_window, float x_Plot, float y_Plot, float z_Plot, float s_Plot) {

    int TES_hour = 1; //4; // 1 = every 1 hour, 4 = every 15 minutes


    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0];
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k;
    if (count_k < 0) count_k = 0;

    if (target_window == TypeWindow.STUDY) {
      Impact_TYPE = (STUDY.PlotImpacts % 2 == 0) ? Impact_ACTIVE : Impact_PASSIVE;
    }

    float Pa1 = FLOAT_undefined;
    float Pb1 = FLOAT_undefined;
    float Pc1 = FLOAT_undefined;
    float Pd1 = FLOAT_undefined;

    float Pa2 = FLOAT_undefined;
    float Pb2 = FLOAT_undefined;
    float Pc2 = FLOAT_undefined;
    float Pd2 = FLOAT_undefined;

    float values_R_dir;
    float values_R_dif;
    float values_E_dir;
    float values_E_dif;

    int now_k = 0;
    int now_i1 = 0;
    int now_i2 = 0;
    int now_j = 0;

    int PAL_type = 0;
    int PAL_direction = 1;

    float PAL_multiplier = 1;

    if (target_window == TypeWindow.STUDY) {

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = STUDY.ACTIVE_pallet_CLR;
        PAL_direction = STUDY.ACTIVE_pallet_DIR;
        PAL_multiplier = STUDY.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = STUDY.PASSIVE_pallet_CLR;
        PAL_direction = STUDY.PASSIVE_pallet_DIR;
        PAL_multiplier = STUDY.PASSIVE_pallet_MLT;
      }
    }
    else {

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR;
        PAL_direction = this.ACTIVE_pallet_DIR;
        PAL_multiplier = this.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR;
        PAL_direction = this.PASSIVE_pallet_DIR;
        PAL_multiplier = this.PASSIVE_pallet_MLT;
      }
    }


    String the_filename = "";
    String TEXTURE_path = "";

    if (target_window == TypeWindow.OBJ3D) {

      num_vertices_added = 0;

      if (User3D.export_MaterialLibrary) {

        the_filename = "sunPatternPallet.bmp";

        TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

        println("Saving texture:", TEXTURE_path);

        int RES1 = User3D.export_PalletResolution;
        int RES2 = User3D.export_PalletResolution / 16;

        PImage pallet_Texture = createImage(RES1, RES2, ARGB);


        pallet_Texture.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float _val = (Image_X / (0.5 * RES1)) - 1;

          float _u = 0.5 + _val;

          if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

          float[] COL = PAINT.getColorStyle(PAL_type, _u);

          pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }

        pallet_Texture.updatePixels();

        pallet_Texture.save(TEXTURE_path);


        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

        //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
      }
    }



    num_vertices_added = 0;

    int end_turn = 1;
    if (target_window == TypeWindow.OBJ3D) end_turn = 3;
    for (int _turn = 1; _turn <= end_turn; _turn++) {


      if (target_window == TypeWindow.OBJ3D) {

        if (_turn == 3) {

          obj_lastGroupNumber += 1;
          objOutput.println("g sunPattern");

          if (User3D.export_MaterialLibrary) {
            objOutput.println("usemtl " +  the_filename.replace('.', '_'));
          }
        }
      }



      for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

        float[][][] SunPathMesh = new float [24 * TES_hour][1 + int(STUDY.perDays / STUDY.joinDays)][3];

        for (int more_J = 0; more_J < STUDY.perDays; more_J += STUDY.joinDays) {

          now_j = (more_J + j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

          float sunrise_origin = funcs.Sunrise(STATION.getLatitude(), DATE_ANGLE) + funcs.EquationOfTime(DATE_ANGLE);
          float sunset_origin = funcs.Sunset(STATION.getLatitude(), DATE_ANGLE) + funcs.EquationOfTime(DATE_ANGLE);

          //println("rise=", sunrise_origin);
          //println("set=", sunset_origin);
          //println("mid=", (sunrise_origin + sunset_origin) * 0.5);

          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          {
            int keep_filter_type = STUDY.filter;
            STUDY.filter = filter_HOURLY;

            Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, more_J + j, DATE_ANGLE);

            STUDY.filter = keep_filter_type;
          }

          int l = STUDY.ImpactLayer;

          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays;

              float valuesSUM_RAD = 0;
              float valuesSUM_EFF = 0;
              int valuesNUM = 0;

              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

                float HOUR_ANGLE = i;
                float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                float Alpha = 90 - funcs.acos_ang(SunR[3]);
                float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);

                //-------------- to extend graph to the horizon ---------------
                if (Alpha < 0) {

                  float[] SunR_temp;
                  if (i < 12) {
                    SunR_temp = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, sunrise_origin);
                  }
                  else {
                    SunR_temp = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, sunset_origin);
                  }

                  //println("x=", SunR_temp[1]);
                  //println("y=", SunR_temp[2]);
                  //println("z=", SunR_temp[3]);

                  Alpha = 0;
                  Beta = 180 - funcs.atan2_ang(SunR_temp[1], SunR_temp[2]);
                }
                //-----------------------------------------------------------

                now_k = k + start_k;

                now_i1 = floor(i);
                now_i2 = (1 + now_i1) % 24;
                float i_ratio = i - now_i1;

                now_j = int(more_J + j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
                Pb1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difhorrad.id);
                Pc1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
                Pd1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difeffect.id);

                Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);
                Pb2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difhorrad.id);
                Pc2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);
                Pd2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difeffect.id);

                if ((is_undefined(Pa1)) || (is_undefined(Pb1)) || (is_undefined(Pc1)) || (is_undefined(Pd1))
                  || (is_undefined(Pa2)) || (is_undefined(Pb2)) || (is_undefined(Pc2)) || (is_undefined(Pd2))) {
                  values_R_dir = FLOAT_undefined;
                  values_R_dif = FLOAT_undefined;
                  values_E_dir = FLOAT_undefined;
                  values_E_dif = FLOAT_undefined;
                } else {

                  int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i1, now_j, now_k);

                  if (memberCount == 1) {
                    values_R_dir = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                    values_R_dif = 0.001 * (Pb1 * (1 - i_ratio) + Pb2 * i_ratio);
                    values_E_dir = 0.001 * (Pc1 * (1 - i_ratio) + Pc2 * i_ratio);
                    values_E_dif = 0.001 * (Pd1 * (1 - i_ratio) + Pd2 * i_ratio);

                    if (is_undefined(valuesSUM_RAD)) {
                      valuesSUM_RAD = 0;
                      valuesSUM_EFF = 0;
                      valuesNUM = 0;
                    } else {
                      valuesSUM_RAD = (values_R_dir); // direct beam radiation
                      valuesSUM_EFF = (values_E_dir); // direct beam effect
                      valuesNUM = 1;
                    }
                  }
                }

                float valuesSUM = FLOAT_undefined;
                if (Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                if (Impact_TYPE == Impact_PASSIVE) valuesSUM = valuesSUM_EFF;

                int row_J = more_J / STUDY.joinDays;

                SunPathMesh[floor(i * TES_hour)][row_J][0] = Alpha;
                SunPathMesh[floor(i * TES_hour)][row_J][1] = Beta;
                SunPathMesh[floor(i * TES_hour)][row_J][2] = valuesSUM;
              }
            } else {
              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

                float valuesSUM = FLOAT_undefined;

                float HOUR_ANGLE = i;
                float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                float Alpha = 90 - funcs.acos_ang(SunR[3]);
                float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);

                int row_J = more_J / STUDY.joinDays;

                SunPathMesh[floor(i * TES_hour)][row_J][0] = Alpha;
                SunPathMesh[floor(i * TES_hour)][row_J][1] = Beta;
                SunPathMesh[floor(i * TES_hour)][row_J][2] = valuesSUM;
              }
            }
          }
        }




        for (int more_J = 0; more_J < STUDY.perDays - STUDY.joinDays; more_J += STUDY.joinDays) { //count one less!

          now_j = (more_J + j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

          float sunrise = funcs.Sunrise(STATION.getLatitude(), DATE_ANGLE);
          float sunset = funcs.Sunset(STATION.getLatitude(), DATE_ANGLE);

          for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
            if (STUDY.isInHourlyRange(i)) {
              if ((i > sunrise - 1.0 / float(TES_hour)) && (i < sunset + 1.0 / float(TES_hour))) {

                if (target_window == TypeWindow.OBJ3D) {
                } else if (target_window == TypeWindow.WIN3D) {
                  WIN3D.graphics.beginShape();
                  WIN3D.graphics.noStroke();
                } else if (target_window == TypeWindow.WORLD) {
                  WORLD.graphics.beginShape();
                  WORLD.graphics.noStroke();
                } else if (target_window == TypeWindow.STUDY) {
                  STUDY.graphics.beginShape();
                  STUDY.graphics.noStroke();
                }

                for (int s = 0; s < 4; s++) {

                  int a = int(i * TES_hour);
                  int b = more_J / STUDY.joinDays;

                  if ((s == 1) || (s == 2)) {
                    a += 1;
                  }

                  if ((s == 2) || (s == 3)) {
                    b += 1;
                  }

                  if (a > (24 * TES_hour - 1)) a = a % (24 * TES_hour);

                  float Alpha = SunPathMesh[a][b][0];
                  float Beta = SunPathMesh[a][b][1];
                  float valuesSUM = SunPathMesh[a][b][2];

                  if (Alpha >= 0) {

                    if (is_defined(valuesSUM)) {

                      float _u = 0;

                      if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * valuesSUM);
                      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * valuesSUM);

                      if (PAL_direction == -1) _u = 1 - _u;
                      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_direction == 2) _u =  0.5 * _u;

                      float[] COL = PAINT.getColorStyle(PAL_type, _u);

                      if (target_window == TypeWindow.OBJ3D) {

                        float x = funcs.cos_ang(Alpha) * (funcs.cos_ang(Beta - 90)) * WIN3D.scale * s_Plot + x_Plot;
                        float y = funcs.cos_ang(Alpha) * (funcs.sin_ang(Beta - 90)) * WIN3D.scale * s_Plot + y_Plot;
                        float z = funcs.sin_ang(Alpha) * WIN3D.scale * s_Plot + z_Plot;

                        if (_turn == 1) {
                          SOLARCHVISION_OBJprintVertex(x, y, z);
                        }

                        if (_turn == 2) {
                          float u1 = 0.5 * (_u + 0.5);

                          if ((WIN3D.FacesShade == SHADE.Global_Solar) ||
                              (WIN3D.FacesShade == SHADE.Vertex_Solar)) {

                            if (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                          }

                          if (u1 > 0.999) u1 = 0.999;
                          if (u1 < 0.001) u1 = 0.001;

                          SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
                        }

                        if (_turn == 3) {
                          num_vertices_added += 1;
                        }
                      } else if (target_window == TypeWindow.WIN3D) {
                        WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);

                        float x = funcs.cos_ang(Alpha) * (funcs.cos_ang(Beta - 90)) * WIN3D.scale * s_Plot + x_Plot;
                        float y = funcs.cos_ang(Alpha) * (funcs.sin_ang(Beta - 90)) * WIN3D.scale * s_Plot + y_Plot;
                        float z = funcs.sin_ang(Alpha) * WIN3D.scale * s_Plot + z_Plot;

                        WIN3D.graphics.vertex(x, -y, z);
                      } else if (target_window == TypeWindow.WORLD) {
                        // ??????????????????????????
                      } else if (target_window == TypeWindow.STUDY) {

                        STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

                        float x = (90 - Alpha) * (funcs.cos_ang(Beta - 90)) * STUDY.rect_scale * s_Plot + x_Plot * STUDY.rect_scale;
                        float y = (90 - Alpha) * (funcs.sin_ang(Beta - 90)) * STUDY.rect_scale * s_Plot + y_Plot * STUDY.rect_scale;

                        float ox = (j + STUDY.rect_offset_x) * s_Plot;

                        STUDY.graphics.vertex(ox + x, -y);
                      }
                    }
                  }
                }

                if (target_window == TypeWindow.OBJ3D) {

                  if (_turn == 3) {

                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                  }
                } else if (target_window == TypeWindow.WIN3D) {
                  WIN3D.graphics.endShape(CLOSE);
                } else if (target_window == TypeWindow.WORLD) {
                  WORLD.graphics.endShape(CLOSE);
                } else if (target_window == TypeWindow.STUDY) {
                  STUDY.graphics.endShape(CLOSE);
                }
              }
            }
          }
        }
      }


      if (target_window == TypeWindow.OBJ3D) {
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }
    }

  }







  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    XML_setInt(parent, "ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    XML_setFloat(parent, "ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    XML_setInt(parent, "PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    XML_setInt(parent, "PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    XML_setFloat(parent, "PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);

    XML_setBoolean(parent, "displayGrid", this.displayGrid);
    XML_setBoolean(parent, "displayPath", this.displayPath);
    XML_setBoolean(parent, "displayPattern", this.displayPattern);


    XML_setBoolean(parent, "displaySurface", this.displaySurface);
    XML_setBoolean(parent, "displayTexture", this.displayTexture);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.ACTIVE_pallet_CLR = XML_getInt(parent, "ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = XML_getInt(parent, "ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = XML_getFloat(parent, "ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = XML_getInt(parent, "PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = XML_getInt(parent, "PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = XML_getFloat(parent, "PASSIVE_pallet_MLT");

    this.displayGrid = XML_getBoolean(parent, "displayGrid");
    this.displayPath = XML_getBoolean(parent, "displayPath");
    this.displayPattern = XML_getBoolean(parent, "displayPattern");

    this.displaySurface = XML_getBoolean(parent, "displaySurface");
    this.displayTexture = XML_getBoolean(parent, "displayTexture");
  }
}

solarchvision_Sun3D Sun3D = new solarchvision_Sun3D();


class solarchvision_Moon3D {

  private final static String CLASS_STAMP = "Moon3D";

  boolean displaySurface = false;
  boolean displayTexture = true;

  String Filename = BaseFolder + "/input/images/moon/Moon.jpg";

  PImage Map;

  void load_images () {
    Map = loadImage(Filename);
  }

  void draw () {
    if (this.displaySurface) {

      WIN3D.graphics.strokeWeight(1);

      float OffsetX = 0;
      float OffsetY = 0;

      float ScaleX = 1;
      float ScaleY = 1;

      float CEN_lon = 0;
      float CEN_lat = 0;

      float delta_Alpha = -5;
      float delta_Beta = -10;

      float r = 1737000.0 * Planetary_Magnification;
      float d = 384400000.0 - FLOAT_r_Earth;

      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

          float[][] subFace = new float [4][5];

          for (int s = 0; s < 4; s++) {

            float a = Alpha;
            float b = Beta;

            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }

            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }

            float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a);
            float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
            float z0 = r * funcs.sin_ang(a);

            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;

            if (this.displayTexture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5);
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }

            // rotating to location coordinates


            float tb = 0;
            float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
            float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
            float z1 = z0;

            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
            float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);

            // move it up here!
            y2 += d * funcs.sin_ang(-STATION.getLatitude());
            z2 += d * funcs.cos_ang(-STATION.getLatitude());

            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }

          WIN3D.graphics.beginShape();

          WIN3D.graphics.noStroke();

          if (this.displayTexture) {

            WIN3D.graphics.texture(this.Map);
          }

          for (int s = 0; s < subFace.length; s++) {

            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, subFace[s][3] * this.Map.width, subFace[s][4] * this.Map.height);
          }

          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displaySurface", this.displaySurface);
    XML_setBoolean(parent, "displayTexture", this.displayTexture);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displaySurface = XML_getBoolean(parent, "displaySurface");
    this.displayTexture = XML_getBoolean(parent, "displayTexture");
  }
}

solarchvision_Moon3D Moon3D = new solarchvision_Moon3D();






class solarchvision_Earth3D {

  private final static String CLASS_STAMP = "Earth3D";

  boolean displaySurface = false; //true;
  boolean displayTexture = true;

  PImage[] Map;

  float[][] BoundariesX;
  float[][] BoundariesY;

  String Path = BaseFolder + "/input/images/earth";

  String[] Filenames = sort(OPESYS.getFiles(this.Path));


  void resize_images () {

    int n = this.Filenames.length;

    this.Map = new PImage [n];

    this.BoundariesX = new float [n][2];
    this.BoundariesY = new float [n][2];

  }


  void load_images () {

    for (int i = 0; i < this.Filenames.length; i++) {

      String MapFilename = this.Path + "/" + this.Filenames[i];

      String[] Parts = split(this.Filenames[i], '_');

      this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;

      println("Loading:", MapFilename);

      this.Map[i] = loadImage(MapFilename);
    }
  }



  void draw (int target_window) {

    boolean proceed = true;

    if ((this.displaySurface == false) || (this.displayTexture == false)) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {

      proceed = false;
    }

    if (proceed) {

      int n_Map = 0;
      if (IMPACTS_displayDay < this.Map.length) n_Map = IMPACTS_displayDay;

      float OffsetX = this.BoundariesX[n_Map][0] + 180;
      float OffsetY = this.BoundariesY[n_Map][1] - 90;

      float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
      float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;

      float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
      float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);

      float delta_Alpha = -BIOSPHERE_drawResolution;
      float delta_Beta = -BIOSPHERE_drawResolution;

      float r = FLOAT_r_Earth;


      if ((target_window == TypeWindow.HTML) ||
          (target_window == TypeWindow.OBJ3D)) {

        if (User3D.export_MaterialLibrary) {

          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='EarthSphere" + nf(n_Map, 0) + "'>");
          }

          if (target_window == TypeWindow.OBJ3D) {

            mtlOutput.println("newmtl EarthSphere");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }

          if (this.displayTexture) {

            String old_Texture_path = this.Path + "/" + this.Filenames[n_Map];

            String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

            String new_Texture_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

            println("Copying texture:", old_Texture_path, ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(old_Texture_path));

            if (target_window == TypeWindow.OBJ3D) {

              //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
              mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
              mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
            }

            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
            }

          }
        }

        if (target_window == TypeWindow.HTML) {
          htmlOutput.println("\t\t\t\t</Appearance>");
        }

        if (target_window == TypeWindow.OBJ3D) {
          if (User3D.export_PolyToPoly == 1) {
            obj_lastGroupNumber += 1;
            objOutput.println("g EarthSphere");
          }

          if (User3D.export_MaterialLibrary) {
            objOutput.println("usemtl EarthSphere");
          }
        }

      }


      num_vertices_added = 0;

      int end_turn = 1;
      if (target_window == TypeWindow.OBJ3D) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {

        int f = 0;
        for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
          for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
            f += 1;

            float[][] subFace = new float [4][5];

            for (int s = 0; s < 4; s++) {

              float a = Alpha;
              float b = Beta;

              if ((s == 2) || (s == 3)) {
                a += delta_Alpha;
              }

              if ((s == 1) || (s == 2)) {
                b += delta_Beta;
              }

              float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a);
              float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
              float z0 = r * funcs.sin_ang(a);

              float _lon = b - CEN_lon;
              float _lat = a - CEN_lat;

              if (this.displayTexture) {
                // calculating u and v
                subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5);
                subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
              }

              // rotating to location coordinates
              float tb = -STATION.getLongitude();
              float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
              float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
              float z1 = z0;

              float ta = 90 - STATION.getLatitude();
              float x2 = x1;
              float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
              float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);

              // move it down!
              z2 -= FLOAT_r_Earth;

              subFace[s][0] = x2;
              subFace[s][1] = y2;
              subFace[s][2] = z2;
            }


            if (target_window == TypeWindow.HTML) {

              htmlOutput.println("\t\t\t\t<shape>");

              if (n_Map != -1) {
                htmlOutput.println("\t\t\t\t\t<Appearance USE='EarthSphere" + nf(n_Map, 0) + "'></Appearance>");
              }

              htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided

              htmlOutput.print  (" coordIndex='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(" ");
                }
                htmlOutput.print(nf(s, 0));
              }
              htmlOutput.println(" -1'>");

              htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(",");
                }

                htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
              }
              htmlOutput.println("'></Coordinate>");

            }

            if (target_window == TypeWindow.WIN3D) {

              WIN3D.graphics.strokeWeight(1);

              WIN3D.graphics.beginShape();

              WIN3D.graphics.noStroke();

              if (this.displayTexture) {

                WIN3D.graphics.texture(this.Map[n_Map]);
              }
            }



            for (int s = 0; s < subFace.length; s++) {

              float x = subFace[s][0];
              float y = subFace[s][1];
              float z = subFace[s][2];
              float u = subFace[s][3];
              float v = subFace[s][4];

              if (u > 1) u = 1;
              if (u < 0) u = 0;
              if (v > 1) v = 1;
              if (v < 0) v = 0;

              if (target_window == TypeWindow.WIN3D) {

                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * this.Map[n_Map].width, v * this.Map[n_Map].height);
              }


              if (target_window == TypeWindow.OBJ3D) {
                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }

                if (_turn == 2) {

                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }

                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }
              }

              if (target_window == TypeWindow.HTML) {

                if (n_Map != -1) {

                  if (s == 0) {
                    htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                  }
                  if (s > 0) {
                    htmlOutput.print(",");
                  }

                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                  SOLARCHVISION_HTMLprintVtexture(u, v);

                  if (s == subFace.length - 1) {
                    htmlOutput.println("'></TextureCoordinate>");
                  }
                }

              }

            }

            if (target_window == TypeWindow.HTML) {

              htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

              htmlOutput.println("\t\t\t\t</shape>");

            }

            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }

            if (target_window == TypeWindow.OBJ3D) {
              String n1_txt = nf(obj_lastVertexNumber - 3, 0);
              String n2_txt = nf(obj_lastVertexNumber - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber - 0, 0);

              String m1_txt = nf(obj_lastVtextureNumber - 3, 0);
              String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
              String m4_txt = nf(obj_lastVtextureNumber - 0, 0);

              if (User3D.export_PolyToPoly == 0) {
                if (_turn == 3) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g EarthSphere_" + nf(f, 0));
                }
              }

              if (_turn == 3) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                if (User3D.export_BackSides) {
                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                }
              }
            }
          }
        }
      }
    }
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displaySurface", this.displaySurface);
    XML_setBoolean(parent, "displayTexture", this.displayTexture);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displaySurface = XML_getBoolean(parent, "displaySurface");
    this.displayTexture = XML_getBoolean(parent, "displayTexture");
  }

}

solarchvision_Earth3D Earth3D = new solarchvision_Earth3D();



class solarchvision_Land3D {

  private final static String CLASS_STAMP = "Land3D";

  boolean loadMesh = true;
  boolean loadTextures = true;

  boolean displaySurface = true;
  boolean displayPoints = false;
  boolean displayTexture = true;
  boolean displayDepth = false;

  int displayTessellation = 0; //0; //2;

  int pallet_CLR = 1;
  int pallet_DIR = -1;
  float pallet_MLT = 0.05;

  float[][][] Mesh;

  float[] Textures_U_scale;
  float[] Textures_V_scale;
  PImage[] Textures_map;
  String[] Textures_path;
  int Textures_num = 0;


  //Polar
  int num_rows = 24;
  int num_columns = 48 + 1;

  int skipStart = 0;
  int skipEnd = 0;


  void update_textures () {

    this.Textures_U_scale = new float [0];
    this.Textures_V_scale = new float [0];
    this.Textures_map = new PImage [0];
    this.Textures_path = new String [0];
    this.Textures_num = 0;

    this.displayTexture = false;

    if (this.loadTextures) {

      try {

        String[] filenames = sort(OPESYS.getFiles(Folder_Land)); // important to sort

        if (filenames != null) {
          for (int i = 0; i < filenames.length; i++) {
            println(filenames[i]);

            int _L = filenames[i].length();
            String _Extention = filenames[i].substring(_L - 4, _L);
            //println(_Extention);
            if (_Extention.toLowerCase().equals(".jpg")) {

              String[] Parts = split(filenames[i], '_');

              if (Parts[0].toUpperCase().equals("ELEV")) {

                if (Parts.length > 1) {

                  String dir = Folder_Land + "/" + filenames[i];

                  {
                    String[] new_item = {
                      dir
                    };

                    this.Textures_path = (String[]) concat(this.Textures_path, new_item);
                  }

                  float u = float(Parts[1]);
                  float v = u;

                  {
                    PImage[] new_item = {
                      loadImage(dir)
                    };

                    this.Textures_map = (PImage[]) concat(this.Textures_map, new_item);

                    int w = new_item[0].width;
                    int h = new_item[0].height;

                    if (w < h) {
                      if (h != 0) {
                        u *= w / (1.0 * h);
                      }
                    }

                    if (w > h) {
                      if (w != 0) {
                        v *= h / (1.0 * w);
                      }
                    }

                  }



                  {
                    float[] new_item = {
                      u
                    };

                    this.Textures_U_scale = (float[]) concat(this.Textures_U_scale, new_item);
                  }

                  {
                    float[] new_item = {
                      v
                    };

                    this.Textures_V_scale = (float[]) concat(this.Textures_V_scale, new_item);
                  }

                  this.Textures_num += 1;


                  this.displayTexture = true;
                }
              }
            }
          }
        }
      }
      catch (Exception e) {
        println("ERROR loading this.Textures_map!");
      }
    }

    SOLARCHVISION_view_changed();
  }




  void update_mesh () {

    this.Mesh = new float [this.num_rows][this.num_columns][3];

    for (int i = 0; i < this.num_rows; i++) {
      for (int j = 0; j < this.num_columns; j++) {
        this.Mesh[i][j][0] = FLOAT_undefined;
        this.Mesh[i][j][1] = FLOAT_undefined;
        this.Mesh[i][j][2] = FLOAT_undefined;
      }
    }

    Boolean using_default_mesh = false;

    try {

      if (this.loadMesh) {

        for (int i = 0; i < this.num_rows; i++) {

          XML FileALL = loadXML(Folder_Land + "/" + nf(i, 0) + ".xml");

          XML[] children0 = FileALL.getChildren("result");

          for (int j = 0; j < this.num_columns; j++) {

            String txt_elevation = children0[j].getChild("elevation").getContent();

            XML[] children1 = children0[j].getChildren("location");

            String txt_latitude = children1[0].getChild("lat").getContent();
            String txt_longitude = children1[0].getChild("lng").getContent();

            //println(txt_longitude, txt_latitude, txt_elevation);

            double _lon = Double.parseDouble(txt_longitude);
            double _lat = Double.parseDouble(txt_latitude);

            float[] XY = funcs.convert_lonlat2XY(STATION.getLongitude(), STATION.getLatitude(), _lon, _lat);

            float x = XY[0];
            float y = XY[1];
            float z = float(txt_elevation);

            this.Mesh[i][j][0] = x;
            this.Mesh[i][j][1] = y;
            this.Mesh[i][j][2] = z;
          }
        }

        float h = this.Mesh[0][0][2];

        h += HeightAboveGround;

        for (int i = 0; i < this.num_rows; i++) {
          for (int j = 0; j < this.num_columns; j++) {

            this.Mesh[i][j][2] -= h;
          }
        }

        /*
        // this is to modify the surronding ponits and set them at the same elevation of the the central point
        for (int j = 0; j < 2; j++) {
          if (j < this.num_columns) {
            for (int i = 0; i < this.num_rows; i++) {
              this.Mesh[i][j][2] = this.Mesh[0][0][2];
            }
          }
        }
        */

      }
    }
    catch (Exception e) {
      println("Warning: problem in loading topography from file.");

      using_default_mesh = true;
    }

    if (using_default_mesh) {
      println("Using default flat mesh:");

      this.flat_mesh();
    }


    this.update_textures();
  }



  void flat_mesh () {

    this.Mesh = new float [this.num_rows][this.num_columns][3];

    for (int i = 0; i < this.num_rows; i++) {


      for (int j = 0; j < this.num_columns; j++) {


        double[] LON_LAT = getLandGrid(i,j);

        double _lon = LON_LAT[0];
        double _lat = LON_LAT[1];

        float[] XY = funcs.convert_lonlat2XY(STATION.getLongitude(), STATION.getLatitude(), _lon, _lat);

        this.Mesh[i][j][0] = XY[0];
        this.Mesh[i][j][1] = XY[1];
        this.Mesh[i][j][2] = 0;

      }

    }

    this.loadMesh = true;
  }



  double[] getLandGrid (int i, int j) {

    double stp_lat = 1.0 / 2224.5968; // equals to 50m

    double stp_lon = stp_lat / funcs.cos_ang(STATION.getLatitude());

    //float q = 2;
    float q = pow(2, 0.5);
    //float q = 1.25;
    //float q = 1.125;

    float t = j * 360.0 / (this.num_columns - 1);

    float r = 0;
    if (i > 0) r = pow(q, i - 1);

    double _lon = STATION.getLongitude() + stp_lon * r * funcs.cos_ang(t);
    double _lat = STATION.getLatitude() + stp_lat * r * funcs.sin_ang(t);

    double[] LON_LAT = {_lon, _lat};

    return LON_LAT;

  }



  void download_mesh () {

    this.Mesh = new float [this.num_rows][this.num_columns][3];

    for (int i = 0; i < this.num_rows; i++) {

      String the_target = Folder_Land + "/" + nf(i, 0) + ".xml";

      File dir = new File(the_target);
      if (!dir.isFile()) {

        String the_link = "";

        for (int j = 0; j < this.num_columns; j++) {

          if (the_link.equals("")) the_link = "https://maps.googleapis.com/maps/api/elevation/xml?locations=";
          else the_link += "%7C"; //"|";

          double[] LON_LAT = getLandGrid(i,j);

          String txt_latitude = nf((float) LON_LAT[1], 0, 5);
          String txt_longitude = nf((float) LON_LAT[0], 0, 5);

          the_link += txt_latitude + "," + txt_longitude;
        }

        println("Try downloading: " + the_link);

        try {
          saveBytes(the_target, loadBytes(the_link));
        }
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }

    }

    this.loadMesh = true;
    this.update_mesh();

  }


  void download_textures () {

    float[] ratios = {
      1128.497220,
      2256.994440,
      4513.988880,
      9027.977761,
      18055.95552,
      36111.91104,
      72223.82209,
      144447.6442,
      288895.2884,
      577790.5767,
      1155581.153,
      2311162.307,
      4622324.614,
      9244649.227,
      18489298.45,
      36978596.91,
      73957193.82,
      147914387.6,
      295828775.3,
      591657550.5
    };

    for (int i = 0; i <= 15; i++) {

      String the_target = Folder_Land + "/ELEV_" + nf(int(0.05 * ratios[i]), 7) + "_.jpg";

      File dir = new File(the_target);
      if (!dir.isFile()) {

        String the_link = "https://maps.googleapis.com/maps/api/staticmap?center=" + nf(STATION.getLatitude(), 0, 5) + "," + nf(STATION.getLongitude(), 0, 5) + "&zoom=" + nf(20 - i, 0) + "&size=640x640&maptype=satellite&format=jpg";

        println("Try downloading: " + the_link);

        try {
          saveBytes(the_target, loadBytes(the_link));
        }
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }

    this.loadTextures = true;
    this.update_textures();

  }




  void draw (int target_window) {

    boolean proceed = true;

    if ((this.displaySurface == false) || (this.loadMesh == false)) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {
      proceed = false;
    }
    /*
    if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {
      proceed = true;
    }
    */
    if (proceed) {

      int PAL_type = SHADE.get_PAL_type();
      int PAL_direction = SHADE.get_PAL_direction();
      float PAL_multiplier = SHADE.get_PAL_multiplier();

      if (User3D.export_MaterialLibrary) {

        for (int n_Map = 0; n_Map < this.Textures_num; n_Map++) {

          if (target_window == TypeWindow.RAD3D) {

            radOutput.println("void plastic " + "LandMap" + nf(n_Map, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 0 0 0 0 0");

          }

          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='LandMap" + nf(n_Map, 0) + "'>");
          }

          if (target_window == TypeWindow.OBJ3D) {

            mtlOutput.println("newmtl LandMap" + nf(n_Map, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

          }


          if ((target_window == TypeWindow.HTML) ||
              (target_window == TypeWindow.OBJ3D)) {

            if (this.displayTexture) {
              if (n_Map != -1) {

                String old_Texture_path = this.Textures_path[n_Map];

                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

                String new_Texture_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));


                if (target_window == TypeWindow.OBJ3D) {

                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
                }

                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                }

              }
            }
          }


          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t</Appearance>");
          }

        }

      }

      if ((target_window == TypeWindow.LandGap) ||
          (target_window == TypeWindow.LandMesh)) {

        current_Material = User3D.default_Material;
        current_Tessellation = User3D.default_Tessellation;
        current_Layer = User3D.default_Layer;
        current_Visibility = User3D.default_Visibility;
        current_Weight = User3D.default_Weight;
        current_Closed = User3D.default_Closed;

        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

      }


      num_vertices_added = 0;

      int end_turn = 1;
      if (target_window == TypeWindow.OBJ3D) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {


        if (target_window == TypeWindow.OBJ3D) {

          if (_turn == 3) {

            if (this.displayTexture) {

              obj_lastGroupNumber += 1;
              objOutput.println("g LandMap");

            }
          }
        }



        int tessellation = this.displayTessellation;
        if (WIN3D.FacesShade == SHADE.Surface_Base) {
          tessellation = 0;
        }

        if ((target_window == TypeWindow.LandGap) ||
            (target_window == TypeWindow.LandMesh)) {
          tessellation = 0;
        }

        int totalNumberOfSubs = 1;
        if (tessellation > 0) totalNumberOfSubs = 4 * int(funcs.roundTo(pow(4, tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.

        int i_start = this.skipStart;
        int i_end = this.num_rows - 1 - this.skipEnd;

        if (target_window == TypeWindow.LandGap) {
          i_start = 0;
          i_end = this.skipStart;

          target_window = TypeWindow.LandMesh; // because the rest is simillar to that
        }


        for (int i = i_start; i < i_end; i++) {

          for (int j = 0; j < this.num_columns - 1; j++) {

            float[][] base_Vertices = new float [4][3];

            base_Vertices[0][0] = this.Mesh[i][j][0];
            base_Vertices[0][1] = this.Mesh[i][j][1];
            base_Vertices[0][2] = this.Mesh[i][j][2];

            base_Vertices[1][0] = this.Mesh[i+1][j][0];
            base_Vertices[1][1] = this.Mesh[i+1][j][1];
            base_Vertices[1][2] = this.Mesh[i+1][j][2];

            base_Vertices[2][0] = this.Mesh[i+1][j+1][0];
            base_Vertices[2][1] = this.Mesh[i+1][j+1][1];
            base_Vertices[2][2] = this.Mesh[i+1][j+1][2];

            base_Vertices[3][0] = this.Mesh[i][j+1][0];
            base_Vertices[3][1] = this.Mesh[i][j+1][1];
            base_Vertices[3][2] = this.Mesh[i][j+1][2];

            for (int n = 0; n < totalNumberOfSubs; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

              int n_Map = -1;
              if (this.displayTexture) {

                for (int q = 0; q < this.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map

                  n_Map = q;

                  for (int s = 0; s < subFace.length; s++) {

                    float u = (subFace[s][0] / this.Textures_U_scale[q] + 0.5);
                    float v = (-subFace[s][1] / this.Textures_V_scale[q] + 0.5);

                    //if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {
                    if ((0.05 > u) || (u > 0.95) || (0.05 > v) || (v > 0.95)) { // simply not to include the legends printed at the margin

                      n_Map = -1;

                      break;
                    }
                  }

                  if (n_Map == q) break;
                }
              }

              if (target_window == TypeWindow.SKY2D) {

                SKY2D_graphics.beginShape();
                SKY2D_graphics.fill(255);
                SKY2D_graphics.noStroke();

              }

              if (target_window == TypeWindow.WIN3D) {

                WIN3D.graphics.beginShape();

                WIN3D.graphics.strokeWeight(1);
                WIN3D.graphics.stroke(0, 0, 0);
                if (allFaces.displayEdges == false) WIN3D.graphics.noStroke();
                if (this.displayTexture) WIN3D.graphics.noStroke();

                if (this.displayTexture) {
                  if (n_Map != -1) {
                    WIN3D.graphics.texture(this.Textures_map[n_Map]);
                  } else {
                    WIN3D.graphics.noFill();
                    WIN3D.graphics.strokeWeight(1);
                    WIN3D.graphics.stroke(0, 0, 0);
                  }
                }
              }

              if (target_window == TypeWindow.OBJ3D) {

                if (_turn == 3) {

                  if (this.displayTexture) {

                    if (User3D.export_MaterialLibrary) {
                      if (n_Map != -1) {
                        objOutput.println("usemtl LandMap" + nf(n_Map, 0));
                      }
                    }
                  }
                }
              }

              if (target_window == TypeWindow.HTML) {

                htmlOutput.println("\t\t\t\t<shape>");

                if (n_Map != -1) {
                  htmlOutput.println("\t\t\t\t\t<Appearance USE='LandMap" + nf(n_Map, 0) + "'></Appearance>");
                }

                htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided

                htmlOutput.print  (" coordIndex='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(" ");
                  }
                  htmlOutput.print(nf(s, 0));
                }
                htmlOutput.println(" -1'>");

                htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(",");
                  }

                  htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                }
                htmlOutput.println("'></Coordinate>");

              }





              for (int s = 0; s < subFace.length; s++) {

                if (target_window == TypeWindow.SKY2D) {
                  SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
                }

                if (this.displayTexture == false) {

                  if (WIN3D.FacesShade != SHADE.Surface_Wire) {

                    float[] COL = {
                      255, 255, 255, 255
                    };

                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;

                      COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {

                      COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {

                      COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {

                      COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }

                    if (WIN3D.FacesShade == SHADE.Surface_White) {
                      COL = SHADE.vertexRender_Surface_White(255);
                    }

                    if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                      //COL = SHADE.vertexRender_Surface_Materials(mt);
                      COL = SHADE.vertexRender_Surface_White(223);
                    }




                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    }
                  } else {

                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.noFill();
                    }
                  }

                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                  }

                  if (target_window == TypeWindow.RAD3D) {

                    if (this.displayTexture) {

                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");

                      radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));

                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");

                      radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));

                    }
                  }



                } else {

                  float u = 0;
                  float v = 0;
                  if (n_Map != -1) {
                    u = (subFace[s][0] / this.Textures_U_scale[n_Map] + 0.5);
                    v = (-subFace[s][1] / this.Textures_V_scale[n_Map] + 0.5);
                  }

                  if (target_window == TypeWindow.WIN3D) {
                    if (n_Map != -1) {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_map[n_Map].width, v * this.Textures_map[n_Map].height);
                    }
                    else {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                    }
                  }

                  if (target_window == TypeWindow.OBJ3D) {

                    if (this.displayTexture) {

                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                      }
                      if (_turn == 2) {

                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }
                      if (_turn == 3) {
                        num_vertices_added += 1;
                      }
                    }
                  }

                  if (target_window == TypeWindow.LandMesh) {
                    if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center
                      allPoints.create(subFace[s][0], subFace[s][1], subFace[s][2]);
                    }
                  }


                  if (target_window == TypeWindow.HTML) {

                    if (n_Map != -1) {

                      if (s == 0) {
                        htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                      }
                      if (s > 0) {
                        htmlOutput.print(",");
                      }

                      v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                      SOLARCHVISION_HTMLprintVtexture(u, v);

                      if (s == subFace.length - 1) {
                        htmlOutput.println("'></TextureCoordinate>");
                      }
                    }

                  }

                }
              }


              if (target_window == TypeWindow.HTML) {

                htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

                htmlOutput.println("\t\t\t\t</shape>");

              }


              if (target_window == TypeWindow.SKY2D) {
                SKY2D_graphics.endShape(CLOSE);
              }

              if (target_window == TypeWindow.WIN3D) {
                WIN3D.graphics.endShape(CLOSE);
              }

              if (target_window == TypeWindow.OBJ3D) {

                if (_turn == 3) {

                  if (this.displayTexture) {

                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    if (User3D.export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }
              }

              if (target_window == TypeWindow.LandMesh) {
                if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center
                  int[] newFace = new int[4];
                  newFace[0] = allPoints.getLength() - 4;
                  newFace[1] = allPoints.getLength() - 3;
                  newFace[2] = allPoints.getLength() - 2;
                  newFace[3] = allPoints.getLength() - 1;
                  allFaces.create(newFace);
                }
              }



              if (this.displayTexture) {

                if (this.displayDepth) {


                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.fill(223, 223, 223);
                    WIN3D.graphics.noStroke();
                  }

                  for (int s = 0; s < subFace.length; s++) {

                    int s_next = (s + 1) % subFace.length;

                    float u = 0;
                    float v = 0;
                    if (n_Map != -1) {
                      u = (subFace[s][0] / this.Textures_U_scale[n_Map] + 0.5);
                      v = (-subFace[s][1] / this.Textures_V_scale[n_Map] + 0.5);
                    }

                    float u_next = (subFace[s_next][0] / this.Textures_U_scale[n_Map] + 0.5);
                    float v_next = (-subFace[s_next][1] / this.Textures_V_scale[n_Map] + 0.5);

                    if (target_window == TypeWindow.WIN3D) {

                      WIN3D.graphics.beginShape();

                      if (n_Map != -1) {
                        WIN3D.graphics.texture(this.Textures_map[n_Map]);

                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_map[n_Map].width, v * this.Textures_map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_map[n_Map].width, v_next * this.Textures_map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_map[n_Map].width, v_next * this.Textures_map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u * this.Textures_map[n_Map].width, v * this.Textures_map[n_Map].height);
                      }
                      else {
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                      }

                      WIN3D.graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }
          }



          if (target_window == TypeWindow.LandMesh) {
            // This is to create a polygon around the center
            if (i == 0) {

              int[] newFace = new int[this.num_columns - 1];
              for (int j = 0; j < newFace.length; j++) {
                newFace[j] = allPoints.create(this.Mesh[i + 1][j][0], this.Mesh[i + 1][j][1], this.Mesh[i + 1][j][2]);
              }
              allFaces.create(newFace);
            }
          }
        }
      }

      if (target_window == TypeWindow.OBJ3D) {
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }

      if (target_window == TypeWindow.WIN3D) {
        if (this.displayPoints) {

          WIN3D.graphics.fill(191, 191, 0);
          WIN3D.graphics.noStroke();

          WIN3D.graphics.sphereDetail(6, 4);

          for (int i = 0; i < this.num_rows; i++) {
            for (int j = 0; j < this.num_columns; j++) {

              float x = this.Mesh[i][j][0];
              float y = this.Mesh[i][j][1];
              float z = this.Mesh[i][j][2];

              float R = 2.0 * OBJECTS_scale; // <<<<<<<<<<

              WIN3D.graphics.pushMatrix();
              WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
              WIN3D.graphics.sphere(R);
              WIN3D.graphics.popMatrix();
            }
          }
        }
      }

      if (target_window == TypeWindow.LandMesh) {
        Select3D.Group_ids = new int [1];
        Select3D.Group_ids[0] = allGroups.num - 1;

        Modify3D.weldObjectsVertices_Selection(0);

      }

    }
  }



  void castShadows () {

    if (this.displaySurface) {

      int tessellation = this.displayTessellation;
      if (WIN3D.FacesShade == SHADE.Surface_Base) {
        tessellation = 0;
      }

      int totalNumberOfSubs = 1;
      if (tessellation > 0) totalNumberOfSubs = 4 * int(funcs.roundTo(pow(4, tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.


      for (int Li = this.skipStart; Li < this.num_rows - 1 - this.skipEnd; Li++) {
        for (int Lj = 0; Lj < this.num_columns - 1; Lj++) {

          float[][] base_Vertices = new float [4][3];

          base_Vertices[0][0] = this.Mesh[Li][Lj][0];
          base_Vertices[0][1] = this.Mesh[Li][Lj][1];
          base_Vertices[0][2] = this.Mesh[Li][Lj][2];

          base_Vertices[1][0] = this.Mesh[Li+1][Lj][0];
          base_Vertices[1][1] = this.Mesh[Li+1][Lj][1];
          base_Vertices[1][2] = this.Mesh[Li+1][Lj][2];

          base_Vertices[2][0] = this.Mesh[Li+1][Lj+1][0];
          base_Vertices[2][1] = this.Mesh[Li+1][Lj+1][1];
          base_Vertices[2][2] = this.Mesh[Li+1][Lj+1][2];

          base_Vertices[3][0] = this.Mesh[Li][Lj+1][0];
          base_Vertices[3][1] = this.Mesh[Li][Lj+1][1];
          base_Vertices[3][2] = this.Mesh[Li][Lj+1][2];

          for (int n = 0; n < totalNumberOfSubs; n++) {

            float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);
            float[][] subFace_Rotated = subFace;

            for (int s = 0; s < subFace_Rotated.length; s++) {
              if (allSolarImpacts.sectionType == 2) {
                float a = subFace_Rotated[s][0];
                float b = -subFace_Rotated[s][1];
                float c = subFace_Rotated[s][2];

                subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
                subFace_Rotated[s][1] = c;
                subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);
              } else if (allSolarImpacts.sectionType == 3) {
              }
            }

            SHADOW_graphics.beginShape();

            for (int s = 0; s < subFace_Rotated.length; s++) {

              float z = subFace_Rotated[s][2] - allSolarImpacts.Z;
              float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
              float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



              if (z >= 0) {

                if (allSolarImpacts.sectionType == 1) {
                  float px = x;
                  float py = y;

                  x = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                  y = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                }

                SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
              } else {
                int s_next = (s + 1) % subFace_Rotated.length;
                int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;

                float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.Z;
                float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                if (z_prev > 0) {
                  float ratio = z_prev / (z_prev - z);

                  float x_trim = x_prev * (1 - ratio) + x * ratio;
                  float y_trim = y_prev * (1 - ratio) + y * ratio;

                  if (allSolarImpacts.sectionType == 1) {
                    float px = x_trim;
                    float py = y_trim;

                    x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                    y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                  }

                  SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                }

                float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.Z;
                float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                if (z_next > 0) {
                  float ratio = z_next / (z_next - z);

                  float x_trim = x_next * (1 - ratio) + x * ratio;
                  float y_trim = y_next * (1 - ratio) + y * ratio;

                  if (allSolarImpacts.sectionType == 1) {
                    float px = x_trim;
                    float py = y_trim;

                    x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                    y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                  }

                  SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                }
              }
            }

            SHADOW_graphics.endShape(CLOSE);
          }
        }
      }
    }
  }



  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [(this.num_rows - 1) * (this.num_columns - 1)][4];

    for (int f = 0; f < (this.num_rows - 1) * (this.num_columns - 1); f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }

    for (int f = 0; f < (this.num_rows - 1) * (this.num_columns - 1); f++) {

      float X_intersect = FLOAT_undefined;
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;

      boolean InPoly = false;

      int LAND_i = f / (this.num_columns - 1);
      int LAND_j = f % (this.num_columns - 1);

      float[] A = this.Mesh[LAND_i][LAND_j];
      float[] B = this.Mesh[LAND_i][LAND_j + 1];
      float[] C = this.Mesh[LAND_i + 1][LAND_j + 1];
      float[] D = this.Mesh[LAND_i + 1][LAND_j];
      float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]), 0.25 * (A[1] + B[1] + C[1] + D[1]), 0.25 * (A[2] + B[2] + C[2] + D[2])};

      for (int i = 0; i < 4; i++) {

        float[] M = {0,0,0};
        float[] N = {0,0,0};

        if (i == 0) {
          M = A;
          N = B;
        } else if (i == 1) {
          M = B;
          N = C;
        } else if (i == 2) {
          M = C;
          N = D;
        } else if (i == 3) {
          M = D;
          N = A;
        }

        float[] NG = funcs.vec3_diff(N, G);
        float[] GM = funcs.vec3_diff(G, M);

        float[] face_norm = funcs.vec3_cross(NG, GM);

        float face_offset = ((G[0] + M[0] + N[0]) * face_norm[0] + (G[1] + M[1] + N[1]) * face_norm[1] + (G[2] + M[2] + N[2]) * face_norm[2]) / 3.0;

        float R = -funcs.vec3_dot(ray_dir, face_norm);

        if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
          dist2intersect = FLOAT_huge;
        }
        else {
          dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

          //if (dist2intersect > 0) {
          if (dist2intersect > FLOAT_tiny) {

            X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
            Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
            Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

            float[] P = {X_intersect, Y_intersect, Z_intersect};

            InPoly = funcs.isInside_Triangle(P, M, N, G);

          }
        }

        if (InPoly) break;
      }

      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }

    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < (this.num_rows - 1) * (this.num_columns - 1); f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }

    }

    return return_point;
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    {
      XML parent = xml.addChild(this.CLASS_STAMP);

      XML_setInt(parent, "displayTessellation", this.displayTessellation);
      XML_setBoolean(parent, "loadTextures", this.loadTextures);
      XML_setBoolean(parent, "loadMesh", this.loadMesh);
      XML_setBoolean(parent, "displaySurface", this.displaySurface);
      XML_setBoolean(parent, "displayPoints", this.displayPoints);
      XML_setBoolean(parent, "displayTexture", this.displayTexture);
      XML_setBoolean(parent, "displayDepth", this.displayDepth);
      XML_setInt(parent, "pallet_CLR", this.pallet_CLR);
      XML_setInt(parent, "pallet_DIR", this.pallet_DIR);
      XML_setFloat(parent, "pallet_MLT", this.pallet_MLT);
      XML_setInt(parent, "skipStart", this.skipStart);
      XML_setInt(parent, "skipEnd", this.skipEnd);
      XML_setInt(parent, "num_rows", this.num_rows);
      XML_setInt(parent, "num_columns", this.num_columns);


      int vNo = 0;
      for (int i = 0; i < this.Mesh.length; i++) {
        for (int j = 0; j < this.Mesh[i].length; j++) {
          XML child = parent.addChild("item");
          XML_setInt(child, "id", vNo);
          String txt = "";
          //for (int k = 0; k < this.Mesh[i][j].length; k++) {
          for (int k = 0; k < 3; k++) { // x, y, z
            txt += nf(this.Mesh[i][j][k], 0, 4).replace(",", "."); // <<<<
            if (k < this.Mesh[i][j].length - 1) txt += ",";
          }
          XML_setContent(child, txt);
          vNo += 1;
        }
      }
    }

    {
      boolean TEXTURE_copied = false;

      String the_dir = save_folder;

      for (int q = 0; q < this.Textures_num; q++) {

        int n_Map = q;

        String the_filename = this.Textures_path[n_Map].substring(this.Textures_path[n_Map].lastIndexOf("/") + 1); // image name

        String new_Texture_path = the_dir + "/Textures/" +  the_filename;

        if (this.Textures_path[n_Map].toUpperCase().equals(new_Texture_path.toUpperCase())) {
          TEXTURE_copied = false;
        } else {

          println("Copying texture:", this.Textures_path[n_Map], ">", new_Texture_path);
          saveBytes(new_Texture_path, loadBytes(this.Textures_path[n_Map]));
          this.Textures_path[n_Map] = new_Texture_path;

          TEXTURE_copied = true;
        }

        //if (TEXTURE_copied == false) {
        //  println("Saving texture from the scene.");
        //  this.Textures_map[n_Map].save(new_Texture_path);
        //}
      }

      XML parent = xml.addChild(this.CLASS_STAMP + ".Textures");
      XML_setInt(parent, "ni", this.Textures_num);

      for (int i = 0; i < this.Textures_num; i++) {
        XML child = parent.addChild("item");
        XML_setInt(child, "id", i);
        XML_setFloat(child, "U_scale", this.Textures_U_scale[i]);
        XML_setFloat(child, "V_scale", this.Textures_U_scale[i]);
        XML_setContent(child, this.Textures_path[i]);
      }
    }

  }






  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    {
      XML parent = xml.getChild(this.CLASS_STAMP);

      this.displayTessellation = XML_getInt(parent, "displayTessellation");
      this.loadTextures = XML_getBoolean(parent, "loadTextures");
      this.loadMesh = XML_getBoolean(parent, "loadMesh");
      this.displaySurface = XML_getBoolean(parent, "displaySurface");
      this.displayPoints = XML_getBoolean(parent, "displayPoints");
      this.displayTexture = XML_getBoolean(parent, "displayTexture");
      this.displayDepth = XML_getBoolean(parent, "displayDepth");
      this.pallet_CLR = XML_getInt(parent, "pallet_CLR");
      this.pallet_DIR = XML_getInt(parent, "pallet_DIR");
      this.pallet_MLT = XML_getFloat(parent, "pallet_MLT");
      this.skipStart = XML_getInt(parent, "skipStart");
      this.skipEnd = XML_getInt(parent, "skipEnd");
      this.num_rows = XML_getInt(parent, "num_rows");
      this.num_columns = XML_getInt(parent, "num_columns");


      this.Mesh = new float [this.num_rows][this.num_columns][3];

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < this.num_rows * this.num_columns; i++) {
        String txt = XML_getContent(children[i]);
        String[] parts = split(txt, ",");
        for (int j = 0; j < parts.length; j++) {
          this.Mesh[(i / this.num_columns)][(i % this.num_columns)][j] = float(parts[j]);
        }
      }
    }

    {

      XML parent = xml.getChild(this.CLASS_STAMP + ".Textures");

      int pre_Land3D_Textures_num = this.Textures_num;
      this.Textures_num = XML_getInt(parent, "ni");

      if (pre_Land3D_Textures_num != this.Textures_num) {
        int ni = this.Textures_num;
        this.Textures_path = new String [ni];
        this.Textures_map = new PImage [ni];
        for (int i = 0; i < this.Textures_num; i++) {
          this.Textures_path[i] = "";
          this.Textures_map[i] = createImage(2, 2, RGB); // empty and small
        }
      }

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < this.Textures_num; i++) {

        this.Textures_U_scale[i] = children[i].getFloat("U_scale");
        this.Textures_V_scale[i] = children[i].getFloat("V_scale");

        String new_Texture_path = XML_getContent(children[i]);

        if (this.Textures_path[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        } else {

          this.Textures_path[i] = new_Texture_path;

          if (this.Textures_path[i].equals("")) {
          } else {
            println("Loading texture:", this.Textures_path[i]);
            this.Textures_map[i] = loadImage(this.Textures_path[i]);
          }
        }
      }
    }


  }


}


solarchvision_Land3D Land3D = new solarchvision_Land3D();









class solarchvision_Model1Ds {

  private final static String CLASS_STAMP = "Model1Ds";

  solarchvision_Model1Ds () { // constructor
    makeEmpty(0);
  }

  int elementSegments = 5; // number of polygons to create each cone

  boolean displayAll = true;
  boolean displayLeaves = true;

  int num;
  float[][] f_data;
  int[][]   i_data;


  void makeEmpty (int n) {

    this.num = n;
    this.f_data = new float [n][11];
    this.i_data = new int   [n][3];

    if (allGroups != null) {
      for (int q = 0; q < allGroups.num; q++) {
        allGroups.Model1Ds[q][0] = 0;
        allGroups.Model1Ds[q][1] = -1;
      }
    }

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Model1Ds();
    }

    SOLARCHVISION_model_changed();
  }


  void create (int type, int seed, int degreeMax, float x, float y, float z, float s, float rot, float tilt, float twist, float ratio, float base, float trunkSize, float leafSize) {

    int[][] new_i_data = {
      {
        type, seed, degreeMax
      }
    };
    this.i_data = (int[][]) concat(this.i_data, new_i_data);

    float[][] new_f_data = {
      {
        x, y, z, s, rot, tilt, twist, ratio, base, trunkSize, leafSize
      }
    };
    this.f_data = (float[][]) concat(this.f_data, new_f_data);

    this.num += 1;

    if (User3D.create_MeshOrSolid != 0) {

      randomSeed(seed); // ??

//this.branch_add_allSolids();
    }


    if (allGroups.num > 0) allGroups.Model1Ds[allGroups.num - 1][1] = this.num - 1;

  }


  float getX (int n) {
    return this.f_data[n][0];
  }

  float getY (int n) {
    return this.f_data[n][1];
  }

  float getZ (int n) {
    return this.f_data[n][2];
  }

  float getScale (int n) {
    return this.f_data[n][3];
  }

  float getRotation (int n) {
    return this.f_data[n][4];
  }

  float getBranchTilt (int n) {
    return this.f_data[n][5];
  }

  float getBranchTwist (int n) {
    return this.f_data[n][6];
  }

  float getBranchRatio (int n) {
    return this.f_data[n][7];
  }

  float getTreeBase (int n) {
    return this.f_data[n][8];
  }

  float getTrunkSize (int n) {
    return this.f_data[n][9];
  }

  float getLeafSize (int n) {
    return this.f_data[n][10];
  }

  void setX (int n, float f) {
    this.f_data[n][0] = f;
  }

  void setY (int n, float f) {
    this.f_data[n][1] = f;
  }

  void setZ (int n, float f) {
    this.f_data[n][2] = f;
  }

  void setScale (int n, float f) {
    this.f_data[n][3] = f;
  }

  void setRotation (int n, float f) {
    this.f_data[n][4] = f;
  }

  void setBranchTilt (int n, float f) {
    this.f_data[n][5] = f;
  }

  void setBranchTwist (int n, float f) {
    this.f_data[n][6] = f;
  }

  void setBranchRatio (int n, float f) {
    this.f_data[n][7] = f;
  }

  void setTreeBase (int n, float f) {
    this.f_data[n][8] = f;
  }

  void setTrunkSize (int n, float f) {
    this.f_data[n][9] = f;
  }

  void setLeafSize (int n, float f) {
    this.f_data[n][10] = f;
  }


  void move (int n, float dx, float dy, float dz) {
    this.f_data[n][0] += dx;
    this.f_data[n][1] += dy;
    this.f_data[n][2] += dz;
  }

  void magS (int n, float f) {
    this.f_data[n][3] *= f;
  }


  int getType (int n) {
    return this.i_data[n][0];
  }

  int getSeed (int n) {
    return this.i_data[n][1];
  }

  int getDegreeMax (int n) {
    return this.i_data[n][2];
  }



  void setType (int n, int t) {
    this.i_data[n][0] = t;
  }

  void setSeed (int n, int t) {
    this.i_data[n][1] = t;
  }

  void setDegreeMax (int n, int t) {
    this.i_data[n][2] = t;
  }












  int nStart;
  float branchTilt;
  float branchTwist;
  float branchRatio;
  float treeBase;
  float leafSize;

  float[][] Vertices;
  int[][] Faces;

  int tree_id = -1; // internal
  int _turn = -1; // internal
  int target_window; // internal

  void draw (int tar_win) {

    target_window = tar_win;

    this.Faces = new int [this.num][4];
    this.Vertices = new float [4 * this.num][3];

    boolean proceed = true;

    if (this.displayAll == false) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {

      proceed = false;
    }


    if (proceed) {

      if (target_window == TypeWindow.OBJ3D) {
        if (User3D.export_MaterialLibrary) {

          if (this.num != 0) {

            mtlOutput.println("newmtl " + "Tree3D_Trunk");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 0.750 0.500"); // ambient
            mtlOutput.println("\tKd 1.000 0.750 0.500"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter


            mtlOutput.println("newmtl " + "Tee3D_Leaf");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 0.500 0.750 0.250"); // ambient
            mtlOutput.println("\tKd 0.500 0.750 0.250"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
        }
      }



      for (int f = 0; f < this.num; f++) {

        tree_id = f;

        float x = this.getX(f);
        float y = this.getY(f);
        float z = this.getZ(f);

        float rad = this.getScale(f) * 0.25;
        float rot = this.getRotation(f);

        int n = this.getType(f);

        int seed = this.getSeed(f);

        float trunkSize = this.getTrunkSize(f);

        leafSize = this.getLeafSize(f);

        branchTilt = this.getBranchTilt(f);
        branchTwist = this.getBranchTwist(f);
        branchRatio = this.getBranchRatio(f);
        treeBase = this.getTreeBase(f);

        nStart = this.getDegreeMax(f);


        if (n == 0) {

          if (target_window == TypeWindow.OBJ3D) {

            num_vertices_added = 0;

            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;
              objOutput.println("g Model1Ds_" + nf(f, 0));
            }
          }


          int end_turn = 1;
          if (target_window == TypeWindow.OBJ3D) end_turn = 3;

          for (_turn = 1; _turn <= end_turn; _turn++) {

            WIN3D.graphics.pushMatrix();

            WIN3D.graphics.scale(OBJECTS_scale * WIN3D.scale);
            WIN3D.graphics.translate(x, -y, z);
            WIN3D.graphics.rotateZ(rot);

            float treeHeight0 = rad;
            float treeWidth0 = rad * trunkSize * 0.15;

            randomSeed(seed);

            // Call to draw the tree
            this.makeBranch(treeWidth0, treeHeight0, nStart);

            WIN3D.graphics.popMatrix();





            // ----------------
            x *= OBJECTS_scale;
            y *= OBJECTS_scale;
            z *= OBJECTS_scale;
            rad *= OBJECTS_scale;
            // ----------------

            float t = PI + WIN3D.rotation_Z * PI / 180.0;
            if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI;


            this.Vertices[f * 4 + 0][0] = (x - rad * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 0][1] = (y - rad * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 0][2] = (z) / OBJECTS_scale;

            this.Vertices[f * 4 + 1][0] = (x + rad * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 1][1] = (y + rad * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 1][2] = (z) / OBJECTS_scale;

            this.Vertices[f * 4 + 2][0] = (x + rad * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 2][1] = (y + rad * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 2][2] = (z + 2 * rad) / OBJECTS_scale;

            this.Vertices[f * 4 + 3][0] = (x - rad * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 3][1] = (y - rad * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 3][2] = (z + 2 * rad) / OBJECTS_scale;

            this.Faces[f][0] = f * 4 + 0;
            this.Faces[f][1] = f * 4 + 1;
            this.Faces[f][2] = f * 4 + 2;
            this.Faces[f][3] = f * 4 + 3;

          }


          if (target_window == TypeWindow.OBJ3D) {
            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;
          }


        }
      }
    }
  }


  void makeBranch(float w, float h, int n) {

    // Note: this is a recursive function.

    if (n > 0) {

      WIN3D.graphics.pushMatrix();
      this.twistBranch(this.branchTwist);
      if ((n == this.nStart) && (this.treeBase > 0.0)) {
        this.drawElement(w, h * this.treeBase, n);
      }
      this.makeBranch(w * this.branchRatio, h * this.branchRatio, n - 1);
      WIN3D.graphics.popMatrix();

      if (n != this.nStart) {
        WIN3D.graphics.pushMatrix();
        this.twistBranch(this.branchTwist);
        this.tiltBranch(this.branchTilt);
        this.drawElement(w, h, n);
        this.makeBranch(w * this.branchRatio, h * this.branchRatio, n - 1);
        WIN3D.graphics.popMatrix();
      }

    }
  }




  void twistBranch (float angle) {

    WIN3D.graphics.rotateZ(angle * PI / 180.0);
  }


  void tiltBranch (float angle) {

    WIN3D.graphics.rotateY(angle * PI / 180.0);
  }


  void drawElement(float w, float h, int n) {

    WIN3D.graphics.pushMatrix();
    WIN3D.graphics.translate(0, 0, 0.5 * h);

    this.drawTrunk(w, h);

    WIN3D.graphics.popMatrix();

    WIN3D.graphics.translate(0, 0, h);

    if (n == 1) {
      this.drawLeaf();
    }
  }


  float[][][] leaf_faces = {{{-1,-1,-1}, { 1,-1,-1}, { 1, 1,-1}, {-1, 1,-1}},
                            {{-1,-1, 1}, { 1,-1, 1}, { 1, 1, 1}, {-1, 1, 1}},
                            {{-1,-1,-1}, { 1,-1,-1}, { 1,-1, 1}, {-1,-1, 1}},
                            {{ 1,-1,-1}, { 1, 1,-1}, { 1, 1, 1}, {-1, 1, 1}},
                            {{-1,-1,-1}, {-1, 1,-1}, {-1, 1, 1}, {-1,-1, 1}},
                            {{ 1,-1,-1}, { 1, 1,-1}, { 1, 1, 1}, { 1,-1, 1}}};

  int num_leaf_faces = leaf_faces.length;

  float[][] local_vertices = new float[4][3];

  void drawLeaf() {

    if (leafSize > 0) {

      WIN3D.graphics.fill(63, 127, 0);
      WIN3D.graphics.noStroke();

      for (int i = 0; i < num_leaf_faces; i++) {

        for (int j = 0; j < 4; j++) {

          this.local_vertices[j][0] = this.leaf_faces[i][j][0] * leafSize;
          this.local_vertices[j][1] = this.leaf_faces[i][j][1] * leafSize;
          this.local_vertices[j][2] = this.leaf_faces[i][j][2] * leafSize;
        }

        this.drawLocalFace("Leaf");
      }
    }
  }


  void drawTrunk(float w, float h) {

    WIN3D.graphics.fill(127, 63, 0);
    WIN3D.graphics.noStroke();

    for (int i = 0; i < this.elementSegments; i++) {

      for (int j = 0; j < 4; j++) {

        float u = 0;
        if ((j == 1) || (j == 2)) u = 1;

        float v = 0;
        if ((j == 2) || (j == 3)) v = 1;

        float T = w;
        if ((j == 2) || (j == 3)) T *= this.branchRatio; // for conic trunks

        this.local_vertices[j][0] = T * cos((i + u) * TWO_PI / float(this.elementSegments));
        this.local_vertices[j][1] = T * sin((i + u) * TWO_PI / float(this.elementSegments));
        this.local_vertices[j][2] = h * (v - 0.5);
      }

      this.drawLocalFace("Trunk");
    }
  }


  void drawLocalFace(String whichPart) {

    float[][] subFace = new float[this.local_vertices.length][3];

    if (target_window == TypeWindow.WIN3D) {
      WIN3D.graphics.beginShape();
    }

    for (int j = 0; j < this.local_vertices.length; j++) {

      float u = 0;
      if ((j == 1) || (j == 2)) u = 1;

      float v = 0;
      if ((j == 2) || (j == 3)) v = 1;

      float x = this.local_vertices[j][0];
      float y = this.local_vertices[j][1];
      float z = this.local_vertices[j][2];

      if (target_window == TypeWindow.WIN3D) {
        WIN3D.graphics.vertex(x, -y, z);
      }


      if (target_window == TypeWindow.SHADOW) {
        subFace[j][0] =  WIN3D.graphics.modelX(x,y,z) / (OBJECTS_scale * WIN3D.scale);
        subFace[j][1] = -WIN3D.graphics.modelY(x,y,z) / (OBJECTS_scale * WIN3D.scale);
        subFace[j][2] =  WIN3D.graphics.modelZ(x,y,z) / (OBJECTS_scale * WIN3D.scale);
      }

      if (target_window == TypeWindow.OBJ3D) {

        if (_turn == 1) {

          SOLARCHVISION_OBJprintVertex(WIN3D.graphics.modelX(x,y,z) / (OBJECTS_scale * WIN3D.scale),
                                      -WIN3D.graphics.modelY(x,y,z) / (OBJECTS_scale * WIN3D.scale),
                                       WIN3D.graphics.modelZ(x,y,z) / (OBJECTS_scale * WIN3D.scale));

        }

        if (_turn == 2) {

          SOLARCHVISION_OBJprintVtexture(u, v, 0);
        }

      }
    }

    if (target_window == TypeWindow.OBJ3D) {
      if (_turn == 3) {

        num_vertices_added += 4;

        String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
        String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
        String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
        String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

        String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
        String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
        String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
        String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

        if (User3D.export_PolyToPoly == 0) {
          obj_lastGroupNumber += 1;
          objOutput.println("g Tree3D_" + whichPart + "_" + nf(tree_id, 0));
        }

        if (User3D.export_MaterialLibrary) {
          objOutput.println("usemtl Tree3D_" + whichPart);
        }

        obj_lastFaceNumber += 1;
        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);

      }

    }




    if (target_window == TypeWindow.SHADOW) {

      float[][] subFace_Rotated = subFace;

      for (int s = 0; s < subFace_Rotated.length; s++) {
        if (allSolarImpacts.sectionType == 2) {
          float a = subFace_Rotated[s][0];
          float b = -subFace_Rotated[s][1];
          float c = subFace_Rotated[s][2];

          subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
          subFace_Rotated[s][1] = c;
          subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);
        } else if (allSolarImpacts.sectionType == 3) {
        }
      }

      SHADOW_graphics.beginShape();

      for (int s = 0; s < subFace_Rotated.length; s++) {

        float z = subFace_Rotated[s][2] - allSolarImpacts.Z;
        float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
        float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];

        if (z >= 0) {

          if (allSolarImpacts.sectionType == 1) {
            float px = x;
            float py = y;

            x = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
            y = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
          }

          SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY);
        } else {
          int s_next = (s + 1) % subFace_Rotated.length;
          int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;

          float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.Z;
          float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
          float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

          if (z_prev > 0) {
            float ratio = z_prev / (z_prev - z);

            float x_trim = x_prev * (1 - ratio) + x * ratio;
            float y_trim = y_prev * (1 - ratio) + y * ratio;

            if (allSolarImpacts.sectionType == 1) {
              float px = x_trim;
              float py = y_trim;

              x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
              y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
            }

            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
          }

          float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.Z;
          float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
          float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

          if (z_next > 0) {
            float ratio = z_next / (z_next - z);

            float x_trim = x_next * (1 - ratio) + x * ratio;
            float y_trim = y_next * (1 - ratio) + y * ratio;

            if (allSolarImpacts.sectionType == 1) {
              float px = x_trim;
              float py = y_trim;

              x_trim = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
              y_trim = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
            }

            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
          }
        }
      }

      SHADOW_graphics.endShape(CLOSE);
    }




    if (target_window == TypeWindow.WIN3D) {
      WIN3D.graphics.endShape(CLOSE);
    }
  }






  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Faces.length][4];

    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }

    for (int f = 0; f < this.Faces.length; f++) {

      int n = this.Faces[f].length;

      float X_intersect = FLOAT_undefined;
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;

      boolean InPoly = false;

      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];

      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);

      float[] face_norm = funcs.vec3_cross(AC, BD);

      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

      float R = -funcs.vec3_dot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {

          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }

      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }

    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.Faces.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }

    }

    return return_point;
  }











  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    int ni = this.num;
    XML_setInt(parent, "ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);

      XML_setInt(child, "type", getType(i));
      XML_setInt(child, "seed", getSeed(i));
      XML_setInt(child, "degreeMax", getDegreeMax(i));


      String txt = "";
      txt += nf(this.getX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getScale(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getRotation(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getBranchTilt(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getBranchTwist(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getBranchRatio(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getTreeBase(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getTrunkSize(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.getLeafSize(i), 0, 4).replace(",", "."); // <<<<

      XML_setContent(child, txt);
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);
    XML_setBoolean(parent, "displayLeaves", this.displayLeaves);
  }

  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = XML_getInt(parent, "ni");

    this.makeEmpty(ni);

    XML[] children = parent.getChildren("item");
    for (int i = 0; i < ni; i++) {

      this.setType(i, children[i].getInt("type"));
      this.setSeed(i, children[i].getInt("seed"));
      this.setDegreeMax(i, children[i].getInt("degreeMax"));

      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");

      this.setX(i, float(parts[0]));
      this.setY(i, float(parts[1]));
      this.setZ(i, float(parts[2]));
      this.setScale(i, float(parts[3]));
      this.setRotation(i, float(parts[4]));
      this.setBranchTilt(i, float(parts[5]));
      this.setBranchTwist(i, float(parts[6]));
      this.setBranchRatio(i, float(parts[7]));
      this.setTreeBase(i, float(parts[8]));
      this.setTrunkSize(i, float(parts[9]));
      this.setLeafSize(i, float(parts[10]));

    }

    this.displayAll = XML_getBoolean(parent, "displayAll");
    this.displayLeaves = XML_getBoolean(parent, "displayLeaves");
  }

}

solarchvision_Model1Ds allModel1Ds = new solarchvision_Model1Ds();







class solarchvision_Model2Ds {

  private final static String CLASS_STAMP = "Model2Ds";

  solarchvision_Model2Ds () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = true;

  int num;
  float[][] XYZS;

  void makeEmpty (int n) {

    this.num = n;
    this.XYZS = new float [n][4];
    this.MAP = new int [n];

    if (allGroups != null) {
      for (int q = 0; q < allGroups.num; q++) {
        allGroups.Model2Ds[q][0] = 0;
        allGroups.Model2Ds[q][1] = -1;
      }
    }

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Model2Ds();
    }

    SOLARCHVISION_model_changed();
  }

  void create (String t, int m, float x, float y, float z, float s) {

    int n1 = this.num_files_PEOPLE;
    int n2 = this.num_files_PEOPLE + this.num_files_TREES;

    int n = m;

    if (n == 0) {
      if (t.equals("PEOPLE")) n = int(random(1, 1 + n1));
      else if (t.equals("TREES")) n = int(random(1 + n1, 1 + n2));
    }

    int d = 1;
    int r = int(random(2));
    if (r == 0) d = -1;

    int[] Temp_MAP = {
      d * n
    };
    this.MAP = concat(this.MAP, Temp_MAP);

    float[][] Temp_XYZS = {
      {
        x, y, z, s
      }
    };
    this.XYZS = (float[][]) concat(this.XYZS, Temp_XYZS);

    this.num += 1;

    if (this.isTree(n)) {

      if (User3D.create_MeshOrSolid != 0) {

        float x0 = x;
        float y0 = y;
        float z0 = 0.5 * s + z;
        float r0 = 0.4 * s; // <<<<<<< approximate

        allSolids.create(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, User3D.create_MeshOrSolid);
      }
    }

    if (allGroups.num > 0) allGroups.Model2Ds[allGroups.num - 1][1] = this.num - 1;
  }


  float getX (int n) {
    return this.XYZS[n][0];
  }

  float getY (int n) {
    return this.XYZS[n][1];
  }

  float getZ (int n) {
    return this.XYZS[n][2];
  }

  float getS (int n) {
    return this.XYZS[n][3];
  }

  void setX (int n, float f) {
    this.XYZS[n][0] = f;
  }

  void setY (int n, float f) {
    this.XYZS[n][1] = f;
  }

  void setZ (int n, float f) {
    this.XYZS[n][2] = f;
  }

  void setS (int n, float f) {
    this.XYZS[n][3] = f;
  }

  void move (int n, float dx, float dy, float dz) {
    this.XYZS[n][0] += dx;
    this.XYZS[n][1] += dy;
    this.XYZS[n][2] += dz;
  }

  void magS (int n, float f) {
    this.XYZS[n][3] *= f;
  }

  int[] MAP = new int[0];

  String[] ImagePath;
  int num_files_PEOPLE = 0;
  int num_files_TREES = 0;

  int num_visualFaces = 3; // internal - number of faces: Vertical, Horizontal Front, Horizontal Back

  String[] Filenames_PEOPLE;
  String[] Filenames_TREES;

  PImage[] Images;
  float[] ImageRatios;

  float[][] Vertices;
  int[][] Faces;

  boolean isTree (int n) {
    if (abs(n) > this.num_files_PEOPLE) {
      return true;
    }
    return false;
  }

  void load_images () {

    this.ImagePath = new String [1];
    this.ImagePath[0] = "";

    this.Filenames_PEOPLE = sort(OPESYS.getFiles(Folder_People));
    this.Filenames_TREES = sort(OPESYS.getFiles(Folder_Trees));

    this.ImagePath = concat(this.ImagePath, this.Filenames_PEOPLE);
    this.ImagePath = concat(this.ImagePath, this.Filenames_TREES);

    this.num_files_PEOPLE = this.Filenames_PEOPLE.length;
    this.num_files_TREES = this.Filenames_TREES.length;


    int n = this.ImagePath.length;

    this.Images = new PImage [n + 1];
    this.ImageRatios = new float [n + 1];

    for (int i = 1; i < n; i++) { // leaving [0] null

      if (i <= this.num_files_PEOPLE) {
        this.ImagePath[i] = Folder_People + "/" + this.ImagePath[i];
      } else {
        this.ImagePath[i] = Folder_Trees + "/" + this.ImagePath[i];
      }
    }

    for (int i = 1; i < n; i++) {
      //println(this.ImagePath[i]);
      this.Images[i] = loadImage(this.ImagePath[i]);

      if (this.Images[i].height != 0) {
        this.ImageRatios[i] = float(this.Images[i].width) / float(this.Images[i].height);
      } else {
        this.ImageRatios[i] = 1;
      }
    }
  }


  void draw (int target_window) {

    this.Faces = new int [this.num * this.num_visualFaces][4];
    this.Vertices = new float [4 * this.num * this.num_visualFaces][5]; // note we are keeping u & v at 3rd and 4th members

    boolean proceed = true;

    if (this.displayAll == false) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {

      proceed = false;
    }

    if (proceed) {

      if (User3D.export_MaterialLibrary) {

        if ((target_window == TypeWindow.HTML) ||
            (target_window == TypeWindow.OBJ3D)) {

          int[] ImageUsed = new int [this.ImagePath.length];

          for (int i = 0; i < ImageUsed.length; i++) {
            ImageUsed[i] = 0;
          }

          for (int f = 0; f < this.num; f++) {

            int n = abs(this.MAP[f]);

            ImageUsed[n] += 1;
          }

          for (int i = 1; i < this.ImagePath.length; i++) {

            if (ImageUsed[i] != 0) {

              String old_Texture_path = this.ImagePath[i];

              String new_Texture_path = "";

              String opacity_Texture_path = "";

              String the_filename = "";

              if (this.ImagePath[i].equals("")) {
              } else {

                the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

                new_Texture_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;
                opacity_Texture_path = Folder_Export3D + "/" + Subfolder_exportMaps + "opacity_" + the_filename;

                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));

                println("Making opacity texture:", new_Texture_path);

                int RES1 = this.Images[i].width;
                int RES2 = this.Images[i].height;

                PImage Opacity_Texture = createImage(RES1, RES2, ARGB);

                Opacity_Texture.loadPixels();

                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;

                  color COL = this.Images[i].get(Image_X, Image_Y);
                  //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;

                  float COL_V = (COL >> 24 & 0xFF);

                  Opacity_Texture.pixels[np] = color(COL_V, COL_V, COL_V, COL_V);
                }

                Opacity_Texture.updatePixels();

                Opacity_Texture.save(opacity_Texture_path);

                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t<Appearance DEF='this." + the_filename + "'>");
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                  htmlOutput.println("\t\t\t\t</Appearance>");
                }

                if (target_window == TypeWindow.OBJ3D) {

                  mtlOutput.println("newmtl " + CLASS_STAMP + the_filename);
                  mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                  mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                  mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                  mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                  mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                  mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                  mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                  mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                  mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + "opacity_" + the_filename); // diffuse map
                }
              }
            }
          }
        }
      }





      float[] DistZ = new float [this.num];

      for (int f = 0; f < this.num; f++) {
        float x = this.getX(f) * OBJECTS_scale;
        float y = this.getY(f) * OBJECTS_scale;
        float z = this.getZ(f) * OBJECTS_scale;

        DistZ[f] = dist(x, y, z, WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z);
      }

      for (int g = 0; g < this.num; g++) {

        int f = -1;
        float max_dist = -1;

        for (int q = 0; q < this.num; q++) {
          if (max_dist < DistZ[q]) {
            max_dist = DistZ[q];
            f = q;
          }
        }

        DistZ[f] = -1;



        if (f != -1) {

          int n = abs(this.MAP[f]);

          int w = this.Images[n].width;
          int h = this.Images[n].height;

          float x = this.getX(f) * OBJECTS_scale;
          float y = this.getY(f) * OBJECTS_scale;
          float z = this.getZ(f) * OBJECTS_scale;

          float rh = this.getS(f) * 0.5 * OBJECTS_scale;
          float rw = rh * this.ImageRatios[n];

          float t = PI + WIN3D.rotation_Z * PI / 180.0;
          if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI;

          if ((target_window == TypeWindow.HTML) ||
              (target_window == TypeWindow.OBJ3D)) {

            t = 0;
          }

          if (this.MAP[f] < 0) t += PI;


          float dx = rw * cos(t);
          float dy = rw * sin(t);

          float x1 = x - dx;
          float y1 = y - dy;

          float x2 = x + dx;
          float y2 = y + dy;

          if (target_window == TypeWindow.OBJ3D) {

            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;
              objOutput.println("g this." + nf(f, 0) + "_type" + nf(n, 0));
            }

            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1).replace('.', '_'));
            }
          }

          num_vertices_added = 0;

          int end_turn = 1;
          if (target_window == TypeWindow.OBJ3D) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
            for (int back_front = -1; back_front <= 1; back_front++) {
              if (back_front == 0) {

                if (target_window == TypeWindow.WIN3D) {

                  WIN3D.graphics.beginShape();

                  WIN3D.graphics.texture(this.Images[n]);
                  WIN3D.graphics.stroke(255, 255, 255, 0);
                  WIN3D.graphics.fill(255, 255, 255, 0);

                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, z * WIN3D.scale, 0, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, z * WIN3D.scale, w, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, w, 0);
                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, 0, 0);

                  WIN3D.graphics.endShape(CLOSE);
                }

                if (target_window == TypeWindow.OBJ3D) {

                  if (_turn == 1) {

                    SOLARCHVISION_OBJprintVertex(x1, y1, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh));
                    SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh));

                    num_vertices_added += 4;

                  }

                  if (_turn == 2) {
                      SOLARCHVISION_OBJprintVtexture(1, 0, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 0, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1, 0);
                      SOLARCHVISION_OBJprintVtexture(1, 1, 0);
                  }

                  if (_turn == 3) {
                    obj_lastVertexNumber += num_vertices_added;
                    obj_lastVtextureNumber += num_vertices_added;

                    String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 1, 0);
                    String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 3, 0);
                    String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4, 0);

                    String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 1, 0);
                    String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 3, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4, 0);

                    if (User3D.export_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g this." + nf(f, 0) + "_ver");
                    }

                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    if (User3D.export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }


                if (target_window == TypeWindow.HTML) {

                  htmlOutput.println("\t\t\t\t<shape>");

                  htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");

                  htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided

                  htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                  htmlOutput.print  (      nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf(z, 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf(z, 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, User3D.export_PrecisionVertex));
                  htmlOutput.println("'></Coordinate>");

                  htmlOutput.println("\t\t\t\t\t\t<TextureCoordinate point='1 0,0 0,0 1,1 1'></TextureCoordinate>");

                  htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

                  htmlOutput.println("\t\t\t\t</shape>");
                }

                int nv = f * this.num_visualFaces * 4;
                int nf = f * this.num_visualFaces;

                this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 0][3] = 0;
                this.Vertices[nv + 0][4] = 1;

                this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 1][3] = 1;
                this.Vertices[nv + 1][4] = 1;

                this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 2][3] = 1;
                this.Vertices[nv + 2][4] = 0;

                this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 3][3] = 0;
                this.Vertices[nv + 3][4] = 0;

                this.Faces[nf][0] = nv + 0;
                this.Faces[nf][1] = nv + 1;
                this.Faces[nf][2] = nv + 2;
                this.Faces[nf][3] = nv + 3;
              }
              else {

                int nv = f * this.num_visualFaces * 4;
                int nf = f * this.num_visualFaces;

                if (back_front == -1) {
                  nv += 4;
                  nf += 1;
                }
                else {
                  nv += 8;
                  nf += 2;
                }

                if (this.isTree(n)) { // case: trees

                  float ratio = 0.5;

                  float rot = back_front * PI / 2 + t;

                  dx = rw * cos(rot);
                  dy = rw * sin(rot);

                  float x3 = x2 + dx;
                  float y3 = y2 + dy;

                  float x4 = x1 + dx;
                  float y4 = y1 + dy;

                  if (target_window == TypeWindow.WIN3D) {

                    WIN3D.graphics.beginShape();

                    WIN3D.graphics.texture(this.Images[n]);
                    WIN3D.graphics.stroke(255, 255, 255, 0);
                    WIN3D.graphics.fill(255, 255, 255, 0);

                    WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, h * ratio);
                    WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, h * ratio);
                    WIN3D.graphics.vertex(x3 * WIN3D.scale, -y3 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, 0);
                    WIN3D.graphics.vertex(x4 * WIN3D.scale, -y4 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, 0);

                    WIN3D.graphics.endShape(CLOSE);
                  }

                  if (target_window == TypeWindow.OBJ3D) {
                    if (_turn == 1) {

                      SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x3, y3, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x4, y4, (z + 2 * rh * ratio));

                      num_vertices_added += 4;
                    }

                    if (_turn == 2) {

                      SOLARCHVISION_OBJprintVtexture(1, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1, 0);
                      SOLARCHVISION_OBJprintVtexture(1, 1, 0);
                    }

                    if (_turn == 3) {

                      int q = (back_front + 1) / 2;

                      String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 1, 0);
                      String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 4, 0);

                      String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 1, 0);
                      String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 4, 0);

                      if (User3D.export_PolyToPoly == 0) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g this." + nf(f, 0) + "_hor" + nf(q, 0));
                      }

                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (User3D.export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }
                  }

                  if (target_window == TypeWindow.HTML) {

                    htmlOutput.println("\t\t\t\t<shape>");

                    htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");

                    htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided

                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    htmlOutput.print  (      nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x3, 0, User3D.export_PrecisionVertex) + " " + nf(y3, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x4, 0, User3D.export_PrecisionVertex) + " " + nf(y4, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.println("'></Coordinate>");

                    htmlOutput.print ("\t\t\t\t\t\t<TextureCoordinate point='");

                    SOLARCHVISION_HTMLprintVtexture(1, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(1, 1);
                    htmlOutput.println("'></TextureCoordinate>");

                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

                    htmlOutput.println("\t\t\t\t</shape>");
                  }

                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = ratio;

                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = ratio;

                  this.Vertices[nv + 2][0] = x3 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y3 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;

                  this.Vertices[nv + 3][0] = x4 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y4 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;

                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;
                }
                else { // case: people
                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = 1;

                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = 1;

                  this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;

                  this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;

                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;
                }
              }
            }
          }
        }
      }
    }
  }


  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Faces.length][6];

    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
      hitPoint[f][4] = FLOAT_undefined;
      hitPoint[f][5] = FLOAT_undefined;
    }

    for (int f = 0; f < this.Faces.length; f++) {

      int n = this.Faces[f].length;

      float X_intersect = FLOAT_undefined;
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;

      //boolean InPoly = false;
      float[] UV = {FLOAT_undefined, FLOAT_undefined};

      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];

      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);

      float[] face_norm = funcs.vec3_cross(AC, BD);

      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

      float R = -funcs.vec3_dot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {

          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          UV = funcs.uvInside_Rectangle(P, A, B, C);
        }
      }

      float u = UV[0];
      float v = UV[1];

      if ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1)) {

        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
        // converting rom face UV to image UV
        hitPoint[f][4] = (1 - u) * B[3] + u * A[3];
        hitPoint[f][5] = (1 - v) * B[4] + v * C[4];

      }
    }


    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.Faces.length; f++) {

      int OBJ_ID = f / this.num_visualFaces;

      if (pre_dist > hitPoint[f][3]) {

        float u = hitPoint[f][4];
        float v = hitPoint[f][5];

        int n = abs(this.MAP[OBJ_ID]);

        int RES1 = this.Images[n].width;
        int RES2 = this.Images[n].height;

        this.Images[n].loadPixels();

        if (n < 0) u = 1 - u;

        //println("uv,n", u, v, n);

        int Image_X = int(u * RES1);
        int Image_Y = int(v * RES2);

        color COL = this.Images[n].get(Image_X, Image_Y);
        //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;

        float COL_V = (COL >> 24 & 0xFF);

        if (COL_V > 0) {

          pre_dist = hitPoint[f][3];

          return_point[0] = OBJ_ID;
          return_point[1] = hitPoint[f][0];
          return_point[2] = hitPoint[f][1];
          return_point[3] = hitPoint[f][2];
          return_point[4] = hitPoint[f][3];
        }
      }

    }

    return return_point;
  }









  void castShadows (float[] SunR) {

    for (int f = 0; f < this.num; f++) {

      int n = abs(this.MAP[f]);

      int w = this.Images[n].width;
      int h = this.Images[n].height;

      float r = this.getS(f) * 0.5;

      float t = atan2(SunR[2], SunR[1]) + 0.5 * PI;

      if (this.MAP[f] < 0) t += PI;

      if (r > 2.5) { // to select only trees!

        float x = this.getX(f);
        float y = this.getY(f);
        float z = this.getZ(f);

        { // Vertical mask
          TREES_graphics.beginShape();

          TREES_graphics.texture(this.Images[n]);

          x = this.getX(f);
          y = this.getY(f);
          z = this.getZ(f);

          float[] TX = {
            0, 0, 0, 0
          };
          float[] TY = {
            0, 0, 0, 0
          };
          float[] TZ = {
            0, 0, 0, 0
          };
          float[] TU = {
            0, 0, 0, 0
          };
          float[] TV = {
            0, 0, 0, 0
          };

          TX[0] = x - r * cos(t);
          TY[0] = y - r * sin(t);
          TZ[0] = z;
          TX[1] = x + r * cos(t);
          TY[1] = y + r * sin(t);
          TZ[1] = z;
          TX[2] = x + r * cos(t);
          TY[2] = y + r * sin(t);
          TZ[2] = z + 2 * r;
          TX[3] = x - r * cos(t);
          TY[3] = y - r * sin(t);
          TZ[3] = z + 2 * r;

          TU[0] = 0;
          TV[0] = h;
          TU[1] = w;
          TV[1] = h;
          TU[2] = w;
          TV[2] = 0;
          TU[3] = 0;
          TV[3] = 0;

          if (allSolarImpacts.sectionType == 2) {
            {
              for (int q = 0; q < 4; q++) {
                float a = TX[q];
                float b = -TY[q];
                float c = TZ[q];

                TX[q] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
                TY[q] = c;
                TZ[q] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);
              }
            }
            { // now that we rotated 2D we could rotate x,y,z
              float a = x;
              float b = -y;
              float c = z;

              x = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
              y = c;
              z = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);
            }
          } else if (allSolarImpacts.sectionType == 3) {
          }

          if ((TZ[0] < allSolarImpacts.Z) && (allSolarImpacts.Z < TZ[2])) {

            float ratio = (allSolarImpacts.Z - TZ[0]) / (TZ[2] - TZ[0]);

            TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
            TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);

            if (allSolarImpacts.sectionType == 1) {

              TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
              TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
            } else if (allSolarImpacts.sectionType == 2) {

              TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
              TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
            } else if (allSolarImpacts.sectionType == 3) {
            }
          }

          if (TZ[2] > allSolarImpacts.Z) {

            for (int q = 0; q < 4; q++) {

              TZ[q] = TZ[q] - allSolarImpacts.Z;
              TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
              TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);

              if (allSolarImpacts.sectionType == 1) {
                float px = TX[q];
                float py = TY[q];

                TX[q] = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                TY[q] = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
              }

              TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
            }
          }

          TREES_graphics.endShape(CLOSE);
        }

        { // Horizontal mask
          float ratio = 0.5; // put the mask at half of the height of the tree

          for (int back_front = -1; back_front <= 1; back_front += 2) {

            float rot = back_front * PI / 2 + t;

            TREES_graphics.beginShape();

            TREES_graphics.texture(this.Images[n]);

            float[] TX = {
              0, 0, 0, 0
            };
            float[] TY = {
              0, 0, 0, 0
            };
            float[] TZ = {
              0, 0, 0, 0
            };
            float[] TU = {
              0, 0, 0, 0
            };
            float[] TV = {
              0, 0, 0, 0
            };

            TX[0] = x - r * cos(t);
            TY[0] = y - r * sin(t);
            TZ[0] = z + 2 * r * ratio;
            TX[1] = x + r * cos(t);
            TY[1] = y + r * sin(t);
            TZ[1] = z + 2 * r * ratio;
            TX[2] = x + r * cos(t) + r * cos(rot);
            TY[2] = y + r * sin(t) + r * sin(rot);
            TZ[2] = z + 2 * r * ratio;
            TX[3] = x - r * cos(t) + r * cos(rot);
            TY[3] = y - r * sin(t) + r * sin(rot);
            TZ[3] = z + 2 * r * ratio;

            TU[0] = 0;
            TV[0] = h * ratio;
            TU[1] = w;
            TV[1] = h * ratio;
            TU[2] = w;
            TV[2] = 0;
            TU[3] = 0;
            TV[3] = 0;

            if (allSolarImpacts.sectionType == 1) {
              if (z + 2 * r * ratio > allSolarImpacts.Z) {

                for (int q = 0; q < 4; q++) {

                  TZ[q] = TZ[q] - allSolarImpacts.Z;
                  TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                  TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);

                  if (allSolarImpacts.sectionType == 1) {
                    float px = TX[q];
                    float py = TY[q];

                    TX[q] = px * funcs.cos_ang(-allSolarImpacts.R) - py * funcs.sin_ang(-allSolarImpacts.R);
                    TY[q] = px * funcs.sin_ang(-allSolarImpacts.R) + py * funcs.cos_ang(-allSolarImpacts.R);
                  }

                  TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                }
              }
            }

            TREES_graphics.endShape(CLOSE);
          }
        }
      }
    }
  }




  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    {
      XML parent = xml.addChild(this.CLASS_STAMP);

      int ni = this.num;
      XML_setInt(parent, "ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        XML_setInt(child, "id", i);
        String txt = "";
        txt += nf(this.getX(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getY(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getZ(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getS(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += this.MAP[i];

        XML_setContent(child, txt);
      }

      XML_setBoolean(parent, "displayAll", this.displayAll);
      XML_setInt(parent, "num_files_PEOPLE", this.num_files_PEOPLE);
      XML_setInt(parent, "num_files_TREES", this.num_files_TREES);
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Textures");
      int ni = this.ImagePath.length;
      XML_setInt(parent, "ni", ni);
      for (int i = 0; i < ni; i++) {

        boolean TEXTURE_copied = false;

        String the_dir = save_folder;

        String the_filename = "";
        if (this.ImagePath[i].equals("")) {
        } else {
          the_filename = this.ImagePath[i].substring(this.ImagePath[i].lastIndexOf("/") + 1); // image name


          String new_Texture_path = the_dir + "/Textures/" + the_filename;

          if (this.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
            TEXTURE_copied = false;
          } else {
            if (this.ImagePath[i].equals("")) {
            } else {
              println("Copying texture:", this.ImagePath[i], ">", new_Texture_path);
              saveBytes(new_Texture_path, loadBytes(this.ImagePath[i]));
              this.ImagePath[i] = new_Texture_path;

              TEXTURE_copied = true;
            }
          }

          //if (TEXTURE_copied == false) {
          //  println("Saving texture from the scene.");
          //  this.Images[i].save(new_Texture_path);
          //}
        }

        XML child = parent.addChild("item");
        XML_setInt(child, "id", i);
        XML_setContent(child, this.ImagePath[i]);
      }
    }
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    {
      XML parent = xml.getChild(this.CLASS_STAMP);

      int ni = XML_getInt(parent, "ni");

      this.makeEmpty(ni);

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < ni; i++) {
        String txt = XML_getContent(children[i]);
        String[] parts = split(txt, ",");
        this.setX(i, float(parts[0]));
        this.setY(i, float(parts[1]));
        this.setZ(i, float(parts[2]));
        this.setS(i, float(parts[3]));
        this.MAP[i] = int(parts[4]);
      }

      this.displayAll = XML_getBoolean(parent, "displayAll");
      this.num_files_PEOPLE = XML_getInt(parent, "num_files_PEOPLE");
      this.num_files_TREES = XML_getInt(parent, "num_files_TREES");
    }

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Textures");

      int ni = XML_getInt(parent, "ni");

      int reload_All_textures = 0;

      if (this.ImagePath.length != ni) {
        this.Images = new PImage [ni];
        this.ImageRatios = new float [ni];

        reload_All_textures = 1;
      }

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < ni; i++) {

        String new_Texture_path = XML_getContent(children[i]);
        if ((reload_All_textures == 0) && (this.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase()))) {
        } else {
          this.ImagePath[i] = new_Texture_path;
          this.Images[i] = createImage(2, 2, RGB); // empty and small
          if (this.ImagePath[i].equals("")) {
          } else {
            println("Loading texture(" + i + "):", this.ImagePath[i]);
            this.Images[i] = loadImage(this.ImagePath[i]);
            println("loaded!");

            if (this.Images[i].height != 0) {
              this.ImageRatios[i] = float(this.Images[i].width) / float(this.Images[i].height);
            } else {
              this.ImageRatios[i] = 1;
            }
          }
        }
      }
    }
  }
}

solarchvision_Model2Ds allModel2Ds = new solarchvision_Model2Ds();




class solarchvision_Solids {

  private final static String CLASS_STAMP = "Solids";

  solarchvision_Solids () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = true;
  int pallet_CLR = 17; //1;
  int pallet_DIR = -1;
  float pallet_MLT = 0.01; //1;

  float[][] DEF;

  void makeEmpty (int n) {
    this.DEF = new float [n][13];

    if (allGroups != null) {
      for (int q = 0; q < allGroups.num; q++) {
        allGroups.Solids[q][0] = 0;
        allGroups.Solids[q][1] = -1;
      }
    }

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Solids();
    }

    SOLARCHVISION_model_changed();
  }

  void updatePosition (int n, float a, float b, float c) {

    this.DEF[n][0] = a;
    this.DEF[n][1] = b;
    this.DEF[n][2] = c;
  }

  void updatePowers (int n, float a, float b, float c) {

    this.DEF[n][3] = a;
    this.DEF[n][4] = b;
    this.DEF[n][5] = c;
  }

  void Scale (int n, float a, float b, float c) {

    this.DEF[n][6] *= a;
    this.DEF[n][7] *= b;
    this.DEF[n][8] *= c;
  }

  void RotateX (int n, float f) {

    this.DEF[n][9] += f;
  }

  void RotateY (int n, float f) {

    this.DEF[n][10] += f;
  }

  void RotateZ (int n, float f) {

    this.DEF[n][11] += f;
  }

  void set_posX (int n, float f) {

    this.DEF[n][0] = f;
  }

  void set_posY (int n, float f) {

    this.DEF[n][1] = f;
  }

  void set_posZ (int n, float f) {

    this.DEF[n][2] = f;
  }

  void set_powX (int n, float f) {

    this.DEF[n][3] = f;
  }

  void set_powY (int n, float f) {

    this.DEF[n][4] = f;
  }

  void set_powZ (int n, float f) {

    this.DEF[n][5] = f;
  }

  void set_scaleX (int n, float f) {

    this.DEF[n][6] = f;
  }

  void set_scaleY (int n, float f) {

    this.DEF[n][7] = f;
  }

  void set_scaleZ (int n, float f) {

    this.DEF[n][8] = f;
  }

  void set_rotX (int n, float f) {

    this.DEF[n][9] = f;
  }


  void set_rotY (int n, float f) {

    this.DEF[n][10] = f;
  }

  void set_rotZ (int n, float f) {

    this.DEF[n][11] = f;
  }

  void set_value (int n, float f) {

    this.DEF[n][12] = f;
  }

  float get_posX (int n) {

    return this.DEF[n][0];
  }

  float get_posY (int n) {

    return this.DEF[n][1];
  }

  float get_posZ (int n) {

    return this.DEF[n][2];
  }

  float get_powX (int n) {

    return this.DEF[n][3];
  }

  float get_powY (int n) {

    return this.DEF[n][4];
  }

  float get_powZ (int n) {

    return this.DEF[n][5];
  }

  float get_scaleX (int n) {

    return this.DEF[n][6];
  }

  float get_scaleY (int n) {

    return this.DEF[n][7];
  }

  float get_scaleZ (int n) {

    return this.DEF[n][8];
  }

  float get_rotX (int n) {

    return this.DEF[n][9];
  }


  float get_rotY (int n) {

    return this.DEF[n][10];
  }

  float get_rotZ (int n) {

    return this.DEF[n][11];
  }

  float get_value (int n) {

    return this.DEF[n][12];
  }

  float get_Distance (int n, float a, float b, float c) {

    float posX = this.DEF[n][0];
    float posY = this.DEF[n][1];
    float posZ = this.DEF[n][2];
    float powX = this.DEF[n][3];
    float powY = this.DEF[n][4];
    float powZ = this.DEF[n][5];
    float scaleX = this.DEF[n][6];
    float scaleY = this.DEF[n][7];
    float scaleZ = this.DEF[n][8];
    float rotX = this.DEF[n][9];
    float rotY = this.DEF[n][10];
    float rotZ = this.DEF[n][11];
    float value = this.DEF[n][12];

    a -= posX;
    b -= posY;
    c -= posZ;

    ///////////////////////// NOT SURE START!

    float y1 = b * funcs.cos_ang(-rotX) - c * funcs.sin_ang(-rotX);
    float z1 = b * funcs.sin_ang(-rotX) + c * funcs.cos_ang(-rotX);
    float x1 = a;

    a = x1;
    b = y1;
    c = z1;

    float z2 = c * funcs.cos_ang(-rotY) - a * funcs.sin_ang(-rotY);
    float x2 = c * funcs.sin_ang(-rotY) + a * funcs.cos_ang(-rotY);
    float y2 = b;

    a = x2;
    b = y2;
    c = z2;
    ///////////////////////// NOT SURE END!

    float x = a * funcs.cos_ang(-rotZ) - b * funcs.sin_ang(-rotZ);
    float y = a * funcs.sin_ang(-rotZ) + b * funcs.cos_ang(-rotZ);
    float z = c;

    x += posX;
    y += posY;
    z += posZ;


    return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))));
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / (value * scaleX * scaleY * scaleZ * 0.001));
    //return(scaleX * scaleY * scaleZ * 0.01 * pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);


  }







  int create (float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz, float v) {

    float[][] newSolid = {
      {
        x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz, v
      }
    };
    this.DEF = (float[][]) concat(this.DEF, newSolid);

    if (allGroups.num > 0) allGroups.Solids[allGroups.num - 1][1] = this.DEF.length - 1;

    return(this.DEF.length - 1);
  }









  int num_visualFaces = 3; // internal - number of faces: XY, YZ, ZX
  int numdisplayAllDegree = 16; //8; // internal - number of each face corners

  private float[][] Vertices;
  private int[][] Faces;

  void draw () {

    this.Faces = new int [this.num_visualFaces * this.DEF.length][this.numdisplayAllDegree];
    this.Vertices = new float [this.num_visualFaces * this.numdisplayAllDegree * this.DEF.length][3];

    if (this.displayAll) {

      WIN3D.graphics.strokeWeight(2);

      for (int f = 0; f < this.DEF.length; f++) {

        float Solid_posX = this.get_posX(f);
        float Solid_posY = this.get_posY(f);
        float Solid_posZ = this.get_posZ(f);
        float Solid_powX = this.get_powX(f);
        float Solid_powY = this.get_powY(f);
        float Solid_powZ = this.get_powZ(f);
        float Solid_scaleX = this.get_scaleX(f);
        float Solid_scaleY = this.get_scaleY(f);
        float Solid_scaleZ = this.get_scaleZ(f);
        float Solid_rotX = this.get_rotX(f);
        float Solid_rotY = this.get_rotY(f);
        float Solid_rotZ = this.get_rotZ(f);
        float Solid_value = this.get_value(f);

        for (int plane_type = 0; plane_type < this.num_visualFaces; plane_type++) {

          WIN3D.graphics.noFill();
          WIN3D.graphics.stroke(0);

          if (plane_type == 0) {
            WIN3D.graphics.stroke(0, 255, 0);
          }
          if (plane_type == 1) {
            WIN3D.graphics.stroke(255, 0, 0);
          }
          if (plane_type == 2) {
            WIN3D.graphics.stroke(0, 0, 255);
          }

          WIN3D.graphics.beginShape();

          float[][] ImageVertex = this.getCorners(plane_type, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

          for (int q = 1; q <= this.numdisplayAllDegree; q++) {

            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];

            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);

            if (q != 0) {

              int vNo = (f * this.num_visualFaces + plane_type) * this.numdisplayAllDegree + q - 1;

              this.Vertices[vNo][0] = x;
              this.Vertices[vNo][1] = y;
              this.Vertices[vNo][2] = z;

              int fNo = (f * this.num_visualFaces + plane_type);

              this.Faces[fNo][q - 1] = vNo;
            }
          }

          WIN3D.graphics.endShape(CLOSE);
        }
      }

      WIN3D.graphics.noStroke();
      WIN3D.graphics.strokeWeight(0);
    }
  }


  float[][] getCorners (int plane_type, float Solid_posX, float Solid_posY, float Solid_posZ, float Solid_powX, float Solid_powY, float Solid_powZ, float Solid_scaleX, float Solid_scaleY, float Solid_scaleZ, float Solid_rotX, float Solid_rotY, float Solid_rotZ, float Solid_value) {

    float[][] ImageVertex = new float [this.numdisplayAllDegree + 1][3];

    for (int q = 0; q <= this.numdisplayAllDegree; q++) {

      float qx = 0;
      float qy = 0;
      float qz = 0;

      if (q != 0) {
        if (plane_type == 0) {
          qx = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qy = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }

        if (plane_type == 1) {
          qy = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qz = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }

        if (plane_type == 2) {
          qz = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qx = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }
      }

      if (q != 0) { // normalizing

        float d = pow(pow(abs(qx), Solid_powX) + pow(abs(qy), Solid_powY) + pow(abs(qz), Solid_powZ), 3.0 / (Solid_powX + Solid_powY + Solid_powZ));

        if (d != 0) {
          qx /= d;
          qy /= d;
          qz /= d;
        }
      }


      float a = qx * Solid_scaleX;
      float b = qy * Solid_scaleY;
      float c = qz * Solid_scaleZ;

      ///////////////////////// NOT SURE START!

      float y1 = b * funcs.cos_ang(Solid_rotX) - c * funcs.sin_ang(Solid_rotX);
      float z1 = b * funcs.sin_ang(Solid_rotX) + c * funcs.cos_ang(Solid_rotX);
      float x1 = a;

      a = x1;
      b = y1;
      c = z1;

      float z2 = c * funcs.cos_ang(Solid_rotY) - a * funcs.sin_ang(Solid_rotY);
      float x2 = c * funcs.sin_ang(Solid_rotY) + a * funcs.cos_ang(Solid_rotY);
      float y2 = b;

      a = x2;
      b = y2;
      c = z2;
      ///////////////////////// NOT SURE END!

      float x = a * funcs.cos_ang(Solid_rotZ) - b * funcs.sin_ang(Solid_rotZ);
      float y = a * funcs.sin_ang(Solid_rotZ) + b * funcs.cos_ang(Solid_rotZ);
      float z = c;


      x += Solid_posX;
      y += Solid_posY;
      z += Solid_posZ;

      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }

    return ImageVertex;
  }

  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Faces.length][4];

    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }

    for (int f = 0; f < this.Faces.length; f++) {

      int n = this.Faces[f].length;

      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];

      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);

      float[] face_norm = funcs.vec3_cross(AC, BD);

      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

      float dist2intersect = FLOAT_undefined;

      float R = -funcs.vec3_dot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {

          float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float AnglesAll = 0;

          for (int i = 0; i < n; i++) {
            int next_i = (i + 1) % n;

            float[] vect1 = {this.Vertices[this.Faces[f][i]][0] - X_intersect, this.Vertices[this.Faces[f][i]][1] - Y_intersect, this.Vertices[this.Faces[f][i]][2] - Z_intersect};
            float[] vect2 = {this.Vertices[this.Faces[f][next_i]][0] - X_intersect, this.Vertices[this.Faces[f][next_i]][1] - Y_intersect, this.Vertices[this.Faces[f][next_i]][2] - Z_intersect};

            float t = funcs.acos_ang(funcs.vec_dot(funcs.vec3_unit(vect1), funcs.vec3_unit(vect2)));

            AnglesAll += t;
          }

          if (AnglesAll > 359) { // <<<<<<<<<

            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
          }
        }
      }
    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.Faces.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = int(f / this.num_visualFaces);
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];

      }

    }

    return return_point;
  }



  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    int ni = this.DEF.length;
    XML_setInt(parent, "ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);
      String txt = "";

      txt += nf(this.get_posX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_posY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_posZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_powX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_powY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_powZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_scaleX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_scaleY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_scaleZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_value(i), 0, 4).replace(",", "."); // <<<<

      XML_setContent(child, txt);
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);
    XML_setInt(parent, "pallet_CLR", this.pallet_CLR);
    XML_setInt(parent, "pallet_DIR", this.pallet_DIR);
    XML_setFloat(parent, "pallet_MLT", this.pallet_MLT);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = XML_getInt(parent, "ni");

    this.makeEmpty(ni);

    XML[] children = parent.getChildren("item");
    for (int i = 0; i < ni; i++) {

      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");
      this.set_posX(i, float(parts[0]));
      this.set_posY(i, float(parts[1]));
      this.set_posZ(i, float(parts[2]));
      this.set_powX(i, float(parts[3]));
      this.set_powY(i, float(parts[4]));
      this.set_powZ(i, float(parts[5]));
      this.set_scaleX(i, float(parts[6]));
      this.set_scaleY(i, float(parts[7]));
      this.set_scaleZ(i, float(parts[8]));
      this.set_rotX(i, float(parts[9]));
      this.set_rotY(i, float(parts[10]));
      this.set_rotZ(i, float(parts[11]));
    }

    this.displayAll = XML_getBoolean(parent, "displayAll");
    this.pallet_CLR = XML_getInt(parent, "pallet_CLR");
    this.pallet_DIR = XML_getInt(parent, "pallet_DIR");
    this.pallet_MLT = XML_getFloat(parent, "pallet_MLT");
  }

}

solarchvision_Solids allSolids = new solarchvision_Solids();
















float[][] allVertices = new float[0][3];

// to increase performance we defined vertices array outside Points class

class solarchvision_Points {

  private final static String CLASS_STAMP = "Points";

  solarchvision_Points () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = false;

  void makeEmpty (int n) {

    allVertices = new float [n][3];

    if (Select3D != null) {
      Select3D.deselect_Groups();
      Select3D.deselect_Faces();
      Select3D.deselect_Curves();
      Select3D.deselect_Vertices();
    }

    SOLARCHVISION_model_changed();
  }

  void setX (int n, float f) {

    allVertices[n][0] = f;
  }

  void setY (int n, float f) {

    allVertices[n][1] = f;
  }

  void setZ (int n, float f) {

    allVertices[n][2] = f;
  }

  void move (int n, float dx, float dy, float dz) {

    allVertices[n][0] += dx;
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }


  int getLength () {
    return  allVertices.length;
  }

  float getX (int n) {

    return allVertices[n][0];
  }

  float getY (int n) {

    return allVertices[n][1];
  }

  float getZ (int n) {

    return allVertices[n][2];
  }

  float[] getPosition (int n) {

    float[] result = {this.getX(n), this.getY(n), this.getZ(n)};

    return result;
  }


  int create (float x, float y, float z) {

    float[][] newVertex = {
      {
        x, y, z
      }
    };

    allVertices = (float[][]) concat(allVertices, newVertex);

    return(this.getLength() - 1);
  }





  void draw () {

    if (this.displayAll) {

      WIN3D.graphics.strokeWeight(3);

      WIN3D.graphics.stroke(0);

      WIN3D.graphics.noFill();

      float d = 0.5; // <<<<<<<<<<<<<< distance

      for (int f = 0; f < allPoints.getLength(); f++) {

        float x = allPoints.getX(f);
        float y = allPoints.getY(f);
        float z = allPoints.getZ(f);

        WIN3D.graphics.line((x - d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, (x + d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);

        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -((y - d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -((y + d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);

        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z - d) * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z + d) * OBJECTS_scale * WIN3D.scale);

      }

      WIN3D.graphics.strokeWeight(0);
    }
  }

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "ni", allPoints.getLength());
    for (int i = 0; i < allPoints.getLength(); i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);
      String txt = "";
      txt += nf(allPoints.getX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(allPoints.getY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(allPoints.getZ(i), 0, 4).replace(",", "."); // <<<<
      XML_setContent(child, txt);
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = XML_getInt(parent, "ni");
    allVertices = new float [ni][3];
    XML[] children = parent.getChildren("item");
    for (int i = 0; i < ni; i++) {
      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");

      allPoints.setX(i, float(parts[0]));
      allPoints.setY(i, float(parts[1]));
      allPoints.setZ(i, float(parts[2]));
    }

    this.displayAll = XML_getBoolean(parent, "displayAll");
  }


}

solarchvision_Points allPoints = new solarchvision_Points();




class solarchvision_User3D {

  private final static String CLASS_STAMP = "User3D";

  int default_Material = 7; //0;
  int default_Tessellation = 0;
  int default_Layer = 0;
  int default_Visibility = 1; // 1: view 0: hide -1:freeze
  int default_Weight = 0;
  int default_Closed = 0;

  float create_Length = 10;
  float create_Width = 10;
  float create_Height = 10;
  float create_Volume = 0; //3000;
  float create_Orientation = 360; //0; // 360: random
  float create_powX = CubePower;
  float create_powY = CubePower;
  float create_powZ = CubePower;
  float create_powAll = 8;
  int create_powRnd = 0;
  int create_SphereDegree = 2; //4;
  int create_CylinderDegree = 24;
  int create_PolyDegree = 6;
  int create_Parametric_Type = 0;
  int create_Person_Type = 0;
  int create_Plant_Type = 0;

  int create_Model1D_Type = 0;
  int create_Model1D_DegreeMax = 8;
  int create_Model1D_Seed = -1; // -1:random, 0-99 choice
  float create_Model1D_TrunkSize = 1;
  float create_Model1D_LeafSize = 0.2;

  float create_Model1D_BranchTilt = 60.0;
  float create_Model1D_BranchTwist = 137.5; //golden angle ratio
  float create_Model1D_BranchRatio = 0.8;
  float create_Model1D_TreeBase = 2.0;





  int create_MeshOrSolid = 0; // 0:Mesh 1:Solid
  int create_Snap = 0;

  int modify_TessellateRows = 6;
  int modify_TessellateColumns = 30;
  float modify_OpenningDepth = 1; // 1 = 1m
  float modify_OpenningArea = 0.25; //0-1, 0.25: 25% of the face area (i.e. for parallel openings)
  float modify_OpenningDeviation = 0.5; //0-1, 0.5: middle of the face edge (could be applied in rotated openning)
  float modify_OffsetAmount = 1.0; // 1 = 1m
  float modify_WeldTreshold = 0.1;

  float export_Scale = 1.0; //0.001; // 0.001: 1km --> 1
  int export_FlipZYaxis = 1; //1; // 1: to fit in Unity3D

  int export_PrecisionVertex = 6;
  int export_PrecisionVtexture = 4;
  int export_PolyToPoly = 1; // 0: Exports each group3D to different individual faces, 1: Exports group3D to group3D

  boolean export_MaterialLibrary = true;
  boolean export_BackSides = true;
  int export_PalletResolution = 256;

  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setInt(parent, "default_Material", this.default_Material);
    XML_setInt(parent, "default_Tessellation", this.default_Tessellation);
    XML_setInt(parent, "default_Layer", this.default_Layer);
    XML_setInt(parent, "default_Visibility", this.default_Visibility);
    XML_setInt(parent, "default_Weight", this.default_Weight);
    XML_setInt(parent, "default_Closed", this.default_Closed);

    XML_setFloat(parent, "create_Length", this.create_Length);
    XML_setFloat(parent, "create_Width", this.create_Width);
    XML_setFloat(parent, "create_Height", this.create_Height);
    XML_setFloat(parent, "create_Volume", this.create_Volume);
    XML_setFloat(parent, "create_Orientation", this.create_Orientation);
    XML_setFloat(parent, "create_powX", this.create_powX);
    XML_setFloat(parent, "create_powY", this.create_powY);
    XML_setFloat(parent, "create_powZ", this.create_powZ);
    XML_setFloat(parent, "create_powAll", this.create_powAll);
    XML_setInt(parent, "create_powRnd", this.create_powRnd);
    XML_setInt(parent, "create_SphereDegree", this.create_SphereDegree);
    XML_setInt(parent, "create_CylinderDegree", this.create_CylinderDegree);
    XML_setInt(parent, "create_PolyDegree", this.create_PolyDegree);
    XML_setInt(parent, "create_Parametric_Type", this.create_Parametric_Type);
    XML_setInt(parent, "create_Person_Type", this.create_Person_Type);
    XML_setInt(parent, "create_Plant_Type", this.create_Plant_Type);

    XML_setInt(parent, "create_Model1D_Type", this.create_Model1D_Type);
    XML_setInt(parent, "create_Model1D_DegreeMax", this.create_Model1D_DegreeMax);
    XML_setInt(parent, "create_Model1D_Seed", this.create_Model1D_Seed);
    XML_setFloat(parent, "create_Model1D_TrunkSize", this.create_Model1D_TrunkSize);
    XML_setFloat(parent, "create_Model1D_LeafSize", this.create_Model1D_LeafSize);

    XML_setInt(parent, "create_Model1D_Type", this.create_Model1D_Type);
    XML_setInt(parent, "create_Model1D_DegreeMax", this.create_Model1D_DegreeMax);
    XML_setInt(parent, "create_Model1D_Seed", this.create_Model1D_Seed);
    XML_setFloat(parent, "create_Model1D_TrunkSize", this.create_Model1D_TrunkSize);
    XML_setFloat(parent, "create_Model1D_LeafSize", this.create_Model1D_LeafSize);

    XML_setInt(parent, "create_MeshOrSolid", this.create_MeshOrSolid);
    XML_setInt(parent, "create_Snap", this.create_Snap);

    XML_setInt(parent, "modify_TessellateRows", this.modify_TessellateRows);
    XML_setInt(parent, "modify_TessellateColumns", this.modify_TessellateColumns);
    XML_setFloat(parent, "modify_OpenningDepth", this.modify_OpenningDepth);
    XML_setFloat(parent, "modify_OpenningArea", this.modify_OpenningArea);
    XML_setFloat(parent, "modify_OpenningDeviation", this.modify_OpenningDeviation);
    XML_setFloat(parent, "modify_WeldTreshold", this.modify_WeldTreshold);
    XML_setFloat(parent, "modify_OffsetAmount", this.modify_OffsetAmount);

    XML_setFloat(parent, "export_Scale", this.export_Scale);
    XML_setInt(parent, "export_FlipZYaxis", this.export_FlipZYaxis);
    XML_setInt(parent, "export_PrecisionVertex", this.export_PrecisionVertex);
    XML_setInt(parent, "export_PrecisionVtexture", this.export_PrecisionVtexture);
    XML_setInt(parent, "export_PolyToPoly", this.export_PolyToPoly);
    XML_setBoolean(parent, "export_MaterialLibrary", this.export_MaterialLibrary);
    XML_setBoolean(parent, "export_BackSides", this.export_BackSides);
    XML_setInt(parent, "export_PalletResolution", this.export_PalletResolution);

  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.default_Material = XML_getInt(parent, "default_Material");
    this.default_Tessellation = XML_getInt(parent, "default_Tessellation");
    this.default_Layer = XML_getInt(parent, "default_Layer");
    this.default_Visibility = XML_getInt(parent, "default_Visibility");
    this.default_Weight = XML_getInt(parent, "default_Weight");
    this.default_Closed = XML_getInt(parent, "default_Closed");

    this.create_Length = XML_getFloat(parent, "create_Length");
    this.create_Width = XML_getFloat(parent, "create_Width");
    this.create_Height = XML_getFloat(parent, "create_Height");
    this.create_Volume = XML_getFloat(parent, "create_Volume");
    this.create_Orientation = XML_getFloat(parent, "create_Orientation");
    this.create_powX = XML_getFloat(parent, "create_powX");
    this.create_powY = XML_getFloat(parent, "create_powY");
    this.create_powZ = XML_getFloat(parent, "create_powZ");
    this.create_powAll = XML_getFloat(parent, "create_powAll");
    this.create_powRnd = XML_getInt(parent, "create_powRnd");
    this.create_SphereDegree = XML_getInt(parent, "create_SphereDegree");
    this.create_CylinderDegree = XML_getInt(parent, "create_CylinderDegree");
    this.create_PolyDegree = XML_getInt(parent, "create_PolyDegree");
    this.create_Parametric_Type = XML_getInt(parent, "create_Parametric_Type");
    this.create_Person_Type = XML_getInt(parent, "create_Person_Type");
    this.create_Plant_Type = XML_getInt(parent, "create_Plant_Type");

    this.create_Model1D_Type = XML_getInt(parent, "create_Model1D_Type");
    this.create_Model1D_DegreeMax = XML_getInt(parent, "create_Model1D_DegreeMax");
    this.create_Model1D_Seed = XML_getInt(parent, "create_Model1D_Seed");
    this.create_Model1D_TrunkSize = XML_getFloat(parent, "create_Model1D_TrunkSize");
    this.create_Model1D_LeafSize = XML_getFloat(parent, "create_Model1D_LeafSize");

    this.create_Model1D_Type = XML_getInt(parent, "create_Model1D_Type");
    this.create_Model1D_DegreeMax = XML_getInt(parent, "create_Model1D_DegreeMax");
    this.create_Model1D_Seed = XML_getInt(parent, "create_Model1D_Seed");
    this.create_Model1D_TrunkSize = XML_getFloat(parent, "create_Model1D_TrunkSize");
    this.create_Model1D_LeafSize = XML_getFloat(parent, "create_Model1D_LeafSize");

    this.create_MeshOrSolid = XML_getInt(parent, "create_MeshOrSolid");
    this.create_Snap = XML_getInt(parent, "create_Snap");

    this.modify_TessellateRows = XML_getInt(parent, "modify_TessellateRows");
    this.modify_TessellateColumns = XML_getInt(parent, "modify_TessellateColumns");
    this.modify_OpenningDepth = XML_getFloat(parent, "modify_OpenningDepth");
    this.modify_OpenningArea = XML_getFloat(parent, "modify_OpenningArea");
    this.modify_OpenningDeviation = XML_getFloat(parent, "modify_OpenningDeviation");
    this.modify_WeldTreshold = XML_getFloat(parent, "modify_WeldTreshold");
    this.modify_OffsetAmount = XML_getFloat(parent, "modify_OffsetAmount");

    this.export_Scale = XML_getFloat(parent, "export_Scale");
    this.export_FlipZYaxis = XML_getInt(parent, "export_FlipZYaxis");
    this.export_PrecisionVertex = XML_getInt(parent, "export_PrecisionVertex");
    this.export_PrecisionVtexture = XML_getInt(parent, "export_PrecisionVtexture");
    this.export_PolyToPoly = XML_getInt(parent, "export_PolyToPoly");
    this.export_MaterialLibrary  = XML_getBoolean(parent, "export_MaterialLibrary");
    this.export_BackSides = XML_getBoolean(parent, "export_BackSides");
    this.export_PalletResolution = XML_getInt(parent, "export_PalletResolution");

  }


}

solarchvision_User3D User3D = new solarchvision_User3D();



















class solarchvision_Modify3D {

  private final static String CLASS_STAMP = "Modify3D";



  void selectVertices_fromCurrentSelection () {

    if (current_ObjectCategory == ObjectCategory.GROUP) {

      Select3D.convert_Groups_to_Vertices();
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {

      Select3D.convert_Faces_to_Vertices();
    }

    if (current_ObjectCategory == ObjectCategory.CURVE) {

      Select3D.convert_Curves_to_Vertices();
    }

    Select3D.Vertex_ids = sort(Select3D.Vertex_ids);

  }






  void selectFacesAndGroups_fromCurrentSelection () {

    if (current_ObjectCategory == ObjectCategory.GROUP) {

      Select3D.Group_ids = sort(Select3D.Group_ids);

      Select3D.convert_Groups_to_Faces();

      Select3D.Face_ids = sort(Select3D.Face_ids);
    }

    if (current_ObjectCategory == ObjectCategory.FACE) {

      Select3D.Face_ids = sort(Select3D.Face_ids);

      Select3D.convert_Faces_to_Groups();

      Select3D.Group_ids = sort(Select3D.Group_ids);

    }
  }



  void repositionVertices_Selection () {

    if (current_ObjectCategory == ObjectCategory.VERTEX) {

      Select3D.calculate_BoundingBox();

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        allPoints.setX(vNo, Select3D.BoundingBox[1][0]); // center
        allPoints.setY(vNo, Select3D.BoundingBox[1][1]); // center
        allPoints.setZ(vNo, Select3D.BoundingBox[1][2]); // center
      }

      Select3D.calculate_BoundingBox();
    }
  }


  void weldSceneVertices_Selection (float max_distance) {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      this.selectVertices_fromCurrentSelection();

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        int found = -1;

        if (found != -1) {
          for (int i = 0; i < allFaces.nodes.length; i++) {
            for (int j = 0; j < allFaces.nodes[i].length; j++) {

              int q = allFaces.nodes[i][j];

              if (q > vNo) { // it is faster than (q != vNo)

                float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

                if (d <= max_distance) {

                  allFaces.nodes[i][j] = vNo;

                  found = q;
                }
              }
            }
          }
        }

        if (found != -1) {
          for (int i = 0; i < allCurves.nodes.length; i++) {
            for (int j = 0; j < allCurves.nodes[i].length; j++) {

              int q = allCurves.nodes[i][j];

              if (q > vNo) { // it is faster than (q != vNo)

                float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

                if (d <= max_distance) {

                  allCurves.nodes[i][j] = vNo;

                  found = q;
                }
              }
            }
          }
        }

        if (found != -1) {

          int q = found;

          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);

            allVertices = (float[][]) concat(startList, endList);
          }

          for (int i = 0; i < allFaces.nodes.length; i++) {
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {

                allFaces.nodes[i][j] -= 1;
              }
            }
          }

          for (int i = 0; i < allCurves.nodes.length; i++) {
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {

                allCurves.nodes[i][j] -= 1;
              }
            }
          }
        }
      }

      Select3D.deselect_Vertices();
    }
  }




  void weldObjectsVertices_Selection (float max_distance) {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      this.selectVertices_fromCurrentSelection();

      Select3D.convert_Vertices_to_Faces();
      Select3D.convert_Vertices_to_Curves();

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        int found = -1;

        for (int m = o - 1; m >= 0; m--) {

          int q = Select3D.Vertex_ids[m];

          float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

          if (d <= max_distance) {

            for (int i = 0; i < Select3D.Face_ids.length; i++) {
              int f = Select3D.Face_ids[i];

              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                if (allFaces.nodes[f][j] == q) {

                  allFaces.nodes[f][j] = vNo;

                  found = q;
                }
              }
            }

            for (int i = 0; i < Select3D.Curve_ids.length; i++) {
              int f = Select3D.Curve_ids[i];

              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                if (allCurves.nodes[f][j] == q) {

                  allCurves.nodes[f][j] = vNo;

                  found = q;
                }
              }
            }
          }
        }

        if (found != -1) {

          int q = found;

          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);

            allVertices = (float[][]) concat(startList, endList);
          }

          for (int i = 0; i < allFaces.nodes.length; i++) {
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {

                allFaces.nodes[i][j] -= 1;
              }
            }
          }

          for (int i = 0; i < allCurves.nodes.length; i++) {
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {

                allCurves.nodes[i][j] -= 1;
              }
            }
          }
        }
      }

      Select3D.deselect_Vertices();
    }
  }



  void offsetVertices_Selection (int _type, float _amount) {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      this.selectVertices_fromCurrentSelection();

      float[][] Vertex_offsetValues = new float [Select3D.Vertex_ids.length][3];
      int[] Vertex_offsetNum = new int [Select3D.Vertex_ids.length];

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {
        Vertex_offsetValues[o][0] = 0;
        Vertex_offsetValues[o][1] = 0;
        Vertex_offsetValues[o][2] = 0;

        Vertex_offsetNum[o] = 0;
      }

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        for (int f = 0; f < allFaces.nodes.length; f++) {
          for (int j = 0; j < allFaces.nodes[f].length; j++) {

            if (allFaces.nodes[f][j] == vNo) {

              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                base_Vertices[s][0] = allPoints.getX(allFaces.nodes[f][s]);
                base_Vertices[s][1] = allPoints.getY(allFaces.nodes[f][s]);
                base_Vertices[s][2] = allPoints.getZ(allFaces.nodes[f][s]);
              }

              for (int s = 0; s < base_Vertices.length; s++) {

                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;

                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
                PVector UV = new PVector(0, 0, 0);

                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);

                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);

                Vertex_offsetValues[o][0] += W[0] * _amount;
                Vertex_offsetValues[o][1] += W[1] * _amount;
                Vertex_offsetValues[o][2] += W[2] * _amount;

                Vertex_offsetNum[o] += 1;
              }
            }
          }
        }

        for (int f = 0; f < allCurves.nodes.length; f++) {
          for (int j = 0; j < allCurves.nodes[f].length; j++) {

            if (allCurves.nodes[f][j] == vNo) {

              float[][] base_Vertices = new float [allCurves.nodes[f].length][3];

              for (int s = 0; s < allCurves.nodes[f].length; s++) {

                base_Vertices[s][0] = allPoints.getX(allCurves.nodes[f][s]);
                base_Vertices[s][1] = allPoints.getY(allCurves.nodes[f][s]);
                base_Vertices[s][2] = allPoints.getZ(allCurves.nodes[f][s]);
              }

              for (int s = 0; s < base_Vertices.length; s++) {

                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;

                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
                PVector UV = new PVector(0, 0, 0);

                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);

                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);

                Vertex_offsetValues[o][0] += W[0] * _amount;
                Vertex_offsetValues[o][1] += W[1] * _amount;
                Vertex_offsetValues[o][2] += W[2] * _amount;

                Vertex_offsetNum[o] += 1;
              }
            }
          }
        }


        if (Vertex_offsetNum[o] != 0) {
          Vertex_offsetValues[o][0] /= float(Vertex_offsetNum[o]);
          Vertex_offsetValues[o][1] /= float(Vertex_offsetNum[o]);
          Vertex_offsetValues[o][2] /= float(Vertex_offsetNum[o]);
        }
      }


      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        allPoints.move(vNo, Vertex_offsetValues[o][0],
                            Vertex_offsetValues[o][1],
                            Vertex_offsetValues[o][2]);
      }

      SOLARCHVISION_selection_changed();
    }
  }







  void separateVertices_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      this.selectVertices_fromCurrentSelection();

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {

            if (allFaces.nodes[i][j] == vNo) {

              allFaces.nodes[i][j] = allPoints.create(allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
            }
          }
        }

        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {

            if (allCurves.nodes[i][j] == vNo) {

              allCurves.nodes[i][j] = allPoints.create(allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
            }
          }
        }
      }


      Select3D.deselect_Vertices();
    }
  }




  int[] remove_item_from_primary_list (int q, int[] primary_list) {
    // to avoid processing the faces twice they should be deleted from the list.
    for (int i = q + 1; i < primary_list.length; i++) {
      primary_list[i] -= 1;
    }
    int[] startList = (int[]) subset(primary_list, 0, q);
    int[] endList = (int[]) subset(primary_list, q + 1);
    primary_list = (int[]) concat(startList, endList);

    return primary_list;
  }





  void insertCornerOpennings_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);

              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }

              float[][] new_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {

                  new_Vertices[i][j] = pow(User3D.modify_OpenningArea, 0.5) * base_Vertices[i][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }

              int[] new_Vertex_ids = new int [allFaces.nodes[f].length];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                new_Vertex_ids[s] = allPoints.create(new_Vertices[s][0], new_Vertices[s][1], new_Vertices[s][2]);
              }

              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                int[][] newFace_nodes = {
                  {
                    new_Vertex_ids[s], allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_Vertex_ids[s_next]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }


              { // modifying the base face to shape the openning
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_Vertex_ids[s];
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }

      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }


  void insertParallelOpennings_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, 2 * allFaces.nodes[f].length); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }


              float[][] new_A_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_B_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
                int s_next = (s + 1) % allFaces.nodes[f].length;

                for (int j = 0; j < 3; j++) {

                  new_A_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * 0.5 * (base_Vertices[s_prev][j] + base_Vertices[s][j]);
                  new_B_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * 0.5 * (base_Vertices[s_next][j] + base_Vertices[s][j]);

                  new_CenterVertices[s][j] = pow(User3D.modify_OpenningArea, 0.5) * base_Vertices[s][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }

              int[] new_A_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge (1/3)
              int[] new_B_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the other edge (2/3)
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                new_A_EdgeVertex_ids[s] = allPoints.create(new_A_EdgeVertices[s][0], new_A_EdgeVertices[s][1], new_A_EdgeVertices[s][2]);
                new_B_EdgeVertex_ids[s] = allPoints.create(new_B_EdgeVertices[s][0], new_B_EdgeVertices[s][1], new_B_EdgeVertices[s][2]);
                new_CenterVertex_ids[s] = allPoints.create(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              }



              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                {
                  int[][] newFace_nodes = {
                    {
                      allFaces.nodes[f][s], new_B_EdgeVertex_ids[s], new_CenterVertex_ids[s], new_A_EdgeVertex_ids[s]
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  };

                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
                }

                {
                  int[][] newFace_nodes = {
                    {
                      new_B_EdgeVertex_ids[s], new_A_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  };

                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
                }
              }


              { // modifying the base face to shape the openning
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void insertRotatedOpennings_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }

              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;

                for (int j = 0; j < 3; j++) {

                  new_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * base_Vertices[s_prev][j];

                  new_CenterVertices[s][j] = pow(User3D.modify_OpenningArea, 0.5) * new_EdgeVertices[s][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }

              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                new_EdgeVertex_ids[s] = allPoints.create(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                new_CenterVertex_ids[s] = allPoints.create(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              }



              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }


              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }


  void insertEdgeOpennings_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }

              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;

                for (int j = 0; j < 3; j++) {

                  new_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * base_Vertices[s_prev][j];
                }
              }

              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                new_EdgeVertex_ids[s] = allPoints.create(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              }



              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }


              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_EdgeVertex_ids[s];
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void tessellateRowsColumns_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            if (allFaces.nodes[f].length == 4) {

              allGroups.inserted_nFaces(OBJ_ID, f, User3D.modify_TessellateColumns * User3D.modify_TessellateRows - 1); // because adding the faces also changes the end pointer of the same object

              int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces_nodes = new int [0][0];
              int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


              int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_options = new int [0][0];
              int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

              {
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

                for (int i = 0; i < allFaces.nodes[f].length; i++) {

                  base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                  base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                  base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                }



                float[][] new_EdgeVertices = new float [(User3D.modify_TessellateColumns + 1) * (User3D.modify_TessellateRows + 1)][3];

                for (int i = 0; i <= User3D.modify_TessellateColumns; i++) {

                  for (int j = 0; j <= User3D.modify_TessellateRows; j++) {

                    int s = i * (User3D.modify_TessellateRows + 1) + j;

                    for (int k = 0; k < 3; k++) {

                      float u = i / float(User3D.modify_TessellateColumns);
                      float v = j / float(User3D.modify_TessellateRows);

                      new_EdgeVertices[s][k] = funcs.bilinear(base_Vertices[0][k], base_Vertices[1][k], base_Vertices[2][k], base_Vertices[3][k], u, v);
                    }
                  }
                }

                int[] new_EdgeVertex_ids = new int [(User3D.modify_TessellateColumns + 1) * (User3D.modify_TessellateRows + 1)]; // on the edge

                for (int i = 0; i <= User3D.modify_TessellateColumns; i++) {

                  for (int j = 0; j <= User3D.modify_TessellateRows; j++) {

                    int s = i * (User3D.modify_TessellateRows + 1) + j;

                    if ((i == 0) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][0];
                    } else if ((i == User3D.modify_TessellateColumns) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][1];
                    } else if ((i == User3D.modify_TessellateColumns) && (j == User3D.modify_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][2];
                    } else if ((i == 0) && (j == User3D.modify_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][3];
                    } else {
                      new_EdgeVertex_ids[s] = allPoints.create(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                    }
                  }
                }


                current_Material = allFaces.getMaterial(f);
                current_Tessellation = allFaces.getTessellation(f);
                current_Layer = allFaces.getLayer(f);
                current_Visibility = allFaces.getVisibility(f);

                for (int i = 0; i < User3D.modify_TessellateColumns; i++) {

                  for (int j = 0; j < User3D.modify_TessellateRows; j++) {

                    int s = i * User3D.modify_TessellateRows + j;  // number of face

                    // number of vertices
                    int s00 = i * (User3D.modify_TessellateRows + 1) + j;
                    int s01 = s00 + 1;
                    int s10 = s00 + (User3D.modify_TessellateRows + 1);
                    int s11 = s00 + (User3D.modify_TessellateRows + 1) + 1;

                    int[][] newFace_nodes = {
                      {
                        new_EdgeVertex_ids[s00], new_EdgeVertex_ids[s10], new_EdgeVertex_ids[s11], new_EdgeVertex_ids[s01]
                      }
                    };
                    int[][] newFace_options = {
                      {
                        current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                      }
                    };

                    midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                    midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);

                    if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                      int[] newFace_nodes_number = {
                        f + s
                      };
                      Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, newFace_nodes_number);
                    }
                  }
                }
              }

              startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
              startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

              allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
              allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

              primary_list = this.remove_item_from_primary_list(q, primary_list);
            }
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void tessellateRectangular_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length - 1); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = new int [0][0];
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = new int [0][0];
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }

              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;

                for (int j = 0; j < 3; j++) {
                  new_EdgeVertices[s][j] = 0.5 * base_Vertices[s][j] + 0.5 * base_Vertices[s_prev][j];
                }
              }

              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                new_EdgeVertex_ids[s] = allPoints.create(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              }

              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = allPoints.create(G_face[0], G_face[1], G_face[2]);


              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);

                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_nodes_number = {
                    f + s
                  };
                  Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, newFace_nodes_number);
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void tessellateTriangular_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length - 1); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = new int [0][0];
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = new int [0][0];
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }

              float[] G_face = {
                0, 0, 0
              };

              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }


              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = allPoints.create(G_face[0], G_face[1], G_face[2]);


              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < allFaces.nodes[f].length; s++) {

                int s_next = (s + 1) % allFaces.nodes[f].length;

                int[][] newFace_nodes = {
                  {
                    allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);

                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_nodes_number = {
                    f + s
                  };
                  Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, newFace_nodes_number);
                }
              }
            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }


  void forceTriangulateFaces_Selection () {

    // this function is the copy of above function (this.tessellateTriangular_Selection)
    // but only processed the faces with degrees above 3.

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          if (allFaces.nodes[f].length > 3) { // <<<<<<<<<<< the condition to perform the process

            int startFace = allGroups.getStart_Face(OBJ_ID);
            int endFace = allGroups.getStop_Face(OBJ_ID);

            if ((startFace <= f) && (f <= endFace)) {

              allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length - 1); // because adding the faces also changes the end pointer of the same object

              int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces_nodes = new int [0][0];
              int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


              int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_options = new int [0][0];
              int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

              {
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

                for (int i = 0; i < allFaces.nodes[f].length; i++) {

                  base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                  base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                  base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                }

                float[] G_face = {
                  0, 0, 0
                };

                for (int i = 0; i < allFaces.nodes[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                  }
                }


                int new_CenterVertex_number = 0; // at the center
                new_CenterVertex_number = allPoints.create(G_face[0], G_face[1], G_face[2]);


                current_Material = allFaces.getMaterial(f);
                current_Tessellation = allFaces.getTessellation(f);
                current_Layer = allFaces.getLayer(f);
                current_Visibility = allFaces.getVisibility(f);

                for (int s = 0; s < allFaces.nodes[f].length; s++) {

                  int s_next = (s + 1) % allFaces.nodes[f].length;

                  int[][] newFace_nodes = {
                    {
                      allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  };

                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);

                  if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                    int[] newFace_nodes_number = {
                      f + s
                    };
                    Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, newFace_nodes_number);
                  }
                }
              }

              startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
              startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

              allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
              allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);
            }

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void optimizeFace_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

            for (int s = 0; s < allFaces.nodes[f].length; s++) {
              int vNo = allFaces.nodes[f][s];

              base_Vertices[s][0] = allPoints.getX(vNo);
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);
            }

            float[][] new_Vertices = funcs.optimizeVertices(base_Vertices);

            int[] newList = new int[0];
            // finding ids of new vertices in old vertices
            for (int k = 0; k < new_Vertices.length; k++) {
              for (int s = 0; s < base_Vertices.length; s++) {
                if (funcs.arePointsClose(new_Vertices[k], base_Vertices[s])) {
                  int[] newItem = {allFaces.nodes[f][s]};
                  newList = (int []) concat(newList, newItem);
                  break;
                }
              }
            }
            allFaces.nodes[f] = newList;
          }

        }
      }


      SOLARCHVISION_selection_changed();
    }
  }



  void triangulateFace_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            allGroups.inserted_nFaces(OBJ_ID, f, allFaces.nodes[f].length); // because adding the faces also changes the end pointer of the same object

            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes;
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);


            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options;
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);

            {
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];

              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);

              }

              midList_Faces_nodes = funcs.reduceDegreePolygon(base_Vertices);
              midList_Faces_options = new int[0][0];

              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);

              for (int s = 0; s < midList_Faces_nodes.length; s++) {

                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                };

                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }

            }

            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);

            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);

            primary_list = this.remove_item_from_primary_list(q, primary_list);
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void extrudeFaceEdges_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      Select3D.deselect_Faces();

      int[] primary_list = Select3D.Face_ids;

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

        for (int q = primary_list.length - 1; q >= 0; q--) {

          int f = primary_list[q];

          int startFace = allGroups.getStart_Face(OBJ_ID);
          int endFace = allGroups.getStop_Face(OBJ_ID);

          if ((startFace <= f) && (f <= endFace)) {

            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            float[][] top_Vertices = new float [allFaces.nodes[f].length][3];

            for (int s = 0; s < allFaces.nodes[f].length; s++) {
              int vNo = allFaces.nodes[f][s];

              base_Vertices[s][0] = allPoints.getX(vNo);
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);

              top_Vertices[s][0] = allPoints.getX(vNo);
              top_Vertices[s][1] = allPoints.getY(vNo);
              top_Vertices[s][2] = allPoints.getZ(vNo);
            }

            for (int s = 0; s < allFaces.nodes[f].length; s++) {

              int s_next = (s + 1) % allFaces.nodes[f].length;
              int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;

              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = funcs.vec3_unit(W);

              top_Vertices[s][0] += W[0] * User3D.modify_OpenningDepth;
              top_Vertices[s][1] += W[1] * User3D.modify_OpenningDepth;
              top_Vertices[s][2] += W[2] * User3D.modify_OpenningDepth;
            }

            int[] base_Vertex_ids = new int [allFaces.nodes[f].length];
            int[] top_Vertex_ids = new int [allFaces.nodes[f].length];

            for (int s = 0; s < allFaces.nodes[f].length; s++) {

              base_Vertex_ids[s] = allPoints.create(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]);
              top_Vertex_ids[s] = allPoints.create(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }

            for (int s = 0; s < allFaces.nodes[f].length; s++) {

              int s_next = (s + 1) % allFaces.nodes[f].length;

              if (User3D.modify_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              } else {
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              }

              int[][] newFace_options = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              };
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);
            }

            { // adding the cap
              int[][] newFace_nodes = {
                top_Vertex_ids
              };
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);

              int[][] newFace_options = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              };
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);

              int[] lastFace = {
                allFaces.nodes.length - 1
              };

              Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, lastFace);
            }

            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }


      SOLARCHVISION_selection_changed();
    }
  }


  void extrudeCurveEdges_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.CURVE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      Select3D.deselect_Faces();

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

        for (int q = Select3D.Curve_ids.length - 1; q >= 0; q--) {

          int f = Select3D.Curve_ids[q];

          int startCurve = allGroups.getStart_Curve(OBJ_ID);
          int endCurve = allGroups.getStop_Curve(OBJ_ID);

          if ((startCurve <= f) && (f <= endCurve)) {

            float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
            float[][] top_Vertices = new float [allCurves.nodes[f].length][3];

            for (int s = 0; s < allCurves.nodes[f].length; s++) {
              int vNo = allCurves.nodes[f][s];

              base_Vertices[s][0] = allPoints.getX(vNo);
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);

              top_Vertices[s][0] = allPoints.getX(vNo);
              top_Vertices[s][1] = allPoints.getY(vNo);
              top_Vertices[s][2] = allPoints.getZ(vNo);
            }

            for (int s = 0; s < allCurves.nodes[f].length; s++) {

              int s_next = (s + 1) % allCurves.nodes[f].length;
              int s_prev = (s + allCurves.nodes[f].length - 1) % allCurves.nodes[f].length;

              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = funcs.vec3_unit(W);

              top_Vertices[s][0] += W[0] * User3D.modify_OpenningDepth;
              top_Vertices[s][1] += W[1] * User3D.modify_OpenningDepth;
              top_Vertices[s][2] += W[2] * User3D.modify_OpenningDepth;
            }

            int[] base_Vertex_ids = new int [allCurves.nodes[f].length];
            int[] top_Vertex_ids = new int [allCurves.nodes[f].length];

            for (int s = 0; s < allCurves.nodes[f].length; s++) {

              base_Vertex_ids[s] = allPoints.create(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]);
              top_Vertex_ids[s] = allPoints.create(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }

            for (int s = 0; s < allCurves.nodes[f].length; s++) {

              int s_next = (s + 1) % allCurves.nodes[f].length;

              if (User3D.modify_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              } else {
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              }

              int[][] newFace_options = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              };
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);
            }

            { // adding the cap
              int[][] newFace_nodes = {
                top_Vertex_ids
              };
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);

              int[][] newFace_options = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              };
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);

              int[] lastFace = {
                allFaces.nodes.length - 1
              };

              Select3D.Face_ids = (int[]) concat(Select3D.Face_ids, lastFace);
            }

            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }



  void autoNormalFaces_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE)) {

      this.selectFacesAndGroups_fromCurrentSelection();

      for (int o = 0; o < Select3D.Face_ids.length; o++) {

        int f = Select3D.Face_ids[o];

        int n = allFaces.nodes[f].length;

        if (n > 2) {
          int[] tmpFace = new int[n];
          float[] G = {
            0, 0, 0
          };
          for (int j = 0; j < n; j++) {
            tmpFace[j] = allFaces.nodes[f][j];
            G[0] += allPoints.getX(tmpFace[j]) / float(n);
            G[1] += allPoints.getY(tmpFace[j]) / float(n);
            G[2] += allPoints.getZ(tmpFace[j]) / float(n);
          }

          PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);
          PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);

          PVector GAxGB = AG.cross(BG);

          float[] ray_start = {G[0], G[1], G[2]};
          float[] ray_direction = {GAxGB.x, GAxGB.y, GAxGB.z};

          float[] RxP = Select3D.intersect(ray_start, ray_direction);

          if (RxP[0] >= 0) {

            for (int j = 0; j < n; j++) {
              allFaces.nodes[f][j] = tmpFace[n - j - 1];
            }
          }
        }
      }


      SOLARCHVISION_switch_category(ObjectCategory.FACE);
    }
  }







  void flatten_LandPoints () {

    for (int q = 0; q < Select3D.LandPoint_ids.length; q++) {

      int f = Select3D.LandPoint_ids[q];

      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;

      Land3D.Mesh[i][j][2] = 0;

    }

    SOLARCHVISION_selection_changed();
  }



  void changeVisibilityFaces_Selection (int new_vsb) {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      if (current_ObjectCategory == ObjectCategory.GROUP) {

        Select3D.convert_Groups_to_Faces();
      }

      if (current_ObjectCategory == ObjectCategory.VERTEX) {

        Select3D.convert_Vertices_to_Faces();
      }

      for (int o = Select3D.Face_ids.length - 1; o >= 0; o--) {

        int f = Select3D.Face_ids[o];

        allFaces.setVisibility(f, new_vsb);

      }
    }

    SOLARCHVISION_model_changed();
  }


  void changeVisibilityFaces_Scene (int new_vsb) {

    for (int f = allFaces.nodes.length - 1; f >= 0; f--) {
      allFaces.setVisibility(f, new_vsb);
    }

    SOLARCHVISION_model_changed();
  }


  void reverseVisibilityFaces_Scene () {

    for (int f = allFaces.nodes.length - 1; f >= 0; f--) {

      int vsb = allFaces.getVisibility(f);
      int new_vsb = vsb;

      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;

      allFaces.setVisibility(f, new_vsb);
    }

    SOLARCHVISION_model_changed();
  }


  void changeVisibilityCurves_Selection (int new_vsb) {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      if (current_ObjectCategory == ObjectCategory.GROUP) {

        Select3D.convert_Groups_to_Curves();
      }

      if (current_ObjectCategory == ObjectCategory.VERTEX) {

        Select3D.convert_Vertices_to_Curves();
      }

      for (int o = Select3D.Curve_ids.length - 1; o >= 0; o--) {

        int f = Select3D.Curve_ids[o];

        allCurves.setVisibility(f, new_vsb);

      }
    }

    SOLARCHVISION_model_changed();
  }


  void changeVisibilityCurves_Scene (int new_vsb) {

    for (int f = allCurves.nodes.length - 1; f >= 0; f--) {
      allCurves.setVisibility(f, new_vsb);
    }

    SOLARCHVISION_model_changed();
  }


  void reverseVisibilityCurves_Scene () {

    for (int f = allCurves.nodes.length - 1; f >= 0; f--) {

      int vsb = allCurves.getVisibility(f);
      int new_vsb = vsb;

      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;

      allCurves.setVisibility(f, new_vsb);
    }

    SOLARCHVISION_model_changed();
  }

  void isolate_Selection () {

    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
        (current_ObjectCategory == ObjectCategory.FACE) ||
        (current_ObjectCategory == ObjectCategory.CURVE) ||
        (current_ObjectCategory == ObjectCategory.VERTEX)) {

      this.changeVisibilityFaces_Scene(0);
      this.changeVisibilityFaces_Selection(1);

      this.changeVisibilityCurves_Scene(0);
      this.changeVisibilityCurves_Selection(1);
    }
  }

}

solarchvision_Modify3D Modify3D = new solarchvision_Modify3D();





class solarchvision_Create3D {

  private final static String CLASS_STAMP = "Create3D";

  void add_Octahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {

    if ((rx > 0) && (ry > 0) && (rz > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float teta = rot * PI / 180.0;

      float[] X_ = new float [6];
      float[] Y_ = new float [6];
      float[] Z_ = new float [6];

      float q = pow(2, 0.5);

      X_[0] = 0;
      Y_[0] = 0;
      Z_[0] = q;
      X_[1] = q;
      Y_[1] = 0;
      Z_[1] = 0;
      X_[2] = 0;
      Y_[2] = q;
      Z_[2] = 0;
      X_[3] = -q;
      Y_[3] = 0;
      Z_[3] = 0;
      X_[4] = 0;
      Y_[4] = -q;
      Z_[4] = 0;
      X_[5] = 0;
      Y_[5] = 0;
      Z_[5] = -q;

      for (int i = 0; i < 6; i++) {
        X_[i] *= rx;
        Y_[i] *= ry;
        Z_[i] *= rz;

        float X_r = X_[i] * cos(teta) - Y_[i] * sin(teta);
        float Y_r = X_[i] * sin(teta) + Y_[i] * cos(teta);
        float Z_r = Z_[i];

        X_[i] = X_r + x;
        Y_[i] = Y_r + y;
        Z_[i] = Z_r + z;
      }

      int[] v = new int [6];

      for (int i = 0; i < 6; i++) {
        v[i] = allPoints.create(X_[i], Y_[i], Z_[i]);
      }

      if (m == -1) current_Material = 0;
      else current_Material = m;

      {
        int[] newFace_nodes = {
          v[1], v[2], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[2], v[3], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[3], v[4], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[4], v[1], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[1], v[5], v[2]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[2], v[5], v[3]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {
        int[] newFace_nodes = {
          v[3], v[5], v[4]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      {
        int[] newFace_nodes = {
          v[4], v[5], v[1]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


    SOLARCHVISION_model_added();
    }
  }


  void add_House3_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {

    if ((rx > 0) && (ry > 0) && (rz > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float teta = (90 + rot) * PI / 180.0;

      float x1 = rx;
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;

      float y1 = ry;
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;

      float z0 = -rz;
      float z1 = rz;
      float z2 = h2;

      float[] vx = {
        1, -1, -1, 1, 1, -1, -1, 1, 1, -1
      };
      float[] vy = {
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };

      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;

        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];

        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }

      int b1 = allPoints.create(vx[0], vy[0], vz[0]);
      int b2 = allPoints.create(vx[1], vy[1], vz[1]);
      int b3 = allPoints.create(vx[2], vy[2], vz[2]);
      int b4 = allPoints.create(vx[3], vy[3], vz[3]);

      int t1 = allPoints.create(vx[4], vy[4], vz[4]);
      int t2 = allPoints.create(vx[5], vy[5], vz[5]);
      int t3 = allPoints.create(vx[6], vy[6], vz[6]);
      int t4 = allPoints.create(vx[7], vy[7], vz[7]);

      int m1 = allPoints.create(vx[8], vy[8], vz[8]);
      int m2 = allPoints.create(vx[9], vy[9], vz[9]);


      if (m == -1) current_Material = 0;
      else current_Material = m;


      {//West
        int[] newFace_nodes = {
          t3, m2, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-South
        int[] newFace_nodes = {
          m1, m2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, m1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-North
        int[] newFace_nodes = {
          m2, m1, t1, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


      SOLARCHVISION_model_added();
    }
  }


  void add_House2_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {

    if ((rx > 0) && (ry > 0) && (rz > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float teta = rot * PI / 180.0;

      float x1 = rx;
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;

      float y1 = ry;
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;

      float z0 = -rz;
      float z1 = rz;
      float z2 = h2;

      float[] vx = {
        1, -1, -1, 1, 1, -1, -1, 1, 1, -1
      };
      float[] vy = {
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };

      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;

        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];

        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }

      int b1 = allPoints.create(vx[0], vy[0], vz[0]);
      int b2 = allPoints.create(vx[1], vy[1], vz[1]);
      int b3 = allPoints.create(vx[2], vy[2], vz[2]);
      int b4 = allPoints.create(vx[3], vy[3], vz[3]);

      int t1 = allPoints.create(vx[4], vy[4], vz[4]);
      int t2 = allPoints.create(vx[5], vy[5], vz[5]);
      int t3 = allPoints.create(vx[6], vy[6], vz[6]);
      int t4 = allPoints.create(vx[7], vy[7], vz[7]);

      int m1 = allPoints.create(vx[8], vy[8], vz[8]);
      int m2 = allPoints.create(vx[9], vy[9], vz[9]);


      if (m == -1) current_Material = 0;
      else current_Material = m;


      {//West
        int[] newFace_nodes = {
          t3, m2, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-South
        int[] newFace_nodes = {
          m1, m2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, m1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-North
        int[] newFace_nodes = {
          m2, m1, t1, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


      SOLARCHVISION_model_added();
    }
  }


  void add_House1_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {

    if ((rx > 0) && (ry > 0) && (rz > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      if (ry > rx) {

        float tmp = rx;
        rx = ry;
        ry = tmp;

        rot += 90;
      }

      float teta = rot * PI / 180.0;

      float x1 = rx;
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;

      float y1 = ry;
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;

      float z0 = -rz;
      float z1 = rz;
      float z2 = h2;

      float[] vx = {
        1, -1, -1, 1, 1, -1, -1, 1, 1-ry/rx, -1+ry/rx
      };
      float[] vy = {
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };

      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;

        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];

        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }

      int b1 = allPoints.create(vx[0], vy[0], vz[0]);
      int b2 = allPoints.create(vx[1], vy[1], vz[1]);
      int b3 = allPoints.create(vx[2], vy[2], vz[2]);
      int b4 = allPoints.create(vx[3], vy[3], vz[3]);

      int t1 = allPoints.create(vx[4], vy[4], vz[4]);
      int t2 = allPoints.create(vx[5], vy[5], vz[5]);
      int t3 = allPoints.create(vx[6], vy[6], vz[6]);
      int t4 = allPoints.create(vx[7], vy[7], vz[7]);

      int m1 = allPoints.create(vx[8], vy[8], vz[8]);
      int m2 = allPoints.create(vx[9], vy[9], vz[9]);


      if (m == -1) current_Material = 0;
      else current_Material = m;


      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-West
        int[] newFace_nodes = {
          t3, m2, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-South
        int[] newFace_nodes = {
          m1, m2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-East
        int[] newFace_nodes = {
          t1, m1, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof-North
        int[] newFace_nodes = {
          m2, m1, t1, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


      SOLARCHVISION_model_added();
    }
  }



  void add_Box_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {

    if ((rx > 0) && (ry > 0) && (rz > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float teta = rot * PI / 180.0;

      int t1 = allPoints.create(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z + rz);
      int t2 = allPoints.create(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z + rz);
      int t3 = allPoints.create(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z + rz);
      int t4 = allPoints.create(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z + rz);

      int b1 = allPoints.create(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z - rz);
      int b2 = allPoints.create(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z - rz);
      int b3 = allPoints.create(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z - rz);
      int b4 = allPoints.create(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z - rz);

      if (m == -1) current_Material = 0;
      else current_Material = m;


      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof
        int[] newFace_nodes = {
          t1, t2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


      SOLARCHVISION_model_added();
    }
  }


  void add_Box_Corners (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2) {

    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int t1 = allPoints.create(x2, y2, z2);
      int t2 = allPoints.create(x1, y2, z2);
      int t3 = allPoints.create(x1, y1, z2);
      int t4 = allPoints.create(x2, y1, z2);

      int b1 = allPoints.create(x2, y2, z1);
      int b2 = allPoints.create(x1, y2, z1);
      int b3 = allPoints.create(x1, y1, z1);
      int b4 = allPoints.create(x2, y1, z1);

      if (m == -1) current_Material = 0;
      else current_Material = m;


      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Roof
        int[] newFace_nodes = {
          t1, t2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }


      SOLARCHVISION_model_added();
    }
  }


  void add_H_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float d, float w, float Alpha, float Beta) {

    if ((d > 0) && (w > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float rx = 0.5 * d * funcs.cos_ang(Beta);
      float ry = 0.5 * d * funcs.sin_ang(Beta);

      float wx = w * funcs.cos_ang(Beta - 90) * funcs.cos_ang(Alpha);
      float wy = w * funcs.sin_ang(Beta - 90) * funcs.cos_ang(Alpha);
      float wz = w * funcs.sin_ang(Alpha);

      float x1 = x0 + rx;
      float y1 = y0 + ry;
      float z1 = z0;

      float x2 = x0 - rx;
      float y2 = y0 - ry;
      float z2 = z0;

      float x3 = wx + x0 - rx;
      float y3 = wy + y0 - ry;
      float z3 = wz + z0;

      float x4 = wx + x0 + rx;
      float y4 = wy + y0 + ry;
      float z4 = wz + z0;

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);

      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }


  void add_V_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float h, float d, float t, float t0) {

    if ((d > 0) && (h > 0)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float dx = d * funcs.cos_ang(t + t0 - 90);
      float dy = d * funcs.sin_ang(t + t0 - 90);

      float x1 = x0;
      float y1 = y0;
      float z1 = z0 - 0.5 * h;

      float x2 = x0;
      float y2 = y0;
      float z2 = z0 + 0.5 * h;

      float x3 = x0 + dx;
      float y3 = y0 + dy;
      float z3 = z0 + 0.5 * h;

      float x4 = x0 + dx;
      float y4 = y0 + dy;
      float z4 = z0 - 0.5 * h;

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);

      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }



  void add_Mesh2 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x3, float y3, float z3) {

    if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      float x2 = x3;
      float y2 = y3;
      float z2 = z3;

      float x4 = x1;
      float y4 = y1;
      float z4 = z1;

      if (z1 == z3) {
        y2 = y1;
        y4 = y3;
      } else if (y1 == y3) {
        x2 = x1;
        x4 = x3;
      } else if (x1 == x3) {
        z2 = z1;
        z4 = z3;
      }

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);


      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }


  void add_Mesh3 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {

    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {
      if ((x2 != x3) || (y2 != y3) || (z2 != z3)) {
        if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {

          current_Material = m;
          current_Tessellation = tes;
          current_Layer = lyr;
          current_Visibility = vsb;
          current_Weight = wgt;
          current_Closed = clz;

          int v1 = allPoints.create(x1, y1, z1);
          int v2 = allPoints.create(x2, y2, z2);
          int v3 = allPoints.create(x3, y3, z3);

          {
            int[] newFace_nodes = {
              v1, v2, v3
            };
            allFaces.create(newFace_nodes);
          }


          SOLARCHVISION_model_added();
        }
      }
    }
  }



  void add_Mesh4 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {

    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {

      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4);
    }
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {

      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4);
    }
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {

      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else if ((x1 == x4) && (y1 == y4) && (z1 == z4)) {

      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);

      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }



  void add_Mesh5 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5) {

    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {

      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {

      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5);
    }
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {

      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {

      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }
    else if ((x1 == x5) && (y1 == y5) && (z1 == z5)) {

      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }
    else {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);
      int v5 = allPoints.create(x5, y5, z5);

      {
        int[] newFace_nodes = {
          v1, v2, v3, v4, v5
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }


  void add_Mesh6 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5, float x6, float y6, float z6) {

    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5, x6, y6, z6);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x6, y6, z6);
    }
    else if ((x5 == x6) && (y5 == y6) && (z5 == z6)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }
    else if ((x1 == x6) && (y1 == y6) && (z1 == z6)) {

      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }
    else {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int v1 = allPoints.create(x1, y1, z1);
      int v2 = allPoints.create(x2, y2, z2);
      int v3 = allPoints.create(x3, y3, z3);
      int v4 = allPoints.create(x4, y4, z4);
      int v5 = allPoints.create(x5, y5, z5);
      int v6 = allPoints.create(x6, y6, z6);

      {
        int[] newFace_nodes = {
          v1, v2, v3, v4, v5, v6
        };
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }




  void add_PolygonHyper (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {

    if ((r > 0) && (h > 0) && (n > 2)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int[] newFace_nodes = {
        allPoints.create(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz - 0.5 * h)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);
        int[] f = {
          allPoints.create(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz + (2 * (i % 2) - 1) * 0.5 * h)
        };
        newFace_nodes = concat(newFace_nodes, f);
      }

      allFaces.create(newFace_nodes);

      SOLARCHVISION_model_added();
    }
  }



  void add_PolygonMesh (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot) {

    if ((r > 0) && (n > 2)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int[] newFace_nodes = {
        allPoints.create(cx + r * funcs.cos_ang(0), cy + r * funcs.sin_ang(0), cz)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n) + rot;
        int[] f = {
          allPoints.create(cx + r * funcs.cos_ang(t), cy + r * funcs.sin_ang(t), cz)
        };
        newFace_nodes = concat(newFace_nodes, f);
      }

      allFaces.create(newFace_nodes);

      SOLARCHVISION_model_added();
    }
  }



  void add_PolygonExtrude (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {

    if ((r > 0) && (h > 0) && (n > 2)) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int[] vT = new int [n];
      int[] vB = new int [n];

      vT[0] = allPoints.create(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz + 0.5 * h);
      vB[0] = allPoints.create(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz - 0.5 * h);

      int[] newFace_nodesT = {
        vT[0]
      };
      int[] newFace_nodesB = {
        vB[0]
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);

        vT[i] = allPoints.create(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz + 0.5 * h);
        vB[i] = allPoints.create(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz - 0.5 * h);
        int[] fT = {
          vT[i]
        };
        int[] fB = {
          vB[i]
        };

        newFace_nodesT = concat(newFace_nodesT, fT);
        newFace_nodesB = concat(newFace_nodesB, fB);
      }

      if (m == -1) current_Material = 0;
      else current_Material = m;

      allFaces.create(newFace_nodesT);

      if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
      allFaces.create(newFace_nodesB);

      for (int i = 0; i < n; i++) {
        int next_i = (i + 1) % n;

        int[] newFace_nodes = {
          vT[i], vB[i], vB[next_i], vT[next_i]
        };
        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
        allFaces.create(newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }






  void add_Icosahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float rot) {

    if (r > 0) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int[] vT = new int [6];
      int[] vB = new int [6];

      vT[0] = allPoints.create(cx, cy, cz + r);
      vB[0] = allPoints.create(cx, cy, cz - r);

      for (int i = 1; i <= 5; i++) {
        float t = i * 72;

        float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;
        float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;

        vT[i] = allPoints.create(cx + R_in * funcs.cos_ang(t + rot), cy + R_in * funcs.sin_ang(t + rot), cz + H_in);
        vB[i] = allPoints.create(cx + R_in * funcs.cos_ang(t + 36 + rot), cy + R_in * funcs.sin_ang(t + 36 + rot), cz - H_in);
      }


      if (m == -1) current_Material = 0;
      else current_Material = m;

      for (int i = 1; i <= 5; i++) {

        int next_i = (i % 5) + 1;

        {
          int[] newFace_nodesT = new int [3];
          int[] newFace_nodesB = new int [3];

          newFace_nodesT[0] = vT[i];
          newFace_nodesT[1] = vT[next_i];
          newFace_nodesT[2] = vT[0];

          newFace_nodesB[0] = vB[i];
          newFace_nodesB[1] = vB[next_i];
          newFace_nodesB[2] = vT[next_i];

          if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
          allFaces.create(newFace_nodesT);
          allFaces.create(newFace_nodesB);
        }

        {
          int[] newFace_nodesT = new int [3];
          int[] newFace_nodesB = new int [3];

          newFace_nodesT[0] = vT[next_i];
          newFace_nodesT[1] = vT[i];
          newFace_nodesT[2] = vB[i];

          newFace_nodesB[0] = vB[next_i];
          newFace_nodesB[1] = vB[i];
          newFace_nodesB[2] = vB[0];

          if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
          allFaces.create(newFace_nodesT);
          allFaces.create(newFace_nodesB);
        }
      }

      SOLARCHVISION_model_added();
    }
  }


  void create_Face_afterSphericaltessellation (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int[] f) {

    if (r > 0) {

      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;

      int A = f[0];
      int B = f[1];
      int C = f[2];
      int D = f[3];

      int M, N;  //
      int MM, NN; // MM: mirror of M based on AB; NN: mirror of N baesd on CD

      float[] G;

      {
        float[][] the_points = {
          {
            allPoints.getX(D) - cx, allPoints.getY(D) - cy, allPoints.getZ(D) - cz
          }
          , {
            allPoints.getX(A) - cx, allPoints.getY(A) - cy, allPoints.getZ(A) - cz
          }
          , {
            allPoints.getX(B) - cx, allPoints.getY(B) - cy, allPoints.getZ(B) - cz
          }
        };

        G = funcs.vec3_unit(funcs.centroid(the_points));
        M = allPoints.create(cx + r * G[0], cy + r * G[1], cz + r * G[2]);

        G[0] = (allPoints.getX(C) - cx) + (allPoints.getX(D) - cx) - (allPoints.getX(M) - cx);
        G[1] = (allPoints.getY(C) - cy) + (allPoints.getY(D) - cy) - (allPoints.getY(M) - cy);
        G[2] = (allPoints.getZ(C) - cz) + (allPoints.getZ(D) - cz) - (allPoints.getZ(M) - cz);
        G = funcs.vec3_unit(G);
        MM = allPoints.create(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }


      {
        float[][] the_points = {
          {
            allPoints.getX(B) - cx, allPoints.getY(B) - cy, allPoints.getZ(B) - cz
          }
          , {
            allPoints.getX(C) - cx, allPoints.getY(C) - cy, allPoints.getZ(C) - cz
          }
          , {
            allPoints.getX(D) - cx, allPoints.getY(D) - cy, allPoints.getZ(D) - cz
          }
        };

        G = funcs.vec3_unit(funcs.centroid(the_points));
        N = allPoints.create(cx + r * G[0], cy + r * G[1], cz + r * G[2]);


        G[0] = (allPoints.getX(A) - cx) + (allPoints.getX(B) - cx) - (allPoints.getX(N) - cx);
        G[1] = (allPoints.getY(A) - cy) + (allPoints.getY(B) - cy) - (allPoints.getY(N) - cy);
        G[2] = (allPoints.getZ(A) - cz) + (allPoints.getZ(B) - cz) - (allPoints.getZ(N) - cz);
        G = funcs.vec3_unit(G);
        NN = allPoints.create(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }





      {
        int[][] newFace_options = {
          {
            current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
          }
        };

        allFaces.options = (int[][]) concat(allFaces.options, newFace_options);


        int[][] newFace_nodes = {
          {
            M, B, N, D
          }
        };

        allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
      }

      {
        int[][] newFace_options = {
          {
            current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
          }
        };

        //allFaces.options = (int[][]) concat(allFaces.options, newFace_options);


        int[][] newFace_nodes = {
          {
            MM, B, M, A
          }
        };

        //allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
      }

      SOLARCHVISION_model_added();
    }
  }







  void add_ParametricSurface (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float rx, float ry, float rz, int n, float rot) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    if (m == -1) current_Material = 0;
    else current_Material = m;

    float teta = rot * PI / 180.0;

    float stp_u = 0.1; //0.05;
    float stp_v = 0.1; //0.05;

    float start_u = -1;
    float start_v = -1;
    float end_u = 1;
    float end_v = 1;

    if (n == 1) {
      start_u = 0;
    }
    if (n == 2) {
      start_u = 0;
    }

    for (float a = start_u; a < end_u; a += stp_u) {
      for (float b = start_v; b < end_v; b += stp_v) {

        int[] newFace_nodes = {
        };

        for (int i = 0; i < 4; i++) {

          float u = a;
          float v = b;

          if ((i == 1) || (i == 2)) u += stp_u;
          if ((i == 2) || (i == 3)) v += stp_v;

          float x = 0;
          float y = 0;
          float z = 0;

          if (n == 1) { // LOGO:
            float x0 = cos(u * PI);
            float y0 = sin(v * PI);
            float z0 = -sin(u * PI) * cos(v * PI);

            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;
              y = y0 / d;
              z = z0 / d;
            }
          } else if (n == 2) {
            x = cos(u * PI);
            y = sin(v * PI);
            z = -sin(u * PI) * cos(v * PI);
          } else if (n == 3) {
            x = sin(u * PI);
            y = sin(v * PI);
            z = cos((u + v) * PI);
          } else if (n == 4) {
            float x0 = sin(u * PI);
            float y0 = sin(v * PI);
            float z0 = cos((u + v) * PI);

            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;
              y = y0 / d;
              z = z0 / d;
            }
          } else if (n == 5) {
            x = u;
            y = v;
            z = cos(0.5 * u * PI) * cos(0.5 * v * PI);
          } else if (n == 6) {
            x = u;
            y = v;
            z = sin(u * PI) * sin(v * PI);
          } else if (n == 7) {
            x = u;
            y = v;
            z = 0.5 * cos(u * PI) + cos(v * PI);
          }


          x *= rx;
          y *= ry;
          z *= rz;

          float x_rot = cx + x * cos(teta) - y * sin(teta);
          float y_rot = cy + x * sin(teta) + y * cos(teta);
          float z_rot = cz + z;

          x = x_rot;
          y = y_rot;
          z = z_rot;

          int[] f = {
            allPoints.create(x, y, z)
          };
          newFace_nodes = concat(newFace_nodes, f);
        }

        if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));

        allFaces.create(newFace_nodes);
      }
    }

    SOLARCHVISION_model_added();
  }


  void add_CrystalSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int tessellation, int isSky, float t) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    int[] vT = new int [6];
    int[] vB = new int [6];

    vT[0] = this.addToTempObjectVertices(0, 0, 1);
    vB[0] = this.addToTempObjectVertices(0, 0, -1);

    for (int i = 1; i <= 5; i++) {
      float q = i * 72 + t;

      float R_in = pow(5.0, 0.5) * 2.0 / 5.0;
      float H_in = pow(5.0, 0.5) * 1.0 / 5.0;

      vT[i] = this.addToTempObjectVertices(R_in * funcs.cos_ang(q), R_in * funcs.sin_ang(q), H_in);
      vB[i] = this.addToTempObjectVertices(R_in * funcs.cos_ang(q + 36), R_in * funcs.sin_ang(q + 36), -H_in);
    }


    int BuildFaces = 0;

    for (int Loop_Tessellation = 1; Loop_Tessellation <= tessellation; Loop_Tessellation++) { // added so that the tree generated from the bottom to the top!

      if (Loop_Tessellation == tessellation) BuildFaces = 1;
      else BuildFaces = 0;

      for (int i = 1; i <= 5; i++) {

        int next_i = (i % 5) + 1;
        int prev_i = ((i + 5 - 2) % 5) + 1;

        {
          createLozenge(
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2],
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2],
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2],
          Loop_Tessellation, BuildFaces);
        }

        {
          createLozenge(
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2],
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2],
          Loop_Tessellation, BuildFaces);
        }

        {
          createLozenge(
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2],
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],
          Loop_Tessellation, BuildFaces);
        }

        {
          createLozenge(

          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2],
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2],
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],

          Loop_Tessellation, BuildFaces);
        }

        {
          createLozenge(
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2],
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2],
          TempObjectVertices[vB[next_i]][0], TempObjectVertices[vB[next_i]][1], TempObjectVertices[vB[next_i]][2],
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2],

          Loop_Tessellation, BuildFaces);
        }
      }
    }


    //println("Vertices:", POINTER_TempObjectVertices);
    //println("Faces:", POINTER_TempObjectFaces);

    if (isSky == 0) {
      this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, r, r, r, t);
    } else if (isSky == 1) {


      skyVertices = new float [0][3];
      skyFaces = new int [0][1];

      for (int i = 0; i < POINTER_TempObjectVertices; i++) {

        float x = TempObjectVertices[i][0];
        float y = TempObjectVertices[i][1];
        float z = TempObjectVertices[i][2];

        float[][] newVertex = {
          {
            x, y, z
          }
        };

        skyVertices = (float[][]) concat(skyVertices, newVertex);
      }

      for (int i = 0; i < POINTER_TempObjectFaces; i++) {

        int[][] newFace_nodes = {
          {
            TempObjectFaces[i][0], TempObjectFaces[i][1], TempObjectFaces[i][2], TempObjectFaces[i][3]
          }
        };

        skyFaces = (int[][]) concat(skyFaces, newFace_nodes);
      }


      POINTER_TempObjectVertices = 0;
      POINTER_TempObjectFaces = 0;
    } else {
      // Nothing. In this case we should add temp object outside this function. See SuperSphere
    }

    SOLARCHVISION_model_added();
  }



  void add_SuperSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float px, float py, float pz, float sx, float sy, float sz, int tessellation, float t) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    this.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, 1, tessellation, -1, 90); // passing with isSky:-1

    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ;
    value = 1;
    posX = 0;
    posY = 0;
    posZ = 0;
    powX = px;
    powY = py;
    powZ = pz;
    scaleX = 1;
    scaleY = 1;
    scaleZ = 1;

    for (int i = 0; i < POINTER_TempObjectVertices; i++) {

      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];

      float the_dist = (pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
        z /= the_dist;
      }

      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }

    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);

    SOLARCHVISION_model_added();
  }


  void add_SuperCylinder (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, int n, float t) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    int[] vT = new int [n];
    int[] vB = new int [n];

    vT[0] = this.addToTempObjectVertices(1, 0, 1);
    vB[0] = this.addToTempObjectVertices(1, 0, -1);

    int[] newFace_nodesT = {
      vT[0]
    };
    int[] newFace_nodesB = {
      vB[0]
    };
    for (int i = 1; i < n; i++) {
      float rot = i * 360.0 / float(n);

      vT[i] = this.addToTempObjectVertices(funcs.cos_ang(rot), funcs.sin_ang(rot), 1);
      vB[i] = this.addToTempObjectVertices(funcs.cos_ang(rot), funcs.sin_ang(rot), -1);
      int[] fT = {
        vT[i]
      };
      int[] fB = {
        vB[i]
      };

      newFace_nodesT = concat(newFace_nodesT, fT);
      newFace_nodesB = concat(newFace_nodesB, fB);
    }

    this.addToTempObjectFaces(newFace_nodesT, 0); // 0:check_duplicates
    this.addToTempObjectFaces(newFace_nodesB, 0); // 0:check_duplicates

    for (int i = 0; i < n; i++) {
      int next_i = (i + 1) % n;

      int[] newFace_nodes = {
        vT[i], vB[i], vB[next_i], vT[next_i]
      };

      this.addToTempObjectFaces(newFace_nodes, 0); // 0:check_duplicates
    }

    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ;
    value = 1;
    posX = 0;
    posY = 0;
    posZ = 0;
    scaleX = 1;
    scaleY = 1;
    scaleZ = 1;

    for (int i = 0; i < POINTER_TempObjectVertices; i++) {

      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];

      float the_dist = (pow((pow(abs(x - posX) / scaleX, 2) + pow(abs(y - posY) / scaleY, 2)), 0.5) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
      }

      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }

    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);

    SOLARCHVISION_model_added();
  }


  int addToTempObjectVertices (float x, float y, float z) {

    float[][] newVertex = {
      {
        x, y, z
      }
    };

    int vertex_existed = 0;

    float min_dist = FLOAT_undefined;

    for (int i = 0; i < POINTER_TempObjectVertices; i++) {

      float the_dist = funcs.vec_dist(newVertex[0], TempObjectVertices[i]);

      if (the_dist < 0.1) { // avoid creating duplicate vertices - WELD is necessary for allModel1Ds spheres!

        if (min_dist > the_dist) {
          min_dist = the_dist;
          vertex_existed = i;
        }
      }
    }

    if (vertex_existed == 0) {

      if (POINTER_TempObjectVertices >= TempObjectVertices.length) {
        TempObjectVertices = (float[][]) concat(TempObjectVertices, newVertex);
      } else {
        //TempObjectVertices[POINTER_TempObjectVertices] = new int [3];

        TempObjectVertices[POINTER_TempObjectVertices][0] = x;
        TempObjectVertices[POINTER_TempObjectVertices][1] = y;
        TempObjectVertices[POINTER_TempObjectVertices][2] = z;
      }

      vertex_existed = POINTER_TempObjectVertices;

      POINTER_TempObjectVertices += 1;
    }

    return(vertex_existed);
  }

  int addToTempObjectFaces (int[] f, int check_duplicates) {

    int face_existed = 0;

    if (check_duplicates == 1) {

      for (int i = 0; i < POINTER_TempObjectFaces; i++) {
        if (f.length == TempObjectFaces[i].length) {

          for (int k = 0; k < f.length; k++) { // "k" introduces different variations that two faces could match

            for (int dir = -1; dir <= 1; dir += 2) { // "dir" introduces different diretions that two faces could match

              //println("\ndir=", dir);

              float total_distances = 0;

              for (int j = 0; j < f.length; j++) {

                int q = (j * dir + k + f.length) % f.length;

                //print("q=", q, "; k=" );

                total_distances += funcs.vec_dist(TempObjectVertices[f[q]], TempObjectVertices[TempObjectFaces[i][j]]);
              }

              if (total_distances < 0.0001) { // avoid creating duplicate faces
                //println("A duplicate face detected :", i);

                face_existed = i;
                break;
              }
            }
          }
        }
        if (face_existed != 0) break;
      }
    }

    if (face_existed == 0) {

      if (POINTER_TempObjectFaces >= TempObjectFaces.length) {
        int[][] newFace_nodes = {
          f
        };
        TempObjectFaces = (int[][]) concat(TempObjectFaces, newFace_nodes);
      } else {
        TempObjectFaces[POINTER_TempObjectFaces] = new int [f.length];

        for (int i = 0; i < f.length; i++) {
          TempObjectFaces[POINTER_TempObjectFaces][i] = f[i];
        }
      }

      face_existed = POINTER_TempObjectFaces;

      POINTER_TempObjectFaces += 1;
    }

    return(face_existed);
  }

  void addTempObjectToScene (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, float t) {

    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;

    if (m == -1) current_Material = 0;
    else current_Material = m;

    for (int i = 0; i < POINTER_TempObjectFaces; i++) {

      int[] new_Vertex_ids = new int [TempObjectFaces[i].length];

      for (int j = 0; j < TempObjectFaces[i].length; j++) {

        float x0 = TempObjectVertices[TempObjectFaces[i][j]][0] * sx;
        float y0 = TempObjectVertices[TempObjectFaces[i][j]][1] * sy;
        float z0 = TempObjectVertices[TempObjectFaces[i][j]][2] * sz;

        float x = x0 * funcs.cos_ang(t) - y0 * funcs.sin_ang(t);
        float y = x0 * funcs.sin_ang(t) + y0 * funcs.cos_ang(t);
        float z = z0;

        new_Vertex_ids[j] = allPoints.create(x + cx, y + cy, z + cz);
      }

      if (m == -1) current_Material = 1 + (current_Material % (allMaterials.Number - 1));
      allFaces.create(new_Vertex_ids);
    }

    TempObjectVertices = new float [0][3];

    TempObjectFaces = new int [0][1];

    POINTER_TempObjectVertices = 0;
    POINTER_TempObjectFaces = 0;

    SOLARCHVISION_model_added();
  }

  void createLozenge (float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, int tessellation, int BuildFaces) {

    if (tessellation > 0) {

      if (tessellation == 1) {

        int[] newPoly = new int [4];

        newPoly[0] = this.addToTempObjectVertices(x1, y1, z1);
        newPoly[1] = this.addToTempObjectVertices(x2, y2, z2);
        newPoly[2] = this.addToTempObjectVertices(x3, y3, z3);
        newPoly[3] = this.addToTempObjectVertices(x4, y4, z4);

        if (BuildFaces != 0) {
          this.addToTempObjectFaces(newPoly, 1); // 1:check_duplicates
        }

        {
          // because the vertices might be welded to a nearest point:

          x1 = TempObjectVertices[newPoly[0]][0];
          y1 = TempObjectVertices[newPoly[0]][1];
          z1 = TempObjectVertices[newPoly[0]][2];

          x2 = TempObjectVertices[newPoly[1]][0];
          y2 = TempObjectVertices[newPoly[1]][1];
          z2 = TempObjectVertices[newPoly[1]][2];

          x3 = TempObjectVertices[newPoly[2]][0];
          y3 = TempObjectVertices[newPoly[2]][1];
          z3 = TempObjectVertices[newPoly[2]][2];

          x4 = TempObjectVertices[newPoly[3]][0];
          y4 = TempObjectVertices[newPoly[3]][1];
          z4 = TempObjectVertices[newPoly[3]][2];
        }
      }



      tessellation -= 1;

      float[] M = {
        (x1 + x2 + x4) / 3.0, (y1 + y2 + y4) / 3.0, (z1 + z2 + z4) / 3.0
      };
      float[] N = {
        (x3 + x2 + x4) / 3.0, (y3 + y2 + y4) / 3.0, (z3 + z2 + z4) / 3.0
      };

      M = funcs.vec3_unit(M);
      N = funcs.vec3_unit(N);

      createLozenge(x2, y2, z2, N[0], N[1], N[2], x4, y4, z4, M[0], M[1], M[2], tessellation, BuildFaces);


      if (BuildFaces != 0)
      {

        float[] P = M;

        PVector A_vec = new PVector(x1, y1, z1);
        PVector B_vec = new PVector(x2, y2, z2);

        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();

        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;

        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };

        Q = funcs.vec3_unit(Q);

        createLozenge(x2, y2, z2, P[0], P[1], P[2], x1, y1, z1, Q[0], Q[1], Q[2], tessellation, BuildFaces);
      }


      if (BuildFaces != 0)
      {

        float[] P = N;

        PVector A_vec = new PVector(x3, y3, z3);
        PVector B_vec = new PVector(x4, y4, z4);

        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();

        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;

        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };

        Q = funcs.vec3_unit(Q);

        createLozenge(x4, y4, z4, P[0], P[1], P[2], x3, y3, z3, Q[0], Q[1], Q[2], tessellation, BuildFaces);
      }
    }

    SOLARCHVISION_model_added();
  }



  void add_onLand (int people_or_trees) {

    //randomSeed(0);

    float[][] treesXYZS = {
      {
        0, 0, 0, 0
      }
    };

    int tessellation = Land3D.displayTessellation;
    if (WIN3D.FacesShade == SHADE.Surface_Base) {
      tessellation = 0;
    }

    int totalNumberOfSubs = 1;
    if (tessellation > 0) totalNumberOfSubs = 4 * int(funcs.roundTo(pow(4, tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.



    if ((Land3D.displayTexture) && (people_or_trees != 1)) { // using another algorithm for people << i.e. no image processing from green colors of the map!

      for (int i = Land3D.skipStart; i < Land3D.num_rows - 1 - Land3D.skipEnd; i++) {
        for (int j = 0; j < Land3D.num_columns - 1; j++) {

          float[][] base_Vertices = new float [4][3];

          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];

          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];

          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];

          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];

          for (int n = 0; n < totalNumberOfSubs; n++) {

            float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

            int n_Map = -1;
            for (int q = 0; q < Land3D.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map

              n_Map = q;

              for (int s = 0; s < subFace.length; s++) {

                float u = (subFace[s][0] / Land3D.Textures_U_scale[q] + 0.5);
                float v = (-subFace[s][1] / Land3D.Textures_V_scale[q] + 0.5);

                if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {

                  n_Map = -1;

                  break;
                }
              }

              if (n_Map == q) break;
            }

            if (n_Map != -1) {

              int max_o = int(10000 / pow(2, Land3D.displayTessellation)); // number of tries to find green points!

              //if (max_o > 100) max_o = 100;

              if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
              //if (i > 10) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<

              //if (i < 4) max_o = 0; // <<<<<<< do not create at near distances <<<<<<<<<<<<<<<

              for (int o = 0; o < max_o; o++) {

                float di = random(1);
                float dj = random(1);

                float x = funcs.bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
                float y = funcs.bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
                float z = funcs.bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);

                // do not create trees close to each other
/*
                for (int p = 0; p < ?.length; p++) {
                }
????????
                if () {

                  break;
                }
*/

                float u = (x / Land3D.Textures_U_scale[n_Map] + 0.5);
                float v = (-y / Land3D.Textures_V_scale[n_Map] + 0.5);

                int uPixel = int(u * Land3D.Textures_map[n_Map].width);
                int vPixel = int(v * Land3D.Textures_map[n_Map].height);

                color COL = Land3D.Textures_map[n_Map].get(uPixel, vPixel);
                //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                float r = COL >> 16 & 0xFF;
                float g = COL >> 8 & 0xFF;
                float b = COL & 0xFF;

                //if ((g > r + 8) && (g > b + 16)) { // looks more green
                //if ((g > r - 4) && (g > b + 16)) { // looks more green, slightly red is acceptible
                if ((g > r + 4) && (g > b + 4)) { // looks more green

                  if (g < 56) { // not on grass (light green)

                    //if (z + STATION.getElevation() > 5) { // not in water (below see level)

                    //float s = 5 + random(10);
                    float s = 5 + random(12.5);
                    //float s = 10 + random(20); // bigger trees

                    int foundNearTree = 0;

                    for (int f = 1; f < treesXYZS.length; f++) {

                      float x0 = treesXYZS[f][0];
                      float y0 = treesXYZS[f][1];
                      float z0 = treesXYZS[f][2];
                      float s0 = treesXYZS[f][3];

                      //if (dist(x0, y0, z0, x, y, z) < 0.25 * (s0 + s)) { //avoids creating trees close to each other
                      if (dist(x0, y0, z0, x, y, z) < 0.5 * (s0 + s)) { //avoids creating trees close to each other
                        foundNearTree = 1;

                        break;
                      }
                    }

                    if (foundNearTree == 0) {

                      if (people_or_trees == 2) {
                        allModel2Ds.create("TREES", 0, x, y, z, s);
                      } else {
                        allModel1Ds.create(User3D.create_Model1D_Type, User3D.create_Model1D_Seed,
                                           User3D.create_Model1D_DegreeMax,
                                           x, y, z, s, floor(random(360)),
                                           User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                                           User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                                           User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                      }


                      float[][] newTree = {
                        {
                          x, y, z, s
                        }
                      };
                      treesXYZS = (float [][]) concat(treesXYZS, newTree);
                    }
                    //}
                  }
                }
              }
            }
          }
        }
      }
    } else {

      for (int i = Land3D.skipStart; i < Land3D.num_rows - 1 - Land3D.skipEnd; i++) {
        for (int j = 0; j < Land3D.num_columns - 1; j++) {

          float[][] base_Vertices = new float [4][3];

          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];

          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];

          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];

          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];

          for (int n = 0; n < totalNumberOfSubs; n++) {

            float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

            //int max_o = int((16.0 / pow(2, Land3D.displayTessellation)) * pow(random(1), 8)); // i.e. maximum 3 people in each pixel for tes=2
            int max_o = int(random(10)) == 0 ? 1 : 0;

            if (i > 2) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<

            for (int o = 0; o < max_o; o++) {

              float di = random(1);
              float dj = random(1);

              float x = funcs.bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
              float y = funcs.bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
              float z = funcs.bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);

              if (z + STATION.getElevation() > 0) { // i.e. above sea level

                if (dist(x, y, 0, 0) > 20.0) { // i.e. No 2D at the center!

                  if (people_or_trees == 1) {
                    allModel2Ds.create("PEOPLE", 0, x, y, z, 2.5);
                  } else if (people_or_trees == 2) {
                    allModel2Ds.create("TREES", 0, x, y, z, 5 + random(10));
                  } else {
                    allModel1Ds.create(User3D.create_Model1D_Type,  User3D.create_Model1D_Seed,
                                       User3D.create_Model1D_DegreeMax,
                                       x, y, z, 5 + random(10), floor(random(360)),
                                       User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                                       User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                                       User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                  }
                }
              }
            }
          }
        }
      }
    }

    SOLARCHVISION_model_changed();
  }

  void add_onPolar (int people_or_trees, int n, float x0, float y0, float z0, float r1, float r2) {

    for (int i = 0; i < n; i++) {

      float a = floor(random(360));
      float b = pow(random(pow(r1, 2), pow(r2, 2)), 0.5); // to make it uniform on the surface

      float x = x0 + b * funcs.cos_ang(a);
      float y = y0 + b * funcs.sin_ang(a);
      float z = z0;

      if (people_or_trees == 1) {
        allModel2Ds.create("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        allModel2Ds.create("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.create(User3D.create_Model1D_Type, User3D.create_Model1D_Seed,
                           User3D.create_Model1D_DegreeMax,
                           x, y, z, 5 + random(10), floor(random(360)),
                           User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                           User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                           User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }

    SOLARCHVISION_model_changed();
  }

  void add_onPlane (int people_or_trees, int n, float x0, float y0, float z0, float rx, float ry, float rot) {

    for (int i = 0; i < n; i++) {

      //float a = random(-rx, rx);
      //float b = random(-ry, ry);

      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);
      float b = random(1-ry, ry-1);

      float x = a * funcs.cos_ang(rot) - b * funcs.sin_ang(rot);
      float y = a * funcs.sin_ang(rot) + b * funcs.cos_ang(rot);
      float z = 0;

      x += x0;
      y += y0;
      z += z0;

      if (people_or_trees == 1) {
        allModel2Ds.create("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        allModel2Ds.create("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.create(User3D.create_Model1D_Type, User3D.create_Model1D_Seed,
                           User3D.create_Model1D_DegreeMax,
                           x, y, z, 5 + random(10), floor(random(360)),
                           User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                           User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                           User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }

    SOLARCHVISION_model_changed();
  }

  void add_onMesh2 (int people_or_trees, int n, float x1, float y1, float z1, float x2, float y2, float z2) {

    float x0 = 0.5 * (x1 + x2);
    float y0 = 0.5 * (y1 + y2);
    float z0 = 0.5 * (z1 + z2);

    float rx = 0.5 * abs(x2 - x1);
    float ry = 0.5 * abs(y2 - y1);

    for (int i = 0; i < n; i++) {

      //float a = random(-rx, rx);
      //float b = random(-ry, ry);

      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);
      float b = random(1-ry, ry-1);

      float x = x0 + a;
      float y = y0 + b;
      float z = z0;

      if (people_or_trees == 1) {
        allModel2Ds.create("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        allModel2Ds.create("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.create(User3D.create_Model1D_Type, User3D.create_Model1D_Seed,
                           User3D.create_Model1D_DegreeMax,
                           x, y, z, 5 + random(10), floor(random(360)),
                           User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                           User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                           User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }

    SOLARCHVISION_model_changed();
  }








  void add_DefaultModel (int n) {

    if (Land3D.loadMesh) {

      Create3D.add_onLand(1); // 1 = people

      Create3D.add_onLand(2); // 2 = 2D trees
    } else {
      //allModel2Ds.add_polar(1, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // people
      //allModel2Ds.add_polar(2, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // trees
    }



    if (n == 1) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(7, 6, 0, 1, 0, 0, -32, -32, 0, 32, 32, 0);

      allGroups.beginNewGroup(0, -20, 0, 1, 1, 1, 0, 0, 0);
      this.add_PolygonHyper(7, 4, 0, 1, 0, 0, 0, -20, 4, 8, 8, 4, 0);

      allGroups.beginNewGroup(15, 15, 0, 1, 1, 1, 0, 0, 0);
      this.add_CrystalSphere(7, 0, 0, 1, 0, 0, 15, 15, 0, 5, 4, 0, 0);

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House2_Core(7, 4, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0);
    }

    if (n == 2) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(8, 0, 0, 1, 0, 0, -25, -25, 0, 25, 25, 0);

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House2_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0);
    }

    if (n == 3) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(8, 0, 0, 1, 0, 0, -25, -25, 0, 25, 25, 0);

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House3_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0);
    }

    if (n == 4) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(8, 0, 0, 1, 0, 0, -25, -25, 0, 25, 25, 0);

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_PolygonHyper(0, 0, 0, 1, 0, 0, 0, 0, 5, 10, 10, 4, 0);
    }

    if (n == 5) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(8, 0, 0, 1, 0, 0, -50, -50, 0, 50, 50, 0);

      {
        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 0;
        float z = 0;
        float r = 10;
        this.add_CrystalSphere(1, 0, 0, 1, 0, 0, x, y, z, r, 5, 0, 90);
        allSolids.create(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }

      {
        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = -20;
        float y = -20;
        float z = 0;
        float r = 8;
        this.add_CrystalSphere(2, 0, 0, 1, 0, 0, x, y, z, r, 4, 0, 90);
        allSolids.create(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }

      {
        allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 20;
        float z = 0;
        float r = 6;
        this.add_CrystalSphere(3, 0, 0, 1, 0, 0, x, y, z, r, 3, 0, 90);
        allSolids.create(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
    }



    if (n == 6) {
      //Complex used in the YC book:

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Mesh2(8, 0, 0, 1, 0, 0, -100, -100, 0, 100, 100, 0);

      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, -78, 0, -66, -42, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, -78, 12, -66, -66, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, -54, 12, -66, -42, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, -78, 24, -66, -42, 36);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -54, -78, 0, -6, -30, 6);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 6, -78, 0, 30, -54, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 6, -42, 0, 30, -30, 48);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 42, -78, 0, 78, -66, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 42, -66, 0, 48, -42, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 72, -66, 0, 78, -42, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 42, -42, 0, 78, -30, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, -30, 0, -66, 18, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -54, -18, 0, -30, -12, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -54, -12, 0, -48, 12, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -36, -12, 0, -30, 12, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -54, 12, 0, -30, 18, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -18, -18, 0, 18, 18, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 30, -18, 0, 54, 30, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 66, -18, 0, 78, 6, 48);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 66, 18, 0, 78, 30, 96);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, 30, 0, -30, 54, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -18, 30, 0, -12, 54, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -12, 30, 0, 12, 36, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -12, 48, 0, 12, 54, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 30, 0, 18, 54, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, 66, 0, -42, 78, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, 66, 12, -66, 78, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -54, 66, 12, -42, 78, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -78, 66, 24, -42, 78, 36);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, -30, 66, 0, 18, 78, 24);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 30, 42, 0, 42, 78, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 42, 42, 0, 66, 48, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 42, 72, 0, 66, 78, 12);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 66, 42, 0, 78, 78, 12);
    }
  }

  int maximum_default_models = 6;


  void add_Model_2DsFromFile () {

    allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);


    String[] FileALL = loadStrings(BaseFolder + "/Import/Hamedan_PEOPLE.txt");

    String lineSTR;

    for (int f = 1; f < FileALL.length; f++) { // skip the first line.

      lineSTR = FileALL[f];
      //println(lineSTR);

      String[] parts = split(lineSTR, ",");

      float x = float(parts[0]);
      float y = float(parts[1]);
      float z = float(parts[2]);

      allModel2Ds.create("PEOPLE", 0, x, y, z, 2.5);
    }
  }



  void add_Model_Main () {

    allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

    addToLastGroup = false;
  }

}

solarchvision_Create3D Create3D = new solarchvision_Create3D();




class solarchvision_Cameras {

  private final static String CLASS_STAMP = "Cameras";

  solarchvision_Cameras () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = false;

  float[][] options;
  int[] Type;
  int num;

  void makeEmpty (int n) {

    this.num = n;
    this.options = new float [n][9];
    this.Type = new int [n];

    this.add_first();

    if (Select3D != null) {
      Select3D.deselect_Cameras();
    }

    SOLARCHVISION_model_changed();
  }


  void create (float x, float y, float z, float s, float rx, float ry, float rz, float rs, float f, int t) {

    int[] TempCamera_type = {
      t
    };
    this.Type = concat(this.Type, TempCamera_type);

    float[][] TempCamera_options = {
      {
        x, y, z, s, rx, ry, rz, rs, f
      }
    };
    this.options = (float[][]) concat(this.options, TempCamera_options);

    this.num += 1;
  }


  float get_posX (int n) {
    return this.options[n][0];
  }

  float get_posY (int n) {
    return this.options[n][1];
  }

  float get_posZ (int n) {
    return this.options[n][2];
  }

  float get_posT (int n) {
    return this.options[n][3];
  }

  float get_rotX (int n) {
    return this.options[n][4];
  }

  float get_rotY (int n) {
    return this.options[n][5];
  }

  float get_rotZ (int n) {
    return this.options[n][6];
  }

  float get_rotT (int n) {
    return this.options[n][7];
  }

  float get_zoom (int n) {
    return this.options[n][8];
  }

  int get_type (int n) {
    return this.Type[n];
  }

  void set_posX (int n, float f) {
    this.options[n][0] = f;
  }

  void set_posY (int n, float f) {
    this.options[n][1] = f;
  }

  void set_posZ (int n, float f) {
    this.options[n][2] = f;
  }

  void set_posT (int n, float f) {
    this.options[n][3] = f;
  }

  void set_rotX (int n, float f) {
    this.options[n][4] = f;
  }

  void set_rotY (int n, float f) {
    this.options[n][5] = f;
  }

  void set_rotZ (int n, float f) {
    this.options[n][6] = f;
  }

  void set_rotT (int n, float f) {
    this.options[n][7] = f;
  }

  void set_zoom (int n, float f) {
    this.options[n][8] = f;
  }

  void set_type (int n, int t) {
    this.Type[n] = t;
  }


  void move (int n, float dx, float dy, float dz) {
    this.options[n][0] += dx;
    this.options[n][1] += dy;
    this.options[n][2] += dz;
  }




  void add_first () {

    this.create(WIN3D.position_X,
                    WIN3D.position_Y,
                    WIN3D.position_Z,
                    WIN3D.position_T,
                    WIN3D.rotation_X,
                    WIN3D.rotation_Y,
                    WIN3D.rotation_Z,
                    WIN3D.rotation_T,
                    WIN3D.Zoom,
                    WIN3D.ViewType);
  }




  private float[][] Vertices;
  private int[][] Faces;

  void draw () {

    this.Faces = new int [this.num][4];
    this.Vertices = new float [4 * this.num][3];

    if (this.displayAll) {

      for (int f = 0; f < this.num; f++) {

        float Camera_pX = this.get_posX(f);
        float Camera_pY = this.get_posY(f);
        float Camera_pZ = this.get_posZ(f);
        float Camera_pT = this.get_posT(f);
        float Camera_rX = this.get_rotX(f);
        float Camera_rY = this.get_rotY(f);
        float Camera_rZ = this.get_rotZ(f);
        float Camera_rT = this.get_rotT(f);
        float Camera_zoom = this.get_zoom(f);
        int   Camera_type = this.get_type(f);

        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        WIN3D.graphics.noFill();

        WIN3D.graphics.beginShape();

        float[][] ImageVertex = getCorners(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_zoom);

        for (int q = 1; q <= 4; q++) {

          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];

          WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);

          this.Vertices[f * 4 + q - 1][0] = x;
          this.Vertices[f * 4 + q - 1][1] = y;
          this.Vertices[f * 4 + q - 1][2] = z;
        }

        this.Faces[f][0] = f * 4 + 0;
        this.Faces[f][1] = f * 4 + 1;
        this.Faces[f][2] = f * 4 + 2;
        this.Faces[f][3] = f * 4 + 3;

        WIN3D.graphics.endShape(CLOSE);

        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        //WIN3D.graphics.fill(127,255,127,127);
        WIN3D.graphics.noFill();

        WIN3D.graphics.beginShape();

        for (int q = 1; q <= 4; q++) {

          {
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];

            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }

          {
            int next_q = 1 + (q % 4);

            float x = ImageVertex[next_q][0];
            float y = ImageVertex[next_q][1];
            float z = ImageVertex[next_q][2];

            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }

          {
            int o = 0;

            float x = ImageVertex[o][0];
            float y = ImageVertex[o][1];
            float z = ImageVertex[o][2];

            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
        }

        WIN3D.graphics.endShape(CLOSE);
      }

      WIN3D.graphics.strokeWeight(0);
    }
  }


  float[][] getCorners (int Camera_type, float Camera_pX, float Camera_pY, float Camera_pZ, float Camera_pT, float Camera_rX, float Camera_rY, float Camera_rZ, float Camera_rT, float Camera_zoom) {

    float[][] ImageVertex = new float [5][3];

    float r = Camera_pT * 5; // <<<<<<

    float rx = r * funcs.sin_ang(0.5 * Camera_zoom) /  WIN3D.view_R;
    float ry = r * funcs.sin_ang(0.5 * Camera_zoom);
    float rz = r * funcs.cos_ang(0.5 * Camera_zoom);

    for (int q = 0; q < 5; q++) {

      float qx = 0, qy = 0, qz = 0;

      if (q == 0) {
        qx = 0;
        qy = 0;
        qz = 0;
      } else if (q == 1) {
        qx = -1;
        qy = -1;
        qz = -1;
      } else if (q == 2) {
        qx = -1;
        qy = 1;
        qz = -1;
      } else if (q == 3) {
        qx = 1;
        qy = 1;
        qz = -1;
      } else if (q == 4) {
        qx = 1;
        qy = -1;
        qz = -1;
      }

      float x = 0, y = 0, z = 0;

      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
      float keep_WIN3D_position_X = WIN3D.position_X;
      float keep_WIN3D_position_Y = WIN3D.position_Y;
      float keep_WIN3D_position_Z = WIN3D.position_Z;
      float keep_WIN3D_position_T = WIN3D.position_T;
      float keep_WIN3D_rotation_X = WIN3D.rotation_X;
      float keep_WIN3D_rotation_Y = WIN3D.rotation_Y;
      float keep_WIN3D_rotation_Z = WIN3D.rotation_Z;
      float keep_WIN3D_rotation_T = WIN3D.rotation_T;
      float keep_WIN3D_Zoom = WIN3D.Zoom;

      {

        WIN3D.position_X = Camera_pX;
        WIN3D.position_Y = Camera_pY;
        WIN3D.position_Z = Camera_pZ;
        WIN3D.position_T = Camera_pT;
        WIN3D.rotation_X = Camera_rX;
        WIN3D.rotation_Y = Camera_rY;
        WIN3D.rotation_Z = Camera_rZ;
        WIN3D.rotation_T = Camera_rT;
        WIN3D.Zoom = Camera_zoom;

        WIN3D.transform_3DViewport();

        float x1 = rx * qx;
        float y1 = ry * qy;
        float z1 = rz * qz;

        float x2 = x1;
        float y2 = y1 * funcs.cos_ang(Camera_rX) - z1 * funcs.sin_ang(Camera_rX);
        float z2 = y1 * funcs.sin_ang(Camera_rX) + z1 * funcs.cos_ang(Camera_rX);

        float x3 = x2 * funcs.cos_ang(Camera_rZ) - y2 * funcs.sin_ang(Camera_rZ);
        float y3 = x2 * funcs.sin_ang(Camera_rZ) + y2 * funcs.cos_ang(Camera_rZ);
        float z3 = z2;

        x = WIN3D.CAM_x + x3;
        y = WIN3D.CAM_y + y3;
        z = WIN3D.CAM_z + z3;
      }

      WIN3D.CAM_x = keep_WIN3D_CAM_x;
      WIN3D.CAM_y = keep_WIN3D_CAM_y;
      WIN3D.CAM_z = keep_WIN3D_CAM_z;
      WIN3D.position_X = keep_WIN3D_position_X;
      WIN3D.position_Y = keep_WIN3D_position_Y;
      WIN3D.position_Z = keep_WIN3D_position_Z;
      WIN3D.position_T = keep_WIN3D_position_T;
      WIN3D.rotation_X = keep_WIN3D_rotation_X;
      WIN3D.rotation_Y = keep_WIN3D_rotation_Y;
      WIN3D.rotation_Z = keep_WIN3D_rotation_Z;
      WIN3D.rotation_T = keep_WIN3D_rotation_T;
      WIN3D.Zoom = keep_WIN3D_Zoom;

      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }

    return ImageVertex;
  }

  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Faces.length][4];

    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }

    for (int f = 0; f < this.Faces.length; f++) {

      int n = this.Faces[f].length;

      float X_intersect = FLOAT_undefined;
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;

      boolean InPoly = false;

      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];

      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);

      float[] face_norm = funcs.vec3_cross(AC, BD);

      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

      float R = -funcs.vec3_dot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {

          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }

      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }

    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.Faces.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }

    }

    return return_point;
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    int ni = this.num;
    XML_setInt(parent, "ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      XML_setInt(child, "id", i);
      String txt = "";
      txt += nf(this.get_posX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_posY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_posZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_posT(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotX(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotY(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotZ(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_rotT(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_zoom(i), 0, 4).replace(",", "."); // <<<<
      txt += ",";
      txt += nf(this.get_type(i), 0);

      XML_setContent(child, txt);
    }

    XML_setBoolean(parent, "displayAll", this.displayAll);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = XML_getInt(parent, "ni");

    this.options = new float [ni][9];
    this.Type = new int [ni];

    this.num = ni;

    XML[] children = parent.getChildren("item");
    for (int i = 0; i < ni; i++) {

      String txt = XML_getContent(children[i]);
      String[] parts = split(txt, ",");
      this.set_posX(i, float(parts[0]));
      this.set_posY(i, float(parts[1]));
      this.set_posZ(i, float(parts[2]));
      this.set_posT(i, float(parts[3]));
      this.set_rotX(i, float(parts[4]));
      this.set_rotY(i, float(parts[5]));
      this.set_rotZ(i, float(parts[6]));
      this.set_rotT(i, float(parts[7]));
      this.set_zoom(i, float(parts[8]));
      this.set_type(i,   int(parts[9]));
    }

    this.displayAll = XML_getBoolean(parent, "displayAll");
  }

}

solarchvision_Cameras allCameras = new solarchvision_Cameras();



class solarchvision_Sections {

  private final static String CLASS_STAMP = "Sections";

  solarchvision_Sections () { // constructor
    makeEmpty(0);
  }

  boolean displayAll = true;

  int num;
  float[][] f_data = new float[0][6];
  int  [][] i_data = new int  [0][3];

  void makeEmpty (int n) {
    this.f_data = new float [n][6];
    this.i_data = new int   [n][3];

    this.SolidImpact = new PImage [n];

    this.SolarImpact = new PImage [n][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];

    this.num = n;

    if (Select3D != null) {
      Select3D.deselect_Sections();
    }

    SOLARCHVISION_model_changed();
  }


  void create (float x, float y, float z, float r, float u, float v, int t, int RES1, int RES2) {

    int[][] Temp_i_data = {
      {
        t, RES1, RES2
      }
    };
    this.i_data = (int[][]) concat(this.i_data, Temp_i_data);

    float[][] Temp_f_data = {
      {
        x, y, z, r, u, v
      }
    };
    this.f_data = (float[][]) concat(this.f_data, Temp_f_data);

    PImage[] Temp_SolidImpact = {
      createImage(RES1, RES2, RGB)
    };
    this.SolidImpact = (PImage[]) concat(this.SolidImpact, Temp_SolidImpact);

    PImage[][][] Temp_SolarImpact = new PImage [1][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      int i = 0;
      for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {
        for (int q = 0; q < numberOfImpactVariations; q++) {
          Temp_SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
        }
      }
    }
    this.SolarImpact = (PImage[][][]) concat(this.SolarImpact, Temp_SolarImpact);

    this.num += 1;
  }




  int get_type (int n) { // Type
    return this.i_data[n][0];
  }

  int get_res1 (int n) { // RES1
    return this.i_data[n][1];
  }

  int get_res2 (int n) { // RES1
    return this.i_data[n][2];
  }

  void set_type (int n, int t) {
    this.i_data[n][0] = t;
  }

  void set_res1 (int n, int t) {
    this.i_data[n][1] = t;
  }

  void set_res2 (int n, int t) {
    this.i_data[n][2] = t;
  }



  float getX (int n) { // offsetX
    return this.f_data[n][0];
  }

  float getY (int n) { // offsetY
    return this.f_data[n][1];
  }

  float getZ (int n) { // elevation
    return this.f_data[n][2];
  }

  float getR (int n) { // rotation
    return this.f_data[n][3];
  }

  float getU (int n) { // scaleU
    return this.f_data[n][4];
  }

  float getV (int n) { //scaleV
    return this.f_data[n][5];
  }



  void setX (int n, float f) {
    this.f_data[n][0] = f;
  }

  void setY (int n, float f) {
    this.f_data[n][1] = f;
  }

  void setZ (int n, float f) {
    this.f_data[n][2] = f;
  }

  void setR (int n, float f) {
    this.f_data[n][3] = f;
  }

  void setU (int n, float f) {
    this.f_data[n][4] = f;
  }

  void setV (int n, float f) {
    this.f_data[n][5] = f;
  }

  void move (int n, float dx, float dy, float dz) {
    this.f_data[n][0] += dx;
    this.f_data[n][1] += dy;
    this.f_data[n][2] += dz;
  }



  PImage[] SolidImpact = new PImage[0];
  PImage[][][] SolarImpact = new PImage [0][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];

  void resize_solarImpact_array () { // called when STUDY.j_End changes

    allSections.SolarImpact = new PImage [allSections.num][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      for (int i = 0; i < allSections.num; i++) {
        for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {
          for (int q = 0; q < numberOfImpactVariations; q++) {
            allSections.SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
          }
        }
      }
    }

  }









  private float[][] Vertices;
  private int[][] Faces;




  void draw (int target_window) {

    this.Faces = new int [this.num][4];
    this.Vertices = new float [4 * this.num][3];


    boolean proceed = true;

    if (this.displayAll == false) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {

      proceed = false;
    }

    if (proceed) {

      for (int f = 0; f < this.num; f++) {

        float Section_X = this.getX(f);
        float Section_Y = this.getY(f);
        float Section_Z = this.getZ(f);
        float Section_R = this.getR(f);
        float Section_U = this.getU(f);
        float Section_V = this.getV(f);

        int Section_Type = this.get_type(f);
        int Section_RES1 = this.get_res1(f);
        int Section_RES2 = this.get_res2(f);

        if (Section_Type != 0) {

          String the_filename = "Impact_" + nf(f, 0) + ".bmp";

          if (User3D.export_MaterialLibrary) {

            String TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

            if ((target_window == TypeWindow.HTML) ||
                (target_window == TypeWindow.OBJ3D)) {

              if (allSolarImpacts.displayImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolarImpact[f][IMPACTS_displayDay][Impact_TYPE].save(TEXTURE_path);
              } else if (allSolidImpacts.displayImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolidImpact[f].save(TEXTURE_path);
              }

              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
                htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                htmlOutput.println("\t\t\t\t</Appearance>");
              }

              if (target_window == TypeWindow.OBJ3D) {

                mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

                //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
              }
            }
          }


          if (target_window == TypeWindow.OBJ3D) {

            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;
              objOutput.println("g Impact_" + nf(f, 0));
            }

            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl " + the_filename.replace('.', '_'));
            }
          }


          float[][] subFace = getCorners(Section_Type, Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_RES1, Section_RES2);


          num_vertices_added = 0;

          int end_turn = 1;
          if (target_window == TypeWindow.OBJ3D) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {

            boolean display_image = false;

            if (target_window == TypeWindow.WIN3D) {

              WIN3D.graphics.beginShape();

              WIN3D.graphics.noStroke();
              WIN3D.graphics.noFill();

              if (allSolarImpacts.displayImage) {

                WIN3D.graphics.texture(this.SolarImpact[f][IMPACTS_displayDay][Impact_TYPE]);

              } else if (allSolidImpacts.displayImage) {

                WIN3D.graphics.texture(this.SolidImpact[f]);
              }

            }


            for (int q = 1; q <= 4; q++) {

              float x = subFace[q][0];
              float y = subFace[q][1];
              float z = subFace[q][2];
              float u = subFace[q][3];
              float v = subFace[q][4];

              if (target_window == TypeWindow.WIN3D) {

                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * Section_RES1, v * Section_RES2);
              }


              if (target_window == TypeWindow.OBJ3D) {

                v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }

                if (_turn == 2) {
                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }

                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }
              }

              this.Vertices[f * 4 + q - 1][0] = x;
              this.Vertices[f * 4 + q - 1][1] = y;
              this.Vertices[f * 4 + q - 1][2] = z;
            }

            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }

            this.Faces[f][0] = f * 4 + 0;
            this.Faces[f][1] = f * 4 + 1;
            this.Faces[f][2] = f * 4 + 2;
            this.Faces[f][3] = f * 4 + 3;
          }

          if (target_window == TypeWindow.OBJ3D) {

            String n1_txt = nf(obj_lastVertexNumber - 3, 0);
            String n2_txt = nf(obj_lastVertexNumber - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber - 0, 0);

            String m1_txt = nf(obj_lastVtextureNumber - 3, 0);
            String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber - 0, 0);

            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (User3D.export_BackSides) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }

          }


          if (target_window == TypeWindow.HTML) {

            htmlOutput.println("\t\t\t\t<shape>");

            htmlOutput.println("\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");


            htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided

            htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
            for (int s = 1; s < subFace.length; s++) {
              if (s > 1) {
                htmlOutput.print(",");
              }

              htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
            }
            htmlOutput.println("'></Coordinate>");


            for (int s = 1; s < subFace.length; s++) {

              float u = subFace[s][3];
              float v = subFace[s][4];

              if (s == 1) {
                htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
              }
              if (s > 1) {
                htmlOutput.print(",");
              }

              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
              SOLARCHVISION_HTMLprintVtexture(u, v);

              if (s == subFace.length - 1) {
                htmlOutput.println("'></TextureCoordinate>");
              }
            }



            htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");

            htmlOutput.println("\t\t\t\t</shape>");
          }

        }
      }

    }

  }


  float[][] getCorners (int Section_Type, float Section_X, float Section_Y, float Section_Z, float Section_R, float Section_U, float Section_V, int Section_RES1, int Section_RES2) {

    float[][] ImageVertex = new float [5][5];

    for (int q = 0; q < 5; q++) {

      float qx = 0, qy = 0, u = 0, v = 0;

      if (q == 0) {
        qx = 0;
        qy = 0;
        u = 0.5;
        v = 0.5;
      } // center
      else if (q == 1) {
        qx = -1;
        qy = -1;
        u = 0;
        v = 1;
      } else if (q == 2) {
        qx = 1;
        qy = -1;
        u = 1;
        v = 1;
      } else if (q == 3) {
        qx = 1;
        qy = 1;
        u = 1;
        v = 0;
      } else if (q == 4) {
        qx = -1;
        qy = 1;
        u = 0;
        v = 0;
      }

      float a = qx * 0.5 * Section_U + Section_X;
      float b = qy * 0.5 * Section_V + Section_Y;
      float c = Section_Z;

      float x = 0, y = 0, z = 0;

      if (Section_Type == 1) {
        x = a * funcs.cos_ang(Section_R) - b * funcs.sin_ang(Section_R);
        y = a * funcs.sin_ang(Section_R) + b * funcs.cos_ang(Section_R);
        z = c;
      } else if (Section_Type == 2) {
        x = a * funcs.cos_ang(Section_R) - c * funcs.sin_ang(Section_R);
        y = -(a * funcs.sin_ang(Section_R) + c * funcs.cos_ang(Section_R));
        z = b;
      } else if (Section_Type == 3) {
        x = a * funcs.cos_ang(90 - Section_R) - c * funcs.sin_ang(90 - Section_R); // ????????????
        y = -(a * funcs.sin_ang(90 - Section_R) + c * funcs.cos_ang(90 - Section_R)); // ????????????
        z = b;
      }

      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
      ImageVertex[q][3] = u;
      ImageVertex[q][4] = v;
    }

    return ImageVertex;
  }

  float[] intersect (float[] ray_pnt, float[] ray_dir) {

    float[] ray_normal = funcs.vec3_unit(ray_dir);

    float[][] hitPoint = new float [this.Faces.length][4];

    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }

    for (int f = 0; f < this.Faces.length; f++) {

      int n = this.Faces[f].length;

      float X_intersect = FLOAT_undefined;
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;

      boolean InPoly = false;

      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];

      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);

      float[] face_norm = funcs.vec3_cross(AC, BD);

      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

      float R = -funcs.vec3_dot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {

          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }

      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }

    }

    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

    float pre_dist = FLOAT_undefined;

    for (int f = 0; f < this.Faces.length; f++) {

      if (pre_dist > hitPoint[f][3]) {

        pre_dist = hitPoint[f][3];

        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }

    }

    return return_point;
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    {
      XML parent = xml.addChild(this.CLASS_STAMP);

      int ni = this.num;
      XML_setInt(parent, "ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        XML_setInt(child, "id", i);
        String txt = "";

        txt += nf(this.getX(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getY(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getZ(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getR(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getU(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";
        txt += nf(this.getV(i), 0, 4).replace(",", "."); // <<<<
        txt += ",";

        txt += nf(this.get_type(i), 0);
        txt += ",";
        txt += nf(this.get_res1(i), 0);
        txt += ",";
        txt += nf(this.get_res2(i), 0);

        XML_setContent(child, txt);
      }

      XML_setBoolean(parent, "displayAll", this.displayAll);
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".SolidImpact");
      int ni = this.SolidImpact.length;
      XML_setInt(parent, "ni", ni);
      for (int i = 0; i < ni; i++) {

        String the_filename = "SolidImpact_" + nf(i, 0) + ".bmp";

        String TEXTURE_path = Folder_Project + "/Textures/" + the_filename;

        println("Saving texture:", TEXTURE_path);
        this.SolidImpact[i].save(TEXTURE_path);

        XML child = parent.addChild("item");
        XML_setInt(child, "id", i);
        XML_setContent(child, TEXTURE_path);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".SolarImpacts");
      int ni = 0, nj = 0, nk = 0;

      ni = this.SolarImpact.length;
      if (ni > 0) {
        nj = this.SolarImpact[0].length;
        if (nj > 0) {
          nk = this.SolarImpact[0][0].length;
        }
      }

      XML_setInt(parent, "ni", ni);
      XML_setInt(parent, "nj", nj);
      XML_setInt(parent, "nk", nk);

      for (int i = 0; i < ni; i++) {
        for (int j = 0; j < nj; j++) {
          for (int k = 0; k < nk; k++) {

            String the_filename = "allSolarImpacts." + nf((i * nj + j) * nk + k, 0) + ".bmp";

            String TEXTURE_path = Folder_Project + "/Textures/" + the_filename;

            println("Saving texture:", TEXTURE_path);
            this.SolarImpact[i][j][k].save(TEXTURE_path);

            XML child = parent.addChild("item");
            XML_setInt(child, "id", (i * nj + j) * nk + k);
            XML_setContent(child, TEXTURE_path);
          }
        }
      }
    }
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    {
      XML parent = xml.getChild(this.CLASS_STAMP);

      int ni = XML_getInt(parent, "ni");

      this.f_data = new float [ni][6];
      this.i_data = new int   [ni][3];
      this.num = ni;

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < ni; i++) {

        String txt = XML_getContent(children[i]);
        String[] parts = split(txt, ",");

        this.setX(i, float(parts[0]));
        this.setY(i, float(parts[1]));
        this.setZ(i, float(parts[2]));
        this.setR(i, float(parts[3]));
        this.setU(i, float(parts[4]));
        this.setV(i, float(parts[5]));

        this.set_type(i, int(parts[6]));
        this.set_res1(i, int(parts[7]));
        this.set_res2(i, int(parts[8]));
      }

      this.displayAll = XML_getBoolean(parent, "displayAll");
    }

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".SolidImpact");

      int ni = XML_getInt(parent, "ni");

      this.SolidImpact = new PImage [ni];

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < ni; i++) {

        String TEXTURE_path = XML_getContent(children[i]);

        this.SolidImpact[i] = createImage(2, 2, RGB); // empty and small

        println("Loading texture(" + i + "):", TEXTURE_path);
        this.SolidImpact[i] = loadImage(TEXTURE_path);
        println("loaded!");
      }
    }

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".SolarImpacts");

      int ni = XML_getInt(parent, "ni");
      int nj = XML_getInt(parent, "nj");
      int nk = XML_getInt(parent, "nk");

      this.SolarImpact = new PImage [ni][nj][nk];

      XML[] children = parent.getChildren("item");
      for (int i = 0; i < ni; i++) {
        for (int j = 0; j < nj; j++) {
          for (int k = 0; k < nk; k++) {

            String TEXTURE_path = XML_getContent(children[(i * nj + j) * nk + k]);

            this.SolarImpact[i][j][k] = createImage(2, 2, RGB); // empty and small

            println("Loading texture(" + i + "," + j + "," + k + "):", TEXTURE_path);
            this.SolarImpact[i][j][k] = loadImage(TEXTURE_path);
            println("loaded!");
          }
        }
      }
    }
  }

}

solarchvision_Sections allSections = new solarchvision_Sections();



class solarchvision_WindRose {

  private final static String CLASS_STAMP = "WindRose";

  boolean rebuild_Image_array = true;

  PImage[] Image;

  boolean displayImage = false;

  int renderedRES = 1;
  int RES = 400;

  float scale = 400;


  void resize_Image_array () {

    this.Image = new PImage [(1 + STUDY.j_End - STUDY.j_Start)];

    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

      this.Image[j + 1] = createImage(2, 2, RGB); // empty and small
    }

    this.rebuild_Image_array = false;
  }


  void draw () {

    if (this.displayImage) {

      if (this.rebuild_Image_array) {
        this.resize_Image_array();
      }

      WIN3D.graphics.stroke(0);
      WIN3D.graphics.fill(127, 127, 127);

      WIN3D.graphics.beginShape();

      float elevation = 0.0 + allSolidImpacts.Z[1];
      float U_scale = this.scale;
      float V_scale = this.scale;

      float minU = 0;
      float maxU = this.renderedRES;
      float minV = 0;
      float maxV = this.renderedRES;

      //float c = HeightAboveGround * OBJECTS_scale; // <<< or zero i.e. height of the plane in 3D  // ?????????
      float c = elevation * OBJECTS_scale;

      c += 1; // put this.Image it at level 1m. // <<<<<<<<<<<

      WIN3D.graphics.beginShape();

      WIN3D.graphics.texture(this.Image[IMPACTS_displayDay]);
      WIN3D.graphics.stroke(255, 255, 255, 0);
      WIN3D.graphics.fill(255, 255, 255, 0);

      for (int q = 0; q < 4; q++) {

        float qx = 0, qy = 0, u = 0, v = 0;

        if (q == 0) {
          qx = -1;
          qy = -1;
          u = minU;
          v = maxV;
        } else if (q == 1) {
          qx = 1;
          qy = -1;
          u = maxU;
          v = maxV;
        } else if (q == 2) {
          qx = 1;
          qy = 1;
          u = maxU;
          v = minV;
        } else if (q == 3) {
          qx = -1;
          qy = 1;
          u = minU;
          v = minV;
        }

        float a = qx * 0.5;
        float b = qy * 0.5;

        float x = 0, y = 0, z = 0;

        x = a;
        y = b;
        z = c;

        WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * U_scale, v * V_scale);
      }

      WIN3D.graphics.endShape(CLOSE);
    }
  }




  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displayImage", this.displayImage);
    XML_setInt(parent, "RES", this.RES);
    XML_setInt(parent, "renderedRES", this.renderedRES);
    XML_setFloat(parent, "scale", this.scale);
  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displayImage = XML_getBoolean(parent, "displayImage");
    this.RES = XML_getInt(parent, "RES");
    this.renderedRES = XML_getInt(parent, "renderedRES");
    this.scale = XML_getFloat(parent, "scale");
  }
}

solarchvision_WindRose allWindRoses = new solarchvision_WindRose();




class solarchvision_WindFlow {

  private final static String CLASS_STAMP = "WindFlow";

  boolean displayAll = false;

  int pallet_CLR = 18;
  int pallet_DIR = -1;
  float pallet_MLT = 1;



  void draw (int target_window) {

    boolean proceed = true;

    if (this.displayAll == false) {
      proceed = false;
    }

    if ((target_window == TypeWindow.STUDY) ||
        (target_window == TypeWindow.WORLD)) {
      proceed = false;
    }

    if (proceed) {

      int PAL_type = allWindFlows.pallet_CLR;
      int PAL_direction = allWindFlows.pallet_DIR;
      float PAL_multiplier = allWindFlows.pallet_MLT;



      if (target_window == TypeWindow.OBJ3D) {

        String the_filename = "";

        if (User3D.export_MaterialLibrary) {

          the_filename = "WindFlowPallet.bmp";

          String TEXTURE_path = Folder_Export3D + "/" + Subfolder_exportMaps + the_filename;

          println("Saving texture:", TEXTURE_path);

          int RES1 = User3D.export_PalletResolution;
          int RES2 = User3D.export_PalletResolution / 16;

          PImage pallet_Texture = createImage(RES1, RES2, ARGB);


          pallet_Texture.loadPixels();

          for (int np = 0; np < (RES1 * RES2); np++) {
            int Image_X = np % RES1;
            int Image_Y = np / RES1;

            float _val = (Image_X / (0.5 * RES1)) - 1;

            float _u = 0.5 + 0.5 * _val;

            float[] COL = PAINT.getColorStyle(PAL_type, _u);

            pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
          }

          pallet_Texture.updatePixels();

          pallet_Texture.save(TEXTURE_path);


          mtlOutput.println("newmtl " + "WindFlow");
          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

          //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
        }

        num_vertices_added = 0;

        for (int _turn = 1; _turn < 4; _turn++) {

          if (_turn == 3) {
            obj_lastGroupNumber += 1;
            objOutput.println("g WindFlow");

            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl WindFlow");
            }
          }

          for (int q = 0; q < allSolidImpacts.Wind_Lines.length; q++) {

            int n1 = allSolidImpacts.Wind_Lines[q][0];
            int n2 = allSolidImpacts.Wind_Lines[q][1];

            float x1 = allSolidImpacts.Wind_Vertices[n1][0];
            float y1 = allSolidImpacts.Wind_Vertices[n1][1];
            float z1 = allSolidImpacts.Wind_Vertices[n1][2];

            float x2 = allSolidImpacts.Wind_Vertices[n2][0];
            float y2 = allSolidImpacts.Wind_Vertices[n2][1];
            float z2 = allSolidImpacts.Wind_Vertices[n2][2];


            float _val = allWindFlows.pallet_MLT * allSolidImpacts.Wind_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

            float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
            if (PAL_direction == -1) _u = 1 - _u;
            if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_direction == 2) _u =  0.5 * _u;

            float the_dist = dist(x1, y1, z1, x2, y2, z2);

            float[] W = {
              x2 - x1, y2 - y1, z2 - z1
            };
            W = funcs.vec3_unit(W);

            float Alpha = funcs.asin_ang(W[2]);
            float Beta = funcs.atan2_ang(W[1], W[0]) + 90;


            if (_turn == 1) {

              SOLARCHVISION_OBJprintVertex(x1, y1, z1);
              SOLARCHVISION_OBJprintVertex(x2, y2, z2);

              for (int i = 0; i < 4; i++) {

                float px = 0.1 * the_dist * cos(i * HALF_PI);
                float py = 0;
                float pz = 0.1 * the_dist * sin(i * HALF_PI);

                float pz_rot = pz;
                float px_rot = px * funcs.cos_ang(Beta) - py * funcs.sin_ang(Beta);
                float py_rot = px * funcs.sin_ang(Beta) + py * funcs.cos_ang(Beta);

                px = px_rot;
                py = py_rot;
                pz = pz_rot;

                px_rot = px;
                py_rot = py * funcs.cos_ang(Alpha) - pz * funcs.sin_ang(Alpha);
                pz_rot = py * funcs.sin_ang(Alpha) + pz * funcs.cos_ang(Alpha);

                px = px_rot;
                py = py_rot;
                pz = pz_rot;

                SOLARCHVISION_OBJprintVertex(x1 + px, y1 + py, z1 + pz);
              }
            }


            if (_turn == 2) {
              for (int i = 0; i < 6; i++) {

                float u1 = 0.5 * (_u + 0.5);

                if (u1 > 0.999) u1 = 0.999;
                if (u1 < 0.001) u1 = 0.001;

                SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
              }
            }

            if (_turn == 3) {
              num_vertices_added += 6;

              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 5, 0);
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 4, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n5_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n6_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 5, 0);
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 4, 0);
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
              String m5_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
              String m6_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);

              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n4_txt + "/" + m4_txt + " " + n5_txt + "/" + m5_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n5_txt + "/" + m5_txt + " " + n6_txt + "/" + m6_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n6_txt + "/" + m6_txt + " " + n3_txt + "/" + m3_txt);

              obj_lastFaceNumber += 4;
            }
          }
        }

        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }




      if (target_window == TypeWindow.WIN3D) {


        for (int q = 0; q < allSolidImpacts.Wind_Lines.length; q++) {

          int n1 = allSolidImpacts.Wind_Lines[q][0];
          int n2 = allSolidImpacts.Wind_Lines[q][1];

          float x1 = allSolidImpacts.Wind_Vertices[n1][0];
          float y1 = allSolidImpacts.Wind_Vertices[n1][1];
          float z1 = allSolidImpacts.Wind_Vertices[n1][2];

          float x2 = allSolidImpacts.Wind_Vertices[n2][0];
          float y2 = allSolidImpacts.Wind_Vertices[n2][1];
          float z2 = allSolidImpacts.Wind_Vertices[n2][2];


          float _val = this.pallet_MLT * allSolidImpacts.Wind_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

          float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;

          float[] COL = PAINT.getColorStyle(PAL_type, _u);

          /*
           WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
           WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);

           WIN3D.graphics.strokeWeight(1);
           WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);

           WIN3D.graphics.strokeWeight(4);
           WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, 0.5 * (x2 + x1) * OBJECTS_scale * WIN3D.scale, -0.5 * (y2 + y1) * OBJECTS_scale * WIN3D.scale, 0.5 * (z2 + z1) * OBJECTS_scale * WIN3D.scale);
           */


          float the_dist = dist(x1, y1, z1, x2, y2, z2);

          float[] W = {
            x2 - x1, y2 - y1, z2 - z1
          };
          W = funcs.vec3_unit(W);

          float Alpha = funcs.asin_ang(W[2]);
          float Beta = funcs.atan2_ang(W[1], W[0]) + 90;

          WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);
          WIN3D.graphics.noStroke();

          for (int i = 0; i < 4; i++) {

            WIN3D.graphics.beginShape();

            WIN3D.graphics.vertex(x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);

            for (int j = 0; j < 2; j++) {

              float px = 0.1 * the_dist * cos((i + j) * HALF_PI);
              float py = 0;
              float pz = 0.1 * the_dist * sin((i + j) * HALF_PI);

              float pz_rot = pz;
              float px_rot = px * funcs.cos_ang(Beta) - py * funcs.sin_ang(Beta);
              float py_rot = px * funcs.sin_ang(Beta) + py * funcs.cos_ang(Beta);

              px = px_rot;
              py = py_rot;
              pz = pz_rot;

              px_rot = px;
              py_rot = py * funcs.cos_ang(Alpha) - pz * funcs.sin_ang(Alpha);
              pz_rot = py * funcs.sin_ang(Alpha) + pz * funcs.cos_ang(Alpha);

              px = px_rot;
              py = py_rot;
              pz = pz_rot;

              WIN3D.graphics.vertex((x1 + px) * OBJECTS_scale * WIN3D.scale, -(y1 + py) * OBJECTS_scale * WIN3D.scale, (z1 + pz) * OBJECTS_scale * WIN3D.scale);
            }

            WIN3D.graphics.endShape(CLOSE);
          }
        }


        WIN3D.graphics.strokeWeight(0);
      }


    }
  }


  public void to_XML (XML xml) {

    println("Saving:" + this.CLASS_STAMP);

    XML parent = xml.addChild(this.CLASS_STAMP);

    XML_setBoolean(parent, "displayAll", this.displayAll);

    XML_setInt(parent, "pallet_CLR", this.pallet_CLR);
    XML_setInt(parent, "pallet_DIR", this.pallet_DIR);
    XML_setFloat(parent, "pallet_MLT", this.pallet_MLT);

  }


  public void from_XML (XML xml) {

    println("Loading:" + this.CLASS_STAMP);

    XML parent = xml.getChild(this.CLASS_STAMP);

    this.displayAll = XML_getBoolean(parent, "displayAll");

    this.pallet_CLR = XML_getInt(parent, "pallet_CLR");
    this.pallet_DIR = XML_getInt(parent, "pallet_DIR");
    this.pallet_MLT = XML_getFloat(parent, "pallet_MLT");

  }
}

solarchvision_WindFlow allWindFlows = new solarchvision_WindFlow();














void VertexSolar_resize_array () { // called when STUDY.j_End changes

  VertexSolar_XYZ     = new float [0][3];
  VertexSolar_amounts = new float [2][1 + STUDY.j_End - STUDY.j_Start][0];

  VertexSolar_rebuild_array = false;
}


void SOLARCHVISION_calculate_VertexSolar_array () {

  cursor(WAIT);

  VertexSolar_resize_array();

  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
      (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0];
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k;
  if (count_k < 0) count_k = 0;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int[][] PROCESSED_DAILY_SCENARIOS = {
    {
    }
  };

  float Progress = 0;

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if (1 + Progress < 100 * f / float(allFaces.nodes.length)) {
      Progress = 100 * f / float(allFaces.nodes.length);
      println("Progress:", int(Progress), "%");
    }

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      int tessellation = allFaces.getTessellation(f);

      int totalNumberOfSubs = 1;
      if (allFaces.getMaterial(f) == 0) {
        tessellation += allFaces.displayTessellation;
      }
      if (tessellation > 0) totalNumberOfSubs = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }

      for (int n = 0; n < totalNumberOfSubs; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

        for (int s = 0; s < subFace.length; s++) {

          int q = SHADE.findID_SolarImpact_atXYZ(subFace[s][0], subFace[s][1], subFace[s][2]);

          if (q < 0) { // this will compute and add new points to the list only if there are not computed before.

            int s_next = (s + 1) % subFace.length;
            int s_prev = (s + subFace.length - 1) % subFace.length;

            PVector U = new PVector(subFace[s_next][0] - subFace[s][0], subFace[s_next][1] - subFace[s][1], subFace[s_next][2] - subFace[s][2]);
            PVector V = new PVector(subFace[s_prev][0] - subFace[s][0], subFace[s_prev][1] - subFace[s][1], subFace[s_prev][2] - subFace[s][2]);
            PVector UV = U.cross(V);
            float[] W = {
              UV.x, UV.y, UV.z
            };
            W = funcs.vec3_unit(W);

            float Alpha = funcs.asin_ang(W[2]);
            float Beta = funcs.atan2_ang(W[1], W[0]) + 90;

            float[] VECT = {
              0, 0, 0
            };

            if (abs(Alpha) > 89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = 1;
            } else if (Alpha < -89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = -1;
            } else {
              VECT[0] = funcs.sin_ang(Beta);
              VECT[1] = -funcs.cos_ang(Beta);
              VECT[2] = funcs.tan_ang(Alpha);
            }

            VECT = funcs.vec3_unit(VECT);


            float SkyMask = 0;

            for (int i = 0; i < DiffuseVectors.length; i++) {
              float[] SkyV = {
                DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
              };

              float tmp = funcs.vec_dot(funcs.vec3_unit(SkyV), funcs.vec3_unit(VECT));
              if (tmp <= 0) tmp = 0; // removes backing faces

              SkyMask += tmp / float(DiffuseVectors.length);
            }



            int l = STUDY.ImpactLayer;

            int DATE_step = 1;

            int J_START = STUDY.j_Start;
            int J_END = STUDY.j_End;

            float TOTALvaluesSUM_RAD = FLOAT_undefined;
            float TOTALvaluesSUM_EFF_P = FLOAT_undefined;
            float TOTALvaluesSUM_EFF_N = FLOAT_undefined;
            int TOTALvaluesNUM = 0;

            for (int j = J_START; j < J_END; j += DATE_step) {

              float valuesSUM_RAD = FLOAT_undefined;
              float valuesSUM_EFF_P = FLOAT_undefined;
              float valuesSUM_EFF_N = FLOAT_undefined;
              int valuesNUM = 0;

              now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }

              float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

              int[] Normals_COL_N;


              if (PROCESSED_DAILY_SCENARIOS.length > STUDY.j_End - STUDY.j_Start) {
                Normals_COL_N = PROCESSED_DAILY_SCENARIOS[STUDY.j_End - STUDY.j_Start];
              } else {
                Normals_COL_N = new int [9];
                Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

                int[][] newNormals = {
                  Normals_COL_N
                };
                PROCESSED_DAILY_SCENARIOS = (int[][]) concat(PROCESSED_DAILY_SCENARIOS, newNormals);
                //println("length of PROCESSED_DAILY_SCENARIOS =", PROCESSED_DAILY_SCENARIOS.length);
              }

              int nk = Normals_COL_N[l];

              if (nk != -1) {
                int k = int(nk / STUDY.joinDays);
                int j_ADD = nk % STUDY.joinDays;

                for (int i = 0; i < 24; i++) {

                  if (STUDY.isInHourlyRange(i)) {

                    float HOUR_ANGLE = i;
                    float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                    if (SunR[3] > 0) {

                      now_k = k + start_k;
                      now_i = i;
                      now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }

                      Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                      Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                      Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                      Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                      if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
                        values_R_dir = FLOAT_undefined;
                        values_R_dif = FLOAT_undefined;
                        values_E_dir = FLOAT_undefined;
                        values_E_dif = FLOAT_undefined;
                      } else {

                        int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);

                        if (memberCount == 1) {
                          values_R_dir = 0.001 * Pa;
                          values_R_dif = 0.001 * Pb;
                          values_E_dir = 0.001 * Pc;
                          values_E_dif = 0.001 * Pd;

                          if (is_undefined(valuesSUM_RAD)) {
                            valuesSUM_RAD = 0;
                            valuesSUM_EFF_P = 0;
                            valuesSUM_EFF_N = 0;
                            valuesNUM = 0;
                          } else {



                            float[] SunV = {
                              SunR[1], SunR[2], SunR[3]
                            };

                            float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
                            if (SunMask <= 0) SunMask = 0; // removes backing faces



                            float[] ray_start = subFace[s];
                            float[] ray_direction = {
                              SunR[1], SunR[2], SunR[3]
                            };

                            if (funcs.vec_dot(W, ray_direction) > 0) { // removes backing faces

                              if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) {
                                if (values_E_dir < 0) {
                                  valuesSUM_EFF_P += -(values_E_dir * SunMask);
                                  valuesSUM_EFF_N += -(values_E_dif * SkyMask);
                                } else {
                                  valuesSUM_EFF_N += (values_E_dir * SunMask);
                                  valuesSUM_EFF_P += (values_E_dif * SkyMask);
                                }

                                valuesSUM_RAD += (values_R_dif * SkyMask);
                              } else {
                                if (values_E_dir < 0) {
                                  valuesSUM_EFF_N += -((values_E_dir * SunMask) + (values_E_dif * SkyMask));
                                } else {
                                  valuesSUM_EFF_P += ((values_E_dir * SunMask) + (values_E_dif * SkyMask));
                                }

                                valuesSUM_RAD += ((values_R_dir * SunMask) + (values_R_dif * SkyMask)); // calculates total radiation
                              }
                            }
                            valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }
              }


              if (valuesNUM != 0) {
                //float valuesMUL = funcs.DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);
                //float valuesMUL = int(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                float valuesMUL = funcs.roundTo(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);

                valuesSUM_RAD *= valuesMUL;
                valuesSUM_EFF_P *= valuesMUL;
                valuesSUM_EFF_N *= valuesMUL;

                if (TOTALvaluesNUM == 0) {
                  TOTALvaluesSUM_RAD = 0;
                  TOTALvaluesSUM_EFF_P = 0;
                  TOTALvaluesSUM_EFF_N = 0;
                }

                TOTALvaluesSUM_RAD += valuesSUM_RAD;
                TOTALvaluesSUM_EFF_P += valuesSUM_EFF_P;
                TOTALvaluesSUM_EFF_N += valuesSUM_EFF_N;
                TOTALvaluesNUM += 1;
              } else {
                valuesSUM_RAD = FLOAT_undefined;
                valuesSUM_EFF_P = FLOAT_undefined;
                valuesSUM_EFF_N = FLOAT_undefined;
              }

              float AVERAGE, PERCENTAGE, COMPARISON;

              AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
              if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N));
              else PERCENTAGE = 0.0;
              COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

              //println("3D-Model >> valuesSUM_RAD:", valuesSUM_RAD, "|COMPARISON:", COMPARISON);

              float[] ADDvalues_RAD = {
                valuesSUM_RAD
              };
              VertexSolar_amounts[Impact_ACTIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][j + 1], ADDvalues_RAD);

              float[] ADDvalues_EFF = {
                COMPARISON
              };
              VertexSolar_amounts[Impact_PASSIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][j + 1], ADDvalues_EFF);

            }


            if (TOTALvaluesNUM != 0) {
              TOTALvaluesSUM_RAD /= 1.0 * TOTALvaluesNUM;
              TOTALvaluesSUM_EFF_P /= 1.0 * TOTALvaluesNUM;
              TOTALvaluesSUM_EFF_N /= 1.0 * TOTALvaluesNUM;
            } else {
              TOTALvaluesSUM_RAD = FLOAT_undefined;
              TOTALvaluesSUM_EFF_P = FLOAT_undefined;
              TOTALvaluesSUM_EFF_N = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (TOTALvaluesSUM_EFF_P - TOTALvaluesSUM_EFF_N);
            if ((TOTALvaluesSUM_EFF_P + TOTALvaluesSUM_EFF_N) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P - TOTALvaluesSUM_EFF_N) / (1.0 * (TOTALvaluesSUM_EFF_P + TOTALvaluesSUM_EFF_N));
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


            float valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) valuesSUM = TOTALvaluesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON;

            //println("3D-Model >> valuesSUM_RAD:", valuesSUM_RAD, "|COMPARISON:", COMPARISON);

            float[] ADDvalues_RAD = {
              TOTALvaluesSUM_RAD
            };
            VertexSolar_amounts[Impact_ACTIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][0], ADDvalues_RAD);

            float[] ADDvalues_EFF = {
              COMPARISON
            };
            VertexSolar_amounts[Impact_PASSIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][0], ADDvalues_EFF);

            float[][] ADD_values_XYZ = {
              {
                subFace[s][0], subFace[s][1], subFace[s][2]
              }
            };
            VertexSolar_XYZ = (float[][]) concat(VertexSolar_XYZ, ADD_values_XYZ);

          }

        }

      }
    }
  }

  cursor(ARROW);
}






float[] SOLARCHVISION_snap_Faces (float[] RxP) {

  if (RxP[0] >= 0) {

    int f = int(RxP[0]);
    float x = RxP[1];
    float y = RxP[2];
    float z = RxP[3];

    if (User3D.create_Snap == 1) { // nearest endpoint

      float nearest_D = FLOAT_undefined;
      float nearest_X = FLOAT_undefined;
      float nearest_Y = FLOAT_undefined;
      float nearest_Z = FLOAT_undefined;

      int mt = allFaces.getMaterial(f);

      int tessellation = allFaces.getTessellation(f);

      int totalNumberOfSubs = 1;
      if (allFaces.getMaterial(f) == 0) {
        tessellation += allFaces.displayTessellation;
      }
      if (tessellation > 0) totalNumberOfSubs = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }

      for (int n = 0; n < totalNumberOfSubs; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

        WIN3D.graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {

          float d = dist(x, y, z, subFace[s][0], subFace[s][1], subFace[s][2]);

          if (nearest_D > d) {
            nearest_D = d;
            nearest_X = subFace[s][0];
            nearest_Y = subFace[s][1];
            nearest_Z = subFace[s][2];
          }
        }
      }

      if (is_defined(nearest_D)) {
        RxP[1] = nearest_X;
        RxP[2] = nearest_Y;
        RxP[3] = nearest_Z;
      }
    }
  }

  return RxP;
}


int SOLARCHVISION_isIntersected_Faces (float[] ray_pnt, float[] ray_dir, int firstGuess) {

  float[] ray_normal = funcs.vec3_unit(ray_dir);

  int hit = 0;

  for (int q = 0; q < allFaces.nodes.length; q++) {

    int f = (q + firstGuess) % allFaces.nodes.length;

    if (f > 0) {

      int n = allFaces.nodes[f].length;

      if (n > 2) {

        int vsb = allFaces.getVisibility(f);

          if (vsb > 0) {

          float X_intersect = FLOAT_undefined;
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};

          boolean InPoly = false;

          if (n < 5) { // works if n==3 or n==4

            float[] A = allPoints.getPosition(allFaces.nodes[f][0]);
            float[] B = allPoints.getPosition(allFaces.nodes[f][1]);
            float[] C = allPoints.getPosition(allFaces.nodes[f][n - 2]);
            float[] D = allPoints.getPosition(allFaces.nodes[f][n - 1]);

            float[] AC = funcs.vec3_diff(A, C);
            float[] BD = funcs.vec3_diff(B, D);

            face_norm = funcs.vec3_cross(AC, BD);

            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] +
                                        (A[1] + B[1] + C[1] + D[1]) * face_norm[1] +
                                        (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);

            float R = -funcs.vec3_dot(ray_dir, face_norm);

            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {

                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                float[] P = {X_intersect, Y_intersect, Z_intersect};

                if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

              }
            }
          }
          else {

            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            };
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allPoints.getX(tmpFace[j]) / float(n);
              G[1] += allPoints.getY(tmpFace[j]) / float(n);
              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
            }

            for (int j = 0; j < n; j++) {

              int j_next = (j + 1) % n;

              float[] A = {
                allPoints.getX(allFaces.nodes[f][j]),
                allPoints.getY(allFaces.nodes[f][j]),
                allPoints.getZ(allFaces.nodes[f][j])
              };

              float[] B = {
                allPoints.getX(allFaces.nodes[f][j_next]),
                allPoints.getY(allFaces.nodes[f][j_next]),
                allPoints.getZ(allFaces.nodes[f][j_next])
              };

              float[] AG = funcs.vec3_diff(A, G);
              float[] BG = funcs.vec3_diff(B, G);

              face_norm = funcs.vec3_cross(AG, BG);

              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] +
                                                 (A[1] + B[1] + G[1]) * face_norm[1] +
                                                 (A[2] + B[2] + G[2]) * face_norm[2]);

              float R = -funcs.vec3_dot(ray_dir, face_norm);

              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;

                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {

                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

                  float[] P = {X_intersect, Y_intersect, Z_intersect};

                  InPoly = funcs.isInside_Triangle(P, A, B, G);

                }
              }

              if (InPoly) break;
            }
          }

          if (InPoly) {

            hit = f;

            break;
          }

        }

        if (hit != 0) break;
      }
    }
  }

  return hit;
}















float[][] skyVertices = new float [0][3];
int[][] skyFaces = new int [0][1];

int POINTER_TempObjectVertices = 0;
int POINTER_TempObjectFaces = 0;

float[][] TempObjectVertices = new float [0][3];
int[][] TempObjectFaces = new int [0][1];

float SOLARCHVISION_SolarAtSurface (float SunR1, float SunR2, float SunR3, float SunR4, float SunR5, float Alpha, float Beta, float THE_ALBEDO) {

  float return_value = FLOAT_undefined;

  if (is_defined(SunR1) &&
      is_defined(SunR2) &&
      is_defined(SunR3) &&
      is_defined(SunR4) &&
      is_defined(SunR5)) {

    float[] VECT = {
      0, 0, 0
    };

    if (abs(Alpha) > 89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = 1;
    } else if (Alpha < -89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = -1;
    } else {
      VECT[0] = funcs.sin_ang(Beta);
      VECT[1] = -funcs.cos_ang(Beta);
      VECT[2] = funcs.tan_ang(Alpha);
    }

    VECT = funcs.vec3_unit(VECT);


    float[] SunV = {
      SunR1, SunR2, SunR3
    };

    float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
    if (SunMask <= 0) SunMask = 0; // removes backing faces

    float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));

    return_value = (SunR4 * SunMask) + (SunR5 * SkyMask);


    /*
    float[] REF_SunV = {SunR1, SunR2, -SunR3};

     float REF_SunMask = funcs.vec_dot(funcs.vec3_unit(REF_SunV), funcs.vec3_unit(VECT));
     if (REF_SunMask <= 0) REF_SunMask = 0; // removes backing faces

     float REF_SkyMask = 1 - (0.5 * (1.0 + (Alpha / 90.0)));

     return_value +=  (0.01 * THE_ALBEDO) * ((SunR4 * REF_SunMask) + (SunR5 * REF_SkyMask));
     */
  }

  return (return_value);
}












void GlobalSolar_resize_array () {

  Sky3D.stp_slp = Sky3D.calculatedResolution;
  Sky3D.stp_dir = Sky3D.calculatedResolution;
  Sky3D.num_slp = int(funcs.roundTo(180.0 / (1.0 * Sky3D.stp_slp), 1)) + 1;
  Sky3D.num_dir = int(funcs.roundTo(360.0 / (1.0 * Sky3D.stp_dir), 1));

  GlobalSolar = new float [2][(1 + STUDY.j_End - STUDY.j_Start)][Sky3D.num_slp][Sky3D.num_dir];

  for (int i = 0; i < GlobalSolar.length; i++) {
    for (int j = 0; j < GlobalSolar[i].length; j++) {

      for (int a = 0; a < Sky3D.num_slp; a++) {
        for (int b = 0; b < Sky3D.num_dir; b++) {
          GlobalSolar[i][j][a][b] = FLOAT_undefined;
        }
      }
    }
  }

  GlobalSolar_rebuild_array = false;
}


void SOLARCHVISION_calculate_GlobalSolar_array () {

  cursor(WAIT);

  if (GlobalSolar_rebuild_array) {
    GlobalSolar_resize_array();
  }

  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
      (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0];
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k;
  if (count_k < 0) count_k = 0;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int l = STUDY.ImpactLayer;

  float[][] TOTALvaluesSUM_RAD = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  float[][] TOTALvaluesSUM_EFF_P = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  float[][] TOTALvaluesSUM_EFF_N = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  int[][] TOTALvaluesNUM = new int [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];

  for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) {
    for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
      TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
      TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
      TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
      TOTALvaluesNUM[a][b] = 0;
    }
  }

  for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

    now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

    if (now_j >= 365) {
      now_j = now_j % 365;
    }
    if (now_j < 0) {
      now_j = (now_j + 365) % 365;
    }

    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);

    int[] Normals_COL_N;
    Normals_COL_N = new int [9];
    Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

    for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
      if (nk != -1) {
        int k = int(nk / STUDY.joinDays);
        int j_ADD = nk % STUDY.joinDays;

        for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) {
          float Alpha = a * Sky3D.stp_slp - 90;
          for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
            float Beta = b * Sky3D.stp_dir;

            float valuesSUM_RAD = 0;
            float valuesSUM_EFF_P = 0;
            float valuesSUM_EFF_N = 0;
            int valuesNUM = 0;

            for (int i = 0; i < 24; i++) {
              if (STUDY.isInHourlyRange(i)) {

                float HOUR_ANGLE = i;
                float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

                  if (is_undefined(Pa) || is_undefined(Pb) || is_undefined(Pc) || is_undefined(Pd)) {
                    values_R_dir = FLOAT_undefined;
                    values_R_dif = FLOAT_undefined;
                    values_E_dir = FLOAT_undefined;
                    values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);

                    if (memberCount == 1) {
                      values_R_dir = 0.001 * Pa;
                      values_R_dif = 0.001 * Pb;
                      values_E_dir = 0.001 * Pc;
                      values_E_dif = 0.001 * Pd;

                      if (is_undefined(valuesSUM_RAD)) {
                        valuesSUM_RAD = 0;
                        valuesSUM_EFF_P = 0;
                        valuesSUM_EFF_N = 0;
                        valuesNUM = 0;
                      } else {

                        if (values_E_dir < 0) {
                          valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                        } else {
                          valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                        }

                        valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_R_dir, values_R_dif, Alpha, Beta, GlobalAlbedo);

                        valuesNUM += 1;
                      }
                    }
                  }
                }
              }
            }


            if (valuesNUM != 0) {
              //float valuesMUL = funcs.DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);
              //float valuesMUL = int(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
              float valuesMUL = funcs.roundTo(funcs.DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);

              valuesSUM_RAD *= valuesMUL;
              valuesSUM_EFF_P *= valuesMUL;
              valuesSUM_EFF_N *= valuesMUL;

              if (TOTALvaluesNUM[a][b] == 0) {
                TOTALvaluesSUM_RAD[a][b] = 0;
                TOTALvaluesSUM_EFF_P[a][b] = 0;
                TOTALvaluesSUM_EFF_N[a][b] = 0;
              }

              TOTALvaluesSUM_RAD[a][b] += valuesSUM_RAD;
              TOTALvaluesSUM_EFF_P[a][b] += valuesSUM_EFF_P;
              TOTALvaluesSUM_EFF_N[a][b] += valuesSUM_EFF_N;
              TOTALvaluesNUM[a][b] += 1;
            } else {
              valuesSUM_RAD = FLOAT_undefined;
              valuesSUM_EFF_P = FLOAT_undefined;
              valuesSUM_EFF_N = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
            if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N));
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

            if (is_defined(valuesSUM_RAD)) {
              GlobalSolar[Impact_ACTIVE][j + 1][a][b] = valuesSUM_RAD;
            }
            if (is_defined(COMPARISON)) {
              GlobalSolar[Impact_PASSIVE][j + 1][a][b] = COMPARISON;
            }
          }
        }
      }
    }
  }



  for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) {
    float Alpha = a * Sky3D.stp_slp - 90;
    for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
      float Beta = b * Sky3D.stp_dir;

      if (TOTALvaluesNUM[a][b] != 0) {
        TOTALvaluesSUM_RAD[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
        TOTALvaluesSUM_EFF_P[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
        TOTALvaluesSUM_EFF_N[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
      } else {
        TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
        TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
        TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
      }

      float AVERAGE, PERCENTAGE, COMPARISON;

      AVERAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]);
      if ((TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]) / (1.0 * (TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]));
      else PERCENTAGE = 0.0;
      COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

      if (is_defined(TOTALvaluesSUM_RAD[a][b])) {
        GlobalSolar[Impact_ACTIVE][0][a][b] = TOTALvaluesSUM_RAD[a][b];
      }
      if (is_defined(COMPARISON)) {
        GlobalSolar[Impact_PASSIVE][0][a][b] = COMPARISON;
      }

    }
  }


  keep_STUDY_perDays = STUDY.perDays;
  STUDY.joinDays = keep_STUDY_joinDays;

  cursor(ARROW);
}


void SOLARCHVISION_draw_logo (float cx, float cy, float cz, float cr, int the_view, int pass) {

  float stp_u = 1.0 / 24.0;
  float stp_v = 1.0 / 24.0;

  int n_a = 1;

  int aI = 0;
  for (float a = -1; a < 1; a += stp_u) {
    aI++;

    n_a *= -1;

    int n_b = n_a;

    int bI = 0;
    for (float b = -1; b < 1; b += stp_v) {
      bI++;

      n_b *= -1;

      float[][] newQuad = {
        {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
      };

      for (int i = 0; i < 4; i++) {

        float u = a;
        float v = b;

        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        //---------------------------------------
        float x0 = cos(u * PI);
        float y0 = -sin(u * PI) * cos(v * PI);
        float z0 = sin(v * PI);

        float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
        x0 /= d;
        y0 /= d;
        z0 /= d;

        float x = x0;
        float y = y0;
        float z = z0;

        if (the_view == 0) { // corner view: logo
          float t = -0.25 * PI;
          newQuad[i][0] = x0 * cos(t) - z0 * sin(t);
          newQuad[i][1] = y0;
          newQuad[i][2] = x0 * sin(t) + z0 * cos(t);
        } else if (the_view == 1) { // front view
          newQuad[i][0] = x0;
          newQuad[i][1] = y0;
          newQuad[i][2] = z0;
        } else if (the_view == -1) { // top view
          newQuad[i][0] = x0;
          newQuad[i][1] = z0;
          newQuad[i][2] = y0;
        }
      }

      float x1 = cr * newQuad[0][0] + cx;
      float y1 = cr * newQuad[0][1] + cy;
      float z1 = cr * newQuad[0][2] + cz;

      float x2 = cr * newQuad[1][0] + cx;
      float y2 = cr * newQuad[1][1] + cy;
      float z2 = cr * newQuad[1][2] + cz;

      float x3 = cr * newQuad[2][0] + cx;
      float y3 = cr * newQuad[2][1] + cy;
      float z3 = cr * newQuad[2][2] + cz;

      float x4 = cr * newQuad[3][0] + cx;
      float y4 = cr * newQuad[3][1] + cy;
      float z4 = cr * newQuad[3][2] + cz;

      strokeWeight(1);
      stroke(127);
      noFill();

      int q = 0;

      if(pass == 2) {
        if((aI == bI + 2) || (aI == bI + 3) || (aI == bI + 4)) {
          if(aI == bI + 2) q = 1;
          if(aI == bI + 4) q = 2;

          strokeWeight(2);
          stroke(255);
          fill(255,191,127);

          if(
            (aI == 47 && bI == 45) ||
            (aI == 48 && bI == 44) ||
            (aI == 40 && bI == 38) ||
            (aI == 41 && bI == 37)
          ) {
            fill(0);
          }
        } else if((aI + bI == 43) || (aI + bI == 44) || (aI + bI == 45)) {
          if(aI + bI == 43) q = 4;
          if(aI + bI == 45) q = 3;

          strokeWeight(2);
          stroke(255);
          fill(0);
        } else {
          continue;
        }
      }

      if(q == 0) {
        if (n_a * n_b == 1) {
          triangle(x1, y1, x2, y2, x3, y3);
          triangle(x3, y3, x4, y4, x1, y1);
        } else {
          triangle(x4, y4, x1, y1, x2, y2);
          triangle(x2, y2, x3, y3, x4, y4);
        }
      } else {
        if(q == 1) triangle(x1, y1, x2, y2, x3, y3);
        if(q == 2) triangle(x3, y3, x4, y4, x1, y1);
        if(q == 3) triangle(x4, y4, x1, y1, x2, y2);
        if(q == 4) triangle(x2, y2, x3, y3, x4, y4);
      }
    }
  }
}













int mouseWheelConsume = 0;

void mouseWheel (MouseEvent event) {

  if (frameCount > Last_initializationStep) {

    if (UI_menuBar.selected_parent == -1) {

      mouseWheelConsume += 1;
      if (mouseWheelConsume % 2 == 0) {
        mouseWheelConsume = 0;

        float Wheel_Value = event.getCount();

        if (SOLARCHVISION_automated == 0) {
          SOLARCHVISION_X_clicked = mouseX;
          SOLARCHVISION_Y_clicked = mouseY;

          {
            float displayBarHeight = MessageSize;
            float displayBarWidth = 2 * SOLARCHVISION_pixel_W;

            STUDY.X_control = 0.5 * displayBarWidth;
            STUDY.Y_control = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + 0.5 * UI_timeBar.tab;

            for (int i = 0; i < UI_timeBar.Items.length; i++) {

              float x1 = STUDY.X_control - 0.366 * displayBarWidth;
              float x2 = STUDY.X_control + 0.5 * displayBarWidth;
              float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
              float y2 = STUDY.Y_control + 0.45 * displayBarHeight;

              if (UI_timeBar.Items[i][0].equals("Hours")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

                  int keep_STUDY_i_Start = STUDY.i_Start;
                  int keep_STUDY_i_End = STUDY.i_End;

                  if (Wheel_Value > 0) {
                    STUDY.i_Start += 1;
                    STUDY.i_End += 1;
                  }
                  if (Wheel_Value < 0) {
                    STUDY.i_Start -= 1;
                    STUDY.i_End -= 1;
                  }

                  if (STUDY.i_Start < 0) STUDY.i_Start = 23;
                  if (STUDY.i_Start > 23) STUDY.i_Start = 0;
                  if (STUDY.i_End < 0) STUDY.i_End = 23;
                  if (STUDY.i_End > 23) STUDY.i_End = 0;

                  if ((keep_STUDY_i_Start != STUDY.i_Start) ||
                      (keep_STUDY_i_End != STUDY.i_End)) {

                    ROLLOUT.revise();
                    STUDY.revise();
                    WORLD.revise();
                    UI_timeBar.revise();
                    SOLARCHVISION_view_changed();

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_timeBar.Items[i][0].equals("Days")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

                  int keep_STUDY_joinDays = STUDY.joinDays;

                  if (Wheel_Value > 0) STUDY.joinDays += 2;
                  if (Wheel_Value < 0) STUDY.joinDays -= 2;

                  if (STUDY.joinDays > 365 / STUDY.j_End) STUDY.joinDays = 365 / STUDY.j_End;
                  if (STUDY.joinDays < 1) STUDY.joinDays = 1;

                  if (keep_STUDY_joinDays != STUDY.joinDays) {

                    ROLLOUT.revise();
                    STUDY.revise();
                    UI_timeBar.revise();
                    SOLARCHVISION_view_changed();

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_timeBar.Items[i][0].equals("Scenario")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1;
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1;
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CWEEDS_start) SampleYear_Start = CLIMATE_CWEEDS_start;
                    if (SampleYear_Start > CLIMATE_CWEEDS_end) SampleYear_Start = CLIMATE_CWEEDS_end;
                    if (SampleYear_End < CLIMATE_CWEEDS_start) SampleYear_End = CLIMATE_CWEEDS_start;
                    if (SampleYear_End > CLIMATE_CWEEDS_end) SampleYear_End = CLIMATE_CWEEDS_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) ||
                        (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.revise();
                      STUDY.revise();
                      UI_timeBar.revise();
                      SOLARCHVISION_view_changed();

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }

                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1;
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1;
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CLMREC_start) SampleYear_Start = CLIMATE_CLMREC_start;
                    if (SampleYear_Start > CLIMATE_CLMREC_end) SampleYear_Start = CLIMATE_CLMREC_end;
                    if (SampleYear_End < CLIMATE_CLMREC_start) SampleYear_End = CLIMATE_CLMREC_start;
                    if (SampleYear_End > CLIMATE_CLMREC_end) SampleYear_End = CLIMATE_CLMREC_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) ||
                        (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.revise();
                      STUDY.revise();
                      UI_timeBar.revise();
                      SOLARCHVISION_view_changed();

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    int keep_SampleMember_Start = SampleMember_Start;
                    int keep_SampleMember_End = SampleMember_End;

                    if (Wheel_Value > 0) {
                      SampleMember_Start += 1;
                      SampleMember_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleMember_Start -= 1;
                      SampleMember_End -= 1;
                    }

                    if (SampleMember_End < SampleMember_Start) SampleMember_End = SampleMember_Start;
                    if (SampleMember_Start > SampleMember_End) SampleMember_Start = SampleMember_End;

                    if (SampleMember_Start < ENSEMBLE_FORECAST_start) SampleMember_Start = ENSEMBLE_FORECAST_start;
                    if (SampleMember_Start > ENSEMBLE_FORECAST_end) SampleMember_Start = ENSEMBLE_FORECAST_end;
                    if (SampleMember_End < ENSEMBLE_FORECAST_start) SampleMember_End = ENSEMBLE_FORECAST_start;
                    if (SampleMember_End > ENSEMBLE_FORECAST_end) SampleMember_End = ENSEMBLE_FORECAST_end;

                    if ((keep_SampleMember_Start != SampleMember_Start) ||
                        (keep_SampleMember_End != SampleMember_End)) {

                      ROLLOUT.revise();
                      STUDY.revise();
                      UI_timeBar.revise();
                      SOLARCHVISION_view_changed();

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }

                  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                    int keep_SampleStation_Start = SampleStation_Start;
                    int keep_SampleStation_End = SampleStation_End;

                    if (Wheel_Value > 0) {
                      SampleStation_Start += 1;
                      SampleStation_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleStation_Start -= 1;
                      SampleStation_End -= 1;
                    }

                    if (SampleStation_End < SampleStation_Start) SampleStation_End = SampleStation_Start;
                    if (SampleStation_Start > SampleStation_End) SampleStation_Start = SampleStation_End;

                    if (SampleStation_Start < ENSEMBLE_OBSERVED_start) SampleStation_Start = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_Start > ENSEMBLE_OBSERVED_end) SampleStation_Start = ENSEMBLE_OBSERVED_end;
                    if (SampleStation_End < ENSEMBLE_OBSERVED_start) SampleStation_End = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_End > ENSEMBLE_OBSERVED_end) SampleStation_End = ENSEMBLE_OBSERVED_end;

                    if ((keep_SampleStation_Start != SampleStation_Start) ||
                        (keep_SampleStation_End != SampleStation_End)) {

                      ROLLOUT.revise();
                      STUDY.revise();
                      UI_timeBar.revise();
                      SOLARCHVISION_view_changed();

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }
                }
              }


              STUDY.Y_control += UI_timeBar.tab;
            }
          }


          if (WORLD.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY)) {

              int keep_WORLD_Zoom = WORLD.Zoom;

              if (Wheel_Value < 0) WORLD.Zoom += 1;
              if (Wheel_Value > 0) WORLD.Zoom -= 1;

              if (WORLD.Zoom < 1) WORLD.Zoom = 1;
              if (WORLD.Zoom > 6) WORLD.Zoom = 6;

              if (keep_WORLD_Zoom != WORLD.Zoom) {
                WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

                WORLD.revise();
              }
            }
          }

          if (WIN3D.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY)) {

              float[] P = Select3D.getPivot();

              float x0 = P[0];
              float y0 = P[1];
              float z0 = P[2];


              if (WIN3D.UI_CurrentTask == UITASK.Rotate) { // rotate

                float r = 5 * Wheel_Value;

                int the_Vector = Select3D.rotVector;

                Rotate3D.selection(x0, y0, z0, r, the_Vector);

                SOLARCHVISION_model_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.Scale) { // scale

                float s = pow(pow(2.0, 0.25), Wheel_Value);

                float sx = s;
                float sy = s;
                float sz = s;

                int the_Vector = Select3D.scaleVector;

                if (the_Vector == 0) {
                  sy = 1;
                  sz = 1;
                }
                if (the_Vector == 1) {
                  sz = 1;
                  sx = 1;
                }
                if (the_Vector == 2) {
                  sx = 1;
                  sy = 1;
                }

                Scale3D.selection(x0, y0, z0, sx, sy, sz);

                SOLARCHVISION_model_changed();
              }


              if (WIN3D.UI_CurrentTask == UITASK.Move) { // move

                float d = Wheel_Value;

                float dx = d;
                float dy = d;
                float dz = d;

                int the_Vector = Select3D.posVector;

                if (the_Vector == 0) {
                  dy = 0;
                  dz = 0;
                }
                if (the_Vector == 1) {
                  dz = 0;
                  dx = 0;
                }
                if (the_Vector == 2) {
                  dx = 0;
                  dy = 0;
                }

                Move3D.selection(dx, dy, dz);

                SOLARCHVISION_model_changed();
              }



              if (WIN3D.UI_TaskModifyParameter == 0) {
                if (WIN3D.UI_CurrentTask >= UITASK.Seed_Material) { // other properties

                  int p = int(Wheel_Value);

                  Edit3D.selection(p);

                  SOLARCHVISION_model_changed();
                }
              }





              if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) ||
                  (WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) ||
                  (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) ||
                  (WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll)) { // viewport:zoom

                if (WIN3D.ViewType == 1) {
                  WIN3D.position_Z -= Wheel_Value * WIN3D.position_T * OBJECTS_scale;
                } else {
                  WIN3D.Zoom *= pow(2.0, Wheel_Value);
                }

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) { // viewport:elevation

                if (Wheel_Value > 0) WIN3D.Zoom = 2 * funcs.atan_ang((1.1 / 1.0) * funcs.tan_ang(0.5 * WIN3D.Zoom));
                if (Wheel_Value < 0) WIN3D.Zoom = 2 * funcs.atan_ang((1.0 / 1.1) * funcs.tan_ang(0.5 * WIN3D.Zoom));

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport:3DModelSize

                if (Wheel_Value > 0) OBJECTS_scale /= pow(2.0, 0.25);
                if (Wheel_Value < 0) OBJECTS_scale *= pow(2.0, 0.25);

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.position_X += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                    SOLARCHVISION_view_changed();
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.position_Y += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                    SOLARCHVISION_view_changed();
                  }
                }


                if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.rotation_X += Wheel_Value * WIN3D.rotation_T;

                    SOLARCHVISION_view_changed();
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.rotation_Z += Wheel_Value * WIN3D.rotation_T;

                    SOLARCHVISION_view_changed();
                  }
                }

              }


              if (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // SkydomeSize

                  if (Wheel_Value > 0) Sky3D.scale *= pow(2.0, 0.25);
                  if (Wheel_Value < 0) Sky3D.scale /= pow(2.0, 0.25);

                  SOLARCHVISION_view_changed();
                }
              }

              if (WIN3D.UI_CurrentTask == UITASK.AllModelSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // AllModelSize

                  if (Wheel_Value > 0) {
                    OBJECTS_scale /= pow(2.0, 0.25);
                    Sky3D.scale /= pow(2.0, 0.25);
                  }

                  if (Wheel_Value < 0) {
                    OBJECTS_scale *= pow(2.0, 0.25);
                    Sky3D.scale *= pow(2.0, 0.25);
                  }

                  SOLARCHVISION_view_changed();
                }
              }

              if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport:TargetRollXY/TargetRoolZ

                if (WIN3D.UI_OptionXorY == 0) {
                  WIN3D.rotation_X += Wheel_Value * WIN3D.rotation_T;

                  WIN3D.reverseTransform_3DViewport();
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  WIN3D.rotation_Z += Wheel_Value * WIN3D.rotation_T;

                  WIN3D.reverseTransform_3DViewport();
                }

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport:CameraRollXY/CameraRoolZ

                if (WIN3D.UI_OptionXorY == 0) {

                  WIN3D.rotateZ_3DViewport_around_Selection(Wheel_Value * WIN3D.rotation_T);
                }

                if (WIN3D.UI_OptionXorY == 1) {

                  WIN3D.rotateXY_3DViewport_around_Selection(Wheel_Value * WIN3D.rotation_T);
                }

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ) { // viewport:CameraDistance

                WIN3D.move_3DViewport_towards_Selection(pow(2, 0.5 * Wheel_Value));

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) { // viewport:PanX

                WIN3D.position_X += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ) { // viewport:PanY

                WIN3D.position_Y += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }

              if ((WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) ||
                  (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport:DistMouseXY

                WIN3D.move_3DViewport_towards_Mouse(pow(2, 0.5 * Wheel_Value));

                SOLARCHVISION_view_changed();
              }

              if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport:LandOrbit

                WIN3D.move_3DViewport_towards_Mouse(pow(2, 0.5 * Wheel_Value));

                SOLARCHVISION_view_changed();
              }



            }
          }
        }
      }
    }
  }
}


int dragging_started = 0;

void mouseReleased () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (dragging_started != 0) {

        SOLARCHVISION_X_click2 = mouseX;
        SOLARCHVISION_Y_click2 = mouseY;

        int swap_tmp = 0;

        if (SOLARCHVISION_X_click2 < SOLARCHVISION_X_click1) {
          swap_tmp = SOLARCHVISION_X_click2;
          SOLARCHVISION_X_click2 = SOLARCHVISION_X_click1;
          SOLARCHVISION_X_click1 = swap_tmp;
        }

        if (SOLARCHVISION_Y_click2 < SOLARCHVISION_Y_click1) {
          swap_tmp = SOLARCHVISION_Y_click2;
          SOLARCHVISION_Y_click2 = SOLARCHVISION_Y_click1;
          SOLARCHVISION_Y_click1 = swap_tmp;
        }

        if (FRAME_drag_IMG) {

          SOLARCHVISION_RecordFrame();

          strokeWeight(2);
          if (mouseButton == RIGHT) {
            noStroke();
            fill(127, 127);
          } else {
            stroke(255, 0, 0);
            noFill();
          }

          rect(SOLARCHVISION_X_click1, SOLARCHVISION_Y_click1, SOLARCHVISION_X_click2 - SOLARCHVISION_X_click1, SOLARCHVISION_Y_click2 - SOLARCHVISION_Y_click1);
          strokeWeight(0);

          SOLARCHVISION_RecordFrame();

          SOLARCHVISION_view_changed();
          WORLD.revise();
          STUDY.revise();
          ROLLOUT.revise();
          UI_menuBar.revise();
          UI_toolBar.revise();
          UI_timeBar.revise();

          FRAME_drag_IMG = false;

          dragging_started = 0;
        } else {

          if (WIN3D.include) {
            if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY)) {

              if ((WIN3D.UI_CurrentTask == UITASK.RectSelect) ||
                  (WIN3D.UI_CurrentTask > UITASK.Move)) { // RectSelect also if scale, rotate, modify, etc. where selected

                float corner1x = SOLARCHVISION_X_click1 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner1y = SOLARCHVISION_Y_click1 - 0.5 * WIN3D.dY - WIN3D.cY;

                float corner2x = SOLARCHVISION_X_click2 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner2y = SOLARCHVISION_Y_click2 - 0.5 * WIN3D.dY - WIN3D.cY;

                pushMatrix();

                translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

                noFill();

                stroke(127);
                strokeWeight(2);

                rect(corner1x, corner1y, corner2x - corner1x, corner2y - corner1y);

                popMatrix();

                Select3D.selectRect(corner1x, corner1y, corner2x, corner2y);
              }


              if (WIN3D.UI_CurrentTask == UITASK.GetLength) {

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                for (int q = 0; q < 2; q++) {

                  float Image_X = 0;
                  float Image_Y = 0;

                  if (q == 0) {
                    Image_X = SOLARCHVISION_X_click1 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click1 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }
                  if (q == 1) {
                    Image_X = SOLARCHVISION_X_click2 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click2 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }

                  float[] ray_direction = new float [3];

                  float[] ray_start = {
                    WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
                  };

                  float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

                  ray_start[0] /= OBJECTS_scale;
                  ray_start[1] /= OBJECTS_scale;
                  ray_start[2] /= OBJECTS_scale;

                  ray_end[0] /= OBJECTS_scale;
                  ray_end[1] /= OBJECTS_scale;
                  ray_end[2] /= OBJECTS_scale;

                  if (WIN3D.ViewType == 0) {
                    float[] ray_center = WIN3D.calculate_Click3D(0, 0);

                    ray_center[0] /= OBJECTS_scale;
                    ray_center[1] /= OBJECTS_scale;
                    ray_center[2] /= OBJECTS_scale;

                    ray_start[0] += ray_end[0] - ray_center[0];
                    ray_start[1] += ray_end[1] - ray_center[1];
                    ray_start[2] += ray_end[2] - ray_center[2];
                  }

                  ray_direction[0] = ray_end[0] - ray_start[0];
                  ray_direction[1] = ray_end[1] - ray_start[1];
                  ray_direction[2] = ray_end[2] - ray_start[2];

                  float[] RxP = new float [8];

                  if (mouseButton == RIGHT) {
                    RxP = Land3D.intersect(ray_start, ray_direction);
                  } else if (mouseButton == LEFT) {
                    RxP = SOLARCHVISION_snap_Faces(allFaces.intersect(ray_start, ray_direction));
                  }

                  if (RxP[0] >= 0) {
                    if (q == 0) {
                      x1 = RxP[1];
                      y1 = RxP[2];
                      z1 = RxP[3];
                    }
                    if (q == 1) {
                      x2 = RxP[1];
                      y2 = RxP[2];
                      z2 = RxP[3];
                    }
                  }
                }

                float dx = x2 - x1;
                float dy = y2 - y1;
                float dz = z2 - z1;

                float dx_rot = dx * funcs.cos_ang(-WIN3D.rotation_Z) - dy * funcs.sin_ang(-WIN3D.rotation_Z);
                float dy_rot = dx * funcs.sin_ang(-WIN3D.rotation_Z) + dy * funcs.cos_ang(-WIN3D.rotation_Z);
                float dz_rot = dz;

                if (WIN3D.UI_TaskModifyParameter == 0) {
                  User3D.create_Length = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 1) {
                  User3D.create_Width = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 2) {
                  User3D.create_Height = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 3) {
                  User3D.create_Length = abs(dx_rot);
                  User3D.create_Width = abs(dy_rot);
                  User3D.create_Height = abs(dz_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 4) {
                  User3D.create_Length = abs(dx_rot);
                  User3D.create_Width = abs(dy_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 5) {
                  User3D.create_Orientation = funcs.atan2_ang(y2 - y1, x2 - x1) + 90;
                }

                ROLLOUT.revise();
              }
            }
          }

          dragging_started = 0;
        }
      }
    }
  }
}

void mouseDragged () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_drag_IMG) {
        if (dragging_started == 0) {
          SOLARCHVISION_X_click1 = pmouseX;
          SOLARCHVISION_Y_click1 = pmouseY;

          dragging_started = 1;
        }
      } else if (WIN3D.include) {
        if (isInside(pmouseX, pmouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY)) {
          if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY)) {

            if (dragging_started == 0) {

              SOLARCHVISION_X_click1 = pmouseX;
              SOLARCHVISION_Y_click1 = pmouseY;

              dragging_started = 1;
            }

            float dx = (mouseX - pmouseX) / float(WIN3D.dX);
            float dy = (mouseY - pmouseY) / float(WIN3D.dY);

            if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraLandOrbit

                WIN3D.rotateXY_3DViewport_around_LandIntersection(10 * dx * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }
            }

            if ((WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) ||
                (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }
            }

            if ((WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll) ||
                (WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) ||
                (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T;
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport();

                SOLARCHVISION_view_changed();
              }
            }

            if ((WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) ||
                (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRoll

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) { // viewport

              if (mouseButton == LEFT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T;
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport();

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // TargetRollXY

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport();

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // TargetRollZ

                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport();

                SOLARCHVISION_view_changed();
              }
            }

            if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) ||
                (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) ||
                (WIN3D.UI_CurrentTask == UITASK.AllModelSize)) { // viewport

              if (mouseButton == LEFT) { // orbit

                WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T;
                WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) {

              if (mouseButton == LEFT) { // move Y

                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // move X

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                SOLARCHVISION_view_changed();
              }

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T;
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport();

                SOLARCHVISION_view_changed();
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions

              if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                  if (mouseButton == RIGHT) WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                  SOLARCHVISION_view_changed();
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;
                  if (mouseButton == LEFT) WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;

                  SOLARCHVISION_view_changed();
                }
              }


              if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;
                  if (mouseButton == RIGHT) WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T;

                  SOLARCHVISION_view_changed();
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;
                  if (mouseButton == LEFT) WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T;

                  SOLARCHVISION_view_changed();
                }
              }


            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_update_project_info (File selectedFile) {

  ProjectName = selectedFile.getName().replace(".xml", "").replace(".XML", ""); // should work most of the times!
  Folder_Project =  selectedFile.getAbsolutePath().replace(char(92), '/').replace("/" + selectedFile.getName(), "");

  println("New ProjectName:", ProjectName);
  println("New Folder_Project:", Folder_Project);
}

void SOLARCHVISION_fileSelected_New (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("New project:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
}

void SOLARCHVISION_fileSelected_Open (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Loading:", Filename);

    SOLARCHVISION_load_project(Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
}


void SOLARCHVISION_fileSelected_SaveAs (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Saving to:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);

    SOLARCHVISION_save_project(Filename);
  }
}



void SOLARCHVISION_SelectFile_Import_3DModel (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');


    if (allGroups.num == 0) {
      allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }


    println("Importing:", Filename);

    int number_of_allGroups_before = allGroups.num;

    //SOLARCHVISION_import_objects_OBJ(Filename, -1,0,0,1,0,0, 0,0,0, 1,1,1); // different objects: different materials
    SOLARCHVISION_import_objects_OBJ(Filename, User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, 0, 0, 0, 1, 1, 1); // apply default material

    int number_of_allGroups_after = allGroups.num;

    Select3D.Group_ids = new int [1 + number_of_allGroups_after - number_of_allGroups_before];
    for (int i = 0; i < Select3D.Group_ids.length - 1; i++) {
      Select3D.Group_ids[i] = i + number_of_allGroups_before;
      //println(Select3D.Group_ids[i]);
    }

    SOLARCHVISION_switch_category(ObjectCategory.GROUP);
  }
}


void SOLARCHVISION_SelectFile_Execute_CommandFile (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Executing:", Filename);

    SOLARCHVISION_execute_commands_TXT(Filename);
  }
}


void mouseClicked () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_click_IMG) {

        SOLARCHVISION_RecordFrame();

        UI_toolBar.drawMouse(1, mouseX, mouseY, 2 * MessageSize);

        SOLARCHVISION_RecordFrame();
      }


      if ((UI_menuBar.selected_parent != -1) && (isInside(mouseX, mouseY, 0, 0, width, SOLARCHVISION_pixel_A) == false)) {

        String menu_option = UI_menuBar.Items[UI_menuBar.selected_parent][UI_menuBar.selected_child];

        if (mouseButton == LEFT) {
          if (UI_menuBar.selected_child != 0) {

            // should call the functions here!

            if (menu_option.equals("Mojtaba Samimi")) {
              link("https://solarchvision.com/?page_id=102");
            }

            if (menu_option.equals("www.solarchvision.com")) {
              link("https://solarchvision.com/");
            }

            if (menu_option.equals("New")) {

              /////////////////////////////
              SOLARCHVISION_hold_project();
              /////////////////////////////

              selectInput("Specify project name:", "SOLARCHVISION_fileSelected_New");

              SOLARCHVISION_deleteAll();

              //SOLARCHVISION_update_station(0);
            }

            if (menu_option.equals("Save")) {
              SOLARCHVISION_save_project(Folder_Project + "/" + ProjectName + ".xml");
            }

            if (menu_option.equals("Hold")) {

              SOLARCHVISION_hold_project();
            }

            if (menu_option.equals("Fetch")) {

              SOLARCHVISION_fetch_project();
            }

            if (menu_option.equals("Open...")) {
              selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
            }

            if (menu_option.equals("Save As...")) {
              selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
            }

            if (menu_option.equals("Import 3D-model...")) {
              selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
            }

            if (menu_option.equals("Import Command File...")) {
              selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
            }

            if (menu_option.equals("Export 3D-model > OBJ (time-series)")) {
              SOLARCHVISION_export_objects_OBJ_timeSeries();
            }


            if (menu_option.equals("Export 3D-model > OBJ (date-series)")) {
              SOLARCHVISION_export_objects_OBJ_dateSeries();
            }

            if (menu_option.equals("Export 3D-model > OBJ")) {
              SOLARCHVISION_export_objects_OBJ("");
            }

            if (menu_option.equals("Export 3D-model > HTML")) {
              SOLARCHVISION_export_objects_HTML();
            }

            if (menu_option.equals("Export 3D-model > RAD")) {
              SOLARCHVISION_export_objects_RAD();
            }

            if (menu_option.equals("Export 3D-model > SCR")) {
              SOLARCHVISION_export_objects_SCR();
            }

            if (menu_option.equals("Quit")) {
              exit();
            }



            if (menu_option.equals("Wind pattern (active)")) {
              STUDY.PlotImpacts = PlotImpacts_WIND_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = true;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Wind pattern (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_WIND_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = true;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Urban solar potential (active)")) {
              STUDY.PlotImpacts = PlotImpacts_URBAN_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Urban solar potential (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_URBAN_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Orientation potential (active)")) {
              STUDY.PlotImpacts = PlotImpacts_GLOBAL_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Orientation potential (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_GLOBAL_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Hourly sun position (active)")) {
              STUDY.PlotImpacts = PlotImpacts_SUNPATH_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Hourly sun position (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_SUNPATH_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("View from sun & sky (active)")) {
              STUDY.PlotImpacts = PlotImpacts_FROMSUN_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("View from sun & sky (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_FROMSUN_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Annual cycle sun path (active)")) {
              STUDY.PlotImpacts = PlotImpacts_CYCLES_ACTIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }
            if (menu_option.equals("Annual cycle sun path (passive)")) {
              STUDY.PlotImpacts = PlotImpacts_CYCLES_PASSIVE;
              STUDY.plotSetup = 0;
              STUDY.revise();
              allWindRoses.displayImage = false;
              ROLLOUT.revise();
            }

            if (menu_option.equals("Pre-bake Selected Sections")) {
              allSolarImpacts.render_Shadows_selectedSections();

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Process Active Impact")) {
              STUDY.PlotImpacts = PlotImpacts_URBAN_ACTIVE;
              allSolarImpacts.calculate_Impact_selectedSections();

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Process Passive Impact")) {
              STUDY.PlotImpacts = PlotImpacts_URBAN_PASSIVE;
              allSolarImpacts.calculate_Impact_selectedSections();

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Process Solid Impact")) {
              allSolidImpacts.calculate_Impact_selectedSections();

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Run wind 3D-model")) {
              allSolidImpacts.calculate_WindFlow();

              SOLARCHVISION_view_changed();
            }

            for (int n = -2; n <= 8; n++) {
              if (menu_option.equals("Layout " + nf(n, 0))) {

                STUDY.plotSetup = n;
                STUDY.revise();
              }
            }

            for (int n = 1; n <= 6; n++) {
              if (menu_option.equals("3D-model " + nf(n, 0))) {

                SOLARCHVISION_deleteAll();

                Create3D.add_DefaultModel(n);

                allSolidImpacts.calculate_Impact_selectedSections();

                ROLLOUT.revise();

                WIN3D.revise();
              }
            }




            if (menu_option.equals("Stop REC.")) {
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;

              ROLLOUT.revise();
            }

            if (menu_option.equals("REC. Time Graph")) {
              STUDY.record_AUTO = true;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;

              ROLLOUT.revise();
            }

            if (menu_option.equals("REC. Location Graph")) {
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = true;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;

              ROLLOUT.revise();
            }

            if (menu_option.equals("REC. Solid Graph")) {
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = true;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;

              ROLLOUT.revise();
            }

            if (menu_option.equals("REC. Screenshot")) {
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = true;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;

              ROLLOUT.revise();
            }

            if (menu_option.equals("PDF Time Graph")) {
              STUDY.record_PDF = true;
              STUDY.revise();
            }

            if (menu_option.equals("JPG Time Graph")) {
              STUDY.record_IMG = true;
              STUDY.revise();
            }

            if (menu_option.equals("JPG Location Graph")) {
              WORLD.record_IMG = true;
              WORLD.revise();
            }

            if (menu_option.equals("PDF Location Graph")) {
              WORLD.record_PDF = true;
              WORLD.revise();
            }

            if (menu_option.equals("JPG 3D Graph")) {
              WIN3D.record_IMG = true;

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("JPG 3D Full-Period")) {
              WIN3D.fullPeriod_IMG = true;
              WIN3D.record_IMG = true;

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Screenshot")) {
              FRAME_record_IMG = true;
            }

            if (menu_option.equals("Screenshot+Click")) {
              FRAME_click_IMG = true;
            }

            if (menu_option.equals("Screenshot+Drag")) {
              FRAME_drag_IMG = true;
            }

            if (menu_option.equals("Update Station")) {
              SOLARCHVISION_update_station(0);
            }

            if (menu_option.equals("Load Land Mesh")) {
              Land3D.update_textures();
            }

            if (menu_option.equals("Load Land Texture")) {
              Land3D.update_textures();
            }

            if (menu_option.equals("Download Land Mesh")) {
              Land3D.download_mesh();
            }

            if (menu_option.equals("Download Land Texture")) {
              Land3D.download_textures();
            }

            if (menu_option.equals("Download Toroposphere")) {
              Tropo3D.download_images();
            }

            if (menu_option.equals("Download Aerial")) {
              SOLARCHVISION_download_AERIAL(TIME.year, TIME.month, TIME.day, TIME.hour);
            }
            if (menu_option.equals("Download NAEFS")) {
              download_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
            }
            if (menu_option.equals("Download CLMREC")) {
              download_CLIMATE_CLMREC();
            }
            if (menu_option.equals("Download SWOB")) {
              download_ENSEMBLE_OBSERVED();
            }





            if (menu_option.equals("Update TMYEPW")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;

              CLIMATE_TMYEPW_load = true;
              update_CLIMATE_TMYEPW();
            }
            if (menu_option.equals("Update CWEEDS")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;

              CLIMATE_CWEEDS_load = true;
              update_CLIMATE_CWEEDS();
            }
            if (menu_option.equals("Update CLMREC")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;

              CLIMATE_CLMREC_load = true;
              update_CLIMATE_CLMREC();
            }
            if (menu_option.equals("Update SWOB")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;

              ENSEMBLE_OBSERVED_load = true;
              SOLARCHVISION_update_ENSEMBLE_OBSERVED();
            }
            if (menu_option.equals("Update NAEFS")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;

              ENSEMBLE_FORECAST_load = true;
              update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
            }
            if (menu_option.equals("Update Aerial")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;

              ENSEMBLE_FORECAST_load = true;
              SOLARCHVISION_load_AERIAL(TIME.year, TIME.month, TIME.day, TIME.hour);
            }






            if (menu_option.equals("Use typical year (TMY)")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;

              CLIMATE_TMYEPW_load = true;
              update_CLIMATE_TMYEPW();

              SOLARCHVISION_view_changed();
              WORLD.revise();
              STUDY.revise();
              ROLLOUT.revise();
              UI_timeBar.revise();

              WORLD.displayAll_TMYEPW = 1;
              WORLD.displayNear_TMYEPW = true;
            }
            if (menu_option.equals("Use long-term (CWEEDS)")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;

              CLIMATE_CWEEDS_load = true;
              update_CLIMATE_CWEEDS();

              SOLARCHVISION_view_changed();
              WORLD.revise();
              STUDY.revise();
              ROLLOUT.revise();
              UI_timeBar.revise();

              WORLD.displayAll_CWEEDS = 1;
              WORLD.displayNear_CWEEDS = true;
            }
            if (menu_option.equals("Use long-term (CLMREC)")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;

              CLIMATE_CLMREC_load = true;
              update_CLIMATE_CLMREC();

              SOLARCHVISION_view_changed();
              WORLD.revise();
              STUDY.revise();
              ROLLOUT.revise();
              UI_timeBar.revise();

              WORLD.displayAll_CLMREC = 1;
              WORLD.displayNear_CLMREC = true;
            }
            if (menu_option.equals("Use real-time observed (SWOB)")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;
              STUDY.joinDays = 1;

              ENSEMBLE_OBSERVED_load = true;
              SOLARCHVISION_update_ENSEMBLE_OBSERVED();

              SOLARCHVISION_view_changed();
              WORLD.revise();
              STUDY.revise();
              ROLLOUT.revise();
              UI_timeBar.revise();

              WORLD.displayAll_SWOB = 1;
              WORLD.displayNear_SWOB = true;
            }
            if (menu_option.equals("Use weather forecast (NAEFS)")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              STUDY.joinDays = 1;

              ENSEMBLE_FORECAST_load = true;
              update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

              SOLARCHVISION_view_changed();
              WIN3D.revise();
              STUDY.revise();
              ROLLOUT.revise();
              UI_timeBar.revise();

              WORLD.displayAll_NAEFS = 1;
              WORLD.displayNear_NAEFS = true;
            }




            if (UI_menuBar.Items[UI_menuBar.selected_parent][0].equals("Layer")) {
              if (UI_menuBar.selected_child > 0) {
                if (CurrentLayer_id != UI_menuBar.selected_child - 1) {

                  if (UI_menuBar.selected_child < numberOfLayers) {

                    changeCurrentLayerTo(UI_menuBar.selected_child - 1);

                    DevelopLayer_id = CurrentLayer_id;

                    STUDY.revise();
                  } else {

                    if ((Develop_Option == DEV_OP_06) || (Develop_Option == DEV_OP_07) || (Develop_Option == DEV_OP_08)) {

                      if (CurrentLayer_id == DevelopLayer_id) {

                        changeCurrentLayerTo(LAYER_developed.id);
                      }

                      Develop_Option = UI_menuBar.selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);

                      STUDY.revise();
                    } else {

                      DevelopLayer_id = CurrentLayer_id;

                      changeCurrentLayerTo(LAYER_developed.id);

                      Develop_Option = UI_menuBar.selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);

                      STUDY.revise();
                    }
                  }
                }
              }
            }



            if (menu_option.equals("Shade Surface Wire")) {
              WIN3D.FacesShade = SHADE.Surface_Wire;
              allFaces.displayEdges = true; //<<<<<<<<<<<<<<<

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Surface Base")) {
              WIN3D.FacesShade = SHADE.Surface_Base;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Surface White")) {
              WIN3D.FacesShade = SHADE.Surface_White;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Surface Materials")) {
              WIN3D.FacesShade = SHADE.Surface_Materials;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Global Solar")) {
              WIN3D.FacesShade = SHADE.Global_Solar;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Vertex Solar")) {
              WIN3D.FacesShade = SHADE.Vertex_Solar;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Vertex Solid")) {
              WIN3D.FacesShade = SHADE.Vertex_Solid;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Shade Vertex Elevation")) {
              WIN3D.FacesShade = SHADE.Vertex_Elevation;

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Render Viewport")) {
              SOLARCHVISION_RenderViewport();
            }
            if (menu_option.equals("PreBake Viewport")) {
              SOLARCHVISION_preBakeViewport();
            }


            if (menu_option.equals("Display/Hide Land Mesh")) {
              Land3D.displaySurface = !Land3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Land Texture")) {
              Land3D.displayTexture = !Land3D.displayTexture;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Land Points")) {
              Land3D.displayPoints = !Land3D.displayPoints;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Land Depth")) {
              Land3D.displayDepth = !Land3D.displayDepth;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Vertices")) {
              allPoints.displayAll = !allPoints.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Edges")) {
              allFaces.displayEdges = !allFaces.displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Normals")) {
              allFaces.displayNormals = !allFaces.displayNormals;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Leaves")) {
              allModel1Ds.displayLeaves = !allModel1Ds.displayLeaves;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Model1Ds")) {
              allModel1Ds.displayAll = !allModel1Ds.displayAll;
              allModel1Ds.displayLeaves = allModel1Ds.displayAll; // <<<<<<

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Model2Ds")) {
              allModel2Ds.displayAll = !allModel2Ds.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Curves")) {
              allCurves.displayAll = !allCurves.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Faces")) {
              allFaces.displayAll = !allFaces.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Solids")) {
              allSolids.displayAll = !allSolids.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sections")) {
              allSections.displayAll = !allSections.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Cameras")) {
              allCameras.displayAll = !allCameras.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sky")) {
              Sky3D.displaySurface = !Sky3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sun Grid")) {
              Sun3D.displayGrid = !Sun3D.displayGrid;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sun Path")) {
              Sun3D.displayPath = !Sun3D.displayPath;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sun Pattern")) {
              Sun3D.displayPattern = !Sun3D.displayPattern;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Sun Surface")) {
              Sun3D.displaySurface = !Sun3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Moon Surface")) {
              Moon3D.displaySurface = !Moon3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Earth Surface")) {
              Earth3D.displaySurface = !Earth3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Troposphere")) {
              Tropo3D.displaySurface = !Tropo3D.displaySurface;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Solar Section")) {
              allSolarImpacts.displayImage = !allSolarImpacts.displayImage;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Solid Section")) {
              allSolidImpacts.displayImage = !allSolidImpacts.displayImage;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Solids")) {
              Select3D.Solid_displayEdges = !Select3D.Solid_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Sections")) {
              Select3D.Section_displayEdges = !Select3D.Section_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Cameras")) {
              Select3D.Camera_displayEdges = !Select3D.Camera_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected LandPoints")) {
              Select3D.LandPoint_displayPoints = !Select3D.LandPoint_displayPoints;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Wind Flow")) {
              allWindFlows.displayAll = !allWindFlows.displayAll;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Faces")) {
              Select3D.Face_displayEdges = !Select3D.Face_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Faces Vertex Count")) {
              Select3D.Face_displayVertexCount = !Select3D.Face_displayVertexCount;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Curves Vertex Count")) {
              Select3D.Curve_displayVertexCount = !Select3D.Curve_displayVertexCount;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Vertices")) {
              Select3D.Vertex_displayVertices = !Select3D.Vertex_displayVertices;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Curves")) {
              Select3D.Curve_displayVertices = !Select3D.Curve_displayVertices;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected REF Pivot")) {
              Select3D.displayReferencePivot = !Select3D.displayReferencePivot;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Group Pivot")) {
              Select3D.Group_displayPivot = !Select3D.Group_displayPivot;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Group Edges")) {
              Select3D.Group_displayEdges = !Select3D.Group_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected Group Box")) {
              Select3D.Group_displayBox = !Select3D.Group_displayBox;

              SOLARCHVISION_view_changed();;
            }
            if (menu_option.equals("Display/Hide Selected 2D Edges")) {
              Select3D.Model2D_displayEdges = !Select3D.Model2D_displayEdges;

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Display/Hide Selected 1D Edges")) {
              Select3D.Model1D_displayEdges = !Select3D.Model1D_displayEdges;

              SOLARCHVISION_view_changed();
            }

            if (menu_option.equals("Display/Hide SWOB stations")) {
              WORLD.displayAll_SWOB = (WORLD.displayAll_SWOB + 1) % 2;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide SWOB nearest")) {
              WORLD.displayNear_SWOB = !WORLD.displayNear_SWOB;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide NAEFS stations")) {
              WORLD.displayAll_NAEFS = (WORLD.displayAll_NAEFS + 1) % 2;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide NAEFS nearest")) {
              WORLD.displayNear_NAEFS = !WORLD.displayNear_NAEFS;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide CWEEDS stations")) {
              WORLD.displayAll_CWEEDS = (WORLD.displayAll_CWEEDS + 1) % 2;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide CWEEDS nearest")) {
              WORLD.displayNear_CWEEDS = !WORLD.displayNear_CWEEDS;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide CLMREC stations")) {
              WORLD.displayAll_CLMREC = (WORLD.displayAll_CLMREC + 1) % 2;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide CLMREC nearest")) {
              WORLD.displayNear_CLMREC = !WORLD.displayNear_CLMREC;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide TMYEPW stations")) {
              WORLD.displayAll_TMYEPW = (WORLD.displayAll_TMYEPW + 1) % 2;

              WORLD.revise();
            }
            if (menu_option.equals("Display/Hide TMYEPW nearest")) {
              WORLD.displayNear_TMYEPW = !WORLD.displayNear_TMYEPW;

              WORLD.revise();
            }

            if (menu_option.equals("3D-Tree")) {
              UI_set_to_Create_allModel1Ds();
              UI_toolBar.highlight("3D-Tree");
              UI_toolBar.revise();
            }
            if (menu_option.equals("2D-Tree")) {
              UI_set_to_Create_Tree();
              UI_toolBar.highlight("2D-Tree");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Person")) {
              UI_set_to_Create_Person();
              UI_toolBar.highlight("Person");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Point")) {
              UI_set_to_Create_Vertex();
              UI_toolBar.highlight("Point");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Spline")) {
              UI_set_to_Create_Curve();
              UI_toolBar.highlight("Spline");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Surface")) {
              UI_set_to_Create_Face();
              UI_toolBar.highlight("Surface");
              UI_toolBar.revise();
            }


            if (menu_option.equals("Parametric 1")) {
              UI_set_to_Create_Parametric(1);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 2")) {
              UI_set_to_Create_Parametric(2);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 3")) {
              UI_set_to_Create_Parametric(3);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 4")) {
              UI_set_to_Create_Parametric(4);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 5")) {
              UI_set_to_Create_Parametric(5);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 6")) {
              UI_set_to_Create_Parametric(6);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Parametric 7")) {
              UI_set_to_Create_Parametric(7);
              UI_toolBar.highlight("Parametric");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Tri")) {
              UI_set_to_Create_Tri();
              UI_toolBar.highlight("Tri");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Plane")) {
              UI_set_to_Create_Plane();
              UI_toolBar.highlight("Plane");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Poly")) {
              UI_set_to_Create_Poly();
              UI_toolBar.highlight("Poly");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Extrude")) {
              UI_set_to_Create_Extrude();
              UI_toolBar.highlight("Extrude");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Hyper")) {
              UI_set_to_Create_Hyper();
              UI_toolBar.highlight("Hyper");
              UI_toolBar.revise();
            }
            if (menu_option.equals("House3")) {
              UI_set_to_Create_House3();
              UI_toolBar.highlight("House3");
              UI_toolBar.revise();
            }
            if (menu_option.equals("House2")) {
              UI_set_to_Create_House2();
              UI_toolBar.highlight("House2");
              UI_toolBar.revise();
            }
            if (menu_option.equals("House1")) {
              UI_set_to_Create_House1();
              UI_toolBar.highlight("House1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Box")) {
              UI_set_to_Create_Box();
              UI_toolBar.highlight("Box");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Icosahedron")) {
              UI_set_to_Create_Icosahedron();
              UI_toolBar.highlight("Icosahedron");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Octahedron")) {
              UI_set_to_Create_Octahedron();
              UI_toolBar.highlight("Octahedron");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Sphere")) {
              UI_set_to_Create_Sphere();
              UI_toolBar.highlight("Sphere");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Cylinder")) {
              UI_set_to_Create_Cylinder();
              UI_toolBar.highlight("Cylinder");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Cushion")) {
              UI_set_to_Create_Cushion();
              UI_toolBar.highlight("Cushion");
              UI_toolBar.revise();
            }



            if (menu_option.equals("Drop on LandSurface")) {
              UI_set_to_Modify_Drop(0);
              UI_toolBar.highlight("DrL±");
              UI_toolBar.revise();

              Drop3D.selection();
            }
            if (menu_option.equals("Drop on ModelSurface (Down)")) {
              UI_set_to_Modify_Drop(1);
              UI_toolBar.highlight("DrM-");
              UI_toolBar.revise();

              Drop3D.selection();
            }
            if (menu_option.equals("Drop on ModelSurface (Up)")) {
              UI_set_to_Modify_Drop(2);
              UI_toolBar.highlight("DrM+");
              UI_toolBar.revise();

              Drop3D.selection();
            }



            if (menu_option.equals("Get dX")) {
              UI_set_to_Modify_GetLength(0);
              UI_toolBar.highlight("GLx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Get dY")) {
              UI_set_to_Modify_GetLength(1);
              UI_toolBar.highlight("GLy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Get dZ")) {
              UI_set_to_Modify_GetLength(2);
              UI_toolBar.highlight("GLz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Get dXYZ")) {
              UI_set_to_Modify_GetLength(3);
              UI_toolBar.highlight("GL³");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Get dXY")) {
              UI_set_to_Modify_GetLength(4);
              UI_toolBar.highlight("GL²");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Get Angle")) {
              UI_set_to_Modify_GetLength(5);
              UI_toolBar.highlight("GLa");
              UI_toolBar.revise();
            }


            if (menu_option.equals("MoveX")) {
              UI_set_to_Modify_Move(0);
              UI_toolBar.highlight("MVx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("MoveY")) {
              UI_set_to_Modify_Move(1);
              UI_toolBar.highlight("MVy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("MoveZ")) {
              UI_set_to_Modify_Move(2);
              UI_toolBar.highlight("MVz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Move")) {
              UI_set_to_Modify_Move(3);
              UI_toolBar.highlight("MV³");
              UI_toolBar.revise();
            }


            if (menu_option.equals("ScaleX")) {
              UI_set_to_Modify_Scale(0);
              UI_toolBar.highlight("SCx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("ScaleY")) {
              UI_set_to_Modify_Scale(1);
              UI_toolBar.highlight("SCy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("ScaleZ")) {
              UI_set_to_Modify_Scale(2);
              UI_toolBar.highlight("SCz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Scale")) {
              UI_set_to_Modify_Scale(3);
              UI_toolBar.highlight("SC³");
              UI_toolBar.revise();
            }


            if (menu_option.equals("PowerX")) {
              UI_set_to_Modify_Power(0);
              UI_toolBar.highlight("PWx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PowerY")) {
              UI_set_to_Modify_Power(1);
              UI_toolBar.highlight("PWy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PowerZ")) {
              UI_set_to_Modify_Power(2);
              UI_toolBar.highlight("PWz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Power")) {
              UI_set_to_Modify_Power(3);
              UI_toolBar.highlight("PW³");
              UI_toolBar.revise();
            }


            if (menu_option.equals("RotateX")) {
              UI_set_to_Modify_Rotate(0);
              UI_toolBar.highlight("RTx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("RotateY")) {
              UI_set_to_Modify_Rotate(1);
              UI_toolBar.highlight("RTy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("RotateZ")) {
              UI_set_to_Modify_Rotate(2);
              UI_toolBar.highlight("RTz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Rotate")) {
              UI_set_to_Modify_Rotate(2);
              UI_toolBar.revise();
            }

            if (menu_option.equals("Pivot")) {
              UI_set_to_Modify_Pivot(0);
              UI_toolBar.highlight("SPvt0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Pivot")) {
              UI_set_to_Modify_Pivot(1);
              UI_toolBar.highlight("SPvt1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Pivot")) {
              UI_set_to_Modify_Pivot(2);
              UI_toolBar.highlight("SPvt2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Save Current ReferenceBox")) {
              Select3D.save_current_BoundingBox();
              UI_toolBar.highlight("<pvt>");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Reset Saved ReferenceBox")) {
              Select3D.apply_saved_BoundingBox();
              UI_toolBar.highlight(">pvt<");
              UI_toolBar.revise();

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Use Selection ReferenceBox")) {
              Select3D.calculate_BoundingBox();
              UI_toolBar.highlight("|pvt|");
              UI_toolBar.revise();

              SOLARCHVISION_view_changed();
            }
            if (menu_option.equals("Use Origin ReferenceBox")) {
              Select3D.apply_origin_ReferenceBox();
              UI_toolBar.highlight(".pvt.");
              UI_toolBar.revise();

              SOLARCHVISION_view_changed();
            }



            if (menu_option.equals("Begin New Group at Origin")) {

              allGroups.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

              Select3D.Group_ids = new int [1];
              Select3D.Group_ids[0] = allGroups.num - 1;

              SOLARCHVISION_model_changed();
            }

            if (menu_option.equals("Begin New Group at Pivot")) {

              allGroups.beginNewGroup(Select3D.BoundingBox[1 + Select3D.alignX][0], Select3D.BoundingBox[1 + Select3D.alignX][1], Select3D.BoundingBox[1 + Select3D.alignX][2], Select3D.BoundingBox[1 + Select3D.alignX][3], Select3D.BoundingBox[1 + Select3D.alignX][4], Select3D.BoundingBox[1 + Select3D.alignX][5], Select3D.BoundingBox[1 + Select3D.alignX][6], Select3D.BoundingBox[1 + Select3D.alignX][7], Select3D.BoundingBox[1 + Select3D.alignX][8]);

              Select3D.Group_ids = new int [1];
              Select3D.Group_ids[0] = allGroups.num - 1;

              SOLARCHVISION_model_changed();
            }

            if (menu_option.equals("Solid")) {
              UI_set_to_Create_Solid();
              UI_toolBar.highlight("SLD");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Section")) {
              UI_set_to_Create_Section();
              UI_toolBar.highlight("SEC");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Camera")) {
              UI_set_to_Create_Camera();
              UI_toolBar.highlight("CAM");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Viewport >> Camera")) {

              float Camera_pX = WIN3D.position_X;
              float Camera_pY = WIN3D.position_Y;
              float Camera_pZ = WIN3D.position_Z;
              float Camera_pT = WIN3D.position_T;
              float Camera_rX = WIN3D.rotation_X;
              float Camera_rY = WIN3D.rotation_Y;
              float Camera_rZ = WIN3D.rotation_Z;
              float Camera_rT = WIN3D.rotation_T;
              float Camera_zoom = WIN3D.Zoom;

              int Camera_type = WIN3D.ViewType;

              allCameras.create(Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_zoom, Camera_type);

              WIN3D.currentCamera = allCameras.num - 1;
              WIN3D.apply_currentCamera();
              SOLARCHVISION_modify_Viewport_Title();

              SOLARCHVISION_view_changed();

              UI_toolBar.revise();
            }

            if (menu_option.equals("Camera >> Viewport")) {

              allCameras.set_posX(0, allCameras.get_posX(WIN3D.currentCamera));
              allCameras.set_posY(0, allCameras.get_posY(WIN3D.currentCamera));
              allCameras.set_posZ(0, allCameras.get_posZ(WIN3D.currentCamera));
              allCameras.set_posT(0, allCameras.get_posT(WIN3D.currentCamera));
              allCameras.set_rotX(0, allCameras.get_rotX(WIN3D.currentCamera));
              allCameras.set_rotY(0, allCameras.get_rotY(WIN3D.currentCamera));
              allCameras.set_rotZ(0, allCameras.get_rotZ(WIN3D.currentCamera));
              allCameras.set_rotT(0, allCameras.get_rotT(WIN3D.currentCamera));
              allCameras.set_zoom(0, allCameras.get_zoom(WIN3D.currentCamera));
              allCameras.set_type(0, allCameras.get_type(WIN3D.currentCamera));

              WIN3D.currentCamera = 0;
              SOLARCHVISION_modify_Viewport_Title();

              SOLARCHVISION_view_changed();

              UI_toolBar.revise();
            }

            if (menu_option.equals("GoTo Selected Camera")) {
              if (Select3D.Camera_ids.length > 0) {
                WIN3D.currentCamera = Select3D.Camera_ids[Select3D.Camera_ids.length - 1];
                WIN3D.apply_currentCamera();
                SOLARCHVISION_modify_Viewport_Title();

                SOLARCHVISION_view_changed();

                UI_toolBar.revise();
              }
            }

            if (menu_option.equals("LandMesh >> Group")) {
              Land3D.draw(TypeWindow.LandMesh);

              SOLARCHVISION_model_changed();
            }

            if (menu_option.equals("LandGap >> Group")) {
              Land3D.draw(TypeWindow.LandGap);

              SOLARCHVISION_model_changed();
            }



            if (menu_option.equals("Change Seed/Material")) {
              UI_set_to_Modify_Seed(0);
              UI_toolBar.highlight("Mat0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Seed/Material")) {
              UI_set_to_Modify_Seed(1);
              UI_toolBar.highlight("Mat1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Seed/Material")) {
              UI_set_to_Modify_Seed(2);
              UI_toolBar.highlight("Mat2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change tessellation")) {
              UI_set_to_Modify_Tessellation(0);
              UI_toolBar.highlight("Tes0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick tessellation")) {
              UI_set_to_Modify_Tessellation(1);
              UI_toolBar.highlight("Tes1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign tessellation")) {
              UI_set_to_Modify_Tessellation(2);
              UI_toolBar.highlight("Tes2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change Layer")) {
              UI_set_to_Modify_Layer(0);
              UI_toolBar.highlight("Lyr0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Layer")) {
              UI_set_to_Modify_Layer(1);
              UI_toolBar.highlight("Lyr1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Layer")) {
              UI_set_to_Modify_Layer(2);
              UI_toolBar.highlight("Lyr2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change Visibility")) {
              UI_set_to_Modify_Visibility(0);
              UI_toolBar.highlight("Vsb0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Visibility")) {
              UI_set_to_Modify_Visibility(1);
              UI_toolBar.highlight("Vsb1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Visibility")) {
              UI_set_to_Modify_Visibility(2);
              UI_toolBar.highlight("Vsb2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change Weight")) {
              UI_set_to_Modify_Weight(0);
              UI_toolBar.highlight("Wgt0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Weight")) {
              UI_set_to_Modify_Weight(1);
              UI_toolBar.highlight("Wgt1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Weight")) {
              UI_set_to_Modify_Weight(2);
              UI_toolBar.highlight("Wgt2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Flip Normal")) {
              UI_set_to_Modify_Normal(1);
              UI_toolBar.highlight("Norm1");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Set-Out Normal")) {
              UI_set_to_Modify_Normal(2);
              UI_toolBar.highlight("Norm2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Set-In Normal")) {
              UI_set_to_Modify_Normal(3);
              UI_toolBar.highlight("Norm3");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Get FirstVertex")) {
              UI_set_to_Modify_FirstVertex(1);
              UI_toolBar.highlight("1stV");
              UI_toolBar.revise();
            }



            if (menu_option.equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
              UI_toolBar.highlight("dgMax0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick DegreeMax")) {
              UI_set_to_Modify_DegreeMax(1);
              UI_toolBar.highlight("dgMax1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign DegreeMax")) {
              UI_set_to_Modify_DegreeMax(2);
              UI_toolBar.highlight("dgMax2");
              UI_toolBar.revise();
            }




            if (menu_option.equals("Change BranchTilt")) {
              UI_set_to_Modify_BranchTilt(0);
              UI_toolBar.highlight("bTilt0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick BranchTilt")) {
              UI_set_to_Modify_BranchTilt(1);
              UI_toolBar.highlight("bTilt1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign BranchTilt")) {
              UI_set_to_Modify_BranchTilt(2);
              UI_toolBar.highlight("bTilt2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change BranchTwist")) {
              UI_set_to_Modify_BranchTwist(0);
              UI_toolBar.highlight("bTwist0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick BranchTwist")) {
              UI_set_to_Modify_BranchTwist(1);
              UI_toolBar.highlight("bTwist1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign BranchTwist")) {
              UI_set_to_Modify_BranchTwist(2);
              UI_toolBar.highlight("bTwist2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change BranchRatio")) {
              UI_set_to_Modify_BranchRatio(0);
              UI_toolBar.highlight("bRatio0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick BranchRatio")) {
              UI_set_to_Modify_BranchRatio(1);
              UI_toolBar.highlight("bRatio1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign BranchRatio")) {
              UI_set_to_Modify_BranchRatio(2);
              UI_toolBar.highlight("bRatio2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change TreeBase")) {
              UI_set_to_Modify_TreeBase(0);
              UI_toolBar.highlight("tBase0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick TreeBase")) {
              UI_set_to_Modify_TreeBase(1);
              UI_toolBar.highlight("tBase1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign TreeBase")) {
              UI_set_to_Modify_TreeBase(2);
              UI_toolBar.highlight("tBase2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
              UI_toolBar.highlight("trSz0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick TrunkSize")) {
              UI_set_to_Modify_TrunkSize(1);
              UI_toolBar.highlight("trSz1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign TrunkSize")) {
              UI_set_to_Modify_TrunkSize(2);
              UI_toolBar.highlight("trSz2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
              UI_toolBar.highlight("lfSz0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick LeafSize")) {
              UI_set_to_Modify_LeafSize(1);
              UI_toolBar.highlight("lfSz1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign LeafSize")) {
              UI_set_to_Modify_LeafSize(2);
              UI_toolBar.highlight("lfSz2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Model1DsProps")) {
              UI_set_to_Modify_Model1DsProps(0);
              UI_toolBar.highlight("allFP0");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Model1DsProps")) {
              UI_set_to_Modify_Model1DsProps(1);
              UI_toolBar.highlight("allFP1");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Assign Model1DsProps")) {
              UI_set_to_Modify_Model1DsProps(2);
              UI_toolBar.highlight("allFP2");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
            }
            if (menu_option.equals("Change BranchTilt")) {
              UI_set_to_Modify_BranchTilt(0);
            }
            if (menu_option.equals("Change BranchTwist")) {
              UI_set_to_Modify_BranchTwist(0);
            }
            if (menu_option.equals("Change BranchRatio")) {
              UI_set_to_Modify_BranchRatio(0);
            }
            if (menu_option.equals("Change TreeBase")) {
              UI_set_to_Modify_TreeBase(0);
            }
            if (menu_option.equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
            }
            if (menu_option.equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
            }


            if (menu_option.equals("Orthographic")) {
              UI_set_to_View_ProjectionType(0);
              UI_toolBar.highlight("P<>");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Perspective")) {
              UI_set_to_View_ProjectionType(1);
              UI_toolBar.highlight("P><");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Invert Selection")) {
              Select3D.invertSelection();
            }
            if (menu_option.equals("Deselect All")) {
              Select3D.deselectAll();
            }
            if (menu_option.equals("Select All")) {
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Cameras")) {
              SOLARCHVISION_switch_category(ObjectCategory.CAMERA);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Sections")) {
              SOLARCHVISION_switch_category(ObjectCategory.SECTION);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Solids")) {
              SOLARCHVISION_switch_category(ObjectCategory.SOLID);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Faces")) {
              SOLARCHVISION_switch_category(ObjectCategory.FACE);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Curves")) {
              SOLARCHVISION_switch_category(ObjectCategory.CURVE);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Verices")) {
              SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Groups")) {
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Model1Ds")) {
              SOLARCHVISION_switch_category(ObjectCategory.MODEL1D);
              Select3D.selectAll();
            }
            if (menu_option.equals("Select All Model2Ds")) {
              SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
              Select3D.selectAll();
            }





            if (menu_option.equals("Select Solid")) {
              SOLARCHVISION_switch_category(ObjectCategory.SOLID);
            }
            if (menu_option.equals("Select Section")) {
              SOLARCHVISION_switch_category(ObjectCategory.SECTION);
            }
            if (menu_option.equals("Select Camera")) {
              SOLARCHVISION_switch_category(ObjectCategory.CAMERA);
            }
            if (menu_option.equals("Select LandPoint")) {
              SOLARCHVISION_switch_category(ObjectCategory.LANDPOINT);
            }
            if (menu_option.equals("Select Model1Ds")) {
              SOLARCHVISION_switch_category(ObjectCategory.MODEL1D);
            }
            if (menu_option.equals("Select Model2Ds")) {
              SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
            }
            if (menu_option.equals("Select Group")) {
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Select Face")) {
              SOLARCHVISION_switch_category(ObjectCategory.FACE);
            }
            if (menu_option.equals("Select Curve")) {
              SOLARCHVISION_switch_category(ObjectCategory.CURVE);
            }
            if (menu_option.equals("Select Vertex")) {
              SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
            }
            if (menu_option.equals("Soft Selection")) {
              Select3D.convert_Vertex_to_softSelection();

              SOLARCHVISION_switch_category(ObjectCategory.SOFTVERTEX);
            }
            if (menu_option.equals("Vertices >> Groups")) {
              Select3D.convert_Vertices_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Faces >> Groups")) {
              Select3D.convert_Faces_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Groups >> Faces")) {
              Select3D.convert_Groups_to_Faces();
              SOLARCHVISION_switch_category(ObjectCategory.FACE);
            }
            if (menu_option.equals("Curves >> Groups")) {
              Select3D.convert_Curves_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Groups >> Curves")) {
              Select3D.convert_Groups_to_Curves();
              SOLARCHVISION_switch_category(ObjectCategory.CURVE);
            }
            if (menu_option.equals("Curves >> Vertices")) {
              Select3D.convert_Curves_to_Vertices();
              SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
            }
            if (menu_option.equals("Vertices >> Curves")) {
              Select3D.convert_Vertices_to_Curves();
              SOLARCHVISION_switch_category(ObjectCategory.CURVE);
            }
            if (menu_option.equals("Groups >> Vertices")) {
              Select3D.convert_Groups_to_Vertices();
              SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
            }
            if (menu_option.equals("Faces >> Vertices")) {
              Select3D.convert_Faces_to_Vertices();
              SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
            }
            if (menu_option.equals("Vertices >> Faces")) {
              Select3D.convert_Vertices_to_Faces();
              SOLARCHVISION_switch_category(ObjectCategory.FACE);
            }
            if (menu_option.equals("Solids >> Groups")) {
              Select3D.convert_Solids_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Groups >> Solids")) {
              Select3D.convert_Groups_to_Solids();
              SOLARCHVISION_switch_category(ObjectCategory.SOLID);
            }
            if (menu_option.equals("Model2Ds >> Groups")) {
              Select3D.convert_Model2Ds_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Groups >> Model2Ds")) {
              Select3D.convert_Groups_to_Model2Ds();
              SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
            }
            if (menu_option.equals("Model1Ds >> Groups")) {
              Select3D.convert_Model1Ds_to_Groups();
              SOLARCHVISION_switch_category(ObjectCategory.GROUP);
            }
            if (menu_option.equals("Groups >> Model1Ds")) {
              Select3D.convert_Groups_to_Model1Ds();
              SOLARCHVISION_switch_category(ObjectCategory.MODEL1D);
            }

            if (menu_option.equals("Pick Select")) {
              UI_set_to_View_PickSelect(0);
              UI_toolBar.highlight("±PS");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Select+")) {
              UI_set_to_View_PickSelect(1);
              UI_toolBar.highlight("+PS");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Pick Select-")) {
              UI_set_to_View_PickSelect(2);
              UI_toolBar.highlight("-PS");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Window Select")) {
              UI_set_to_View_WindowSelect(0);
              UI_toolBar.highlight("±WS");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Window Select+")) {
              UI_set_to_View_WindowSelect(1);
              UI_toolBar.highlight("+WS");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Window Select-")) {
              UI_set_to_View_WindowSelect(2);
              UI_toolBar.highlight("-WS");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Select Near Selected Vertices")) {
              Select3D.selectNearVertices();
            }

            if (menu_option.equals("Weld Objects Selected Vertices")) {
              Modify3D.weldObjectsVertices_Selection(User3D.modify_WeldTreshold);
            }
            if (menu_option.equals("Weld Scene Selected Vertices")) {
              Modify3D.weldSceneVertices_Selection(User3D.modify_WeldTreshold);
            }
            if (menu_option.equals("Reposition Selected Vertices")) {
              Modify3D.repositionVertices_Selection();
            }
            if (menu_option.equals("Separate Selected Vertices")) {
              Modify3D.separateVertices_Selection();
            }
            if (menu_option.equals("Select Scene Isolated Vertices")) {
              Select3D.isolatedVertices_Scene();
            }
            if (menu_option.equals("Delete Scene Isolated Vertices")) {
              Delete3D.isolatedVertices_Scene();
            }
            if (menu_option.equals("Delete Selection Isolated Vertices")) {
              Delete3D.isolatedVertices_Selection();
            }
            if (menu_option.equals("Delete Scene Empty Groups")) {
              allGroups.deleteEmptyGroups_Scene();
            }
            if (menu_option.equals("Delete Selection")) {
              Delete3D.selection();
            }
            if (menu_option.equals("Dettach from Groups Selection")) {
              allGroups.dettachFromGroups_Selection();
            }
            if (menu_option.equals("Ungroup Selection")) {
              allGroups.ungroup_Selection();
            }
            if (menu_option.equals("Group Selection")) {
              allGroups.group_Selection(1);
            }
            if (menu_option.equals("Attach to Last Group")) {
              allGroups.group_Selection(0);
            }
            if (menu_option.equals("Clone Selection (Identical)")) {
              Clone3D.selection(true);
            }
            if (menu_option.equals("Clone Selection (Variation)")) {
              Clone3D.selection(false);
            }
            if (menu_option.equals("Auto-Normal Selected Faces")) {
              Modify3D.autoNormalFaces_Selection();
            }
            if (menu_option.equals("Force Triangulate Selected Faces")) {
              Modify3D.forceTriangulateFaces_Selection();
            }

            if (menu_option.equals("Insert Corner Opennings")) {
              Modify3D.insertCornerOpennings_Selection();
            }
            if (menu_option.equals("Insert Parallel Opennings")) {
              Modify3D.insertParallelOpennings_Selection();
            }
            if (menu_option.equals("Insert Rotated Opennings")) {
              Modify3D.insertRotatedOpennings_Selection();
            }
            if (menu_option.equals("Insert Edge Opennings")) {
              Modify3D.insertEdgeOpennings_Selection();
            }

            if (menu_option.equals("Optimize Faces")) {
              Modify3D.optimizeFace_Selection();
            }

            if (menu_option.equals("Triangulate Faces")) {
              Modify3D.triangulateFace_Selection();
            }

            if (menu_option.equals("Tessellate Rows & Columns")) {
              Modify3D.tessellateRowsColumns_Selection();
            }
            if (menu_option.equals("Tessellate Rectangular")) {
              Modify3D.tessellateRectangular_Selection();
            }
            if (menu_option.equals("tessellation Triangular")) {
              Modify3D.tessellateTriangular_Selection();
            }
            if (menu_option.equals("Extrude Face Edges")) {
              Modify3D.extrudeFaceEdges_Selection();
            }
            if (menu_option.equals("Extrude Curve Edges")) {
              Modify3D.extrudeCurveEdges_Selection();
            }
            if (menu_option.equals("Offset(above) Vertices")) {
              Modify3D.offsetVertices_Selection(0, abs(User3D.modify_OffsetAmount));
            }
            if (menu_option.equals("Offset(below) Vertices")) {
              Modify3D.offsetVertices_Selection(0, -abs(User3D.modify_OffsetAmount));
            }
            if (menu_option.equals("Offset(expand) Vertices")) {
              Modify3D.offsetVertices_Selection(1, -abs(User3D.modify_OffsetAmount));
            }
            if (menu_option.equals("Offset(shrink) Vertices")) {
              Modify3D.offsetVertices_Selection(1, abs(User3D.modify_OffsetAmount));
            }

            if (menu_option.equals("Reverse Visibility of All Faces")) {
              Modify3D.reverseVisibilityFaces_Scene();
            }
            if (menu_option.equals("Hide All Faces")) {
              Modify3D.changeVisibilityFaces_Scene(0);
            }
            if (menu_option.equals("Unhide All Faces")) {
              Modify3D.changeVisibilityFaces_Scene(1);
            }
            if (menu_option.equals("Hide Selected Faces")) {
              Modify3D.changeVisibilityFaces_Selection(0);
            }
            if (menu_option.equals("Unhide Selected Faces")) {
              Modify3D.changeVisibilityFaces_Selection(1);
            }
            if (menu_option.equals("Isolate Selection")) {
              Modify3D.isolate_Selection();
            }

            if (menu_option.equals("Flatten Selected LandPoints")) {
              Modify3D.flatten_LandPoints();
            }

            if (menu_option.equals("Add People on Land")) {
              Create3D.add_onLand(1); // 1 = people
            }

            if (menu_option.equals("Add 2D-Trees on Land")) {
              Create3D.add_onLand(2); // 2 = 2D trees
            }

            if (menu_option.equals("Add 3D-Trees on Land")) {
              Create3D.add_onLand(3); // 3 = 3D trees
            }

            if (menu_option.equals("Erase All Model1Ds")) {
              allModel1Ds.makeEmpty(0);
            }

            if (menu_option.equals("Erase All Model2Ds")) {
              allModel2Ds.makeEmpty(0);
            }

            if (menu_option.equals("Erase All Groups")) {
              allGroups.makeEmpty(0);
            }

            if (menu_option.equals("Erase All Solids")) {
              allSolids.makeEmpty(0);
            }

            if (menu_option.equals("Erase All Sections")) {
              allSections.makeEmpty(0);
            }

            if (menu_option.equals("Erase All Cameras")) {
              allCameras.makeEmpty(0);
            }

            if (menu_option.equals("Erase Faces")) {
              allFaces.makeEmpty(0);
            }

            if (menu_option.equals("Erase Curves")) {
              allCurves.makeEmpty(0);
            }

            if (menu_option.equals("Erase All")) {
              SOLARCHVISION_deleteAll();
            }


            if (menu_option.equals("TargetRoll")) {
              UI_set_to_View_TargetRoll(0);
              UI_toolBar.highlight("TRL");
              UI_toolBar.revise();
            }
            if (menu_option.equals("TargetRollZ")) {
              UI_set_to_View_TargetRoll(1);
              UI_toolBar.highlight("TRLz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("TargetRollXY")) {
              UI_set_to_View_TargetRoll(2);
              UI_toolBar.highlight("TRLxy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("CameraRoll")) {
              UI_set_to_View_CameraRoll(0);
              UI_toolBar.highlight("CRL");
              UI_toolBar.revise();
            }
            if (menu_option.equals("CameraRollZ")) {
              UI_set_to_View_CameraRoll(1);
              UI_toolBar.highlight("CRLz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("CameraRollXY")) {
              UI_set_to_View_CameraRoll(2);
              UI_toolBar.highlight("CRLxy");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Orbit")) {
              UI_set_to_View_Orbit(0);
              UI_toolBar.highlight("OR");
              UI_toolBar.revise();
            }
            if (menu_option.equals("OrbitZ")) {
              UI_set_to_View_Orbit(1);
              UI_toolBar.highlight("ORz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("OrbitXY")) {
              UI_set_to_View_Orbit(2);
              UI_toolBar.highlight("ORxy");
              UI_toolBar.revise();
            }

            if (menu_option.equals("LandOrbit")) {
              UI_set_to_View_LandOrbit(0);
              UI_toolBar.highlight("LNOR");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Pan")) {
              UI_set_to_View_Pan(0);
              UI_toolBar.highlight("Pan");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PanX")) {
              UI_set_to_View_Pan(1);
              UI_toolBar.highlight("PanX");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PanY")) {
              UI_set_to_View_Pan(2);
              UI_toolBar.highlight("PanY");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Zoom")) {
              UI_set_to_View_ZOOM(0);
              UI_toolBar.highlight("±ZM");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Zoom as default")) {
              UI_set_to_View_ZOOM(1);
              UI_toolBar.highlight("0ZM");
              UI_toolBar.revise();
            }


            if (menu_option.equals("TruckX")) {
              UI_set_to_View_Truck(1);
              UI_toolBar.highlight("DIx");
              UI_toolBar.revise();
            }
            if (menu_option.equals("TruckY")) {
              UI_set_to_View_Truck(2);
              UI_toolBar.highlight("DIy");
              UI_toolBar.revise();
            }
            if (menu_option.equals("TruckZ")) {
              UI_set_to_View_Truck(0);
              UI_toolBar.highlight("DIz");
              UI_toolBar.revise();
            }
            if (menu_option.equals("DistZ")) {
              UI_set_to_View_Truck(0);
              UI_toolBar.highlight("±CDZ");
              UI_toolBar.revise();
            }
            if (menu_option.equals("CameraDistance")) {
              UI_set_to_View_CameraDistance(0);
              UI_toolBar.highlight("±CDS");
              UI_toolBar.revise();
            }
            if (menu_option.equals("DistMouseXY")) {
              UI_set_to_View_DistMouseXY(0);
              UI_toolBar.highlight("±CDM");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Look at origin")) {
              UI_set_to_View_LookAtOrigin(0);
              UI_toolBar.highlight("LAO");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Look at direction")) {
              UI_set_to_View_LookAtDirection(0);
              UI_toolBar.highlight("LAD");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Look at selection")) {
              UI_set_to_View_LookAtSelection(0);
              UI_toolBar.highlight("LAS");
              UI_toolBar.revise();
            }


            if (menu_option.equals("3DModelSize")) {
              UI_set_to_View_3DModelSize();
              UI_toolBar.highlight("±SZ");
              UI_toolBar.revise();
            }

            if (menu_option.equals("SkydomeSize")) {
              UI_set_to_View_SkydomeSize();
              UI_toolBar.highlight("±SK");
              UI_toolBar.revise();
            }

            if (menu_option.equals("AllModelSize")) {
              UI_set_to_View_AllModelSize();
              UI_toolBar.highlight("±SA");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Display All Viewports")) {
              UI_set_to_Viewport(0);
              UI_toolBar.highlight("AllViewports");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Enlarge 3D Viewport")) {
              UI_set_to_Viewport(1);
              UI_toolBar.highlight("Expand3DView");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Enlarge Time Viewport")) {
              UI_set_to_Viewport(2);
              UI_toolBar.highlight("ExpandTimeView");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Enlarge Map Viewport")) {
              UI_set_to_Viewport(3);
              UI_toolBar.highlight("ExpandMapView");
              UI_toolBar.revise();
            }

            if (menu_option.equals("Top")) {
              UI_set_to_View_3DViewPoint(0);
              UI_toolBar.highlight("Top");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Front")) {
              UI_set_to_View_3DViewPoint(1);
              UI_toolBar.highlight("Front");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Left")) {
              UI_set_to_View_3DViewPoint(2);
              UI_toolBar.highlight("Left");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Back")) {
              UI_set_to_View_3DViewPoint(3);
              UI_toolBar.highlight("Back");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Right")) {
              UI_set_to_View_3DViewPoint(4);
              UI_toolBar.highlight("Right");
              UI_toolBar.revise();
            }
            if (menu_option.equals("Bottom")) {
              UI_set_to_View_3DViewPoint(5);
              UI_toolBar.highlight("Bottom");
              UI_toolBar.revise();
            }
            if (menu_option.equals("S.W.")) {
              UI_set_to_View_3DViewPoint(6);
              UI_toolBar.highlight("S.W.");
              UI_toolBar.revise();
            }
            if (menu_option.equals("S.E.")) {
              UI_set_to_View_3DViewPoint(7);
              UI_toolBar.highlight("S.E.");
              UI_toolBar.revise();
            }
            if (menu_option.equals("N.E.")) {
              UI_set_to_View_3DViewPoint(8);
              UI_toolBar.highlight("N.E.");
              UI_toolBar.revise();
            }
            if (menu_option.equals("N.W.")) {
              UI_set_to_View_3DViewPoint(9);
              UI_toolBar.highlight("N.W.");
              UI_toolBar.revise();
            }

            if (menu_option.equals("PivotX:Minimum")) {
              UI_set_to_View_PivotX(-1);
              UI_toolBar.highlight("X<");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotX:Center")) {
              UI_set_to_View_PivotX(0);
              UI_toolBar.highlight("X|");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotX:Maximum")) {
              UI_set_to_View_PivotX(1);
              UI_toolBar.highlight("X>");
              UI_toolBar.revise();
            }

            if (menu_option.equals("PivotY:Minimum")) {
              UI_set_to_View_PivotY(-1);
              UI_toolBar.highlight("Y<");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotY:Center")) {
              UI_set_to_View_PivotY(0);
              UI_toolBar.highlight("Y|");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotY:Maximum")) {
              UI_set_to_View_PivotY(1);
              UI_toolBar.highlight("Y>");
              UI_toolBar.revise();
            }

            if (menu_option.equals("PivotZ:Minimum")) {
              UI_set_to_View_PivotZ(-1);
              UI_toolBar.highlight("Z<");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotZ:Center")) {
              UI_set_to_View_PivotZ(0);
              UI_toolBar.highlight("Z|");
              UI_toolBar.revise();
            }
            if (menu_option.equals("PivotZ:Maximum")) {
              UI_set_to_View_PivotZ(1);
              UI_toolBar.highlight("Z>");
              UI_toolBar.revise();
            }
          }
        }

        UI_menuBar.selected_parent = -1;
        UI_menuBar.selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_pixel_A);

        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      } else {

        SOLARCHVISION_X_clicked = mouseX;
        SOLARCHVISION_Y_clicked = mouseY;

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, 0, width, SOLARCHVISION_pixel_A)) {
          UI_menuBar.revise();
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B)) {
          UI_toolBar.revise();
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C)) {
          UI_timeBar.revise();
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + SOLARCHVISION_pixel_D)) {
          typeUserCommand = 1;
          UI_commandBar.revise();
        } else {
          typeUserCommand = 0;
          UI_commandBar.revise();
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, ROLLOUT.cX, ROLLOUT.cY, ROLLOUT.cX + ROLLOUT.dX, ROLLOUT.cY + ROLLOUT.dY)) {
          ROLLOUT.revise();
        }

        if (WORLD.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY)) {

            float mouse_lon = 360.0 * ((mouseX - WORLD.cX) * WORLD.sX / WORLD.dX - 0.5) + WORLD.oX;
            float mouse_lat = -180.0 * ((mouseY - WORLD.cY) * WORLD.sY / WORLD.dY - 0.5) + WORLD.oY;
            //float mouse_lon = STATION.getLongitude();
            //float mouse_lat = STATION.getLatitude();


            pre_LocationLAT = LocationLAT;
            pre_LocationLON = LocationLON;

            STATION.setLatitude(mouse_lat);
            STATION.setLongitude(mouse_lon);

            if (mouseButton == LEFT) {
              WORLD.Zoom = 6;
            }

            if ((pre_LocationLAT != LocationLAT) ||
                (pre_LocationLON != LocationLON)) {

              WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
            }



            {
              int nearest_WORLD_NAEFS = -1;
              float nearest_WORLD_NAEFS_dist = FLOAT_undefined;

              for (int f = 0; f < NAEFposition_Ts.length; f++) {

                float _lat = NAEFposition_Ts[f].getLatitude();
                float _lon = NAEFposition_Ts[f].getLongitude();
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_NAEFS_dist > d) {
                  nearest_WORLD_NAEFS_dist = d;
                  nearest_WORLD_NAEFS = f;
                }
              }

              {
                int f = nearest_WORLD_NAEFS;

                if (STATION.getFilename_NAEFS().equals(NAEFposition_Ts[f].getFilename_NAEFS())) {
                } else {

                  STATION.setLatitude(mouse_lat);
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_NAEFS(NAEFposition_Ts[f].getFilename_NAEFS()); // naefs filename

                  println("nearest naefs filename:", NAEFposition_Ts[f].getFilename_NAEFS());

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    STATION.setCity(NAEFposition_Ts[f].getCity());
                    STATION.setProvince(NAEFposition_Ts[f].getProvince());
                    STATION.setCountry(NAEFposition_Ts[f].getCountry());

                    //STATION.setLatitude(NAEFposition_Ts[f].getLatitude());
                    //STATION.setLongitude(NAEFposition_Ts[f].getLongitude());
                    STATION.setElevation(NAEFposition_Ts[f].getElevation());
                    STATION.setTimelong(NAEFposition_Ts[f].getTimelong());

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.revise();


                    SOLARCHVISION_update_station(1);
                    update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
                  }
                }
              }
            }


            {
              int nearest_WORLD_CWEEDS = -1;
              float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;

              for (int f = 0; f < CWEEDS_coordinates.length; f++) {

                float _lat = CWEEDS_coordinates[f].getLatitude();
                float _lon = CWEEDS_coordinates[f].getLongitude();
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_CWEEDS_dist > d) {
                  nearest_WORLD_CWEEDS_dist = d;
                  nearest_WORLD_CWEEDS = f;
                }
              }

              {
                int f = nearest_WORLD_CWEEDS;

                if (STATION.getFilename_CWEEDS().equals(CWEEDS_coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_CWEEDS(CWEEDS_coordinates[f].getFilename_CWEEDS()); // CWEEDS filename

                  println("nearest CWEEDS filename:", CWEEDS_coordinates[f].getFilename_CWEEDS());

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {

                    STATION.setCity(CWEEDS_coordinates[f].getCity());
                    STATION.setProvince(CWEEDS_coordinates[f].getProvince());
                    STATION.setCountry(CWEEDS_coordinates[f].getCountry());

                    //STATION.setLatitude(CWEEDS_coordinates[f].getLatitude());
                    //STATION.setLongitude(CWEEDS_coordinates[f].getLongitude());
                    STATION.setElevation(CWEEDS_coordinates[f].getElevation());
                    STATION.setTimelong(funcs.roundTo(STATION.getLongitude(), 15));

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.revise();

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CWEEDS();
                  }
                }
              }
            }

            {
              int nearest_WORLD_CLMREC = -1;
              float nearest_WORLD_CLMREC_dist = FLOAT_undefined;

              for (int f = 0; f < CLMREC_Coordinates.length; f++) {

                //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016)
                { // only use stations with this condition

                  float _lat = CLMREC_Coordinates[f].getLatitude();
                  float _lon = CLMREC_Coordinates[f].getLongitude();
                  if (_lon > 180) _lon -= 360; // << important!

                  float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                  if (nearest_WORLD_CLMREC_dist > d) {
                    nearest_WORLD_CLMREC_dist = d;
                    nearest_WORLD_CLMREC = f;
                  }
                }
              }

              {
                int f = nearest_WORLD_CLMREC;

                if (STATION.getFilename_CWEEDS().equals(CLMREC_Coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_CWEEDS(CLMREC_Coordinates[f].getFilename_CWEEDS()); // CLMREC filename

                  println("nearest CLMREC filename:", CLMREC_Coordinates[f].getFilename_CWEEDS());

                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {

                    STATION.setCity(CLMREC_Coordinates[f].getCity());
                    STATION.setProvince(CLMREC_Coordinates[f].getProvince());
                    STATION.setCountry(CLMREC_Coordinates[f].getCountry());

                    //STATION.setLatitude(CLMREC_Coordinates[f].getLatitude());
                    //STATION.setLongitude(CLMREC_Coordinates[f].getLongitude());
                    STATION.setElevation(CLMREC_Coordinates[f].getElevation());
                    STATION.setTimelong(CLMREC_Coordinates[f].getTimelong());

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.revise();

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CLMREC();
                  }
                }
              }
            }


            {
              int nearest_WORLD_TMYEPW = -1;
              float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;

              for (int f = 0; f < TMYEPW_Coordinates.length; f++) {

                float _lat = TMYEPW_Coordinates[f].getLatitude();
                float _lon = TMYEPW_Coordinates[f].getLongitude();
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_TMYEPW_dist > d) {
                  nearest_WORLD_TMYEPW_dist = d;
                  nearest_WORLD_TMYEPW = f;
                }
              }

              {
                int f = nearest_WORLD_TMYEPW;

                if (STATION.getFilename_TMYEPW().equals(TMYEPW_Coordinates[f].getFilename_TMYEPW())) {
                } else {

                  STATION.setLatitude(mouse_lat);
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_TMYEPW(TMYEPW_Coordinates[f].getFilename_TMYEPW()); // epw filename

                  println("nearest epw filename:", TMYEPW_Coordinates[f].getFilename_TMYEPW());

                  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
                    STATION.setCity(TMYEPW_Coordinates[f].getCity());
                    STATION.setProvince(TMYEPW_Coordinates[f].getProvince());
                    STATION.setCountry(TMYEPW_Coordinates[f].getCountry());

                    //STATION.setLatitude(TMYEPW_Coordinates[f].getLatitude());
                    //STATION.setLongitude(TMYEPW_Coordinates[f].getLongitude());
                    STATION.setElevation(TMYEPW_Coordinates[f].getElevation());
                    STATION.setTimelong(TMYEPW_Coordinates[f].getTimelong());

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.revise();

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_TMYEPW();
                  }
                }
              }
            }




            WORLD.revise();
            WIN3D.revise();
          }
        }

        if (WIN3D.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY)) {

            float Image_X = 0;
            float Image_Y = 0;

            Image_X = SOLARCHVISION_X_clicked - (WIN3D.cX + 0.5 * WIN3D.dX);
            Image_Y = SOLARCHVISION_Y_clicked - (WIN3D.cY + 0.5 * WIN3D.dY);

            if (WIN3D.UI_CurrentTask == UITASK.LookAtDirection) { // viewport:LookAtDirection

              WIN3D.look_3DViewport_towards_Direction(Image_X, Image_Y);

              SOLARCHVISION_view_changed();
            }
            else {

              float[] ray_direction = new float [3];

              float[] ray_start = {
                WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
              };

              float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

              ray_start[0] /= OBJECTS_scale;
              ray_start[1] /= OBJECTS_scale;
              ray_start[2] /= OBJECTS_scale;

              ray_end[0] /= OBJECTS_scale;
              ray_end[1] /= OBJECTS_scale;
              ray_end[2] /= OBJECTS_scale;

              if (WIN3D.ViewType == 0) {
                float[] ray_center = WIN3D.calculate_Click3D(0, 0);

                ray_center[0] /= OBJECTS_scale;
                ray_center[1] /= OBJECTS_scale;
                ray_center[2] /= OBJECTS_scale;

                ray_start[0] += ray_end[0] - ray_center[0];
                ray_start[1] += ray_end[1] - ray_center[1];
                ray_start[2] += ray_end[2] - ray_center[2];
              }

              ray_direction[0] = ray_end[0] - ray_start[0];
              ray_direction[1] = ray_end[1] - ray_start[1];
              ray_direction[2] = ray_end[2] - ray_start[2];

              float[] RxP = new float [8];

              if (mouseButton == RIGHT) {
                RxP = Land3D.intersect(ray_start, ray_direction);
              } else if (mouseButton == LEFT) {

                if ((WIN3D.UI_CurrentTask == UITASK.Create) ||
                    (WIN3D.UI_CurrentTask == UITASK.Move)) {

                   RxP = SOLARCHVISION_snap_Faces(allFaces.intersect(ray_start, ray_direction));

                } else {

                  if (current_ObjectCategory == ObjectCategory.CURVE) {
                    RxP = allCurves.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.CAMERA) {
                    RxP = allCameras.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.SECTION) {
                    RxP = allSections.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.SOLID) {
                    RxP = allSolids.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.MODEL1D) {
                    RxP = allModel1Ds.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.MODEL2D) {
                    RxP = allModel2Ds.intersect(ray_start, ray_direction);
                  } else {
                    RxP = SOLARCHVISION_snap_Faces(allFaces.intersect(ray_start, ray_direction));
                  }
                }



              }


              //println(ray_start[0], ray_start[1], ray_start[2], ">>", ray_end[0], ray_end[1], ray_end[2], ">>", RxP[1], RxP[2], RxP[3], RxP[4], RxP[0]);

              if (RxP[0] >= 0) {

                if (WIN3D.UI_CurrentTask == UITASK.Move) { // move

                  float x1 = FLOAT_undefined;
                  float y1 = FLOAT_undefined;
                  float z1 = FLOAT_undefined;

                  if (current_ObjectCategory == ObjectCategory.GROUP) {

                    float[] P = Select3D.getPivot();

                    x1 = P[0];
                    y1 = P[1];
                    z1 = P[2];
                  }

                  if (current_ObjectCategory == ObjectCategory.MODEL2D) {

                    x1 = allModel2Ds.getX(Select3D.Model2D_ids[Select3D.Model2D_ids.length - 1]);
                    y1 = allModel2Ds.getY(Select3D.Model2D_ids[Select3D.Model2D_ids.length - 1]);
                    z1 = allModel2Ds.getZ(Select3D.Model2D_ids[Select3D.Model2D_ids.length - 1]);
                  }

                  if (current_ObjectCategory == ObjectCategory.MODEL1D) {

                    x1 = allModel1Ds.getX(Select3D.Model1D_ids[Select3D.Model1D_ids.length - 1]);
                    y1 = allModel1Ds.getY(Select3D.Model1D_ids[Select3D.Model1D_ids.length - 1]);
                    z1 = allModel1Ds.getZ(Select3D.Model1D_ids[Select3D.Model1D_ids.length - 1]);
                  }

                  if (current_ObjectCategory == ObjectCategory.SOLID) {

                    x1 = allSolids.get_posX(Select3D.Solid_ids[Select3D.Solid_ids.length - 1]);
                    y1 = allSolids.get_posY(Select3D.Solid_ids[Select3D.Solid_ids.length - 1]);
                    z1 = allSolids.get_posZ(Select3D.Solid_ids[Select3D.Solid_ids.length - 1]);
                  }

                  if (current_ObjectCategory == ObjectCategory.VERTEX) {

                    x1 = allPoints.getX(Select3D.Vertex_ids[Select3D.Vertex_ids.length - 1]);
                    y1 = allPoints.getY(Select3D.Vertex_ids[Select3D.Vertex_ids.length - 1]);
                    z1 = allPoints.getZ(Select3D.Vertex_ids[Select3D.Vertex_ids.length - 1]);
                  }

                  if ((is_defined(x1)) &&
                      (is_defined(y1)) &&
                      (is_defined(z1))) {

                    float x2 = RxP[1];
                    float y2 = RxP[2];
                    float z2 = RxP[3];

                    float dx, dy, dz;

                    /*
                    float[] p = Select3D.translateOutside_ReferencePivot(x2, y2, z2);
                    dx = p[0] - x1;
                    dy = p[1] - y1;
                    dz = p[2] - z1;
                    */
                    dx = x2 - x1;
                    dy = y2 - y1;
                    dz = z2 - z1;



                    int the_Vector = Select3D.posVector;

                    if (the_Vector == 0) {
                      dy = 0;
                      dz = 0;
                    }
                    if (the_Vector == 1) {
                      dz = 0;
                      dx = 0;
                    }
                    if (the_Vector == 2) {
                      dx = 0;
                      dy = 0;
                    }

                    Move3D.selection(dx, dy, dz);

                    SOLARCHVISION_model_changed();
                  }
                }




                if (mouseButton == LEFT) { // modify should work only with left click because the right click returns the land info, not objects info

                  if ((WIN3D.UI_TaskModifyParameter != 0) && (WIN3D.UI_CurrentTask >= UITASK.Seed_Material)) { // Pick/Assign properties

                    if ((current_ObjectCategory == ObjectCategory.GROUP) ||
                        (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE)) {

                      int f = int(RxP[0]);

                      if ((WIN3D.UI_CurrentTask == UITASK.Seed_Material) ||
                          (WIN3D.UI_CurrentTask == UITASK.Tessellation) ||
                          (WIN3D.UI_CurrentTask == UITASK.Layer) ||
                          (WIN3D.UI_CurrentTask == UITASK.Visibility) ||
                          (WIN3D.UI_CurrentTask == UITASK.Weight)) {

                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) User3D.default_Material     = allFaces.getMaterial(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  User3D.default_Tessellation = allFaces.getTessellation(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         User3D.default_Layer        = allFaces.getLayer(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    User3D.default_Visibility   = allFaces.getVisibility(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        User3D.default_Weight       = allFaces.getWeight(f);
                        }
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign(sub)
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (f, User3D.default_Material);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(f, User3D.default_Tessellation);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (f, User3D.default_Layer);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (f, User3D.default_Visibility);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setWeight      (f, User3D.default_Weight);
                        }
                        if (WIN3D.UI_TaskModifyParameter == 3) { // Assign(all)
                          int OBJ_ID = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_ID = i;
                              break;
                            }
                          }

                          for (int q = allGroups.getStart_Face(OBJ_ID); q <= allGroups.getStop_Face(OBJ_ID); q++) {
                            if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (q, User3D.default_Material);
                            if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(q, User3D.default_Tessellation);
                            if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (q, User3D.default_Layer);
                            if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (q, User3D.default_Visibility);
                            if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setClose       (q, User3D.default_Weight);
                          }
                        }
                      }

                      if (WIN3D.UI_CurrentTask == UITASK.Pivot) {
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick
                          //?????????????????????????????????????????????????
                        }
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign
                          int OBJ_ID = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_ID = i;
                              break;
                            }
                          }


                          float[] P = Select3D.getPivot();

                          allGroups.Pivots[OBJ_ID][0] = P[0];
                          allGroups.Pivots[OBJ_ID][1] = P[1];
                          allGroups.Pivots[OBJ_ID][2] = P[2];

                          //zzzzzzzzzzzzzzzzzzz should add other components?

                        }
                      }

                      if (WIN3D.UI_CurrentTask == UITASK.Normal) { //Normal

                        if (current_ObjectCategory == ObjectCategory.FACE) {

                          Select3D.Face_ids = new int [1];
                          Select3D.Face_ids[0] = f;

                          Select3D.Face_displayVertexCount = true;

                          int n = allFaces.nodes[f].length;

                          if (n > 2) {
                            int[] tmpFace = new int[n];
                            float[] G = {
                              0, 0, 0
                            };
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                              G[0] += allPoints.getX(tmpFace[j]) / float(n);
                              G[1] += allPoints.getY(tmpFace[j]) / float(n);
                              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
                            }

                            int flip_face = 0;
                            if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                            else {
                              PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);
                              PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);

                              PVector GAxGB = AG.cross(BG);

                              float[] P = Select3D.getPivot();

                              float x0 = P[0];
                              float y0 = P[1];
                              float z0 = P[2];

                              PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                              float V = PG.dot(GAxGB);

                              if (WIN3D.UI_TaskModifyParameter == 2) {
                                if (V > 0) flip_face = 1;
                              }
                              if (WIN3D.UI_TaskModifyParameter == 3) {
                                if (V < 0) flip_face = 1;
                              }
                            }

                            if (flip_face == 1) {
                              for (int j = 0; j < n; j++) {
                                allFaces.nodes[f][j] = tmpFace[n - j - 1];
                              }
                            }
                          }
                        }

                        if (current_ObjectCategory == ObjectCategory.GROUP) {
                          int OBJ_ID = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_ID = i;
                              break;
                            }
                          }

                          for (int q = allGroups.getStart_Face(OBJ_ID); q <= allGroups.getStop_Face(OBJ_ID); q++) {
                            int n = allFaces.nodes[q].length;

                            if (n > 2) {
                              int[] tmpFace = new int[n];
                              float[] G = {
                                0, 0, 0
                              };
                              for (int j = 0; j < n; j++) {
                                tmpFace[j] = allFaces.nodes[q][j];
                                G[0] += allPoints.getX(tmpFace[j]) / float(n);
                                G[1] += allPoints.getY(tmpFace[j]) / float(n);
                                G[2] += allPoints.getZ(tmpFace[j]) / float(n);
                              }

                              int flip_face = 0;
                              if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                              else {
                                PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);
                                PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);

                                PVector GAxGB = AG.cross(BG);

                                float[] P = Select3D.getPivot();

                                float x0 = P[0];
                                float y0 = P[1];
                                float z0 = P[2];

                                PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                                float V = PG.dot(GAxGB);

                                if (WIN3D.UI_TaskModifyParameter == 2) {
                                  if (V > 0) flip_face = 1;
                                }
                                if (WIN3D.UI_TaskModifyParameter == 3) {
                                  if (V < 0) flip_face = 1;
                                }
                              }

                              if (flip_face == 1) {
                                for (int j = 0; j < n; j++) {
                                  allFaces.nodes[q][j] = tmpFace[n - j - 1];
                                }
                              }
                            }
                          }

                        }
                      }


                      if (WIN3D.UI_CurrentTask == UITASK.FirstVertex) { //FirstVertex

                        if (current_ObjectCategory == ObjectCategory.FACE) {

                          Select3D.Face_ids = new int [1];
                          Select3D.Face_ids[0] = f;

                          Select3D.Face_displayVertexCount = true;

                          int n = allFaces.nodes[f].length;

                          if (n > 2) {

                            int min_num = 0;
                            float min_dist = FLOAT_undefined;

                            for (int j = 0; j < n; j++) {
                              int vNo = allFaces.nodes[f][j];

                              float d = dist(RxP[1], RxP[2], RxP[3], allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }

                            int[] tmpFace = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                            }

                            for (int j = 0; j < n; j++) {
                              allFaces.nodes[f][j] = tmpFace[(j + min_num + n) % n];
                            }
                          }
                        }


                        if (current_ObjectCategory == ObjectCategory.CURVE) {

                          Select3D.Curve_ids = new int [1];
                          Select3D.Curve_ids[0] = f;

                          Select3D.Curve_displayVertexCount = true;

                          int n = allCurves.nodes[f].length;

                          if (n > 2) {

                            int min_num = 0;
                            float min_dist = FLOAT_undefined;

                            for (int j = 0; j < n; j++) {
                              int vNo = allCurves.nodes[f][j];

                              float d = dist(RxP[1], RxP[2], RxP[3], allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));

                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }

                            int[] tmpCurve = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpCurve[j] = allCurves.nodes[f][j];
                            }

                            for (int j = 0; j < n; j++) {
                              allCurves.nodes[f][j] = tmpCurve[(j + min_num + n) % n];
                            }
                          }
                        }

                      }
                    }










                    if (current_ObjectCategory == ObjectCategory.MODEL2D) {

                      int OBJ_ID = int(RxP[0]);

                      int n = allModel2Ds.MAP[OBJ_ID];
                      int sign_n = 1;
                      if (n < 0) sign_n = -1;
                      n = abs(n);
                      int n1 = allModel2Ds.num_files_PEOPLE;
                      int n2 = allModel2Ds.num_files_PEOPLE + allModel2Ds.num_files_TREES;

                      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {

                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick
                          if (allModel2Ds.isTree(n)) { // case: trees
                            User3D.create_Plant_Type = n - n1;
                          }
                          else { // case: people
                            User3D.create_Person_Type = n;
                          }
                        }
                        if ((WIN3D.UI_TaskModifyParameter == 2) || (WIN3D.UI_TaskModifyParameter == 3)) { // Assign
                          if (allModel2Ds.isTree(n)) { // case: trees
                            allModel2Ds.MAP[OBJ_ID] = sign_n * (User3D.create_Plant_Type + n1);
                          }
                          else { // case: people
                            allModel2Ds.MAP[OBJ_ID] = sign_n * User3D.create_Person_Type;
                          }
                        }
                      }
                    }


                    if (current_ObjectCategory == ObjectCategory.MODEL1D) {

                      int OBJ_ID = int(RxP[0]);

                      if (WIN3D.UI_TaskModifyParameter == 1) { // Pick
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) User3D.create_Model1D_DegreeMax = allModel1Ds.getDegreeMax(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchTilt) User3D.create_Model1D_BranchTilt = allModel1Ds.getBranchTilt(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchTwist) User3D.create_Model1D_BranchTwist = allModel1Ds.getBranchTwist(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchRatio) User3D.create_Model1D_BranchRatio = allModel1Ds.getBranchRatio(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.TreeBase) User3D.create_Model1D_TreeBase = allModel1Ds.getTreeBase(OBJ_ID);

                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) User3D.create_Model1D_TrunkSize = allModel1Ds.getTrunkSize(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) User3D.create_Model1D_LeafSize = allModel1Ds.getLeafSize(OBJ_ID);
                        if (WIN3D.UI_CurrentTask == UITASK.Model1DsProps) { // all properties
                          User3D.create_Model1D_DegreeMax = allModel1Ds.getDegreeMax(OBJ_ID);
                          User3D.create_Model1D_TrunkSize = allModel1Ds.getTrunkSize(OBJ_ID);
                          User3D.create_Model1D_LeafSize = allModel1Ds.getLeafSize(OBJ_ID);
                        }
                      }
                      if (WIN3D.UI_TaskModifyParameter == 2) { // Assign
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) allModel1Ds.setDegreeMax(OBJ_ID, User3D.create_Model1D_DegreeMax);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchTilt) allModel1Ds.setBranchTilt(OBJ_ID, User3D.create_Model1D_BranchTilt);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchTwist) allModel1Ds.setBranchTwist(OBJ_ID, User3D.create_Model1D_BranchTwist);
                        if (WIN3D.UI_CurrentTask == UITASK.BranchRatio) allModel1Ds.setBranchRatio(OBJ_ID, User3D.create_Model1D_BranchRatio);
                        if (WIN3D.UI_CurrentTask == UITASK.TreeBase) allModel1Ds.setTreeBase(OBJ_ID, User3D.create_Model1D_TreeBase);

                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) allModel1Ds.setTrunkSize(OBJ_ID, User3D.create_Model1D_TrunkSize);
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) allModel1Ds.setLeafSize(OBJ_ID, User3D.create_Model1D_LeafSize);
                        if (WIN3D.UI_CurrentTask == UITASK.Model1DsProps) { // all properties
                          allModel1Ds.setDegreeMax(OBJ_ID, User3D.create_Model1D_DegreeMax);
                          allModel1Ds.setTrunkSize(OBJ_ID, User3D.create_Model1D_TrunkSize);
                          allModel1Ds.setLeafSize(OBJ_ID, User3D.create_Model1D_LeafSize);
                        }
                      }
                    }

                    SOLARCHVISION_model_changed();

                  } else if ((WIN3D.UI_CurrentTask != UITASK.Create) && (WIN3D.UI_CurrentTask != UITASK.Move)) { // PickSelect also if scale, rotate, modify, etc. where selected

                    Select3D.selectPick(RxP);
                  }
                }

                if (WIN3D.UI_CurrentTask == UITASK.Create) { // create

                  int keep_number_of_allGroups = allGroups.num;
                  int keep_number_of_allModel2Ds = allModel2Ds.num;
                  int keep_number_of_allModel1Ds = allModel1Ds.num;
                  int keep_number_of_allSolids = allSolids.DEF.length;
                  int keep_number_of_allSections = allSections.num;
                  int keep_number_of_allCameras = allCameras.num;

                  float x = RxP[1];
                  float y = RxP[2];
                  float z = RxP[3];

                  float rot = User3D.create_Orientation;
                  if (rot == 360) rot = WIN3D.rotation_Z;



                  float rx = 0.5 * User3D.create_Length;
                  if (rx < 0) rx = random(0.25 * abs(rx), abs(rx));

                  float ry = 0.5 * User3D.create_Width;
                  if (ry < 0) ry = random(0.25 * abs(ry), abs(ry));

                  float rz = 0.5 * User3D.create_Height;
                  if (rz < 0) rz = random(0.25 * abs(rz), abs(rz));



                  float px = User3D.create_powX;
                  float py = User3D.create_powY;
                  float pz = User3D.create_powZ;

                  if (User3D.create_powRnd == 1) {
                    px = pow(2, int(random(5)) - 1);
                    py = px;
                    pz = px;
                  }

                  if (User3D.create_Volume != 0) {

                    if ((rx != 0) && (ry != 0)) {
                      rz = User3D.create_Volume / (8 * rx * ry);
                    }

                    //---------------------------------------------------
                    float A = 1;
                    // cube volume: 8*r^3, sphere volume: 4*r^3, so maybe:
                    if (pz >= 8) A = 1;
                    else if (pz == 4) A = 0.75;
                    else if (pz == 2) A = 0.5;
                    else if (pz == 1) A = 0.25;
                    else if (pz == 0.5) A = 0.125;
                    else if (pz == 0.25) A = 0.0625;

                    rx /= pow(A, (1.0 / 3.0));
                    ry /= pow(A, (1.0 / 3.0));
                    rz /= pow(A, (1.0 / 3.0));
                    //---------------------------------------------------
                  }


                  if ((current_ObjectCategory != ObjectCategory.MODEL1D) &&
                      (current_ObjectCategory != ObjectCategory.MODEL2D) &&
                      (current_ObjectCategory != ObjectCategory.LANDPOINT) &&
                      (current_ObjectCategory != ObjectCategory.CAMERA) &&
                      (current_ObjectCategory != ObjectCategory.SECTION)) {

                    x -= rx * Select3D.alignX;
                    y -= ry * Select3D.alignY;
                    z -= rz * Select3D.alignZ;
                  }



                  //if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.SOLID) || (current_ObjectCategory == ObjectCategory.MODEL1D) || (current_ObjectCategory == ObjectCategory.MODEL2D)) {
                  if (current_ObjectCategory == ObjectCategory.GROUP) {

                    if (addToLastGroup == false) {

                      allGroups.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
                    }
                  }


                  if (current_ObjectCategory == ObjectCategory.GROUP) { // working with meshes

                    if (CreateObject == CREATE.SuperOBJ) {

                      if ((px == CubePower) && (py == CubePower) && (pz == 2)) {

                        Create3D.add_ParametricSurface(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, 2, rot);
                      } else if ((px == 2) && (py == 2) && (pz == CubePower)) {

                        Create3D.add_SuperCylinder(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, User3D.create_CylinderDegree, rot);
                      } else if ((px == CubePower) && (py == CubePower) && (pz == CubePower)) {

                        Create3D.add_Box_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, rot);
                      } else if ((px == 1) && (py == 1) && (pz == 1)) {

                        Create3D.add_Octahedron(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, rot);
                      } else {

                        Create3D.add_SuperSphere(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, pz, py, pz, rx, ry, rz, User3D.create_SphereDegree, rot);
                      }




                      if (User3D.create_MeshOrSolid != 0) {

                        allSolids.create(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                      }
                    }



                    if (CreateObject == CREATE.Tri) {

                      Create3D.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y-ry, z-rz, x+rx, y-ry, z-rz, x, y, z+rz);
                      Create3D.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x+rx, y-ry, z-rz, x+rx, y+ry, z-rz, x, y, z+rz);
                      Create3D.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x+rx, y+ry, z-rz, x-rx, y+ry, z-rz, x, y, z+rz);
                      Create3D.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y+ry, z-rz, x-rx, y-ry, z-rz, x, y, z+rz);
                    }


                    if (CreateObject == CREATE.Plane) {

                      Create3D.add_Mesh4(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y-ry, z, x+rx, y-ry, z, x+rx, y+ry, z, x-rx, y+ry, z);
                    }

                    if (CreateObject == CREATE.Poly) {

                      Create3D.add_PolygonMesh(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, User3D.create_PolyDegree, rot);
                    }

                    if (CreateObject == CREATE.Hyper) {

                      Create3D.add_PolygonHyper(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, 2 * rz, User3D.create_PolyDegree, rot);
                    }


                    if (CreateObject == CREATE.Extrude) {

                      Create3D.add_PolygonExtrude(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, 2 * rz, User3D.create_PolyDegree, rot);
                    }

                    if (CreateObject == CREATE.House3) {

                      float h = ry;

                      Create3D.add_House3_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, h, rot);
                    }

                    if (CreateObject == CREATE.House2) {

                      float h = ry;

                      Create3D.add_House2_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, h, rot);
                    }

                    if (CreateObject == CREATE.House1) {

                      float h = ry;

                      if (ry > rx) h = rx;

                      Create3D.add_House1_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, h, rot);
                    }

                    if (CreateObject == CREATE.Parametric) {

                      Create3D.add_ParametricSurface(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, User3D.create_Parametric_Type, rot);
                    }

                  }

                  if (current_ObjectCategory == ObjectCategory.MODEL2D) { // working with model2Ds
                    if (CreateObject == CREATE.Person) {

                      randomSeed(millis());
                      allModel2Ds.create("PEOPLE", User3D.create_Person_Type, x, y, z, 2.5);
                    }

                    if (CreateObject == CREATE.Plant) {
                      int n = 0;
                      if (User3D.create_Plant_Type > 0) n = User3D.create_Plant_Type + allModel2Ds.num_files_PEOPLE;

                      randomSeed(millis());
                      allModel2Ds.create("TREES", n, x, y, z, 2 * rz);
                    }
                  }

                  if (current_ObjectCategory == ObjectCategory.MODEL1D) { // working with model1Ds
                    if (CreateObject == CREATE.Model1Ds) {

                      randomSeed(millis());
                      allModel1Ds.create(User3D.create_Model1D_Type, User3D.create_Model1D_Seed,
                                         User3D.create_Model1D_DegreeMax,
                                         x, y, z, 2 * rz, floor(random(360)),
                                         User3D.create_Model1D_BranchTilt, User3D.create_Model1D_BranchTwist,
                                         User3D.create_Model1D_BranchRatio, User3D.create_Model1D_TreeBase,
                                         User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                    }
                  }

                  if (current_ObjectCategory == ObjectCategory.VERTEX) { // working with vertices
                    if (CreateObject == CREATE.Vertex) {
                      allPoints.create(x, y, z);

                    }
                  }


                  if (current_ObjectCategory == ObjectCategory.FACE) { // working with faces
                    if (CreateObject == CREATE.Face) {
                      allFaces.add_VertexToLastFace(x, y, z);

                      Select3D.Face_ids = new int [1];
                      Select3D.Face_ids[0] = allFaces.nodes.length - 1;

                      Select3D.calculate_BoundingBox();
                    }
                  }

                  if (current_ObjectCategory == ObjectCategory.CURVE) { // working with curves
                    if (CreateObject == CREATE.Curve) {
                      allCurves.add_VertexToLastCurve(x, y, z);

                      Select3D.Curve_ids = new int [1];
                      Select3D.Curve_ids[0] = allCurves.nodes.length - 1;

                      Select3D.calculate_BoundingBox();
                    }
                  }



                  if (current_ObjectCategory == ObjectCategory.SOLID) { // working with solids
                    if (CreateObject == CREATE.Solid) {
                      allSolids.create(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                    }
                  }


                  if (current_ObjectCategory == ObjectCategory.CAMERA) { // working with cameras
                    if (CreateObject == CREATE.Camera) {

                      int f = int(RxP[0]);

                      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
                      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
                      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
                      float keep_WIN3D_position_X = WIN3D.position_X;
                      float keep_WIN3D_position_Y = WIN3D.position_Y;
                      float keep_WIN3D_position_Z = WIN3D.position_Z;
                      float keep_WIN3D_position_T = WIN3D.position_T;
                      float keep_WIN3D_rotation_X = WIN3D.rotation_X;
                      float keep_WIN3D_rotation_Y = WIN3D.rotation_Y;
                      float keep_WIN3D_rotation_Z = WIN3D.rotation_Z;
                      float keep_WIN3D_rotation_T = WIN3D.rotation_T;
                      float keep_WIN3D_Zoom = WIN3D.Zoom;

                      {

                        WIN3D.CAM_x = RxP[1];
                        WIN3D.CAM_y = RxP[2];
                        WIN3D.CAM_z = RxP[3] + EyeLevel;

                        WIN3D.reverseTransform_3DViewport();

                        float Camera_pX = WIN3D.position_X;
                        float Camera_pY = WIN3D.position_Y;
                        float Camera_pZ = WIN3D.position_Z;
                        float Camera_pT = WIN3D.position_T;
                        float Camera_rX = WIN3D.rotation_X;
                        float Camera_rY = WIN3D.rotation_Y;
                        float Camera_rZ = WIN3D.rotation_Z;
                        float Camera_rT = WIN3D.rotation_T;
                        float Camera_zoom = WIN3D.Zoom;

                        int Camera_type = WIN3D.ViewType;

                        allCameras.create(Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_zoom, Camera_type);
                      }

                      WIN3D.CAM_x = keep_WIN3D_CAM_x;
                      WIN3D.CAM_y = keep_WIN3D_CAM_y;
                      WIN3D.CAM_z = keep_WIN3D_CAM_z;
                      WIN3D.position_X = keep_WIN3D_position_X;
                      WIN3D.position_Y = keep_WIN3D_position_Y;
                      WIN3D.position_Z = keep_WIN3D_position_Z;
                      WIN3D.position_T = keep_WIN3D_position_T;
                      WIN3D.rotation_X = keep_WIN3D_rotation_X;
                      WIN3D.rotation_Y = keep_WIN3D_rotation_Y;
                      WIN3D.rotation_Z = keep_WIN3D_rotation_Z;
                      WIN3D.rotation_T = keep_WIN3D_rotation_T;
                      WIN3D.Zoom = keep_WIN3D_Zoom;
                    }
                  }


                  if (current_ObjectCategory == ObjectCategory.SECTION) { // working with sections
                    if (CreateObject == CREATE.Section) {

                      int createNewSection = 0;

                      float Section_X = allSolidImpacts.X[allSolidImpacts.sectionType];
                      float Section_Y = allSolidImpacts.Y[allSolidImpacts.sectionType];
                      float Section_Z = allSolidImpacts.Z[allSolidImpacts.sectionType];
                      float Section_R = allSolidImpacts.R[allSolidImpacts.sectionType];
                      float Section_U = allSolidImpacts.U[allSolidImpacts.sectionType];
                      float Section_V = allSolidImpacts.V[allSolidImpacts.sectionType];

                      int Section_Type = allSolidImpacts.sectionType;
                      int Section_RES1 = allSolidImpacts.RES1;
                      int Section_RES2 = allSolidImpacts.RES2;

                      if (mouseButton == LEFT) {

                        int f = int(RxP[0]);

                        int n = allFaces.nodes[f].length;

                        if (n > 2) {

                          //float min_Alpha = 90;
                          float min_Beta = 360;

                          for (int j = 0; j < n; j++) {

                            int j_next = (j + 1) % n;

                            float x1 = allPoints.getX(allFaces.nodes[f][j]);
                            float y1 = allPoints.getY(allFaces.nodes[f][j]);
                            float z1 = allPoints.getZ(allFaces.nodes[f][j]);

                            float x2 = allPoints.getX(allFaces.nodes[f][j_next]);
                            float y2 = allPoints.getY(allFaces.nodes[f][j_next]);
                            float z2 = allPoints.getZ(allFaces.nodes[f][j_next]);


                            //float Alpha = funcs.asin_ang(z2 - z1);
                            float Beta = funcs.atan2_ang(y2 - y1, x2 - x1) + 90;

                            //if (min_Alpha > Alpha) min_Alpha = Alpha;
                            if (min_Beta > Beta) min_Beta = Beta;
                          }

                          //println("min_Alpha", min_Alpha);

                          float[][] tmpVertices = new float[n][3];


                          for (int j = 0; j < n; j++) {

                            float x1 = allPoints.getX(allFaces.nodes[f][j]);
                            float y1 = allPoints.getY(allFaces.nodes[f][j]);
                            float z1 = allPoints.getZ(allFaces.nodes[f][j]);

                            float x2 = x1 * funcs.cos_ang(-min_Beta) - y1 * funcs.sin_ang(-min_Beta);
                            float y2 = x1 * funcs.sin_ang(-min_Beta) + y1 * funcs.cos_ang(-min_Beta);
                            float z2 = z1;

                            tmpVertices[j][0] = x2;
                            tmpVertices[j][1] = y2;
                            tmpVertices[j][2] = z2;
                          }

                          float min_x = FLOAT_undefined;
                          float max_x = -FLOAT_undefined;
                          float min_y = FLOAT_undefined;
                          float max_y = -FLOAT_undefined;
                          float min_z = FLOAT_undefined;
                          float max_z = -FLOAT_undefined;

                          float[] G = {
                            0, 0, 0
                          };
                          for (int j = 0; j < n; j++) {
                            float the_x = tmpVertices[j][0];
                            float the_y = tmpVertices[j][1];
                            float the_z = tmpVertices[j][2];

                            G[0] += the_x / float(n);
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);

                            if (min_x > the_x) min_x = the_x;
                            if (max_x < the_x) max_x = the_x;
                            if (min_y > the_y) min_y = the_y;
                            if (max_y < the_y) max_y = the_y;
                            if (min_z > the_z) min_z = the_z;
                            if (max_z < the_z) max_z = the_z;
                          }



                          if ((max_z - min_z < max_x - min_x) && (max_z - min_z < max_y - min_y)) {
                            Section_Type = 1;

                            Section_U = max_x - min_x;
                            Section_V = max_y - min_y;

                            Section_X = G[0];
                            Section_Y = G[1];

                            Section_Z = G[2];

                            Section_R = min_Beta;
                          } else {
                            Section_Type = 2;

                            Section_U = max_y - min_y;
                            Section_V = max_z - min_z;

                            Section_X = -G[1];
                            Section_Y = G[2];

                            Section_Z = -G[0];

                            Section_R = 90 - min_Beta;
                          }


                          // recalculating G...
                          G[0] = 0;
                          G[1] = 0;
                          G[2] = 0;
                          for (int j = 0; j < n; j++) {
                            float the_x = allPoints.getX(allFaces.nodes[f][j]);
                            float the_y = allPoints.getY(allFaces.nodes[f][j]);
                            float the_z = allPoints.getZ(allFaces.nodes[f][j]);

                            G[0] += the_x / float(n);
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);
                          }

                          PVector AG = new PVector(allPoints.getX(allFaces.nodes[f][0]) - G[0], allPoints.getY(allFaces.nodes[f][0]) - G[1], allPoints.getZ(allFaces.nodes[f][0]) - G[2]);
                          PVector BG = new PVector(allPoints.getX(allFaces.nodes[f][1]) - G[0], allPoints.getY(allFaces.nodes[f][1]) - G[1], allPoints.getZ(allFaces.nodes[f][1]) - G[2]);

                          PVector GAxGB = AG.cross(BG);

                          float[][] ImageVertex = allSections.getCorners(Section_Type, Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_RES1, Section_RES2);

                          float[] SectionCorner_A = ImageVertex[1];
                          float[] SectionCorner_B = ImageVertex[2];
                          float[] SectionCorner_C = ImageVertex[3];
                          float[] SectionCorner_D = ImageVertex[4];

                          float[] ImageCenter = {
                            0, 0, 0
                          };
                          for (int j = 0; j < 3; j++) {
                            ImageCenter[j] = 0.25 * (SectionCorner_A[j] + SectionCorner_B[j] + SectionCorner_C[j] + SectionCorner_D[j]);
                          }

                          PVector AG_other = new PVector(SectionCorner_A[0] - ImageCenter[0], SectionCorner_A[1] - ImageCenter[1], SectionCorner_A[2] - ImageCenter[2]);
                          PVector BG_other = new PVector(SectionCorner_B[0] - ImageCenter[0], SectionCorner_B[1] - ImageCenter[1], SectionCorner_B[2] - ImageCenter[2]);

                          PVector GAxGB_other = AG_other.cross(BG_other);

                          //println("GAxGB", GAxGB);
                          //println("GAxGB_other", GAxGB_other);

                          float V = GAxGB_other.dot(GAxGB);

                          //println("V", nf(V, 0, 6));

                          if (V < 0) {
                            println("flip face!");

                            Section_R = 180 + Section_R;
                            Section_Z *= -1;
                            Section_X *= -1;
                          } else {
                            println("face OK!");
                          }

                          createNewSection = 1;

                        }
                      }

                      if (mouseButton == RIGHT) {

                        Section_Type = 1;

                        Section_X = RxP[1];
                        Section_Y = RxP[2];
                        Section_Z = RxP[3];


                        createNewSection = 1;
                      }

                      if (createNewSection != 0) {

                        allSections.create(Section_X, Section_Y, Section_Z, Section_R, Section_U, Section_V, Section_Type, Section_RES1, Section_RES2);

                        if (keep_number_of_allSections != allSections.num) { // if any Section created during the process

                          Select3D.deselect_Sections();

                          for (int o = keep_number_of_allSections; o < allSections.num; o++) {

                            int[] newlyAddedSection = {o};

                            Select3D.Section_ids = concat(Select3D.Section_ids, newlyAddedSection);
                          }

                          Select3D.calculate_BoundingBox();
                        }

                        allSolidImpacts.X[allSolidImpacts.sectionType] = Section_X;
                        allSolidImpacts.Y[allSolidImpacts.sectionType] = Section_Y;
                        allSolidImpacts.Z[allSolidImpacts.sectionType] = Section_Z;
                        allSolidImpacts.R[allSolidImpacts.sectionType] = Section_R;
                        allSolidImpacts.U[allSolidImpacts.sectionType] = Section_U;
                        allSolidImpacts.V[allSolidImpacts.sectionType] = Section_V;

                        allSolidImpacts.sectionType = Section_Type;
                        allSolidImpacts.RES1 = Section_RES1;
                        allSolidImpacts.RES2 = Section_RES2;

                        allSolidImpacts.calculate_Impact_selectedSections();

                        allSolarImpacts.sectionType = Section_Type;
                      }
                    }
                  }




                  if (keep_number_of_allSolids != allSolids.DEF.length) { // if any Solid created during the process

                    Select3D.deselect_Solids();

                    for (int o = keep_number_of_allSolids; o < allSolids.DEF.length; o++) {

                      int[] newlyAddedSolid = {o};

                      Select3D.Solid_ids = concat(Select3D.Solid_ids, newlyAddedSolid);
                    }

                    Select3D.calculate_BoundingBox();
                  }



                  if (keep_number_of_allCameras != allCameras.num) { // if any Camera created during the process

                    Select3D.deselect_Cameras();

                    for (int o = keep_number_of_allCameras; o < allCameras.num; o++) {

                      int[] newlyAddedCamera = {o};

                      Select3D.Camera_ids = concat(Select3D.Camera_ids, newlyAddedCamera);
                    }

                    Select3D.calculate_BoundingBox();
                  }


                  if (keep_number_of_allGroups != allGroups.num) { // if any Group created during the process

                    Select3D.deselect_Groups();

                    for (int o = keep_number_of_allGroups; o < allGroups.num; o++) {

                      int[] newlyAddedGroup = {o};

                      Select3D.Group_ids = concat(Select3D.Group_ids, newlyAddedGroup);
                    }

                    Select3D.calculate_BoundingBox();
                  }

                  if (keep_number_of_allModel2Ds != allModel2Ds.num) { // if any allModel2Ds created during the process

                    Select3D.deselect_Model2Ds();

                    for (int o = keep_number_of_allModel2Ds; o < allModel2Ds.num; o++) {

                      int[] newlyAddedallModel2Ds = {o};

                      Select3D.Model2D_ids = concat(Select3D.Model2D_ids, newlyAddedallModel2Ds);
                    }

                    Select3D.calculate_BoundingBox();
                  }


                  if (keep_number_of_allModel1Ds != allModel1Ds.num) { // if any allModel1Ds created during the process

                    Select3D.deselect_Model1Ds();

                    for (int o = keep_number_of_allModel1Ds; o < allModel1Ds.num; o++) {

                      int[] newlyAddedallModel1Ds = {o};

                      Select3D.Model1D_ids = concat(Select3D.Model1D_ids, newlyAddedallModel1Ds);
                    }

                    Select3D.calculate_BoundingBox();
                  }




                }
              }

              SOLARCHVISION_view_changed();
            }
          }
        }

        redraw();
      }
    }
  }
}

boolean isInside (float x, float y, float x1, float y1, float x2, float y2) {
  if ((x1 < x) && (x < x2) && (y1 < y) && (y < y2)) {
    return true;
  }
  return false;
}















//---------------------------------------------------------------------


void SOLARCHVISION_download_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {

  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR;

/*
  String the_directory = getGrib2Folder(GRIB2_DomainSelection);
  {
    String[] tmpMessage = {
      nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
    };
    saveStrings(the_directory + "/TempEmpty.txt", tmpMessage);
  }


  for (int h = 0; h < GRIB2_TGL_number; h++) {

    if (GRIB2_TGL_Selected[h] != 0) {

      for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
        GRIB2_Layer = l;

        for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
          GRIB2_Hour = k;

          boolean new_files_downloaded = false;

          String the_link = "";

          String the_filename = getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);

          String the_target = the_directory + "/" + the_filename;

          File dir = new File(the_target);
          if (!dir.isFile()) {

            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDWPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("HRDPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GDPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("REPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GEPS")) {
              the_link = "https://dd.weather.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }


            println("Try downloading: " + the_link);

            try {
              saveBytes(the_target, loadBytes(the_link));
            }
            catch (Exception e) {
              println("LINK NOT AVAILABLE:", the_link);
            }

          }

        }
      }
    }
  }
*/
}




void SOLARCHVISION_load_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {


  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR;

/*


  AERIAL_Data = new float [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Flags = new int [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Locations = new float [AERIAL_num][3]; // lon, lat, tgl
  AERIAL_Center_Longitude = STATION.getLongitude();
  AERIAL_Center_Latitude = STATION.getLatitude();

  for (int h = 0; h < GRIB2_TGL_number; h++) {
    GRIB2_TGL_Selected[h] = 0; // deselect all layers first.
  }

  for (int n = 0; n < AERIAL_num; n++) {
    for (int k = 0; k <= 48; k++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int o = 0; o < GRIB2_maxScenarios; o++) {
          AERIAL_Data[k][l][n][o] = FLOAT_undefined;
          AERIAL_Flags[k][l][n][o] = -1;
        }
      }
    }


    float stp_lat = 20.0 / 2224.5968; // equals to 1km <<<<<<<<
    float stp_lon = stp_lat / funcs.cos_ang(AERIAL_Center_Latitude);


    float r1 = float(GRIB2_Domains[GRIB2_DomainSelection][5]);
    float r = 0;
    float t = 0;

    int p = n / (1 + 6 + 12);
    int q = n % (1 + 6 + 12);

    if ((q > 0) && (q <= 6)) {
      r = 1 * r1;
      t = 360 * q / 6.0;
    }

    if ((q > 6) && (q <= 18)) {
      r = 2 * r1;
      t = 360 * (q - 6) / 12.0;
    }

    if ((q > 18) && (q <= 36)) {
      r = 3 * r1;
      t = 360 * (q - 18) / 18.0;
    }

    float _tgl = 40 * p;

    if (_tgl == 0) _tgl = 10; // <<<<<<

    AERIAL_Locations[n][0] = AERIAL_Center_Longitude + stp_lon * r * funcs.cos_ang(t);
    AERIAL_Locations[n][1] = AERIAL_Center_Latitude + stp_lat * r * funcs.sin_ang(t);
    AERIAL_Locations[n][2] = _tgl;

    GRIB2_TGL_Selected[p] = 1;
  }




  if (ENSEMBLE_FORECAST_load) {

    String the_directory = getGrib2Folder(GRIB2_DomainSelection);
    {
      String[] tmpMessage = {
        nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
      };
      saveStrings(Folder_Wgrib2Temp + "/TempEmpty.txt", tmpMessage);
    }


    for (int h = 0; h < GRIB2_TGL_number; h++) {

      if (GRIB2_TGL_Selected[h] != 0) {

        for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
          GRIB2_Layer = l;

          for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
            GRIB2_Hour = k;

            boolean new_files_downloaded = false;

            String the_link = "";

            String the_target = the_directory + "/" + getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);

            File dir = new File(the_target);
            if (dir.isFile()) {

              float[][] Points = {
                {
                  0, 0, 0
                }
              };

              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(funcs.roundTo(AERIAL_Locations[n][2] / 40.0, 1));

                if (p == h) {

                  float[][] newPoint = {
                    {
                      AERIAL_Locations[n][0], AERIAL_Locations[n][1], AERIAL_Locations[n][2]
                    }
                  };
                  Points = (float[][]) concat(Points, newPoint);

                }
              }


              float[][] GRIB2_values = getGrib2Value_MultiplePoints(GRIB2_Hour, GRIB2_Layer, h, Points, the_link);

              int nPoint = 0;

              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(funcs.roundTo(AERIAL_Locations[n][2] / 40.0, 1));

                if (p == h) {

                  nPoint += 1;

                  for (int o = 0; o < GRIB2_maxScenarios; o++) {
                    AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] = GRIB2_values[nPoint][o];
                  }
                }
              }
            }
          }
        }
      }
    }







    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;

      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;

        for (int n = 0; n < AERIAL_num; n++) {
          for (int o = 0; o < GRIB2_maxScenarios; o++) {
            if (is_defined(AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o])) {
              AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = 1;
            } else AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = -1;
          }
        }
      }
    }

    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;

      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;

        for (int n = 0; n < 1; n++) { // <<<<<<<<<<<<<<<< For now: only the first point (i.e. the center)
          for (int o = 0; o < GRIB2_maxScenarios; o++) {

            int THE_YEAR = GRIB2_Year;
            int THE_MONTH = GRIB2_Month;
            int THE_DAY = GRIB2_Day;
            int THE_HOUR = GRIB2_ModelRun;

            int now_i = int(THE_HOUR);
            int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

            now_i -= int(-STATION.getTimelong() / 15);
            if (now_i < 0) {
              now_i += 24;
              now_j -= 1;
              if (now_j < 0) {
                now_j += 365;
              }
            }

            int next_i = now_i + k;
            int next_j = now_j;
            if (next_i >= 24) {

              next_j += int(next_i / 24);
              if (next_j >= 365) {
                next_j = next_j % 365;
              }

              next_i = next_i % 24;
            }


            ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o] = AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]; // <<<<<<<<<<< writing after member 43

            println(GRIB2_Domains[GRIB2_DomainSelection][0] + "[" + nf(o, 0) + "]:", ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o]);
            println("GDPS:", ENSEMBLE_FORECAST_values[next_i][next_j][l][21]);
          }
        }
      }
    }


    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);

    WORLD.displayAll_NAEFS = 1;
    WORLD.displayNear_NAEFS = true;
  }

  SOLARCHVISION_model_changed();
  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();

  SampleMember_Start = 44; //ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;

  */
}















void SOLARCHVISION_draw_Perspective_Internally () {

  if (current_ObjectCategory == ObjectCategory.LANDPOINT) {

    if (Select3D.LandPoint_displayPoints) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = Select3D.LandPoint_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.LandPoint_ids[o];


        int i = OBJ_ID / Land3D.num_columns;
        int j = OBJ_ID % Land3D.num_columns;

        float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
        float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
        float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R)) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }

      }

      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.CAMERA) {

    if (Select3D.Camera_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0);
      strokeWeight(2);

      {
        for (int o = Select3D.Camera_ids.length - 1; o >= 0; o--) {

          int f = Select3D.Camera_ids[o];

          beginShape();

          for (int j = 0; j < allCameras.Faces[f].length; j++) {

            int vNo = allCameras.Faces[f][j];

            float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
            float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.SECTION) {

    if (Select3D.Section_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0);
      strokeWeight(2);

      {
        for (int o = Select3D.Section_ids.length - 1; o >= 0; o--) {

          int f = Select3D.Section_ids[o];

          beginShape();

          for (int j = 0; j < allSections.Faces[f].length; j++) {

            int vNo = allSections.Faces[f][j];

            float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
            float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.SOLID) {

    if (Select3D.Solid_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0);
      strokeWeight(2);

      {
        for (int o = Select3D.Solid_ids.length - 1; o >= 0; o--) {

          int OBJ_ID = Select3D.Solid_ids[o];

          for (int plane_type = 0; plane_type < allSolids.num_visualFaces; plane_type++) {

            int f = OBJ_ID * allSolids.num_visualFaces + plane_type;

            beginShape();

            for (int j = 0; j < allSolids.Faces[f].length; j++) {

              int vNo = allSolids.Faces[f][j];

              float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
              float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

      }


      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.MODEL2D) {

    if (Select3D.Model2D_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0);
      strokeWeight(2);

      {
        for (int o = Select3D.Model2D_ids.length - 1; o >= 0; o--) {

          int OBJ_ID = Select3D.Model2D_ids[o];

          for (int plane_type = 0; plane_type < allModel2Ds.num_visualFaces; plane_type++) {

            int f = OBJ_ID * allModel2Ds.num_visualFaces + plane_type;

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.MODEL1D) {

    if (Select3D.Model1D_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0);
      strokeWeight(2);

      {
        for (int o = Select3D.Model1D_ids.length - 1; o >= 0; o--) {

          int f = Select3D.Model1D_ids[o];

          beginShape();

          for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

            int vNo = allModel1Ds.Faces[f][j];

            float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
            float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);

        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.FACE) {

    if (Select3D.Face_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(127, 0, 255);
      strokeWeight(2);

      for (int o = Select3D.Face_ids.length - 1; o >= 0; o--) {

        int f = Select3D.Face_ids[o];

        int tessellation = allFaces.getTessellation(f);

        int totalNumberOfSubs = 1;
        if (allFaces.getMaterial(f) == 0) {
          tessellation += allFaces.displayTessellation;
        }
        if (tessellation > 0) totalNumberOfSubs = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

        float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];
          base_Vertices[j][0] = allPoints.getX(vNo);
          base_Vertices[j][1] = allPoints.getY(vNo);
          base_Vertices[j][2] = allPoints.getZ(vNo);
        }

        for (int n = 0; n < totalNumberOfSubs; n++) {

          float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

          beginShape();

          for (int s = 0; s < subFace.length; s++) {

            float x = subFace[s][0] * OBJECTS_scale;
            float y = subFace[s][1] * OBJECTS_scale;
            float z = -subFace[s][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }

      }

      strokeWeight(0);

      popMatrix();
    }


    if (Select3D.Face_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      fill(0);

      stroke(0);
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = Select3D.Face_ids.length - 1; o >= 0; o--) {

        int f = Select3D.Face_ids[o];

        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }


  if (current_ObjectCategory == ObjectCategory.CURVE) {

    if (Select3D.Curve_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      fill(0);

      stroke(0);
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = Select3D.Curve_ids.length - 1; o >= 0; o--) {

        int f = Select3D.Curve_ids[o];

        for (int j = 0; j < allCurves.nodes[f].length; j++) {
          int vNo = allCurves.nodes[f][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }


  if (current_ObjectCategory == ObjectCategory.VERTEX) {

    if (Select3D.Vertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = Select3D.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = Select3D.Vertex_ids[o];

        float x = allPoints.getX(vNo) * OBJECTS_scale;
        float y = allPoints.getY(vNo) * OBJECTS_scale;
        float z = -allPoints.getZ(vNo) * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R)) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }
      }

      strokeWeight(0);

      popMatrix();
    }
  }



  if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {

    if (Select3D.Vertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      strokeWeight(0);

      ellipseMode(CENTER);

      float R = 5;

      for (int q = 0; q < Select3D.softSelection_ids.length; q++) {

        int vNo = Select3D.softSelection_ids[q];

        float _u = Select3D.softSelection_values[q];

        float x = allPoints.getX(vNo) * OBJECTS_scale;
        float y = allPoints.getY(vNo) * OBJECTS_scale;
        float z = -allPoints.getZ(vNo) * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R)) {

            float[] COL = PAINT.getColorStyle(14, _u); // <<<<<<<<<<<<<<<<<
            fill(COL[1], COL[2], COL[3], COL[0]);
            stroke(COL[1], COL[2], COL[3], COL[0]);

            ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
        }
      }


      strokeWeight(0);

      popMatrix();
    }
  }



  if (current_ObjectCategory == ObjectCategory.GROUP) {

    if (Select3D.Group_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(127);
      strokeWeight(2);

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];


        for (int f = allGroups.getStart_Face(OBJ_ID); f <= allGroups.getStop_Face(OBJ_ID); f++) {
          if ((0 <= f) && (f < allFaces.nodes.length)) {

            int tessellation = allFaces.getTessellation(f);

            int totalNumberOfSubs = 1;
            if (allFaces.getMaterial(f) == 0) {
              tessellation += allFaces.displayTessellation;
            }
            if (tessellation > 0) totalNumberOfSubs = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, tessellation - 1), 1));

            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }

            for (int n = 0; n < totalNumberOfSubs; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, tessellation, n);

              beginShape();

              for (int s = 0; s < subFace.length; s++) {

                float x = subFace[s][0] * OBJECTS_scale;
                float y = subFace[s][1] * OBJECTS_scale;
                float z = -subFace[s][2] * OBJECTS_scale;

                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }


        for (int f = allGroups.getStart_Curve(OBJ_ID); f <= allGroups.getStop_Curve(OBJ_ID); f++) {
          if ((0 <= f) && (f < allCurves.nodes.length)) {

            beginShape();

            for (int vNo = 0; vNo < allCurves.nodes[f].length; vNo++) {

              float x = allPoints.getX(vNo) * OBJECTS_scale;
              float y = allPoints.getY(vNo) * OBJECTS_scale;
              float z = -allPoints.getZ(vNo) * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }


        for (int f = allGroups.getStart_Model1D(OBJ_ID); f <= allGroups.getStop_Model1D(OBJ_ID); f++) {

          if ((0 <= f) && (f < allModel1Ds.Faces.length)) {

            beginShape();

            for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

              int vNo = allModel1Ds.Faces[f][j];

              float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }


        for (int f = allGroups.getStart_Model2D(OBJ_ID); f <= allGroups.getStop_Model2D(OBJ_ID); f++) {

          if ((0 <= f) && (f < allModel2Ds.Faces.length)) {

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

        for (int q = allGroups.getStart_Solid(OBJ_ID); q <= allGroups.getStop_Solid(OBJ_ID); q++) {

          if ((0 < q) && (q < allSolids.Faces.length)) {

            for (int plane_type = 0; plane_type < allSolids.num_visualFaces; plane_type++) {

              int f = (q - 1) * allSolids.num_visualFaces + plane_type + 1;

              if ((0 <= f) && (f < allSolids.Faces.length)) {

                beginShape();

                for (int j = 0; j < allSolids.Faces[f].length; j++) {

                  int vNo = allSolids.Faces[f][j];

                  float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
                  float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
                  float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

                  float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                }

                endShape(CLOSE);
              }
            }
          }
        }
      }


      strokeWeight(0);

      popMatrix();
    }


    if (Select3D.Group_displayBox) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(0, 127, 0, 127);
      strokeWeight(2);

      int keep_selection_alignX = Select3D.alignX;
      int keep_selection_alignY = Select3D.alignY;
      int keep_selection_alignZ = Select3D.alignZ;

      Select3D.alignX = 0; // apply the centre
      Select3D.alignY = 0; // apply the centre
      Select3D.alignZ = 0; // apply the centre

      float[] P = Select3D.getPivot();

      float posX = P[0];
      float posY = P[1];
      float posZ = P[2];

      float posX_min = Select3D.BoundingBox[0][0];
      float posY_min = Select3D.BoundingBox[0][1];
      float posZ_min = Select3D.BoundingBox[0][2];

      float posX_max = Select3D.BoundingBox[2][0];
      float posY_max = Select3D.BoundingBox[2][1];
      float posZ_max = Select3D.BoundingBox[2][2];

      float[][] BoundingBox_Vertices = {
        {
          posX_min, posY_min, posZ_min
        }
        ,
        {
          posX_max, posY_min, posZ_min
        }
        ,
        {
          posX_max, posY_max, posZ_min
        }
        ,
        {
          posX_min, posY_max, posZ_min
        }
        ,
        {
          posX_min, posY_min, posZ_max
        }
        ,
        {
          posX_max, posY_min, posZ_max
        }
        ,
        {
          posX_max, posY_max, posZ_max
        }
        ,
        {
          posX_min, posY_max, posZ_max
        }
      };


      for (int i = 0; i < BoundingBox_Vertices.length; i++) {

        float x = BoundingBox_Vertices[i][0] - posX;
        float y = BoundingBox_Vertices[i][1] - posY;
        float z = BoundingBox_Vertices[i][2] - posZ;

        float[] A = Select3D.translateInside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        BoundingBox_Vertices[i][0] = x;
        BoundingBox_Vertices[i][1] = y;
        BoundingBox_Vertices[i][2] = z;
      }

      int[][] BoundingBox_Faces = {
        {
          3, 2, 1, 0
        }
        , {
          0, 1, 5, 4
        }
        , {
          1, 2, 6, 5
        }
        , {
          2, 3, 7, 6
        }
        , {
          3, 0, 4, 7
        }
        , {
          4, 5, 6, 7
        }
      };

      for (int f = 0; f < BoundingBox_Faces.length; f++) {

        beginShape();

        for (int g = 0; g < BoundingBox_Faces[f].length; g++) {

          int vNo = BoundingBox_Faces[f][g];

          float x = BoundingBox_Vertices[vNo][0] * OBJECTS_scale;
          float y = BoundingBox_Vertices[vNo][1] * OBJECTS_scale;
          float z = -BoundingBox_Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) vertex(Image_XYZ[0], Image_XYZ[1]);
          }
        }
        endShape(CLOSE);
      }

      strokeWeight(0);

      popMatrix();


      Select3D.alignX = keep_selection_alignX;
      Select3D.alignY = keep_selection_alignY;
      Select3D.alignZ = keep_selection_alignZ;
    }




    if (Select3D.Group_displayPivot) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

      noFill();

      stroke(255, 127, 0, 127);

      strokeWeight(5);

      for (int o = Select3D.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_ID = Select3D.Group_ids[o];

        float[][] Pivot_Vertices = {
          {
            0, 0, 0
          }
          ,
          {
            1, 0, 0
          }
          ,
          {
            0, 1, 0
          }
          ,
          {
            0, 0, 1
          }
        };


        float x0 = allGroups.Pivots[OBJ_ID][0];
        float y0 = allGroups.Pivots[OBJ_ID][1];
        float z0 = allGroups.Pivots[OBJ_ID][2];

        for (int i = 0; i < Pivot_Vertices.length; i++) {

          float x = Pivot_Vertices[i][0];
          float y = Pivot_Vertices[i][1];
          float z = Pivot_Vertices[i][2];

          float r = 10; // <<<<<<<<< display size

          x *= r;
          y *= r;
          z *= r;

          float[] O = Select3D.translateInside_ReferencePivot(0, 0, 0);
          float[] A = Select3D.translateInside_ReferencePivot(x, y, z);

          float dx = A[0] - O[0];
          float dy = A[1] - O[1];
          float dz = A[2] - O[2];

          Pivot_Vertices[i][0] = x0 + dx;
          Pivot_Vertices[i][1] = y0 + dy;
          Pivot_Vertices[i][2] = z0 + dz;
        }


        int[][] Pivot_Lines = {
          {
            0, 1
          }
          , {
            0, 2
          }
          , {
            0, 3
          }
        };

        int f_start = 0;
        int f_end = Pivot_Lines.length - 1;

        for (int f = f_start; f <= f_end; f++) {

          int a = Pivot_Lines[f][0];
          int b = Pivot_Lines[f][1];

          float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
          float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;
          float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

          float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
          float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;
          float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

          float[] Image_XYZa = WIN3D.calculate_Perspective_Internally(x1, y1, z1);
          float[] Image_XYZb = WIN3D.calculate_Perspective_Internally(x2, y2, z2);

          if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
              if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
                line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
              }
            }
          }
        }
      }


      strokeWeight(0);

      popMatrix();
    }
  }



  if (Select3D.displayReferencePivot) {

    pushMatrix();

    translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);

    noFill();

    strokeWeight(2);

    float[][] Pivot_Vertices = {
      {
        0, 0, 0
      }
      ,
      {
        1, 0, 0
      }
      ,
      {
        0, 1, 0
      }
      ,
      {
        0, 0, 1
      }
    };

    float[] P = Select3D.getPivot();

    float x0 = P[0];
    float y0 = P[1];
    float z0 = P[2];

    for (int i = 0; i < Pivot_Vertices.length; i++) {

      float x = Pivot_Vertices[i][0];
      float y = Pivot_Vertices[i][1];
      float z = Pivot_Vertices[i][2];

      float r = 5; // <<<<<<<<< display size

      x *= r;
      y *= r;
      z *= r;

      float[] O = Select3D.translateInside_ReferencePivot(0, 0, 0);
      float[] A = Select3D.translateInside_ReferencePivot(x, y, z);

      float dx = A[0] - O[0];
      float dy = A[1] - O[1];
      float dz = A[2] - O[2];

      Pivot_Vertices[i][0] = x0 + dx;
      Pivot_Vertices[i][1] = y0 + dy;
      Pivot_Vertices[i][2] = z0 + dz;
    }

    int[][] Pivot_Lines = {
      {
        0, 1
      }
      , {
        0, 2
      }
      , {
        0, 3
      }
    };


    for (int f = 0; f < Pivot_Lines.length; f++) {

      if (f == 0) stroke(255, 0, 0);
      if (f == 1) stroke(0, 0, 255);
      if (f == 2) stroke(127, 127, 0);

      int a = Pivot_Lines[f][0];
      int b = Pivot_Lines[f][1];

      float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
      float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;
      float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

      float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
      float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;
      float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

      float[] Image_XYZa = WIN3D.calculate_Perspective_Internally(x1, y1, z1);
      float[] Image_XYZb = WIN3D.calculate_Perspective_Internally(x2, y2, z2);

      if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
          if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY)) {
            line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
          }
        }
      }
    }

    strokeWeight(0);

    popMatrix();
  }
}













String NearLatitude_Stamp () {

  int Round_Latitude = int(funcs.roundTo(STATION.getLatitude(), 5));
  if (Round_Latitude > 70) Round_Latitude = 70; // <<<<<<<<<<<<<<<
  if (Round_Latitude < -45) Round_Latitude = -45; // <<<<<<<<<<<<<<<

  String a = nf(abs(Round_Latitude), 2);

  if (Round_Latitude < 0) a += "S";
  else a += "N";

  return a;
}



String Section_Stamp () {

  String s = "";

  s += "t" + nf(allSolidImpacts.sectionType, 0);
  s += "u" + nf(allSolarImpacts.X, 0, 3);
  s += "v" + nf(allSolarImpacts.Y, 0, 3);
  s += "w" + nf(allSolarImpacts.Z, 0, 3);
  s += "r" + nf(allSolarImpacts.R, 0, 3);

  s = s.replace('.', 'p');
  s = s.replace('-', 'n');

  return s;
}


String Viewport_Stamp () {

  String s = "";

  /*

  s += "x" + nf(WIN3D.position_X, 0, 3);
  s += "y" + nf(WIN3D.position_Y, 0, 3);
  s += "z" + nf(WIN3D.position_Z, 0, 3);

  s += "rx" + nf(WIN3D.rotation_X, 0, 3);
  s += "ry" + nf(WIN3D.rotation_Y, 0, 3);
  s += "rz" + nf(WIN3D.rotation_Z, 0, 3);

  s = s.replace('.', 'p');
  s = s.replace('-', 'n');

  */

  return s;
}




int UI_X_moved = -1;
int UI_Y_moved = -1;


void mouseMoved () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (UI_menuBar.selected_parent != -1) {

        if ((UI_X_moved != mouseX) || (UI_Y_moved != mouseY)) {

          UI_X_moved = mouseX;
          UI_Y_moved = mouseY;

          UI_menuBar.revise();

          redraw();
        }
      }
    }
  }
}



PImage pre_screen;




void SOLARCHVISION_modify_Viewport_Title () {

  String s = "Cam" + nf(WIN3D.currentCamera, 2);

  UI_toolBar.Items[0][11] = s; // <<<<< Note: 3DViewPoint is the first index on BAR_b
  UI_toolBar.highlight(s);

  UI_toolBar.revise();
}






void UI_set_to_Create_Nothing () {

  CreateObject = CREATE.Nothing;

  WIN3D.UI_CurrentTask = UITASK.Create;

  ROLLOUT.revise();
}


void UI_set_to_Create_allModel1Ds () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Model1Ds;
  SOLARCHVISION_switch_category(ObjectCategory.MODEL1D);
}


void UI_set_to_Create_Tree () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plant;
  SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
}

void UI_set_to_Create_Person () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Person;
  SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
}

void UI_set_to_Create_Vertex () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Vertex;
  SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
}

void UI_set_to_Create_Face () {
  UI_set_to_Create_Nothing();

  current_Material = User3D.default_Material;
  current_Tessellation = User3D.default_Tessellation;
  current_Layer = User3D.default_Layer;
  current_Visibility = User3D.default_Visibility;
  current_Weight = User3D.default_Weight;
  current_Closed = User3D.default_Closed;

  allFaces.beginNewFace();

  CreateObject = CREATE.Face;
  SOLARCHVISION_switch_category(ObjectCategory.FACE);
}

void UI_set_to_Create_Curve () {
  UI_set_to_Create_Nothing();

  current_Material = User3D.default_Material;
  current_Tessellation = User3D.default_Tessellation;
  current_Layer = User3D.default_Layer;
  current_Visibility = User3D.default_Visibility;
  current_Weight = User3D.default_Weight;
  current_Closed = User3D.default_Closed;

  allCurves.beginNewCurve();

  CreateObject = CREATE.Curve;
  SOLARCHVISION_switch_category(ObjectCategory.CURVE);
}

void UI_set_to_Create_Solid () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Solid;
  SOLARCHVISION_switch_category(ObjectCategory.SOLID);
}

void UI_set_to_Create_Section () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Section;
  SOLARCHVISION_switch_category(ObjectCategory.SECTION);
}


void UI_set_to_Create_Camera () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Camera;
  SOLARCHVISION_switch_category(ObjectCategory.CAMERA);
}






void UI_set_to_Create_Parametric (int n) {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Parametric;
  User3D.create_Parametric_Type = n;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Tri () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Tri;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Plane () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plane;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Poly () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Poly;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Extrude () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Extrude;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Hyper () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Hyper;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_House3 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House3;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_House2 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House2;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_House1 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House1;
  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Box () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = CubePower;
  User3D.create_powY = CubePower;
  User3D.create_powZ = CubePower;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}


void UI_set_to_Create_Icosahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 1;
  User3D.create_powY = 1;
  User3D.create_powZ = 1;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Octahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 1;
  User3D.create_powY = 1;
  User3D.create_powZ = 1;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Sphere () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 2;
  User3D.create_powY = 2;
  User3D.create_powZ = 2;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Cylinder () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 2;
  User3D.create_powY = 2;
  User3D.create_powZ = CubePower;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}

void UI_set_to_Create_Cushion () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = CubePower;
  User3D.create_powY = CubePower;
  User3D.create_powZ = 2;

  SOLARCHVISION_switch_category(ObjectCategory.GROUP);
}




void UI_set_to_Modify_Move (int n) {
  WIN3D.UI_CurrentTask = UITASK.Move;

  Select3D.posVector = n;

  ROLLOUT.revise();
}

void UI_set_to_Modify_Scale (int n) {
  WIN3D.UI_CurrentTask = UITASK.Scale;

  Select3D.scaleVector = n;

  ROLLOUT.revise();
}


void UI_set_to_Modify_Rotate (int n) {
  WIN3D.UI_CurrentTask = UITASK.Rotate;

  Select3D.rotVector = n;

  ROLLOUT.revise();
}

void UI_set_to_Modify_Seed (int n) {
  WIN3D.UI_CurrentTask = UITASK.Seed_Material;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Tessellation (int n) {
  WIN3D.UI_CurrentTask = UITASK.Tessellation;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Layer (int n) {
  WIN3D.UI_CurrentTask = UITASK.Layer;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Visibility (int n) {
  WIN3D.UI_CurrentTask = UITASK.Visibility;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Weight (int n) {
  WIN3D.UI_CurrentTask = UITASK.Weight;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_DegreeMax (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeMax;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_BranchTilt (int n) {
  WIN3D.UI_CurrentTask = UITASK.BranchTilt;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_BranchTwist (int n) {
  WIN3D.UI_CurrentTask = UITASK.BranchTwist;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_BranchRatio (int n) {
  WIN3D.UI_CurrentTask = UITASK.BranchRatio;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_TreeBase (int n) {
  WIN3D.UI_CurrentTask = UITASK.TreeBase;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}


void UI_set_to_Modify_TrunkSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.TrunkSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_LeafSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.LeafSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Model1DsProps (int n) {
  WIN3D.UI_CurrentTask = UITASK.Model1DsProps;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Pivot (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pivot;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.revise();
}

void UI_set_to_Modify_Normal (int n) {
  WIN3D.UI_CurrentTask = UITASK.Normal;
  WIN3D.UI_TaskModifyParameter = n; // 1:flip normal, 2:set out from pivot, 3:set in from pivot

  ROLLOUT.revise();
}

void UI_set_to_Modify_FirstVertex (int n) {
  WIN3D.UI_CurrentTask = UITASK.FirstVertex;
  WIN3D.UI_TaskModifyParameter = n; // 1:default

  ROLLOUT.revise();
}




void UI_set_to_Modify_Drop (int n) {
  WIN3D.UI_CurrentTask = UITASK.Drop;

  WIN3D.UI_TaskModifyParameter = n; // 0:LandSurface± 1:ModelSurface- 2:ModelSurface+

  ROLLOUT.revise();
}


void UI_set_to_Modify_GetLength (int n) {
  WIN3D.UI_CurrentTask = UITASK.GetLength;

  WIN3D.UI_TaskModifyParameter = n; // 0:x 1:y 2:z 3:xyz 4:xy 5:angle(on XY plane)

  ROLLOUT.revise();
}

void UI_set_to_Modify_Power (int n) {

  if (n == 0) WIN3D.UI_CurrentTask = UITASK.PowerX; // x
  if (n == 1) WIN3D.UI_CurrentTask = UITASK.PowerY; // y
  if (n == 2) WIN3D.UI_CurrentTask = UITASK.PowerZ; // z
  if (n == 3) WIN3D.UI_CurrentTask = UITASK.PowerAll; // xyz

  WIN3D.UI_TaskModifyParameter = 0; // 0:change

  ROLLOUT.revise();
}










void UI_set_to_View_ProjectionType (int n) {
  WIN3D.ViewType = n;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

void UI_set_to_View_PickSelect (int n) {

  WIN3D.UI_CurrentTask = UITASK.PickSelect;

  addNewSelectionToPreviousSelection = 0;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.revise();
}

void UI_set_to_View_WindowSelect (int n) {
  WIN3D.UI_CurrentTask = UITASK.RectSelect;

  addNewSelectionToPreviousSelection = 0;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.revise();
}

void UI_set_to_View_PivotX (int n) {

  Select3D.alignX = n;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

void UI_set_to_View_PivotY (int n) {

  Select3D.alignY = n;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

void UI_set_to_View_PivotZ (int n) {

  Select3D.alignZ = n;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}


void UI_set_to_View_Truck (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 0;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 1;
  }

  ROLLOUT.revise();
}


void UI_set_to_View_DistMouseXY (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.DistMouseXY_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.revise();
}



void UI_set_to_View_CameraDistance (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraDistance_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.revise();
}



void UI_set_to_View_CameraRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 0;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 1;
  }

  ROLLOUT.revise();
}



void UI_set_to_View_TargetRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.TargetRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 0;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;
    WIN3D.UI_OptionXorY = 1;
  }

  ROLLOUT.revise();
}


void UI_set_to_View_Orbit (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;
    WIN3D.UI_OptionXorY = 0;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;
    WIN3D.UI_OptionXorY = 1;
  }

  ROLLOUT.revise();
}



void UI_set_to_View_LandOrbit (int n) {

  WIN3D.UI_CurrentTask = UITASK.LandOrbit_Pan_TargetRollZ;

  ROLLOUT.revise();
}



void UI_set_to_View_LookAtSelection (int n) {

  WIN3D.look_3DViewport_towards_Selection();

  { // automatically set another choice of ineterest
    UI_set_to_View_CameraDistance(0);
    UI_toolBar.highlight("±CDS");
    UI_toolBar.revise();
  }

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}


void UI_set_to_View_LookAtDirection (int n) {

  WIN3D.UI_CurrentTask = UITASK.LookAtDirection;

  ROLLOUT.revise();
}


void UI_set_to_View_LookAtOrigin (int n) {

  WIN3D.position_X = 0;
  WIN3D.position_Y = 0;
  WIN3D.position_Z = 0;

  {
    // automatically set another choice of ineterest

    UI_set_to_View_Truck(0);
    UI_toolBar.highlight("±CDZ");
    UI_toolBar.revise();
  }

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}


void UI_set_to_View_Pan (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Pan_TargetRoll;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.PanX_TargetRollXY_TargetRollZ;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.PanY_TargetRollXY_TargetRollZ;
  }


  ROLLOUT.revise();
}

void UI_set_to_View_ZOOM (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pan_Height;

  ROLLOUT.revise();

  if (n == 1) {
    WIN3D.Zoom = 60;

    SOLARCHVISION_view_changed();
  }
}

void UI_set_to_View_3DModelSize () {

  WIN3D.UI_CurrentTask = UITASK.ModelSize_Pan_TargetRoll;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

void UI_set_to_View_SkydomeSize () {

  WIN3D.UI_CurrentTask = UITASK.SkydomeSize;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

void UI_set_to_View_AllModelSize () {

  WIN3D.UI_CurrentTask = UITASK.AllModelSize;

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}

boolean updateBars = false;

void UI_set_to_Viewport (int n) {

  updateBars = true;

  FrameVariation = n;
  SOLARCHVISION_update_frame_layout();

  ROLLOUT.revise();
}

void UI_set_to_View_3DViewPoint (int n) {

  WIN3D.currentCamera = 0;

  WIN3D.apply_currentCamera();

  if (n == 0) {
    WIN3D.rotateZ_3DViewport_around_Selection(0 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }

  if (n == 1) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }

  if (n == 2) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(-90 - WIN3D.rotation_Z);
  }

  if (n == 3) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(180 - WIN3D.rotation_Z);
  }

  if (n == 4) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(90 - WIN3D.rotation_Z);
  }

  if (n == 5) {
    WIN3D.rotateZ_3DViewport_around_Selection(180 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }

  if (n == 6) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(-45 - WIN3D.rotation_Z);
  }

  if (n == 7) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(45 - WIN3D.rotation_Z);
  }

  if (n == 8) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(135 - WIN3D.rotation_Z);
  }

  if (n == 9) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(-135 - WIN3D.rotation_Z);
  }


  UI_toolBar.revise();

  ROLLOUT.revise();

  SOLARCHVISION_view_changed();
}























int[] get_startK_endK () {
  int[] a = new int [2];

  int start_k = -1;
  int end_k = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End;

    if (start_k < CLIMATE_CWEEDS_start) start_k = CLIMATE_CWEEDS_start;
    if (end_k > CLIMATE_CWEEDS_end) end_k = CLIMATE_CWEEDS_end;

    start_k -= CLIMATE_CWEEDS_start;
    end_k -= CLIMATE_CWEEDS_start;
  }
  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End;

    if (start_k < CLIMATE_CLMREC_start) start_k = CLIMATE_CLMREC_start;
    if (end_k > CLIMATE_CLMREC_end) end_k = CLIMATE_CLMREC_end;

    start_k -= CLIMATE_CLMREC_start;
    end_k -= CLIMATE_CLMREC_start;
  }
  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {

    start_k = 0;
    end_k = 0;
  }
  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {

    start_k = SampleMember_Start;
    end_k = SampleMember_End;

    start_k -= ENSEMBLE_FORECAST_start;
    end_k -= ENSEMBLE_FORECAST_start;
  }
  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {

    start_k =  SampleStation_Start;
    end_k =  SampleStation_End;

    start_k -= ENSEMBLE_OBSERVED_start;
    end_k -= ENSEMBLE_OBSERVED_start;
  }


  //println("start_k=", start_k);
  //println("end_k=", end_k);

  a[0] = start_k;
  a[1] = end_k;

  return  a;
}
































void SOLARCHVISION_preBakeViewport () {

  cursor(WAIT);

  println("PreBaking Direct and Diffuse Models. Please wait...");

  Camera_Variation = 0;

  allSolarImpacts.sectionType = 1; // <<<<< so that it analyzed later!

  int start_DATE_ANGLE = 0;
  int step_DATE_ANGLE = 15;
  int end_DATE_ANGLE = 360 - step_DATE_ANGLE;

  int start_HOUR = 4; // to make it faster. Also the images are not needed out of this period.
  int step_HOUR = 1;
  int end_HOUR = 20; // to make it faster. Also the images are not needed out of this period.

  SceneName = "Viewport_" + Viewport_Stamp();

  int pre_WIN3D_dX = WIN3D.dX;
  int pre_WIN3D_dY = WIN3D.dY;

  WIN3D.dX = allSolarImpacts.RES1;
  WIN3D.dY = allSolarImpacts.RES2;
  WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);

  WIN3D.transform_3DViewport();

  //WIN3D.put_3DViewport();  //????????????

  float ScaleToFit = float(pre_WIN3D_dY) / float(WIN3D.dY);


  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;

  float[][] Diffuse_Matrix = new float [2][(RES1 * RES2)];

  for (int SHD = 0; SHD <= 1; SHD++) {
    for (int np = 0; np < (RES1 * RES2); np++) {
      Diffuse_Matrix[SHD][np] = 0;
    }
  }

  int n_Map = 0;
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {

    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) {
      n_Map += 1;
    }
  }

  PImage[][] Direct_RGBA = new PImage [n_Map][2];


  int[] lastHitDirect = new int [n_Map];

  for (int i = 0; i < lastHitDirect.length; i++) {
    lastHitDirect[i] = 0;
  }

  int[] lastHitDiffuse = new int [DiffuseVectors.length];

  for (int i = 0; i < lastHitDiffuse.length; i++) {
    lastHitDiffuse[i] = 0;
  }


  n_Map = -1;
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {

    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) {
      n_Map += 1;

      for (int SHD = 0; SHD <= 1; SHD++) {

        Direct_RGBA[n_Map][SHD] = createImage(RES1, RES2, ARGB);

        Direct_RGBA[n_Map][SHD].loadPixels();
      }
    }
  }

  float Progress = 0;

  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;

    if (1 + Progress < 100 * np / float(RES1 * RES2)) {
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }

    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;


    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = WIN3D.calculate_Click3D(Image_X * ScaleToFit, Image_Y * ScaleToFit);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];


    float[] RxP = new float [8];

    RxP = allFaces.intersect(ray_start, ray_direction);

    if (RxP[0] >= 0) {

      int f = int(RxP[0]);

      float[] COL = {
        0, 0, 0, 0
      };

      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = funcs.vec3_unit(face_norm);

      if (funcs.vec_dot(face_norm, ray_direction) > 0) { // to render backing faces
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }

      float Alpha = 90 - funcs.acos_ang(face_norm[2]);
      float Beta = 180 - funcs.atan2_ang(face_norm[0], face_norm[1]);

      float[] VECT = {
        0, 0, 0
      };

      if (abs(Alpha) > 89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = 1;
      } else if (Alpha < -89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = -1;
      } else {
        VECT[0] = funcs.sin_ang(Beta);
        VECT[1] = -funcs.cos_ang(Beta);
        VECT[2] = funcs.tan_ang(Alpha);
      }

      VECT = funcs.vec3_unit(VECT);

      {

        for (int n_Ray = 0; n_Ray < DiffuseVectors.length; n_Ray++) {

          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];

          ray_direction[0] = DiffuseVectors[n_Ray][0];
          ray_direction[1] = DiffuseVectors[n_Ray][1];
          ray_direction[2] = DiffuseVectors[n_Ray][2];

          float SkyMask = funcs.vec_dot(funcs.vec3_unit(DiffuseVectors[n_Ray]), funcs.vec3_unit(VECT));
          //if (SkyMask <= 0) SkyMask = 0; // removes backing faces

          // when SHD = 0;
          Diffuse_Matrix[0][np] += SkyMask / float(DiffuseVectors.length);

          lastHitDiffuse[n_Ray] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDiffuse[n_Ray]);

          // when SHD = 1;
          if (lastHitDiffuse[n_Ray] == 0) {
            Diffuse_Matrix[1][np] += SkyMask / float(DiffuseVectors.length);
          }
          else Diffuse_Matrix[1][np] += 0;
        }
      }


      n_Map = -1;
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {

        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) {
          n_Map += 1;

          float HOUR_ANGLE = i;

          float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

          float[] DirectVector = {
            SunR[1], SunR[2], SunR[3]
          };

          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];

          ray_direction[0] = DirectVector[0];
          ray_direction[1] = DirectVector[1];
          ray_direction[2] = DirectVector[2];

          float SunMask = funcs.vec_dot(funcs.vec3_unit(DirectVector), funcs.vec3_unit(VECT));
          //if (SunMask <= 0) SunMask = 0; // removes backing faces

          // when SHD = 0;
          Direct_RGBA[n_Map][0].pixels[np] = color(255 * SunMask, 255);

          // when SHD = 1;

          lastHitDirect[n_Map] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDirect[n_Map]);

          if (lastHitDirect[n_Map] == 0) {
            Direct_RGBA[n_Map][1].pixels[np] = color(255 * SunMask, 255);
          }
          else Direct_RGBA[n_Map][1].pixels[np] = color(0, 255);
        }
      }
    }
    else {

      n_Map = -1;
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {

        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) {
          n_Map += 1;

          for (int SHD = 0; SHD <= 1; SHD++) {

            Direct_RGBA[n_Map][SHD].pixels[np] = color(0,0,0,0);

          }
        }
      }

      for (int SHD = 0; SHD <= 1; SHD++) {

        Diffuse_Matrix[SHD][np] = FLOAT_undefined;

      }

    }

  }

  println("Progress: 100 %");

  n_Map = -1;
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {

    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) {
      n_Map += 1;

      float HOUR_ANGLE = i;

      for (int SHD = 0; SHD <= 1; SHD++) {

        String[] STR_SHD = {
          "F", "T"
        };
        String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

        File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);

        File_Name += "_Camera" + nf(Camera_Variation, 2);

        Direct_RGBA[n_Map][SHD].updatePixels();

        Direct_RGBA[n_Map][SHD].save(File_Name + ".png");

        println(File_Name + ".png");
      }
    }
  }

  PImage[] Diffuse_RGBA = new PImage [2];

  for (int SHD = 0; SHD <= 1; SHD++) {

    String[] STR_SHD = {
      "F", "T"
    };
    String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

    File_Name += "DIF_" + STR_SHD[SHD];

    File_Name += "_Camera" + nf(Camera_Variation, 2);

    Diffuse_RGBA[SHD] = createImage(RES1, RES2, ARGB);

    Diffuse_RGBA[SHD].loadPixels();

    for (int np = 0; np < (RES1 * RES2); np++) {

      if (is_defined(Diffuse_Matrix[SHD][np])) {

        Diffuse_RGBA[SHD].pixels[np] = color(255 * Diffuse_Matrix[SHD][np], 255);
      }
      else {

        Diffuse_RGBA[SHD].pixels[np] = color(0,0,0,0);
      }
    }

    Diffuse_RGBA[SHD].updatePixels();


    Diffuse_RGBA[SHD].save(File_Name + ".png");

    println(File_Name + ".png");
  }



  cursor(ARROW);

  WIN3D.dX = pre_WIN3D_dX;
  WIN3D.dY = pre_WIN3D_dY;
  WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
}






void SOLARCHVISION_RenderViewport () {

  println("Render started!");

  int PAL_type = 0;
  int PAL_direction = 1;
  float PAL_multiplier = 1;

  if (Impact_TYPE == Impact_ACTIVE) {
    PAL_type = allFaces.ACTIVE_pallet_CLR;
    PAL_direction = allFaces.ACTIVE_pallet_DIR;
    PAL_multiplier = allFaces.ACTIVE_pallet_MLT;
  }
  if (Impact_TYPE == Impact_PASSIVE) {
    PAL_type = allFaces.PASSIVE_pallet_CLR;
    PAL_direction = allFaces.PASSIVE_pallet_DIR;
    PAL_multiplier = allFaces.PASSIVE_pallet_MLT;
  }


  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;

  PImage Image_RGBA = createImage(RES1, RES2, ARGB);

  Image_RGBA.loadPixels();

  float Progress = 0;




  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;

    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;

    if (1 + Progress < 100 * np / float(RES1 * RES2)) {
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];





    float[] RxP = new float [8];

    RxP = allFaces.intersect(ray_start, ray_direction);

    if (RxP[0] >= 0) {

      int f = int(RxP[0]);


      float[] COL = {
        0, 0, 0, 0
      };

      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = funcs.vec3_unit(face_norm);

      if (funcs.vec_dot(face_norm, ray_direction) > 0) { // to render backing faces
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }


      float Alpha = 90 - funcs.acos_ang(face_norm[2]);
      float Beta = 180 - funcs.atan2_ang(face_norm[0], face_norm[1]);

float valuesSUM_RAD = 0;
float valuesSUM_EFF_P = 0;
float valuesSUM_EFF_N = 0;
int valuesNUM = 0;

float values_R_dir = 1;
float values_R_dif = 1;
float values_E_dir = 0.1;
float values_E_dif = 0.1;


//float[] SunR = funcs.SunPositionRadiation( DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);
float[] SunR = funcs.SunPositionRadiation(0, 12, 0);
float[] VECT = {
  0, 0, 0
};

if (abs(Alpha) > 89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = 1;
} else if (Alpha < -89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = -1;
} else {
  VECT[0] = funcs.sin_ang(Beta);
  VECT[1] = -funcs.cos_ang(Beta);
  VECT[2] = funcs.tan_ang(Alpha);
}

VECT = funcs.vec3_unit(VECT);


float[] SunV = {
  SunR[1], SunR[2], SunR[3]
};

float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
if (SunMask <= 0) SunMask = 0; // removes backing faces

float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));


// new trace
ray_start[0] = RxP[1];
ray_start[1] = RxP[2];
ray_start[2] = RxP[3];

ray_direction[0] = SunV[0];
ray_direction[1] = SunV[1];
ray_direction[2] = SunV[2];

//if (funcs.vec_dot(face_norm, ray_direction) > 0)
{ // removes backing faces

  if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) {
    if (values_E_dir < 0) {
      valuesSUM_EFF_P += -(values_E_dir * SunMask);
      valuesSUM_EFF_N += -(values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    } else {
      valuesSUM_EFF_N += (values_E_dir * SunMask);
      valuesSUM_EFF_P += (values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    }

    valuesSUM_RAD += (values_R_dif * SkyMask); // only approximate diffuse radiation!
  } else {
    if (values_E_dir < 0) {
      valuesSUM_EFF_N += -((values_E_dir * SunMask) + (values_E_dif * SkyMask));
    } else {
      valuesSUM_EFF_P += ((values_E_dir * SunMask) + (values_E_dif * SkyMask));
    }

    valuesSUM_RAD += ((values_R_dir * SunMask) + (values_R_dif * SkyMask)); // calculates total radiation
  }
}
valuesNUM += 1;

//-----------------------------
float valuesSUM = valuesSUM_RAD; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//-----------------------------

      float _u = 0;

      if (is_defined(valuesSUM)) {

        if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);

        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
      }

      COL = PAINT.getColorStyle(PAL_type, _u);


      Image_RGBA.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
    }

    else Image_RGBA.pixels[np] = color(0,0,0,0);
  }

  Image_RGBA.updatePixels();

  String myFile = Folder_ScreenShots + "/" + createStamp(1, "Render") + ".png";
  Image_RGBA.save(myFile);
  println("File created:" + myFile);

}





float[][] DiffuseVectors;

void SOLARCHVISION_build_SkySphere (int tessellation) {

  //Create3D.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0,0,0, 1, tessellation, 1, 90); // SKY
  //Create3D.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 4, 1, 90); // SKY
  Create3D.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1, 90); // SKY

  DiffuseVectors = new float[0][3];

  for (int i = 0; i < skyFaces.length; i++) {

    float x = 0;
    float y = 0;
    float z = 0;

    for (int j = 0; j < skyFaces[i].length; j++) {

      x += skyVertices[skyFaces[i][j]][0] / float(skyFaces[i].length);
      y += skyVertices[skyFaces[i][j]][1] / float(skyFaces[i].length);
      z += skyVertices[skyFaces[i][j]][2] / float(skyFaces[i].length);

      if (z > 0) {
        float[][] new_Vector = {{x, y, z}};
        DiffuseVectors = (float[][]) concat(DiffuseVectors, new_Vector);
      }
    }
  }

}






void setFlag_CurrentDataSource (int i, int j, int k, int Parameter_ID, boolean flag) {

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_flags[i][j][Parameter_ID][k] = flag;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_flags[i][j][Parameter_ID][k] = flag;
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_flags[i][j][Parameter_ID][k] = flag;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_flags[i][j][Parameter_ID][k] = flag;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_flags[i][j][Parameter_ID][k] = flag;
  }

}

void setValue_CurrentDataSource (int i, int j, int k, int Parameter_ID, float value) {

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_values[i][j][Parameter_ID][k] = value;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_values[i][j][Parameter_ID][k] = value;
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_values[i][j][Parameter_ID][k] = value;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k] = value;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k] = value;
  }

}


float getValue_CurrentDataSource (int i, int j, int k, int Parameter_ID) {

  float return_value = FLOAT_undefined;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_values[i][j][Parameter_ID][k];
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_values[i][j][Parameter_ID][k];
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_values[i][j][Parameter_ID][k];
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k];
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k];
  }

  return return_value;
}


int getStart_CurrentDataSource () {

  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_start;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_start;
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_start;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_start;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_start;
  }

  return return_value;
}

int getEnd_CurrentDataSource () {

  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_end;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_end;
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_end;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_end;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_end;
  }

  return return_value;
}

String getReference_CurrentDataSource () {

  String return_value = "";

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = STATION.getFilename_CWEEDS() + ".WY3" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/";
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value  = "Environment and Climate Change Canada website at https://climate.weather.gc.ca/climate_data";
  }
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = STATION.getFilename_TMYEPW() + ".epw";
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = nf(TIME.year, 4) + nf(TIME.month, 2) + nf(TIME.day, 2) + nf(TIME.hour, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + CurrentLayer_name + "_000-384.xml" + ", Environment and Climate Change Canada: https://dd.weather.gc.ca/ensemble/naefs/";
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = "Environment and Climate Change Canada website at https://dd.weather.gc.ca/observations/swob-ml/";
  }

  return return_value;
}



void SOLARCHVISION_setDataFlags (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;

  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();
  // setting the flags
  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
          if (is_defined(getValue_CurrentDataSource(i, j, k, l))) {
            setFlag_CurrentDataSource(i, j, k, l, true);
          }
        }
      }
    }
  }

  CurrentDataSource = keep_CurrentDataSource;
}

void SOLARCHVISION_postProcess_fillGaps (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;

  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.

  for (int l = 0; l < numberOfLayers; l++) {

    for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
      float pre_v = FLOAT_undefined;
      int pre_num = 0;

      for (int j = 0; j < 365; j++) {

        for (int i = 0; i < 24; i++) {

          if (is_undefined(getValue_CurrentDataSource(i, j, k, l))) {
            if (is_defined(pre_v)) {
              pre_num += 1;

              float next_v = FLOAT_undefined;
              int next_i = i;
              int next_j = j;
              int next_num = 0;
              while ((next_num < MAX_SEARCH) && (is_undefined(next_v))) {
                next_num += 1;
                next_i += 1;
                if (next_i == 24) {
                  next_i -= 24;
                  next_j += 1;
                }
                if (next_j == 365) {
                  next_j = 0;
                }
                if (is_defined(getValue_CurrentDataSource(next_i, next_j, k, l))) {
                  next_v = getValue_CurrentDataSource(next_i, next_j, k, l);

                  if (l == LAYER_winddir.id) {
                    if ((next_v - pre_v) > 180) next_v -= 360;
                    if ((next_v - pre_v) < -180) next_v += 360;
                  }
                }
              }
              if (next_num < MAX_SEARCH) {
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360);
                else setValue_CurrentDataSource(i, j, k, l, (next_num * pre_v + pre_num * next_v) / (pre_num + next_num));

                float interpolation_pow = pow(2.0, Interpolation_Weight);

                setValue_CurrentDataSource(i, j, k, l, (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow)));
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, (getValue_CurrentDataSource(i, j, k, l) + 360) % 360);
              }
            }
          } else {
            pre_v = getValue_CurrentDataSource(i, j, k, l);
            pre_num = 0;
          }

        }
      }

    }
  }

  CurrentDataSource = keep_CurrentDataSource;
}






void SOLARCHVISION_postProcess_solarsUsingCloud (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;

  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
    for (int j = 0; j < 365; j++) {
      for (int i = 0; i < 24; i++) {

        float CL = getValue_CurrentDataSource(i, j, k, LAYER_cloudcover.id);

        if (is_defined(CL)) {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i;

          float[] SunR = funcs.SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, CL);

          setValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id, SunR[4]);

          setValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id, SunR[5]);

          setValue_CurrentDataSource(i, j, k, LAYER_glohorrad.id, SunR[4] * SunR[3] + SunR[5]);
        }

      }
    }
  }

  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_solarEffects (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;

  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();


  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {

        float T     = getValue_CurrentDataSource(i, j, k, LAYER_drybulb.id);
        float R_dir = getValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id);
        float R_dif = getValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id);

        if (is_defined(T) && is_defined(R_dir) && is_defined(R_dif)) {

          setValue_CurrentDataSource(i, j, k, LAYER_direffect.id, (18 - T) * R_dir);
          setValue_CurrentDataSource(i, j, k, LAYER_difeffect.id, (18 - T) * R_dif);

        }
      }
    }
  }

  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_climaticSolarForecast () {

  int num_count = (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start);

  for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
    for (int j_for = 0; j_for < ENSEMBLE_FORECAST_maxDays; j_for++) {
      int j = ((j_for + TIME.beginDay) % 365);
      for (int i = 0; i < 24; i++) {
        if (is_undefined(ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k])) {
        } else {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i;

          float[] SunR = funcs.SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);

          ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = SunR[4];

          ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = SunR[5];

          ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = SunR[4] * SunR[3] + SunR[5];

          //---------------------------------------------------------------------

          float Forecast_CC = ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k];
          float Forecast_AP = ENSEMBLE_FORECAST_values[i][j][LAYER_pressure.id][k];

          float CC_epsilon = 1.0; // defines a range for finding near previous results: 1.0 results in e.g. 2 < CC < 4 for CC at 3
          float AP_epsilon = 50.0;

          float valuesSUM_DIR = 0;
          float valuesSUM_DIF = 0;
          float valuesSUM_GLO = 0;
          float sum_count = 0;

          float process_add_days = 11;

          for (int q = 0; q < num_count; q++) {

            for (int j_ADD = 0; j_ADD < process_add_days; j_ADD++) {

              int now_i = i;
              int now_j = int(j + (j_ADD - int(0.5 * process_add_days)) + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }


              if ((is_undefined(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q])) ||
                 (is_undefined(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]))) {
              } else {
                float CC_dist = abs(Forecast_CC - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q]);
                float AP_dist = abs(Forecast_AP - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]);
                if ((CC_dist < CC_epsilon) && (AP_dist < AP_epsilon)) {

                  float _weight;

                  _weight = 1;
                  _weight *= pow(abs(1 - pow(CC_dist/CC_epsilon, 2)), 2); // to add more wights to closer cases
                  _weight *= pow(abs(1 - pow(AP_dist/AP_epsilon, 2)), 2);

                  sum_count += _weight;

                  if (is_undefined(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q])) {
                  } else valuesSUM_DIR += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q];
                  if (is_undefined(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q])) {
                  } else valuesSUM_DIF += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q];
                  if (is_undefined(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q])) {
                  } else valuesSUM_GLO += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q];
                }
              }
            }
          }

          if (sum_count != 0) {
            valuesSUM_DIR /= sum_count;
            valuesSUM_DIF /= sum_count;
            valuesSUM_GLO /= sum_count;

            ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = valuesSUM_DIR;
            ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = valuesSUM_DIF;
            ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = valuesSUM_GLO;
          } else {
            println("Cannot find simillar conditions in climate file at i:", i, ", j:", j, ", k:", k);
          }

        }
      }
    }
  }
}




void SOLARCHVISION_postProcess_developDATA (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;

  CurrentDataSource = desired_DataSource;

  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;

  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
      (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {

    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  int count_k = 1 + DATA_end - DATA_start;
  if (count_k > 0) {

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float RAIN, T, WS, R_dir, R_dif;

    float[] valuesSUM;
    valuesSUM = new float [count_k];

    for (int k = 0; k < count_k; k++) {
      valuesSUM[k] = FLOAT_undefined;
    }

    for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {
      for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {
        for (int k = 0; k < count_k; k++) {
          for (int i = 0; i < 24; i++) {

            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            int next_i = now_i + 12;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i >= 24) {
              next_i = next_i - 24;
              next_j += 1;
              if (next_j >= 365) {
                next_j = next_j % 365;
              }
            }


            int pre_i = now_i - 12;
            int pre_j = now_j;
            int pre_k = now_k;
            if (pre_i < 0) {
              pre_i = pre_i + 24;
              pre_j -= 1;
              if (pre_j < 0) {
                pre_j = (pre_j + 365) % 365;
              }
            }


            setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, FLOAT_undefined);

            T = FLOAT_undefined;
            R_dir = FLOAT_undefined;
            R_dif = FLOAT_undefined;

            if ((i == 0) && (j == STUDY.j_Start)) valuesSUM[now_k] = 0;



            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);

            if (is_undefined(Pa)) {
              R_dir = FLOAT_undefined;
            } else {
              R_dir = Pa;
            }

            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);

            if (is_undefined(Pa)) {
              R_dif = FLOAT_undefined;
            } else {
              R_dif = Pa;
            }

            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);

            if (is_undefined(Pa)) {
              T = FLOAT_undefined;
            } else {
              T = Pa;
            }

            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);

            if (is_undefined(Pa)) {
              WS = FLOAT_undefined;
            } else {
              WS = Pa;
            }

            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_precipitation.id);
            Pb = getValue_CurrentDataSource(next_i, next_j, now_k, LAYER_precipitation.id);

            if (is_undefined(Pa) || is_undefined(Pb)) {
              RAIN = FLOAT_undefined;
            } else {
              RAIN = Pb - Pa;
              //RAIN = Pa - Pb;

              if (T <= 0) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<< Lewis
              //if ((T < 5) && (T > -5)) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<< Mojtaba
            }


            float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);
            float HOUR_ANGLE = now_i;

            float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);






            if (Develop_Option == DEV_OP_00) {

              if (is_defined(R_dir) && is_defined(R_dif)) {

                if (allMaterials.DirectArea_Flags[now_i][now_j] == -1) {
                  valuesSUM[now_k] = FLOAT_undefined;
                } else {
                  valuesSUM[now_k] = 0.001 * (R_dir * allMaterials.DirectArea_Data[allMaterials.Selection][now_i][now_j] + R_dif * allMaterials.DiffuseArea_Data[allMaterials.Selection][now_i][now_j]);
                }

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 0.5;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "KW";
              LAYER_developed.descriptions[Language_EN] = "Direct radiation on surfaces with material #" + String.valueOf(allMaterials.Selection);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }


            if (Develop_Option == DEV_OP_01) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;



              if (is_defined(R_dir) && is_defined(R_dif)) {

                valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }

            if (Develop_Option == DEV_OP_02) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;

              if (is_defined(R_dir) && is_defined(R_dif)) {

                valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * valuesSUM[now_k]);
              }


              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }

            if (Develop_Option == DEV_OP_03) {
              float Alpha = funcs.asin_ang(SunR[3]);
              float Beta = funcs.atan2_ang(SunR[2], SunR[1]) + 90;

              if (is_defined(R_dir) && is_defined(R_dif)) {

                valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }

            if (Develop_Option == DEV_OP_04) {
              float Alpha = funcs.asin_ang(SunR[3]);
              float Beta = funcs.atan2_ang(SunR[2], SunR[1]) + 90;

              if (is_defined(R_dir) && is_defined(R_dif)) {

                valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }


            if (Develop_Option == DEV_OP_05) {

              if (is_defined(T)) {
                valuesSUM[now_k] += (T - 18) / 24;

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 1.0;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = -1;
              LAYER_developed.unit = "°C";
              LAYER_developed.descriptions[Language_EN] = "Accumulated degree day (based on 18°C)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }

            if (Develop_Option == DEV_OP_06) {

              valuesSUM[now_k] = 0;
              float sum_count = 0;

              int num_count = STUDY.TrendJoinHours;


              for (int _count = 1; _count <= num_count; _count++) {

                int plus_i = - (_count - 1);

                int new_k = k;
                int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }

                float T_new = FLOAT_undefined;

                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);

                if (is_undefined(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }

                if (is_defined(T_new)) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  valuesSUM[now_k] += _weight * T_new;
                }
              }

              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);

              valuesSUM[now_k] = 0;

              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }


            if (Develop_Option == DEV_OP_07) {

              valuesSUM[now_k] = 0;
              float sum_count = 0;

              int num_count = STUDY.TrendJoinHours;


              for (int _count = 1; _count <= ceil ( (num_count + 1) / 2); _count++) {
                for (int dir_count = -1; dir_count <= 1; dir_count += 2) {

                  int plus_i = dir_count * (_count - 1);

                  int new_k = k;
                  int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                  int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

                  if (new_j >= 365) {
                    new_j = new_j % 365;
                  }
                  if (now_j < 0) {
                    new_j = (new_j + 365) % 365;
                  }

                  float T_new = FLOAT_undefined;

                  Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);

                  if (is_undefined(Pa)) {
                    T_new = FLOAT_undefined;
                  } else {
                    T_new = Pa;
                  }

                  if (is_defined(T_new)) {
                    float _weight = (num_count - _count + 1);
                    if (STUDY.TrendJoinType == 1) _weight = 1;
                    sum_count += _weight;
                    valuesSUM[now_k] += _weight * T_new;
                  }
                }
              }

              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);

              valuesSUM[now_k] = 0;


              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }

            if (Develop_Option == DEV_OP_08) {

              valuesSUM[now_k] = 0;
              float sum_count = 0;

              int num_count = STUDY.TrendJoinHours;


              for (int _count = num_count; _count > 0; _count--) {

                int plus_i = _count - 1;

                int new_k = k;
                int new_i = ((i + plus_i) + 24 * floor((i + plus_i) / 24.0)) % 24;
                int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }

                float T_new = FLOAT_undefined;

                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);

                if (is_undefined(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }

                if (is_defined(T_new)) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  valuesSUM[now_k] += _weight * T_new;
                }
              }

              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);

              valuesSUM[now_k] = 0;


              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }


            if (Develop_Option == DEV_OP_09) {

              if (is_defined(RAIN)) {
                valuesSUM[now_k] = RAIN;

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = 0; //-20.0 / (1.0 * STUDY.LevelPix); // so that we can have two views on probabilites above and below zero.
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/12hours";
              LAYER_developed.descriptions[Language_EN] = "12-hour Surface Accumulated Precipitation";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }

            if (Develop_Option == DEV_OP_10) {

              if (is_defined(RAIN)) {
                valuesSUM[now_k] = RAIN;

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 2.0; //4.0;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/h";
              LAYER_developed.descriptions[Language_EN] = "Hourly Surface Precipitation (interpolated)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }


            if (Develop_Option == DEV_OP_11) {

              if (is_defined(WS)) {

                valuesSUM[now_k] = 0.5 * 1.23 * 1 * pow(WS / 3.6, 3);

                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }

              LAYER_developed.V_scale = 0.05;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Wind power";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }






            if ((Develop_Option == DEV_OP_02) || (Develop_Option == DEV_OP_04)) {

              if ((i == 23) && (Develop_DayHour == 1)) {
                for (int l = i + 1 - 24; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 24;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/day";

                valuesSUM[now_k] = 0;
              }

              if (((i == 11) || (i == 23)) && (Develop_DayHour == 2)) {
                for (int l = i + 1 - 12; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 12;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/12hours";

                valuesSUM[now_k] = 0;
              }

              if (((i == 5) || (i == 11) || (i == 17) || (i == 23)) && (Develop_DayHour == 3)) {
                for (int l = i + 1 - 6; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 6;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/6hours";

                valuesSUM[now_k] = 0;
              }
            }
          }
        }
      }
    }
  }

  println("developDATA updated!");

  DevelopData_update = false;

  STUDY.perDays = keep_STUDY_perDays;
  STUDY.joinDays = keep_STUDY_joinDays;

  CurrentDataSource = keep_CurrentDataSource;
}





















class solarchvision_UI_menuBar {

  private final static String CLASS_STAMP = "UI_menuBar";

  boolean update = true;

  float width_parent = 4.5 * SOLARCHVISION_pixel_A;
  float width_child = width_parent; // i.e. minimum size

  int selected_parent = -1;
  int selected_child = 0;

  String[][] Items = {
    {
      "About",
      "SOLARCHVISION-BIM6D",
      "Designed & developed by",
      "Mojtaba Samimi",
      "www.solarchvision.com"
    }
    ,
    {
      "File",
      "New",
      "Open...",
      "Import 3D-model...",
      "Import Command File...",
      "Hold",
      "Fetch",
      "Save",
      "Save As...",
      "Export 3D-model > SCR",
      "Export 3D-model > RAD",
      "Export 3D-model > HTML",
      "Export 3D-model > OBJ",
      "Export 3D-model > OBJ (date-series)",
      "Export 3D-model > OBJ (time-series)",
      "Quit"
    }
    ,
    {
      "Tools",
      "JPG Time Graph",
      "PDF Time Graph",
      "JPG Location Graph",
      "PDF Location Graph",
      "JPG 3D Graph",
      "JPG 3D Full-Period",
      "Screenshot",
      "Screenshot+Click",
      "Screenshot+Drag",
      "REC. Time Graph",
      "REC. Location Graph",
      "REC. Solid Graph",
      "REC. Screenshot",
      "Stop REC.",
      "Erase All Model1Ds",
      "Erase All Model2Ds",
      "Erase All Groups",
      "Erase All Solids",
      "Erase All Sections",
      "Erase All Cameras",
      "Erase Faces",
      "Erase Curves",
      "Erase All",
      "Display All Viewports",
      "Enlarge 3D Viewport",
      "Enlarge Map Viewport",
      "Enlarge Time Viewport",
    }
    ,
    {
      "Region",
      "Use typical year (TMY)",
      "Use long-term (CWEEDS)",
      "Use long-term (CLMREC)",
      "Use real-time observed (SWOB)",
      "Use weather forecast (NAEFS)",

      "Update TMYEPW",
      "Update CWEEDS",
      "Update CLMREC",
      "Update SWOB",
      "Update NAEFS",
      "Update Aerial",
      "Update Station",

      "Load Land Mesh",
      "Load Land Texture",
      "Download Land Mesh",
      "Download Land Texture",
      "Download Toroposphere",
      "Download NAEFS",
      "Download SWOB",
      "Download CLMREC",
      "Download Aerial",

      "Display/Hide TMYEPW stations",
      "Display/Hide TMYEPW nearest",
      "Display/Hide CWEEDS stations",
      "Display/Hide CWEEDS nearest",
      "Display/Hide CLMREC stations",
      "Display/Hide CLMREC nearest",
      "Display/Hide SWOB stations",
      "Display/Hide SWOB nearest",
      "Display/Hide NAEFS stations",
      "Display/Hide NAEFS nearest"
    }
    ,
    {
      "Layer"
      // Parameters are added here later in the process.
    }
    ,
    {
      "Study",
      "Wind pattern (active)",
      "Wind pattern (passive)",
      "Urban solar potential (active)",
      "Urban solar potential (passive)",
      "Orientation potential (active)",
      "Orientation potential (passive)",
      "Hourly sun position (active)",
      "Hourly sun position (passive)",
      "View from sun & sky (active)",
      "View from sun & sky (passive)",
      "Annual cycle sun path (active)",
      "Annual cycle sun path (passive)",
      "Render Viewport",
      "PreBake Viewport",
      "Pre-bake Selected Sections",
      "Process Active Impact",
      "Process Passive Impact",
      "Process Solid Impact",
      "Run wind 3D-model"
    }
    ,
    {
      "Setup",
      "Layout -2",
      "Layout -1",
      "Layout 0",
      "Layout 1",
      "Layout 2",
      "Layout 3",
      "Layout 4",
      "Layout 5",
      "Layout 6",
      "Layout 7",
      "Layout 8",
      "3D-model 1",
      "3D-model 2",
      "3D-model 3",
      "3D-model 4",
      "3D-model 5",
      "3D-model 6"
    }
    ,
    {
      "3D-view",
      "Camera >> Viewport",
      "GoTo Selected Camera",
      "Top",
      "Front",
      "Left",
      "Back",
      "Right",
      "Bottom",
      "S.W.",
      "S.E.",
      "N.E.",
      "N.W.",
      "Perspective",
      "Orthographic",
      "Zoom",
      "Zoom as default",
      "Look at origin",
      "Look at direction",
      "Look at selection",
      "Pan",
      "PanX",
      "PanY",
      "LandOrbit",
      "Orbit",
      "OrbitXY",
      "OrbitZ",
      "CameraRoll",
      "CameraRollXY",
      "CameraRollZ",
      "TargetRoll",
      "TargetRollXY",
      "TargetRollZ",
      "TruckX",
      "TruckY",
      "TruckZ",
      "DistZ",
      "DistMouseXY",
      "CameraDistance",
      "3DModelSize",
      "SkydomeSize"
    }
    ,
    {
      "3D-display",
      "Display/Hide Land Mesh",
      "Display/Hide Land Texture",
      "Display/Hide Land Points",
      "Display/Hide Land Depth",
      "Display/Hide Vertices",
      "Display/Hide Edges",
      "Display/Hide Normals",
      "Display/Hide Leaves",
      "Display/Hide Model1Ds",
      "Display/Hide Model2Ds",
      "Display/Hide Curves",
      "Display/Hide Faces",
      "Display/Hide Solids",
      "Display/Hide Sections",
      "Display/Hide Cameras",
      "Display/Hide Sky",
      "Display/Hide Sun Grid",
      "Display/Hide Sun Path",
      "Display/Hide Sun Pattern",
      "Display/Hide Sun Surface",
      "Display/Hide Moon Surface",
      "Display/Hide Troposphere",
      "Display/Hide Earth Surface",
      "Display/Hide Solar Section",
      "Display/Hide Solid Section",
      "Display/Hide Wind Flow",
      "Display/Hide Selected Solids",
      "Display/Hide Selected Sections",
      "Display/Hide Selected Cameras",
      "Display/Hide Selected LandPoints",
      "Display/Hide Selected Faces",
      "Display/Hide Selected Faces Vertex Count",
      "Display/Hide Selected Curves Vertex Count",
      "Display/Hide Selected Vertices",
      "Display/Hide Selected REF Pivot",
      "Display/Hide Selected Group Pivot",
      "Display/Hide Selected Group Edges",
      "Display/Hide Selected Group Box",
      "Display/Hide Selected 2D Edges",
      "Display/Hide Selected 1D Edges",
    }
    ,
    {
      "3D-shade",
      "Shade Surface Wire",
      "Shade Surface Base",
      "Shade Surface White",
      "Shade Surface Materials",
      "Shade Global Solar",
      "Shade Vertex Solar",
      "Shade Vertex Solid",
      "Shade Vertex Elevation"
    }
    ,
    {
      "3D-create",
      "Begin New Group at Origin",
      "Begin New Group at Pivot",
      "LandMesh >> Group",
      "LandGap >> Group",
      "Viewport >> Camera",
      "Camera",
      "Section",
      "Solid",
      "Point",
      "Spline",
      "Surface",
      "3D-Tree",
      "2D-Tree",
      "Person",
      "Add People on Land",
      "Add 2D-Trees on Land",
      "Add 3D-Trees on Land",
      "House1",
      "House2",
      "House3",
      "Box",
      "Cushion",
      "Cylinder",
      "Sphere",
      "Octahedron",
      "Icosahedron",
      "Tri",
      "Hyper",
      "Plane",
      "Poly",
      "Extrude",
      "Parametric 1",
      "Parametric 2",
      "Parametric 3",
      "Parametric 4",
      "Parametric 5",
      "Parametric 6",
      "Parametric 7",
      "Get dX",
      "Get dY",
      "Get dZ",
      "Get dXYZ",
      "Get dXY",
      "Get Angle"
    }
    ,
    {
      "3D-select",
      "Invert Selection",
      "Deselect All",
      "Select All",
      "Select All Cameras",
      "Select All Curves",
      "Select All Faces",
      "Select All Groups",
      "Select All LandPoints",
      "Select All Model1Ds",
      "Select All Model2Ds",
      "Select All Sections",
      "Select All Solids",
      "Select All Vertices",
      "Select Scene Isolated Vertices",
      "Select Near Selected Vertices",
      "Select Curve",
      "Select Camera",
      "Select Face",
      "Select Group",
      "Select LandPoint",
      "Select Model1Ds",
      "Select Model2Ds",
      "Select Section",
      "Select Solid",
      "Select Vertex",
      "Soft Selection",
      "Curves >> Vertices",
      "Vertices >> Curves",
      "Faces >> Vertices",
      "Vertices >> Faces",
      "Groups >> Curves",
      "Groups >> Faces",
      "Groups >> Solids",
      "Groups >> Model2Ds",
      "Groups >> Model1Ds",
      "Groups >> Vertices",
      "Curves >> Groups",
      "Faces >> Groups",
      "Model1Ds >> Groups",
      "Model2Ds >> Groups",
      "Solids >> Groups",
      "Vertices >> Groups",
      "Pick Select",
      "Pick Select+",
      "Pick Select-",
      "Window Select",
      "Window Select+",
      "Window Select-"
    }
    ,
    {
      "3D-alter",
      "Move",
      "MoveX",
      "MoveY",
      "MoveZ",
      "Rotate",
      "RotateX",
      "RotateY",
      "RotateZ",
      "Scale",
      "ScaleX",
      "ScaleY",
      "ScaleZ",
      "Power",
      "PowerX",
      "PowerY",
      "PowerZ",
      "Flip Normal",
      "Set-Out Normal",
      "Set-In Normal",
      "Get FirstVertex",
      "Change Seed/Material",
      "Change tessellation",
      "Change Layer",
      "Change Visibility",
      "Change Weight",
      "Change DegreeMax",
      "Change BranchTilt",
      "Change BranchTwist",
      "Change BranchRatio",
      "Change TreeBase",
      "Change TrunkSize",
      "Change LeafSize"
    }
    ,
    {
      "3D-modify",
      "Clone Selection (Identical)",
      "Clone Selection (Variation)",
      "Attach to Last Group",
      "Dettach from Groups Selection",
      "Group Selection",
      "Ungroup Selection",
      "Delete Scene Empty Groups",
      "Delete Selection",
      "Delete Scene Isolated Vertices",
      "Delete Selection Isolated Vertices",
      "Separate Selected Vertices",
      "Reposition Selected Vertices",
      "Weld Objects Selected Vertices",
      "Weld Scene Selected Vertices",
      "Offset(above) Vertices",
      "Offset(below) Vertices",
      "Offset(expand) Vertices",
      "Offset(shrink) Vertices",
      "Extrude Face Edges",
      "Extrude Curve Edges",
      "Optimize Faces",
      //"Triangulate Faces",
      "tessellation Triangular",
      "Tessellate Rectangular",
      "Tessellate Rows & Columns",
      "Auto-Normal Selected Faces",
      "Force Triangulate Selected Faces",
      "Insert Corner Opennings",
      "Insert Parallel Opennings",
      "Insert Rotated Opennings",
      "Insert Edge Opennings",
      "Reverse Visibility of All Faces",
      "Hide All Faces",
      "Hide Selected Faces",
      "Unhide Selected Faces",
      "Unhide All Faces",
      "Isolate Selection",
      "Reverse Visibility of All Curves",
      "Hide All Curves",
      "Hide Selected Curves",
      "Unhide Selected Curves",
      "Unhide All Curves",
      "Flatten Selected LandPoints"
    }
    ,
    {
      "3D-match",
      "Save Current ReferenceBox",
      "Reset Saved ReferenceBox",
      "Use Selection ReferenceBox",
      "Use Origin ReferenceBox",
      "PivotX:Minimum",
      "PivotX:Center",
      "PivotX:Maximum",
      "PivotY:Minimum",
      "PivotY:Center",
      "PivotY:Maximum",
      "PivotZ:Minimum",
      "PivotZ:Center",
      "PivotZ:Maximum",
      "Pick Seed/Material",
      "Pick tessellation",
      "Pick Layer",
      "Pick Visibility",
      "Pick DegreeMax",
      "Pick TrunkSize",
      "Pick LeafSize",
      "Pick Model1DsProps",
      "Assign Seed/Material",
      "Assign tessellation",
      "Assign Layer",
      "Assign Visibility",
      "Assign DegreeMax",
      "Assign TrunkSize",
      "Assign LeafSize",
      "Assign Model1DsProps",
      "Assign Pivot",
      "Drop on LandSurface",
      "Drop on ModelSurface (Up)",
      "Drop on ModelSurface (Down)"
    }
  };





  private int LayersID_in_Bar;

  solarchvision_UI_menuBar () { // constructor

    // finding id of "Layer" in the list

    LayersID_in_Bar = -1;
    for (int i = 0; i < this.Items.length; i++) {
       if (this.Items[i][0].equals("Layer")) {
         LayersID_in_Bar = i;
         break;
       }
    }

    this.Items[LayersID_in_Bar] = new String [numberOfLayers + 12];

    this.Items[LayersID_in_Bar][0] = "Layer";

    for (int i = 0; i < numberOfLayers; i++) {

      this.Items[LayersID_in_Bar][i + 1] = allLayers[i].descriptions[Language_EN];
    }

    this.Items[LayersID_in_Bar][numberOfLayers + 0] = "12h accumulated Precipitation";
    this.Items[LayersID_in_Bar][numberOfLayers + 1] = "Hourly precipitation";
    this.Items[LayersID_in_Bar][numberOfLayers + 2] = "Wind power";
    this.Items[LayersID_in_Bar][numberOfLayers + 3] = "Accumulated degree day <18°C<";
    this.Items[LayersID_in_Bar][numberOfLayers + 4] = "Accumulated radiation on tracker";
    this.Items[LayersID_in_Bar][numberOfLayers + 5] = "Accumulated radiation on surface";
    this.Items[LayersID_in_Bar][numberOfLayers + 6] = "Radiation on surface inclination";
    this.Items[LayersID_in_Bar][numberOfLayers + 7] = "Radiation on solar tracker";
    this.Items[LayersID_in_Bar][numberOfLayers + 8] = "Radiation on surface material";
    this.Items[LayersID_in_Bar][numberOfLayers + 9] = "Normal trend of parameter";
    this.Items[LayersID_in_Bar][numberOfLayers + 10] = "Passive trend of parameter";
    this.Items[LayersID_in_Bar][numberOfLayers + 11] = "Active trend of parameter";
  }


  void draw () {

    if (this.update) {

      //println("update BAR!");

      this.updated();

      fill(127);
      noStroke();

      rect(0, 0, width, SOLARCHVISION_pixel_A);

      STUDY.X_control = 0; //0.25 * MessageSize;
      STUDY.Y_control = 0.5 * SOLARCHVISION_pixel_A;

      for (int i = 0; i < this.Items.length; i++) {

        float cx = STUDY.X_control + i * this.width_parent;
        float cy = STUDY.Y_control;
        float cr = 0.5 * SOLARCHVISION_pixel_A;

        if (isInside(mouseX, mouseY, cx, cy - cr, cx + this.width_parent, cy + cr)) {

          if (this.selected_parent == -1) {

            pre_screen = get(0, SOLARCHVISION_pixel_A, width, height - SOLARCHVISION_pixel_A);

            //println("Screen GET!");
          }

          this.selected_parent = i;

          this.selected_child = 0;
        }


        textAlign(LEFT, CENTER);

        if (this.selected_parent == i) {

          stroke(0);
          fill(0);
          textSize(1.25 * MessageSize);
        } else {
          stroke(255);
          fill(255);
          textSize(1.25 * MessageSize);
        }

        text(this.Items[i][0], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize);



        if (this.selected_parent == i) {

          image(pre_screen, 0, SOLARCHVISION_pixel_A);

          this.selected_child = 0;


          float widthChildren = this.width_child;

          for (int j = 1; j < this.Items[this.selected_parent].length; j++) {
            float estimatedWidth = this.Items[this.selected_parent][j].length() * MessageSize * 0.55;
            if (widthChildren < estimatedWidth) widthChildren = estimatedWidth;
          }

          for (int j = 1; j < this.Items[this.selected_parent].length; j++) {

            if (isInside(UI_X_moved, UI_Y_moved, cx, ceil(cy - cr + j * SOLARCHVISION_pixel_A * 0.85) + 1, cx + widthChildren, floor(cy + cr + j * SOLARCHVISION_pixel_A * 0.85) - 1)) {

              this.selected_child = j;

              fill(255, 127, 0);
              noStroke();
              rect(cx, cy - cr + j * SOLARCHVISION_pixel_A * 0.85, widthChildren, SOLARCHVISION_pixel_A * 0.85);
            } else {

              fill(0, 223);
              noStroke();
              rect(cx, cy - cr + j * SOLARCHVISION_pixel_A * 0.85, widthChildren, SOLARCHVISION_pixel_A * 0.85);
            }

            textAlign(LEFT, CENTER);

            if (this.selected_child == j) {

              stroke(0);
              fill(0);
            } else {
              stroke(255);
              fill(255);

              if (this.Items[i][0].equals("Region")) {
                if (this.Items[i][j].equals("Display/Hide SWOB stations")) {
                  if (WORLD.displayAll_SWOB == 0) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide SWOB nearest")) {
                  if (WORLD.displayNear_SWOB == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide NAEFS stations")) {
                  if (WORLD.displayAll_NAEFS == 0) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide NAEFS nearest")) {
                  if (WORLD.displayNear_NAEFS == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CWEEDS stations")) {
                  if (WORLD.displayAll_CWEEDS == 0) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CWEEDS nearest")) {
                  if (WORLD.displayNear_CWEEDS == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CLMREC stations")) {
                  if (WORLD.displayAll_CLMREC == 0) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CLMREC nearest")) {
                  if (WORLD.displayNear_CLMREC == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide TMYEPW stations")) {
                  if (WORLD.displayAll_TMYEPW == 0) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide TMYEPW nearest")) {
                  if (WORLD.displayNear_TMYEPW == false) {
                    stroke(127);
                    fill(127);
                  }
                }
              }

              if (this.Items[i][0].equals("Display")) {
                if (this.Items[i][j].equals("Display/Hide Land Mesh")) {
                  if (Land3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Land Texture")) {
                  if (Land3D.displayTexture == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Land Points")) {
                  if (Land3D.displayPoints == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Land Depth")) {
                  if (Land3D.displayDepth == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Vertices")) {
                  if (allPoints.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Edges")) {
                  if (allFaces.displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Normals")) {
                  if (allFaces.displayNormals == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Leaves")) {
                  if (allModel1Ds.displayLeaves == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Model1Ds")) {
                  if (allModel1Ds.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Model2Ds")) {
                  if (allModel2Ds.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Curves")) {
                  if (allFaces.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Faces")) {
                  if (allFaces.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Solids")) {
                  if (allSolids.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sections")) {
                  if (allSections.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Cameras")) {
                  if (allCameras.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sky")) {
                  if (Sky3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Grid")) {
                  if (Sun3D.displayGrid == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Path")) {
                  if (Sun3D.displayPath == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Pattern")) {
                  if (Sun3D.displayPattern == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Surface")) {
                  if (Sun3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Moon Surface")) {
                  if (Moon3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Earth Surface")) {
                  if (Earth3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Troposphere")) {
                  if (Tropo3D.displaySurface == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Solar Section")) {
                  if (allSolarImpacts.displayImage == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Solid Section")) {
                  if (allSolidImpacts.displayImage == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Wind Flow")) {
                  if (allWindFlows.displayAll == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Solids")) {
                  if (Select3D.Solid_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Sections")) {
                  if (Select3D.Section_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Cameras")) {
                  if (Select3D.Camera_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected LandPoints")) {
                  if (Select3D.LandPoint_displayPoints == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Faces")) {
                  if (Select3D.Face_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Curves")) {
                  if (Select3D.Curve_displayVertices == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Faces Vertex Count")) {
                  if (Select3D.Face_displayVertexCount == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Curves Vertex Count")) {
                  if (Select3D.Curve_displayVertexCount == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Vertices")) {
                  if (Select3D.Vertex_displayVertices == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected REF Pivot")) {
                  if (Select3D.displayReferencePivot == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Group Pivot")) {
                  if (Select3D.displayReferencePivot == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Group Edges")) {
                  if (Select3D.Group_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Group Box")) {
                  if (Select3D.Group_displayBox == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected 2D Edges")) {
                  if (Select3D.Model2D_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected 1D Edges")) {
                  if (Select3D.Model1D_displayEdges == false) {
                    stroke(127);
                    fill(127);
                  }
                }
              }
            }

            textSize(MessageSize);
            text(this.Items[i][j], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize + j * SOLARCHVISION_pixel_A * 0.85);
          }
        }
      }

      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }

  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_UI_menuBar UI_menuBar = new solarchvision_UI_menuBar();



class solarchvision_UI_toolBar {

  private final static String CLASS_STAMP = "UI_toolBar";

  boolean update = true;

  float tab = SOLARCHVISION_pixel_B;

  String[][] Items = {
    {
      "11", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Cam00", "3DViewPoint", "2.0"
    }
    ,
    {
      "2", "AllViewports", "Expand3DView", "ExpandTimeView", "ExpandMapView", "3DViewSpace", "1"
    }
    ,

    {
      "2", "P<>", "P><", "ProjectionType", "1.0"
    }
    ,
    {
      "1", "LAO", "LookAtOrigin", "1.0"
    }
    ,
    {
      "1", "LAD", "LookAtDirection", "1.0"
    }
    ,
    {
      "1", "LAS", "LookAtSelection", "1.0"
    }
    ,
    {
      "3", "CRL", "CRLz", "CRLxy", "CameraRoll", "1.0"
    }
    ,
    {
      "1", "±CDS", "CameraDistance", "1.0"
    }
    ,
    {
      "1", "±CDM", "DistMouseXY", "1.0"
    }
    ,
    {
      "1", "±CDZ", "DistZ", "1.0"
    }
    ,
    {
      "3", "DIz", "DIx", "DIy", "Truck", "1.0"
    }
    ,
    {
      "1", "LNOR", "LandOrbit", "1.0"
    }
    ,
    {
      "1", "OR", "ORxy", "ORz", "Orbit", "1.0"
    }
    ,
    {
      "1", "TRL", "TRLz", "TRLxy", "TargetRoll", "1.0"
    }
    ,
    {
      "1", "Pan", "PanX", "PanY", "Pan", "1.0"
    }
    ,
    {
      "1", "±ZM", "0ZM", "Zoom", "1.0"
    }
    ,
    {
      "1", "±SA", "AllModelSize", "1.0"
    }
    ,
    {
      "1", "±SZ", "3DModelSize", "1.0"
    }
    ,
    {
      "1", "±SK", "SkydomeSize", "1.0"
    }
    ,

    {
      "3", "3D-Tree", "2D-Tree", "Person", "Model2DsType", "1.5"
    }
    ,
    {
      "1", "House1", "House2", "House3", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Icosahedron", "Tri", "Hyper", "Plane", "Poly", "Extrude", "Parametric", "Point", "Spline", "Surface", "BuildingType", "2.5"
    }
    ,
    {
      "1", "as_Mesh", "as_Solid", "Mesh|Solid", "2.0"
    }
    ,

    {
      "4", "Land", "1D", "2D", "Group", "Face", "Vertex", "Soft", "Solid", "Section", "Camera", "Curve", "LayerType", "2.0"
    }
    ,
    {
      "1", "±PS", "+PS", "-PS", "PickSelect", "1.0"
    }
    ,
    {
      "1", "±WS", "+WS", "-WS", "WindowSelect", "1.0"
    }
    ,
    {
      "2", "X<", "X|", "X>", "PivotX", "1.0"
    }
    ,
    {
      "2", "Y<", "Y|", "Y>", "PivotY", "1.0"
    }
    ,
    {
      "2", "Z<", "Z|", "Z>", "PivotZ", "1.0"
    }
    ,
    //{"1", "DrL±", "DrM+", "DrM-", "Drop", "1.0"},
    {
      "4", "GLx", "GLy", "GLz", "GL³", "GL²", "GLa", "GetLength", "1.0"
    }
    ,
    {
      "3", "MVx", "MVy", "MVz", "MV³", "Move", "1.0"
    }
    ,
    {
      "3", "SCx", "SCy", "SCz", "SC³", "Scale", "1.0"
    }
    ,
    {
      "3", "RTx", "RTy", "RTz", "Rotate", "1.0"
    }
    ,
    //{"3", "PWx", "PWy", "PWz", "PW³", "Power", "1.0"},
    {
      "1", "Mat0", "Mat1", "Mat2", "Mat3", "Change Seed/Material", "1.0"
    }
    ,
    {
      "1", "Tes0", "Tes1", "Tes2", "Tes3", "Change tessellation", "1.0"
    }
    ,
    {
      "1", "Lyr0", "Lyr1", "Lyr2", "Lyr3", "Change Layer", "1.0"
    }
    ,
    {
      "1", "Vsb0", "Vsb1", "Vsb2", "Vsb3", "Change Visibility", "1.0"
    }
    ,
    {
      "1", "Wgt0", "Wgt1", "Wgt2", "Wgt3", "Change Weight", "1.0"
    }
    ,
    {
      "1", "Norm1", "Norm2", "Norm3", "Normal", "1.0"
    }
    ,
    {
      "1", "1stV", "FirstVertex", "1.0"
    }
    ,


    //{"1", "<pvt>", ">pvt<", "|pvt|", ".pvt.", "Get/Set Pivot", "1.0"},

    //{"1", "SPvt0", "SPvt1", "SPvt2", "Pivot", "1.0"},

    //{"1", "dgMax0", "dgMax1", "dgMax2", "Change DegreeMax", "1.0"},
    //{"1", "bTilt0", "bTilt1", "bTilt2", "Change BranchTilt", "1.0"},
    //{"1", "bTwist0", "bTwist1", "bTwist2", "Change BranchTwist", "1.0"},
    //{"1", "bTwist0", "bTwist1", "bTwist2", "Change BranchTwist", "1.0"},
    //{"1", "bRatio0", "bRatio1", "bRatio2", "Change BranchRatio", "1.0"},
    //{"1", "tBase0", "tBase1", "tBase2", "Change TreeBase", "1.0"},

    //{"1", "trSz0", "trSz1", "trSz2", "Change TrunkSize", "1.0"},
    //{"1", "lfSz0", "lfSz1", "lfSz2", "Change LeafSize", "1.0"},
    //{"1", "allFP0", "allFP1", "allFP2", "Model1DsProps", "1.0"},

    //{"1", "SEC", "Section", "1.0"},
    //{"1", "SLD", "Solid", "1.0"},
    //{"1", "CAM", "Pick Study Camera", "1.0"},
  };



  int Selection = -1;


  boolean displayText;


  void highlight (String s) {

    int break_loops = 0;

    for (int i = 0; i < this.Items.length; i++) {
      for (int j = 1; j < this.Items[i].length - 2; j++) {
        if (this.Items[i][j].equals(s)) {

          this.Items[i][0] = nf(j, 0);

          break_loops = 1;
        }

        if (break_loops == 1) break;
      }
      if (break_loops == 1) break;
    }
  }


  void draw () {

    if (this.update) {

      this.updated();

      fill(0);
      noStroke();
      rect(0, SOLARCHVISION_pixel_A, width, SOLARCHVISION_pixel_B);

      STUDY.X_control = 0; //0.25 * MessageSize;
      STUDY.Y_control = SOLARCHVISION_pixel_A + 0.5 * SOLARCHVISION_pixel_B;

      float cx = STUDY.X_control;
      float cy = STUDY.Y_control;
      float cr = 0.5 * SOLARCHVISION_pixel_B;

      for (int i = 0; i < this.Items.length; i++) {

        {
          String Bar_Switch = this.Items[i][this.Items[i].length - 2];

          if (Bar_Switch.equals("LayerType")) {
            this.Items[i][0] = nf(current_ObjectCategory + 1, 0);
          }
        }



        int j = int(this.Items[i][0]);

        float Item_width = this.tab * float(this.Items[i][this.Items[i].length - 1]);

        noFill();
        stroke(255);
        strokeWeight(1);
        rect(cx, cy - cr, Item_width, SOLARCHVISION_pixel_B);
        strokeWeight(0);




        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + Item_width, cy + cr)) {

          if (mouseButton == RIGHT) {

            if (this.Selection != i) {
              this.Selection = i;
            } else {

              int n = int(this.Items[i][0]);

              n -= 1;

              if (n <= 0) n = this.Items[i].length - 3;

              this.Items[i][0] = nf(n, 0);

              j = n;
            }
          }

          if (mouseButton == LEFT) {

            if (this.Selection != i) {
              this.Selection = i;
            } else {

              int n = int(this.Items[i][0]);

              n += 1;

              if (n >= this.Items[i].length - 2) n = 1;

              this.Items[i][0] = nf(n, 0);

              j = n;
            }
          }


          fill(255, 127, 0);
          noStroke();
          rect(cx, cy - cr, Item_width, SOLARCHVISION_pixel_B);

          String Bar_Switch = this.Items[i][this.Items[i].length - 2];


          if (Bar_Switch.equals("LayerType")) {
            current_ObjectCategory = j - 1;

            if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
              Select3D.convert_Vertex_to_softSelection();
            }

            ROLLOUT.revise();
            SOLARCHVISION_view_changed();
          }

          if (Bar_Switch.equals("Mesh|Solid")) {
            User3D.create_MeshOrSolid = j - 1;

            ROLLOUT.revise();
          }

          if ((Bar_Switch.equals("Model2DsType")) || (Bar_Switch.equals("BuildingType"))) {
            if ((this.Items[i][j]).equals("3D-Tree")) UI_set_to_Create_allModel1Ds();
            else if ((this.Items[i][j]).equals("2D-Tree")) UI_set_to_Create_Tree();
            else if ((this.Items[i][j]).equals("Person")) UI_set_to_Create_Person();
            else if ((this.Items[i][j]).equals("Point")) UI_set_to_Create_Vertex();
            else if ((this.Items[i][j]).equals("Spline")) UI_set_to_Create_Curve();
            else if ((this.Items[i][j]).equals("Surface")) UI_set_to_Create_Face();
            else if ((this.Items[i][j]).equals("Tri")) UI_set_to_Create_Tri();
            else if ((this.Items[i][j]).equals("Plane")) UI_set_to_Create_Plane();
            else if ((this.Items[i][j]).equals("Poly")) UI_set_to_Create_Poly();
            else if ((this.Items[i][j]).equals("Extrude")) UI_set_to_Create_Extrude();
            else if ((this.Items[i][j]).equals("Hyper")) UI_set_to_Create_Hyper();
            else if ((this.Items[i][j]).equals("House3")) UI_set_to_Create_House3();
            else if ((this.Items[i][j]).equals("House2")) UI_set_to_Create_House2();
            else if ((this.Items[i][j]).equals("House1")) UI_set_to_Create_House1();
            else if ((this.Items[i][j]).equals("Box")) UI_set_to_Create_Box();
            else if ((this.Items[i][j]).equals("Icosahedron")) UI_set_to_Create_Octahedron();
            else if ((this.Items[i][j]).equals("Octahedron")) UI_set_to_Create_Octahedron();
            else if ((this.Items[i][j]).equals("Sphere")) UI_set_to_Create_Sphere();
            else if ((this.Items[i][j]).equals("Cylinder")) UI_set_to_Create_Cylinder();
            else if ((this.Items[i][j]).equals("Cushion")) UI_set_to_Create_Cushion();
            else if ((this.Items[i][j]).equals("Parametric")) UI_set_to_Create_Parametric(User3D.create_Parametric_Type);
          }

          if (Bar_Switch.equals("Change Seed/Material")) {
            if ((this.Items[i][j]).equals("Mat0")) UI_set_to_Modify_Seed(0);
            if ((this.Items[i][j]).equals("Mat1")) UI_set_to_Modify_Seed(1);
            if ((this.Items[i][j]).equals("Mat2")) UI_set_to_Modify_Seed(2);
            if ((this.Items[i][j]).equals("Mat3")) UI_set_to_Modify_Seed(3);
          }

          if (Bar_Switch.equals("Change tessellation")) {
            if ((this.Items[i][j]).equals("Tes0")) UI_set_to_Modify_Tessellation(0);
            if ((this.Items[i][j]).equals("Tes1")) UI_set_to_Modify_Tessellation(1);
            if ((this.Items[i][j]).equals("Tes2")) UI_set_to_Modify_Tessellation(2);
            if ((this.Items[i][j]).equals("Tes3")) UI_set_to_Modify_Tessellation(3);
          }

          if (Bar_Switch.equals("Change Layer")) {
            if ((this.Items[i][j]).equals("Lyr0")) UI_set_to_Modify_Layer(0);
            if ((this.Items[i][j]).equals("Lyr1")) UI_set_to_Modify_Layer(1);
            if ((this.Items[i][j]).equals("Lyr2")) UI_set_to_Modify_Layer(2);
            if ((this.Items[i][j]).equals("Lyr3")) UI_set_to_Modify_Layer(3);
          }

          if (Bar_Switch.equals("Change Visibility")) {
            if ((this.Items[i][j]).equals("Vsb0")) UI_set_to_Modify_Visibility(0);
            if ((this.Items[i][j]).equals("Vsb1")) UI_set_to_Modify_Visibility(1);
            if ((this.Items[i][j]).equals("Vsb2")) UI_set_to_Modify_Visibility(2);
            if ((this.Items[i][j]).equals("Vsb3")) UI_set_to_Modify_Visibility(3);
          }

          if (Bar_Switch.equals("Change Weight")) {
            if ((this.Items[i][j]).equals("Wgt0")) UI_set_to_Modify_Weight(0);
            if ((this.Items[i][j]).equals("Wgt1")) UI_set_to_Modify_Weight(1);
            if ((this.Items[i][j]).equals("Wgt2")) UI_set_to_Modify_Weight(2);
            if ((this.Items[i][j]).equals("Wgt3")) UI_set_to_Modify_Weight(3);
          }

          if (Bar_Switch.equals("Normal")) {
            if ((this.Items[i][j]).equals("Norm1")) UI_set_to_Modify_Normal(1);
            if ((this.Items[i][j]).equals("Norm2")) UI_set_to_Modify_Normal(2);
            if ((this.Items[i][j]).equals("Norm3")) UI_set_to_Modify_Normal(3);
          }

          if (Bar_Switch.equals("FirstVertex")) {
            if ((this.Items[i][j]).equals("1stV")) UI_set_to_Modify_FirstVertex(1);
          }



          if (Bar_Switch.equals("Rotate")) UI_set_to_Modify_Rotate(j - 1);
          if (Bar_Switch.equals("Power")) UI_set_to_Modify_Power(j - 1);
          if (Bar_Switch.equals("Scale")) UI_set_to_Modify_Scale(j - 1);
          if (Bar_Switch.equals("Move")) UI_set_to_Modify_Move(j - 1);
          if (Bar_Switch.equals("GetLength")) UI_set_to_Modify_GetLength(j - 1);
          if (Bar_Switch.equals("Drop")) UI_set_to_Modify_Drop(j - 1);

          if (Bar_Switch.equals("ProjectionType")) UI_set_to_View_ProjectionType(j - 1);

          if (Bar_Switch.equals("PickSelect")) UI_set_to_View_PickSelect(j - 1);
          if (Bar_Switch.equals("WindowSelect")) UI_set_to_View_WindowSelect(j - 1);

          if (Bar_Switch.equals("PivotX")) UI_set_to_View_PivotX(j - 2);
          if (Bar_Switch.equals("PivotY")) UI_set_to_View_PivotY(j - 2);
          if (Bar_Switch.equals("PivotZ")) UI_set_to_View_PivotZ(j - 2);

          if (Bar_Switch.equals("LandOrbit")) UI_set_to_View_LandOrbit(0);

          if (Bar_Switch.equals("Orbit")) UI_set_to_View_Orbit(j - 1);
          if (Bar_Switch.equals("CameraRoll")) UI_set_to_View_CameraRoll(j - 1);
          if (Bar_Switch.equals("TargetRoll")) UI_set_to_View_TargetRoll(j - 1);

          if (Bar_Switch.equals("LookAtOrigin")) UI_set_to_View_LookAtOrigin(j - 1);
          if (Bar_Switch.equals("LookAtDirection")) UI_set_to_View_LookAtDirection(j - 1);
          if (Bar_Switch.equals("LookAtSelection")) UI_set_to_View_LookAtSelection(j - 1);

          if (Bar_Switch.equals("Pan")) {

            UI_set_to_View_Pan(j - 1);
          }

          if (Bar_Switch.equals("Zoom")) {
            UI_set_to_View_ZOOM(j - 1);

            this.Items[i][0] = "1"; // << set it to default choice next time
          }

          if (Bar_Switch.equals("CameraDistance")) UI_set_to_View_CameraDistance(0);

          if (Bar_Switch.equals("DistMouseXY")) UI_set_to_View_DistMouseXY(0);

          if (Bar_Switch.equals("DistZ")) UI_set_to_View_Truck(0);
          if (Bar_Switch.equals("Truck")) UI_set_to_View_Truck(j - 1);

          if (Bar_Switch.equals("3DModelSize")) UI_set_to_View_3DModelSize();

          if (Bar_Switch.equals("SkydomeSize")) UI_set_to_View_SkydomeSize();

          if (Bar_Switch.equals("AllModelSize")) UI_set_to_View_AllModelSize();

          if (Bar_Switch.equals("3DViewSpace")) UI_set_to_Viewport(j - 1);

          if (Bar_Switch.equals("3DViewPoint")) UI_set_to_View_3DViewPoint(j - 1);
        }


        this.displayText = true;

        { // drawing the icons where available

          String Bar_Switch = this.Items[i][this.Items[i].length - 2];

          if (Bar_Switch.equals("Drop")) {
            UI_toolBar.drawDrop(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("GetLength")) {
            UI_toolBar.drawGetLength(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Move")) {
            UI_toolBar.drawMove(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Scale")) {
            UI_toolBar.drawScale(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Power")) {
            UI_toolBar.drawPower(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Rotate")) {
            UI_toolBar.drawRotate(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Seed/Material")) {
            UI_toolBar.drawSeed(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change tessellation")) {
            UI_toolBar.drawtessellation(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Layer")) {
            UI_toolBar.drawLayer(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Visibility")) {
            UI_toolBar.drawVisibility(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Weight")) {
            UI_toolBar.drawWeight(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Normal")) {
            UI_toolBar.drawNormal(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("FirstVertex")) {
            UI_toolBar.drawFirstVertex(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }

          if (Bar_Switch.equals("PickSelect")) {
            UI_toolBar.drawPickSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("WindowSelect")) {
            UI_toolBar.drawWindowSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("ProjectionType")) {
            UI_toolBar.drawProjectionType(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Zoom")) {
            UI_toolBar.drawZOOM(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("LandOrbit")) {
            UI_toolBar.drawLandOrbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Orbit")) {
            UI_toolBar.drawOrbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("CameraRoll")) {
            UI_toolBar.drawCameraRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("TargetRoll")) {
            UI_toolBar.drawTargetRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("CameraDistance")) {
            UI_toolBar.drawCameraDistance(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("LookAtOrigin")) {
            UI_toolBar.drawLookAtOrigin(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("LookAtDirection")) {
            UI_toolBar.drawLookAtDirection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("LookAtSelection")) {
            UI_toolBar.drawLookAtSelection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Pan")) {
            UI_toolBar.drawPan(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("DistMouseXY")) {
            UI_toolBar.drawDistMouseXY(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("DistZ")) {
            UI_toolBar.drawDistZ(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Truck")) {
            UI_toolBar.drawTruck(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("3DModelSize")) {
            UI_toolBar.draw3DModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("SkydomeSize")) {
            UI_toolBar.drawSkydomeSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("AllModelSize")) {
            UI_toolBar.drawAllModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }

          if (Bar_Switch.equals("3DViewSpace")) {
            UI_toolBar.draw3DViewSpace(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
        }

        if (this.displayText) { // writing titles where the icon is not available

          textAlign(CENTER, CENTER);
          stroke(255);
          fill(255);
          textSize(0.45 * SOLARCHVISION_pixel_B);

          text(this.Items[i][j], cx + 0.5 * Item_width, cy - 0.2 * MessageSize);
        }


        cx += Item_width;
      }


      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }

  void drawMouse (int _type, float x, float y, float r) {

    float d = 0.4 * r;

    for (int i = 0; i < 3; i++) {

      float dx = 0;
      float dy = 0;

      if (i == 0) {
        dx = 0.5 * d;
        dy = 0.5 * d;
        strokeWeight(1);
        stroke(63);
        fill(63);
      } else if (i == 1) {
        strokeWeight(3);
        stroke(0);
        fill(0);
      } else {
        strokeWeight(1);
        stroke(1);
        stroke(255);
        fill(255);
      }

      pushMatrix();
      translate(x + d + dx, y + d + dy);

      triangle(-d, -d, -d, d, d, -d);

      if (i == 1) {
        strokeWeight(2 + d);
      } else {
        strokeWeight(d);
      }

      line(0, 0, d, d);

      popMatrix();
    }

    strokeWeight(0);
  }

  void drawPickSelect (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    fill(255);

    float d = 0.3 * r;
    triangle(-d, -d, -d, d, d, -d);

    strokeWeight(5);
    line(0, 0, d, d);

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawWindowSelect (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    fill(63);
    rect(-0.5 * r, -0.5 * r, 1.25 * r, 1.25 * r);

    strokeWeight(1);
    stroke(255);
    fill(255);

    float d = 0.3 * r;
    triangle(-d, -d, -d, d, d, -d);

    strokeWeight(5);
    line(0, 0, d, d);

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawDrop (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    fill(0);

    float d = 0.8 * r;

    if (_type == 1) {
      ellipse(0, 0, 2 * d, d);
    }
    if ((_type == 2) || (_type == 3)) {
      beginShape();
      vertex(0, 0.5 * d);
      vertex(funcs.cos_ang(30) * d, 0);
      vertex(0, -0.5 * d);
      vertex(-funcs.cos_ang(30) * d, 0);
      endShape(CLOSE);
    }




    strokeWeight(2);
    stroke(255);
    fill(0);

    if (_type == 1) {
      line(0, 0, 0, -d);
      line(0, 0, 0 - 0.25 * d, 0.25 * -d);
      line(0, 0, 0 + 0.25 * d, 0.25 * -d);

      line(0, 0, 0, d);
      line(0, 0, 0 - 0.25 * d, 0.25 * d);
      line(0, 0, 0 + 0.25 * d, 0.25 * d);
    }

    if (_type == 2) {
      line(0, 0.25 * d, 0, -d);
      line(0, 0.25 * d, 0 - 0.25 * d, 0);
      line(0, 0.25 * d, 0 + 0.25 * d, 0);
    }

    if (_type == 3) {
      line(0, 0.25 * -d, 0, d);
      line(0, 0.25 * -d, 0 - 0.25 * d, 0);
      line(0, 0.25 * -d, 0 + 0.25 * d, 0);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawGetLength (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();


    float d = 0.8 * r;

    beginShape();
    vertex(0, 0);
    vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, -d);
    vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
    endShape(CLOSE);


    strokeWeight(2);
    stroke(0, 127, 255);
    fill(0);

    if (_type == 1) {
      line(0, 0, funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }
    if (_type == 2) {
      line(0, 0, funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }
    if (_type == 3) {
      line(0, 0, -funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }
    if (_type == 4) {
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }
    if (_type == 5) {
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
    }
    if (_type == 6) {
      line(0, 0, 0, -d);
    }


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawMove (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(0, 0, 0.8 * r, 0);
    line(0, 0, 0, -0.8 * r);
    line(0, 0, -0.4 * r, 0.4 * r);

    strokeWeight(3);
    stroke(255);
    noFill();

    if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
    if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
    if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
    if (_type == 4) line(-0.4 * r, -0.4 * r, 0.4 * r, 0.4 * r);

    noStroke();
    fill(255, 0, 0);
    float d = 5;
    if (_type == 1) {
      ellipse(-0.8 * r, 0, d, d);
      ellipse(0.8 * r, 0, d, d);
    }
    if (_type == 2) {
      ellipse(0.4 * r, -0.4 * r, d, d);
      ellipse(-0.4 * r, 0.4 * r, d, d);
    }
    if (_type == 3) {
      ellipse(0, 0.8 * r, d, d);
      ellipse(0, -0.8 * r, d, d);
    }
    if (_type == 4) {
      ellipse(-0.4 * r, -0.4 * r, d, d);
      ellipse(0.4 * r, 0.4 * r, d, d);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }

  void drawScale (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(0, 0, 0.8 * r, 0);
    line(0, 0, 0, -0.8 * r);
    line(0, 0, -0.4 * r, 0.4 * r);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

    strokeWeight(5);
    stroke(0, 255, 0);
    noFill();

    if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
    if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
    if (_type == 4) {
      line(-0.4 * r, 0, 0.4 * r, 0);
      line(0, 0.4 * r, 0, -0.4 * r);
      line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawPower (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(0, 0, 0.8 * r, 0);
    line(0, 0, 0, -0.8 * r);
    line(0, 0, -0.4 * r, 0.4 * r);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

    strokeWeight(3);
    stroke(0, 127, 255);
    noFill();

    if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
    if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
    if (_type == 4) {
      line(-0.4 * r, 0, 0.4 * r, 0);
      line(0, 0.4 * r, 0, -0.4 * r);
      line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawRotate (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(0, 0, 0.8 * r, 0);
    line(0, 0, 0, -0.8 * r);
    line(0, 0, -0.4 * r, 0.4 * r);

    strokeWeight(3);
    stroke(255);
    noFill();

    if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
    if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
    if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);

    strokeWeight(2);
    stroke(0, 127, 255);
    noFill();
    float d = 0.85 * r;
    if (_type == 1) {
      arc(0, 0, d, d, 0.25 * PI, 1.75 * PI);
    }
    if (_type == 2) {
      arc(0, 0, d, d, (0.25 + 0.75) * PI, (1.75 + 0.75) * PI);
    }
    if (_type == 3) {
      arc(0, 0, d, d, (0.25 - 0.5) * PI, (1.75 - 0.5) * PI);
    }


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }





  void drawSeed (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(0, 0, 0.8 * r, 0);
    line(0, 0, 0, -0.8 * r);
    line(0, 0, -0.4 * r, 0.4 * r);

    strokeWeight(1);
    stroke(255);
    noFill();

    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

    strokeWeight(1);
    stroke(255, 255, 0);
    noFill();

    for (int i = 0; i < 360; i += 30) {
      float d = random(0.25, 0.75);

      line(0, 0, 0.8 * r * d * cos(i), 0.8 * r * d * sin(i));
    }

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void drawtessellation (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 1.25 * r;

    strokeWeight(2);
    stroke(255);
    fill(63);
    rect(-0.5 * d, -0.5 * d, d, d);

    strokeWeight(1);
    stroke(191);
    fill(191);

    for (int i = 1; i < 4; i++) {
      float w = (0.25 * i - 0.5) * d;
      line(-0.5 * d, w, 0.5 * d, w);
      line(w, -0.5 * d, w, 0.5 * d);
    }

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawLayer (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 0.8 * r;

    strokeWeight(1);
    stroke(255);
    fill(0);

    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE);

    strokeWeight(2);
    stroke(255);
    fill(0, 127, 255);

    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawVisibility (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 0.8 * r;

    strokeWeight(1);
    stroke(255);
    fill(0);

    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE);

    strokeWeight(0);
    stroke(255);
    fill(127, 127);

    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);

    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawWeight (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);


    strokeWeight(1);
    stroke(255);
    fill(63);
    //rect(-0.5 * r, -0.5 * r, r, r);

    float d = r * pow(2, 0.5);

    strokeWeight(1);
    noFill();
    ellipse(0, 0, d, d);

    strokeWeight(1);
    noFill();
    arc(0, -r, d, d, 0.25 * PI, 0.75 * PI);
    arc(r, 0, d, d, 0.75 * PI, 1.25 * PI);
    arc(0, r, d, d, 1.25 * PI, 1.75 * PI);
    arc(-r, 0, d, d, 1.75 * PI, 2.25 * PI);


    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    }
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawNormal (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 0.8 * r;

    strokeWeight(2);
    stroke(255);
    fill(0);

    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);

    if (_type == 1) {
      line(0, 0, 0, -d);
      line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
      line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);

      line(0, 0.5 * d, 0, d);
      line(0 - 0.25 * d, d - 0.25 * d, 0, d);
      line(0 + 0.25 * d, d - 0.25 * d, 0, d);
    }

    if (_type == 2) {
      line(0, 0, 0, -d);
      line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
      line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
    }


    if (_type == 3) {
      line(0, 0, 0, d);
      line(0 - 0.25 * d, d - 0.25 * d, 0, d);
      line(0 + 0.25 * d, d - 0.25 * d, 0, d);
    }


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawFirstVertex (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 0.8 * r;

    strokeWeight(2);
    stroke(255);
    fill(0);

    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE);

    stroke(255, 0, 0);
    ellipse(0, 0, 0.25 * d, 0.25 * d);

    fill(255);
    textSize(d);
    textAlign(CENTER, BOTTOM);
    text("1st", 0, 0);

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void draw3DViewSpace (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(2);
    stroke(255);
    noFill();

    strokeWeight(1);
    stroke(255);
    if (_type == 1) fill(63);
    if (_type == 2) fill(191);
    rect(-0.75 * r, -0.75 * r, 1.5 * r, 1.5 * r);

    if (_type == 1) fill(191);
    if (_type == 2) fill(63);
    rect(-0.75 * r, -0.75 * r, 0.75 * r, 0.75 * r);

    strokeWeight(2);
    line(0, 0, 0.75 * r, 0.75 * r);

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }

  void drawProjectionType (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(2);
    stroke(255);
    fill(0);


    float d = 0.8 * r;

    if (_type == 1) {

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }

    if (_type == 2) {

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0.75 * funcs.sin_ang(0) * d, 0.75 * -funcs.cos_ang(0) * d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(0.75 * funcs.sin_ang(120) * d, 0.75 * -funcs.cos_ang(120) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(0.75 * funcs.sin_ang(240) * d, 0.75 * -funcs.cos_ang(240) * d);
      endShape(CLOSE);
    }



    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawTruck (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);


    stroke(255);
    fill(0);

    float d = 0.625 * r;

    float a = 0;
    float b = 0;
    if (_type == 1) {
      a = funcs.cos_ang(30) * d;
      b = -funcs.sin_ang(30) * d;
    }
    if (_type == 2) {
      a = -funcs.cos_ang(30) * d;
      b = -funcs.sin_ang(30) * d;
    }
    if (_type == 3) {
      a = 0;
      b = d;
    }

    strokeWeight(1);
    {
      pushMatrix();
      translate(0.5 * a, 0.5 * b);

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      popMatrix();
    }




    strokeWeight(2);
    {
      pushMatrix();
      translate(-0.5 * a, -0.5 * b);

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      popMatrix();
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }




  void drawZOOM (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    {
      pushMatrix();
      translate(0.25 * r, 0.25 * r);

      stroke(255);

      fill(0);
      strokeWeight(1);
      ellipse(-0.4 * r, -0.4 * r, 0.8 * r, 0.8 * r);

      noFill();
      strokeWeight(4);
      line(-0.1 * r, -0.1 * r, 0.3 * r, 0.3 * r);

      strokeWeight(2);
      stroke(255, 255, 0);
      if (_type == 1) {
        line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);
        line(-0.4 * r, -0.6 * r, -0.4 * r, -0.2 * r);
      }
      if (_type == 2) {
        line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);
      }

      popMatrix();
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void draw3DModelSize (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    stroke(255);
    fill(0);
    strokeWeight(2);
    ellipse(0, 0, r, r);
    noFill();
    strokeWeight(1);
    ellipse(0, 0, 1.5 * r, 1.5 * r);

    strokeWeight(1);
    line(-0.75 * r, 0, -0.5 * r, 0);
    line(0, -0.75 * r, 0, -0.5 * r);
    line(0.75 * r, 0, 0.5 * r, 0);
    line(0, 0.75 * r, 0, 0.5 * r);


    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r);

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }





  void drawAllModelSize (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 0.75 * r;

    stroke(255);
    fill(0);
    strokeWeight(1);
    ellipse(0, 0, d, d);
    noFill();
    strokeWeight(1);
    ellipse(0, 0, 2 * d, 2 * d);

    strokeWeight(1);
    line(-1 * d, 0, -0.5 * d, 0);
    line(0, -1 * d, 0, -0.5 * d);
    line(1 * d, 0, 0.5 * d, 0);
    line(0, 1 * d, 0, 0.5 * d);


    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r);

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawSkydomeSize (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    {
      pushMatrix();
      translate(0, 0.125 * r);

      float d = 1.0 * r;

      strokeWeight(1);
      stroke(255);
      fill(0);
      arc(0, 0, d, d, PI, 2 * PI);
      arc(0, 0, d, 0.333 * d, 0, PI);

      d = 1.5 * r;

      strokeWeight(2);
      stroke(255);
      noFill();
      arc(0, 0, d, d, PI, 2 * PI);
      arc(0, 0, d, 0.333 * d, 0, PI);

      popMatrix();
    }

    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r);

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawLandOrbit (int _type, float x, float y, float r) {

    {
      pushMatrix();
      translate(x, y);
      translate(-0.333 * r, -0.333 * r); // <<<<<<

      float d = 1.0 * r;

      strokeWeight(1);
      stroke(255);
      fill(0);
      ellipse(0, 0, d, d);

      strokeWeight(2);
      stroke(255);
      noFill();

      if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI);
      if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
        arc(0, 0, d, 0.333 * d, 0, PI);
      }

      strokeWeight(0);

      popMatrix();
    }

    {
      pushMatrix();
      translate(x, y);
      translate(0.333 * r, 0.333 * r); // <<<<<<

      float d = 0.75 * r;

      strokeWeight(1);
      stroke(255);
      noFill();
      arc(0, 0, d, d, 0, PI);

      stroke(255);
      noFill();

      for (float i = -1.5; i <= 1.5; i++) {
        line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);

        if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
      }

      strokeWeight(0);

      popMatrix();
    }

    this.displayText = false;
  }

  void drawOrbit (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    float d = 1.5 * r;

    strokeWeight(1);
    stroke(255);
    fill(0);
    ellipse(0, 0, d, d);

    strokeWeight(2);
    stroke(255);
    noFill();

    if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI);
    if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
      arc(0, 0, d, 0.333 * d, 0, PI);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawLookAtOrigin (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0);

    {
      float d = 0.8 * r;

      line(0, 0, funcs.cos_ang(90) * d, -funcs.sin_ang(90) * d);
      line(0, 0, funcs.cos_ang(210) * d, -funcs.sin_ang(210) * d);
      line(0, 0, funcs.cos_ang(330) * d, -funcs.sin_ang(330) * d);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawLookAtDirection (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0);

    {
      float d = 0.8 * r;

      line(-d,d/2,d,d/2);
      line(d/2,-d,d/2,d);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawLookAtSelection (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0);

    {
      float d = 0.8 * r;

      line(0, 0, funcs.cos_ang(90) * d, -funcs.sin_ang(90) * d);
      line(0, 0, funcs.cos_ang(210) * d, -funcs.sin_ang(210) * d);
      line(0, 0, funcs.cos_ang(330) * d, -funcs.sin_ang(330) * d);
    }

    {
      //float d = 0.625 * r;
      float d = 0.5 * r;

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawCameraRoll (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    {
      float d = 1.5 * r;

      strokeWeight(1);
      stroke(255);
      fill(0);
      ellipse(0, 0, d, d);
    }


    strokeWeight(1);
    stroke(255);
    fill(127, 63, 0);
    {
      //float d = 0.625 * r;
      float d = 0.5 * r;

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }



    {
      float d = 1.5 * r;

      strokeWeight(2);
      stroke(255);
      noFill();

      if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI);
      if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI);
        arc(0, 0, d, 0.333 * d, 0, PI);
      }
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void drawTargetRoll (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    {

      float d = 1.5 * r;

      strokeWeight(1);
      stroke(255);
      fill(0);
      rect(-d/2, -d/2, d, d);

      strokeWeight(2);
      stroke(255);
      noFill();

      if (_type == 3) arc(0, 0, d, 0.333 * d, PI, 2 * PI);
      if (_type == 2) arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI);
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI);
        arc(0, 0, d, 0.333 * d, PI, 2 * PI);
      }
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }


  void drawPan (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    {
      float d = 1.0 * r;

      strokeWeight(1);
      stroke(255);
      noFill();
      arc(0, 0, d, d, 0, PI);

      stroke(255);
      noFill();

      for (float i = -1.5; i <= 1.5; i++) {
        line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);

        if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
      }
    }

    strokeWeight(2);
    stroke(255);
    noFill();
    {
      float d = 0.75 * r;

      if (_type == 2) {
        line(-1 * d, 0, -0.5 * d, 0);
        line(1 * d, 0, 0.5 * d, 0);
      }
      if (_type == 3) {
        line(0, -1 * d, 0, -0.5 * d);
        line(0, 1 * d, 0, 0.5 * d);
      }
    }

    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void drawDistMouseXY (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    line(-r, -0.5 * r, r, -0.5 * r);
    strokeWeight(2);
    line(-0.5 * r, -0.5 * r, r, 0);
    line(-0.5 * r, -0.5 * r, -r, 0);
    strokeWeight(2);
    line(-0.5 * r, -0.5 * r, 0, r);


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void drawCameraDistance (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    line(-r, 0, r, 0);
    strokeWeight(2);
    line(0, 0, r, 0.5 * r);
    line(0, 0, -r, 0.5 * r);
    strokeWeight(2);
    line(0, 0, 0, r);

    strokeWeight(1);
    stroke(255);
    fill(127, 63, 0);
    {
      //float d = 0.625 * r;
      float d = 0.5 * r;

      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);

      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);

      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }



  void drawDistZ (int _type, float x, float y, float r) {

    pushMatrix();
    translate(x, y);

    strokeWeight(1);
    stroke(255);
    line(-r, 0, r, 0);
    strokeWeight(2);
    line(0, 0, r, 0.5 * r);
    line(0, 0, -r, 0.5 * r);
    strokeWeight(2);
    line(0, 0, 0, r);


    strokeWeight(0);

    popMatrix();

    this.displayText = false;
  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_UI_toolBar UI_toolBar = new solarchvision_UI_toolBar();






class solarchvision_UI_commandBar {

  private final static String CLASS_STAMP = "UI_commandBar";

  boolean update = true;

  void draw () {
    if (this.update) {

      this.updated();

      int maxDisplayLines = 2;

      if (typeUserCommand == 1) {
        fill(0);
      }
      else {
        fill(63);
      }
      noStroke();
      rect(0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C, width, SOLARCHVISION_pixel_D);

      noStroke();

      textSize(1.25 * MessageSize);


      pushMatrix();
      translate(0, 0.625 * MessageSize + SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C);

      for (int q = 0; q < maxDisplayLines; q++) {

        int n = allCommands.length + q - maxDisplayLines;

        if ((0 <= n) && (n < allCommands.length)) {

          textAlign(RIGHT, CENTER);
          fill(255,127,0);
          text(allMessages[n], width - 0.5 * MessageSize, q * 1.5 * MessageSize);

          textAlign(LEFT, CENTER);
          fill(255);
          text(allCommands[n], 0.5 * MessageSize, q * 1.5 * MessageSize);

        }
      }

      popMatrix();

      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_UI_commandBar UI_commandBar = new solarchvision_UI_commandBar();





class solarchvision_UI_timeBar {

  private final static String CLASS_STAMP = "UI_timeBar";

  boolean update = true;

  float tab;

  String[][] Items = {

    {
      "Hours"
    }
    ,
    {
      "Days"
    }
    ,
    {
      "Scenario"
    }
  };



  void draw () {

    if (this.update) {

      this.updated();

      this.tab = SOLARCHVISION_pixel_C / float(this.Items.length);

      fill(191);
      noStroke();
      rect(0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H, width, SOLARCHVISION_pixel_C);



      float displayBarHeight = MessageSize;
      float displayBarWidth = 2 * SOLARCHVISION_pixel_W;

      STUDY.X_control = 0.5 * displayBarWidth;
      STUDY.Y_control = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + 0.5 * this.tab;

      for (int i = 0; i < this.Items.length; i++) {

        float x1 = STUDY.X_control - 0.3666 * displayBarWidth;
        float x2 = STUDY.X_control + 0.4875 * displayBarWidth;
        float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
        float y2 = STUDY.Y_control + 0.45 * displayBarHeight;

        fill(127);
        noStroke();
        rect(x1, y1, x2 - x1, y2 - y1);

        textAlign(RIGHT, CENTER);
        stroke(0);
        fill(0);
        textSize(1.25 * MessageSize);

        text(this.Items[i][0] + ": ", x1, STUDY.Y_control - 0.2 * MessageSize);

        if (this.Items[i][0].equals("Hours")) {

          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

            if (mouseButton == LEFT) {
              STUDY.i_Start = int(funcs.roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

              ROLLOUT.revise();
              STUDY.revise();
              WORLD.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }

            if (mouseButton == RIGHT) {
              STUDY.i_End = int(funcs.roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

              ROLLOUT.revise();
              STUDY.revise();
              WORLD.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }

          float x_start = x1 + (x2 - x1) * (STUDY.i_Start) / 24.0;
          float x_end = x1 + (x2 - x1) * (STUDY.i_End + 1) / 24.0;

          fill(0, 191, 0, 191);
          noStroke();

          if (STUDY.i_Start <= STUDY.i_End) {
            rect(x_start, y1, x_end - x_start, y2 - y1);
          } else {
            rect(x1, y1, x_end - x1, y2 - y1);
            rect(x_start, y1, x2 - x_start, y2 - y1);
          }

          textAlign(CENTER, CENTER);
          stroke(0);
          fill(0);
          textSize(1.25 * MessageSize);

          for (int j = 0; j < 24; j++) {
            text(nf(j, 0), x1 + (x2 - x1) * (j + 0.5) / 24.0, STUDY.Y_control - 0.2 * MessageSize);
          }
        }

        if (this.Items[i][0].equals("Days")) {

          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

            if (mouseButton == LEFT) {
              float keep_TIME_Date = TIME.date;
              TIME.date = (int(funcs.roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
              TIME.updateDate();
              TIME.beginDay = int(TIME.beginDay + (TIME.date - keep_TIME_Date) + 365) % 365;
              update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

              STUDY.revise();
              ROLLOUT.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }

            if (mouseButton == RIGHT) {

              float _DATE2 = (int(funcs.roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;

              if (TIME.date > _DATE2) _DATE2 += 365;

              STUDY.perDays = int(funcs.roundTo((_DATE2 - TIME.date) / float(STUDY.j_End - STUDY.j_Start), 1));

              if (STUDY.perDays < 0) STUDY.perDays = 1;

              STUDY.revise();
              ROLLOUT.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }

          float keep_STUDY_perDays = STUDY.perDays;
          int keep_STUDY_joinDays = STUDY.joinDays;
          if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) ||
              (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {

            STUDY.perDays = 1;
            STUDY.joinDays = 1;
          }

          for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

            for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {

              int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }

              float x_start = x1 + (x2 - x1) * ((now_j) % 365) / 365.0;
              float x_end = x1 + (x2 - x1) * ((now_j + 1) % 365) / 365.0;

              fill(191, 0, 0, 127);
              noStroke();

              if (x_start <= x_end) {
                rect(x_start, y1, x_end - x_start, y2 - y1);
              } else {
                rect(x1, y1, x_end - x1, y2 - y1);
                rect(x_start, y1, x2 - x_start, y2 - y1);
              }
            }
          }

          {
            textAlign(CENTER, CENTER);
            stroke(0);
            fill(0);
            textSize(1.25 * MessageSize);

            for (int j = 0; j < 12; j++) {
              text(TIME.namesOfMonths[j][Language_Active], x1 + (x2 - x1) * (j + 0.5) / 12.0, STUDY.Y_control - 0.2 * MessageSize);
            }
          }

          STUDY.perDays = keep_STUDY_perDays;
          STUDY.joinDays = keep_STUDY_joinDays;
        }


        if (this.Items[i][0].equals("Scenario")) {

          int n1 = 0;
          int n2 = 1;

          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
            n1 = 1950;
            n2 = 2050;
          }
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
            n1 = 1950;
            n2 = 2050;
          }
          if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
            n1 = 1950;
            n2 = 2050;
          }
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
            n1 = ENSEMBLE_FORECAST_start;
            n2 = ENSEMBLE_FORECAST_end;
          }
          if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
            n1 = ENSEMBLE_OBSERVED_start;
            n2 = ENSEMBLE_OBSERVED_end;
          }

          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

            if (mouseButton == LEFT) {

              int V_selection = n1 + int(funcs.roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

              if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                SampleYear_Start = V_selection;

                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                SampleYear_Start = V_selection;

                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                SampleMember_Start = V_selection;

                if (SampleMember_Start > SampleMember_End) {
                  int swap_tmp = SampleMember_Start;
                  SampleMember_Start = SampleMember_End;
                  SampleMember_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                SampleStation_Start = V_selection;

                if (SampleStation_Start > SampleStation_End) {
                  int swap_tmp = SampleStation_Start;
                  SampleStation_Start = SampleStation_End;
                  SampleStation_End = swap_tmp;
                }

              }

              ROLLOUT.revise();
              STUDY.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }

            if (mouseButton == RIGHT) {

              int V_selection = n1 + int(funcs.roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

              if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                SampleYear_End = V_selection;

                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                SampleYear_End = V_selection;

                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                SampleMember_End = V_selection;

                if (SampleMember_Start > SampleMember_End) {
                  int swap_tmp = SampleMember_Start;
                  SampleMember_Start = SampleMember_End;
                  SampleMember_End = swap_tmp;
                }

              }

              if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                SampleStation_End = V_selection;

                if (SampleStation_Start > SampleStation_End) {
                  int swap_tmp = SampleStation_Start;
                  SampleStation_Start = SampleStation_End;
                  SampleStation_End = swap_tmp;
                }

              }

              ROLLOUT.revise();
              STUDY.revise();
              SOLARCHVISION_view_changed();

              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }

          float V_start = 0;
          float V_end = 0;

          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
            V_start = SampleYear_Start;
            V_end = SampleYear_End;
          }
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
            V_start = SampleYear_Start;
            V_end = SampleYear_End;
          }
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
            V_start = SampleMember_Start;
            V_end = SampleMember_End;
          }
          if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
            V_start = SampleStation_Start;
            V_end = SampleStation_End;
          }

          float x_start = x1 + (x2 - x1) * (V_start - n1) / float(n2 - n1 + 1);
          float x_end = x1 + (x2 - x1) * (V_end - n1 + 1) / float(n2 - n1 + 1);

          fill(0, 0, 191, 191);
          noStroke();

          if (x_start <= x_end) {
            rect(x_start, y1, x_end - x_start, y2 - y1);
          }

          textAlign(CENTER, CENTER);
          stroke(0);
          fill(0);
          textSize(1.25 * MessageSize);

          for (int j = 0; j < n2 - n1 + 1; j++) {

            String txt = ".";

            if (j % 5 == 0) {
              txt = "|";
            }

            if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
              if ((j % 10 == 5)) {
                txt = nf(j - 5 + n1, 0) + "s";
              }
            }
            if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
              if ((j % 10 == 5)) {
                txt = nf(j - 5 + n1, 0) + "s";
              }
            }
            if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
              //if ((j % 1 == 0)) {
              txt = nf(j + n1, 0);
              //}
            }
            if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
              //if ((j % 1 == 0)) {
              txt = SWOB_Coordinates[nearest_Station_ENSEMBLE_OBSERVED_id[j]].getCode();
              //}
            }

            text(txt, x1 + (x2 - x1) * (j + 0.5) / float(n2 - n1 + 1), STUDY.Y_control - 0.2 * MessageSize);
          }
        }




        STUDY.Y_control += this.tab;
      }


      displayBarWidth = ROLLOUT.dX; // <<<<<<<<<
      displayBarHeight = 4.5 * MessageSize;

      float temp_offsetX = ROLLOUT.cX + 0.5 * displayBarWidth;
      float temp_offsetY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + 0.5 * displayBarHeight;

      for (int n = 0; n < 9; n++) {

        int i = 2 - n / 3;
        int j = 2 - n % 3;

        float rx = (i + 0.5) / 3.0 - 0.5;
        float ry = (j + 0.5) / 3.0 - 0.5;

        float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
        float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
        float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
        float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2)) {

          STUDY.ImpactLayer = n;

          STUDY.revise();
          ROLLOUT.revise();
          SOLARCHVISION_view_changed();

          SOLARCHVISION_find_which_bakings_to_regenerate();
        }
      }

      for (int n = 0; n < 9; n++) {

        int i = 2 - n / 3;
        int j = 2 - n % 3;

        float rx = (i + 0.5) / 3.0 - 0.5;
        float ry = (j + 0.5) / 3.0 - 0.5;

        float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
        float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
        float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
        float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

        if (n == STUDY.ImpactLayer) {
          fill(255, 127, 0);
          noStroke();
        } else if (n / 3 == STUDY.ImpactLayer / 3) {
          fill(127, 63, 0);
          noStroke();
        } else {
          fill(127);
          noStroke();
        }
        rect(x1, y1, x2 - x1, y2 - y1);

        textAlign(CENTER, CENTER);
        if (n == STUDY.ImpactLayer) {
          stroke(0);
          fill(0);
        } else if (n / 3 == STUDY.ImpactLayer / 3) {
          stroke(191);
          fill(191);
        } else {
          stroke(255);
          fill(255);
        }

        if (n == STUDY.ImpactLayer) {
          textSize(1.25 * MessageSize);
        } else {
          textSize(1.125 * MessageSize);
        }

        text(STAT_N_Title[n], 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.2 * MessageSize);
      }

      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }

  void revise () {
    this.update = true;
  }
  void updated () {
    this.update = false;
  }
}

solarchvision_UI_timeBar UI_timeBar = new solarchvision_UI_timeBar();






String[] allCommands = {"SOLARCHVISION Command Input:", ""};
String[] allMessages = {"SOLARCHVISION Command Output:", ""};


int typeUserCommand = 0;

void COMIN_keyPressed (KeyEvent e) {

  if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {

    if (key == CODED) {
      switch(keyCode) {
      }
    }
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key != CODED) {
      switch(key) {

       case ENTER:
         String[] newCommand = {""};
         String[] newMessage = {""};

         allMessages[allMessages.length - 1] = SOLARCHVISION_executeCommand(allCommands[allCommands.length - 1]);

         allCommands = concat(allCommands, newCommand);
         allMessages = concat(allMessages, newMessage);
         break;

       case BACKSPACE:
          if (allCommands[allCommands.length - 1].length() > 0) {
            allCommands[allCommands.length - 1] = allCommands[allCommands.length - 1].substring(0, allCommands[allCommands.length - 1].length() - 1);
          }
          break;

        default:
          if ((31 < key) && (key < 127)) {
            allCommands[allCommands.length - 1] += key;
          }
          break;
      }


    }
  }
}

void SOLARCHVISION_execute_commands_TXT (String FileName) {

  String[] FileALL = loadStrings(FileName);

  for (int f = 0; f < FileALL.length; f++) {

    String lineSTR = FileALL[f];

    SOLARCHVISION_executeCommand(lineSTR);
  }

}

String SOLARCHVISION_executeCommand (String lineSTR) {

  String return_message = "";

  lineSTR = lineSTR.replace("\"", "");

  String[] parts = split(lineSTR, ' ');

  String Command_CAPITAL = parts[0].toUpperCase();

  if (Command_CAPITAL.equals("CLS")) {
    allCommands = new String[1];
    allMessages = new String[1];

    allCommands[0] = "";
    allMessages[0] = "";
  }

  else if (Command_CAPITAL.equals("OPEN")) {
    selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
  }

  else if (Command_CAPITAL.equals("SAVE.AS")) {
    selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
  }

  else if (Command_CAPITAL.equals("SAVE")) {
    SOLARCHVISION_save_project(Folder_Project + "/" + ProjectName + ".xml");
  }

  else if (Command_CAPITAL.equals("HOLD")) {
    SOLARCHVISION_hold_project();
  }

  else if (Command_CAPITAL.equals("FETCH")) {
    SOLARCHVISION_fetch_project();
  }

  else if (Command_CAPITAL.equals("IMPORT")) {
    selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
  }

  else if (Command_CAPITAL.equals("EXECUTE")) {
    selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
  }

  else if (Command_CAPITAL.equals("EXPORT.OBJ.TIMESERIES")) {
    SOLARCHVISION_export_objects_OBJ_timeSeries();
  }

  else if (Command_CAPITAL.equals("EXPORT.OBJ.DATESERIES")) {
    SOLARCHVISION_export_objects_OBJ_dateSeries();
  }

  else if (Command_CAPITAL.equals("EXPORT.OBJ")) {
    SOLARCHVISION_export_objects_OBJ("");
  }

  else if (Command_CAPITAL.equals("EXPORT.RAD")) {
    SOLARCHVISION_export_objects_RAD();
  }

  else if (Command_CAPITAL.equals("EXPORT.SCR")) {
    SOLARCHVISION_export_objects_SCR();
  }

  else if (Command_CAPITAL.equals("QUIT")) {
    exit();
  }





  else if (Command_CAPITAL.equals("MOVE")) {
    if (parts.length > 1) {
      float dx = 0;
      float dy = 0;
      float dz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
        }
        else {
               if (q == 1) dx = float(parameters[0]);
          else if (q == 2) dy = float(parameters[0]);
          else if (q == 3) dz = float(parameters[0]);
        }
      }
      Move3D.selection(dx, dy, dz);
    }
    else {
      return_message = "Move dx=? dy=? dz=?";

      UI_toolBar.highlight("MV³");
      UI_toolBar.revise();
    }
  }

  else if ((Command_CAPITAL.equals("ROTATE")) ||
          (Command_CAPITAL.equals("ROTATEX")) ||
          (Command_CAPITAL.equals("ROTATEY")) ||
          (Command_CAPITAL.equals("ROTATEZ"))) {
    if (parts.length > 1) {
      int v = 2;
      if (Command_CAPITAL.equals("ROTATEX")) v = 0;
      if (Command_CAPITAL.equals("ROTATEY")) v = 1;
      if (Command_CAPITAL.equals("ROTATEZ")) v = 2;

      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) r = float(parameters[0]);
        }
      }
      Rotate3D.selection(x, y, z, r, v);
    }
    else {
      return_message = "Rotate[X|Y|Z] r=? x=? y=? z=?";

      UI_set_to_Modify_Rotate(2);
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("SCALE")) {
    if (parts.length > 1) {
      float sx = 1;
      float sy = 1;
      float sz = 1;

      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("s")) {sx = float(parameters[1]); sy = sx; sz = sx;}
          else if (low_case.equals("sxy")) {sx = float(parameters[1]); sy = sx;}
          else if (low_case.equals("syz")) {sy = float(parameters[1]); sz = sy;}
          else if (low_case.equals("szx")) {sz = float(parameters[1]); sx = sz;}
          else if (low_case.equals("sx")) sx = float(parameters[1]);
          else if (low_case.equals("sy")) sy = float(parameters[1]);
          else if (low_case.equals("sz")) sz = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) {sx = float(parameters[0]); sy = sx; sz = sx;}
        }
      }
      Scale3D.selection(x, y, z, sx, sy, sz);
    }
    else {
      return_message = "Scale s=? sx=? sy=? sz=? x=? y=? z=?";

      UI_toolBar.highlight("SC³");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("DELETE")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("all")) SOLARCHVISION_deleteAll();
        else if (low_case.equals("groups")) allGroups.makeEmpty(0);
        else if (low_case.equals("model2ds")) allModel2Ds.makeEmpty(0);
        else if (low_case.equals("model1ds")) allModel1Ds.makeEmpty(0);
        else if (low_case.equals("faces")) allFaces.makeEmpty(0);
        else if (low_case.equals("lines")) allCurves.makeEmpty(0);
        else if (low_case.equals("solids")) allSolids.makeEmpty(0);
        else if (low_case.equals("sections")) allSections.makeEmpty(0);
        else if (low_case.equals("cameras")) allCameras.makeEmpty(0);
        else if (low_case.equals("vertices")) Delete3D.isolatedVertices_Selection();
        else if (low_case.equals("selection")) Delete3D.selection();
      }
    }
    else {
      return_message = "Delete all/selection/groups/model2ds/model1ds/vertices/faces/solids/sections/cameras";
    }
  }

  else if (Command_CAPITAL.equals("COPY")) {
    if (parts.length > 1) {
      int n = 1;
      float dx = 0;
      float dy = 0;
      float dz = 0;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("n")) n = int(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);
        }
      }

      for (int q = 0; q < n; q++) {
        Clone3D.selection(true);
        if ((dx != 0) || (dy != 0) || (dz != 0)) Move3D.selection(dx, dy, dz);
        if (rx != 0) Rotate3D.selection(0, 0, 0, rx, 0);
        if (ry != 0) Rotate3D.selection(0, 0, 0, ry, 1);
        if (rz != 0) Rotate3D.selection(0, 0, 0, rz, 2);
      }
    }
    else {
      return_message = "Copy n=? dx=? dy=? dz=? rx=? ry=? rz=?";
    }
  }

  else if (Command_CAPITAL.equals("SELECT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("groups")) SOLARCHVISION_switch_category(ObjectCategory.GROUP);
        else if (low_case.equals("model2ds")) SOLARCHVISION_switch_category(ObjectCategory.MODEL2D);
        else if (low_case.equals("model1ds")) SOLARCHVISION_switch_category(ObjectCategory.MODEL1D);
        else if (low_case.equals("vertices")) SOLARCHVISION_switch_category(ObjectCategory.VERTEX);
        else if (low_case.equals("faces")) SOLARCHVISION_switch_category(ObjectCategory.FACE);
        else if (low_case.equals("lines")) SOLARCHVISION_switch_category(ObjectCategory.CURVE);
        else if (low_case.equals("solids")) SOLARCHVISION_switch_category(ObjectCategory.SOLID);
        else if (low_case.equals("sections")) SOLARCHVISION_switch_category(ObjectCategory.SECTION);
        else if (low_case.equals("cameras")) SOLARCHVISION_switch_category(ObjectCategory.CAMERA);
        else if (low_case.equals("landpoints")) SOLARCHVISION_switch_category(ObjectCategory.LANDPOINT);
      }

      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("all")) Select3D.selectAll();
        else if (low_case.equals("invert")) Select3D.invertSelection();
        else if (low_case.equals("nothing")) Select3D.deselectAll();
        else if (low_case.equals("last")) Select3D.selectLast();
      }
    }
    else {
      return_message = "Select all/last/nothing/invert/groups/model2ds/model1ds/vertices/faces/solids/sections/cameras/landpoint";
    }
  }






  else if (Command_CAPITAL.equals("2DMAN")) {
    if (parts.length > 1) {
      String t = "PEOPLE";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
      }
      allModel2Ds.create(t, m, x, y, z, 2.5);
    }
    else {
      return_message = "2Dman m=? x=? y=? z=?";

      UI_set_to_Create_Person();
      UI_toolBar.highlight("Person");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("2DTREE")) {
    if (parts.length > 1) {
      String t = "TREES";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel2Ds.create(t, m, x, y, z, h);
      }
    }
    else {
      return_message = "2Dtree m=? x=? y=? z=? h=?";

      UI_set_to_Create_Tree();
      UI_toolBar.highlight("2D-Tree");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("3DTREE")) {
    if (parts.length > 1) {
      int m = 0;
      int seed = 0; //PlantSeed
      int degree = 5; //PlantDegree
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      float r = floor(random(360));
      float tilt = floor(random(90));
      float twist = floor(random(360));
      float ratio = 0.5 + random(0.5);
      float base = 0.0 + random(2.0);
      float Tk = 1.0; //TrunkSize
      float Lf = 0.1; //LeafSize

      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("seed")) seed = int(parameters[1]);
          else if (low_case.equals("degree")) degree = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]) * PI / 180.0;
          else if (low_case.equals("tilt")) tilt = float(parameters[1]) * PI / 180.0;
          else if (low_case.equals("twist")) twist = float(parameters[1]) * PI / 180.0;
          else if (low_case.equals("ratio")) ratio = float(parameters[1]);
          else if (low_case.equals("base")) base = float(parameters[1]);
          else if (low_case.equals("tk")) Tk = float(parameters[1]);
          else if (low_case.equals("lf")) Lf = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel1Ds.create(m, seed, degree, x, y, z, h, r, tilt, twist, ratio, base, Tk, Lf);
      }
    }
    else {
      return_message = "3Dtree m=? degree=? seed=? x=? y=? z=? h=? r=? tilt=? twist=? ratio=? base=? Tk=? Lf=?";

      UI_set_to_Create_allModel1Ds();
      UI_toolBar.highlight("3D-Tree");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("BOX2P")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x2 - x1 != 0) && (y2 - y1 != 0) && (z2 - z1 != 0)) {
        Create3D.add_Box_Corners(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
      }
    }
    else {
      return_message = "Box2P m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";

      UI_set_to_Create_Box();
      UI_toolBar.highlight("Box");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("BOX")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_Box_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
      }
    }
    else {
      return_message = "Box m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";

      UI_set_to_Create_Box();
      UI_toolBar.highlight("Box");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("HOUSE3")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_House3_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
      }
    }
    else {
      return_message = "House3 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House3();
      UI_toolBar.highlight("House3");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("HOUSE2")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_House2_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
      }
    }
    else {
      return_message = "House2 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House2();
      UI_toolBar.highlight("House2");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("HOUSE1")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_House1_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
      }
    }
    else {
      return_message = "House1 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House2();
      UI_toolBar.highlight("House1");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("CYLINDER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 16;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {
        Create3D.add_SuperCylinder(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, 0.5 * d, 0.5 * h, deg, r);
      }
    }
    else {
      return_message = "Cylinder m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";

      UI_set_to_Create_Cylinder();
      UI_toolBar.highlight("Cylinder");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("SPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {
        Create3D.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, 0, 90 + r); // passing with isSky:0
      }
    }
    else {
      return_message = "Sphere m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";

      UI_set_to_Create_Sphere();
      UI_toolBar.highlight("Sphere");
      UI_toolBar.revise();
    }
  }


  else if (Command_CAPITAL.equals("SUPERSPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float px = 2;
      float py = 2;
      float pz = 2;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0) && (px > 0) && (py > 0) && (pz > 0)) {
        Create3D.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, px, py, pz, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
      }
    }
    else {
      return_message = "SuperSphere m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? px=? py=? pz=? deg=? r=?";

      UI_set_to_Create_Sphere();
      UI_toolBar.highlight("Sphere");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("CUSHION")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, CubePower, CubePower, 2, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
      }
    }
    else {
      return_message = "Cushion m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";

      UI_set_to_Create_Cushion();
      UI_toolBar.highlight("Cushion");
      UI_toolBar.revise();
    }
  }


  else if (Command_CAPITAL.equals("OCTAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {
        Create3D.add_Octahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
      }
    }
    else {
      return_message = "Octahedron m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";

      UI_set_to_Create_Octahedron();
      UI_toolBar.highlight("Octahedron");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("ICOSAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if (d != 0) {
        Create3D.add_Icosahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, r);
      }
    }
    else {
      return_message = "Icosahedron m=? tes=? lyr=? x=? y=? z=? d=? r=?";

      UI_set_to_Create_Icosahedron();
      UI_toolBar.highlight("Icosahedron");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("POLYGONEXTRUDE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {
        Create3D.add_PolygonExtrude(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
      }
    }
    else {
      return_message = "PolygonExtrude m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";

      UI_set_to_Create_Extrude();
      UI_toolBar.highlight("Extrude");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("POLYGONHYPER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {
        Create3D.add_PolygonHyper(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
      }
    }
    else {
      return_message = "PolygonHyper m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";

      UI_set_to_Create_Hyper();
      UI_toolBar.highlight("Hyper");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("POLYGONMESH")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {
        Create3D.add_PolygonMesh(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, r);
      }
    }
    else {
      return_message = "PolygonMesh m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";

      UI_set_to_Create_Plane();
      UI_toolBar.highlight("Poly");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("MESH2")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x1 == x2) || (y1 == y2) || (z1 == z2)) {
        Create3D.add_Mesh2(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
      }
    }
    else {
      return_message = "Mesh2 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";
    }
  }

  else if (Command_CAPITAL.equals("MESH3")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
        }
      }
      {
        Create3D.add_Mesh3(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
      }
    }
    else {
      return_message = "Mesh3 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=?";
    }
  }

  else if (Command_CAPITAL.equals("MESH4")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);
        }
      }
      {
        Create3D.add_Mesh4(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
      }
    }
    else {
      return_message = "Mesh4 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=?";
    }
  }

  else if (Command_CAPITAL.equals("MESH5")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);
          else if (low_case.equals("x5")) x5 = float(parameters[1]);
          else if (low_case.equals("y5")) y5 = float(parameters[1]);
          else if (low_case.equals("z5")) z5 = float(parameters[1]);
        }
      }
      {
        Create3D.add_Mesh5(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
      }
    }
    else {
      return_message = "Mesh5 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=?";
    }
  }

  else if (Command_CAPITAL.equals("MESH6")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;
      float x6 = 0;
      float y6 = 0;
      float z6 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);
          else if (low_case.equals("x5")) x5 = float(parameters[1]);
          else if (low_case.equals("y5")) y5 = float(parameters[1]);
          else if (low_case.equals("z5")) z5 = float(parameters[1]);
          else if (low_case.equals("x6")) x6 = float(parameters[1]);
          else if (low_case.equals("y6")) y6 = float(parameters[1]);
          else if (low_case.equals("z6")) z6 = float(parameters[1]);
        }
      }
      {
        Create3D.add_Mesh6(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
      }
    }
    else {
      return_message = "Mesh6 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=? x6=? y6=? z6=?";
    }
  }

  else if (Command_CAPITAL.equals("H_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float w = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("w")) w = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
          else if (low_case.equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (w != 0)) {
        Create3D.add_H_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, d, w, a, b);
      }
    }
    else {
      return_message = "H_Shade m=? tes=? lyr=? x=? y=? z=? d=? w=? a=? b=?";
    }
  }

  else if (Command_CAPITAL.equals("V_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float h = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
          else if (low_case.equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {
        Create3D.add_V_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, h, d, a, b);
      }
    }
    else {
      return_message = "V_Shade m=? tes=? lyr=? x=? y=? z=? d=? h=? a=? b=?";
    }
  }

  else if (Command_CAPITAL.equals("SOLID")) {
    if (parts.length > 1) {
      float v = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float px = 2;
      float py = 2;
      float pz = 2;
      float sx = 1;
      float sy = 1;
      float sz = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("v")) v = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("sx")) sx = float(parameters[1]);
          else if (low_case.equals("sy")) sy = float(parameters[1]);
          else if (low_case.equals("sz")) sz = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);
        }
      }
      if ((px != 0) && (py != 0) && (pz != 0) && (sx != 0) && (sy != 0) && (sz != 0) && (v != 0)) {
        allSolids.create(x, y, z, px, py, pz, sx, sy, sz, rx, ry, rz, v);
      }
    }
    else {
      return_message = "Solid x=? y=? z=? px=? py=? pz=? sx=? sy=? sz=? rx=? ry=? rz=? v=?";

      UI_set_to_Create_Solid();
      UI_toolBar.highlight("SLD");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("SECTION")) {
    if (parts.length > 1) {

      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      float u = 20;
      float v = 20;

      int t = 1;
      int i = 200;
      int j = 200;

      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("u")) u = float(parameters[1]);
          else if (low_case.equals("v")) v = float(parameters[1]);
          else if (low_case.equals("t")) t = int(parameters[1]);
          else if (low_case.equals("i")) i = int(parameters[1]);
          else if (low_case.equals("j")) j = int(parameters[1]);

        }
      }
      if ((t > 0) && (i > 0) && (j > 0) && (u > 0) && (v > 0)) {
        allSections.create(x, y, z, r, u, v, t, i, j);
      }
    }
    else {
      return_message = "Section x=? y=? z=? r=? u=? v=? t=? i=? j=?";

      UI_set_to_Create_Section();
      UI_toolBar.highlight("SEC");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("CAMERA")) {
    if (parts.length > 1) {

      float px = 0;
      float py = 0;
      float pz = 0;
      float pt = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      float rt = 5;
      float a = 60;
      int t = 1;

      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("pt")) pt = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);
          else if (low_case.equals("rt")) rt = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
          else if (low_case.equals("t")) t = int(parameters[1]);
        }
      }
      if (a != 0) {
        allCameras.create(px, py, pz, pt, rx, ry, rz, rt, a, t);
      }
    }
    else {
      return_message = "Camera px=? py=? pz=? pt=? rx=? ry=? rz=? rt=? a=? t=?";

      UI_set_to_Create_Camera();
      UI_toolBar.highlight("CAM");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("SPLINE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float[][] points = new float [0][3];
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);
          else if (low_case.equals("wgt")) wgt = int(parameters[1]);
          else if (low_case.equals("clz")) clz = int(parameters[1]);
        }
        else {
          String[] xyz = split(parts[q], ",");
          if (xyz.length > 2) {
            float[][] newPoint = {{float(xyz[0]), float(xyz[1]), float(xyz[2])}};
            points = (float[][]) concat(points, newPoint);
          }
        }
      }
      if (points.length > 1) {
        allCurves.add_Spline(m, tes, lyr, vsb, wgt, clz, points);
      }
    }
    else {
      return_message = "Spline m=? tes=? lyr=? xtr=? wgt=? clz=? x1,y1,z1 x2,y2,z2 etc.";

      UI_set_to_Create_Curve();
      UI_toolBar.highlight("Curve");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("ARC")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      float rot = 0;
      float ang = 360; // complete circle
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);
          else if (low_case.equals("wgt")) wgt = int(parameters[1]);
          else if (low_case.equals("clz")) clz = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("rot")) rot = float(parameters[1]);
          else if (low_case.equals("ang")) ang = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((r != 0) && (deg > 2)) {
        allCurves.add_Arc(m, tes, lyr, vsb, wgt, clz, x, y, z, r, deg, rot, ang);
      }
    }
    else {
      return_message = "Arc m=? tes=? lyr=? xtr=? wgt=? clz=? x=? y=? z=? r=? deg=? rot=? ang=?";

      UI_set_to_Create_Curve();
      UI_toolBar.highlight("Curve");
      UI_toolBar.revise();
    }
  }

  else if (Command_CAPITAL.equals("PIVOT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("minx")) UI_set_to_View_PivotX(-1);
        else if (low_case.equals("midx")) UI_set_to_View_PivotX(0);
        else if (low_case.equals("maxx")) UI_set_to_View_PivotX(1);
        else if (low_case.equals("miny")) UI_set_to_View_PivotY(-1);
        else if (low_case.equals("midy")) UI_set_to_View_PivotY(0);
        else if (low_case.equals("maxy")) UI_set_to_View_PivotY(1);
        else if (low_case.equals("minz")) UI_set_to_View_PivotZ(-1);
        else if (low_case.equals("midz")) UI_set_to_View_PivotZ(0);
        else if (low_case.equals("maxz")) UI_set_to_View_PivotZ(1);
      }
    }
    else {
      return_message = "PIVOT minX midY maxZ or other variations";
    }
  }

  else if (Command_CAPITAL.equals("VERTEX>GROUP")) {
    Select3D.convert_Vertices_to_Groups();
  }
  else if (Command_CAPITAL.equals("FACE>GROUP")) {
    Select3D.convert_Faces_to_Groups();
  }
  else if (Command_CAPITAL.equals("GROUP>FACE")) {
    Select3D.convert_Groups_to_Faces();
  }
  else if (Command_CAPITAL.equals("CURVE>GROUP")) {
    Select3D.convert_Curves_to_Groups();
  }
  else if (Command_CAPITAL.equals("GROUP>CURVE")) {
    Select3D.convert_Groups_to_Curves();
  }
  else if (Command_CAPITAL.equals("CURVE>VERTEX")) {
    Select3D.convert_Curves_to_Vertices();
  }
  else if (Command_CAPITAL.equals("VERTEX>CURVE")) {
    Select3D.convert_Vertices_to_Curves();
  }
  else if (Command_CAPITAL.equals("GROUP>VERTEX")) {
    Select3D.convert_Groups_to_Vertices();
  }
  else if (Command_CAPITAL.equals("FACE>VERTEX")) {
    Select3D.convert_Faces_to_Vertices();
  }
  else if (Command_CAPITAL.equals("VERTEX>FACE")) {
    Select3D.convert_Vertices_to_Faces();
  }
  else if (Command_CAPITAL.equals("SOLID>GROUP")) {
    Select3D.convert_Solids_to_Groups();
  }
  else if (Command_CAPITAL.equals("GROUP>SOLID")) {
    Select3D.convert_Groups_to_Solids();
  }
  else if (Command_CAPITAL.equals("2D>GROUP")) {
    Select3D.convert_Model2Ds_to_Groups();
  }
  else if (Command_CAPITAL.equals("GROUP>2D")) {
    Select3D.convert_Groups_to_Model2Ds();
  }
  else if (Command_CAPITAL.equals("1D>GROUP")) {
    Select3D.convert_Model1Ds_to_Groups();
  }
  else if (Command_CAPITAL.equals("GROUP>1D")) {
    Select3D.convert_Groups_to_Model1Ds();
  }

  else if (Command_CAPITAL.equals("DISTZ")) {
    UI_set_to_View_Truck(0);
    UI_toolBar.highlight("±CDZ");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("DISTC")) {
    UI_set_to_View_CameraDistance(0);
    UI_toolBar.highlight("±CDS");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("DISTP")) {
    UI_set_to_View_DistMouseXY(0);
    UI_toolBar.highlight("±CDM");
    UI_toolBar.revise();
  }


  else if (Command_CAPITAL.equals("SIZEALL")) {
    UI_set_to_View_AllModelSize();
    UI_toolBar.highlight("±SA");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("SIZESKY")) {
    UI_set_to_View_SkydomeSize();
    UI_toolBar.highlight("±SK");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("SIZE3D")) {
    UI_set_to_View_3DModelSize();
    UI_toolBar.highlight("±SZ");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("ALLVIEWPORTS")) {
    UI_set_to_Viewport(0);
    UI_toolBar.highlight("AllViewports");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("ENLARGE3D")) {
    UI_set_to_Viewport(1);
    UI_toolBar.highlight("Expand3DView");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("LOOKORG")) {
    UI_set_to_View_LookAtOrigin(0);
    UI_toolBar.highlight("LAO");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("LOOKDIR")) {
    UI_set_to_View_LookAtDirection(0);
    UI_toolBar.highlight("LAD");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("LOOKSEL")) {
    UI_set_to_View_LookAtSelection(0);
    UI_toolBar.highlight("LAS");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("TRUCKZ")) {
    UI_set_to_View_Truck(0);
    UI_toolBar.highlight("DIz");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("TRUCKX")) {
    UI_set_to_View_Truck(1);
    UI_toolBar.highlight("DIx");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("TRUCKY")) {
    UI_set_to_View_Truck(2);
    UI_toolBar.highlight("DIy");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("TROLL")) {
    UI_set_to_View_TargetRoll(0);
    UI_toolBar.highlight("TRL");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("TROLLZ")) {
    UI_set_to_View_TargetRoll(1);
    UI_toolBar.highlight("TRLz");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("TROLLXY")) {
    UI_set_to_View_TargetRoll(2);
    UI_toolBar.highlight("TRLxy");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("CROLL")) {
    UI_set_to_View_CameraRoll(0);
    UI_toolBar.highlight("CRL");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("CROLLZ")) {
    UI_set_to_View_CameraRoll(1);
    UI_toolBar.highlight("CRLz");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("CROLLXY")) {
    UI_set_to_View_CameraRoll(2);
    UI_toolBar.highlight("CRLxy");
    UI_toolBar.revise();
  }


  else if (Command_CAPITAL.equals("ORBIT")) {
    UI_set_to_View_Orbit(0);
    UI_toolBar.highlight("OR");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("ORBITZ")) {
    UI_set_to_View_Orbit(1);
    UI_toolBar.highlight("ORz");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("ORBITXY")) {
    UI_set_to_View_Orbit(2);
    UI_toolBar.highlight("ORxy");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("LANDORBIT")) {
    UI_set_to_View_LandOrbit(0);
    UI_toolBar.highlight("LNOR");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("PAN")) {
    UI_set_to_View_Pan(0);
    UI_toolBar.highlight("Pan");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("PANX")) {
    UI_set_to_View_Pan(1);
    UI_toolBar.highlight("PanX");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("PANY")) {
    UI_set_to_View_Pan(2);
    UI_toolBar.highlight("PanY");
    UI_toolBar.revise();
  }

  else if (Command_CAPITAL.equals("ZOOM")) {
    UI_set_to_View_ZOOM(0);
    UI_toolBar.highlight("±ZM");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("NORMALZOOM")) {
    UI_set_to_View_ZOOM(1);
    UI_toolBar.highlight("0ZM");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("ORTHOGRAPHIC")) {
    UI_set_to_View_ProjectionType(0);
    UI_toolBar.highlight("P<>");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("PERSPECTIVE")) {
    UI_set_to_View_ProjectionType(1);
    UI_toolBar.highlight("P><");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("TOP")) {
    UI_set_to_View_3DViewPoint(0);
    UI_toolBar.highlight("Top");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("FRONT")) {
    UI_set_to_View_3DViewPoint(1);
    UI_toolBar.highlight("Front");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("LEFT")) {
    UI_set_to_View_3DViewPoint(2);
    UI_toolBar.highlight("Left");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("BACK")) {
    UI_set_to_View_3DViewPoint(3);
    UI_toolBar.highlight("Back");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("RIGHT")) {
    UI_set_to_View_3DViewPoint(4);
    UI_toolBar.highlight("Right");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("BOTTOM")) {
    UI_set_to_View_3DViewPoint(5);
    UI_toolBar.highlight("Bottom");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("S.W.")) {
    UI_set_to_View_3DViewPoint(6);
    UI_toolBar.highlight("S.W.");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("S.E.")) {
    UI_set_to_View_3DViewPoint(7);
    UI_toolBar.highlight("S.E.");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("N.E.")) {
    UI_set_to_View_3DViewPoint(8);
    UI_toolBar.highlight("N.E.");
    UI_toolBar.revise();
  }
  else if (Command_CAPITAL.equals("N.W.")) {
    UI_set_to_View_3DViewPoint(9);
    UI_toolBar.highlight("N.W.");
    UI_toolBar.revise();
  }


  else if (Command_CAPITAL.equals("SHADE.WIRE")) {
    WIN3D.FacesShade = SHADE.Surface_Wire;
    allFaces.displayEdges = true; //<<<<<<<<<<<<<<<
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.BASE")) {
    WIN3D.FacesShade = SHADE.Surface_Base;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.WHITE")) {
    WIN3D.FacesShade = SHADE.Surface_White;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.MATERIALS")) {
    WIN3D.FacesShade = SHADE.Surface_Materials;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.GLOBAL")) {
    WIN3D.FacesShade = SHADE.Global_Solar;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.REAL")) {
    WIN3D.FacesShade = SHADE.Vertex_Solar;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.SOLID")) {
    WIN3D.FacesShade = SHADE.Vertex_Solid;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("SHADE.ELEVATION")) {
    WIN3D.FacesShade = SHADE.Vertex_Elevation;
    SOLARCHVISION_view_changed();
  }
  else if (Command_CAPITAL.equals("RENDER.VIEWPORT")) {
    SOLARCHVISION_RenderViewport();
  }
  else if (Command_CAPITAL.equals("PREBAKE.VIEWPORT")) {
    SOLARCHVISION_preBakeViewport();
  }


  else if (Command_CAPITAL.equals("LONLAT")) {
    if (parts.length > 2) {

      STATION.setLatitude(float(parts[2]));
      STATION.setLongitude(float(parts[1]));

      SOLARCHVISION_update_station(1);
    }
    else {
      return_message = "LonLat ? ?";
    }
  }


  return return_message;
}



solarchvision_STATION[] TMYEPW_Coordinates;

void inputCoordinates_TMYEPW () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/TMYEPW.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line

  TMYEPW_Coordinates = new solarchvision_STATION [num_stn];

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line

    String[] parts = split(lineSTR, ",");

    TMYEPW_Coordinates[f] = new solarchvision_STATION();

    TMYEPW_Coordinates[f].setCity(parts[1]);
    TMYEPW_Coordinates[f].setProvince(parts[2]);
    TMYEPW_Coordinates[f].setCountry(parts[3]);
    TMYEPW_Coordinates[f].setLatitude(float(parts[6]));
    TMYEPW_Coordinates[f].setLongitude(float(parts[7]));
    TMYEPW_Coordinates[f].setTimelong(float(parts[8]) * 15);
    TMYEPW_Coordinates[f].setElevation(float(parts[9]));
    TMYEPW_Coordinates[f].setFilename_TMYEPW(parts[10]);
  }
}




solarchvision_STATION[] CWEEDS_coordinates;

void inputCoordinates_CWEEDS () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/CWEEDS.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line

  CWEEDS_coordinates = new solarchvision_STATION [num_stn];

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line

    String[] parts = split(lineSTR, ',');

    float latitude = float(parts[5]);
    float longitude = float(parts[6]);

    CWEEDS_coordinates[f] = new solarchvision_STATION();

    CWEEDS_coordinates[f].setCity(parts[1]);
    CWEEDS_coordinates[f].setProvince(parts[2]);
    CWEEDS_coordinates[f].setCountry(parts[3]);
    CWEEDS_coordinates[f].setLatitude(latitude);
    CWEEDS_coordinates[f].setLongitude(longitude);
    CWEEDS_coordinates[f].setTimelong(float(parts[7]));
    CWEEDS_coordinates[f].setElevation(float(parts[8]));
    CWEEDS_coordinates[f].setFilename_CWEEDS(parts[9]);
  }
}






solarchvision_STATION[] CLMREC_Coordinates;

void inputCoordinates_CLMREC () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/CLMREC.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line

  CLMREC_Coordinates = new solarchvision_STATION [num_stn];

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line

    String[] parts = split(lineSTR, ",");

    CLMREC_Coordinates[f] = new solarchvision_STATION();

    float latitude = float(parts[6]);
    float longitude = float(parts[7]);

    CLMREC_Coordinates[f].setCity(parts[0].replace('/', '_'));
    CLMREC_Coordinates[f].setProvince(parts[1]);
    CLMREC_Coordinates[f].setCountry("CA");
    CLMREC_Coordinates[f].setLatitude(latitude);
    CLMREC_Coordinates[f].setLongitude(longitude);
    CLMREC_Coordinates[f].setTimelong(funcs.roundTo(longitude, 15));
    CLMREC_Coordinates[f].setElevation(float(parts[10]));
    //CLMREC_Coordinates[f].setFilename_CLMREC(?);
  }
}




solarchvision_STATION[] SWOB_Coordinates;

void inputCoordinates_SWOB () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/SWOB.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line

  SWOB_Coordinates = new solarchvision_STATION [num_stn];

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line

    String[] parts = split(lineSTR, '\t');

    float latitude = float(parts[5]);
    float longitude = float(parts[6]);

    SWOB_Coordinates[f] = new solarchvision_STATION();

    String code = parts[8];
    if (parts[4].equals("Manned")) code += "-MAN";
    if (parts[4].equals("Auto")) code += "-AUTO";

    SWOB_Coordinates[f].setCode(code);
    SWOB_Coordinates[f].setCity(parts[2]);
    SWOB_Coordinates[f].setProvince(parts[3]);
    SWOB_Coordinates[f].setCountry("CA");
    SWOB_Coordinates[f].setLatitude(latitude);
    SWOB_Coordinates[f].setLongitude(longitude);
    SWOB_Coordinates[f].setTimelong(funcs.roundTo(longitude, 15));
    SWOB_Coordinates[f].setElevation(float(parts[7]));
    //SWOB_Coordinates[f].setFilename_SWOB(?);

  }
}








solarchvision_STATION[] NAEFposition_Ts;

void inputCoordinates_NAEFS () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/NAEFS.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line

  NAEFposition_Ts = new solarchvision_STATION [num_stn];

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line

    String[] parts = split(lineSTR, '\t');

    String filename = parts[0];

    String city = split(filename, '_')[0];
    String province = split(filename, '_')[1];
    String country = split(filename, '_')[2];

    float latitude = 0;
    float longitude = 0;
    float elevation = 0;

    int l = 0;

    l = parts[1].length();
    if (((parts[1].substring(l - 1, l)).equals("N")) || ((parts[1].substring(l - 1, l)).equals("S"))) {
      String[] the_parts = split(parts[1], ':');
      latitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[1].substring(l - 1, l)).equals("S")) latitude *= -1;
    } else {
      latitude = float(parts[1]);
    }

    l = parts[2].length();
    if (((parts[2].substring(l - 1, l)).equals("E")) || ((parts[2].substring(l - 1, l)).equals("W"))) {
      String[] the_parts = split(parts[2], ':');
      longitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[2].substring(l - 1, l)).equals("W")) longitude *= -1;
    } else {
      longitude = float(parts[2]);
    }

    l = parts[3].length();
    elevation = float(parts[3].substring(0, l - 1));


    NAEFposition_Ts[f] = new solarchvision_STATION();

    NAEFposition_Ts[f].setCity(city);
    NAEFposition_Ts[f].setProvince(province);
    NAEFposition_Ts[f].setCountry(country);
    NAEFposition_Ts[f].setLatitude(latitude);
    NAEFposition_Ts[f].setLongitude(longitude);
    NAEFposition_Ts[f].setTimelong(funcs.roundTo(longitude, 15));
    NAEFposition_Ts[f].setElevation(elevation);
    NAEFposition_Ts[f].setFilename_NAEFS(filename);
  }
}



void download_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  boolean new_files_downloaded = false;

  for (int f = 0; f < numberOfLayers; f++) {
    if (allLayers[f].name.equals("")) {
    } else {
      String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";

      String the_target = Folder_ENSEMBLE_FORECAST + "/" + FN;

      File dir = new File(the_target);
      if (!dir.isFile()) {

        String the_directory = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + nf(THE_HOUR, 2) + "/" + allLayers[f].name + "/raw";
        String the_link = "https://dd.weather.gc.ca/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/WXO-DD/ensemble/naefs/xml/" + the_directory + "/" + FN + ".bz2";
        the_target = the_target + ".bz2";

        println("Try downloading: " + the_link);

        try {
          saveBytes(the_target, loadBytes(the_link));

          new_files_downloaded = true;
        }
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }
  }



  if (new_files_downloaded) {

    String folder_inout = Folder_ENSEMBLE_FORECAST;
    // on Windows:
    //folder_inout = folder_inout.replace('/', char(92));

    {
      // on Windows:
      //String Command1 = "cmd /c \"\"C:\\Program Files (x86)\\7-Zip\\7z.exe\"\" e " + folder_inout + "\\*.bz2 -o" + folder_inout + " -y";
      String Command1 = "for bz2 in " + folder_inout + "/*.bz2; do 7z e $bz2 -o" + folder_inout + " -y; done";
      println(Command1);

      // on Windows:
      //String Command2 = "del " + folder_inout + "\\*.bz2 /q";
      String Command2 = "rm " + folder_inout + "/*.bz2";
      println(Command2);

      try {
        // on Windows:
        //launch(Command1 + " & " + Command2);
        exec(Command1 + " && " + Command2);
      }
      catch (Exception e) {
        println(e);
      }
    }

    Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST);

    ENSEMBLE_FORECAST_load = true;
    update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
  }
}


void update_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST); // slow <<<<<<<<<<<< this line didn't work well below... but it is rather slow here!

  ENSEMBLE_FORECAST_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)];
  ENSEMBLE_FORECAST_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
          ENSEMBLE_FORECAST_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_FORECAST_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_FORECAST_load) {

    for (int f = 0; f < numberOfLayers; f++) {
      if (allLayers[f].name.equals("")) {
      } else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";

        String the_source = Folder_ENSEMBLE_FORECAST + "/" + FN;

        File dir = new File(the_source);
        if (dir.isFile()) load_ENSEMBLE_FORECAST(the_source, f);
        else println("FILE NOT FOUND:", the_source);
      }
    }

    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);

    WORLD.displayAll_NAEFS = 1;
    WORLD.displayNear_NAEFS = true;
  }

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

  SampleMember_Start = ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;
}







void load_ENSEMBLE_FORECAST (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  boolean continue_process = true;

  XML FileALL = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileALL = loadXML(FileName);
  }
  catch (Exception e) {
    println("Can't read:", FileName);
    continue_process = false;
  }

  if (continue_process) {

    //println(TIME.year, TIME.month, TIME.day, TIME.hour);

    XML[] children0 = FileALL.getChildren("forecast");

    for (int Li = 0; Li < children0.length; Li++) {

      int _a1 = children0[Li].getInt("forecast_hour");
      String _a2 = children0[Li].getString("valid_time");

      //println("Li=", Li, "hour =", _a1, "date:", _a2);

      if (Li >= 0) {

        int THE_YEAR = int(_a2.substring(0, 4));
        int THE_MONTH = int(_a2.substring(4, 6));
        int THE_DAY = int(_a2.substring(6, 8));
        int THE_HOUR = int(_a2.substring(8));

        //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

        int now_i = int(THE_HOUR);
        int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

        //println(now_i, now_j);

        now_i -= int(-STATION.getTimelong() / 15);
        if (now_i < 0) {
          now_i += 24;
          now_j -= 1;
          if (now_j < 0) {
            now_j += 365;
          }
        }

        //println(now_i, now_j);
        //println("-------------");

        XML[] _c = children0[Li].getChildren("model");
        //println("number of members:", _c.length);

        for (int Lk = 0; Lk < _c.length; Lk++) {
          int k = _c[Lk].getInt("id") - 1;

          if (k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)) {

            ENSEMBLE_FORECAST_values[now_i][now_j][Load_Layer][k] = Float.valueOf(_c[Lk].getContent());
          }
        }
      }
    }
  }
}




void update_CLIMATE_CWEEDS () {

  CLIMATE_CWEEDS_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)];
  CLIMATE_CWEEDS_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k++) {
          CLIMATE_CWEEDS_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CWEEDS_flags[i][j][l][k] = false;
        }
      }
    }
  }


  if (CLIMATE_CWEEDS_load) {

    String FN = STATION.getFilename_CWEEDS() + ".WY3";

    String the_source = Folder_CLIMATE_CWEEDS + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_CWEEDS(the_source);
    else println("FILE NOT FOUND:", the_source);

  }

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

  SampleYear_Start = CLIMATE_CWEEDS_start;
  SampleYear_End = CLIMATE_CWEEDS_end;
}


void load_CLIMATE_CWEEDS (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  println("lines = ", FileALL.length);

  for (int f = 1; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    int CLIMATE_YEAR = int(lineSTR.substring(8, 12));
    int CLIMATE_MONTH = int(lineSTR.substring(12, 14));
    int CLIMATE_DAY = int(lineSTR.substring(14, 16));
    int CLIMATE_HOUR = int(lineSTR.substring(16, 18));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CWEEDS_start);

    //println(i);

    CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = float(lineSTR.substring(87, 92)); // 10 times in Pa
    CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = float(lineSTR.substring(93, 97)); // 10 times in °C
    //CLIMATE_CWEEDS_values[i][j][LAYER_relhum.id][k] = 50; // Relative Humidity is not presented in DCLIMATE files!
    CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = float(lineSTR.substring(22, 26)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = float(lineSTR.substring(28, 32)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = float(lineSTR.substring(34, 38)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = float(lineSTR.substring(107, 111)); // 10 times in m/s
    CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = float(lineSTR.substring(103, 106)); // °
    CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = float(lineSTR.substring(115, 117)); // 0.1 times in %
    CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = float(lineSTR.substring(63, 67)); // 0.1 times in m

    if (CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] == 99999) CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = 0.1 * 3.6 * CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 7777) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000; // <<<<<<<<<

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 10 * CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k];
  }

  SOLARCHVISION_setDataFlags(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_CWEEDS);

  WORLD.displayAll_CWEEDS = 1;
  WORLD.displayNear_CWEEDS = true;

}







void download_CLIMATE_CLMREC () {

  if (nearest_Station_CLMREC_id != -1) {

    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {

        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;

        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";

        String the_target = Folder_CLIMATE_CLMREC + "/" + FN;

        File dir = new File(the_target);
        if (!dir.isFile()) {

          String the_link = "https://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&stationID=" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCode() + "&Year=" + nf(THE_YEAR, 4) + "&Month=" + nf(THE_MONTH, 2) + "&timeframe=1";

          println("Try downloading: " + the_link);

          try {
            saveBytes(the_target, loadBytes(the_link));
          }
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }

    Files_CLIMATE_CLMREC = OPESYS.getFiles(Folder_CLIMATE_CLMREC);

    CLIMATE_CLMREC_load = true;
    update_CLIMATE_CLMREC();
  }
}


void update_CLIMATE_CLMREC () {

  CLIMATE_CLMREC_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)];
  CLIMATE_CLMREC_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
          CLIMATE_CLMREC_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CLMREC_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_CLMREC_load) {

    nearest_Station_CLMREC_id = -1;
    nearest_Station_CLMREC_dist = FLOAT_undefined;

    for (int f = 0; f < CLMREC_Coordinates.length; f++) {

      //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016)
      { // only use stations with this condition

        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude();
        if (_lon > 180) _lon -= 360; // << important!

        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

        if (nearest_Station_CLMREC_dist > d) {

          nearest_Station_CLMREC_dist = d;
          nearest_Station_CLMREC_id = f;
        }
      }
    }


    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {

        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;

        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";

        String the_source = Folder_CLIMATE_CLMREC + "/" + FN;

        File dir = new File(the_source);
        if (dir.isFile()) load_CLIMATE_CLMREC(the_source);
        else println("FILE NOT FOUND:", the_source);

      }
    }

    SOLARCHVISION_setDataFlags(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_fillGaps(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CLMREC);

    WORLD.displayAll_CLMREC = 1;
    WORLD.displayNear_CLMREC = true;

  }

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

  SampleYear_Start = CLIMATE_CLMREC_start;
  SampleYear_End = CLIMATE_CLMREC_end;
}


void load_CLIMATE_CLMREC (String FileName) {

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  println("lines = ", FileALL.length);

  for (int f = 18; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("\"", "");
    String[] parts = split(lineSTR, ",");

    int CLIMATE_YEAR = int(parts[1]);
    int CLIMATE_MONTH = int(parts[2]);
    int CLIMATE_DAY = int(parts[3]);
    int CLIMATE_HOUR = int(parts[4].substring(0, 2));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR);
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CLMREC_start);

    //println(i);

    if (parts.length > 24) {

      String str = "";

      str = parts[24];

      //println(str);

      if (str.equals("NA")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;
      else if (str.equals("Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 0;
      else if (str.equals("Mainly Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 2.5;
      else if (str.equals("Mostly Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 5;
      else if (str.equals("Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 7.5;
      else CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 10;

      //println(CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k]);

      str = parts[6];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_drybulb.id][k] = float(str); // °C

      str = parts[10];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_relhum.id][k] = float(str); // %

      str = parts[12];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_winddir.id][k] = float(str) * 10; // °

      str = parts[14];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_windspd.id][k] = float(str); // km/h

      str = parts[18];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_pressure.id][k] = float(str) * 10; // hPa


    }
  }

}









void update_CLIMATE_TMYEPW () {

  CLIMATE_TMYEPW_values = new float [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)];
  CLIMATE_TMYEPW_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k++) {
          CLIMATE_TMYEPW_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_TMYEPW_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_TMYEPW_load) {

    String FN = STATION.getFilename_TMYEPW() + ".epw";

    String the_source = Folder_CLIMATE_TMYEPW + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_TMYEPW(the_source);
    else println("FILE NOT FOUND:", the_source);

    WORLD.displayAll_TMYEPW = 1;
    WORLD.displayNear_TMYEPW = true;

  }

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

}




void load_CLIMATE_TMYEPW (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  //println("lines = ", FileALL.length);

  for (int f = 8; f < FileALL.length; f++) {

    lineSTR = FileALL[f];

    String[] parts = split(lineSTR, ",");

    int CLIMATE_YEAR = int(parts[0]);
    int CLIMATE_MONTH = int(parts[1]);
    int CLIMATE_DAY = int(parts[2]);
    int CLIMATE_HOUR = int(parts[3]);

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = 0; // on TMYEPW:TMY files we have only one year

    //println(i);

    CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = float(parts[9]) * 0.01; // 10 times in Pa
    CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = float(parts[6]); // in °C
    CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = float(parts[8]); // 0 - 110%
    CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = float(parts[13]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = float(parts[14]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = float(parts[15]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = float(parts[21]); // in m/s
    CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = float(parts[20]); // °
    CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = float(parts[23]); // 0.1 times in % ... there is also total_sky_cover on[22]
    CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = float(parts[25]); // in m


    if (CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] == 999999) CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] == 99.9) CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = 3.6 * CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 77777) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 88888) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 99999) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
  }

  SOLARCHVISION_setDataFlags(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_TMYEPW);

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

}



void download_ENSEMBLE_OBSERVED () {

  // this line tries to update the most recent files! <<
  int THE_YEAR = year();
  int THE_MONTH = month();
  int THE_DAY = day();
  int THE_HOUR = hour();


  float THE_DATE = TIME.date;

  int now_i = int(THE_HOUR);
  int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

  now_i += int(-STATION.getTimelong() / 15);
  if (now_i > 23) {
    now_i -= 24;
    now_j += 1;
    if (now_j > 364) {
      now_j -= 365;
      THE_YEAR += 1;
    }
    THE_DATE += 1;
    if (THE_DATE > 364) THE_DATE -= 365;
  }
  THE_HOUR = now_i;

  for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

    THE_MONTH = TIME.getMonth_fromDate(THE_DATE);
    THE_DAY = TIME.getDay_fromDate(THE_DATE);

    for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

      int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

      if (f != -1) {

        String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

        String the_target = Folder_ENSEMBLE_OBSERVED + "/" + FN;

        File dir = new File(the_target);
        if (!dir.isFile()) {

          String the_link = "https://dd.weather.gc.ca/observations/swob-ml/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + split(SWOB_Coordinates[f].getCode(),'-')[0] + "/" + FN;

          println("Try downloading: " + the_link);

          try {
            saveBytes(the_target, loadBytes(the_link));
          }
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }

    now_i -= 1;
    if (now_i < 0) {
      now_i += 24;
      now_j -= 1;
      if (now_j < 0) {
        now_j += 365;
        THE_YEAR -= 1;
      }
      THE_DATE -= 1;
      if (THE_DATE < 0) THE_DATE += 364;
    }
    THE_HOUR = now_i;
  }


  Files_ENSEMBLE_OBSERVED = OPESYS.getFiles(Folder_ENSEMBLE_OBSERVED);

  ENSEMBLE_OBSERVED_load = true;
  SOLARCHVISION_update_ENSEMBLE_OBSERVED();
}

void SOLARCHVISION_update_ENSEMBLE_OBSERVED () {

  ENSEMBLE_OBSERVED_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)];
  ENSEMBLE_OBSERVED_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start); k++) {
          ENSEMBLE_OBSERVED_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_OBSERVED_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_OBSERVED_load) {

    // this line tries to update the most recent files! <<
    int THE_YEAR = year();
    int THE_MONTH = month();
    int THE_DAY = day();
    int THE_HOUR = hour();


    float THE_DATE = TIME.date;

    int now_i = int(THE_HOUR);
    int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

    now_i += int(-STATION.getTimelong() / 15);
    if (now_i > 23) {
      now_i -= 24;
      now_j += 1;
      if (now_j > 364) {
        now_j -= 365;
        THE_YEAR += 1;
      }
      THE_DATE += 1;
      if (THE_DATE > 364) THE_DATE -= 365;
    }
    THE_HOUR = now_i;

    for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

      THE_MONTH = TIME.getMonth_fromDate(THE_DATE);
      THE_DAY = TIME.getDay_fromDate(THE_DATE);

      for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

        int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

        if (f != -1) {

          String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

          String the_source = Folder_ENSEMBLE_OBSERVED + "/" + FN;

          File dir = new File(the_source);
          if (dir.isFile()) load_ENSEMBLE_OBSERVED(the_source, q);
          else println("FILE NOT FOUND:", the_source);

        }
      }

      now_i -= 1;
      if (now_i < 0) {
        now_i += 24;
        now_j -= 1;
        if (now_j < 0) {
          now_j += 365;
          THE_YEAR -= 1;
        }
        THE_DATE -= 1;
        if (THE_DATE < 0) THE_DATE += 364;
      }
      THE_HOUR = now_i;
    }

    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_OBSERVED); // <<<<<<<<<<<<
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_OBSERVED);

    WORLD.displayAll_SWOB = 1;
    WORLD.displayNear_SWOB = true;
  }

  WORLD.revise();
  STUDY.revise();
  ROLLOUT.revise();
  UI_timeBar.revise();
  SOLARCHVISION_view_changed();

  SampleStation_Start = ENSEMBLE_OBSERVED_start;
  SampleStation_End = ENSEMBLE_OBSERVED_end;
}


void load_ENSEMBLE_OBSERVED (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  XML FileALL = loadXML(FileName);

  XML[] children0 = FileALL.getChildren("om:member");
  XML[] children1 = children0[0].getChildren("om:Observation");
  XML[] children2 = children1[0].getChildren("om:samplingTime");
  XML[] children3 = children2[0].getChildren("gml:TimeInstant");
  XML[] children4 = children3[0].getChildren("gml:timePosition");
  String _TimeInstant = String.valueOf(children4[0].getContent());
  //println(_TimeInstant);

  int THE_YEAR = int(_TimeInstant.substring(0, 4));
  int THE_MONTH = int(_TimeInstant.substring(5, 7));
  int THE_DAY = int(_TimeInstant.substring(8, 10));
  int THE_HOUR = int(_TimeInstant.substring(11, 13));

  //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

  int now_i = int(THE_HOUR);
  int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

  //println(now_i, now_j);

  now_i -= int(-STATION.getTimelong() / 15);

  if (now_i < 0) {
    now_i += 24;
    now_j -= 1;
    if (now_j < 0) {
      now_j += 365;
    }
  }

  //println(now_i, now_j);
  //println("-------------");

  children2 = children1[0].getChildren("om:result");
  children3 = children2[0].getChildren("elements");
  children4 = children3[0].getChildren("element");

  for (int Li = 0; Li < children4.length; Li++) {

    String _a1 = children4[Li].getString("name");
    String _a2 = children4[Li].getString("value");
    String _a3 = children4[Li].getString("uom");

    //println("Li=", Li, _a1, _a2, _a3);

    if (_a2.toUpperCase().equals("MSNG")) { // missing values
      _a2 = String.valueOf(FLOAT_undefined);
    }

    if (_a1.equals("stn_pres")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_pressure.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("air_temp")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_drybulb.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("rel_hum")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_relhum.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("tot_cld_amt")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_cloudcover.id][Load_Layer] = 0.1 * Float.valueOf(_a2);
    }

    if (_a1.equals("avg_wnd_dir_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_winddir.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("avg_wnd_spd_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_windspd.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("pcpn_amt_pst6hrs")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_precipitation.id][Load_Layer] = Float.valueOf(_a2); // past 6 hours!
    }

    if (_a1.equals("avg_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("W/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = 1000 * Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }

    if (_a1.equals("tot_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("kJ/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }

  }

}



boolean diag_XML_input = false;
boolean diag_XML_output = false;


String XML_getContent(XML xml) {
 String result = xml.getContent();
 //if (diag_XML_input) println("<" + result + ">");
 return result;
}

String XML_getString(XML xml, String tag) {
 if (diag_XML_input) print(tag + "=");
 String result = xml.getString(tag);
 if (diag_XML_input) println('"' + result + '"');
 return result;
}

float XML_getFloat(XML xml, String tag) {
 if (diag_XML_input) print(tag + "=");
 float result = xml.getFloat(tag);
 if (diag_XML_input) println(result);
 return result;
}

int XML_getInt(XML xml, String tag) {
 if (diag_XML_input) print(tag + "=");
 int result = xml.getInt(tag);
 if (diag_XML_input) println(result);
 return result;
}

Boolean XML_getBoolean(XML xml, String tag) {
 if (diag_XML_input) print(tag + "=");
 Boolean result = Boolean.parseBoolean(xml.getString(tag));
 if (diag_XML_input) println(result);
 return result;
}



void XML_setContent(XML xml, String value) {
 //if (diag_XML_output) println("<" + value + ">");
 xml.setContent(value);
}

void XML_setString(XML xml, String tag, String value) {
 if (diag_XML_output) {
   print(tag + "=");
   println('"' + value + '"');
 }
 xml.setString(tag, value);
}

void XML_setFloat(XML xml, String tag, float value) {
 if (diag_XML_output) {
   print(tag + "=");
   println(value);
 }
 xml.setFloat(tag, value);
}

void XML_setInt(XML xml, String tag, int value) {
 if (diag_XML_output) {
   print(tag + "=");
   println(value);
 }
 xml.setInt(tag, value);
}

void XML_setBoolean(XML xml, String tag, boolean value) {
 if (diag_XML_output) {
   print(tag + "=");
   println(value);
 }
 xml.setString(tag, Boolean.toString(value));
}



PGraphics TREES_graphics;

PGraphics SHADOW_graphics;

float Shades_scaleX;
float Shades_scaleY;

float Shades_offsetX;
float Shades_offsetY;

float[] SunR_Rotated;


void SOLARCHVISION_castShadows_CurrentSection () {

  cursor(WAIT);

  SceneName = "Section_" + Section_Stamp();


  int RES1 = allSolarImpacts.RES1;
  int RES2 = allSolarImpacts.RES2;

  Shades_scaleX = RES1 / allSolarImpacts.U;
  Shades_scaleY = RES2 / allSolarImpacts.V;

  Shades_offsetX = allSolarImpacts.X;
  Shades_offsetY = allSolarImpacts.Y;


  SHADOW_graphics = createGraphics(RES1, RES2, P2D);

  TREES_graphics = createGraphics(RES1, RES2, P2D);

  int keep_allSolarImpacts_sectionType = allSolarImpacts.sectionType;
  float keep_allSolarImpacts_rotation = allSolarImpacts.R;

  if (allSolarImpacts.sectionType == 3) {
    allSolarImpacts.sectionType = 2;
    allSolarImpacts.R = 90 - allSolarImpacts.R;
  }

  {
    int RAD_TYPE = 0;

    for (int DATE_ANGLE = 0; DATE_ANGLE < 360; DATE_ANGLE += 15) {

      //for (int i = 0; i < 24; i++) {
      for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not needed out of this period.

        float HOUR_ANGLE = i;
        float[] SunR = funcs.SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
        SunR_Rotated = SunR;
        int SunR_Rotated_check = 3;

        if (allSolarImpacts.sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);

          SunR_Rotated_check = 2;
        } else if (allSolarImpacts.sectionType == 3) {
        }

        for (int SHD = 0; SHD <= 1; SHD++) {

          String[] STR_SHD = {
            "F", "T"
          };
          String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

          File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);

          File_Name += "_Camera00";

          TREES_graphics.beginDraw();

          TREES_graphics.blendMode(REPLACE);

          TREES_graphics.fill(255);
          TREES_graphics.stroke(255);
          TREES_graphics.strokeWeight(0);
          TREES_graphics.rectMode(CORNER);
          TREES_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            TREES_graphics.pushMatrix();
            TREES_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);

            TREES_graphics.stroke(0);
            TREES_graphics.fill(0);

            TREES_graphics.blendMode(BLEND);

            allModel2Ds.castShadows(SunR);

            TREES_graphics.popMatrix();
          }


          TREES_graphics.endDraw();

          TREES_graphics.save(File_Name + "_2D.jpg");



          SHADOW_graphics.beginDraw();

          SHADOW_graphics.blendMode(REPLACE);

          float _val = 0;
          if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
          SHADOW_graphics.fill(255 * _val);
          SHADOW_graphics.stroke(255 * _val);
          SHADOW_graphics.strokeWeight(0);
          SHADOW_graphics.rectMode(CORNER);
          SHADOW_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            SHADOW_graphics.pushMatrix();
            SHADOW_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);

            SHADOW_graphics.stroke(0);
            SHADOW_graphics.fill(0);

            allFaces.castShadows();

            Land3D.castShadows();

            allModel1Ds.draw(TypeWindow.SHADOW);

            SHADOW_graphics.popMatrix();
          }


          SHADOW_graphics.save(File_Name + "3D_.jpg"); //just to test

          if (allModel2Ds.displayAll) {

            PImage img = loadImage(File_Name + "_2D.jpg");

            img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

            SHADOW_graphics.blendMode(DARKEST);

            SHADOW_graphics.tint(255, 255);

            SHADOW_graphics.image(img, 0, 0, RES1, RES2);

            SHADOW_graphics.noTint();
          }

          SHADOW_graphics.endDraw();


          SHADOW_graphics.save(File_Name + ".png");
        }
      }
    }
  }


  {
    int RAD_TYPE = 1;

    for (int SHD = 0; SHD <= 1; SHD++) {

      String[] STR_SHD = {
        "F", "T"
      };
      String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

      File_Name += "DIF_" + STR_SHD[SHD];

      for (int i = 0; i < DiffuseVectors.length; i++) {

        float[] SunR= {
          0, DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
        };

        SunR_Rotated = SunR;
        int SunR_Rotated_check = 3;

        if (allSolarImpacts.sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * funcs.cos_ang(-allSolarImpacts.R) - b * funcs.sin_ang(-allSolarImpacts.R);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * funcs.sin_ang(-allSolarImpacts.R) + b * funcs.cos_ang(-allSolarImpacts.R);

          SunR_Rotated_check = 2;
        } else if (allSolarImpacts.sectionType == 3) {
        }



        TREES_graphics.beginDraw();

        TREES_graphics.blendMode(REPLACE);

        TREES_graphics.fill(255);
        TREES_graphics.stroke(255);
        TREES_graphics.strokeWeight(0);
        TREES_graphics.rectMode(CORNER);
        TREES_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          TREES_graphics.pushMatrix();
          TREES_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);

          TREES_graphics.stroke(0);
          TREES_graphics.fill(0);

          TREES_graphics.blendMode(BLEND);

          allModel2Ds.castShadows(SunR);

          TREES_graphics.popMatrix();
        }


        TREES_graphics.endDraw();

        TREES_graphics.save(File_Name + nf(i, 3) + "_2D.jpg");



        SHADOW_graphics.beginDraw();

        SHADOW_graphics.blendMode(REPLACE);

        float _val = 0;
        if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
        SHADOW_graphics.fill(255 * _val);
        SHADOW_graphics.stroke(255 * _val);
        SHADOW_graphics.strokeWeight(0);
        SHADOW_graphics.rectMode(CORNER);
        SHADOW_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          SHADOW_graphics.pushMatrix();
          SHADOW_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);

          SHADOW_graphics.stroke(0);
          SHADOW_graphics.fill(0);

          allFaces.castShadows();

          Land3D.castShadows();

          allModel1Ds.draw(TypeWindow.SHADOW);

          SHADOW_graphics.popMatrix();
        }

        SHADOW_graphics.save(File_Name + "3D_.jpg"); //just to test

        if (allModel2Ds.displayAll) {

          PImage img = loadImage(File_Name + nf(i, 3) + "_2D.jpg");

          img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

          SHADOW_graphics.blendMode(DARKEST);

          SHADOW_graphics.tint(255, 255);

          SHADOW_graphics.image(img, 0, 0, RES1, RES2);

          SHADOW_graphics.noTint();
        }

        SHADOW_graphics.endDraw();

        SHADOW_graphics.save(File_Name + nf(i, 3) + ".jpg");
      }



      PGraphics DIFFUSE_graphics = createGraphics(RES1, RES2, P2D);

      DIFFUSE_graphics.beginDraw();

      DIFFUSE_graphics.blendMode(REPLACE);

      DIFFUSE_graphics.fill(0);
      DIFFUSE_graphics.stroke(0);
      DIFFUSE_graphics.strokeWeight(0);
      DIFFUSE_graphics.rectMode(CORNER);
      DIFFUSE_graphics.rect(0, 0, RES1, RES2);

      for (int i = 0; i < skyFaces.length; i++) {

        PImage img = loadImage(File_Name + nf(i, 3) + ".jpg");

        DIFFUSE_graphics.blendMode(ADD);

        DIFFUSE_graphics.tint(255, 255 / (0.5 * float(skyFaces.length)));

        DIFFUSE_graphics.image(img, 0, 0, RES1, RES2);

        DIFFUSE_graphics.noTint();
      }

      DIFFUSE_graphics.endDraw();

      File_Name += "_Camera00.png";

      DIFFUSE_graphics.save(File_Name);
      println(File_Name);
    }
  }

  allSolarImpacts.sectionType = keep_allSolarImpacts_sectionType;
  allSolarImpacts.R = keep_allSolarImpacts_rotation;

  cursor(ARROW);
}










String save_folder = "";

void SOLARCHVISION_save_project (String myFile) {

  myFile = myFile.replace(char(92), '/');

  save_folder = myFile.substring(0, myFile.lastIndexOf("/"));

  XML xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  xml.setName("SOLARCHVISION_" + SOLARCHVISION_version + "_project");

  {
    XML parent = xml.addChild("SOLARCHVISION_variables");

    XML_setInt(parent, "current_ObjectCategory", current_ObjectCategory);

    XML_setFloat(parent, "GlobalAlbedo", GlobalAlbedo);
    XML_setFloat(parent, "Interpolation_Weight", Interpolation_Weight);

    XML_setInt(parent, "CLIMATIC_SolarForecast", CLIMATIC_SolarForecast);
    XML_setInt(parent, "CLIMATIC_WeatherForecast", CLIMATIC_WeatherForecast);
    XML_setInt(parent, "SOLARCHVISION_automated", SOLARCHVISION_automated);

    XML_setInt(parent, "CLIMATE_TMYEPW_start", CLIMATE_TMYEPW_start);
    XML_setInt(parent, "CLIMATE_TMYEPW_end", CLIMATE_TMYEPW_end);
    XML_setInt(parent, "CLIMATE_CWEEDS_start", CLIMATE_CWEEDS_start);
    XML_setInt(parent, "CLIMATE_CWEEDS_end", CLIMATE_CWEEDS_end);
    XML_setInt(parent, "CLIMATE_CLMREC_start", CLIMATE_CLMREC_start);
    XML_setInt(parent, "CLIMATE_CLMREC_end", CLIMATE_CLMREC_end);
    XML_setInt(parent, "ENSEMBLE_FORECAST_start", ENSEMBLE_FORECAST_start);
    XML_setInt(parent, "ENSEMBLE_FORECAST_end", ENSEMBLE_FORECAST_end);
    XML_setInt(parent, "ENSEMBLE_FORECAST_maxDays", ENSEMBLE_FORECAST_maxDays);
    XML_setInt(parent, "ENSEMBLE_OBSERVED_maxDays", ENSEMBLE_OBSERVED_maxDays);
    XML_setInt(parent, "ENSEMBLE_OBSERVED_numNearest", ENSEMBLE_OBSERVED_numNearest);
    XML_setInt(parent, "ENSEMBLE_OBSERVED_start", ENSEMBLE_OBSERVED_start);
    XML_setInt(parent, "ENSEMBLE_OBSERVED_end", ENSEMBLE_OBSERVED_end);
    XML_setInt(parent, "SampleYear_Start", SampleYear_Start);
    XML_setInt(parent, "SampleYear_End", SampleYear_End);
    XML_setInt(parent, "SampleMember_Start", SampleMember_Start);
    XML_setInt(parent, "SampleMember_End", SampleMember_End);
    XML_setInt(parent, "SampleStation_Start", SampleStation_Start);
    XML_setInt(parent, "SampleStation_End", SampleStation_End);
    XML_setBoolean(parent, "CLIMATE_TMYEPW_load", CLIMATE_TMYEPW_load);
    XML_setBoolean(parent, "CLIMATE_CWEEDS_load", CLIMATE_CWEEDS_load);
    XML_setBoolean(parent, "CLIMATE_CLMREC_load", CLIMATE_CLMREC_load);
    XML_setBoolean(parent, "ENSEMBLE_FORECAST_load", ENSEMBLE_FORECAST_load);
    XML_setBoolean(parent, "ENSEMBLE_OBSERVED_load", ENSEMBLE_OBSERVED_load);
    XML_setInt(parent, "GRIB2_Month", GRIB2_Month);
    XML_setInt(parent, "GRIB2_Day", GRIB2_Day);
    XML_setInt(parent, "GRIB2_ModelRun", GRIB2_ModelRun);
    XML_setInt(parent, "AERIAL_num", AERIAL_num);
    XML_setFloat(parent, "AERIAL_Center_Longitude", AERIAL_Center_Longitude);
    XML_setFloat(parent, "AERIAL_Center_Latitude", AERIAL_Center_Latitude);
    XML_setInt(parent, "GRIB2_Hour_Start", GRIB2_Hour_Start);
    XML_setInt(parent, "GRIB2_Hour_End", GRIB2_Hour_End);
    XML_setInt(parent, "GRIB2_Hour_Step", GRIB2_Hour_Step);
    XML_setInt(parent, "GRIB2_Layer_Start", GRIB2_Layer_Start);
    XML_setInt(parent, "GRIB2_Layer_End", GRIB2_Layer_End);
    XML_setInt(parent, "GRIB2_Layer_Step", GRIB2_Layer_Step);
    XML_setInt(parent, "GRIB2_Hour", GRIB2_Hour);
    XML_setInt(parent, "GRIB2_Layer", GRIB2_Layer);
    XML_setInt(parent, "GRIB2_DomainSelection", GRIB2_DomainSelection);
    XML_setInt(parent, "GRIB2_TGL_number", GRIB2_TGL_number);
    XML_setInt(parent, "AERIAL_graphOption", AERIAL_graphOption);
    XML_setInt(parent, "Develop_Option", Develop_Option);
    XML_setInt(parent, "Develop_DayHour", Develop_DayHour);
    XML_setBoolean(parent, "DevelopData_update", DevelopData_update);
    XML_setInt(parent, "numberOfLayers", numberOfLayers);

    XML_setFloat(parent, "Develop_AngleInclination", Develop_AngleInclination);
    XML_setFloat(parent, "Develop_AngleOrientation", Develop_AngleOrientation);
    XML_setInt(parent, "DevelopLayer_id", DevelopLayer_id);
    XML_setInt(parent, "CurrentLayer_id", CurrentLayer_id);


    XML_setInt(parent, "Impact_TYPE", Impact_TYPE);

    XML_setInt(parent, "COLOR_STYLE_Current", COLOR_STYLE_Current);
    XML_setInt(parent, "COLOR_STYLE_Number", COLOR_STYLE_Number);

    XML_setInt(parent, "CurrentDataSource", CurrentDataSource);
    XML_setInt(parent, "DrawnFrame", DrawnFrame);



    XML_setFloat(parent, "Planetary_Magnification", Planetary_Magnification);


    //XML_setInt(parent, "Camera_Variation", Camera_Variation);

    XML_setInt(parent, "allMaterials.Selection", allMaterials.Selection);
    XML_setFloat(parent, "OBJECTS_scale", OBJECTS_scale);

    XML_setInt(parent, "FrameVariation", FrameVariation);
    XML_setInt(parent, "Language_Active", Language_Active);

    XML_setInt(parent, "IMPACTS_displayDay", IMPACTS_displayDay);

    XML_setFloat(parent, "BIOSPHERE_drawResolution", BIOSPHERE_drawResolution);

    XML_setString(parent, "Default_Font", Default_Font);
  }


  STATION.to_XML(xml);

  allPoints.to_XML(xml);

  allCurves.to_XML(xml);

  allFaces.to_XML(xml);

  allCameras.to_XML(xml);

  allSolids.to_XML(xml);

  allSections.to_XML(xml);

  allModel1Ds.to_XML(xml);

  allModel2Ds.to_XML(xml);

  allGroups.to_XML(xml);

  Land3D.to_XML(xml);

  Earth3D.to_XML(xml);

  Sky3D.to_XML(xml);

  Tropo3D.to_XML(xml);

  Moon3D.to_XML(xml);

  Sun3D.to_XML(xml);

  WIN3D.to_XML(xml);

  User3D.to_XML(xml);

  Select3D.to_XML(xml);

  WORLD.to_XML(xml);

  STUDY.to_XML(xml);

  allWindRoses.to_XML(xml);

  allWindFlows.to_XML(xml);

  allSolidImpacts.to_XML(xml);

  allSolarImpacts.to_XML(xml);

  LAYER_windspd200hPa.to_XML(xml);
  LAYER_thicknesses_1000_500.to_XML(xml);
  LAYER_heightp500hPa.to_XML(xml);
  LAYER_ceilingsky.to_XML(xml);
  LAYER_cloudcover.to_XML(xml);
  LAYER_winddir.to_XML(xml);
  LAYER_windspd.to_XML(xml);
  LAYER_pressure.to_XML(xml);
  LAYER_drybulb.to_XML(xml);
  LAYER_relhum.to_XML(xml);
  LAYER_dirnorrad.to_XML(xml);
  LAYER_difhorrad.to_XML(xml);
  LAYER_glohorrad.to_XML(xml);
  LAYER_direffect.to_XML(xml);
  LAYER_difeffect.to_XML(xml);
  LAYER_precipitation.to_XML(xml);
  LAYER_developed.to_XML(xml);

  saveXML(xml, myFile);

  println("End of saving XML:", myFile);

}


void SOLARCHVISION_load_project (String myFile) {

  myFile = myFile.replace(char(92), '/');


  boolean continue_process = true;

  XML xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    xml = loadXML(myFile);
  }
  catch (Exception e) {
    println("Can't read:", myFile);
    continue_process = false;
  }

  if (continue_process) {

    try {
      SOLARCHVISION_parse_XML_variables(xml, false); // first try: loading without printing logs
    }
    catch (Exception e) {
      println("Problem loading variables:", myFile);

      SOLARCHVISION_parse_XML_variables(xml, true); // second try with printing logs
      System.exit(1);
    }

    // loading only weather data //
    SOLARCHVISION_update_station(2);
    SOLARCHVISION_update_station(3);
    SOLARCHVISION_update_station(4);
    SOLARCHVISION_update_station(5);
    ///////////////////////////////

    addNewSelectionToPreviousSelection = 0;

    addToLastGroup = false;

    UI_set_to_Create_Nothing();

    WORLD.autoView = true;

    WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

    SOLARCHVISION_update_frame_layout();

    ROLLOUT.revise();
    WORLD.revise();
    STUDY.revise();
    UI_menuBar.revise();
    UI_toolBar.revise();
    UI_timeBar.revise();
    SOLARCHVISION_view_changed();


    allSolarImpacts.rebuild_Image_array = true;
    allWindRoses.rebuild_Image_array = true;

    VertexSolar_rebuild_array = true;
    GlobalSolar_rebuild_array = true;

    VertexSolar_resize_array();
    GlobalSolar_resize_array();


    SOLARCHVISION_modify_Viewport_Title();
  }

}


void SOLARCHVISION_parse_XML_variables (XML xml, boolean desired_diag) {

  diag_XML_input = desired_diag;

  XML parent = xml.getChild("SOLARCHVISION_variables");

  current_ObjectCategory = XML_getInt(parent, "current_ObjectCategory");

  GlobalAlbedo = XML_getFloat(parent, "GlobalAlbedo");
  Interpolation_Weight = XML_getFloat(parent, "Interpolation_Weight");

  CLIMATIC_SolarForecast = XML_getInt(parent, "CLIMATIC_SolarForecast");
  CLIMATIC_WeatherForecast = XML_getInt(parent, "CLIMATIC_WeatherForecast");
  SOLARCHVISION_automated = XML_getInt(parent, "SOLARCHVISION_automated");

  CLIMATE_TMYEPW_start = XML_getInt(parent, "CLIMATE_TMYEPW_start");
  CLIMATE_TMYEPW_end = XML_getInt(parent, "CLIMATE_TMYEPW_end");
  CLIMATE_CWEEDS_start = XML_getInt(parent, "CLIMATE_CWEEDS_start");
  CLIMATE_CWEEDS_end = XML_getInt(parent, "CLIMATE_CWEEDS_end");
  CLIMATE_CLMREC_start = XML_getInt(parent, "CLIMATE_CLMREC_start");
  CLIMATE_CLMREC_end = XML_getInt(parent, "CLIMATE_CLMREC_end");
  ENSEMBLE_FORECAST_start = XML_getInt(parent, "ENSEMBLE_FORECAST_start");
  ENSEMBLE_FORECAST_end = XML_getInt(parent, "ENSEMBLE_FORECAST_end");
  ENSEMBLE_FORECAST_maxDays = XML_getInt(parent, "ENSEMBLE_FORECAST_maxDays");
  ENSEMBLE_OBSERVED_maxDays = XML_getInt(parent, "ENSEMBLE_OBSERVED_maxDays");
  ENSEMBLE_OBSERVED_numNearest = XML_getInt(parent, "ENSEMBLE_OBSERVED_numNearest");
  ENSEMBLE_OBSERVED_start = XML_getInt(parent, "ENSEMBLE_OBSERVED_start");
  ENSEMBLE_OBSERVED_end = XML_getInt(parent, "ENSEMBLE_OBSERVED_end");
  SampleYear_Start = XML_getInt(parent, "SampleYear_Start");
  SampleYear_End = XML_getInt(parent, "SampleYear_End");
  SampleMember_Start = XML_getInt(parent, "SampleMember_Start");
  SampleMember_End = XML_getInt(parent, "SampleMember_End");
  SampleStation_Start = XML_getInt(parent, "SampleStation_Start");
  SampleStation_End = XML_getInt(parent, "SampleStation_End");
  CLIMATE_TMYEPW_load = XML_getBoolean(parent, "CLIMATE_TMYEPW_load");
  CLIMATE_CWEEDS_load = XML_getBoolean(parent, "CLIMATE_CWEEDS_load");
  CLIMATE_CLMREC_load = XML_getBoolean(parent, "CLIMATE_CLMREC_load");
  ENSEMBLE_FORECAST_load = XML_getBoolean(parent, "ENSEMBLE_FORECAST_load");
  ENSEMBLE_OBSERVED_load = XML_getBoolean(parent, "ENSEMBLE_OBSERVED_load");
  GRIB2_Month = XML_getInt(parent, "GRIB2_Month");
  GRIB2_Day = XML_getInt(parent, "GRIB2_Day");
  GRIB2_ModelRun = XML_getInt(parent, "GRIB2_ModelRun");
  AERIAL_num = XML_getInt(parent, "AERIAL_num");
  AERIAL_Center_Longitude = XML_getFloat(parent, "AERIAL_Center_Longitude");
  AERIAL_Center_Latitude = XML_getFloat(parent, "AERIAL_Center_Latitude");
  GRIB2_Hour_Start = XML_getInt(parent, "GRIB2_Hour_Start");
  GRIB2_Hour_End = XML_getInt(parent, "GRIB2_Hour_End");
  GRIB2_Hour_Step = XML_getInt(parent, "GRIB2_Hour_Step");
  GRIB2_Layer_Start = XML_getInt(parent, "GRIB2_Layer_Start");
  GRIB2_Layer_End = XML_getInt(parent, "GRIB2_Layer_End");
  GRIB2_Layer_Step = XML_getInt(parent, "GRIB2_Layer_Step");
  GRIB2_Hour = XML_getInt(parent, "GRIB2_Hour");
  GRIB2_Layer = XML_getInt(parent, "GRIB2_Layer");
  GRIB2_DomainSelection = XML_getInt(parent, "GRIB2_DomainSelection");
  GRIB2_TGL_number = XML_getInt(parent, "GRIB2_TGL_number");
  AERIAL_graphOption = XML_getInt(parent, "AERIAL_graphOption");
  Develop_Option = XML_getInt(parent, "Develop_Option");
  Develop_DayHour = XML_getInt(parent, "Develop_DayHour");
  //DevelopData_update = XML_getBoolean(parent, "DevelopData_update");
  numberOfLayers = XML_getInt(parent, "numberOfLayers");
  Develop_AngleInclination = XML_getFloat(parent, "Develop_AngleInclination");
  Develop_AngleOrientation = XML_getFloat(parent, "Develop_AngleOrientation");
  DevelopLayer_id = XML_getInt(parent, "DevelopLayer_id");

  changeCurrentLayerTo(XML_getInt(parent, "CurrentLayer_id"));

  Impact_TYPE = XML_getInt(parent, "Impact_TYPE");

  COLOR_STYLE_Current = XML_getInt(parent, "COLOR_STYLE_Current");
  COLOR_STYLE_Number = XML_getInt(parent, "COLOR_STYLE_Number");

  CurrentDataSource = XML_getInt(parent, "CurrentDataSource");
  DrawnFrame = XML_getInt(parent, "DrawnFrame");

  Planetary_Magnification = XML_getFloat(parent, "Planetary_Magnification");

  Camera_Variation = XML_getInt(parent, "Camera_Variation");

  allMaterials.Selection = XML_getInt(parent, "allMaterials.Selection");
  OBJECTS_scale = XML_getFloat(parent, "OBJECTS_scale");

  FrameVariation = XML_getInt(parent, "FrameVariation");
  Language_Active = XML_getInt(parent, "Language_Active");

  IMPACTS_displayDay = XML_getInt(parent, "IMPACTS_displayDay");

  BIOSPHERE_drawResolution = XML_getFloat(parent, "BIOSPHERE_drawResolution");

  String new_Default_Font = XML_getString(parent, "Default_Font");
  if (Default_Font.equals(new_Default_Font)) {
  } else {
    Default_Font = new_Default_Font;
    SOLARCHVISION_loadDefaultFontStyle();
  }


  STATION.from_XML(xml);

  allPoints.from_XML(xml);

  allCurves.from_XML(xml);

  allFaces.from_XML(xml);

  allCameras.from_XML(xml);

  allSolids.from_XML(xml);

  allSections.from_XML(xml);

  allModel1Ds.from_XML(xml);

  allModel2Ds.from_XML(xml);

  allGroups.from_XML(xml); // Note: Groups should be inputted after Faces, Curves, Model1Ds, Model2Ds, etc.

  Land3D.from_XML(xml);

  Earth3D.from_XML(xml);

  Sky3D.from_XML(xml);

  Tropo3D.from_XML(xml);

  Moon3D.from_XML(xml);

  Sun3D.from_XML(xml);

  WIN3D.from_XML(xml);

  User3D.from_XML(xml);

  Select3D.from_XML(xml);

  WORLD.from_XML(xml);

  STUDY.from_XML(xml);

  allWindRoses.from_XML(xml);

  allWindFlows.from_XML(xml);

  allSolidImpacts.from_XML(xml);

  allSolarImpacts.from_XML(xml);

  LAYER_windspd200hPa.from_XML(xml);
  LAYER_thicknesses_1000_500.from_XML(xml);
  LAYER_heightp500hPa.from_XML(xml);
  LAYER_ceilingsky.from_XML(xml);
  LAYER_cloudcover.from_XML(xml);
  LAYER_winddir.from_XML(xml);
  LAYER_windspd.from_XML(xml);
  LAYER_pressure.from_XML(xml);
  LAYER_drybulb.from_XML(xml);
  LAYER_relhum.from_XML(xml);
  LAYER_dirnorrad.from_XML(xml);
  LAYER_difhorrad.from_XML(xml);
  LAYER_glohorrad.from_XML(xml);
  LAYER_direffect.from_XML(xml);
  LAYER_difeffect.from_XML(xml);
  LAYER_precipitation.from_XML(xml);
  LAYER_developed.from_XML(xml);

  println("End of loading XML");
}



void SOLARCHVISION_hold_project () {

  HoldStamp = nf(millis(), 0);

  String myFile = Folder_Project + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml";

  SOLARCHVISION_save_project(myFile);
}

void SOLARCHVISION_fetch_project () {

  String myFile = Folder_Project + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml";

  try {
    SOLARCHVISION_load_project(myFile);
  }
  catch (Exception e) {
    println("Cannot find the hold file:", myFile);
  }
}


String Default_Font = "Liberation Sans";

PFont SOLARCHVISION_font;

void SOLARCHVISION_loadDefaultFontStyle () {

  println("Loading font:", Default_Font);

  SOLARCHVISION_font = createFont(Default_Font, 36, true);

  SOLARCHVISION_ResetFontStyle();
}

void SOLARCHVISION_ResetFontStyle () {

  textFont(SOLARCHVISION_font);
  WORLD.graphics.textFont(SOLARCHVISION_font);
  WIN3D.graphics.textFont(SOLARCHVISION_font);
  STUDY.graphics.textFont(SOLARCHVISION_font);
}

void SOLARCHVISION_draw_frameIcon () {
  int frame_icon_size = 64;

  PGraphics frame_icon = createGraphics(frame_icon_size, frame_icon_size);

  frame_icon.beginDraw();

  //frame_icon.image(loadImage(BaseFolder + "/input/images/icon/s-icon.png"), 0, 0 );

  frame_icon.background(0);
  //frame_icon.background(63,63,255,255);

  //frame_icon.fill(255,127);
  frame_icon.fill(255, 255, 0, 127);

  frame_icon.textAlign(CENTER, CENTER);
  frame_icon.textSize(1.0 * frame_icon_size);
  frame_icon.text("S", 0.20 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("A", 0.50 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("V", 0.80 * frame_icon_size, 0.4 * frame_icon_size);

  frame_icon.endDraw();
  //frame.setIconImage(frame_icon.image);

  //frame.setTitle("SOLARCHVISION-" + SOLARCHVISION_version);
}



void SOLARCHVISION_update_station (int Step) {

  if ((Step == 0) || (Step == 1)) {

    VertexSolar_rebuild_array = true;
    GlobalSolar_rebuild_array = true;
    allSolarImpacts.rebuild_Image_array = true;
    allWindRoses.rebuild_Image_array = true;

    WORLD.revise();
    STUDY.revise();
    SOLARCHVISION_view_changed();

    LocationLAT = STATION.getLatitude();
    LocationLON = STATION.getLongitude();

    WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

    TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
  }

  if ((Step == 0) || (Step == 2)) update_CLIMATE_TMYEPW();

  if ((Step == 0) || (Step == 3)) update_CLIMATE_CWEEDS();

  if ((Step == 0) || (Step == 4)) update_CLIMATE_CLMREC();

  if ((Step == 0) || (Step == 5)) SOLARCHVISION_update_ENSEMBLE_OBSERVED();

  if ((Step == 0) || (Step == 6)) update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

  if ((Step == 0) || (Step == 7)) Land3D.update_mesh();
}

void SOLARCHVISION_update_models (int Step) {

  if ((Step == 0) || (Step == 1)) allGroups.makeEmpty(0); //not deleting all
  if ((Step == 0) || (Step == 2)) Create3D.add_Model_Main();
}


void SOLARCHVISION_update_folders () {

  Folder_Project = BaseFolder + "/projects/model-01";

  Folder_Wgrib2Temp = Folder_Project + "/temp";

  Folder_GEOMET = Folder_Project + "/data/GEOMET" + "/" + RunStamp;
  Folder_GRIB2 = Folder_Project + "/data/GRIB2";

  Folder_ENSEMBLE_FORECAST = Folder_Project + "/data/NAEFS";
  Folder_ENSEMBLE_OBSERVED = Folder_Project + "/data/SWOB";

  Folder_CLIMATE_CLMREC = BaseFolder + "/input/climate/CLMREC";
  Folder_CLIMATE_TMYEPW = BaseFolder + "/input/climate/TMYEPW";
  Folder_CLIMATE_CWEEDS = BaseFolder + "/input/climate/CWEEDS";

  Files_CLIMATE_CLMREC = OPESYS.getFiles(Folder_CLIMATE_CLMREC);
  Files_CLIMATE_TMYEPW = OPESYS.getFiles(Folder_CLIMATE_TMYEPW);
  Files_CLIMATE_CWEEDS = OPESYS.getFiles(Folder_CLIMATE_CWEEDS);

  Files_ENSEMBLE_OBSERVED = OPESYS.getFiles(Folder_ENSEMBLE_OBSERVED);
  Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST);

  Folder_Coordinates      = BaseFolder + "/input/coordinates";
  WORLD.ViewFolder      = BaseFolder + "/input/images/worldmap";

  Folder_People = BaseFolder + "/input/images/people";
  Folder_Trees  = BaseFolder + "/input/images/trees";

  Folder_Shadings = Folder_Project + "/shadings";

  Folder_Land         = Folder_Project + "/land";

  Folder_Export       = Folder_Project + "/export";
  Folder_Graphics     = Folder_Export + "/graphics" + "/" + RunStamp;
  Folder_Export3D      = Folder_Export + "/3D" + "/" + RunStamp;
  Folder_ViewsFromSky = Folder_Export + "/viewsFromSky" + "/" + RunStamp;
  Folder_ScreenShots   = Folder_Export + "/screenshots" + "/" + RunStamp;

  String[] filenames = OPESYS.getFiles(Folder_ScreenShots);
  if (filenames != null) SavedScreenShots = filenames.length;

}

// TODOs:

/*
test these functions:

"LandMesh >> Group"
"LandGap >> Group"

*/


// add to last group remains active when drawing houses then trees are added to the last group!


// Now when adding mulitole objects at once (e.g. trees on land), only the last one selected.

// continue to remove win3d and ui updates from create3D, etc.
// WIN3D.revise();


// move should keep the same distance of bounding box - now only moves the center

// SOLARCHVISION_snap_Faces --> allFaces.snap...

// please define station elevation data for CWEEDS points!

// after calling .reduceDegreePolygon is not complete

// remember: should optimize vertices after optimizing faces!

//for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not available out of this period.

// Tropo3D.draw --- we only use the first image!
// note we used .... float r = FLOAT_r_Earth + 10000; for clouds




// should define subroutines to perfome this not inside draw! if ((STUDY.PlotImpacts == PlotImpacts_FROMSUN_ACTIVE) || (STUDY.PlotImpacts == PlotImpacts_FROMSUN_PASSIVE)) {





// pick select LandPoint is not written.


// diffuse model used in render is simple see note "adding approximate diffuse radiation effect anyway!"


// snap for Curve objects is not developed yet.

// don't know if multiple allModel2Ds.Images[n].get(Image_X, Image_Y) in allModel2Ds selection can produce performance problems?


// note: code for SOLARCHVISION_intersect_allSolids might run a bit slow. But it is OK for now.


// should see where else could add snap3D :)


// drop functions only works for allModel2Ds objects and not at Group level

// could add join/explode groups ?


// export and import of curves
// converting curves to faces e.g. Surface, Extrude, Connect

// Modify Normal at Curve level is not complete...

// Create3D.autoNormalCurve_Selection

// writing export to rad completed for meshes and land - not Model1Ds and 2Ds yet!

// colud record Climate data flags later.

// exporting shaded land is not written.

// void Rotate3D.selection_Groups
// serach for Rotate3D.selection_Selection ( need to make them all correct for local pivots!
// local pivot


// solid rotations inside groups should be translated to locals to avoid problems!
