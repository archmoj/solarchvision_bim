

// writing export to rad completed for meshes and land - not Fractals and 2Ds yet!

// colud record Climate data flags later.

// exporting shaded land is not written. 

// void SOLARCHVISION_rotate_selectedGroup3Ds 
// serach for SOLARCHVISION_rotate_Selection ( need to make them all correct for local pivots!
// local pivot


// solid rotations inside groups should be translated to locals to avoid problems!

// some rotations are not in degrees e.g. solids, fractals??, what else?

// could add join/explode groups ?

// could add create face
// could add create vertex
// drop functions only works for living objects and not at Group3D level

// Note: different tropo layer exported in obj format but only at frame 0.
// Note: still cannot use regional layers as tropo.


import processing.pdf.*;

void launch (String s) {
  open(s);
}
void launch (String[] s) {
  open(s);
}


String BaseFolder = "C:/SOLARCHVISION_2015"; 

String Grib2ArchiveFolder;
String Wgrib2TempFolder;

String BackgroundFolder;
String WorldViewFolder;
String SWOBFolder;
String NAEFSFolder;
String CWEEDSFolder;
String CLMRECFolder;
String TMYEPWFolder;
String LandFolder;
String Object2DFolder_PEOPLE;
String Object2DFolder_TREES;
String ExportFolder;
String ProjectsFolder;
String DiagramsFolder;
String ScreenShotFolder;
String Model3DFolder;

String ProjectName = "Revision_" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
String HoldStamp = ""; 

void SOLARCHVISION_update_folders () {

  Grib2ArchiveFolder = BaseFolder + "/Input/WeatherForecast";
  Wgrib2TempFolder = BaseFolder + "/Temp";

  BackgroundFolder      = BaseFolder + "/Input/BackgroundImages/Standard/Other";
  WorldViewFolder       = BaseFolder + "/Input/BackgroundImages/Standard/World";
  SWOBFolder            = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  NAEFSFolder           = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  CWEEDSFolder          = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  CLMRECFolder          = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  TMYEPWFolder          = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  LandFolder            = BaseFolder + "/Input/CoordinateFiles/Land";
  Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_ALL_CROP_low";
  //Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_SEL";
  //Object2DFolder_PEOPLE = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People_ALL";
  Object2DFolder_TREES  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees_SEL";
  //Object2DFolder_TREES  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees_ALL";
  ExportFolder          = BaseFolder + "/Export";
  ProjectsFolder        = BaseFolder + "/Projects/Project_B01";  
  DiagramsFolder        = ExportFolder + "/Diagrams";  
  Model3DFolder         = ExportFolder + "/Model_3D" + "/" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);  

  ScreenShotFolder      = ExportFolder + "/ScreenShots" + "/" + nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
  //ScreenShotFolder      = ExportFolder + "/ScreenShots" + "/Next_Presentation";



  //try {

  String[] filenames = SOLARCHVISION_getfiles(ScreenShotFolder);
  if (filenames != null) SavedScreenShots = filenames.length;
  //println("SavedScreenShots:", SavedScreenShots);

  //} catch (Exception e) println("No ScreenShotFolder!");
}














float pre_TIME_Date;
int pre_TIME_Hour;
int pre_TIME_Day;
int pre_TIME_Month;
int pre_TIME_Year;

int pre_SampleYear_Start; 
int pre_SampleYear_End; 
int pre_SampleMember_Start;
int pre_SampleMember_End;
int pre_SampleStation_Start; 
int pre_SampleStation_End;

int pre_STUDY_JoinDays;
int pre_STUDY_i_Start;
int pre_STUDY_i_End;
int pre_STUDY_j_End;
int pre_STUDY_Setup;

int pre_IMPACTS_DisplayDay;
int pre_IMPACTS_DataSource;

int pre_STATION_Number;
int pre_STATION_Selected;

int pre_CLIMATIC_SolarForecast;
int pre_CLIMATIC_WeatherForecast;

int pre_LoadButton_CLIMATE_TMYEPW;
int pre_LoadButton_CLIMATE_CWEEDS;
int pre_LoadButton_CLIMATE_CLMREC;
int pre_LoadButton_FORECAST_ENSEMBLE;
int pre_LoadButton_RECENT_OBSERVED;    

int pre_LoadButton_LandMesh;
int pre_LoadButton_UrbanMesh; 

float pre_LocationLatitude;
float pre_LocationLongitude;

int pre_WORLD_AutoView;

int pre_selectedFractal_numbers_lastItem;
int pre_selectedObject2D_numbers_lastItem;
int pre_selectedGroup3D_numbers_lastItem;
int pre_selectedFace_numbers_lastItem;
int pre_selectedVertex_numbers_lastItem;

int pre_selectedFractal_displayEdges;
int pre_selectedObject2D_displayEdges;

int pre_selectedSolid_displayEdges;
int pre_selectedSection_displayEdges;
int pre_selectedCamera_displayEdges;

int pre_selectedLandPoint_displayPoints;



float pre_softSelection_Power;
float pre_softSelection_Radius;

float pre_selected_posValue;
float pre_selected_rotValue;
float pre_selected_scaleValue;

int pre_selection_alignX;
int pre_selection_alignY;
int pre_selection_alignZ;

int pre_selected_displayReferencePivot;

int pre_selectedGroup3D_displayPivot;
int pre_selectedGroup3D_displayEdges;
int pre_selectedGroup3D_displayBox;      

int pre_selectedFace_displayEdges;
int pre_selectedFace_displayVertexCount;
int pre_selectedVertex_displayVertices;

int pre_LoadButton_DefaultModels;

int pre_WIN3D_CurrentCamera;

int pre_WIN3D_FacesShade;

int pre_MODEL3D_Tessellation;

int pre_MODEL3D_DisplayEdges;
int pre_MODEL3D_DisplayNormals;




int pre_H_Layer_Option;
int pre_F_Layer_Option;
int pre_O_Layer_Option;
int pre_Develop_Option;

int pre_STUDY_ImpactLayer;
int pre_STUDY_CurrentLayer;

int pre_STUDY_SkyScenario;
int pre_STUDY_PlotImpacts;

int pre_SOLID_Pallet_CLR;
int pre_SOLID_Pallet_DIR; 
float pre_SOLID_Pallet_MLT; 





float pre_SolidImpact_Grade;
float pre_SolidImpact_Power;
float[] pre_SolidImpact_Rotation = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_Elevation = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_scale_U = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_scale_V = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_offset_U = {
  0, 0, 0, 0
};
float[] pre_SolidImpact_offset_V = {
  0, 0, 0, 0
};

float pre_SolidImpact_Wspd; 
float pre_SolidImpact_Wdir;

int pre_Display_SolidImpact_Points;
int pre_Display_SolidImpact_Lines;

int pre_Process_subDivisions;

int pre_Display_WindFlow;

float pre_CreateInput_powAll;








int SavedScreenShots = 0;

float Interpolation_Weight = 0.5;// 0 = linear distance interpolation, 1 = square distance interpolation, 5 = nearest







String STRING_undefined = "N/A";
float FLOAT_undefined = 2000000000; // it must be a positive big number that is not included in any data

float FLOAT_huge = 1000000000;
float FLOAT_tiny = 0.001; // don't use very tiny values that could result is shading problems at the intersection of faces

float CubePower = 16; //8; 
float StarPower = 0.25; 


double DOUBLE_r_Earth = 6373000.0;
float FLOAT_r_Earth = (float) DOUBLE_r_Earth;


float CrustDepth = 100; // 100 = 100m .The actual crust ranges from 5–70 km

float EyeLevel = 1.5; // 1.5 abouve ground - applied for setting cameras - intreanl!




float GlobalAlbedo = 0; // 0-100

float GLOBE_calculatedResolution = 2.5; //1, 2.5, 5

float BIOSPHERE_drawResolution = 5.0; //2.5; // 5: 5 degrees

float objExport_Scale = 0.001; // 0.001: 1km --> 1
int objExport_FlipZYaxis = 1; //1; // 1: to fit in Unity3D

int objExport_PrecisionVertex = 6; 
int objExport_PrecisionVtexture = 4;
int objExport_PolyToPoly = 1; // 0: Exports each group3D to different individual faces, 1: Exports group3D to group3D 

int objExport_MaterialLibrary = 1; // 0-1
int objExport_BackSides = 1; // 0-1
int objExport_CombinedMaterial = 1; // 0-1
int objExport_BakingResolution = 16;
int objExport_PalletResolution = 256;
int objExport_UsePalletOrBakeFaces = 0; // 0-1







int Display_EARTH3D_Surface = 0;
int Display_EARTH3D_Texture = 1;

int Display_TROPO3D_Surface = 0;
int Display_TROPO3D_Texture = 1;

int Display_STAR3D_Surface = 0;
int Display_STAR3D_Texture = 1;

int Display_MOON3D_Surface = 0;
int Display_MOON3D_Texture = 1;

float Planetary_Magnification = 2.5; // <<<<<<<<<<


int Language_EN = 0;
int Language_FR = 1;
int Language_Active = Language_EN;

int STATION_Number = 0; 

String[][] Defined_Stations = {

  {
    "SolidArch_01", "XX", "AT", "47.267286", "11.398778", "15", "573.5", "240.0", "", "", "AUT_Innsbruck.111200_IWEC"
  }  
  ,  
  
  {
    "FORT_MCMURRAY", "AB", "CA", "56.65", "-111.22", "-105", "369.10", "240.0", "FORT_MCMURRAY_AB_CA", "AB_FORT-MCMURRAY-A_5665_11122_10500", "CAN_AB_Fort.McMurray.719320_CWEC"
  }  
  ,
  
  
  {
    "VANCOUVER_Harbour", "BC", "CA", "49.295353", "-123.121869", "-120", "2.5", "240.0", "VANCOUVER_INTL_BC_CA", "BC_VANCOUVER-INT'L_4925_12325_12000", "CAN_BC_Vancouver.718920_CWEC"
  }  
  ,

  {
    "Isle_of_Man", "XX", "UK", "54.216539", "-4.683195", "0", "0", "240.0", "", "", "GBR_Aughton.033220_IWEC"
  }
  , 
  
  {
    "Brossard_Oakland", "QC", "CA", "45.4337", "-73.4615", "-75", "13.4594707", "240.0", "SAINT-HUBERT_QC_CA", "QC_ST-HUBERT-A_4552_7342_7500", "CAN_PQ_St.Hubert.713710_CWEC"
  }
  ,   
  
  {
    "Montreal_WestStation", "QC", "CA", "45.455158", "-73.640696", "-75", "36", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-JEAN-BREBEUF_4550_7362_7500", "CAN_PQ_Montreal.Jean.Brebeuf.716278_CWEC"
  }
  , 

  {
    "Montreal_CMC", "QC", "CA", "45.4834", "-73.7879", "-75", "36", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-INT'L-A_4547_7375_7500", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"
  }
  , 
  {
    "Montreal_Biosphere", "QC", "CA", "45.5141", "-73.53145", "-75", "9", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-JEAN-BREBEUF_4550_7362_7500", "CAN_PQ_Montreal.Jean.Brebeuf.716278_CWEC"
  }
  , 
  {
    "Montreal_Dorval", "QC", "CA", "45.470556", "-73.740833", "-75", "36", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-INT'L-A_4547_7375_7500", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"
  }
  , 
  {
    "Place_Bonaventure", "QC", "CA", "45.4995", "-73.5650", "-75", "30", "692.82", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-JEAN-BREBEUF_4550_7362_7500", "CAN_PQ_Montreal.Jean.Brebeuf.716278_CWEC"
  }
  
  , 
  {
    "OCPM_2016a", "QC", "CA", "45.489049", "-73.578942", "-75", "30", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-JEAN-BREBEUF_4550_7362_7500", "CAN_PQ_Montreal.Jean.Brebeuf.716278_CWEC"
  }  
  , 
  {
    "Ryerson_University", "ON", "CA", "43.6593", "-79.3779", "-75", "95", "461.88", "TORONTO_ISLAND_ON_CA", "ON_TORONTO_4367_7937_7500", "CAN_ON_Toronto.716240_CWEC"
  }
  , 
  {
    "Financial_District", "ON", "CA", "43.6488", "-79.3817", "-75", "86", "692.82", "TORONTO_ISLAND_ON_CA", "ON_TORONTO-ISLAND-A_4363_7940_7500", "CAN_ON_Toronto.716240_CWEC"
  }
  , 
  {
    "TORONTO-ISLAND", "ON", "CA", "43.6275", "-79.396111", "-75", "76.8", "240.0", "TORONTO_ISLAND_ON_CA", "ON_TORONTO-ISLAND-A_4363_7940_7500", "CAN_ON_Toronto.716240_CWEC"
  }
  , 
  {
    "TORONTO-PEARSON", "ON", "CA", "43.676667", "-79.630556", "-75", "173.4", "240.0", "TORONTO_PEARSON_INTL_ON_CA", "ON_TORONTO-PEARSON-INT'L_4367_7962_7500", "CAN_ON_Toronto.716240_CWEC"
  }
  , 
  {
    "CALGARY", "AB", "CA", "51.113889", "-114.02", "-120", "1084.1", "240.0", "CALGARY_INTL_AB_CA", "AB_CALGARY-INT'L-A_5110_11402_10500", "CAN_AB_Calgary.718770_CWEC"
  }
  , 
  {
    "EDMONTON", "AB", "CA", "53.31", "-113.579444", "-120", "723.3", "240.0", "EDMONTON_INTL_A_AB_CA", "AB_EDMONTON-INT'L-A_5332_11358_10500", "CAN_AB_Edmonton.711230_CWEC"
  }
  , 
  {
    "HALIFAX", "NS", "CA", "44.881111", "-63.508611", "-60", "145.4", "240.0", "HALIFAX_INTL_AIRPORT_NS_CA", "NS_HALIFAX-INT'L-A_4488_6352_6000", "CAN_NS_Shearwater.716010_CWEC"
  }
  , 
  {
    "OTTAWA", "ON", "CA", "45.383333", "-75.716667", "-75", "79.2", "240.0", "OTTAWA_INTL_ON_CA", "ON_OTTAWA-CDA_4538_7572_7500", "CAN_ON_Ottawa.716280_CWEC"
  }
  , 
  {
    "QUEBEC", "QC", "CA", "46.803611", "-71.381667", "-75", "60", "240.0", "QUEBEC_QC_CA", "QC_QUEBEC-A_4680_7137_7500", "CAN_PQ_Quebec.717140_CWEC"
  }
  , 
  {
    "SUDBURY", "ON", "CA", "46.625556", "-80.797778", "-75", "348.4", "240.0", "SUDBURY_ON_CA", "ON_SUDBURY-A_4662_8080_7500", "CAN_ON_North.Bay.717310_CWEC"
  }
  , 
  {
    "VANCOUVER_Harbour", "BC", "CA", "49.295353", "-123.121869", "-120", "2.5", "240.0", "VANCOUVER_INTL_BC_CA", "BC_VANCOUVER-INT'L_4925_12325_12000", "CAN_BC_Vancouver.718920_CWEC"
  }
  , 
  {
    "WINNIPEG", "MB", "CA", "49.91", "-97.24", "-90", "238.7", "240.0", "WINNIPEG_INTL_MB_CA", "MB_WINNIPEG-INT'L-A_4990_9723_9000", "CAN_MB_Winnipeg.718520_CWEC"
  }
  , 

  {
    "BOSTON", "MA", "US", "42.35843", "-71.05978", "-75", "15.0", "240.0", "BOSTON_MA_US", "WY2-filename", "USA_MA_Boston-Logan.Intl.AP.725090_TMY3"
  }
  , 
  {
    "CHICAGO", "IL", "US", "41.878113", "-87.6298", "-90", "181.0", "240.0", "CHICAGO_IL_US", "WY2-filename", "USA_IL_Chicago-Midway.AP.725340_TMY3"
  }
  , 
  {
    "DENVER", "CO", "US", "39.737568", "-104.98472", "-105", "1608.0", "240.0", "DENVER_CO_US", "WY2-filename", "USA_CO_Golden-NREL.724666_TMY3"
  }
  , 
  {
    "HOUSTON", "TX", "US", "29.760193", "-95.36939", "-90", "15.0", "240.0", "HOUSTON_TX_US", "WY2-filename", "USA_TX_Houston-William.P.Hobby.AP.722435_TMY3"
  }
  , 
  {
    "LAS_VEGAS", "NV", "US", "36.16994", "-115.13983", "-120", "611.0", "240.0", "LAS_VEGAS_NV_US", "WY2-filename", "USA_NV_Las.Vegas-McCarran.Intl.AP.723860_TMY3"
  }
  , 
  {
    "LOS_ANGELES", "CA", "US", "34.052235", "-118.24368", "-120", "87.0", "240.0", "LOS_ANGELES_CA_US", "WY2-filename", "USA_CA_Hawthorne-Jack.Northrop.Field.722956_TMY3"
  }
  , 
  {
    "MIAMI", "FL", "US", "25.789097", "-80.20404", "-75", "3.0", "240.0", "MIAMI_FL_US", "WY2-filename", "USA_FL_Miami.Intl.AP.722020_TMY3"
  }
  , 
  {
    "NEW_YORK_CITY", "NY", "US", "40.712784", "-74.00594", "-75", "10.0", "240.0", "NEW_YORK_CITY_NY_US", "WY2-filename", "USA_NY_New.York-Central.Park.725033_TMY3"
  }
  , 
  {
    "WASHINGTON", "DC", "US", "38.907192", "-77.03687", "-75", "22.0", "240.0", "WASHINGTON_DC_US", "WY2-filename", "USA_VA_Arlington-Ronald.Reagan.Washington.Natl.AP.724050_TMY3"
  }
  , 

  {
    "BRASILIA", "XX", "BR", "-29.176456", "-51.22032", "-45", "774.0", "240.0", "BRASILIA_XX_BR", "WY2-filename", "BRA_Santa.Maria.839360_SWERA"
  }
  , 
  {
    "RIO_DE_JANEIRO", "XX", "BR", "-22.893467", "-43.21391", "-45", "6.0", "240.0", "RIO_DE_JANEIRO_XX_BR", "WY2-filename", "BRA_Rio.de.Janeiro-Santos.Dumont.837550_SWERA"
  }
  , 
  {
    "SAO_PAULO", "XX", "BR", "-23.5500", "-46.6333", "-45", "768.0", "240.0", "SAO_PAULO_XX_BR", "WY2-filename", "BRA_Bom.Jesus.da.Lapa.832880_SWERA"
  }
  , 

  {
    "MEXICO_CITY", "DF", "MX", "19.432608", "-99.13321", "-105", "2230.0", "240.0", "CIUDAD_DE_MEXICO_DF_MX", "WY2-filename", "MEX_Mexico.City.766790_IWEC"
  }
  , 
  {
    "HAVANA", "XX", "CU", "23.05407", "-82.34519", "-75", "93.0", "240.0", "HAVANA_XX_CU", "WY2-filename", "CUB_Havana-Jose.Marti.782240_SWERA"
  }
  , 
  {
    "SANTO_DOMINGO", "XX", "DO", "18.482439", "-69.96518", "-75", "62.0", "240.0", "SANTO_DOMINGO_XX_DO", "WY2-filename", "PRI_Mayaguez-Eugenio.Maria.de.Hostos.AP.785145_TMY3"
  }
  , 
  {
    "SAN_SALVADOR", "XX", "SV", "13.679502", "-89.21397", "-90", "796.0", "240.0", "SAN_SALVADOR_XX_SV", "WY2-filename", "SLV_San.Salvador-Ilopango.786630_SWERA"
  }
  , 
  {
    "CARACAS", "XX", "VE", "10.960712", "-63.920437", "-60", "32.0", "240.0", "CARACAS_XX_VEe", "WY2-filename", "VEN_Caracas.804150_IWEC"
  }
  , 
  {
    "BOGOTA", "XX", "CO", "7.894716", "-72.504616", "-75", "302.0", "240.0", "BOGOTA_XX_CO", "WY2-filename", "COL_Bogota.802220_IWEC"
  }
  , 
  {
    "GUAYAQUIL", "XX", "EC", "-2.1241937", "-79.59123", "-75", "11.0", "240.0", "GUAYAQUIL_XX_EC", "WY2-filename", "ECU_Quito.840710_IWEC"
  }
  , 
  {
    "LIMA", "XX", "PE", "-12.032012", "-76.92987", "-75", "336.0", "240.0", "LIMA_XX_PE", "WY2-filename", "PER_Lima.846280_IWEC"
  }
  , 
  {
    "ANTOFAGASTA", "XX", "CL", "-23.65", "-70.4", "-75", "13.0", "240.0", "ANTOFAGASTA_XX_CL", "WY2-filename", "CHL_Antofagasta.854420_IWEC"
  }
  , 



  {
    "Tehran_SBU", "XX", "IR", "35.797", "51.395", "52.5", "1672", "240.0", "", "", "IRN_TEHRAN_XX_IR"
  }
  , 

  {
    "Tehran_Adib", "XX", "IR", "35.797", "51.352", "52.5", "1769", "240.0", "", "", "IRN_TEHRAN_XX_IR"
  }
  , 

  {
    "Tehran_11x12", "XX", "IR", "35.6789", "51.413063", "52.5", "1500", "240.0", "", "", "IRN_TEHRAN_XX_IR"
  }
  , 

  {
    "Hamedan", "XX", "IR", "34.807", "48.455", "52.5", "1988.5", "240.0", "", "", "IRN_HAMEDAN_XX_IR"
  }
  , 

  {
    "Vancouver_A", "BC", "CA", "49.28793", "-123.11415", "-120", "0", "240.0", "VANCOUVER_INTL_BC_CA", "BC_VANCOUVER-INT'L_4925_12325_12000", "CAN_BC_Vancouver.718920_CWEC"
  }
  , 
  {
    "Vancouver_B", "BC", "CA", "49.274166", "-123.103353", "-120", "0", "240.0", "VANCOUVER_INTL_BC_CA", "BC_VANCOUVER-INT'L_4925_12325_12000", "CAN_BC_Vancouver.718920_CWEC"
  }
  , 

  {
    "Yazd", "XX", "IR", "31.8916", "54.3712", "52.5", "1144", "240.0", "", "", "IRN_Yazd_XX_IR"
  }
  , 


  {
    "Edinburgh_School", "QC", "CA", "45.457", "-73.660", "-75", "0", "240.0", "MONTREAL_DORVAL_QC_CA", "QC_MONTREAL-INT'L-A_4547_7375_7500", "CAN_PQ_Montreal.Intl.AP.716270_CWEC"
  }
  , 

  {
    "Berlin_Museum_of_the_20th_Century", "BB", "DE", "52.5080", "13.3685", "15", "36.7", "240.0", "", "", "DEU_Berlin.103840_IWEC"
  }
  , 

  {
    "Villa-Matina", "XX", "GR", "36.644", "22.383", "15", "0", "240.0", "", "", "GRC_Andravida.166820_IWEC"
  }
  ,
};


int STATION_Selected = STATION_Number;
int LoadButton_STATION = 0; 


int STUDY_i_Start = 0;
int STUDY_i_End = 23;

int STUDY_j_Start = 0; // constant
int STUDY_j_End = 6; //2; //16; // Variable




int Display_Output_in_Explorer = 1;

int Display_Model3Ds = 1;
int Display_Model2Ds = 1;
int Display_Fractals = 1;
int Display_Leaves = 1;

int Display_Solids = 1;
int Display_Sections = 1;
int Display_Cameras = 1;


int defaultMaterial = 7;
int defaultTessellation = 0;
int defaultLayer = 0;
int defaultVisibility = 1;
int defaultExtraType = 0; // if additional info required at face level

int defaultPivotType = 0; // for Group3Ds




int DEFAULT_CreateMaterial = 7; //0;
int DEFAULT_CreateTessellation = 0;
int DEFAULT_CreateLayer = 0;
int DEFAULT_CreateVisibility = 1; // 1: view 0: hide -1:freeze 
int DEFAULT_CreateExtraType = 0; // reserved!

int DEFAULT_CreatePivotType = 0;

float ModifyInput_WeldTreshold = 0.1; 

int ModifyInput_TessellateRows = 6;
int ModifyInput_TessellateColumns = 4;

float ModifyInput_OffsetAmount = 1.0; // 1 = 1m

float ModifyInput_OpenningDepth = 1; // 1 = 1m 
float ModifyInput_OpenningArea = 0.25; //0-1, 0.25: 25% of the face area (i.e. for parallel openings) 
float ModifyInput_OpenningDeviation = 0.5; //0-1, 0.5: middle of the face edge (could be applied in rotated openning)


float CreateInput_Length = 10;
float CreateInput_Width = 10;
float CreateInput_Height = 10;


float CreateInput_Volume = 0; //3000;

float CreateInput_Orientation = 360; //0; // 360: random




float CreateInput_powX = CubePower; 
float CreateInput_powY = CubePower; 
float CreateInput_powZ = CubePower; 

float CreateInput_powAll = 8;
int CreateInput_powRnd = 0;

int CreateInput_SphereDegree = 2; //4;

int CreateInput_CylinderDegree = 24; 



int CreateInput_PolyDegree = 6;


int CreateButton_3DPoly = 0;
int CreateButton_3DExtrude = 0;
int CreateButton_3DTri = 0;
int CreateButton_3DQuad = 0;
int CreateButton_3DHouse = 0; 
int CreateButton_3DSuperOBJ = 0;
int CreateButton_3DParametric = 0;
int CreateButton_2DPerson = 0;
int CreateButton_2DPlant = 0;
int CreateButton_Fractal = 0;


int CreateParametric_Type = 0;
int CreatePerson_Type = 0;
int CreatePlant_Type = 0;
int CreateFractal_Type = 0;
int CreateFractal_DegreeMin = 1; //2; 
int CreateFractal_DegreeMax = 6; //5; //8;
int CreateFractal_Seed = -1; // -1:random, 0-99 choice
float CreateFractal_TrunkSize = 1; //0.5;
float CreateFractal_LeafSize = 1; //1; 


int ObjectCategory_LandPoint = 0; 
int ObjectCategory_Fractals = 1; 
int ObjectCategory_Object2Ds = 2; 
int ObjectCategory_Group3Ds = 3;
int ObjectCategory_Faces = 4; 
int ObjectCategory_Vertices = 5; 
int ObjectCategory_SoftVerts = 6;
int ObjectCategory_Solids = 7;
int ObjectCategory_Sections = 8;
int ObjectCategory_Cameras = 9;

int Current_ObjectCategory = ObjectCategory_Group3Ds; 

int CreateInput_MeshOrSolid = 0; // 0:Mesh 1:Solid

int WIN3D_UI_CurrentTask = 0; //-17:DistMouseXY/TargetRollXY/TargetRollZ -16:PanY/TargetRollXY/TargetRollZ -15:PanX/TargetRollXY/TargetRollZ -14:Pan/TargetRoll -13:CameraDistance/TargetRollXY/TargetRollZ -12:TargetRoll/Pan -11:TargetRollXY/TargetRollZ -10:TargetRoll/Pan -9:TargetRollXY/TargetRollZ -8:AllModelSize -7:SkydomeSize -6:Truck/Orbit -5:3DModelSize/Pan/TargetRoll -4:Pan/Height -3:Zoom/Orbit/Pan -2:RectSelect -1:PickSelect 0:Create 1:Move 2:Scale 3:Rotate 4:Seed/Material 5:Tessellation 6:Layer 7:Visibility 8:DegreeMax 9:DegreeDif 10:DegreeMin 11:TrunkSize 12:LeafSize 13:AllFractalProps 14:Pivot 15:FaceNormal 16:FaceFirstVertex 17:Drop 18:GetLength 19:PowerX 20:PowerY 21:PowerZ 22:PowerXYZ 
int WIN3D_UI_OptionXorY = 0; // 0-1
int WIN3D_UI_TaskModifyParameter = 0; //to modify objects with several parameters e.g. Fractals





int Display_SWOB_Points = 0; // 0-2
int Display_SWOB_Nearest = 0;

int Display_NAEFS_Points = 0; // 0-2
int Display_NAEFS_Nearest = 0;

int Display_CWEEDS_Points = 0; // 0-2
int Display_CWEEDS_Nearest = 0;

int Display_CLMREC_Points = 0; // 0-2
int Display_CLMREC_Nearest = 0;

int Display_TMYEPW_Points = 1; // 0-2
int Display_TMYEPW_Nearest = 1;

int FRAME_record_AUTO = 0;
int FRAME_record_JPG = 0;
int FRAME_click_JPG = 0;
int FRAME_drag_JPG = 0;

int SolidImpact_record_PDF = 0;
int SolidImpact_record_JPG = 0;

int SolarImpact_record_JPG = 0;  


int RUN_AudioProduct = 0; // inactive
int RUN_ExternalSimulation = 0; // inactive
int RUN_ExternalHardware = 0; // inactive


//-------------------------------

float SolidImpact_WindSpeed = 5; // (5m/s = 18 km/h) 
float SolidImpact_WindDirection = 180.0;

float SolidImpact_Power = 1.0; //2.0; //3.0; // 1/2/3 
float SolidImpact_Grade = 0.02; //1.0; //0.1; //10.0; //contour lines 



int CLIMATIC_SolarForecast = 0; //                                   Used for solar radiation only
int CLIMATIC_WeatherForecast = 0; // 0:linear 1:average 2:sky-based. Used for some parameters namely: air temperature, humidity

int SOLARCHVISION_automated = 0; //0: User interface, 1: Automatic

//String CLIMATE_TMYEPW_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_EPW";
String CLIMATE_TMYEPW_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_EPW_WORLD";

//String CLIMATE_CWEEDS_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED_EMPTY"; 
//String CLIMATE_CWEEDS_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED_90s"; 
String CLIMATE_CWEEDS_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CWEED";

String CLIMATE_CLMREC_directory = "C:/SOLARCHVISION_2015/Input/WeatherClimate/CLIMATE_CLMREC";

//String FORECAST_ENSEMBLE_directory = "C:/SOLARCHVISION_2015/Input/WeatherForecast/FORECAST_NAEFS";
String FORECAST_ENSEMBLE_directory = "C:/SOLARCHVISION_2015/Input/WeatherForecast/FORECAST_NAEFS_Download";

String RECENT_OBSERVED_directory = "C:/SOLARCHVISION_2015/Input/WeatherRealTime/OBSERVATION_SWOB_EMPTY";
//String RECENT_OBSERVED_directory = "C:/SOLARCHVISION_2015/Input/WeatherRealTime/OBSERVATION_SWOB";

int TIME_ModelRun = 0; //12; 

int TIME_Hour = TIME_ModelRun; //hour(); 
int TIME_Year = year(); 
int TIME_Month = month();
int TIME_Day = day(); 

int TIME_BeginDay;
float TIME_Date;

void SOLARCHVISION_RecordFrame () {

  saveFrame(ScreenShotFolder + "/" + CreateStamp(1) + "Screen.jpg");
}

String CreateStamp (int _add) {

  SavedScreenShots += _add; 

  return nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + nf(hour(), 2) + "_IMG" + nf(SavedScreenShots, 4);
}







String MAKE_Filename (String beginName) {

  String My_Filenames = ScreenShotFolder + "/" + beginName;  

  return My_Filenames;
}



String MAKE_MainName () {

  String s = "";

  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) s = nf(TIME_Year, 2) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + "_" + nf(STUDY_j_End, 0) + "dayFORECAST_";

  return s;
}

String getFilename_SolidImpact () {

  return DiagramsFolder + "/" + nf(TIME_Year, 2) + "-" + nf(TIME_Month, 2) + "-" + nf(TIME_Day, 2) + "/" + databaseString[IMPACTS_DataSource] + "/Impacts/SolidImpact" + nf(SolidImpact_sectionType, 0) + "h" + nf(int(roundTo(SolidImpact_Elevation[SolidImpact_sectionType], 1)), 4) + "r" + nf(int(roundTo(SolidImpact_Rotation[SolidImpact_sectionType], 1)), 3) + "p" + nf(SolidImpact_Power, 2, 2).replace(".", "_") + "m" + nf(SolidImpact_Grade, 2, 2).replace(".", "_");
}

String getFilename_SolarImpact () {

  return DiagramsFolder + "/" + nf(TIME_Year, 2) + "-" + nf(TIME_Month, 2) + "-" + nf(TIME_Day, 2) + "/" + databaseString[IMPACTS_DataSource] + "/Impacts/SolarImpact" + nf(SolarImpact_sectionType, 0) + "h" + nf(int(roundTo(SolarImpact_Elevation, 1)), 4) + "r" + nf(int(roundTo(SolarImpact_Rotation, 1)), 3);
}




String LocationName;
String LocationProvince;
float LocationLatitude;
float LocationLongitude;
float LocationTimeZone;
float LocationElevation;
float LocationDeltaNoon;

float HeightAboveGround = 0; //2.5; // <<<<<<<<<



float LocationLAT_step = 0.1;
float LocationLON_step = 0.1;
float LocationELE_step = 1.0;

int save_frame_number = 0;

int STUDY_record_JPG = 0;
int STUDY_record_PDF = 0;
int STUDY_record_AUTO = 0;

int WORLD_record_JPG = 0;
int WORLD_record_PDF = 0;
int WORLD_record_AUTO = 0;

int WIN3D_record_JPG = 0;
int WIN3D_record_AUTO = 0;


int STUDY_max_j_end_parameters = 16; // Constant
int STUDY_max_j_end_observations = 0; // Variable

float STUDY_PerDays = 61; //1; //45; //61; //30.5;
int STUDY_JoinDays = 1; //30;//STUDY_PerDays; // it should be set up to 1 in order to plot only one day  

int CLIMATE_TMYEPW_start = 1; 
int CLIMATE_TMYEPW_end = 1;

int CLIMATE_CWEEDS_start = 1953;
int CLIMATE_CWEEDS_end = 2005;

int CLIMATE_CLMREC_start = 2000;
int CLIMATE_CLMREC_end = 2016;

int FORECAST_ENSEMBLE_start = 1; 
int FORECAST_ENSEMBLE_end = 43; // NAEFS:1-43 we append HRDPS or other scenarions at the end  of this list

int numberOfNearestStations_FORECAST_ENSEMBLE = 1;  // <<<<<<<<

int[] nearest_Station_FORECAST_ENSEMBLE_id = new int [numberOfNearestStations_FORECAST_ENSEMBLE];
float[] nearest_Station_FORECAST_ENSEMBLE_dist = new float [numberOfNearestStations_FORECAST_ENSEMBLE];


int numberOfNearestStations_RECENT_OBSERVED = 5;  // <<<<<<<<

int RECENT_OBSERVED_start = 1; 
int RECENT_OBSERVED_end = numberOfNearestStations_RECENT_OBSERVED;

int[] nearest_Station_RECENT_OBSERVED_id = new int [numberOfNearestStations_RECENT_OBSERVED];
float[] nearest_Station_RECENT_OBSERVED_dist = new float [numberOfNearestStations_RECENT_OBSERVED];




int SampleYear_Start = 1996; 
int SampleYear_End = 2005; 

int SampleMember_Start = 1;
int SampleMember_End = 43;

int SampleStation_Start = 1; 
int SampleStation_End = 1;

float[][][][] CLIMATE_TMYEPW_Data;

float[][][][] CLIMATE_CWEEDS_Data;

float[][][][] CLIMATE_CLMREC_Data;

float[][][][] FORECAST_ENSEMBLE_Data;
int[][][][] FORECAST_ENSEMBLE_Flags;

float[][][][] RECENT_OBSERVED_Data;
int[][][][] RECENT_OBSERVED_Flags;


int LoadButton_CLIMATE_TMYEPW = 1;
int LoadButton_CLIMATE_CWEEDS = 0;
int LoadButton_CLIMATE_CLMREC = 0;
int LoadButton_FORECAST_ENSEMBLE = 0;
int LoadButton_RECENT_OBSERVED = 0;

int Download_RECENT_OBSERVED = 0;
int Download_CLMREC = 0;
int Download_FORECAST_ENSEMBLE = 1;


int Download_AERIAL = 0;


int GRIB2_Year; 
int GRIB2_Month; 
int GRIB2_Day; 
int GRIB2_ModelRun;

int AERIAL_num = 4 * (1 + 6 + 12); // the number of nearest points on the path we want to extract the data 

float AERIAL_Center_Longitude = FLOAT_undefined;
float AERIAL_Center_Latitude = FLOAT_undefined;

float[][] AERIAL_Locations;

float[][][][] AERIAL_Data;
int[][][][] AERIAL_Flags;

int GRIB2_Hour_Start = 0;
int GRIB2_Hour_End = 0; //48;
int GRIB2_Hour_Step = 6; //1;

int GRIB2_Layer_Start = 4; //_cloudcover;
int GRIB2_Layer_End = 8; //_drybulb;
int GRIB2_Layer_Step = 1;

int GRIB2_Hour;
int GRIB2_Layer;




String[][] GRIB2_Domains = {
  {
    "GEPS", "ensemble/naefs/grib2/raw", "CMC_naefs-geps-raw", "latlon1p0x1p0", "_allmbrs.grib2", "100"
  }
  , {
    "GDPS", "model_gem_global/25km/grib2/lat_lon", "CMC_glb", "latlon.24x.24", ".grib2", "20"
  }
  , {
    "RDPS", "model_gem_regional/10km/grib2", "CMC_reg", "ps10km", ".grib2", "10"
  }
  , {
    "HRDPS", "model_hrdps/east/grib2", "CMC_hrdps_east", "ps2.5km", "-00.grib2", "2.5"
  } 
  , {
    "WAVE", "model_wave/great_lakes/superior/grib2", "CMC_rdwps_lake-superior", "latlon0.05x0.0", ".grib2", "5"
  }
};



// http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/grib2/raw           /00/000/CMC_naefs-geps-raw_TMP_TGL_2m_latlon1p0x1p0_2015081800_P000_allmbrs.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_global/25km/grib2/lat_lon/00/000/CMC_glb           _TMP_TGL_2_latlon.24x.24 _2015081800_P000.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_regional/10km/grib2      /00/000/CMC_reg           _TMP_TGL_2_ps10km        _2015083100_P000.grib2 
// http://dd.weatheroffice.ec.gc.ca/model_hrdps/east/grib2             /00/000/CMC_hrdps_east    _TMP_TGL_2_ps2.5km       _2015081800_P000-00.grib2



// http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/grib2/raw/00/000/CMC_naefs-geps-raw_TMP_TGL_2m_latlon1p0x1p0_2015081800_P000_allmbrs.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_global/25km/grib2/lat_lon/00/000/CMC_glb_TMP_TGL_2_latlon.24x.24_2015081800_P000.grib2
// http://dd.weatheroffice.ec.gc.ca/model_gem_regional/10km/grib2/00/000/CMC_reg_TMP_TGL_2_ps10km_2015083100_P000.grib2 
// http://dd.weatheroffice.ec.gc.ca/model_hrdps/east/grib2/00/000/CMC_hrdps_east_TMP_TGL_2_ps2.5km_2015081800_P000-00.grib2



//int GRIB2_DomainSelection = 0; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!   
//int GRIB2_DomainSelection = 1; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 2; int GRIB2_maxScenarios = 1;

int GRIB2_DomainSelection = 3; 
int GRIB2_maxScenarios = 1;

//int GRIB2_DomainSelection = 4; int GRIB2_maxScenarios = 1; // not working now!

{
  FORECAST_ENSEMBLE_end += GRIB2_maxScenarios;
}


int AERIAL_graphOption = 0; 


PrintWriter[] FILE_outputRaw;
PrintWriter[] FILE_outputNorms;
PrintWriter[] FILE_outputProbs;

int H_Layer_Option = -1; 
int F_Layer_Option = -1;
int O_Layer_Option = -1;

int DEV_OP_00 = 8;
int DEV_OP_01 = 6;
int DEV_OP_02 = 5;
int DEV_OP_03 = 7;
int DEV_OP_04 = 4;
int DEV_OP_05 = 3;
int DEV_OP_06 = 10;
int DEV_OP_07 = 9;
int DEV_OP_08 = 11;
int DEV_OP_09 = 0;
int DEV_OP_10 = 1;
int DEV_OP_11 = 2;

int Develop_Option = DEV_OP_06; //between 0 - 11...
int Develop_DayHour = 0; //0:accumulative 1:daily(24h) 2:per12h 3:per6h <should be zero to work well with current menues> 

int Update_DevelopData = 1;







int num_Layers = 0;  

int addLayer () {
  num_Layers += 1;
  return(num_Layers - 1);
}

int LAYER_windspd200hPa = addLayer();
int LAYER_thicknesses_1000_500 = addLayer();
int LAYER_heightp500hPa = addLayer();

int LAYER_ceilingsky = addLayer();
int LAYER_cloudcover = addLayer();

int LAYER_winddir = addLayer();
int LAYER_windspd = addLayer();

int LAYER_pressure = addLayer();

int LAYER_drybulb = addLayer();

int LAYER_relhum = addLayer();

int LAYER_dirnorrad = addLayer();
int LAYER_difhorrad = addLayer();
int LAYER_glohorrad = addLayer();

int LAYER_direffect = addLayer();
int LAYER_difeffect = addLayer();


int LAYER_precipitation_A = addLayer();

int LAYER_developed = addLayer();




float Develop_AngleInclination = 45; // 90 = horizontal surface, 0 = Vertical surface 
float Develop_AngleOrientation = 0; // 0 = South, 90 = East


int STUDY_CurrentLayer = LAYER_dirnorrad; //LAYER_developed; //LAYER_drybulb; ; //LAYER_cloudcover; 

int STUDY_DevelopLayer = STUDY_CurrentLayer;

int STUDY_PrintTtitle = 1;

float STUDY_T_scale = 0.5;
float STUDY_U_scale = 18.0 / float(STUDY_j_End - STUDY_j_Start);

float[] STUDY_V_scale;
float[] STUDY_V_offset;
float[] STUDY_V_belowLine;

String[] LAYERS_Unit;
String[][] LAYERS_Title;
String[] LAYERS_Text; 
String[][] LAYERS_GRIB2_VAL;
float[] LAYERS_GRIB2_MUL;
float[] LAYERS_GRIB2_ADD;


int[] GRIB2_TGL_Selected = {
  1, 0, 0, 0
}; // for levels above ground level 
int GRIB2_TGL_number = GRIB2_TGL_Selected.length;

{
  STUDY_V_scale = new float [num_Layers];
  STUDY_V_offset = new float [num_Layers];
  STUDY_V_belowLine = new float [num_Layers];
  LAYERS_Unit = new String [num_Layers];  
  LAYERS_Title = new String [num_Layers][2];
  LAYERS_Text = new String [num_Layers];
  LAYERS_GRIB2_VAL = new String [num_Layers][GRIB2_TGL_number]; 
  LAYERS_GRIB2_MUL = new float [num_Layers];
  LAYERS_GRIB2_ADD = new float [num_Layers];

  int i = -1;

  i = LAYER_winddir;
  if (i > -1) {
    STUDY_V_scale[i] = (100.0/360.0);
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "°";
    LAYERS_Title[i][Language_EN] = "Surface Wind Direction";
    LAYERS_Title[i][Language_FR] = "Direction du vent à la surface";
    LAYERS_Text[i] = "WDIR-SFC";
    LAYERS_GRIB2_VAL[i][0] = "WDIR_TGL_10";
    LAYERS_GRIB2_VAL[i][1] = "WDIR_TGL_40";
    LAYERS_GRIB2_VAL[i][2] = "WDIR_TGL_80";
    LAYERS_GRIB2_VAL[i][3] = "WDIR_TGL_120";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_windspd;
  if (i > -1) {
    STUDY_V_scale[i] = (10.0/5.0);
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "km/h";
    LAYERS_Title[i][Language_EN] = "Surface Wind Speed";
    LAYERS_Title[i][Language_FR] = "Vitesse du vent à la surface";
    LAYERS_Text[i] = "WIND-SFC";
    LAYERS_GRIB2_VAL[i][0] = "WIND_TGL_10"; // m/sec
    LAYERS_GRIB2_VAL[i][1] = "WIND_TGL_40"; // m/sec
    LAYERS_GRIB2_VAL[i][2] = "WIND_TGL_80"; // m/sec
    LAYERS_GRIB2_VAL[i][3] = "WIND_TGL_120"; // m/sec
    LAYERS_GRIB2_MUL[i] = 3.6; // m/s > Km/h  ----> because for some domains we need to calculate wind speed and direction via U & V this value is not applied actually. Search for other line that we infact converted from m/s > Km/h
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_precipitation_A;
  if (i > -1) {
    STUDY_V_scale[i] = 4.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "mm";
    LAYERS_Title[i][Language_EN] = "Surface Accumulated Precipitation";
    LAYERS_Title[i][Language_FR] = "Précipitations accumulées à la surface";
    LAYERS_Text[i] = "APCP-SFC";
    LAYERS_GRIB2_VAL[i][0] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2_VAL[i][1] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2_VAL[i][2] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2_VAL[i][3] = "APCP_SFC_0"; // kg/m²
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_relhum;
  if (i > -1) {
    STUDY_V_scale[i] = 1.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "%";
    LAYERS_Title[i][Language_EN] = "Surface Relative Humidity";
    LAYERS_Title[i][Language_FR] = "Humidité relative à la surface";
    LAYERS_Text[i] = "RELH-SFC";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_drybulb;
  if (i > -1) {
    STUDY_V_scale[i] = (2.5 * pow(2, 0.5));
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "°C";
    LAYERS_Title[i][Language_EN] = "Surface Air Temperature";
    LAYERS_Title[i][Language_FR] = "Température de l'air à la surface";
    LAYERS_Text[i] = "TMP-SFC";
    LAYERS_GRIB2_VAL[i][0] = "TMP_TGL_2"; // Kelvin
    LAYERS_GRIB2_VAL[i][1] = "TMP_TGL_40"; // Kelvin
    LAYERS_GRIB2_VAL[i][2] = "TMP_TGL_80"; // Kelvin
    LAYERS_GRIB2_VAL[i][3] = "TMP_TGL_120"; // Kelvin
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = -273.15; // °K > °C
  }

  i = LAYER_dirnorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][Language_EN] = "Direct normal radiation";
    LAYERS_Title[i][Language_FR] = "Rayonnement direct normal";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_difhorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][Language_EN] = "Diffuse horizontal radiation";
    LAYERS_Title[i][Language_FR] = "Diffus rayonnement horizontal";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_glohorrad;
  if (i > -1) {
    STUDY_V_scale[i] = 0.1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "W/m²";
    LAYERS_Title[i][Language_EN] = "Global horizontal radiation";
    LAYERS_Title[i][Language_FR] = "Rayonnement global horizontal";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_developed;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "";
    LAYERS_Title[i][Language_EN] = "";
    LAYERS_Title[i][Language_FR] = "";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_direffect;
  if (i > -1) {
    STUDY_V_scale[LAYER_direffect] = 0.0025;
    STUDY_V_offset[LAYER_direffect] = 0;
    STUDY_V_belowLine[LAYER_direffect] = 1;
    LAYERS_Unit[i] = "W°C/m²";
    //LAYERS_Title[i][Language_EN] = "Direct normal effect (based on 18°C)";
    LAYERS_Title[i][Language_EN] = "Direct normal effect <18°C<";
    //LAYERS_Title[i][Language_FR] = "Effet direct normal (basé sur 18°C)";
    LAYERS_Title[i][Language_FR] = "Effet direct normal <18°C<";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_difeffect;
  if (i > -1) {
    STUDY_V_scale[i] = 0.0025;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "W°C/m²";
    //LAYERS_Title[i][Language_EN] = "Diffuse normal effect (based on 18°C)";
    LAYERS_Title[i][Language_EN] = "Diffuse normal effect <18°C<";
    //LAYERS_Title[i][Language_FR] = "Effet diffus normal (basé sur 18°C)";
    LAYERS_Title[i][Language_FR] = "Effet diffus normal <18°C<";
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_cloudcover;
  if (i > -1) {
    STUDY_V_scale[i] = 10.0;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "tenth";
    LAYERS_Title[i][Language_EN] = "Total Cloud Cover";
    LAYERS_Title[i][Language_FR] = "Couvert nuageux total";
    LAYERS_Text[i] = "TCDC";
    LAYERS_GRIB2_VAL[i][0] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2_VAL[i][1] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2_VAL[i][2] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2_VAL[i][3] = "TCDC_SFC_0"; // percent
    LAYERS_GRIB2_MUL[i] = 0.1; // percent >> tenth    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_ceilingsky;
  if (i > -1) {
    STUDY_V_scale[i] = 0.01;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "m";
    LAYERS_Title[i][Language_EN] = "Ceiling height";
    LAYERS_Title[i][Language_FR] = "Hauteur sous plafond";  
    LAYERS_Text[i] = "";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_pressure;
  if (i > -1) {
    STUDY_V_scale[i] = 2.0;
    STUDY_V_offset[i] = -1000;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "hPa";
    LAYERS_Title[i][Language_EN] = "Mean Sea level Pressure";
    LAYERS_Title[i][Language_FR] = "Pression moyenne au niveau de la mer";
    LAYERS_Text[i] = "MSLP";
    LAYERS_GRIB2_VAL[i][0] = "PRMSL_MSL_0";
    LAYERS_GRIB2_VAL[i][1] = "PRMSL_MSL_0";
    LAYERS_GRIB2_VAL[i][2] = "PRMSL_MSL_0";
    LAYERS_GRIB2_VAL[i][3] = "PRMSL_MSL_0";
    LAYERS_GRIB2_MUL[i] = 0.01; // Pa >> hPa 
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_heightp500hPa;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = -500;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "dam";
    LAYERS_Title[i][Language_EN] = "Geopotential at 500 hPa";
    LAYERS_Title[i][Language_FR] = "Géopotentiel à 500 hPa";
    LAYERS_Text[i] = "HGT-500HPA";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_thicknesses_1000_500;
  if (i > -1) {
    STUDY_V_scale[i] = 1;
    STUDY_V_offset[i] = -500;
    STUDY_V_belowLine[i] = 1;
    LAYERS_Unit[i] = "dam";
    //LAYERS_Title[i][Language_EN] = "Thicknesses (Geopotentiel Difference) between 1000 and 500 hPa";
    LAYERS_Title[i][Language_EN] = "Geopotentiel Difference";
    //LAYERS_Title[i][Language_FR] = "Épaisseurs (différence de géopotentiel) entre 1000 et 500 hPa";
    LAYERS_Title[i][Language_FR] = "Différence de géopotentiel";
    LAYERS_Text[i] = "LAYER-1000-500HPA";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }

  i = LAYER_windspd200hPa;
  if (i > -1) {
    STUDY_V_scale[i] = 0.5;
    STUDY_V_offset[i] = 0;
    STUDY_V_belowLine[i] = 0;
    LAYERS_Unit[i] = "knots";
    LAYERS_Title[i][Language_EN] = "Wind Speed at 200 hPa";
    LAYERS_Title[i][Language_FR] = "Vitesse du vent à 200 hPa";  
    LAYERS_Text[i] = "WIND-200HPA";
    LAYERS_GRIB2_VAL[i][0] = "";
    LAYERS_GRIB2_VAL[i][1] = "";
    LAYERS_GRIB2_VAL[i][2] = "";
    LAYERS_GRIB2_VAL[i][3] = "";
    LAYERS_GRIB2_MUL[i] = 1;    
    LAYERS_GRIB2_ADD[i] = 0;
  }
}

int STUDY_skyScenario_Active = 1; // 1: all scenarios, 2: Total Cloud Cover < 0.33, 3: middle range, 4: Total Cloud Cover > 0.66
String[] STUDY_skyScenario_Title = {
  "", "", "[66% < Total Cloud Cover]", "[33% < Total Cloud Cover < 66%]", "[Total Cloud Cover < 33%]"
};
String[] STUDY_skyScenario_FileTXT = {
  "", "", "Overcast sky", "Scattered sky", "Clear sky"
};

int FILTER_Hourly = 0;
int FILTER_Daily = 1;
int FILTER_Active = FILTER_Daily;

int STUDY_TrendJoinHours = 24; //48;
int STUDY_TrendJoinType = -1; // -1: increasing weights, +1: equal weights



int TIME_Interval = 1; //dT

int Export_STUDY_info_node = 0;
int Export_STUDY_info_norm = 0;
int Export_STUDY_info_prob = 0;

int STUDY_Pallet_SORT_CLR = -1;
int STUDY_Pallet_SORT_DIR = -1;
float STUDY_Pallet_SORT_MLT = 2;

int STUDY_Pallet_PROB_CLR = -1;
int STUDY_Pallet_PROB_DIR = 1;
float STUDY_Pallet_PROB_MLT = 0.5;

int STUDY_Pallet_ACTIVE_CLR = 19; //15; //14; 
int STUDY_Pallet_ACTIVE_DIR = 1;
float STUDY_Pallet_ACTIVE_MLT = 1; //2;

int STUDY_Pallet_PASSIVE_CLR = 1; 
int STUDY_Pallet_PASSIVE_DIR = 1;
float STUDY_Pallet_PASSIVE_MLT = 1; 

int OBJECTS_Pallet_ACTIVE_CLR = 19; //15; //14;
int OBJECTS_Pallet_ACTIVE_DIR = 1;
float OBJECTS_Pallet_ACTIVE_MLT = 1; //2; 

int OBJECTS_Pallet_PASSIVE_CLR = 1; 
int OBJECTS_Pallet_PASSIVE_DIR = 1;  
float OBJECTS_Pallet_PASSIVE_MLT = 1; 

int SunPath3D_Pallet_ACTIVE_CLR = 15;
int SunPath3D_Pallet_ACTIVE_DIR = 1;
float SunPath3D_Pallet_ACTIVE_MLT = 1;

int SunPath3D_Pallet_PASSIVE_CLR = 18; 
int SunPath3D_Pallet_PASSIVE_DIR = -1;  
float SunPath3D_Pallet_PASSIVE_MLT = 1; //1;

int SKY3D_Pallet_ACTIVE_CLR = 18; //-1; //7; //8;
int SKY3D_Pallet_ACTIVE_DIR = 1; //-1;
float SKY3D_Pallet_ACTIVE_MLT = 0.5; //0.25; //1;

int SKY3D_Pallet_PASSIVE_CLR = 18; 
int SKY3D_Pallet_PASSIVE_DIR = -1;  
float SKY3D_Pallet_PASSIVE_MLT = 1; //2;

int ELEVATION_Pallet_CLR = 1; 
int ELEVATION_Pallet_DIR = -1; 
float ELEVATION_Pallet_MLT = 0.05; 

int SOLID_Pallet_CLR = 17; //1; 
int SOLID_Pallet_DIR = -1; 
float SOLID_Pallet_MLT = 0.01; //1; 

int WindFlow_Pallet_CLR = 18; 
int WindFlow_Pallet_DIR = -1;  
float WindFlow_Pallet_MLT = 1;


int Impact_ACTIVE = 1;
int Impact_PASSIVE = 2;
int Impact_WIND_Overlay = 1;
int Impact_WIND_Temperature = 2;

int Impact_TYPE = 1; 




String[][] SOLARCHVISION_WORDS = {
  {
    "", ""
  }
  , 
  {
    "at hour", "à l'heure"
  }
  , 
  {
    "day", "jour"
  }
  , 
  {
    "month", "mois"
  }
  , 
  {
    "year", "année"
  }
  , 
  {
    "date", "date"
  }
}; 

String[][] CalendarMonth = {
  {
    "January", "janvier"
  }
  , 
  {
    "February", "février"
  }
  , 
  {
    "March", "mars"
  }
  , 
  {
    "April", "avril"
  }
  , 
  {
    "May", "mai"
  }
  , 
  {
    "June", "juin"
  }
  , 
  {
    "July", "juillet"
  }
  , 
  {
    "August", "août"
  }
  , 
  {
    "September", "septembre"
  }
  , 
  {
    "October", "octobre"
  }
  , 
  {
    "November", "novembre"
  }
  , 
  {
    "December", "décembre"
  }
};

int[] CalendarLength = {
  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
String[][] CalendarDay;
String[][] CalendarMM;
String[][] CalendarDD;
int[][] CalendarDate;


float STUDY_X_control;
float STUDY_Y_control;


float STUDY_X_Coordinate = 0;
float STUDY_Y_Coordinate = 0;

float STUDY_O_scale = 50.0;
float STUDY_W_scale = 3.0;


int COLOR_STYLE_Active = 0;
int COLOR_STYLE_Number = 20; //6;

float STUDY_rect_scale = 0.005;
float STUDY_rect_offset_x = 0.5;

PGraphics STUDY_Diagrams;

int databaseNumber_RECENT_OBSERVED = 0;
int databaseNumber_FORECAST_ENSEMBLE = 1;
int databaseNumber_CLIMATE_CWEEDS = 2;
int databaseNumber_CLIMATE_CLMREC = 3;
int databaseNumber_CLIMATE_TMYEPW = 4;

int IMPACTS_DataSource = databaseNumber_CLIMATE_TMYEPW; 

String[] databaseString = {
  "SWOB", "NAEFS", "CWEEDS", "CLMREC", "TMY"
};

int STUDY_impact_summary = 0;

int STUDY_ImpactLayer = 1; // 4 = Median
int STUDY_PlotImpacts = 4; //-2/-1:wind 0/1:urban 2/3:globe 4/5:sun-path 6/7:view-from-sun 8/9:two-cycles
int STUDY_Impacts_Update = 1; 



int DrawnFrame = 0;

int SOLARCHVISION_X_clicked = -1;
int SOLARCHVISION_Y_clicked = -1;

int SOLARCHVISION_X_click1 = -1;
int SOLARCHVISION_Y_click1 = -1;
int SOLARCHVISION_X_click2 = -1;
int SOLARCHVISION_Y_click2 = -1;

String[] CLIMATE_TMYEPW_Files = SOLARCHVISION_getfiles(CLIMATE_TMYEPW_directory);
String[] CLIMATE_CWEEDS_Files = SOLARCHVISION_getfiles(CLIMATE_CWEEDS_directory);
String[] CLIMATE_CLMREC_Files = SOLARCHVISION_getfiles(CLIMATE_CLMREC_directory);
String[] FORECAST_ENSEMBLE_XML_Files = SOLARCHVISION_getfiles(FORECAST_ENSEMBLE_directory);
String[] RECENT_OBSERVED_XML_Files = SOLARCHVISION_getfiles(RECENT_OBSERVED_directory);

int ERASE_All = 0;
int ERASE_Faces = 0;
int ERASE_Fractals = 0;
int ERASE_Object2Ds = 0;
int ERASE_Group3Ds = 0;
int ERASE_Solids = 0;
int ERASE_Sections = 0;
int ERASE_Cameras = 0;

int LAND_TESSELLATION = 0; //2;

int MODEL3D_Tessellation = 2;

int SKY3D_TESSELLATION = 3; //3;
float SKY3D_scale = 25000; //10000; //10km:Troposphere 25km:Ozone layer 100km:Karman line.

float WindRose3D_scale = 400;


int Display_SUN3D_Path = 1;
int Display_SUN3D_Pattern = 0;

int Display_SKY3D = 1;

int Download_LAND_MESH = 0;
int LoadButton_LandMesh = 1; 

int Display_LAND_MESH = 1; 
int Display_LAND_POINTS = 0;
int Display_LAND_Texture = 1;
int Display_LAND_DEPTH = 0;
int Skip_LAND_MESH_Center = 0; //5;

int LoadButton_UrbanMesh = 0;
int Display_URBAN_MESH = 1;

int Display_SolidImpact_Points = 0;
int Display_SolidImpact_Lines = 1;

int MODEL3D_DisplayEdges = 1;
int MODEL3D_DisplayNormals = 0;

int Display_WindFlow = 0;


int Camera_Variation = 0; // 1;




int STUDY_DisplayRaws = 0;
int STUDY_DisplaySorted = 1;
int STUDY_DisplayNormals = 1;
int STUDY_DisplayProbs = 0;

int STUDY_SumInterval = 2;
float STUDY_LevelPix = 8;

float STUDY_Pix = 0; 

color STUDY_color_data_raws = color(0, 0, 0);

int STUDY_Setup = 14; //4; //12; //13;

float STUDY_ImageScale = 1.0;

float WORLD_ImageScale = 1.0;

float WIN3D_ImageScale = 1.0;

















int Materials_Number = 11; //256; // 0, 1, 2, ... , 10

int Materials_Selection = 1; //2; // yellow

float[][][] Materials_DirectArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DirectArea_Flags = new int [24][365];

float[][][] Materials_DiffuseArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DiffuseArea_Flags = new int [24][365];

int[][] Materials_Color = new int [Materials_Number][4]; // ARGB                            
{
  {
    int[] COL = {
      255, 255, 127, 0
    };    
    Materials_Color[0] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 0
    };    
    Materials_Color[1] = COL;
  }  
  {
    int[] COL = {
      255, 255, 255, 0
    };    
    Materials_Color[2] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 0
    };    
    Materials_Color[3] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 255
    };    
    Materials_Color[4] = COL;
  }
  {
    int[] COL = {
      255, 0, 0, 255
    };    
    Materials_Color[5] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 255
    };    
    Materials_Color[6] = COL;
  }
  {
    int[] COL = {
      255, 255, 255, 255
    };    
    Materials_Color[7] = COL;
  }
  {
    //int[] COL = {255, 63, 63, 63};    
    int[] COL = {
      63, 63, 63, 63
    };
    Materials_Color[8] = COL;
  }
  {
    //int[] COL = {255, 127, 127, 127};    
    int[] COL = {
      127, 127, 127, 127
    };
    Materials_Color[9] = COL;
  }
  {
    //int[] COL = {255, 191, 191, 191};    
    int[] COL = {
      191, 191, 191, 191
    };
    Materials_Color[10] = COL;
  }

  {
    for (int mt = 11; mt < Materials_Number; mt++) {
      int[] COL = {
        255, int(random(256)), int(random(256)), int(random(256))
      };
      Materials_Color[mt] = COL;
    }
  }
}

void SOLARCHVISION_empty_Materials_DirectArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i += 1) {
      for (int j = 0; j < 365; j += 1) {
        Materials_DirectArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DirectArea_Flags[i][j] = -1;
      }
    }
  }
}

void SOLARCHVISION_empty_Materials_DiffuseArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i += 1) {
      for (int j = 0; j < 365; j += 1) {
        Materials_DiffuseArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DiffuseArea_Flags[i][j] = -1;
      }
    }
  }
}





int SOLARCHVISION_H_Pixel = 300; //325; //340; 
int SOLARCHVISION_W_Pixel = int(SOLARCHVISION_H_Pixel * 1.5); 

float MessageSize = SOLARCHVISION_W_Pixel / 40.0;


int SOLARCHVISION_A_Pixel = int(1.5 * MessageSize); // menu bar
int SOLARCHVISION_B_Pixel = int(2.75 * MessageSize); // 3D tool bar

int SOLARCHVISION_D_Pixel = int(4.5 * MessageSize); // time bar


float WIN3D_Scale3D; 

int WIN3D_CX_View = 0;
int WIN3D_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
int WIN3D_X_View = int(1.25 * SOLARCHVISION_H_Pixel);
int WIN3D_Y_View = SOLARCHVISION_H_Pixel;
float WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);

float WIN3D_X_Coordinate = 0;
float WIN3D_Y_Coordinate = 10;
float WIN3D_Z_Coordinate = 0; 
float WIN3D_S_Coordinate = 1;

float WIN3D_RX_Coordinate = 90; //75; 
float WIN3D_RY_Coordinate = 0;
float WIN3D_RZ_Coordinate = 0; //0; //180; //135;
float WIN3D_RS_Coordinate = 5.0;

float WIN3D_Zoom = 60; // / (SOLARCHVISION_H_Pixel / 300.0);

int WIN3D_ViewType = 1; // 0: Ortho 1: Perspective

int WIN3D_Update = 1;
int WIN3D_Include = 1;









float[] WIN3D_VerticesSolarEnergy;
float[] WIN3D_VerticesSolarEffect;
int WIN3D_VerticesSolarValue_Update = 1;






int WORLD_CX_View = int(1.25 * SOLARCHVISION_H_Pixel);
int WORLD_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
int WORLD_X_View = int(1.75 * SOLARCHVISION_H_Pixel);
int WORLD_Y_View = SOLARCHVISION_H_Pixel;
float WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);

int WORLD_Update = 1;
int WORLD_Include = 1;

int WORLD_VIEW_Number = 0;
int WORLD_AutoView = 1;

String[][] WORLD_VIEW_Name;
float[][] WORLD_VIEW_BoundariesX;
float[][] WORLD_VIEW_BoundariesY; 
int[] WORLD_VIEW_GridDisplay;
String[] WORLD_VIEW_Filenames;
String[] Object2D_ImagePath;
int Object2D_PEOPLE_Files_Num = 0;
int Object2D_TREES_Files_Num = 0;

int WORLD_Viewports_num;
int WORLD_Viewport_ZOOM = 1; //1:A 2:B 3:C 4:D 5:E and 6:L <<<


int STUDY_CX_View = 0;
int STUDY_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_H_Pixel;
int STUDY_X_View = 2 * SOLARCHVISION_W_Pixel;
int STUDY_Y_View = 1 * SOLARCHVISION_H_Pixel;
float STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);
float STUDY_S_View;

int STUDY_Update = 1;
int STUDY_Include = 1;

int ROLLOUT_CX_View = 2 * SOLARCHVISION_W_Pixel;
int ROLLOUT_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
int ROLLOUT_X_View = 1 * SOLARCHVISION_H_Pixel;
int ROLLOUT_Y_View = 2 * SOLARCHVISION_H_Pixel;
float ROLLOUT_R_View = float(ROLLOUT_Y_View) / float(ROLLOUT_X_View);
float ROLLOUT_S_View = SOLARCHVISION_H_Pixel / 325.0; //1; //0.75; // ?????

int ROLLOUT_Update = 1;
int ROLLOUT_Include = 1;


int MESSAGE_CX_View = 0;
int MESSAGE_CY_View = int(1 * SOLARCHVISION_H_Pixel - 0.75 * MessageSize + 0.5 * (SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_D_Pixel));
int MESSAGE_X_View = 2 * SOLARCHVISION_W_Pixel + ROLLOUT_X_View;
int MESSAGE_Y_View = int(1.5 * MessageSize);


float WIN3D_CAM_x;
float WIN3D_CAM_y;
float WIN3D_CAM_z;
float WIN3D_CAM_fov;
float WIN3D_CAM_dist;

float WIN3D_CAM_clipNear = 0.01;
float WIN3D_CAM_clipFar = 2000000000.0;





float[][] allVertices = {
  {
    0, 0, 0
  }
};
int[][] allFaces_PNT = {
  {
    0, 0, 0
  }
};
int[][] allFaces_MTLV = {
  {
    0, 0, 0, 0
  }
}; // 0:material, 1:teselation, 2:layer, 3:visibility

float[][] allSolids_DEF = {
  {
    0, 0, 0, 2, 2, 2, 1, 1, 1, 0, 0, 0, 1
  }
};

float[][] allObject2Ds_XYZS = {
  {
    0, 0, 0, 0
  }
};
int[] allObject2Ds_MAP = {
  0
};
int allObject2Ds_num = 0; 

int[][] allGroup3Ds_Faces = {
  {
    0, 0
  }
}; // start face - end face
int[][] allGroup3Ds_Solids = {
  {
    0, 0
  }
}; // start solid - end solid
int[][] allGroup3Ds_Object2Ds = {
  {
    0, 0
  }
}; // start object2D - end object2D
int[][] allGroup3Ds_Fractals = {
  {
    0, 0
  }
}; // start fractal - end fractal
int allGroup3Ds_num = 0; 

float[][] allGroup3Ds_PivotXYZ = {
  {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
}; 
int[][] allGroup3Ds_PivotType = {
  {
    0
  }
}; // 0: no solar rotation, 1: allow X-axis solar rotation, 2: allow X-axis solar rotation, 3: allow Z-axis solar rotation 4: free solar rotation (double axis tracking)








float[][] allFractals_XYZSR = {
  {
    0, 0, 0, 0, 0
  }
};
int[] allFractals_Type = {
  0
};
int[] allFractals_DegreeMin = {
  0
};
int[] allFractals_DegreeMax = {
  0
};
int[] allFractals_Seed = {
  0
};
float[] allFractals_TrunkSize = {
  0
};
float[] allFractals_LeafSize = {
  0
};
int allFractals_num = 0; 



float[][] allSections_UVERAB = {
  {
    0, 0, 0, 0, 0, 0
  }
};
int[] allSections_Type = {
  0
};
int[] allSections_RES1 = {
  0
};
int[] allSections_RES2 = {
  0
};
int allSections_num = 0;
PImage[] allSections_SolidImpact = {
  createImage(2, 2, RGB)
};
PImage[][] allSections_SolarImpact = new PImage[1][(1 + STUDY_j_End - STUDY_j_Start)];
{
  int i = 0;
  for (int j = STUDY_j_Start; j <= STUDY_j_End; j += 1) { 
    allSections_SolarImpact[i][j] = createImage(2, 2, RGB);
  }
}


float[][] allCameras_PPPSRRRF = {
  {
    WIN3D_X_Coordinate, WIN3D_Y_Coordinate, WIN3D_Z_Coordinate, WIN3D_S_Coordinate, WIN3D_RX_Coordinate, WIN3D_RY_Coordinate, WIN3D_RZ_Coordinate, WIN3D_Zoom
  }
};
int[] allCameras_Type = {
  WIN3D_ViewType
};
int allCameras_num = 0;

int WIN3D_CurrentCamera = 0; // 0 = Free Viewport | etc.= Saved Viewport

int selected_posVector = 2; // 0:X, 1:Y, 2:Z, 3: All
int selected_rotVector = 2; // 0:X, 1:Y, 2:Z
int selected_scaleVector = 2; // 0:X, 1:Y, 2:Z, 3:All

float selected_posValue = 0;
float selected_rotValue = 0;  
float selected_scaleValue = 0; 

int selection_alignX = 0;
int selection_alignY = 0;
int selection_alignZ = 0;


int selected_displayReferencePivot = 1;

int selectedGroup3D_displayPivot = 1;
int selectedGroup3D_displayEdges = 1; //0;
int selectedGroup3D_displayBox = 1;

int selectedFace_displayEdges = 1;
int selectedFace_displayVertexCount = 0;
int selectedVertex_displayVertices = 1;


int selectedObject2D_displayEdges = 1;
int selectedFractal_displayEdges = 1;
int selectedSolid_displayEdges = 1;
int selectedSection_displayEdges = 1;
int selectedCamera_displayEdges = 1;
int selectedLandPoint_displayPoints = 1;

int[] selectedLandPoint_numbers = {
  0
};
int[] selectedCamera_numbers = {
  0
};
int[] selectedSection_numbers = {
  0
};
int[] selectedSolid_numbers = {
  0
};
int[] selectedFractal_numbers = {
  0
};
int[] selectedObject2D_numbers = {
  0
};
int[] selectedGroup3D_numbers = {
  0
};
int[] selectedFace_numbers = {
  0
};
int[] selectedVertex_numbers = {
  0
};

float softSelection_Power = 1;
float softSelection_Radius = 2; // 2 = 2m


int addToLastGroup3D = 0;


int LoadButton_DefaultModels = 0; // internal

int addNewSelectionToPreviousSelection = 0; // internal










void setup () {

  size(1200, 696, P2D);
  //size(2 * SOLARCHVISION_W_Pixel + ROLLOUT_X_View, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_D_Pixel, P2D);


  SOLARCHVISION_draw_frameIcon();

  TIME_Date = (286 + SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day)) % 365; // 0 presents March 21, 286 presents Jan.01, 345 presents March.01
  //if (TIME_Hour >= 12) TIME_Date += 0.5;   

  SOLARCHVISION_empty_Materials_DirectArea();
  SOLARCHVISION_empty_Materials_DiffuseArea();

  WIN3D_VerticesSolarEnergy = new float [1];
  WIN3D_VerticesSolarEffect = new float [1];
  WIN3D_VerticesSolarEnergy[0] = FLOAT_undefined;
  WIN3D_VerticesSolarEffect[0] = FLOAT_undefined;



  WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);

  WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);  

  STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);


  Load_EARTH_IMAGES(); // <<<<<<<<<<<< should move it below
  Load_TROPO_IMAGES(); // <<<<<<<<<<<< should move it below

  MOON_IMAGE_Map = loadImage(MOON_IMAGE_Filename);
  STAR_IMAGE_Map = loadImage(STAR_IMAGE_Filename);

  SOLARCHVISION_LoadDefaultFontStyle();  

  frameRate(24);

  loop();
}

void SOLARCHVISION_draw_frameIcon () {
  int frame_icon_size = 64;

  PGraphics frame_icon = createGraphics(frame_icon_size, frame_icon_size);  

  frame_icon.beginDraw();

  //frame_icon.image(loadImage("C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Icon/s-icon.png"), 0, 0 );

  frame_icon.background(0);
  //frame_icon.background(63,63,255,255);

  //frame_icon.fill(255,127);
  frame_icon.fill(255, 255, 0, 127);

  frame_icon.textAlign(CENTER, CENTER);
  frame_icon.textSize(1.0 * frame_icon_size);
  frame_icon.text("S", 0.20 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("A", 0.50 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("V", 0.80 * frame_icon_size, 0.4 * frame_icon_size);

  frame_icon.endDraw();
  frame.setIconImage(frame_icon.image);  

  frame.setTitle("SOLARCHVISION-2016");
}



void SOLARCHVISION_update_station (int Step) {

  if ((Step == 0) || (Step == 1)) {

    rebuild_SolarProjection_array = 1;
    rebuild_SolarImpactImage_array = 1;
    rebuild_WindRoseImage_array = 1;    

    WIN3D_VerticesSolarValue_Update = 1;

    WORLD_Update = 1;
    WIN3D_Update = 1; 
    STUDY_Update = 1;    

    LocationName = Defined_Stations[STATION_Number][0];
    LocationProvince = Defined_Stations[STATION_Number][1];

    LocationLatitude = float(Defined_Stations[STATION_Number][3]);
    LocationLongitude = float(Defined_Stations[STATION_Number][4]);
    LocationTimeZone = float(Defined_Stations[STATION_Number][5]);
    LocationElevation = float(Defined_Stations[STATION_Number][6]);
    LocationDeltaNoon = (LocationTimeZone - LocationLongitude) / 15.0;

    WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);

    TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
  }

  if ((Step == 0) || (Step == 2)) SOLARCHVISION_try_update_CLIMATE_TMYEPW();

  if ((Step == 0) || (Step == 3)) SOLARCHVISION_try_update_CLIMATE_CWEEDS();  
  
  if ((Step == 0) || (Step == 4)) SOLARCHVISION_try_update_CLIMATE_CLMREC();

  if ((Step == 0) || (Step == 5)) SOLARCHVISION_try_update_RECENT_OBSERVED();

  if ((Step == 0) || (Step == 6)) SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

  if ((Step == 0) || (Step == 7)) SOLARCHVISION_load_LandMesh(LocationName);

  //if ((Step == 0) || (Step == 8)) SOLARCHVISION_delete_Fractals();

  if ((Step == 0) || (Step == 9)) SOLARCHVISION_delete_Object2Ds();

  if ((Step == 0) || (Step == 10)) {

    SOLARCHVISION_add_Object2Ds_onLand(1); // 1 = people

    SOLARCHVISION_add_Object2Ds_onLand(2); // 2 = 2D trees
  }
}

void SOLARCHVISION_update_models (int Step) {

  if ((Step == 0) || (Step == 1)) SOLARCHVISION_delete_Group3Ds(); //not deleting all
  if ((Step == 0) || (Step == 2)) SOLARCHVISION_add_Model_Main();
}


int Last_initializationStep = 1000;
int InitializationStep = 0;


void draw () {

  //println("frameCount:", frameCount);



  if (frameCount == 1) {

    background(223);

    SOLARCHVISION_update_folders();

    float cr;

    cr = SOLARCHVISION_W_Pixel / 4.0;
    PImage SOLARCHVISION_logo = loadImage(BackgroundFolder + "/" + "SOLARCHVISION.jpg");
    imageMode(CENTER);
    image(SOLARCHVISION_logo, 0.5 * width, 0.5 * height - 0.75 * MessageSize - cr + (0.075 * cr), 3.05 * cr, 3.05 * cr);
    imageMode(CORNER);

    strokeWeight(1);
    stroke(0);
    noFill();


    ellipseMode(CENTER);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);
    strokeWeight(1);
    stroke(255);
    noFill();    
    SOLARCHVISION_draw_logo(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(1);
    stroke(127);
    noFill();  
    //SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 0);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);    
    strokeWeight(1);
    stroke(255);
    noFill();  
    SOLARCHVISION_draw_logo(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, -1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);

    stroke(255);
    fill(255);
    textAlign(CENTER, CENTER); 
    textSize(3 * MessageSize);
    text("SOLARCHVISION model integrations 2016", 0.5 * width, 0.05 * height); 

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER); 
    textSize(1.5 * MessageSize);
    text("Raz, Mehr, Mehraz solarch studio\n1998-2016\nAuthor: Mojtaba Samimi\nwww.solarchvision.com", 0.5 * width, 0.75 * height);

    textAlign(CENTER, CENTER); 
    textSize(MessageSize);
  } else if (frameCount == 2) {
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_ListWorldImages", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 3) {
    SOLARCHVISION_ListWorldImages();
    SOLARCHVISION_Load_WorldViewImage(WORLD_VIEW_Number); // to load the globe image into memory

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_LoadObject2DImages", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 4) {
    SOLARCHVISION_LoadObject2DImages();

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_Calendar", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 5) {
    SOLARCHVISION_Calendar(); 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getSWOB_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 6) {
    SOLARCHVISION_getSWOB_Coordinates(); 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getNAEFS_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 7) {
    SOLARCHVISION_getNAEFS_Coordinates(); 
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getCWEEDS_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 8) {
    SOLARCHVISION_getCWEEDS_Coordinates();  
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getCLMREC_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 9) {
    SOLARCHVISION_getCLMREC_Coordinates();  
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_getTMYEPW_Coordinates", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 10) {
    SOLARCHVISION_getTMYEPW_Coordinates();  
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_update_date", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 11) {
    SOLARCHVISION_update_date(); 
    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_update_station(start)", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 12) {
    SOLARCHVISION_update_station(1);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_CLIMATE_TMYEPW", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 13) {
    SOLARCHVISION_update_station(2);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_CLIMATE_CWEEDS", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 14) {
    SOLARCHVISION_update_station(3);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_CLIMATE_CLMREC", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 15) {
    SOLARCHVISION_update_station(4);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_RECENT_OBSERVED", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 16) {
    SOLARCHVISION_update_station(5);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_try_update_FORECAST_ENSEMBLE", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 17) {
    SOLARCHVISION_update_station(6);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_load_LandMesh", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 18) {
    SOLARCHVISION_update_station(7);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_delete_Fractals", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 19) {
    SOLARCHVISION_update_station(8);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_delete_Object2Ds", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 20) {
    SOLARCHVISION_update_station(9);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_add_Object2Ds_onLand", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 21) {
    SOLARCHVISION_update_station(10);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_delete_Group3Ds", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 22) {
    SOLARCHVISION_update_models(1);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_add_Model_Main", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 23) {
    SOLARCHVISION_update_models(2);

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("SOLARCHVISION_build_SkySphere", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);
  } else if (frameCount == 24) {

    SOLARCHVISION_build_SkySphere(1); //1 - 3 

    stroke(0);
    fill(0);
    rect(MESSAGE_CX_View, MESSAGE_CY_View, MESSAGE_X_View, MESSAGE_Y_View); 

    stroke(255);
    fill(255);
    text("Please wait while integrating the models.", MESSAGE_CX_View + 0.5 * MESSAGE_X_View, MESSAGE_CY_View + 0.5 * MESSAGE_Y_View);

    MESSAGE_X_View = 2 * SOLARCHVISION_W_Pixel;

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;

    InitializationStep = frameCount; 
    Last_initializationStep = frameCount;
  } else {

    if (ROLLOUT_Include == 1) {
      if (ROLLOUT_Update == 1) {
        ROLLOUT_Update = 0;

        pre_SampleYear_Start = SampleYear_Start;
        pre_SampleYear_End = SampleYear_End;
        pre_SampleMember_Start = SampleMember_Start;
        pre_SampleMember_End = SampleMember_End;
        pre_SampleStation_Start = SampleStation_Start; 
        pre_SampleStation_End = SampleStation_End;
        pre_STUDY_JoinDays = STUDY_JoinDays;
        pre_STUDY_i_Start = STUDY_i_Start;
        pre_STUDY_i_End = STUDY_i_End;        
        pre_STUDY_j_End = STUDY_j_End;
        pre_IMPACTS_DisplayDay = IMPACTS_DisplayDay;
        pre_STUDY_Setup = STUDY_Setup;
        pre_IMPACTS_DataSource = IMPACTS_DataSource;
        pre_STATION_Number = STATION_Number;
        pre_STATION_Selected = STATION_Selected;
        pre_TIME_Year = TIME_Year;
        pre_TIME_Month = TIME_Month;
        pre_TIME_Day = TIME_Day;
        pre_TIME_Date = TIME_Date;
        pre_TIME_Hour = TIME_Hour;
        pre_CLIMATIC_SolarForecast = CLIMATIC_SolarForecast;
        pre_CLIMATIC_WeatherForecast = CLIMATIC_WeatherForecast;

        pre_LoadButton_CLIMATE_TMYEPW = LoadButton_CLIMATE_TMYEPW;
        pre_LoadButton_CLIMATE_CWEEDS = LoadButton_CLIMATE_CWEEDS;
        pre_LoadButton_CLIMATE_CLMREC = LoadButton_CLIMATE_CLMREC;
        pre_LoadButton_FORECAST_ENSEMBLE = LoadButton_FORECAST_ENSEMBLE;
        pre_LoadButton_RECENT_OBSERVED = LoadButton_RECENT_OBSERVED;       

        pre_LocationLatitude = LocationLatitude;
        pre_LocationLongitude = LocationLongitude;

        pre_WORLD_AutoView = WORLD_AutoView;

        pre_LoadButton_LandMesh = LoadButton_LandMesh;
        pre_LoadButton_UrbanMesh = LoadButton_UrbanMesh;

        pre_SOLID_Pallet_CLR = SOLID_Pallet_CLR;
        pre_SOLID_Pallet_DIR = SOLID_Pallet_DIR; 
        pre_SOLID_Pallet_MLT = SOLID_Pallet_MLT;         

        pre_CreateInput_powAll = CreateInput_powAll;

        pre_SolidImpact_scale_U = SolidImpact_scale_U;
        pre_SolidImpact_scale_V = SolidImpact_scale_V;

        pre_SolidImpact_offset_U = SolidImpact_offset_U;
        pre_SolidImpact_offset_V = SolidImpact_offset_V;

        pre_SolidImpact_Grade = SolidImpact_Grade;
        pre_SolidImpact_Power = SolidImpact_Power;
        pre_SolidImpact_Rotation[SolidImpact_sectionType] = SolidImpact_Rotation[SolidImpact_sectionType];
        pre_SolidImpact_Elevation[SolidImpact_sectionType] = SolidImpact_Elevation[SolidImpact_sectionType];

        pre_SolidImpact_Wspd = SolidImpact_WindSpeed; 
        pre_SolidImpact_Wdir = SolidImpact_WindDirection;

        pre_Process_subDivisions = Process_subDivisions;

        pre_Display_SolidImpact_Points = Display_SolidImpact_Points;
        pre_Display_SolidImpact_Lines = Display_SolidImpact_Lines;

        pre_Display_WindFlow = Display_WindFlow;

        pre_selectedFractal_numbers_lastItem = selectedFractal_numbers[selectedFractal_numbers.length - 1];
        pre_selectedObject2D_numbers_lastItem = selectedObject2D_numbers[selectedObject2D_numbers.length - 1];
        pre_selectedGroup3D_numbers_lastItem = selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1];
        pre_selectedFace_numbers_lastItem = selectedFace_numbers[selectedFace_numbers.length - 1];
        pre_selectedVertex_numbers_lastItem = selectedVertex_numbers[selectedVertex_numbers.length - 1];

        pre_selectedSolid_displayEdges = selectedSolid_displayEdges;

        pre_selectedSection_displayEdges = selectedSection_displayEdges;

        pre_selectedCamera_displayEdges = selectedCamera_displayEdges;

        pre_selectedLandPoint_displayPoints = selectedLandPoint_displayPoints;

        pre_selectedFractal_displayEdges = selectedFractal_displayEdges;
        pre_selectedObject2D_displayEdges = selectedObject2D_displayEdges;
        pre_MODEL3D_DisplayEdges = MODEL3D_DisplayEdges;
        pre_MODEL3D_DisplayNormals = MODEL3D_DisplayNormals;

        pre_softSelection_Power = softSelection_Power;
        pre_softSelection_Radius = softSelection_Radius;


        pre_selected_posValue = selected_posValue;
        pre_selected_rotValue = selected_rotValue;
        pre_selected_scaleValue = selected_scaleValue;        

        pre_selection_alignX = selection_alignX;
        pre_selection_alignY = selection_alignY;
        pre_selection_alignZ = selection_alignZ;

        pre_selected_displayReferencePivot = selected_displayReferencePivot;

        pre_selectedGroup3D_displayPivot = selectedGroup3D_displayPivot;
        pre_selectedGroup3D_displayEdges = selectedGroup3D_displayEdges;
        pre_selectedGroup3D_displayBox = selectedGroup3D_displayBox;        

        pre_selectedFace_displayEdges = selectedFace_displayEdges;
        pre_selectedFace_displayVertexCount = selectedFace_displayVertexCount;
        pre_selectedVertex_displayVertices = selectedVertex_displayVertices;

        pre_WIN3D_CurrentCamera = WIN3D_CurrentCamera; 

        pre_WIN3D_FacesShade = WIN3D_FacesShade;

        pre_MODEL3D_Tessellation = MODEL3D_Tessellation;


        pre_LoadButton_DefaultModels = LoadButton_DefaultModels;

        pre_STUDY_ImpactLayer = STUDY_ImpactLayer;

        pre_H_Layer_Option = H_Layer_Option;
        pre_F_Layer_Option = F_Layer_Option;
        pre_O_Layer_Option = O_Layer_Option;

        pre_Develop_Option = Develop_Option;

        pre_STUDY_CurrentLayer = STUDY_CurrentLayer;

        pre_STUDY_SkyScenario = STUDY_skyScenario_Active;

        pre_STUDY_PlotImpacts = STUDY_PlotImpacts;

        SOLARCHVISION_draw_ROLLOUT();

        if (abs(pre_STUDY_PlotImpacts) % 2 != abs(STUDY_PlotImpacts) % 2) {
          rebuild_SolarProjection_array = 1;
        }

        if (pre_SampleYear_Start != SampleYear_Start) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }            
        if (pre_SampleYear_End != SampleYear_End) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }            

        if (pre_SampleMember_Start != SampleMember_Start) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }  

        if (pre_SampleMember_End != SampleMember_End) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }  

        if (pre_SampleStation_Start != SampleStation_Start) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }  

        if (pre_SampleStation_End != SampleStation_End) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }  

        if (pre_STUDY_JoinDays != STUDY_JoinDays) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }            

        if (pre_STUDY_i_Start != STUDY_i_Start) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }      

        if (pre_STUDY_i_End != STUDY_i_End) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }      

        if (pre_STUDY_j_End != STUDY_j_End) {
          SOLARCHVISION_UI_BAR_d_Update = 1;

          rebuild_SolarProjection_array = 1;
          rebuild_SolarImpactImage_array = 1;
          rebuild_WindRoseImage_array = 1;      

          SOLARCHVISION_resize_allSections_Solar_Impact_Array();
        }

        if (pre_IMPACTS_DisplayDay != IMPACTS_DisplayDay) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }

        if (pre_TIME_Date != TIME_Date) {
          SOLARCHVISION_UI_BAR_d_Update = 1;

          SOLARCHVISION_update_date();
          SOLARCHVISION_draw_ROLLOUT();
        }

        if ((pre_TIME_Year != TIME_Year) || (pre_TIME_Month != TIME_Month) || (pre_TIME_Day != TIME_Day) || (pre_TIME_Hour != TIME_Hour) || (pre_CLIMATIC_SolarForecast != CLIMATIC_SolarForecast) || (pre_CLIMATIC_WeatherForecast != CLIMATIC_WeatherForecast)) {
          SOLARCHVISION_UI_BAR_d_Update = 1;

          TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
          TIME_Hour = int(24 * (TIME_Date - int(TIME_Date)));
          TIME_Date = (TIME_Hour / 24.0) + (286 + SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day)) % 365;
          println("DATE:", TIME_Date, "\tHOUR:", TIME_Hour);
          SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

          SOLARCHVISION_draw_ROLLOUT();
        }

        if (pre_STATION_Number != STATION_Number) SOLARCHVISION_update_station(0);

        if (pre_STATION_Selected != STATION_Selected) ROLLOUT_Update = 1;

        if (LoadButton_STATION == 1) {         
          STATION_Number = STATION_Selected;
          SOLARCHVISION_update_station(0);
          LoadButton_STATION = 0;
        }

        if (pre_LoadButton_CLIMATE_TMYEPW != LoadButton_CLIMATE_TMYEPW) SOLARCHVISION_try_update_CLIMATE_TMYEPW();
        if (pre_LoadButton_CLIMATE_CWEEDS != LoadButton_CLIMATE_CWEEDS) SOLARCHVISION_try_update_CLIMATE_CWEEDS();
        if (pre_LoadButton_CLIMATE_CLMREC != LoadButton_CLIMATE_CLMREC) SOLARCHVISION_try_update_CLIMATE_CLMREC();
        if (pre_LoadButton_RECENT_OBSERVED != LoadButton_RECENT_OBSERVED) SOLARCHVISION_try_update_RECENT_OBSERVED();
        if (pre_LoadButton_FORECAST_ENSEMBLE != LoadButton_FORECAST_ENSEMBLE) SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

        if (pre_WORLD_AutoView != WORLD_AutoView) {
          WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);
        }



        if ((pre_LocationLatitude != LocationLatitude) || (pre_LocationLongitude != LocationLongitude)) {

          WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);
          WORLD_Update = 1;
        }


        if (Download_LAND_MESH != 0) {
          SOLARCHVISION_download_LandMesh();
          WIN3D_Update = 1;
          ROLLOUT_Update = 1;
        }

        if (pre_LoadButton_LandMesh != LoadButton_LandMesh) {
          SOLARCHVISION_load_LandMesh(LocationName);
          WIN3D_Update = 1;
        }


        if (pre_LoadButton_UrbanMesh != LoadButton_UrbanMesh) {
          SOLARCHVISION_add_urban();

          WIN3D_Update = 1;
        }


        if (pre_selectedCamera_displayEdges != selectedCamera_displayEdges) {
          WIN3D_Update = 1;
        }

        if (pre_selectedSection_displayEdges != selectedSection_displayEdges) {
          WIN3D_Update = 1;
        }         

        if (pre_selectedSolid_displayEdges != selectedSolid_displayEdges) {
          WIN3D_Update = 1;
        }  

        if (pre_selectedLandPoint_displayPoints != selectedLandPoint_displayPoints) {
          WIN3D_Update = 1;
        }          


        if (pre_selectedFractal_displayEdges != selectedFractal_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedObject2D_displayEdges != selectedObject2D_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFractal_numbers_lastItem != selectedFractal_numbers[selectedFractal_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_BoundingBox 19");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }

        if (pre_selectedObject2D_numbers_lastItem != selectedObject2D_numbers[selectedObject2D_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_BoundingBox 20");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }

        if (pre_selectedGroup3D_numbers_lastItem != selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_BoundingBox 21");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }

        if (pre_selectedFace_numbers_lastItem != selectedFace_numbers[selectedFace_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_BoundingBox 22");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }

        if (pre_selectedVertex_numbers_lastItem != selectedVertex_numbers[selectedVertex_numbers.length - 1]) {
          println("SOLARCHVISION_calculate_selection_BoundingBox 23");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }        



        if (pre_softSelection_Power != softSelection_Power) {    
          SOLARCHVISION_convert_Vertex_to_softSelection();
          WIN3D_Update = 1;
        }  

        if (pre_softSelection_Radius != softSelection_Radius) {
          SOLARCHVISION_convert_Vertex_to_softSelection();
          WIN3D_Update = 1;
        }  


        if (pre_selection_alignX != selection_alignX) {    
          println("SOLARCHVISION_calculate_selection_BoundingBox 24");    
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }        

        if (pre_selection_alignY != selection_alignY) {   
          println("SOLARCHVISION_calculate_selection_BoundingBox 25");     
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }      

        if (pre_selection_alignZ != selection_alignZ) {        
          println("SOLARCHVISION_calculate_selection_BoundingBox 26");
          SOLARCHVISION_calculate_selection_BoundingBox();
          WIN3D_Update = 1;
        }      

        if (pre_selected_posValue != selected_posValue) {

          float d = selected_posValue - pre_selected_posValue;

          float dx = d;
          float dy = d;
          float dz = d;

          int the_Vector = selected_posVector;

          if (the_Vector == 0) {
            dy = 0; 
            dz = 0;
          }  
          if (the_Vector == 1) {
            dz = 0; 
            dx = 0;
          }  
          if (the_Vector == 2) {
            dx = 0; 
            dy = 0;
          }            

          SOLARCHVISION_move_Selection(dx, dy, dz);
          WIN3D_Update = 1;
        }
        if (pre_selected_rotValue != selected_rotValue) {

          float[] P = SOLARCHVISION_getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float r = selected_rotValue - pre_selected_rotValue;

          int the_Vector = selected_rotVector;

          SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);
          WIN3D_Update = 1;
        }
        if (pre_selected_scaleValue != selected_scaleValue) {

          float[] P = SOLARCHVISION_getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float s = pow(2.0, selected_scaleValue - pre_selected_scaleValue);

          float sx = s;
          float sy = s;
          float sz = s;

          int the_Vector = selected_scaleVector;

          if (the_Vector == 0) {
            sy = 1; 
            sz = 1;
          }  
          if (the_Vector == 1) {
            sz = 1; 
            sx = 1;
          }  
          if (the_Vector == 2) {
            sx = 1; 
            sy = 1;
          }           

          SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);
          WIN3D_Update = 1;
        }        


        if (pre_selected_displayReferencePivot != selected_displayReferencePivot) {
          WIN3D_Update = 1;
        }

        if (pre_selectedGroup3D_displayPivot != selectedGroup3D_displayPivot) {
          WIN3D_Update = 1;
        }             

        if (pre_selectedGroup3D_displayEdges != selectedGroup3D_displayEdges) {
          WIN3D_Update = 1;
        }

        if (pre_selectedGroup3D_displayBox != selectedGroup3D_displayBox) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFace_displayEdges != selectedFace_displayEdges) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedFace_displayVertexCount != selectedFace_displayVertexCount) {
          WIN3D_Update = 1;
        }     

        if (pre_selectedVertex_displayVertices != selectedVertex_displayVertices) {
          WIN3D_Update = 1;
        }     



        if (pre_WIN3D_CurrentCamera != WIN3D_CurrentCamera) {
          SOLARCHVISION_apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();
          WIN3D_Update = 1;
        }


        if (pre_WIN3D_FacesShade != WIN3D_FacesShade) {
          WIN3D_Update = 1;
        }             

        if (pre_MODEL3D_Tessellation != MODEL3D_Tessellation) {
          WIN3D_VerticesSolarValue_Update = 1;
        }


        if (ERASE_Fractals == 1) {
          SOLARCHVISION_delete_Fractals();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Fractals = 0;
        }      

        if (ERASE_Object2Ds == 1) {
          SOLARCHVISION_delete_Object2Ds();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Object2Ds = 0;
        }        

        if (ERASE_Group3Ds == 1) {

          SOLARCHVISION_delete_Group3Ds();

          SOLARCHVISION_calculate_SolidImpact_selectedSections();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Group3Ds = 0;
        }

        if (ERASE_Solids == 1) {
          SOLARCHVISION_delete_Solids();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Solids = 0;
        }          

        if (ERASE_Sections == 1) {
          SOLARCHVISION_delete_Sections();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Sections = 0;
        }       

        if (ERASE_Cameras == 1) {
          SOLARCHVISION_delete_Cameras();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Cameras = 0;
        }    

        if (ERASE_Faces == 1) {
          SOLARCHVISION_delete_Faces();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_Faces = 0;
        }             

        if (ERASE_All == 1) {
          SOLARCHVISION_delete_All();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;

          ERASE_All = 0;
        }  

        if (pre_LoadButton_DefaultModels != LoadButton_DefaultModels) {

          SOLARCHVISION_delete_All();

          SOLARCHVISION_add_DefaultModel(LoadButton_DefaultModels);

          SOLARCHVISION_calculate_SolidImpact_selectedSections();

          WIN3D_Update = 1;

          ROLLOUT_Update = 1;
        }


        if (pre_CreateInput_powAll != CreateInput_powAll) {
          CreateInput_powX = CreateInput_powAll;
          CreateInput_powY = CreateInput_powAll;
          CreateInput_powZ = CreateInput_powAll;

          ROLLOUT_Update = 1;
        }


        if (pre_SOLID_Pallet_CLR != SOLID_Pallet_CLR) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SOLID_Pallet_DIR != SOLID_Pallet_DIR) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SOLID_Pallet_MLT != SOLID_Pallet_MLT) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }

        if (pre_SolidImpact_Grade != SolidImpact_Grade) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_Power != SolidImpact_Power) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_Rotation[SolidImpact_sectionType] != SolidImpact_Rotation[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_Elevation[SolidImpact_sectionType] != SolidImpact_Elevation[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }

        if (pre_SolidImpact_scale_U[SolidImpact_sectionType] != SolidImpact_scale_U[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_scale_V[SolidImpact_sectionType] != SolidImpact_scale_V[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }

        if (pre_SolidImpact_offset_U[SolidImpact_sectionType] != SolidImpact_offset_U[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_offset_V[SolidImpact_sectionType] != SolidImpact_offset_V[SolidImpact_sectionType]) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }



        if (pre_SolidImpact_Wspd != SolidImpact_WindSpeed) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }
        if (pre_SolidImpact_Wdir != SolidImpact_WindDirection) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }


        if (pre_Process_subDivisions != Process_subDivisions) {
          SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
          WIN3D_Update = 1;
        }

        if (pre_Display_SolidImpact_Points != Display_SolidImpact_Points) WIN3D_Update = 1;
        if (pre_Display_SolidImpact_Lines != Display_SolidImpact_Lines) WIN3D_Update = 1;

        if (pre_MODEL3D_DisplayEdges != MODEL3D_DisplayEdges) WIN3D_Update = 1;
        if (pre_MODEL3D_DisplayNormals != MODEL3D_DisplayNormals) WIN3D_Update = 1;

        if (pre_Display_WindFlow != Display_WindFlow) WIN3D_Update = 1;

        if (Download_AERIAL != 0) {
          SOLARCHVISION_try_update_AERIAL(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

          Download_AERIAL = 0;
          ROLLOUT_Update = 1;
        }


        if (STUDY_Setup != pre_STUDY_Setup) {
          STUDY_Impacts_Update = 1;
          SOLARCHVISION_UI_BAR_d_Update = 0;
        }

        if (IMPACTS_DataSource != pre_IMPACTS_DataSource) {
          STUDY_Impacts_Update = 1;
          SOLARCHVISION_UI_BAR_d_Update = 0;
        }
      }
    }



    if (FRAME_record_AUTO == 1) {
      if (STUDY_Update == 1) FRAME_record_JPG = 1;
      if (WIN3D_Update == 1) FRAME_record_JPG = 1;
      if (WORLD_Update == 1) FRAME_record_JPG = 1;
      //if (SOLARCHVISION_UI_BAR_a_Update == 1) FRAME_record_JPG = 1;
      //if (SOLARCHVISION_UI_BAR_b_Update == 1) FRAME_record_JPG = 1;
      //if (SOLARCHVISION_UI_BAR_d_Update == 1) FRAME_record_JPG = 1;
    }




    int Illustrations_Animate = 0;

    //if ((STUDY_Update == 0) && (WIN3D_Update == 0)) {
    if (STUDY_Update == 0) {
      //Illustrations_Animate = 1;
    }

    if (STUDY_Include == 1) {
      if (STUDY_Update == 1) {

        SOLARCHVISION_draw_STUDY();
      }
    }
    STUDY_Update = 0;

    if (STUDY_record_PDF == 0) {
      /*      
       if (Illustrations_Animate != 0) {
       GRIB2_Layer = GRIB2_Layer_Start;
       
       GRIB2_Hour = GRIB2_Hour_Start;
       
       int d = (GRIB2_Hour_End - GRIB2_Hour_Start) / GRIB2_Hour_Step;      
       
       if (d > 1) {
       
       GRIB2_Hour += GRIB2_Hour_Step * (frameCount % d);
       
       if (GRIB2_Hour > GRIB2_Hour_End) GRIB2_Hour = GRIB2_Hour_Start;
       
       WORLD_Update = 1;
       WIN3D_Update = 1; // <<<<<<<<<<<
       }
       }
       */

      if (WORLD_Include == 1) {
        if (WORLD_Update == 1) {

          SOLARCHVISION_draw_WORLD();
        }
      }

      if (WORLD_record_PDF == 0) {      
        if (WIN3D_Include == 1) {
          if (WIN3D_Update == 1) {

            SOLARCHVISION_draw_WIN3D();
          }
        }

        if (SOLARCHVISION_UI_BAR_a_Update == 1) {
          SOLARCHVISION_draw_window_BAR_a();
        }

        if (SOLARCHVISION_UI_BAR_b_Update == 1) {
          SOLARCHVISION_draw_window_BAR_b();
        }

        if (SOLARCHVISION_UI_BAR_d_Update == 1) {
          SOLARCHVISION_draw_window_BAR_d();
        }    



        if (FRAME_record_JPG == 1) {
          SOLARCHVISION_RecordFrame();
          FRAME_record_JPG = 0;
        }
      } else {
        WORLD_record_PDF = 0;
      }
    } else {
      STUDY_record_PDF = 0;
    }


    //WIN3D_Update = 0;
    //WORLD_Update = 0;
    //STUDY_Update = 0;

    //noLoop(); // <<<<<<<<<<<<
  }
} 

float WIN3D_refScale = 250;

PGraphics WIN3D_Diagrams;

void SOLARCHVISION_draw_WIN3D () {

  if (WIN3D_Update == 1) {

    if (WIN3D_FacesShade == Shade_Global_Solar) {
      if (rebuild_SolarProjection_array != 0) {
        SOLARCHVISION_SolarProjection();
      }
    }     

    if (WIN3D_record_JPG == 1) WIN3D_ImageScale = 2; //3;
    else WIN3D_ImageScale = 1;

    //////////////////////////////////
    WIN3D_X_View *= WIN3D_ImageScale;
    WIN3D_Y_View *= WIN3D_ImageScale;
    //////////////////////////////////

    if (WIN3D_ImageScale != 1) {
      println("IMG:high-res");
      WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);
    }  

    WIN3D_Diagrams.beginDraw();  

    WIN3D_Scale3D = WIN3D_Y_View / WIN3D_refScale; // fits field of view to window's height

    WIN3D_Diagrams.background(233);

    WIN3D_Diagrams.fill(127);
    WIN3D_Diagrams.strokeWeight(0);

    WIN3D_Diagrams.pushMatrix();

    WIN3D_Diagrams.hint(ENABLE_DEPTH_TEST);

    SOLARCHVISION_record_last3DViewport();

    SOLARCHVISION_transform_3DViewport();

    SOLARCHVISION_put_3DViewport();

    SOLARCHVISION_draw_SKY3D();

    SOLARCHVISION_draw_SunPattern3D(0, 0, 0, 0.975 * SKY3D_scale);

    SOLARCHVISION_draw_SunPath3D(0, 0, 0, 0.975 * SKY3D_scale, LocationLatitude);

    SOLARCHVISION_draw_SolarRotation(0, 0, 0, (150000.0 * 1000000) * OBJECTS_scale, LocationLatitude);

    SOLARCHVISION_draw_STAR3D();

    SOLARCHVISION_draw_MOON3D();

    SOLARCHVISION_draw_EARTH3D();

    SOLARCHVISION_draw_TROPO3D();

    SOLARCHVISION_draw_land(3);

    SOLARCHVISION_draw_Group3Ds();

    SOLARCHVISION_draw_Fractals();

    SOLARCHVISION_draw_WindRoseImage();

    SOLARCHVISION_draw_Sections();

    SOLARCHVISION_draw_Cameras();

    SOLARCHVISION_draw_Solids();

    SOLARCHVISION_draw_SolidImpact_lines();

    SOLARCHVISION_draw_SolidImpact_points();

    SOLARCHVISION_draw_Object2Ds();  

    SOLARCHVISION_draw_WindFlow();




    WIN3D_Diagrams.sphereDetail(6, 4);

    for (int n = 0; n < AERIAL_num; n += 1) {

      if ((AERIAL_Center_Longitude == LocationLongitude) && (AERIAL_Center_Latitude == LocationLatitude)) {

        float _tgl = AERIAL_Locations[n][2];
        float _lat = AERIAL_Locations[n][1];
        float _lon = AERIAL_Locations[n][0]; 
        if (_lon > 180) _lon -= 360; // << important!

        double du = ((_lon - AERIAL_Center_Longitude) / 180.0) * (PI * DOUBLE_r_Earth);
        double dv = ((_lat - AERIAL_Center_Latitude) / 180.0) * (PI * DOUBLE_r_Earth);

        float x = 0.1 * (float) du * cos_ang((float) AERIAL_Center_Latitude); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float y = 0.1 * (float) dv;                                           // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float z = _tgl - HeightAboveGround;

        if (AERIAL_graphOption == 0) {
          //-----------------------------
          int PAL_TYPE = 6; //12; 
          int PAL_DIR = -1;
          float PAL_Multiplier = 1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o += 1) {

            float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb][n][o];

            if (_val < 0.9 * FLOAT_undefined) {

              float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;

              float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);             

              WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
              WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);           
              //WIN3D_Diagrams.noFill();

              WIN3D_Diagrams.strokeWeight(0); // 2; <<<<<<<<<

              float R = 5;
              /*         
               WIN3D_Diagrams.beginShape();
               for (float teta = 0; teta < 360; teta += 360.0 / 6.0) {
               WIN3D_Diagrams.vertex((x + R * cos_ang(teta)) * OBJECTS_scale * WIN3D_Scale3D, (y + R * sin_ang(teta)) * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
               }
               WIN3D_Diagrams.endShape(CLOSE);
               */
              WIN3D_Diagrams.pushMatrix();
              WIN3D_Diagrams.translate(x * OBJECTS_scale * WIN3D_Scale3D, y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
              WIN3D_Diagrams.sphere(R);
              WIN3D_Diagrams.popMatrix();
            }
          }
        }

        if (AERIAL_graphOption == 1) {

          //-----------------------------
          int PAL_TYPE = 1;//12; 
          int PAL_DIR = 1;//-1;
          float PAL_Multiplier = 0.1;//1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o += 1) {

            //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb][n][o];
            float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o];

            if (_val < 0.9 * FLOAT_undefined) {

              float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir][n][o];
              float D_teta = 15; 
              float R = 5.0 * AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o];

              float R_in = 0.0 * R; 
              float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta)));
              float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta)));
              float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta)));
              float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta)));                      

              float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta)));
              float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta)));
              float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta)));
              float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta)));          

              //float ox = -0.5 * (R * cos_ang(90 - teta));
              //float oy = -0.5 * (R * -sin_ang(90 - teta));
              //float ox = -1 * (R * cos_ang(90 - teta));
              //float oy = -1 * (R * -sin_ang(90 - teta));
              float ox = -2 * (R * cos_ang(90 - teta)) / 3.0;
              float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0;            

              float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;

              float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);             

              WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
              //WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);           
              WIN3D_Diagrams.noFill();

              WIN3D_Diagrams.strokeWeight(2); // 0; <<<<<<<<<

              WIN3D_Diagrams.beginShape();
              WIN3D_Diagrams.vertex((x + x1 + ox) * OBJECTS_scale * WIN3D_Scale3D, (y + y1 + oy) * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
              WIN3D_Diagrams.vertex((x + x2 + ox) * OBJECTS_scale * WIN3D_Scale3D, (y + y2 + oy) * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
              WIN3D_Diagrams.vertex((x + x3 + ox) * OBJECTS_scale * WIN3D_Scale3D, (y + y3 + oy) * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
              WIN3D_Diagrams.vertex((x + x4 + ox) * OBJECTS_scale * WIN3D_Scale3D, (y + y4 + oy) * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
              WIN3D_Diagrams.endShape(CLOSE);
            }
          }
        }
      }
    }   

    WIN3D_Diagrams.hint(DISABLE_DEPTH_TEST);

    SOLARCHVISION_draw_referencePivot();

    WIN3D_Diagrams.popMatrix();


    SOLARCHVISION_draw_pallet_on_WIN3D();  

    WIN3D_Diagrams.endDraw();

    if ((WIN3D_record_JPG == 1) || (WIN3D_record_AUTO == 1)) {
      String myFile = MAKE_Filename(CreateStamp(1) + "WIN3D_") + ".jpg";
      WIN3D_Diagrams.save(myFile);
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    }

    imageMode(CORNER);
    image(WIN3D_Diagrams, WIN3D_CX_View, WIN3D_CY_View, WIN3D_X_View / WIN3D_ImageScale, WIN3D_Y_View / WIN3D_ImageScale);



    if ((WIN3D_record_JPG == 1) || (WIN3D_record_AUTO == 0)) WIN3D_record_JPG = 0;  

    //////////////////////////////////
    WIN3D_X_View /= WIN3D_ImageScale;
    WIN3D_Y_View /= WIN3D_ImageScale;  
    //////////////////////////////////

    if (WIN3D_ImageScale != 1) {
      WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);
      WIN3D_Update = 0; //1;
    } else {
      WIN3D_Update = 0;

      SOLARCHVISION_draw_Perspective_Internally();
    }
  }
}

void SOLARCHVISION_draw_pallet_on_WIN3D () {

  int draw_pal = 0;

  int PAL_TYPE = 0; 
  int PAL_DIR = 1;
  float PAL_Multiplier = 1; 

  if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {

    if (Impact_TYPE == Impact_ACTIVE) {
      PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR; 
      PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
    }   

    draw_pal = 1;
  }

  if (WIN3D_FacesShade == Shade_Vertex_Elevation) {

    PAL_TYPE = ELEVATION_Pallet_CLR; 
    PAL_DIR = ELEVATION_Pallet_DIR; 
    PAL_Multiplier = ELEVATION_Pallet_MLT; 

    draw_pal = 1;
  }

  if (WIN3D_FacesShade == Shade_Vertex_Solid) {

    PAL_TYPE = SOLID_Pallet_CLR; 
    PAL_DIR = SOLID_Pallet_DIR;
    PAL_Multiplier = SOLID_Pallet_MLT;

    draw_pal = 1;
  }          




  if (draw_pal != 0) {

    float the_scale = 1;

    if (WIN3D_ViewType == 1) {

      //the_scale *= (0.5 * WIN3D_Scale3D / tan(0.5 * WIN3D_CAM_fov)) * WIN3D_refScale;
      the_scale *= (0.5 / tan(0.5 * WIN3D_CAM_fov));
    } else {
      float ZOOM = Orthographic_ZOOM();

      //the_scale *= (1.0 / ZOOM) * (0.5 * WIN3D_Scale3D);
      the_scale *= (0.5 / ZOOM);
    }  

    WIN3D_Diagrams.pushMatrix();

    WIN3D_CAM_fov = WIN3D_Zoom * PI / 180;

    WIN3D_CAM_dist = (0.5 * WIN3D_refScale) / tan(0.5 * WIN3D_CAM_fov);

    if (WIN3D_ViewType == 1) {

      float aspect = 1.0 / WIN3D_R_View;

      float zFar = WIN3D_CAM_dist * 1000;
      float zNear = WIN3D_CAM_dist * 0.001;

      WIN3D_Diagrams.translate(0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View, 0); // << IMPORTANT!
    } else {

      float ZOOM = Orthographic_ZOOM();

      WIN3D_Diagrams.translate(0, 1.0 * WIN3D_Y_View, 0); // << IMPORTANT!
    }









    float pal_length = 1 * SOLARCHVISION_H_Pixel * WIN3D_ImageScale / the_scale;

    for (int q = 0; q < 11; q += 1) {

      float _u = 0.2 * q - 0.5;

      if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
      }

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u); 

      WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

      WIN3D_Diagrams.strokeWeight(0);

      float x1 = -0.5 * pal_length + q * (pal_length / 11.0); 
      float x2 = x1 + (pal_length / 11.0);
      float y1 = -0.2 * (x2 - x1) + (0.4 * WIN3D_Y_View / the_scale);
      float y2 = y1 + 0.4 * (x2 - x1);

      WIN3D_Diagrams.beginShape();
      WIN3D_Diagrams.vertex(x1, y1, 0);
      WIN3D_Diagrams.vertex(x1, y2, 0);
      WIN3D_Diagrams.vertex(x2, y2, 0);
      WIN3D_Diagrams.vertex(x2, y1, 0);
      WIN3D_Diagrams.endShape(CLOSE);    

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        WIN3D_Diagrams.stroke(127);
        WIN3D_Diagrams.fill(127);
        WIN3D_Diagrams.strokeWeight(0);
      } else {
        WIN3D_Diagrams.stroke(255);
        WIN3D_Diagrams.fill(255);
        WIN3D_Diagrams.strokeWeight(2);
      }  

      float txtSize = y2 - y1;

      WIN3D_Diagrams.textSize(txtSize);
      WIN3D_Diagrams.textAlign(CENTER, CENTER);

      if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {
        if (Impact_TYPE == Impact_ACTIVE) WIN3D_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        if (Impact_TYPE == Impact_PASSIVE) WIN3D_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }

      if (WIN3D_FacesShade == Shade_Vertex_Elevation) {
        WIN3D_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }

      if (WIN3D_FacesShade == Shade_Vertex_Solid) {
        WIN3D_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      }
    }


    WIN3D_Diagrams.popMatrix();
  }
}






PGraphics WORLD_Diagrams;

void SOLARCHVISION_draw_WORLD () {

  if (WORLD_Update == 1) {

    if (WORLD_record_PDF == 1) WORLD_ImageScale = 1;
    else if (WORLD_record_JPG == 1) WORLD_ImageScale = 2;
    else WORLD_ImageScale = 1;

    //////////////////////////////////
    WORLD_X_View *= WORLD_ImageScale;
    WORLD_Y_View *= WORLD_ImageScale;  
    //////////////////////////////////  

    if (WORLD_record_PDF == 1) {
      println("PDF:begin");
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, PDF, MAKE_Filename(CreateStamp(1) + "WORLD_") + ".pdf");
      beginRecord(WORLD_Diagrams);
    } else if (WORLD_ImageScale != 1) {
      println("IMG:high-res");
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
      WORLD_Diagrams.beginDraw();
    } else {
      WORLD_Diagrams.beginDraw();
    }

    WORLD_Diagrams.background(0, 0, 0);

    WORLD_Diagrams.image(WORLDViewImage, 0, 0, WORLD_X_View, WORLD_Y_View);

    float WORLD_VIEW_OffsetX = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0] + 180;
    float WORLD_VIEW_OffsetY = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - 90;

    float WORLD_VIEW_ScaleX = (WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) / 360.0;
    float WORLD_VIEW_ScaleY = (WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) / 180.0;    

    float _lon1 = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0];
    float _lon2 = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1];
    float _lat1 = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0];
    float _lat2 = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1];

    int x_point1 = int(WORLD_X_View * (( 1 * (_lon1 - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX);
    int y_point1 = int(WORLD_Y_View * ((-1 * (_lat1 - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY);
    int x_point2 = int(WORLD_X_View * (( 1 * (_lon2 - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX);
    int y_point2 = int(WORLD_Y_View * ((-1 * (_lat2 - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY); 

    float R_station = 2 * WORLD_ImageScale;
    if (WORLD_VIEW_GridDisplay[WORLD_VIEW_Number] == 1) R_station = 5; 

    WORLD_Diagrams.ellipseMode(CENTER);

    for (int n = 0; n < AERIAL_num; n += 1) {

      //try {

      if ((AERIAL_Center_Longitude == LocationLongitude) && (AERIAL_Center_Latitude == LocationLatitude)) {

        float _lat = AERIAL_Locations[n][1];
        float _lon = AERIAL_Locations[n][0]; 
        if (_lon > 180) _lon -= 360; // << important!

        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY; 

        WORLD_Diagrams.pushMatrix();
        WORLD_Diagrams.translate(x_point, y_point);

        if (AERIAL_graphOption == 0) {
          //-----------------------------
          int PAL_TYPE = 6; //12; 
          int PAL_DIR = -1;
          float PAL_Multiplier = 1.0 / 30.0;
          //-----------------------------

          for (int _turn = 1; _turn <= 2; _turn += 1) {
            for (int o = 0; o < GRIB2_maxScenarios; o += 1) {

              float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb][n][o];

              if (_val < 0.9 * FLOAT_undefined) {

                float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                if (PAL_DIR == -1) _u = 1 - _u;
                if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_DIR == 2) _u =  0.5 * _u;

                float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);             

                if (_turn == 1) {
                  WORLD_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
                  WORLD_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);           

                  WORLD_Diagrams.strokeWeight(0);
                  WORLD_Diagrams.ellipse(0, 0, R_station, R_station);
                }

                if (_turn == 2) {
                  WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
                  WORLD_Diagrams.textAlign(CENTER, CENTER);

                  _u = 0.5 + 0.5 * (PAL_Multiplier * _val);

                  if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                    WORLD_Diagrams.stroke(127);
                    WORLD_Diagrams.fill(127);
                    WORLD_Diagrams.strokeWeight(0);
                  } else {
                    WORLD_Diagrams.stroke(255);
                    WORLD_Diagrams.fill(255);
                    WORLD_Diagrams.strokeWeight(2 * WORLD_ImageScale);
                  }              
                  if (_val < 0.9 * FLOAT_undefined) WORLD_Diagrams.text(nf(int(roundTo(_val, 1)), 0), 0, 0);
                }
              }
            }
          }
        }  

        if (AERIAL_graphOption == 1) {

          //-----------------------------
          int PAL_TYPE = 1;//12; 
          int PAL_DIR = 1;//-1;
          float PAL_Multiplier = 0.1;//1.0 / 30.0;
          //-----------------------------

          for (int _turn = 1; _turn <= 2; _turn += 1) {
            for (int o = 0; o < GRIB2_maxScenarios; o += 1) {

              //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb][n][o];
              float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o];

              if (_val < 0.9 * FLOAT_undefined) {              

                float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir][n][o];
                float D_teta = 15; 
                float R = 0.25 * R_station * AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o];

                float R_in = 0.0 * R; 
                float x1 = (R_in * cos_ang(90 - (teta - 0.5 * D_teta))) * WORLD_ImageScale;
                float y1 = (R_in * -sin_ang(90 - (teta - 0.5 * D_teta))) * WORLD_ImageScale;
                float x2 = (R_in * cos_ang(90 - (teta + 0.5 * D_teta))) * WORLD_ImageScale;
                float y2 = (R_in * -sin_ang(90 - (teta + 0.5 * D_teta))) * WORLD_ImageScale;                      

                float x4 = (R * cos_ang(90 - (teta - 0.5 * D_teta))) * WORLD_ImageScale;
                float y4 = (R * -sin_ang(90 - (teta - 0.5 * D_teta))) * WORLD_ImageScale;
                float x3 = (R * cos_ang(90 - (teta + 0.5 * D_teta))) * WORLD_ImageScale;
                float y3 = (R * -sin_ang(90 - (teta + 0.5 * D_teta))) * WORLD_ImageScale;          

                //float ox = -0.5 * (R * cos_ang(90 - teta)) * WORLD_ImageScale;
                //float oy = -0.5 * (R * -sin_ang(90 - teta)) * WORLD_ImageScale;
                //float ox = -1 * (R * cos_ang(90 - teta)) * WORLD_ImageScale;
                //float oy = -1 * (R * -sin_ang(90 - teta)) * WORLD_ImageScale;
                float ox = -2 * (R * cos_ang(90 - teta)) / 3.0 * WORLD_ImageScale;
                float oy = -2 * (R * -sin_ang(90 - teta)) / 3.0 * WORLD_ImageScale;            

                float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
                if (PAL_DIR == -1) _u = 1 - _u;
                if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_DIR == 2) _u =  0.5 * _u;

                float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);             

                if (_turn == 1) {
                  WORLD_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
                  WORLD_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);           

                  WORLD_Diagrams.strokeWeight(0);
                  //WORLD_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  WORLD_Diagrams.quad(x1 + ox, y1 + oy, x2 + ox, y2 + oy, x3 + ox, y3 + oy, x4 + ox, y4 + oy);
                }

                if (_turn == 2) {
                  WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
                  WORLD_Diagrams.textAlign(CENTER, CENTER);

                  _u = 0.5 + 0.5 * (PAL_Multiplier * _val);

                  if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                    WORLD_Diagrams.stroke(127);
                    WORLD_Diagrams.fill(127);
                    WORLD_Diagrams.strokeWeight(0);
                  } else {
                    WORLD_Diagrams.stroke(255);
                    WORLD_Diagrams.fill(255);
                    WORLD_Diagrams.strokeWeight(2 * WORLD_ImageScale);
                  }              
                  if (_val < 0.9 * FLOAT_undefined) WORLD_Diagrams.text(nf(int(roundTo(_val, 1)), 0), 0, 0);
                }
              }
            }
          }
        }

        WORLD_Diagrams.popMatrix();
      }
      //}
      //catch (Exception e) {
      //}
    }   




    {
      float _lat = LocationLatitude;
      float _lon = LocationLongitude; 
      if (_lon > 180) _lon -= 360; // << important!

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY; 

      WORLD_Diagrams.strokeWeight(3 * WORLD_ImageScale);
      WORLD_Diagrams.stroke(0, 0, 127, 255);
      WORLD_Diagrams.noFill();

      WORLD_Diagrams.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
    }   

    int nearest_Station_RECENT_OBSERVED_id = -1;
    float nearest_Station_RECENT_OBSERVED_dist = FLOAT_undefined;

    for (int f = 0; f < STATION_SWOB_INFO.length; f += 1) {
      float draw_info = 0;

      if (Display_SWOB_Points != 0) draw_info = 1;

      float _lat = float(STATION_SWOB_INFO[f][3]);
      float _lon = float(STATION_SWOB_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!

      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 

      if (draw_info == 1) {

        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

        WORLD_Diagrams.strokeWeight(0);
        WORLD_Diagrams.stroke(191, 0, 0, 191);
        WORLD_Diagrams.fill(191, 0, 0, 191);      
        WORLD_Diagrams.ellipse(x_point, y_point, R_station, R_station);

        if (Display_SWOB_Points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
          WORLD_Diagrams.text(STATION_SWOB_INFO[f][6], x_point, y_point);
        }
      }

      float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

      if (nearest_Station_RECENT_OBSERVED_dist > d) {
        nearest_Station_RECENT_OBSERVED_dist = d;
        nearest_Station_RECENT_OBSERVED_id = f;
      }
    }    

    if (Display_SWOB_Nearest == 1) {   
      int f = nearest_Station_RECENT_OBSERVED_id;

      float _lat = float(STATION_SWOB_INFO[f][3]);
      float _lon = float(STATION_SWOB_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER);
      WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
      WORLD_Diagrams.text(STATION_SWOB_INFO[f][6], x_point, y_point);
      //println(STATION_SWOB_INFO[f][6]);
    }  



    int nearest_STATION_NAEFS = -1;
    float nearest_STATION_NAEFS_dist = FLOAT_undefined;

    for (int f = 0; f < STATION_NAEFS_INFO.length; f += 1) {
      float draw_info = 0;

      if (Display_NAEFS_Points != 0) draw_info = 1;

      float _lat = float(STATION_NAEFS_INFO[f][3]);
      float _lon = float(STATION_NAEFS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!

      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 

      if (draw_info == 1) {

        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

        WORLD_Diagrams.strokeWeight(0);
        WORLD_Diagrams.stroke(0, 63, 0, 127);
        WORLD_Diagrams.fill(0, 63, 0, 127);

        WORLD_Diagrams.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);

        if (Display_NAEFS_Points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
          WORLD_Diagrams.text(STATION_NAEFS_INFO[f][0], x_point, y_point);
        }
      }

      float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

      if (nearest_STATION_NAEFS_dist > d) {
        nearest_STATION_NAEFS_dist = d;
        nearest_STATION_NAEFS = f;
      }
    }

    if (Display_NAEFS_Nearest == 1) {   
      int f = nearest_STATION_NAEFS;

      float _lat = float(STATION_NAEFS_INFO[f][3]);
      float _lon = float(STATION_NAEFS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!      

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
      WORLD_Diagrams.text(STATION_NAEFS_INFO[f][0], x_point, y_point);
      //println(STATION_NAEFS_INFO[f][0]);
    }


    int nearest_STATION_CWEEDS = -1;
    float nearest_STATION_CWEEDS_dist = FLOAT_undefined;

    for (int f = 0; f < STATION_CWEEDS_INFO.length; f += 1) {
      float draw_info = 0;

      if (Display_CWEEDS_Points != 0) draw_info = 1;

      float _lat = float(STATION_CWEEDS_INFO[f][3]);
      float _lon = float(STATION_CWEEDS_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!

      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 

      if (draw_info == 1) {

        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

        WORLD_Diagrams.strokeWeight(2 * WORLD_ImageScale);
        WORLD_Diagrams.stroke(0, 0, 0, 191);
        WORLD_Diagrams.noFill();
        WORLD_Diagrams.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);

        if (Display_CWEEDS_Points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
          WORLD_Diagrams.text(STATION_CWEEDS_INFO[f][0], x_point, y_point);
        }
      }

      float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

      if (nearest_STATION_CWEEDS_dist > d) {
        nearest_STATION_CWEEDS_dist = d;
        nearest_STATION_CWEEDS = f;
      }
    } 

    if (Display_CWEEDS_Nearest == 1) {   
      int f = nearest_STATION_CWEEDS;

      float _lat = float(STATION_CWEEDS_INFO[f][3]);
      float _lon = float(STATION_CWEEDS_INFO[f][4]);  
      if (_lon > 180) _lon -= 360; // << important!      

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
      WORLD_Diagrams.text(STATION_CWEEDS_INFO[f][0], x_point, y_point);
      //println(STATION_CWEEDS_INFO[f][0]);
    }


    int nearest_STATION_CLMREC = -1;
    float nearest_STATION_CLMREC_dist = FLOAT_undefined;

    for (int f = 0; f < STATION_CLMREC_INFO.length; f += 1) {
      float draw_info = 0;

      if (Display_CLMREC_Points != 0) draw_info = 1;
      
      if (int(STATION_CLMREC_INFO[f][10]) == 2016) { // only use stations with this condition

        float _lat = float(STATION_CLMREC_INFO[f][3]);
        float _lon = float(STATION_CLMREC_INFO[f][4]); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
        if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
        if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
        if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 
  
        if (draw_info == 1) {
  
          float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
          float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;
  
          WORLD_Diagrams.strokeWeight(1 * WORLD_ImageScale);
          WORLD_Diagrams.stroke(0, 0, 0, 191);
          WORLD_Diagrams.noFill();
          WORLD_Diagrams.ellipse(x_point, y_point, 0.5 * R_station, 0.5 * R_station);
  
          if (Display_CLMREC_Points > 1) {
            WORLD_Diagrams.strokeWeight(0);
            WORLD_Diagrams.stroke(0);
            WORLD_Diagrams.fill(0);      
            WORLD_Diagrams.textAlign(RIGHT, CENTER); 
            WORLD_Diagrams.textSize(0.5 * MessageSize * WORLD_ImageScale);
            WORLD_Diagrams.text(STATION_CLMREC_INFO[f][0], x_point, y_point);
          }
        }
  
        float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);
  
        if (nearest_STATION_CLMREC_dist > d) {
          nearest_STATION_CLMREC_dist = d;
          nearest_STATION_CLMREC = f;
        }
      }
    } 

    if (Display_CLMREC_Nearest == 1) {   
      int f = nearest_STATION_CLMREC;

      float _lat = float(STATION_CLMREC_INFO[f][3]);
      float _lon = float(STATION_CLMREC_INFO[f][4]);  
      if (_lon > 180) _lon -= 360; // << important!      

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
      WORLD_Diagrams.text(STATION_CLMREC_INFO[f][0], x_point, y_point);
      //println(STATION_CLMREC_INFO[f][0]);
    }

    int nearest_STATION_TMYEPW = -1;
    float nearest_STATION_TMYEPW_dist = FLOAT_undefined;

    for (int f = 0; f < STATION_TMYEPW_INFO.length; f += 1) {
      float draw_info = 0;

      if (Display_TMYEPW_Points != 0) draw_info = 1;

      float _lat = float(STATION_TMYEPW_INFO[f][3]);
      float _lon = float(STATION_TMYEPW_INFO[f][4]); 
      if (_lon > 180) _lon -= 360; // << important!

      if (_lon < WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lon > WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1]) draw_info = 0;
      if (_lat < WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) draw_info = 0;
      if (_lat > WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1]) draw_info = 0; 

      if (draw_info == 1) {

        float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
        float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

        WORLD_Diagrams.strokeWeight(2 * WORLD_ImageScale);
        WORLD_Diagrams.stroke(255, 0, 0, 127);
        WORLD_Diagrams.noFill();
        WORLD_Diagrams.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);

        if (Display_TMYEPW_Points > 1) {
          WORLD_Diagrams.strokeWeight(0);
          WORLD_Diagrams.stroke(0);
          WORLD_Diagrams.fill(0);      
          WORLD_Diagrams.textAlign(RIGHT, CENTER); 
          WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
          WORLD_Diagrams.text(STATION_TMYEPW_INFO[f][0], x_point, y_point);
        }
      }

      float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

      if (nearest_STATION_TMYEPW_dist > d) {
        nearest_STATION_TMYEPW_dist = d;
        nearest_STATION_TMYEPW = f;
      }
    } 

    if (Display_TMYEPW_Nearest == 1) {   
      int f = nearest_STATION_TMYEPW;

      float _lat = float(STATION_TMYEPW_INFO[f][3]);
      float _lon = float(STATION_TMYEPW_INFO[f][4]);  
      if (_lon > 180) _lon -= 360; // << important!      

      float x_point = WORLD_X_View * (( 1 * (_lon - WORLD_VIEW_OffsetX) / 360.0) + 0.5) / WORLD_VIEW_ScaleX;
      float y_point = WORLD_Y_View * ((-1 * (_lat - WORLD_VIEW_OffsetY) / 180.0) + 0.5) / WORLD_VIEW_ScaleY;

      WORLD_Diagrams.strokeWeight(0);
      WORLD_Diagrams.stroke(0);
      WORLD_Diagrams.fill(0);      
      WORLD_Diagrams.textAlign(RIGHT, CENTER); 
      WORLD_Diagrams.textSize(MessageSize * WORLD_ImageScale);
      WORLD_Diagrams.text(STATION_TMYEPW_INFO[f][0], x_point, y_point);
      //println(STATION_TMYEPW_INFO[f][0]);
    }


    WORLD_Diagrams.strokeWeight(0);


    if (WORLD_record_PDF == 1) {
      endRecord();

      String myFile = MAKE_Filename(CreateStamp(0) + "WORLD_") + ".pdf";
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    } else {
      WORLD_Diagrams.endDraw();

      if ((WORLD_record_JPG == 1) || (WORLD_record_AUTO == 1)) {
        String myFile = MAKE_Filename(CreateStamp(1) + "WORLD_") + ".jpg";
        WORLD_Diagrams.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }

      imageMode(CORNER);
      image(WORLD_Diagrams, WORLD_CX_View, WORLD_CY_View, WORLD_X_View / WORLD_ImageScale, WORLD_Y_View / WORLD_ImageScale);
    }


    //////////////////////////////////
    WORLD_X_View /= WORLD_ImageScale;
    WORLD_Y_View /= WORLD_ImageScale;  
    //////////////////////////////////

    if ((WORLD_ImageScale != 1) || (WORLD_record_PDF == 1)) {
      WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
      WORLD_Update = 0; //1;
    } else {
      WORLD_Update = 0;
    }


    if ((WORLD_record_JPG == 1) || (WORLD_record_AUTO == 0)) WORLD_record_JPG = 0;
  }
}





void SOLARCHVISION_draw_STUDY () {

  cursor(WAIT);


  if (STUDY_Update == 1) {

    if (STUDY_record_PDF == 1) STUDY_ImageScale = 1;
    else if (STUDY_record_JPG == 1) STUDY_ImageScale = 2;
    else STUDY_ImageScale = 1;

    //////////////////////////////////
    STUDY_X_View *= STUDY_ImageScale;
    STUDY_Y_View *= STUDY_ImageScale;  
    STUDY_T_scale *= STUDY_ImageScale;
    //////////////////////////////////  

    if (STUDY_record_PDF == 1) {
      println("PDF:begin");
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, PDF, MAKE_Filename(CreateStamp(1) + "STUDY_") + ".pdf");
      beginRecord(STUDY_Diagrams);
    } else if (STUDY_ImageScale != 1) {
      println("IMG:high-res");
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
      STUDY_Diagrams.beginDraw();
    } else {
      STUDY_Diagrams.beginDraw();
    }  

    DrawnFrame += 1;
    println("frame:", DrawnFrame);    

    //if (Update_DevelopData == 1) {
    if (STUDY_CurrentLayer == LAYER_developed) {
      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);

      println("DevelopDATA updated!");

      Update_DevelopData = 0;
    }
    //}     


    STUDY_S_View = (STUDY_X_View / 2100.0);
    STUDY_U_scale = 18.0 / float(STUDY_j_End - STUDY_j_Start);


    STUDY_X_Coordinate = -0.333 * STUDY_X_View;      

    STUDY_Y_Coordinate = 1.0 * STUDY_Y_View;


    STUDY_Diagrams.background(255);

    STUDY_Diagrams.blendMode(BLEND);

    STUDY_Diagrams.strokeJoin(ROUND); 

    STUDY_Diagrams.textFont(SOLARCHVISION_font);

    STUDY_Diagrams.strokeWeight(0);

    //STUDY_Diagrams.translate(STUDY_X_Coordinate * -0.25, STUDY_Y_Coordinate * 0.5); 
    STUDY_Diagrams.translate(STUDY_X_Coordinate * -0.425, STUDY_Y_Coordinate * 0.5);

    SOLARCHVISION_Plot_Setup();

    //STUDY_Diagrams.translate(STUDY_X_Coordinate * 0.25, STUDY_Y_Coordinate * 0.5);
    STUDY_Diagrams.translate(STUDY_X_Coordinate * 0.425, STUDY_Y_Coordinate * 0.5);

    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);

    STUDY_Diagrams.stroke(63);
    STUDY_Diagrams.fill(63);
    STUDY_Diagrams.textAlign(CENTER, CENTER);

    String _text = "SOLARCHVISION post-processing";

    if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) _text += " based on typical-year data for Building Energy Simulation";  //"(TMYEPW - U.S. Department of Energy)";
    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) _text += " based on long-term Canadian Weather Energy and Engineering Datasets (CWEEDS - Environment and Climate Change Canada)";
    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) _text += " based on Environment and Climate Change Canada's Climate website";
    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) _text += " based on the North American Ensemble Forecast System (NAEFS - Environment and Climate Change Canada)";
    if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) _text += " based on real-time Surface Weather Observation (SWOB - Environment and Climate Change Canada)";

    //_text += ", www.solarchvision.com";

    STUDY_Diagrams.textSize(STUDY_X_View * 0.01);
    ///STUDY_Diagrams.text(_text, STUDY_X_View * 0.55, STUDY_Y_View * -0.1666 / STUDY_R_View, 0);

    if (STUDY_record_PDF == 1) {
      endRecord();

      String myFile = MAKE_Filename(CreateStamp(0) + "STUDY_") + ".pdf";
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    } else {
      STUDY_Diagrams.endDraw();

      if ((STUDY_record_JPG == 1) || (STUDY_record_AUTO == 1)) {
        String myFile = MAKE_Filename(CreateStamp(1) + "STUDY_") + ".jpg";
        STUDY_Diagrams.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }

      imageMode(CORNER);
      image(STUDY_Diagrams, STUDY_CX_View, STUDY_CY_View, STUDY_X_View / STUDY_ImageScale, STUDY_Y_View / STUDY_ImageScale);
    }

    //////////////////////////////////
    STUDY_X_View /= STUDY_ImageScale;
    STUDY_Y_View /= STUDY_ImageScale;
    STUDY_T_scale /= STUDY_ImageScale;
    //////////////////////////////////

    if ((STUDY_ImageScale != 1) || (STUDY_record_PDF == 1)) {
      STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
      STUDY_Update = 0; //1;
    } else {
      STUDY_Update = 0;
    }


    if ((STUDY_record_JPG == 1) || (STUDY_record_AUTO == 0)) STUDY_record_JPG = 0;
  }

  Export_STUDY_info_node = 0;
  Export_STUDY_info_norm = 0;
  Export_STUDY_info_prob = 0;

  cursor(ARROW);
} 



int SOLARCHVISION_now_drawing = -1; 

void SOLARCHVISION_PlotHOURLY (float x, float y, float z, float sx, float sy, float sz) {

  int draw_CLIMATE_CWEEDS = 0;
  int draw_CLIMATE_CLMREC = 0;
  int draw_forecast = 0;
  int draw_observed = 0;
  int draw_climate_TMYEPW = 0; 

  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) draw_CLIMATE_CWEEDS = 1;
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) draw_CLIMATE_CLMREC = 1;
  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) draw_forecast = 1;
  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) draw_observed = 1;
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) draw_climate_TMYEPW = 1;

  //////////////////
  draw_observed = 1;
  //////////////////  

  if (draw_climate_TMYEPW == 1) {
    SOLARCHVISION_now_drawing = databaseNumber_CLIMATE_TMYEPW;
    SOLARCHVISION_PlotCLIMATE_TMYEPW(x, y, z, sx, sy, sz);
  }  
  if (draw_CLIMATE_CWEEDS == 1) {
    SOLARCHVISION_now_drawing = databaseNumber_CLIMATE_CWEEDS;
    SOLARCHVISION_PlotCLIMATE_CWEEDS(x, y, z, sx, sy, sz);
  }
  if (draw_CLIMATE_CLMREC == 1) {
    SOLARCHVISION_now_drawing = databaseNumber_CLIMATE_CLMREC;
    SOLARCHVISION_PlotCLIMATE_CLMREC(x, y, z, sx, sy, sz);
  }  
  if (draw_forecast == 1) {
    SOLARCHVISION_now_drawing = databaseNumber_FORECAST_ENSEMBLE;
    SOLARCHVISION_PlotFORECAST_ENSEMBLE(x, y, z, sx, sy, sz);
  }
  if (draw_observed == 1) {

    int keep_STUDY_DisplayRaws = STUDY_DisplayRaws;
    int keep_STUDY_DisplaySorted = STUDY_DisplaySorted;
    int keep_STUDY_DisplayNormals = STUDY_DisplayNormals;
    int keep_STUDY_DisplayProbs = STUDY_DisplayProbs;

    STUDY_DisplayRaws = 1;
    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayProbs = 0; 

    SOLARCHVISION_now_drawing = databaseNumber_RECENT_OBSERVED;
    SOLARCHVISION_PlotRECENT_OBSERVED(x, y, z, sx, sy, sz);

    STUDY_DisplayRaws = keep_STUDY_DisplayRaws;
    STUDY_DisplaySorted = keep_STUDY_DisplaySorted;
    STUDY_DisplayNormals = keep_STUDY_DisplayNormals;
    STUDY_DisplayProbs = keep_STUDY_DisplayProbs;
  }

  SOLARCHVISION_now_drawing = -1;
}





void SOLARCHVISION_Plot_Setup () {

  if (STUDY_Setup == 14) {

    if (FrameVariation == 2) {

      for (int p = 0; p < 3; p += 1) { 
        STUDY_ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3) + p;

        SOLARCHVISION_PlotIMPACT(0, (175 - p * 350) * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);
      }
      STUDY_ImpactLayer = pre_STUDY_ImpactLayer;

      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);
    } else {

      if ((STUDY_PlotImpacts == 8) || (STUDY_PlotImpacts == 9)) {

        int keep_TIME_BeginDay = TIME_BeginDay;
        float keep_STUDY_PerDays = STUDY_PerDays;
        int keep_STUDY_j_End = STUDY_j_End;
        float keep_STUDY_U_scale = STUDY_U_scale;

        TIME_BeginDay = 183; //0; // 183: to put the summer diagram on the left similar to the YC book
        STUDY_PerDays = 183;
        STUDY_j_End = 2;
        STUDY_U_scale = 18.0 / float(STUDY_j_End - STUDY_j_Start);

        SOLARCHVISION_PlotIMPACT(0, 0 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

        TIME_BeginDay = keep_TIME_BeginDay;
        STUDY_PerDays = keep_STUDY_PerDays;
        STUDY_j_End = keep_STUDY_j_End;
        STUDY_U_scale = keep_STUDY_U_scale;
      } else {
        SOLARCHVISION_PlotIMPACT(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

        SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);
      }
    }
  }  

  // -----------------------------------------------

  if (STUDY_Setup == -2) {
    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
      pre_TIME_Date = TIME_Date;
      int keep_TIME_BeginDay = TIME_BeginDay;
      int delta = 4;

      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      TIME_Date -= delta;
      SOLARCHVISION_update_date();
      TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
      SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
      TIME_BeginDay = (TIME_BeginDay + delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      TIME_Date -= delta;
      SOLARCHVISION_update_date();
      TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
      SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
      TIME_BeginDay = (TIME_BeginDay + 2 * delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      TIME_Date -= delta;
      SOLARCHVISION_update_date();
      TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
      SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
      TIME_BeginDay = (TIME_BeginDay + 3 * delta) % 365;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      TIME_Date = pre_TIME_Date;
      SOLARCHVISION_update_date();
      TIME_BeginDay = SOLARCHVISION_Convert2Date(TIME_Month, TIME_Day);
      SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
      TIME_BeginDay = keep_TIME_BeginDay;
    }
  }


  if (STUDY_Setup == -1) {
    pre_IMPACTS_DataSource = IMPACTS_DataSource;

    IMPACTS_DataSource = databaseNumber_FORECAST_ENSEMBLE; 

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    IMPACTS_DataSource = databaseNumber_CLIMATE_CWEEDS;

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;

    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0; 
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    IMPACTS_DataSource = pre_IMPACTS_DataSource;
  }


  if (STUDY_Setup == 0) {
    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {


      H_Layer_Option = 3;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      H_Layer_Option = 4;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      H_Layer_Option = 5;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      H_Layer_Option = 0;
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      H_Layer_Option = pre_H_Layer_Option;
    }       
    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {


      F_Layer_Option = 4;
      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      F_Layer_Option = 3;
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      F_Layer_Option = 1;
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

      F_Layer_Option = 0;
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      F_Layer_Option = pre_F_Layer_Option;
    }
  }


  if (STUDY_Setup == 1) {

    STUDY_DevelopLayer = STUDY_CurrentLayer;
    STUDY_CurrentLayer = LAYER_developed; 

    Develop_Option = DEV_OP_01;
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    Develop_Option = DEV_OP_02;
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    Develop_Option = DEV_OP_03;
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    Develop_Option = DEV_OP_04;
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    Develop_Option = pre_Develop_Option;
    STUDY_CurrentLayer = pre_STUDY_CurrentLayer;
  }  


  if (STUDY_Setup == 2) {
    if (STUDY_CurrentLayer != LAYER_developed) {


      SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      STUDY_DevelopLayer = STUDY_CurrentLayer;
      STUDY_CurrentLayer = LAYER_developed;

      Develop_Option = DEV_OP_06; 
      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
      SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      Develop_Option = DEV_OP_07; 
      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
      SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      Develop_Option = DEV_OP_08; 
      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
      SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

      STUDY_CurrentLayer = pre_STUDY_CurrentLayer;
    }
  }  


  if (STUDY_Setup == 3) {

    STUDY_CurrentLayer = LAYER_windspd200hPa;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_pressure;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_heightp500hPa;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_thicknesses_1000_500;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = pre_STUDY_CurrentLayer;
  }


  if (STUDY_Setup == 4) {

    STUDY_CurrentLayer = LAYER_windspd;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_precipitation_A;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_relhum;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_drybulb;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = pre_STUDY_CurrentLayer;
  }  


  if (STUDY_Setup == 5) {

    STUDY_CurrentLayer = LAYER_dirnorrad;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_difhorrad;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_developed;
    Develop_Option = DEV_OP_01; 
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_developed;
    Develop_Option = DEV_OP_03; 
    SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = pre_STUDY_CurrentLayer;
    Develop_Option = pre_Develop_Option;
  }


  if (STUDY_Setup == 6) {

    STUDY_skyScenario_Active = 4;
    SOLARCHVISION_PlotHOURLY(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_skyScenario_Active = 3;
    SOLARCHVISION_PlotHOURLY(0, -175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_skyScenario_Active = 2;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_skyScenario_Active = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_skyScenario_Active = pre_STUDY_SkyScenario;
  }  


  if (STUDY_Setup == 7) {

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1; 
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = -2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = -1;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = pre_STUDY_PlotImpacts;
  }


  if (STUDY_Setup == 8) {    

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 3;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = pre_STUDY_PlotImpacts; 
    STUDY_ImpactLayer = pre_STUDY_ImpactLayer;
  }


  if (STUDY_Setup == 9) {

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = pre_STUDY_PlotImpacts;
    STUDY_ImpactLayer = pre_STUDY_ImpactLayer;
  }

  if (STUDY_Setup == 10) {

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 4;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = pre_STUDY_PlotImpacts; 
    STUDY_ImpactLayer = pre_STUDY_ImpactLayer;
  }

  if (STUDY_Setup == 11) {

    STUDY_DisplaySorted = 0;
    STUDY_DisplayNormals = 0;
    STUDY_DisplayRaws = 1;
    STUDY_DisplayProbs = 1;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_DisplaySorted = 1;
    STUDY_DisplayNormals = 1;
    STUDY_DisplayRaws = 0;
    STUDY_DisplayProbs = 0;
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 5;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = pre_STUDY_PlotImpacts; 
    STUDY_ImpactLayer = pre_STUDY_ImpactLayer;
  }  

  if (STUDY_Setup == 12) {

    if (SOLARCHVISION_automated != 0) {
      STUDY_DisplaySorted = 0;
      STUDY_DisplayNormals = 1;
      STUDY_DisplayRaws = 0;
      STUDY_DisplayProbs = 1;
    }

    STUDY_CurrentLayer = LAYER_windspd; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    //STUDY_CurrentLayer = LAYER_precipitation_A ; 
    //STUDY_DevelopLayer = STUDY_CurrentLayer;
    //STUDY_CurrentLayer = LAYER_developed; 
    //Develop_Option = DEV_OP_09;
    //SOLARCHVISION_DevelopDATA(IMPACTS_DataSource); 
    //SOLARCHVISION_PlotHOURLY(0, 325 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_drybulb; 
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 1;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = -2;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);
  }

  if (STUDY_Setup == 13) {

    if (SOLARCHVISION_automated != 0) {
      STUDY_DisplaySorted = 1;
      STUDY_DisplayNormals = 1;
      STUDY_DisplayRaws = 0;
      STUDY_DisplayProbs = 0;
    }

    STUDY_CurrentLayer = STUDY_CurrentLayer = LAYER_dirnorrad; 
    SOLARCHVISION_PlotHOURLY(0, 175 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View); 

    //STUDY_CurrentLayer = LAYER_glohorrad; //LAYER_difhorrad; // <<<<<<<<<<<<<< 
    //SOLARCHVISION_PlotHOURLY(0, 325 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_CurrentLayer = LAYER_cloudcover;
    SOLARCHVISION_PlotHOURLY(0, 525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 0;
    SOLARCHVISION_PlotIMPACT(0, -525 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);

    STUDY_PlotImpacts = 2; //4;
    SOLARCHVISION_PlotIMPACT(0, -200 * STUDY_S_View, 0, (100.0 * STUDY_U_scale * STUDY_S_View), (-1.0 * STUDY_V_scale[STUDY_CurrentLayer] * STUDY_S_View), 1.0 * STUDY_S_View);


    STUDY_PlotImpacts = pre_STUDY_PlotImpacts; 
    STUDY_ImpactLayer = pre_STUDY_ImpactLayer;
  }
}






String[] SOLARCHVISION_getfiles (String _Folder) {
  File dir = new File(_Folder);

  String[] filenames = dir.list();

  if (filenames != null) {
    for (int i = 0; i < filenames.length; i++) {
      //println(filenames[i]);
    }
  }
  return filenames;
}



int SOLARCHVISION_getOpacity (float STUDY_O_scale) {
  int k = int(STUDY_O_scale * 0.01 * 256);
  if (k > 255) k = 255;
  if (k < 0) k = 0;

  return k;
}


float asin_ang (float a) {
  return ((asin(a)) * 180/PI);
}

float acos_ang (float a) {
  return ((acos(a)) * 180/PI);
}

float atan_ang (float a) {
  return ((atan(a)) * 180/PI);
}

float atan2_ang (float a, float b) {
  return ((atan2(a, b)) * 180/PI);
}


float sin_ang (float a) {
  return sin(a * PI / 180);
}

float cos_ang (float a) {
  return cos(a * PI / 180);
}

float tan_ang (float a) {
  return tan(a * PI / 180);
}




float roundTo (float a, float b) {
  float a_floor = (floor (a / (1.0 * b))) * b;
  float a_ceil =  (ceil (a / (1.0 * b))) * b;
  float c;
  if ((a - a_floor) > (a_ceil - a)) {
    c = a_ceil;
  } else {
    c = a_floor;
  }
  return c;
}

float dist_lon_lat (double lon1, double lat1, double lon2, double lat2) {

  float dLon = (float) (lon2 - lon1); 
  float dLat = (float) (lat2 - lat1);

  float a = sin_ang(dLon / 2.0);
  float b = sin_ang(dLat / 2.0) * sin_ang(dLat / 2.0) + cos_ang((float) lat1) * cos_ang((float) lat2) * a * a;
  float d = 2 * atan2(sqrt(b), sqrt(1 - b)) * (float) DOUBLE_r_Earth; 

  return(d);
}

float SOLARCHVISION_fn_dist (float[] a, float[] b) {

  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(b[i] - a[i], 2);
  }
  d = pow(d, 0.5);

  return d;
}

float[] SOLARCHVISION_fn_G (float[][] a) {

  float[] b = a[0]; // initializing to the first node

  // adding other nodes
  for (int i = 1; i < a.length; i++) {
    for (int j = 0; j < b.length; j++) {
      b[j] += a[i][j];
    }
  }

  // dividing to the number of nodes
  for (int j = 0; j < b.length; j++) {
    b[j] /= float(a.length);
  }

  return b;
}

float[] SOLARCHVISION_fn_normalize (float[] a) {
  float[] b = a;
  float d = 0;
  for (int i = 0; i < a.length; i++) {
    d += pow(a[i], 2);
  }
  d = pow(d, 0.5);

  for (int i = 0; i < a.length; i++) {
    if (d != 0) b[i] = a[i]/d;
    else b[i] = 0;
  } 
  return b;
}

float SOLARCHVISION_fn_dot (float[] a, float b[]) {
  float d = 0;
  for (int i = 0; i < min (a.length, b.length); i++) {
    d += a[i] * b[i];
  }
  return d;
}

float SOLARCHVISION_3xDot (float[] a, float b[]) {
  
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

float[] SOLARCHVISION_3xCross (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[1] * b[2] - a[2] * b[1];
  c[1] = a[2] * b[0] - a[0] * b[2];
  c[2] = a[0] * b[1] - a[1] * b[0];
  
  return c;
  
}


float[] SOLARCHVISION_3xSub (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[0] - b[0];
  c[1] = a[1] - b[1];
  c[2] = a[2] - b[2];
  
  return c;
  
}


float[] SOLARCHVISION_3xSum (float[] a, float b[]) {
  
  float[] c = new float [3];
  
  c[0] = a[0] + b[0];
  c[1] = a[1] + b[1];
  c[2] = a[2] + b[2];
  
  return c;
  
}


float SOLARCHVISION_Bilinear (float f_00, float f_10, float f_11, float f_01, float x, float y) {

  float f_xy = f_00 * (1 - x) * (1 - y) + f_10 * x * (1 - y) + f_01 * (1 - x) * y + f_11 * x * y;

  return f_xy;
}




float[] SOLARCHVISION_WBGRW (float _variable) {
  _variable *= 600.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };

  if (_variable < 0) {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  } else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  } else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = 255;
    COL[2] = v;
    COL[3] = v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }

  return COL;
}

float[] SOLARCHVISION_BGR (float _variable) {
  _variable *= 400.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };

  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 255;
  } else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}

float[] SOLARCHVISION_DBGR (float _variable) {
  _variable *= 500.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = v;
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  } else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}

float[] SOLARCHVISION_DWBGR (float _variable) {
  _variable *= 600.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  } else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}

float[] SOLARCHVISION_DWYR (float _variable) {
  _variable *= 400.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < 0) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < 100) {
    v = ((_variable) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 255 - 0.5 * v;
    COL[2] = 0;
    COL[3] = 0;
  } else {
    COL[1] = 127;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}


float[] SOLARCHVISION_VDWBGR (float _variable) {
  _variable *= 700.0;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < 0) {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 255;
  } else if (_variable < 100) {
    v = ((_variable - 0) * 2.55);
    COL[1] = (255 - v);
    COL[2] = 0;
    COL[3] = (255 - v);
  } else if (_variable < 200) {
    v = ((_variable - 100) * 2.55);
    COL[1] = v;
    COL[2] = v;
    COL[3] = v;
  } else if (_variable < 300) {
    v = ((_variable - 200) * 2.55);
    COL[1] = (255 - v);
    COL[2] = (255 - v);
    COL[3] = 255;
  } else if (_variable < 400) {
    v = ((_variable - 300) * 2.55);
    COL[1] = 0;
    COL[2] = v;
    COL[3] = 255;
  } else if (_variable < 500) {
    v = ((_variable - 400) * 2.55);
    COL[1] = 0;
    COL[2] = 255;
    COL[3] = (255 - v);
  } else if (_variable < 600) {
    v = ((_variable - 500) * 2.55);
    COL[1] = v;
    COL[2] = 255;
    COL[3] = 0;
  } else if (_variable < 700) {
    v = ((_variable - 600) * 2.55);
    COL[1] = 255;
    COL[2] = (255 - v);
    COL[3] = 0;
  } else {
    COL[1] = 255;
    COL[2] = 0;
    COL[3] = 0;
  }

  return COL;
}

float[] SOLARCHVISION_DRYWCBD (float _variable) {

  _variable *= 1.5;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable <= -2.75) {
    COL[1] = 63;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else if (_variable < 1) {
    v = (_variable * 255);
    COL[1] = 255 - v;
    COL[2] = 255;
    COL[3] = 255;
  } else if (_variable < 2) {
    v = ((_variable - 1) * 255);
    COL[1] = 0;
    COL[2] = 255 - v;
    COL[3] = 255;
  } else if (_variable < 2.75) {
    v = ((_variable - 2) * 255);
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 255 - v;
  } else {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 63;
  }

  return COL;
}


float[] SOLARCHVISION_DBCW (float _variable) {
  _variable = 1 - _variable;
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }

  float r, g, b;
  r = COL[3]; 
  g = COL[2];
  b = COL[1];
  COL[1] = r;
  COL[2] = g;
  COL[3] = b;

  return COL;
}


float[] SOLARCHVISION_GET_COLOR_STYLE (int COLOR_STYLE_Active, float j) {
  float[] c = {
    255, 0, 0, 0
  };

  if (COLOR_STYLE_Active == 0) {
    c[0] = SOLARCHVISION_getOpacity(STUDY_O_scale);
    c[1] = 0;
    c[2] = 0;
    c[3] = 0;
  } else if (COLOR_STYLE_Active == 19) {
    float[] COL = SOLARCHVISION_DWYR(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 18) {
    float[] COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5));
    c[0] = 255;
    c[1] = COL[3];
    c[2] = COL[2];
    c[3] = COL[1];
  } else if (COLOR_STYLE_Active == 17) {
    float[] COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5));
    c[0] = 255;
    c[1] = 255 - COL[3];
    c[2] = 255 - COL[2];
    c[3] = 255 - COL[1];
  } else if (COLOR_STYLE_Active == 16) {
    float[] COL = SOLARCHVISION_DBCW(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 15) {
    float[] COL = SOLARCHVISION_DRYW(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 14) {
    float[] COL = SOLARCHVISION_DBGR(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 13) {
    float[] COL = SOLARCHVISION_DWBGR(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 12) {
    float[] COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 11) {
    float[] COL = SOLARCHVISION_BGR(j);
    c[0] = 127;
    c[1] = 255 - 0.5 * COL[1];
    c[2] = 255 - 0.5 * COL[2];
    c[3] = 255 - 0.5 * COL[3];
    STUDY_Diagrams.stroke(255 - 0.5 * COL[1], 255 - 0.5 * COL[2], 255 - 0.5 * COL[3], 127);
  } else if (COLOR_STYLE_Active == 10) {
    float[] COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = 255 - COL[1];
    c[2] = 255 - COL[2];
    c[3] = 255 - COL[3];
  } else if (COLOR_STYLE_Active == 9) {
    float[] COL = SOLARCHVISION_WBGRW(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 8) {
    float[] COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = 255 - COL[1];
    c[2] = 255 - COL[2];
    c[3] = 255 - COL[3];
  } else if (COLOR_STYLE_Active == 7) {
    float[] COL = SOLARCHVISION_WBGRW(j);
    c[0] = 255;
    c[1] = 255 - COL[1];
    c[2] = 255 - COL[2];
    c[3] = 255 - COL[3];
  } else if (COLOR_STYLE_Active == 6) {
    float[] COL = SOLARCHVISION_BGR(j);
    c[0] = 255;
    c[1] = COL[3];
    c[2] = COL[2];
    c[3] = COL[1];
  } else if (COLOR_STYLE_Active == 4) {
    float[] COL = SOLARCHVISION_VDWBGR(j);
    c[0] = STUDY_O_scale;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 3) {
    float[] COL = SOLARCHVISION_VDWBGR(j);
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 2) {
    float[] COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5));
    c[0] = STUDY_O_scale;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 1) {
    float[] COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5));
    c[0] = 255;
    c[1] = COL[1];
    c[2] = COL[2];
    c[3] = COL[3];
  } else if (COLOR_STYLE_Active == 5) {
    c[0] = 255;
    c[1] = 0;
    c[2] = 0;
    c[3] = 0;
  } else if (COLOR_STYLE_Active == -1) {
    float[] COL = SOLARCHVISION_DRYWCBD(2.0 * (j - 0.5));
    c[0] = 255;
    c[1] = 255 - COL[3];
    c[2] = 255 - COL[2];
    c[3] = 255 - COL[1];
  } 


  return c;
}


void SOLARCHVISION_Calendar () {
  CalendarMM = new String [365][2];
  CalendarDD = new String [365][2];
  CalendarDay = new String [365][2];

  CalendarDate = new int [365][2];

  int k = 285;
  for (int l = 0; l < 2; l += 1) {
    for (int i = 0; i < 12; i += 1) {
      for (int j = 0; j < CalendarLength[i]; j += 1) {
        k += 1;
        if (k == 365) k = 0; 
        CalendarMM[k][l] = CalendarMonth[i][l];
        CalendarDD[k][l] = String.valueOf(j + 1);
        CalendarDay[k][l] = CalendarDD[k][l] + " " + CalendarMM[k][l];

        CalendarDate[k][0] = i + 1;
        CalendarDate[k][1] = j + 1;
      }
    }
  }
}

int SOLARCHVISION_Convert2Day (int Date_Angle) {
  int DAY = (Date_Angle + 360) % 360;
  if (DAY >=  31) DAY += 1;
  if (DAY >=  62) DAY += 1;
  if (DAY >=  93) DAY += 1;
  if (DAY >= 124) DAY += 1;
  if (DAY >= 155) DAY += 1;
  DAY = DAY % 365;
  return DAY;
}

int SOLARCHVISION_Convert2Date (int TIME_Month, int TIME_Day) {
  int k = 0;
  for (int i = 0; i < (TIME_Month - 1); i += 1) {
    for (int j = 0; j < CalendarLength[i]; j += 1) {
      k += 1;
      if (k == 365) k = 0;
    }
  }
  k += TIME_Day - 1;

  k = k % 365;
  return k;
}

void SOLARCHVISION_update_date () {
  TIME_Month = CalendarDate[int(TIME_Date)][0]; 
  TIME_Day = CalendarDate[int(TIME_Date)][1];
  TIME_Hour = int(24 * (TIME_Date - int(TIME_Date)));
}



void SOLARCHVISION_try_update_FORECAST_ENSEMBLE (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  FORECAST_ENSEMBLE_XML_Files = SOLARCHVISION_getfiles(FORECAST_ENSEMBLE_directory); // slow <<<<<<<<<<<< this line didn't work well below... but it is rather slow here! 

  FORECAST_ENSEMBLE_Data = new float [24][365][num_Layers][(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)];
  FORECAST_ENSEMBLE_Flags = new int [24][365][num_Layers][(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)]; // -1: undefined, 0: interpolated, 1: data

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_Layers; l += 1) {
        for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) {
          FORECAST_ENSEMBLE_Data[i][j][l][k] = FLOAT_undefined;
          FORECAST_ENSEMBLE_Flags[i][j][l][k] = -1;
        }
      }
    }
  }

  if (LoadButton_FORECAST_ENSEMBLE == 1) {

    int any_file_downloaded = 0;

    for (int f = 0; f < num_Layers; f++) {
      if (LAYERS_Text[f].equals("")) {
      } else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + Defined_Stations[STATION_Number][8] + "_" + LAYERS_Text[f] + "_000-384.xml";

        int File_Found = -1;

        //println(FN);
        for (int i = FORECAST_ENSEMBLE_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
          //println(FORECAST_ENSEMBLE_XML_Files[i]); 

          if (FORECAST_ENSEMBLE_XML_Files[i].equals(FN)) {
            //println("FILE FOUND:", FN);
            File_Found = i;

            break; // <<<<<<<<<<
          }
        }

        if (File_Found == -1) {
          if (Download_FORECAST_ENSEMBLE == 1) {
            String the_directory = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + nf(THE_HOUR, 2) + "/" + LAYERS_Text[f] + "/raw";
            String the_link = "http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/xml/" + the_directory + "/" + FN + ".bz2";
            String the_target = FORECAST_ENSEMBLE_directory + "/" + FN + ".bz2";

            println("Try downloading: " + the_link);

            try {
              saveBytes(the_target, loadBytes(the_link));

              any_file_downloaded = 1;

              /*
              String[] new_file = {FN};
               FORECAST_ENSEMBLE_XML_Files = concat(FORECAST_ENSEMBLE_XML_Files, new_file); // fast
               //FORECAST_ENSEMBLE_XML_Files = SOLARCHVISION_getfiles(FORECAST_ENSEMBLE_directory); //slow! 
               
               File_Found = FORECAST_ENSEMBLE_XML_Files.length - 1;
               //println("Added:", File_Found);    
               */
            } 
            catch (Exception e) {
              println("LINK NOT AVAILABLE:", the_link);
            }
          }
        }
      }
    }


    if (any_file_downloaded != 0) {
      launch("C:/SOLARCHVISION_2015/BatchFiles/unzipNAEFS.bat".replace('/', char(92)));
      //FORECAST_ENSEMBLE_XML_Files = SOLARCHVISION_getfiles(FORECAST_ENSEMBLE_directory); // slow
    }


    for (int f = 0; f < num_Layers; f++) {
      if (LAYERS_Text[f].equals("")) {
      } else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + Defined_Stations[STATION_Number][8] + "_" + LAYERS_Text[f] + "_000-384.xml";

        int File_Found = -1;

        //println(FN);
        for (int i = FORECAST_ENSEMBLE_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
          //println(FORECAST_ENSEMBLE_XML_Files[i]); 

          if (FORECAST_ENSEMBLE_XML_Files[i].equals(FN)) {
            //println("FILE FOUND:", FN);
            File_Found = i;

            break; // <<<<<<<<<<
          }
        }        


        if (File_Found != -1) SOLARCHVISION_LoadFORECAST_ENSEMBLE((FORECAST_ENSEMBLE_directory + "/" + FN), f);
        else println("FILE NOT FOUND:", FN);
      }
    }



    SOLARCHVISION_postProcess_FORECAST_ENSEMBLE();
  }
}

void SOLARCHVISION_postProcess_FORECAST_ENSEMBLE () {

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  

  for (int l = 0; l < num_Layers; l += 1) {

    if (LAYERS_Text[l].equals("")) {  // <<<<<<<<<< to make it faster but this won't process the HRDPS layers those not available in NAEFS layers!
    } else 
    {
      //////////////////////////////////////  PASS 1  //////////////////////////////////////  

      for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) {
        float pre_v = FLOAT_undefined;
        int pre_num = 0;

        for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
          int j = (int(j_for + TIME_Date + 365 - 286) % 365);

          for (int i = 0; i < 24; i += 1) {

            if (FORECAST_ENSEMBLE_Data[i][j][l][k] > 0.9 * FLOAT_undefined) {
              if (pre_v < 0.9 * FLOAT_undefined) {
                pre_num += 1;

                float next_v = FLOAT_undefined;
                int next_i = i;
                int next_j = j;
                int next_num = 0;
                while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                  next_num += 1;
                  next_i += 1;
                  if (next_i == 24) {
                    next_i -= 24;
                    next_j += 1;
                  }
                  if (next_j == 365) {
                    next_j = 0;
                  }
                  if (FORECAST_ENSEMBLE_Data[next_i][next_j][l][k] > 0.9 * FLOAT_undefined) {
                  } else {
                    next_v = FORECAST_ENSEMBLE_Data[next_i][next_j][l][k];

                    if (l == LAYER_winddir) {
                      if ((next_v - pre_v) > 180) next_v -= 360;
                      if ((next_v - pre_v) < -180) next_v += 360;
                    }
                  }
                }
                if (next_num < MAX_SEARCH) {
                  //if (l == LAYER_winddir) FORECAST_ENSEMBLE_Data[i][j][l][k] = ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360;
                  //else FORECAST_ENSEMBLE_Data[i][j][l][k] = (next_num * pre_v + pre_num * next_v) / (pre_num + next_num);

                  float interpolation_pow = pow(2.0, Interpolation_Weight);

                  FORECAST_ENSEMBLE_Data[i][j][l][k] = (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow));
                  if (l == LAYER_winddir) FORECAST_ENSEMBLE_Data[i][j][l][k] = (FORECAST_ENSEMBLE_Data[i][j][l][k] + 360) % 360;


                  //println("[i][j][l][k]", i, j, l, k);
                  FORECAST_ENSEMBLE_Flags[i][j][l][k] = 0; // On Layers: RH and TMP it didn't work with TIME_ModelRun == 12!!!!!!!!!!!!!!!!!!??????????
                } else {
                  FORECAST_ENSEMBLE_Flags[i][j][l][k] = -1;
                }
              }
            } else {
              FORECAST_ENSEMBLE_Flags[i][j][l][k] = 1;
              pre_v = FORECAST_ENSEMBLE_Data[i][j][l][k];
              pre_num = 0;
            }

            //if ((k == 43) && (FORECAST_ENSEMBLE_Data[i][j][l][k] < 0.9 * FLOAT_undefined)) println(GRIB2_Domains[GRIB2_DomainSelection][0] + ":", i, j, l, FORECAST_ENSEMBLE_Data[i][j][l][k]);
          }
        }
      }

      //////////////////////////////////////  PASS 2  //////////////////////////////////////      

      if (CLIMATIC_WeatherForecast != 0) {

        int keep_STUDY_JoinDays = STUDY_JoinDays;

        STUDY_JoinDays = 7; // 1; for faster results      

        float[][][] _valuesO;
        float[][][] _valuesO_overcast;
        float[][][] _valuesO_scattered;
        float[][][] _valuesO_clear;

        _valuesO           = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];
        _valuesO_overcast  = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];
        _valuesO_scattered = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];
        _valuesO_clear     = new float [24][STUDY_max_j_end_parameters][((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];

        for (int i = 0; i < 24; i += 1) {      

          for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
            for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {

              for (int j = 0; j < STUDY_max_j_end_parameters; j += 1) {

                int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }           


                _valuesO          [i][j][(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                _valuesO_overcast [i][j][(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                _valuesO_scattered[i][j][(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                _valuesO_clear    [i][j][(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined; 

                float Pa = CLIMATE_CWEEDS_Data[i][now_j][l][k];

                if (Pa > 0.9 * FLOAT_undefined) {
                } else {
                  _valuesO[i][j][(k * STUDY_JoinDays + j_ADD)] = Float.valueOf(Pa);

                  if (SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Daily, 2, i, now_j, k) == 1) {
                    _valuesO_overcast[i][j][(k * STUDY_JoinDays + j_ADD)] = Float.valueOf(Pa);
                  }

                  if (SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Daily, 3, i, now_j, k) == 1) {
                    _valuesO_scattered[i][j][(k * STUDY_JoinDays + j_ADD)] = Float.valueOf(Pa);
                  }

                  if (SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Daily, 4, i, now_j, k) == 1) {
                    _valuesO_clear[i][j][(k * STUDY_JoinDays + j_ADD)] = Float.valueOf(Pa);
                  }
                }
              }
            }
          }
        }

        float[][] _valuesH;
        float[][] _valuesH_overcast;
        float[][] _valuesH_scattered;
        float[][] _valuesH_clear;

        _valuesH           = new float [24][STUDY_max_j_end_parameters];
        _valuesH_overcast  = new float [24][STUDY_max_j_end_parameters];
        _valuesH_scattered = new float [24][STUDY_max_j_end_parameters];
        _valuesH_clear     = new float [24][STUDY_max_j_end_parameters];

        for (int i = 0; i < 24; i += 1) {
          for (int j = 0; j < STUDY_max_j_end_parameters; j += 1) {      
            _valuesH          [i][j] = SOLARCHVISION_NORMAL(_valuesO          [i][j])[STAT_N_Middle];
            _valuesH_overcast [i][j] = SOLARCHVISION_NORMAL(_valuesO_overcast [i][j])[STAT_N_Middle];
            _valuesH_scattered[i][j] = SOLARCHVISION_NORMAL(_valuesO_scattered[i][j])[STAT_N_Middle];
            _valuesH_clear    [i][j] = SOLARCHVISION_NORMAL(_valuesO_clear    [i][j])[STAT_N_Middle];

            //if (l == LAYER_drybulb) println("Average at hour", i, ", day", j, "=", _valuesH[i][j]);
          }
        }

        STUDY_JoinDays = keep_STUDY_JoinDays;




        for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) {
          int pre_num = 0;

          float pre_v = FLOAT_undefined;
          int pre_TIME_Hour = -1; // that means it is undefined.
          int pre_TIME_Day = -1; // that means it is undefined.

          for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
            int now_j = (int(j_for + TIME_Date + 365 - 286) % 365);
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }        

            for (int i = 0; i < 24; i += 1) {
              if (FORECAST_ENSEMBLE_Flags[i][now_j][l][k] == 0) { // if it was interpolated then ...

                if (pre_v < 0.9 * FLOAT_undefined) {
                  pre_num += 1;

                  float next_v = FLOAT_undefined;
                  int next_hour = -1; // that means it is undefined.
                  int next_day = -1; // that means it is undefined.

                  int next_i = i;
                  int next_j = now_j;
                  int next_num = 0;

                  while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                    next_num += 1;
                    next_i += 1;
                    if (next_i == 24) {
                      next_i -= 24;
                      next_j += 1;
                    }
                    if (next_j == 365) {
                      next_j = 0;
                    }
                    if (FORECAST_ENSEMBLE_Flags[next_i][next_j][l][k] != 0) { // if it wasn't interpolated then ...
                      next_v = FORECAST_ENSEMBLE_Data[next_i][next_j][l][k];
                      next_hour = next_i;
                      next_day = (int(next_j - TIME_Date + 286 + 365) % 365); 


                      // non-linear post processing for some parameters
                      if ((l == LAYER_drybulb) || (l == LAYER_relhum)) {

                        if ((pre_v < 0.9 * FLOAT_undefined) && (next_v < 0.9 * FLOAT_undefined)) {
                          // replacing linear interpolated forecast with new values based on hourly patterns of observations in recent days.

                          float linear_climate = 0;
                          float current_dist = 0;

                          if (CLIMATIC_WeatherForecast == 1) {
                            linear_climate = (next_num * _valuesH[pre_TIME_Hour][pre_TIME_Day] + pre_num * _valuesH[next_hour][next_day]) / (pre_num + next_num);
                            current_dist = _valuesH[i][j_for] - linear_climate;
                          } else {                    
                            if ((SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Daily, 2, i, now_j, k)) == 1) {
                              linear_climate = (next_num * _valuesH_overcast[pre_TIME_Hour][pre_TIME_Day] + pre_num * _valuesH_overcast[next_hour][next_day]) / (pre_num + next_num);
                              current_dist = _valuesH_overcast[i][j_for] - linear_climate;
                            } else if ((SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Daily, 3, i, now_j, k)) == 1) {
                              linear_climate = (next_num * _valuesH_scattered[pre_TIME_Hour][pre_TIME_Day] + pre_num * _valuesH_scattered[next_hour][next_day]) / (pre_num + next_num);
                              current_dist = _valuesH_scattered[i][j_for] - linear_climate;
                            }
                            //else if ((SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Daily, 4, i, now_j, k)) == 1) {
                            else {
                              linear_climate = (next_num * _valuesH_clear[pre_TIME_Hour][pre_TIME_Day] + pre_num * _valuesH_clear[next_hour][next_day]) / (pre_num + next_num);
                              current_dist = _valuesH_clear[i][j_for] - linear_climate;
                            }
                          }                          


                          FORECAST_ENSEMBLE_Data[i][now_j][l][k] = FORECAST_ENSEMBLE_Data[i][now_j][l][k] + current_dist;
                        }
                      }       


                      if (l == LAYER_winddir) {
                        if ((next_v - pre_v) > 180) next_v -= 360;
                        if ((next_v - pre_v) < -180) next_v += 360;
                      }
                    }
                  }

                  FORECAST_ENSEMBLE_Flags[i][now_j][l][k] = 0;
                } else {
                  FORECAST_ENSEMBLE_Flags[i][now_j][l][k] = -1;
                }
              } else {
                FORECAST_ENSEMBLE_Flags[i][now_j][l][k] = 1;
                pre_v = FORECAST_ENSEMBLE_Data[i][now_j][l][k];
                pre_num = 0;

                pre_TIME_Hour = i;
                pre_TIME_Day = j_for;
              }
            }
          }
        }
      }

      //////////////////////////////////////  END PASS 2  //////////////////////////////////////
    }
  }

  println("Post-processing solar components ...");

  int num_count = (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start);

  for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) {
    for (int j_for = 0; j_for < STUDY_max_j_end_parameters; j_for += 1) { 
      int j = ((j_for + TIME_BeginDay) % 365);
      for (int i = 0; i < 24; i += 1) {
        if (FORECAST_ENSEMBLE_Data[i][j][LAYER_cloudcover][k] > 0.9 * FLOAT_undefined) {
        } else {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(LocationLatitude, DATE_ANGLE, HOUR_ANGLE, FORECAST_ENSEMBLE_Data[i][j][LAYER_cloudcover][k]);
          float T = FORECAST_ENSEMBLE_Data[i][j][LAYER_drybulb][k];

          FORECAST_ENSEMBLE_Data[i][j][LAYER_dirnorrad][k] = SunR[4];
          FORECAST_ENSEMBLE_Flags[i][j][LAYER_dirnorrad][k] = 0;

          FORECAST_ENSEMBLE_Data[i][j][LAYER_difhorrad][k] = SunR[5];
          FORECAST_ENSEMBLE_Flags[i][j][LAYER_difhorrad][k] = 0;

          FORECAST_ENSEMBLE_Data[i][j][LAYER_glohorrad][k] = SunR[4] * SunR[3] + SunR[5];
          FORECAST_ENSEMBLE_Flags[i][j][LAYER_glohorrad][k] = 0;


          //---------------------------------------------------------------------
          if (CLIMATIC_SolarForecast == 1) {

            float Forecast_CC = FORECAST_ENSEMBLE_Data[i][j][LAYER_cloudcover][k];
            float Forecast_AP = FORECAST_ENSEMBLE_Data[i][j][LAYER_pressure][k];

            float CC_epsilon = 1.0; // defines a range for finding near previous results: 1.0 results in e.g. 2 < CC < 4 for CC at 3  
            float AP_epsilon = 50.0;

            float _valuesSUM_DIR = 0;
            float _valuesSUM_DIF = 0;
            float _valuesSUM_GLO = 0;
            float sum_count = 0;

            float process_add_days = 11;

            for (int q = 0; q < num_count; q += 1) {

              for (int j_ADD = 0; j_ADD < process_add_days; j_ADD += 1) { 

                int now_i = i;
                int now_j = int(j + (j_ADD - int(0.5 * process_add_days)) + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }


                if ((CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_cloudcover][q] > 0.9 * FLOAT_undefined) || (CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_pressure][q] > 0.9 * FLOAT_undefined)) {
                } else {
                  float CC_dist = abs(Forecast_CC - CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_cloudcover][q]);
                  float AP_dist = abs(Forecast_AP - CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_pressure][q]);
                  if ((CC_dist < CC_epsilon) && (AP_dist < AP_epsilon)) {

                    float _weight;

                    _weight = 1; 
                    _weight *= pow(abs(1 - pow(CC_dist/CC_epsilon, 2)), 2); // to add more wights to closer cases
                    _weight *= pow(abs(1 - pow(AP_dist/AP_epsilon, 2)), 2);

                    sum_count += _weight;

                    if (CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][q] > 0.9 * FLOAT_undefined) {
                    } else _valuesSUM_DIR += _weight * CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][q]; 
                    if (CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][q] > 0.9 * FLOAT_undefined) {
                    } else _valuesSUM_DIF += _weight * CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][q]; 
                    if (CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_glohorrad][q] > 0.9 * FLOAT_undefined) {
                    } else _valuesSUM_GLO += _weight * CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_glohorrad][q];
                  }
                }
              }
            }

            if (sum_count != 0) {
              _valuesSUM_DIR /= sum_count;
              _valuesSUM_DIF /= sum_count;
              _valuesSUM_GLO /= sum_count;

              FORECAST_ENSEMBLE_Data[i][j][LAYER_dirnorrad][k] = _valuesSUM_DIR;
              FORECAST_ENSEMBLE_Data[i][j][LAYER_difhorrad][k] = _valuesSUM_DIF;
              FORECAST_ENSEMBLE_Data[i][j][LAYER_glohorrad][k] = _valuesSUM_GLO;
            } else {
              //println("Cannot find simillar conditions in climate file at i:", i, ", j:", j, ", k:", k);
            }
          }      

          //---------------------------------------------------------------------

          FORECAST_ENSEMBLE_Data[i][j][LAYER_direffect][k] = FORECAST_ENSEMBLE_Data[i][j][LAYER_dirnorrad][k] * (18 - T);
          FORECAST_ENSEMBLE_Flags[i][j][LAYER_direffect][k] = 0;

          FORECAST_ENSEMBLE_Data[i][j][LAYER_difeffect][k] = FORECAST_ENSEMBLE_Data[i][j][LAYER_difhorrad][k] * (18 - T);
          FORECAST_ENSEMBLE_Flags[i][j][LAYER_difeffect][k] = 0;
        }
      }
    }
  }
}


void SOLARCHVISION_LoadFORECAST_ENSEMBLE (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  int continue_process = 1;

  XML FileALL = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileALL = loadXML(FileName);
  }
  catch (Exception e) {
    println("Can't read:", FileName);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    //println(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

    XML[] children0 = FileALL.getChildren("forecast");

    for (int Li = 0; Li < children0.length; Li++) {

      int _a1 = children0[Li].getInt("forecast_hour");
      String _a2 = children0[Li].getString("valid_time");

      //println("Li=", Li, "hour =", _a1, "date:", _a2);

      if (Li >= 0) {

        int THE_YEAR = int(_a2.substring(0, 4));
        int THE_MONTH = int(_a2.substring(4, 6));
        int THE_DAY = int(_a2.substring(6, 8));
        int THE_HOUR = int(_a2.substring(8));

        //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

        int now_i = int(THE_HOUR);
        int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

        //println(now_i, now_j);

        now_i -= int(-LocationTimeZone / 15);
        if (now_i < 0) {
          now_i += 24;
          now_j -= 1;
          if (now_j < 0) {
            now_j += 365;
          }
        }

        //println(now_i, now_j);
        //println("-------------");

        XML[] _c = children0[Li].getChildren("model");
        //println("number of members:", _c.length);

        for (int Lk = 0; Lk < _c.length; Lk++) {
          int k = _c[Lk].getInt("id") - 1;

          if (k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)) {

            FORECAST_ENSEMBLE_Data[now_i][now_j][Load_Layer][k] = Float.valueOf(_c[Lk].getContent());
          }
        }
      }
    }
  }
}


void SOLARCHVISION_PlotFORECAST_ENSEMBLE (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Pix = (100.0 * STUDY_S_View / STUDY_LevelPix);

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  STUDY_color_data_raws = color(0, 0, 63, SOLARCHVISION_getOpacity(STUDY_O_scale));

  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  int start_z = STUDY_get_startZ_endZ(databaseNumber_FORECAST_ENSEMBLE)[0];
  int end_z = STUDY_get_startZ_endZ(databaseNumber_FORECAST_ENSEMBLE)[1]; 

  if (STUDY_PrintTtitle != 0) {

    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER); 
    STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_CurrentLayer][Language_Active]), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);
  }

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)];
  _valuesB = new float [(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)]; 

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)];
  _valuesNUM = new float [(1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)];

  for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) { 
    _valuesA[k] = FLOAT_undefined;
    _valuesB[k] = FLOAT_undefined;
    _valuesSUM[k] = FLOAT_undefined;
    _valuesNUM[k] = 0;
  }

  float[] Ax_LINES = {
    0
  };
  float[] Ay_LINES = {
    0
  };
  float[] Az_LINES = {
    0
  };
  float[] Bx_LINES = {
    0
  };
  float[] By_LINES = {
    0
  };
  float[] Bz_LINES = {
    0
  };

  FILE_outputRaw = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputNorms = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputProbs = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];

  String Main_name = MAKE_MainName();

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 

    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_Start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

      STUDY_Diagrams.text(CalendarDay[int((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (STUDY_JoinDays > 1) {
        //STUDY_Diagrams.text(("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }

    String _FilenamesAdd = "";
    if (STUDY_JoinDays > 1) {
      //_FilenamesAdd = ("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/FORECAST_node_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputRaw[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(FORECAST)");

      FILE_outputRaw[(j - STUDY_j_Start)].print("Hour\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        FILE_outputRaw[(j - STUDY_j_Start)].print(nf(l, 4) + "        \t");
      }
      FILE_outputRaw[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/FORECAST_norm_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputNorms[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(FORECAST)");
      FILE_outputNorms[(j - STUDY_j_Start)].print("Hour\t");
      for (int l = 0; l < 9; l += 1) {
        FILE_outputNorms[(j - STUDY_j_Start)].print(STAT_N_Title[l] + "\t");
      }
      FILE_outputNorms[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/FORECAST_prob_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputProbs[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(FORECAST)");

      FILE_outputProbs[(j - STUDY_j_Start)].print("Hour:\t");
      FILE_outputProbs[(j - STUDY_j_Start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) FILE_outputProbs[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");

      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

        _valuesA[k] = FLOAT_undefined;
        _valuesB[k] = FLOAT_undefined;

        if ((k + 1) == 22) {
          STUDY_Diagrams.stroke(127, 0, 255, 127); 
          STUDY_Diagrams.fill(127, 0, 255);
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 6);
        } else {
          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(COLOR_STYLE_Active, (1.0 * k / (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)));
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
        }

        int _plot = 1;

        if (_plot == 1) {

          int now_k = k;
          int now_i = i;
          int now_j = (j + TIME_BeginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          int next_i = now_i + TIME_Interval;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = 0; //i % 24;
            next_j += 1; //int((i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
              //next_k += 1;
            }
          }

          Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][STUDY_CurrentLayer][now_k]; 
          if (Pa > 0.9 * FLOAT_undefined) {
            _valuesA[k] = FLOAT_undefined;

            if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
          } else {
            int drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

            if (drw_count == 1) {

              _valuesA[k] = Pa;
              _valuesA[k] += STUDY_V_offset[STUDY_CurrentLayer];

              _valuesSUM[k] += _valuesA[k];
              _valuesNUM[k] += 1;

              if ((FORECAST_ENSEMBLE_Flags[now_i][now_j][STUDY_CurrentLayer][now_k] == 1) && ((STUDY_DisplayRaws == 1))) STUDY_Diagrams.ellipse((j + ((i + 0.5) / 24.0)) * sx_Plot, _valuesA[k] * sy_Plot, 5, 5);

              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
                if (_valuesA[k] < 0.9 * FLOAT_undefined) FILE_outputRaw[(j - STUDY_j_Start)].print(nfs(_valuesA[k] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
                else FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
              }

              if (next_k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start)) {

                Pb = FORECAST_ENSEMBLE_Data[next_i][next_j][STUDY_CurrentLayer][next_k];
                if (Pb > 0.9 * FLOAT_undefined) {
                  _valuesB[k] = FLOAT_undefined;
                } else {
                  _valuesB[k] = Pb;
                  _valuesB[k] += STUDY_V_offset[STUDY_CurrentLayer];

                  if (STUDY_DisplayRaws == 1) {
                    if ((STUDY_CurrentLayer == LAYER_winddir) && (abs(_valuesB[k] - _valuesA[k]) > 180)) {
                    } else {
                      Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                      Ay_LINES = append(Ay_LINES, _valuesA[k] * sy_Plot);
                      Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                      Bx_LINES = append(Bx_LINES, (j + ((i + 0.5 + TIME_Interval) / 24.0)) * sx_Plot);
                      By_LINES = append(By_LINES, _valuesB[k] * sy_Plot);
                      Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                    }
                  }
                }
              }
            } else {
              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("not_the_case\t");
            }
          }
        }
      }

      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].println();

      _interval += 1; 
      if ((_interval % STUDY_SumInterval) == 0) {
        for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
          _valuesSUM[k] += _valuesA[k];
          _valuesNUM[k] += 1;

          if ((_valuesSUM[k] < 0.9 * FLOAT_undefined) && (_valuesNUM[k] != 0)) {
            _valuesSUM[k] /= _valuesNUM[k];
          }
        }    
        if (STUDY_DisplayProbs == 1) {
          SOLARCHVISION_draw_dataProbs(i, j, start_z, end_z, _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }  

        for (int k = 0; k < (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); k += 1) {
          _valuesSUM[k] = 0;
          _valuesNUM[k] = 0;
        }
      }        

      if (STUDY_DisplaySorted == 1) {
        SOLARCHVISION_draw_data_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (STUDY_DisplayNormals == 1) {
        SOLARCHVISION_draw_data_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)].println("Source: " + nf(TIME_Year, 4) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + nf(TIME_Hour, 2) + "_GEPS-NAEFS-RAW_" + Defined_Stations[STATION_Number][8] + "_" + LAYERS_Text[STUDY_CurrentLayer] + "_000-384.xml" + ", Environment and Climate Change Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      FILE_outputRaw[(j - STUDY_j_Start)].println("Interpolated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      if (LAYERS_Unit[STUDY_CurrentLayer].equals("kW°C/m²") || LAYERS_Unit[STUDY_CurrentLayer].equals("W/m²")) FILE_outputRaw[(j - STUDY_j_Start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      FILE_outputRaw[(j - STUDY_j_Start)].flush(); 
      FILE_outputRaw[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)].println("Source: " + nf(TIME_Year, 4) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + nf(TIME_Hour, 2) + "_GEPS-NAEFS-RAW_" + Defined_Stations[STATION_Number][8] + "_" + LAYERS_Text[STUDY_CurrentLayer] + "_000-384.xml" + ", Environment and Climate Change Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      FILE_outputNorms[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputNorms[(j - STUDY_j_Start)].println("* : SOLARCHVISION internal algorithm");
      if (LAYERS_Unit[STUDY_CurrentLayer].equals("kW°C/m²") || LAYERS_Unit[STUDY_CurrentLayer].equals("W/m²")) FILE_outputNorms[(j - STUDY_j_Start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      FILE_outputNorms[(j - STUDY_j_Start)].flush(); 
      FILE_outputNorms[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)].println("Source: " + nf(TIME_Year, 4) + nf(TIME_Month, 2) + nf(TIME_Day, 2) + nf(TIME_Hour, 2) + "_GEPS-NAEFS-RAW_" + Defined_Stations[STATION_Number][8] + "_" + LAYERS_Text[STUDY_CurrentLayer] + "_000-384.xml" + ", Environment and Climate Change Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/");
      FILE_outputProbs[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      if (LAYERS_Unit[STUDY_CurrentLayer].equals("kW°C/m²") || LAYERS_Unit[STUDY_CurrentLayer].equals("W/m²")) FILE_outputProbs[(j - STUDY_j_Start)].println("Note: direct and diffuse radiation models are derived form cloud cover and air pressure information using SOLARCHVISION program.");
      FILE_outputProbs[(j - STUDY_j_Start)].flush(); 
      FILE_outputProbs[(j - STUDY_j_Start)].close();
    }
  }

  if (STUDY_DisplayRaws == 1) {
    SOLARCHVISION_draw_dataRaws(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }    

  STUDY_Diagrams.popMatrix();
} 


void SOLARCHVISION_try_update_CLIMATE_CWEEDS () {


  CLIMATE_CWEEDS_Data = new float [24][365][num_Layers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)];

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_Layers; l += 1) {
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
          CLIMATE_CWEEDS_Data[i][j][l][k] = FLOAT_undefined;
        }
      }
    }
  }


  if (LoadButton_CLIMATE_CWEEDS == 1) {

    String FN = Defined_Stations[STATION_Number][9] + ".wy2";

    int File_Found = -1;

    //println(FN);
    for (int i = 0; i < CLIMATE_CWEEDS_Files.length; i++) {

      if (CLIMATE_CWEEDS_Files[i].toLowerCase().equals(FN.toLowerCase())) {
        //println("FILE FOUND:", FN);
        File_Found = i;

        break; // <<<<<<<<<<
      }
    }

    if (File_Found != -1) SOLARCHVISION_LoadCLIMATE_CWEEDS((CLIMATE_CWEEDS_directory + "/" + FN));
    else println("FILE NOT FOUND:", FN);
  }
}


void SOLARCHVISION_LoadCLIMATE_CWEEDS (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f += 1) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    int CLIMATE_YEAR = int(lineSTR.substring(6, 10));
    int CLIMATE_MONTH = int(lineSTR.substring(10, 12));
    int CLIMATE_DAY = int(lineSTR.substring(12, 14));
    int CLIMATE_HOUR = int(lineSTR.substring(14, 16));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CWEEDS_start);

    //println(i);

    CLIMATE_CWEEDS_Data[i][j][LAYER_pressure][k] = float(lineSTR.substring(85, 90)); // 10 times in Pa
    CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k] = float(lineSTR.substring(91, 95)); // 10 times in °C
    //CLIMATE_CWEEDS_Data[i][j][LAYER_relhum][k] = 50; // Relative Humidity is not presented in DCLIMATE files!
    CLIMATE_CWEEDS_Data[i][j][LAYER_glohorrad][k] = float(lineSTR.substring(20, 24)); // Wh/m²
    CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k] = float(lineSTR.substring(26, 30)); // Wh/m²
    CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k] = float(lineSTR.substring(32, 36)); // Wh/m²
    CLIMATE_CWEEDS_Data[i][j][LAYER_windspd][k] = float(lineSTR.substring(105, 109)); // 10 times in m/s
    CLIMATE_CWEEDS_Data[i][j][LAYER_winddir][k] = float(lineSTR.substring(101, 104)); // °
    CLIMATE_CWEEDS_Data[i][j][LAYER_cloudcover][k] = float(lineSTR.substring(113, 115)); // 0.1 times in %
    CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] = float(lineSTR.substring(61, 65)); // 0.1 times in m

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_pressure][k] == 99999) CLIMATE_CWEEDS_Data[i][j][LAYER_pressure][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_pressure][k] = 0.1 * CLIMATE_CWEEDS_Data[i][j][LAYER_pressure][k];

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k] = 0.1 * CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k];

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_glohorrad][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_glohorrad][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_glohorrad][k] = CLIMATE_CWEEDS_Data[i][j][LAYER_glohorrad][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k] = CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k] = CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_windspd][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_windspd][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_windspd][k] = 0.1 * 3.6 * CLIMATE_CWEEDS_Data[i][j][LAYER_windspd][k];

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_winddir][k] == 999) CLIMATE_CWEEDS_Data[i][j][LAYER_winddir][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_cloudcover][k] == 99) CLIMATE_CWEEDS_Data[i][j][LAYER_cloudcover][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] == 7777) CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] = 1000;
    if (CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] >= 1000) CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] = 1000; // <<<<<<<<<

    if (CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] == 9999) CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k] = 10 * CLIMATE_CWEEDS_Data[i][j][LAYER_ceilingsky][k];
  }

  float Pa, Pb, Pc;
  float T, R_dir, R_dif;
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
        Pa = CLIMATE_CWEEDS_Data[i][j][LAYER_drybulb][k];
        Pb = CLIMATE_CWEEDS_Data[i][j][LAYER_dirnorrad][k];
        Pc = CLIMATE_CWEEDS_Data[i][j][LAYER_difhorrad][k];

        if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined)) {
        } else {
          T = Pa;
          R_dir = Pb;
          R_dif = Pc;
          CLIMATE_CWEEDS_Data[i][j][LAYER_direffect][k] = (18 - T) * R_dir;
          CLIMATE_CWEEDS_Data[i][j][LAYER_difeffect][k] = (18 - T) * R_dif;
        }
      }
    }
  }
}


void SOLARCHVISION_PlotCLIMATE_CWEEDS (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  STUDY_Pix = (100.0 * STUDY_S_View / STUDY_LevelPix);

  int start_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_CWEEDS)[0];
  int end_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_CWEEDS)[1]; 

  if (STUDY_PrintTtitle != 0) {

    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER);
    STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_CurrentLayer][Language_Active]), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);
  }   

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];
  _valuesB = new float [((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];
  _valuesNUM = new float [((1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start) * STUDY_JoinDays)];

  float[] Ax_LINES = {
    0
  };
  float[] Ay_LINES = {
    0
  };
  float[] Az_LINES = {
    0
  };
  float[] Bx_LINES = {
    0
  };
  float[] By_LINES = {
    0
  };
  float[] Bz_LINES = {
    0
  };

  FILE_outputRaw = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputNorms = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputProbs = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];

  String Main_name = MAKE_MainName();

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_Start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

      STUDY_Diagrams.text(CalendarDay[int((365 + j * STUDY_PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (STUDY_JoinDays > 1) {
        //STUDY_Diagrams.text(("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }    

    String _FilenamesAdd = "";
    if (STUDY_JoinDays > 1) {
      _FilenamesAdd = ("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/Climate_node_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CWEEDS_start) + "_to_" + String.valueOf(end_z + CLIMATE_CWEEDS_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputRaw[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(CWEED)");

      FILE_outputRaw[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        FILE_outputRaw[(j - STUDY_j_Start)].print(nf(l, 4) + "        \t");
      }
      FILE_outputRaw[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_norm_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CWEEDS_start) + "_to_" + String.valueOf(end_z + CLIMATE_CWEEDS_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputNorms[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(CWEED)");
      FILE_outputNorms[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = 0; l < 9; l += 1) {
        FILE_outputNorms[(j - STUDY_j_Start)].print(STAT_N_Title[l] + "\t");
      }
      FILE_outputNorms[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_prob_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CWEEDS_start) + "_to_" + String.valueOf(end_z + CLIMATE_CWEEDS_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputProbs[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(CWEED)");

      FILE_outputProbs[(j - STUDY_j_Start)].print("Hour:\t");
      FILE_outputProbs[(j - STUDY_j_Start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) FILE_outputProbs[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");

      for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
        for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {

          _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
          _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(COLOR_STYLE_Active, (1.0 * k / (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)));
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          int _plot = 0;

          if ((start_z <= k) && (end_z >= k)) {
            _plot = 1;
          }

          if (_plot == 1) {

            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;


            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }

            Pa = CLIMATE_CWEEDS_Data[now_i][now_j][STUDY_CurrentLayer][now_k]; 
            if (Pa > 0.9 * FLOAT_undefined) {
              _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
            } else {
              int drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

              if (drw_count == 1) {
                _valuesA[(k * STUDY_JoinDays + j_ADD)] = Pa;
                _valuesA[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
                _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
                  if (_valuesA[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) FILE_outputRaw[(j - STUDY_j_Start)].print(nfs(_valuesA[(k * STUDY_JoinDays + j_ADD)] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
                  else FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
                }

                if (next_k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)) {
                  Pb = CLIMATE_CWEEDS_Data[next_i][next_j][STUDY_CurrentLayer][next_k];
                  if (Pb > 0.9 * FLOAT_undefined) {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = Pb;
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                    if (STUDY_DisplayRaws == 1) {
                      if ((STUDY_CurrentLayer == LAYER_winddir) && (abs(_valuesB[(k * STUDY_JoinDays + j_ADD)] - _valuesA[(k * STUDY_JoinDays + j_ADD)]) > 180)) {
                      } else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                      }
                    }
                  }
                }
              } else {
                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("not_the_case\t");
              }
            }
          }
        }
      }

      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].println();

      _interval += 1; 
      if ((_interval % STUDY_SumInterval) == 0) {
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

            if ((_valuesSUM[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) && (_valuesNUM[(k * STUDY_JoinDays + j_ADD)] != 0)) {
              _valuesSUM[(k * STUDY_JoinDays + j_ADD)] /= _valuesNUM[(k * STUDY_JoinDays + j_ADD)];
            }
          }
        }        
        if (STUDY_DisplayProbs == 1) {
          SOLARCHVISION_draw_dataProbs(i, j, ((start_z - 1) * STUDY_JoinDays + 1), ((end_z - 1) * STUDY_JoinDays + STUDY_JoinDays), _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] = 0;
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] = 0;
          }
        }
      }      

      if (STUDY_DisplaySorted == 1) {
        SOLARCHVISION_draw_data_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (STUDY_DisplayNormals == 1) {
        SOLARCHVISION_draw_data_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputRaw[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputRaw[(j - STUDY_j_Start)].flush(); 
      FILE_outputRaw[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputNorms[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputNorms[(j - STUDY_j_Start)].println("* : SOLARCHVISION internal algorithm");
      FILE_outputNorms[(j - STUDY_j_Start)].flush(); 
      FILE_outputNorms[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputProbs[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputProbs[(j - STUDY_j_Start)].flush(); 
      FILE_outputProbs[(j - STUDY_j_Start)].close();
    }
  }

  if (STUDY_DisplayRaws == 1) {
    SOLARCHVISION_draw_dataRaws(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }       

  STUDY_Diagrams.popMatrix();
} 


void SOLARCHVISION_try_update_CLIMATE_CLMREC () {


  CLIMATE_CLMREC_Data = new float [24][365][num_Layers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)];

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_Layers; l += 1) {
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
          CLIMATE_CLMREC_Data[i][j][l][k] = FLOAT_undefined;
        }
      }
    }
  }



  if (LoadButton_CLIMATE_CLMREC == 1) {

    int nearest_Station_CLMREC_id = -1;
    float nearest_Station_CLMREC_dist = FLOAT_undefined;
    
    for (int f = 0; f < STATION_CLMREC_INFO.length; f += 1) {
      
      if (int(STATION_CLMREC_INFO[f][10]) == 2016) { // only use stations with this condition

        float _lat = float(STATION_CLMREC_INFO[f][3]);
        float _lon = float(STATION_CLMREC_INFO[f][4]); 
        if (_lon > 180) _lon -= 360; // << important!
  
        float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);
  
        if (nearest_Station_CLMREC_dist > d) {
  
          nearest_Station_CLMREC_dist = d;
          nearest_Station_CLMREC_id = f;
        }
      }
    }


    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
      for (int m = 0; m < 12; m++) {
      
        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;
  
        int File_Found = -1;    
    
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + STATION_CLMREC_INFO[nearest_Station_CLMREC_id][0] + ".csv";
    
        println(FN);
        for (int i = 0; i < CLIMATE_CLMREC_Files.length; i++) {
    
          if (CLIMATE_CLMREC_Files[i].toLowerCase().equals(FN.toLowerCase())) {
            //println("FILE FOUND:", FN);
            File_Found = i;
    
            break; // <<<<<<<<<<
          }
        }
    
        if ((File_Found == -1) && (Download_CLMREC != 0)) {
          
          String the_link = "http://climate.weather.gc.ca/climateData/bulkdata_e.html?format=csv&stationID=" + STATION_CLMREC_INFO[nearest_Station_CLMREC_id][6] + "&Year=" + nf(THE_YEAR, 4) + "&Month=" + nf(THE_MONTH, 2) + "&timeframe=1";
          String the_target = CLIMATE_CLMREC_directory + "/" + FN;
    
          println("Try downloading: " + the_link);
    
          try {
            saveBytes(the_target, loadBytes(the_link));
    
            String[] new_file = {
              FN
            };
            CLIMATE_CLMREC_Files = concat(CLIMATE_CLMREC_Files, new_file);
    
            File_Found = CLIMATE_CLMREC_Files.length - 1;
            println("Added:", File_Found);
          } 
          catch (Exception e) {
          }
          
        }    
        
    
        if (File_Found != -1) SOLARCHVISION_LoadCLIMATE_CLMREC((CLIMATE_CLMREC_directory + "/" + FN));
        else println("FILE NOT FOUND:", FN);
      }
    }
  }
  

  SOLARCHVISION_postProcess_CLIMATE_CLMREC();
}


void SOLARCHVISION_LoadCLIMATE_CLMREC (String FileName) {

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  println("lines = ", FileALL.length);

  for (int f = 18; f < FileALL.length; f += 1) {

    lineSTR = FileALL[f];
    //println(lineSTR);
    
    lineSTR = lineSTR.replace("\"", ""); 
    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[1]);
    int CLIMATE_MONTH = int(parts[2]);
    int CLIMATE_DAY = int(parts[3]);
    int CLIMATE_HOUR = int(parts[4].substring(0, 2));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR);
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CLMREC_start);

    //println(i);
    
    if (parts.length > 24) {
      
      String str = "";
      
      str = parts[24];
      
      println(str);
       
      if (str.equals("NA")) CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = FLOAT_undefined;
      else if (str.equals("Clear")) CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = 0;
      else if (str.equals("Mainly Clear")) CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = 2.5;
      else if (str.equals("Mostly Cloudy")) CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = 5;
      else if (str.equals("Cloudy")) CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = 7.5;
      else CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] = 10;
      
      println(CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k]);
    
      str = parts[6];
      if (!str.equals("")) CLIMATE_CLMREC_Data[i][j][LAYER_drybulb][k] = float(str); // °C

      str = parts[10];
      if (!str.equals("")) CLIMATE_CLMREC_Data[i][j][LAYER_relhum][k] = float(str); // %

      str = parts[12];
      if (!str.equals("")) CLIMATE_CLMREC_Data[i][j][LAYER_winddir][k] = float(str) * 10; // °

      str = parts[14];
      if (!str.equals("")) CLIMATE_CLMREC_Data[i][j][LAYER_windspd][k] = float(str); // km/h

      str = parts[18];
      if (!str.equals("")) CLIMATE_CLMREC_Data[i][j][LAYER_pressure][k] = float(str) * 10; // hPa


    }
  }
  
}



void SOLARCHVISION_postProcess_CLIMATE_CLMREC () {

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  

  for (int l = 0; l < num_Layers; l += 1) {

    if (LAYERS_Text[l].equals("")) {  // <<<<<<<<<< to make it faster but this won't process the HRDPS layers those not available in NAEFS layers!
    } else 
    {
      
      for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
        float pre_v = FLOAT_undefined;
        int pre_num = 0;

        for (int j = 0; j < 365; j += 1) { 

          for (int i = 0; i < 24; i += 1) {

            if (CLIMATE_CLMREC_Data[i][j][l][k] > 0.9 * FLOAT_undefined) {
              if (pre_v < 0.9 * FLOAT_undefined) {
                pre_num += 1;

                float next_v = FLOAT_undefined;
                int next_i = i;
                int next_j = j;
                int next_num = 0;
                while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                  next_num += 1;
                  next_i += 1;
                  if (next_i == 24) {
                    next_i -= 24;
                    next_j += 1;
                  }
                  if (next_j == 365) {
                    next_j = 0;
                  }
                  if (CLIMATE_CLMREC_Data[next_i][next_j][l][k] > 0.9 * FLOAT_undefined) {
                  } else {
                    next_v = CLIMATE_CLMREC_Data[next_i][next_j][l][k];

                    if (l == LAYER_winddir) {
                      if ((next_v - pre_v) > 180) next_v -= 360;
                      if ((next_v - pre_v) < -180) next_v += 360;
                    }
                  }
                }
                if (next_num < MAX_SEARCH) {
                  //if (l == LAYER_winddir) CLIMATE_CLMREC_Data[i][j][l][k] = ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360;
                  //else CLIMATE_CLMREC_Data[i][j][l][k] = (next_num * pre_v + pre_num * next_v) / (pre_num + next_num);

                  float interpolation_pow = pow(2.0, Interpolation_Weight);

                  CLIMATE_CLMREC_Data[i][j][l][k] = (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow));
                  if (l == LAYER_winddir) CLIMATE_CLMREC_Data[i][j][l][k] = (CLIMATE_CLMREC_Data[i][j][l][k] + 360) % 360;


                  //println("[i][j][l][k]", i, j, l, k);
                  //CLIMATE_CLMREC_Flags[i][j][l][k] = 0; // On Layers: RH and TMP it didn't work with TIME_ModelRun == 12!!!!!!!!!!!!!!!!!!??????????
                } else {
                  //CLIMATE_CLMREC_Flags[i][j][l][k] = -1;
                }
              }
            } else {
              //CLIMATE_CLMREC_Flags[i][j][l][k] = 1;
              pre_v = CLIMATE_CLMREC_Data[i][j][l][k];
              pre_num = 0;
            }

            //if ((k == 43) && (CLIMATE_CLMREC_Data[i][j][l][k] < 0.9 * FLOAT_undefined)) println(GRIB2_Domains[GRIB2_DomainSelection][0] + ":", i, j, l, CLIMATE_CLMREC_Data[i][j][l][k]);
          }
        }
      }

    }
  }

  println("Post-processing solar components ...");

  for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
    for (int j = 0; j < 365; j += 1) { 
      for (int i = 0; i < 24; i += 1) {
        if (CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k] > 0.9 * FLOAT_undefined) {
        } else {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(LocationLatitude, DATE_ANGLE, HOUR_ANGLE, CLIMATE_CLMREC_Data[i][j][LAYER_cloudcover][k]);
          float T = CLIMATE_CLMREC_Data[i][j][LAYER_drybulb][k];

          CLIMATE_CLMREC_Data[i][j][LAYER_dirnorrad][k] = SunR[4];
          //CLIMATE_CLMREC_Flags[i][j][LAYER_dirnorrad][k] = 0;

          CLIMATE_CLMREC_Data[i][j][LAYER_difhorrad][k] = SunR[5];
          //CLIMATE_CLMREC_Flags[i][j][LAYER_difhorrad][k] = 0;

          CLIMATE_CLMREC_Data[i][j][LAYER_glohorrad][k] = SunR[4] * SunR[3] + SunR[5];
          //CLIMATE_CLMREC_Flags[i][j][LAYER_glohorrad][k] = 0;

          CLIMATE_CLMREC_Data[i][j][LAYER_direffect][k] = CLIMATE_CLMREC_Data[i][j][LAYER_dirnorrad][k] * (18 - T);
          //CLIMATE_CLMREC_Flags[i][j][LAYER_direffect][k] = 0;

          CLIMATE_CLMREC_Data[i][j][LAYER_difeffect][k] = CLIMATE_CLMREC_Data[i][j][LAYER_difhorrad][k] * (18 - T);
          //CLIMATE_CLMREC_Flags[i][j][LAYER_difeffect][k] = 0;
        }
      }
    }
  }

}



void SOLARCHVISION_PlotCLIMATE_CLMREC (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  STUDY_Pix = (100.0 * STUDY_S_View / STUDY_LevelPix);

  int start_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_CLMREC)[0];
  int end_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_CLMREC)[1]; 

  if (STUDY_PrintTtitle != 0) {

    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER);
    STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_CurrentLayer][Language_Active]), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);
  }   

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [((1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start) * STUDY_JoinDays)];
  _valuesB = new float [((1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start) * STUDY_JoinDays)];

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [((1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start) * STUDY_JoinDays)];
  _valuesNUM = new float [((1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start) * STUDY_JoinDays)];

  float[] Ax_LINES = {
    0
  };
  float[] Ay_LINES = {
    0
  };
  float[] Az_LINES = {
    0
  };
  float[] Bx_LINES = {
    0
  };
  float[] By_LINES = {
    0
  };
  float[] Bz_LINES = {
    0
  };

  FILE_outputRaw = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputNorms = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputProbs = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];

  String Main_name = MAKE_MainName();

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_Start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

      STUDY_Diagrams.text(CalendarDay[int((365 + j * STUDY_PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (STUDY_JoinDays > 1) {
        //STUDY_Diagrams.text(("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }    

    String _FilenamesAdd = "";
    if (STUDY_JoinDays > 1) {
      _FilenamesAdd = ("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/Climate_node_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CLMREC_start) + "_to_" + String.valueOf(end_z + CLIMATE_CLMREC_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputRaw[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(CWEED)");

      FILE_outputRaw[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        FILE_outputRaw[(j - STUDY_j_Start)].print(nf(l, 4) + "        \t");
      }
      FILE_outputRaw[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_norm_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CLMREC_start) + "_to_" + String.valueOf(end_z + CLIMATE_CLMREC_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputNorms[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(CWEED)");
      FILE_outputNorms[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = 0; l < 9; l += 1) {
        FILE_outputNorms[(j - STUDY_j_Start)].print(STAT_N_Title[l] + "\t");
      }
      FILE_outputNorms[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_prob_" + LocationName + "_from_" + String.valueOf(start_z + CLIMATE_CLMREC_start) + "_to_" + String.valueOf(end_z + CLIMATE_CLMREC_start) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputProbs[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(CWEED)");

      FILE_outputProbs[(j - STUDY_j_Start)].print("Hour:\t");
      FILE_outputProbs[(j - STUDY_j_Start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) FILE_outputProbs[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");

      for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
        for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {

          _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
          _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(COLOR_STYLE_Active, (1.0 * k / (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)));
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          int _plot = 0;

          if ((start_z <= k) && (end_z >= k)) {
            _plot = 1;
          }

          if (_plot == 1) {

            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;


            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }

            Pa = CLIMATE_CLMREC_Data[now_i][now_j][STUDY_CurrentLayer][now_k]; 
            if (Pa > 0.9 * FLOAT_undefined) {
              _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
            } else {
              int drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

              if (drw_count == 1) {
                _valuesA[(k * STUDY_JoinDays + j_ADD)] = Pa;
                _valuesA[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
                _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
                  if (_valuesA[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) FILE_outputRaw[(j - STUDY_j_Start)].print(nfs(_valuesA[(k * STUDY_JoinDays + j_ADD)] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
                  else FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
                }

                if (next_k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)) {
                  Pb = CLIMATE_CLMREC_Data[next_i][next_j][STUDY_CurrentLayer][next_k];
                  if (Pb > 0.9 * FLOAT_undefined) {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = Pb;
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                    if (STUDY_DisplayRaws == 1) {
                      if ((STUDY_CurrentLayer == LAYER_winddir) && (abs(_valuesB[(k * STUDY_JoinDays + j_ADD)] - _valuesA[(k * STUDY_JoinDays + j_ADD)]) > 180)) {
                      } else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                      }
                    }
                  }
                }
              } else {
                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("not_the_case\t");
              }
            }
          }
        }
      }

      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].println();

      _interval += 1; 
      if ((_interval % STUDY_SumInterval) == 0) {
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

            if ((_valuesSUM[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) && (_valuesNUM[(k * STUDY_JoinDays + j_ADD)] != 0)) {
              _valuesSUM[(k * STUDY_JoinDays + j_ADD)] /= _valuesNUM[(k * STUDY_JoinDays + j_ADD)];
            }
          }
        }        
        if (STUDY_DisplayProbs == 1) {
          SOLARCHVISION_draw_dataProbs(i, j, ((start_z - 1) * STUDY_JoinDays + 1), ((end_z - 1) * STUDY_JoinDays + STUDY_JoinDays), _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] = 0;
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] = 0;
          }
        }
      }      

      if (STUDY_DisplaySorted == 1) {
        SOLARCHVISION_draw_data_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (STUDY_DisplayNormals == 1) {
        SOLARCHVISION_draw_data_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputRaw[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputRaw[(j - STUDY_j_Start)].flush(); 
      FILE_outputRaw[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputNorms[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputNorms[(j - STUDY_j_Start)].println("* : SOLARCHVISION internal algorithm");
      FILE_outputNorms[(j - STUDY_j_Start)].flush(); 
      FILE_outputNorms[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][9] + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/");
      FILE_outputProbs[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputProbs[(j - STUDY_j_Start)].flush(); 
      FILE_outputProbs[(j - STUDY_j_Start)].close();
    }
  }

  if (STUDY_DisplayRaws == 1) {
    SOLARCHVISION_draw_dataRaws(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }       

  STUDY_Diagrams.popMatrix();
} 



void SOLARCHVISION_try_update_CLIMATE_TMYEPW () {

  CLIMATE_TMYEPW_Data = new float [24][365][num_Layers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)];

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_Layers; l += 1) {
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k += 1) {
          CLIMATE_TMYEPW_Data[i][j][l][k] = FLOAT_undefined;
        }
      }
    }
  }

  if (LoadButton_CLIMATE_TMYEPW == 1) {

    String FN = Defined_Stations[STATION_Number][10] + ".epw";

    int File_Found = -1;

    //println(FN);
    for (int i = 0; i < CLIMATE_TMYEPW_Files.length; i++) {

      if (CLIMATE_TMYEPW_Files[i].toLowerCase().equals(FN.toLowerCase())) {
        //println("FILE FOUND:", FN);
        File_Found = i;

        break; // <<<<<<<<<<
      }
    }

    if (File_Found != -1) SOLARCHVISION_LoadCLIMATE_TMYEPW((CLIMATE_TMYEPW_directory + "/" + FN));
    else println("FILE NOT FOUND:", FN);
  }
}

void SOLARCHVISION_LoadCLIMATE_TMYEPW (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  //println("lines = ", FileALL.length);

  for (int f = 8; f < FileALL.length; f += 1) {

    lineSTR = FileALL[f];

    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[0]);
    int CLIMATE_MONTH = int(parts[1]);
    int CLIMATE_DAY = int(parts[2]);
    int CLIMATE_HOUR = int(parts[3]);

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = SOLARCHVISION_Convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = 0; // on TMYEPW:TMY files we have only one year 

    //println(i);

    CLIMATE_TMYEPW_Data[i][j][LAYER_pressure][k] = float(parts[9]) * 0.01; // 10 times in Pa
    CLIMATE_TMYEPW_Data[i][j][LAYER_drybulb][k] = float(parts[6]); // in °C
    CLIMATE_TMYEPW_Data[i][j][LAYER_relhum][k] = float(parts[8]); // 0 - 110%
    CLIMATE_TMYEPW_Data[i][j][LAYER_glohorrad][k] = float(parts[13]); // Wh/m²
    CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k] = float(parts[14]); // Wh/m²
    CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k] = float(parts[15]); // Wh/m²
    CLIMATE_TMYEPW_Data[i][j][LAYER_windspd][k] = float(parts[21]); // in m/s
    CLIMATE_TMYEPW_Data[i][j][LAYER_winddir][k] = float(parts[20]); // ° 
    CLIMATE_TMYEPW_Data[i][j][LAYER_cloudcover][k] = float(parts[23]); // 0.1 times in % ... there is also total_sky_cover on[22]
    CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] = float(parts[25]); // in m


    if (CLIMATE_TMYEPW_Data[i][j][LAYER_pressure][k] == 999999) CLIMATE_TMYEPW_Data[i][j][LAYER_pressure][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_drybulb][k] == 99.9) CLIMATE_TMYEPW_Data[i][j][LAYER_drybulb][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_relhum][k] == 999) CLIMATE_TMYEPW_Data[i][j][LAYER_relhum][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_glohorrad][k] == 9999) CLIMATE_TMYEPW_Data[i][j][LAYER_glohorrad][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k] >= 9999) CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k] < 0) CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k] >= 9999) CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k] < 0) CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_windspd][k] == 999) CLIMATE_TMYEPW_Data[i][j][LAYER_windspd][k] = FLOAT_undefined;
    else CLIMATE_TMYEPW_Data[i][j][LAYER_windspd][k] = 3.6 * CLIMATE_TMYEPW_Data[i][j][LAYER_windspd][k];

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_winddir][k] == 999) CLIMATE_TMYEPW_Data[i][j][LAYER_winddir][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_cloudcover][k] == 99) CLIMATE_TMYEPW_Data[i][j][LAYER_cloudcover][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] == 77777) CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] = 1000;
    if (CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] == 88888) CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] = 1000;
    if (CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] >= 1000) CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] = 1000; 

    if (CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] == 99999) CLIMATE_TMYEPW_Data[i][j][LAYER_ceilingsky][k] = FLOAT_undefined;
  }

  float Pa, Pb, Pc;
  float T, R_dir, R_dif;
  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k += 1) {
        Pa = CLIMATE_TMYEPW_Data[i][j][LAYER_drybulb][k];
        Pb = CLIMATE_TMYEPW_Data[i][j][LAYER_dirnorrad][k];
        Pc = CLIMATE_TMYEPW_Data[i][j][LAYER_difhorrad][k];

        if ((Pa > 0.9 * FLOAT_undefined) ||(Pb > 0.9 * FLOAT_undefined) ||(Pc > 0.9 * FLOAT_undefined)) {
        } else {
          T = Pa;
          R_dir = Pb;
          R_dif = Pc;
          CLIMATE_TMYEPW_Data[i][j][LAYER_direffect][k] = (18 - T) * R_dir;
          CLIMATE_TMYEPW_Data[i][j][LAYER_difeffect][k] = (18 - T) * R_dif;
        }
      }
    }
  }
}

void SOLARCHVISION_PlotCLIMATE_TMYEPW (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  STUDY_Pix = (100.0 * STUDY_S_View / STUDY_LevelPix);

  int start_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_TMYEPW)[0];
  int end_z = STUDY_get_startZ_endZ(databaseNumber_CLIMATE_TMYEPW)[1]; 

  if (STUDY_PrintTtitle != 0) {

    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER);
    STUDY_Diagrams.text(("[Typical Year] "), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_CurrentLayer][Language_Active]), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);
  }    

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [((1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start) * STUDY_JoinDays)];
  _valuesB = new float [((1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start) * STUDY_JoinDays)];

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [((1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start) * STUDY_JoinDays)];
  _valuesNUM = new float [((1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start) * STUDY_JoinDays)];

  float[] Ax_LINES = {
    0
  };
  float[] Ay_LINES = {
    0
  };
  float[] Az_LINES = {
    0
  };
  float[] Bx_LINES = {
    0
  };
  float[] By_LINES = {
    0
  };
  float[] Bz_LINES = {
    0
  };

  FILE_outputRaw = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputNorms = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputProbs = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];

  String Main_name = MAKE_MainName();

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

    STUDY_Diagrams.stroke(0);
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.textAlign(CENTER, CENTER); 

    if ((STUDY_U_scale >= 0.75) || (((j - STUDY_j_Start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

      STUDY_Diagrams.text(CalendarDay[int((365 + j * STUDY_PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (j - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (STUDY_JoinDays > 1) {
        //STUDY_Diagrams.text(("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }    

    String _FilenamesAdd = "";
    if (STUDY_JoinDays > 1) {
      _FilenamesAdd = ("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/Climate_node_" + LocationName + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputRaw[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(CWEED)");

      FILE_outputRaw[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        FILE_outputRaw[(j - STUDY_j_Start)].print(nf(l, 4) + "        \t");
      }
      FILE_outputRaw[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_norm_" + LocationName + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputNorms[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(CWEED)");
      FILE_outputNorms[(j - STUDY_j_Start)].print("Hour:\t");
      for (int l = 0; l < 9; l += 1) {
        FILE_outputNorms[(j - STUDY_j_Start)].print(STAT_N_Title[l] + "\t");
      }
      FILE_outputNorms[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "Climate_prob_" + LocationName + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputProbs[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(CWEED)");

      FILE_outputProbs[(j - STUDY_j_Start)].print("Hour:\t");
      FILE_outputProbs[(j - STUDY_j_Start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) FILE_outputProbs[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");

      for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k += 1) {
        for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {

          _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
          _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(COLOR_STYLE_Active, (1.0 * k / (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)));
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          int _plot = 0;

          //if ((start_z <= k + 1) && (end_z >= k + 1)) {
          _plot = 1;
          //}

          if (_plot == 1) {

            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;


            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }

            Pa = CLIMATE_TMYEPW_Data[now_i][now_j][STUDY_CurrentLayer][now_k]; 
            if (Pa > 0.9 * FLOAT_undefined) {
              _valuesA[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;

              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
            } else {
              int drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

              if (drw_count == 1) {
                _valuesA[(k * STUDY_JoinDays + j_ADD)] = Pa;
                _valuesA[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
                _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
                  if (_valuesA[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) FILE_outputRaw[(j - STUDY_j_Start)].print(nfs(_valuesA[(k * STUDY_JoinDays + j_ADD)] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
                  else FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
                }

                if (next_k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)) {
                  Pb = CLIMATE_TMYEPW_Data[next_i][next_j][STUDY_CurrentLayer][next_k];
                  if (Pb > 0.9 * FLOAT_undefined) {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] = Pb;
                    _valuesB[(k * STUDY_JoinDays + j_ADD)] += STUDY_V_offset[STUDY_CurrentLayer];

                    if (STUDY_DisplayRaws == 1) {
                      if ((STUDY_CurrentLayer == LAYER_winddir) && (abs(_valuesB[(k * STUDY_JoinDays + j_ADD)] - _valuesA[(k * STUDY_JoinDays + j_ADD)]) > 180)) {
                      } else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, _valuesA[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, _valuesB[(k * STUDY_JoinDays + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                      }
                    }
                  }
                }
              } else {
                if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("not_the_case\t");
              }
            }
          }
        }
      }

      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].println();

      _interval += 1; 
      if ((_interval % STUDY_SumInterval) == 0) {
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] += _valuesA[(k * STUDY_JoinDays + j_ADD)];
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;

            if ((_valuesSUM[(k * STUDY_JoinDays + j_ADD)] < 0.9 * FLOAT_undefined) && (_valuesNUM[(k * STUDY_JoinDays + j_ADD)] != 0)) {
              _valuesSUM[(k * STUDY_JoinDays + j_ADD)] /= _valuesNUM[(k * STUDY_JoinDays + j_ADD)];
            }
          }
        }        
        if (STUDY_DisplayProbs == 1) {
          SOLARCHVISION_draw_dataProbs(i, j, ((start_z - CLIMATE_TMYEPW_start) * STUDY_JoinDays + 1), ((end_z - CLIMATE_TMYEPW_start) * STUDY_JoinDays + STUDY_JoinDays), _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k += 1) {
          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
            _valuesSUM[(k * STUDY_JoinDays + j_ADD)] = 0;
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] = 0;
          }
        }
      }      

      if (STUDY_DisplaySorted == 1) {
        SOLARCHVISION_draw_data_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (STUDY_DisplayNormals == 1) {
        SOLARCHVISION_draw_data_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][10] + ".epw");
      FILE_outputRaw[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputRaw[(j - STUDY_j_Start)].flush(); 
      FILE_outputRaw[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][10] + ".epw");
      FILE_outputNorms[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputNorms[(j - STUDY_j_Start)].println("* : SOLARCHVISION internal algorithm");
      FILE_outputNorms[(j - STUDY_j_Start)].flush(); 
      FILE_outputNorms[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)].println("Source: " + Defined_Stations[STATION_Number][10] + ".epw");
      FILE_outputProbs[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputProbs[(j - STUDY_j_Start)].flush(); 
      FILE_outputProbs[(j - STUDY_j_Start)].close();
    }
  }

  if (STUDY_DisplayRaws == 1) {
    SOLARCHVISION_draw_dataRaws(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }       

  STUDY_Diagrams.popMatrix();
} 





void SOLARCHVISION_try_update_RECENT_OBSERVED () {


  RECENT_OBSERVED_Data = new float [24][365][num_Layers][(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)];
  RECENT_OBSERVED_Flags = new int [24][365][num_Layers][(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)]; // -1: undefined, 0: interpolated, 1: data

  for (int i = 0; i < 24; i += 1) {
    for (int j = 0; j < 365; j += 1) {
      for (int l = 0; l < num_Layers; l += 1) {
        for (int k = 0; k < (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start); k += 1) {
          RECENT_OBSERVED_Data[i][j][l][k] = FLOAT_undefined;
          RECENT_OBSERVED_Flags[i][j][l][k] = -1;
        }
      }
    }
  }

  if (LoadButton_RECENT_OBSERVED == 1) {

    for (int q = 0; q < numberOfNearestStations_RECENT_OBSERVED; q++) {
      nearest_Station_RECENT_OBSERVED_id[q] = -1;
      nearest_Station_RECENT_OBSERVED_dist[q] = FLOAT_undefined;
    }

    for (int q = 0; q < numberOfNearestStations_RECENT_OBSERVED; q++) {
      for (int f = 0; f < STATION_SWOB_INFO.length; f += 1) {

        float _lat = float(STATION_SWOB_INFO[f][3]);
        float _lon = float(STATION_SWOB_INFO[f][4]); 
        if (_lon > 180) _lon -= 360; // << important!


        float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

        if (nearest_Station_RECENT_OBSERVED_dist[q] > d) {

          int added_before = 0;

          for (int p = 0; p < q; p++) {
            if (nearest_Station_RECENT_OBSERVED_id[p] == f) added_before = 1;
          }

          if (added_before == 0) {
            nearest_Station_RECENT_OBSERVED_dist[q] = d;
            nearest_Station_RECENT_OBSERVED_id[q] = f;
          }
        }
      }

      nearest_Station_RECENT_OBSERVED_id[q] = nearest_Station_RECENT_OBSERVED_id[q];
    }    




    // this line tries to update the most recent files! << 
    int THE_YEAR = year(); 
    int THE_MONTH = month();
    int THE_DAY = day();
    int THE_HOUR = hour(); 


    float THE_DATE = TIME_Date;

    int now_i = int(THE_HOUR);
    int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

    now_i += int(-LocationTimeZone / 15);
    if (now_i > 23) {
      now_i -= 24;
      now_j += 1;
      if (now_j > 364) {
        now_j -= 365;
        THE_YEAR += 1;
      }
      THE_DATE += 1;
      if (THE_DATE > 364) THE_DATE -= 365;
    }         
    THE_HOUR = now_i;

    for (int j_for = 0; j_for < STUDY_max_j_end_observations * 24; j_for += 1) {

      THE_MONTH = CalendarDate[int(THE_DATE)][0]; 
      THE_DAY = CalendarDate[int(THE_DATE)][1];

      for (int q = 0; q < numberOfNearestStations_RECENT_OBSERVED; q++) {

        int f = nearest_Station_RECENT_OBSERVED_id[q];

        if (f != -1) {

          String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + STATION_SWOB_INFO[f][6] + "-" + STATION_SWOB_INFO[f][11] + "-swob.xml";

          int File_Found = -1;

          //println(FN);
          for (int i = RECENT_OBSERVED_XML_Files.length - 1; i >= 0; i--) { // reverse search is faster 
            //println(RECENT_OBSERVED_XML_Files[i]); 

            if (RECENT_OBSERVED_XML_Files[i].equals(FN)) {

              File_Found = i;
              println("Found:", File_Found);

              break; // <<<<<<<<<<
            }
          }

          if ((File_Found == -1) && (Download_RECENT_OBSERVED != 0)) {
            String the_link = "http://dd.weatheroffice.gc.ca/observations/swob-ml/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + STATION_SWOB_INFO[f][6] + "/" + FN;
            String the_target = RECENT_OBSERVED_directory + "/" + FN;

            println("Try downloading: " + the_link);

            try {
              saveBytes(the_target, loadBytes(the_link));

              String[] new_file = {
                FN
              };
              RECENT_OBSERVED_XML_Files = concat(RECENT_OBSERVED_XML_Files, new_file);

              File_Found = RECENT_OBSERVED_XML_Files.length - 1;
              println("Added:", File_Found);
            } 
            catch (Exception e) {
            }
          }

          if (File_Found != -1) SOLARCHVISION_LoadRECENT_OBSERVED((RECENT_OBSERVED_directory + "/" + FN), q);
          else println("FILE NOT FOUND:", FN);
        }
      }

      now_i -= 1;
      if (now_i < 0) {
        now_i += 24;
        now_j -= 1;
        if (now_j < 0) {
          now_j += 365;
          THE_YEAR -= 1;
        }
        THE_DATE -= 1;
        if (THE_DATE < 0) THE_DATE += 364;
      }
      THE_HOUR = now_i;
    }
  }

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  

  for (int l = 0; l < num_Layers; l += 1) {
    if (LAYERS_Text[l].equals("")) {
    } else {
      for (int k = 0; k < (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start); k += 1) {
        float pre_v = FLOAT_undefined;
        int pre_num = 0;

        for (int j_for = 0; j_for <= STUDY_max_j_end_observations; j_for += 1) { // should be controlled.
          int j = (int(j_for + TIME_Date - STUDY_max_j_end_observations + 365 - 286) % 365); // should be controlled.

          for (int i = 0; i < 24; i += 1) {
            if (RECENT_OBSERVED_Data[i][j][l][k] > 0.9 * FLOAT_undefined) {
              if (pre_v < 0.9 * FLOAT_undefined) {
                pre_num += 1;

                float next_v = FLOAT_undefined;
                int next_i = i;
                int next_j = j;
                int next_num = 0;
                while ((next_num < MAX_SEARCH) && (next_v > 0.9 * FLOAT_undefined)) {
                  next_num += 1;
                  next_i += 1;
                  if (next_i == 24) {
                    next_i -= 24;
                    next_j += 1;
                  }
                  if (next_j == 365) {
                    next_j = 0;
                  }
                  if (RECENT_OBSERVED_Data[next_i][next_j][l][k] > 0.9 * FLOAT_undefined) {
                  } else {
                    next_v = RECENT_OBSERVED_Data[next_i][next_j][l][k];

                    if (l == LAYER_winddir) {
                      if ((next_v - pre_v) > 180) next_v -= 360;
                      if ((next_v - pre_v) < -180) next_v += 360;
                    }
                  }
                }
                if (next_num < MAX_SEARCH) {
                  if (l == LAYER_winddir) RECENT_OBSERVED_Data[i][j][l][k] = ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360;
                  else RECENT_OBSERVED_Data[i][j][l][k] = (next_num * pre_v + pre_num * next_v) / (pre_num + next_num);

                  RECENT_OBSERVED_Flags[i][j][l][k] = 0;
                } else {
                  RECENT_OBSERVED_Flags[i][j][l][k] = -1;
                }
              }
            } else {
              RECENT_OBSERVED_Flags[i][j][l][k] = 1;
              pre_v = RECENT_OBSERVED_Data[i][j][l][k];
              pre_num = 0;
            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_LoadRECENT_OBSERVED (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  XML FileALL = loadXML(FileName);

  XML[] children0 = FileALL.getChildren("om:member");
  XML[] children1 = children0[0].getChildren("om:Observation");
  XML[] children2 = children1[0].getChildren("om:samplingTime");
  XML[] children3 = children2[0].getChildren("gml:TimeInstant");
  XML[] children4 = children3[0].getChildren("gml:timePosition");
  String _TimeInstant = String.valueOf(children4[0].getContent());
  //println(_TimeInstant);

  int THE_YEAR = int(_TimeInstant.substring(0, 4));
  int THE_MONTH = int(_TimeInstant.substring(5, 7));
  int THE_DAY = int(_TimeInstant.substring(8, 10));
  int THE_HOUR = int(_TimeInstant.substring(11, 13));

  //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

  int now_i = int(THE_HOUR);
  int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

  //println(now_i, now_j);

  now_i -= int(-LocationTimeZone / 15);

  if (now_i < 0) {
    now_i += 24;
    now_j -= 1;
    if (now_j < 0) {
      now_j += 365;
    }
  }

  //println(now_i, now_j);
  //println("-------------");

  children2 = children1[0].getChildren("om:result");
  children3 = children2[0].getChildren("elements");
  children4 = children3[0].getChildren("element");

  for (int Li = 0; Li < children4.length; Li++) {

    String _a1 = children4[Li].getString("name");
    String _a2 = children4[Li].getString("value");
    String _a3 = children4[Li].getString("uom");

    //println("Li=", Li, _a1, _a2, _a3);

    if (_a2.toUpperCase().equals("MSNG")) { // missing values
      _a2 = String.valueOf(FLOAT_undefined);
    }

    if (_a1.equals("stn_pres")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_pressure][Load_Layer] = Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_pressure][Load_Layer] = 1;
    }

    if (_a1.equals("air_temp")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_drybulb][Load_Layer] = Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_drybulb][Load_Layer] = 1;
    }

    if (_a1.equals("rel_hum")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_relhum][Load_Layer] = Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_relhum][Load_Layer] = 1;
    } 

    if (_a1.equals("tot_cld_amt")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_cloudcover][Load_Layer] = 0.1 * Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_cloudcover][Load_Layer] = 1;
    }    

    if (_a1.equals("avg_wnd_dir_10m_mt50-60")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_winddir][Load_Layer] = Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_winddir][Load_Layer] = 1;
    }    

    if (_a1.equals("avg_wnd_spd_10m_mt50-60")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_windspd][Load_Layer] = Float.valueOf(_a2);
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_windspd][Load_Layer] = 1;
    }

    if (_a1.equals("pcpn_amt_pst6hrs")) {
      RECENT_OBSERVED_Data[now_i][now_j][LAYER_precipitation_A][Load_Layer] = Float.valueOf(_a2); // past 6 hours!
      RECENT_OBSERVED_Flags[now_i][now_j][LAYER_precipitation_A][Load_Layer] = 1;
    }

    if (_a1.equals("avg_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("W/m²")) {
        RECENT_OBSERVED_Data[now_i][now_j][LAYER_glohorrad][Load_Layer] = 1000 * Float.valueOf(_a2) / 3.6; // we should check the units!
        RECENT_OBSERVED_Flags[now_i][now_j][LAYER_glohorrad][Load_Layer] = 1;
        //}
      }
    }

    if (_a1.equals("tot_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("kJ/m²")) {
        RECENT_OBSERVED_Data[now_i][now_j][LAYER_glohorrad][Load_Layer] = Float.valueOf(_a2) / 3.6; // we should check the units!
        RECENT_OBSERVED_Flags[now_i][now_j][LAYER_glohorrad][Load_Layer] = 1;
        //}
      }
    }
  }
}


void SOLARCHVISION_PlotRECENT_OBSERVED (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Pix = (100.0 * STUDY_S_View / STUDY_LevelPix);

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  STUDY_color_data_raws = color(63, 0, 0, SOLARCHVISION_getOpacity(STUDY_O_scale)); 

  SOLARCHVISION_draw_Grid_Cartesian_TIME(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);

  int start_z = STUDY_get_startZ_endZ(databaseNumber_RECENT_OBSERVED)[0];
  int end_z = STUDY_get_startZ_endZ(databaseNumber_RECENT_OBSERVED)[1]; 

  if (STUDY_PrintTtitle != 0) {

    STUDY_Diagrams.stroke(0); 
    STUDY_Diagrams.fill(0);
    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(RIGHT, CENTER); 
    //STUDY_Diagrams.text(("[Observations:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);

    STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
    STUDY_Diagrams.textAlign(LEFT, CENTER); 
    STUDY_Diagrams.text((LAYERS_Title[STUDY_CurrentLayer][Language_Active]), 0, (0.5 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale);
  }

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;

  float[] _valuesA;
  float[] _valuesB; 
  _valuesA = new float [(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)];
  _valuesB = new float [(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)]; 

  float[] _valuesSUM; 
  float[] _valuesNUM;
  int _interval = 0;
  _valuesSUM = new float [(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)];
  _valuesNUM = new float [(1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)];

  for (int k = 0; k < (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start); k += 1) { 
    _valuesA[k] = FLOAT_undefined;
    _valuesB[k] = FLOAT_undefined;
    _valuesSUM[k] = FLOAT_undefined;
    _valuesNUM[k] = 0;
  }

  float[] Ax_LINES = {
    0
  };
  float[] Ay_LINES = {
    0
  };
  float[] Az_LINES = {
    0
  };
  float[] Bx_LINES = {
    0
  };
  float[] By_LINES = {
    0
  };
  float[] Bz_LINES = {
    0
  };

  FILE_outputRaw = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputNorms = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];
  FILE_outputProbs = new PrintWriter [(STUDY_j_End - STUDY_j_Start)];

  String Main_name = MAKE_MainName();

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 
    String _FilenamesAdd = "";
    if (STUDY_JoinDays > 1) {
      //_FilenamesAdd = ("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s");
    }
    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/OBSERVATION_node_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputRaw[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly data(OBSERVATION)");

      FILE_outputRaw[(j - STUDY_j_Start)].print("Hour\t");
      for (int l = start_z; l < (1 + end_z); l += 1) {
        FILE_outputRaw[(j - STUDY_j_Start)].print(STATION_SWOB_INFO[nearest_Station_RECENT_OBSERVED_id[l]][6] + "\t");
      }
      FILE_outputRaw[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/OBSERVATION_norm_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputNorms[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly normal(OBSERVATION)");
      FILE_outputNorms[(j - STUDY_j_Start)].print("Hour\t");
      for (int l = 0; l < 9; l += 1) {
        FILE_outputNorms[(j - STUDY_j_Start)].print(STAT_N_Title[l] + "\t");
      }
      FILE_outputNorms[(j - STUDY_j_Start)].println("");
    }
    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)] = createWriter("/" + Main_name + "/OBSERVATION_prob_" + LocationName + "_from_" + String.valueOf(start_z) + "_to_" + String.valueOf(end_z) + "_" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "_" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "_" + CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + ".txt");
      FILE_outputProbs[(j - STUDY_j_Start)].println(CalendarDay[((365 + j + 286 + TIME_BeginDay) % 365)][Language_Active] + _FilenamesAdd + "\t" + STUDY_skyScenario_FileTXT[STUDY_skyScenario_Active] + "\t" + LAYERS_Title[STUDY_CurrentLayer][Language_EN] + "(" + LAYERS_Unit[STUDY_CurrentLayer] + ")" + "\tfrom:" + String.valueOf(start_z) + "\tto:" + String.valueOf(end_z) + "\t" + LocationName + "\tHourly probabilities(OBSERVATION)");

      FILE_outputProbs[(j - STUDY_j_Start)].print("Hour:\t");
      FILE_outputProbs[(j - STUDY_j_Start)].println("");
    }

    for (int i = 0; i < 24; i += 1) {
      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");
      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) FILE_outputProbs[(j - STUDY_j_Start)].print(nf(i, 2) + "\t");

      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

        _valuesA[k] = FLOAT_undefined;
        _valuesB[k] = FLOAT_undefined;

        if ((k + 1) == 22) {
          STUDY_Diagrams.stroke(127, 0, 255, 127); 
          STUDY_Diagrams.fill(127, 0, 255);
          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 6);
        } else {
          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(COLOR_STYLE_Active, (1.0 * k / (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)));
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
        }

        int _plot = 1;

        if (_plot == 1) {

          int now_k = k;
          int now_i = i;
          int now_j = (j + TIME_BeginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          int next_i = now_i + TIME_Interval;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = 0; //i % 24;
            next_j += 1; //int((i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
              //next_k += 1;
            }
          }

          Pa = RECENT_OBSERVED_Data[now_i][now_j][STUDY_CurrentLayer][now_k]; 
          if (Pa > 0.9 * FLOAT_undefined) {
            _valuesA[k] = FLOAT_undefined;

            if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
          } else {
            int drw_count = 1; //SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

            if (drw_count == 1) {

              _valuesA[k] = Pa;
              _valuesA[k] += STUDY_V_offset[STUDY_CurrentLayer];

              _valuesSUM[k] += _valuesA[k];
              _valuesNUM[k] += 1;

              //if ((RECENT_OBSERVED_Flags[now_i][now_j][STUDY_CurrentLayer][now_k] == 1) && ((STUDY_DisplayRaws == 1))) STUDY_Diagrams.ellipse((j + ((i + 0.5) / 24.0)) * sx_Plot, _valuesA[k] * sy_Plot, 5, 5);

              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
                if (_valuesA[k] < 0.9 * FLOAT_undefined) FILE_outputRaw[(j - STUDY_j_Start)].print(nfs(_valuesA[k] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
                else FILE_outputRaw[(j - STUDY_j_Start)].print("[undefined]\t");
              }

              if (next_k < (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start)) {

                Pb = RECENT_OBSERVED_Data[next_i][next_j][STUDY_CurrentLayer][next_k];
                if (Pb > 0.9 * FLOAT_undefined) {
                  _valuesB[k] = FLOAT_undefined;
                } else {
                  _valuesB[k] = Pb;
                  _valuesB[k] += STUDY_V_offset[STUDY_CurrentLayer];

                  if (STUDY_DisplayRaws == 1) {
                    if ((STUDY_CurrentLayer == LAYER_winddir) && (abs(_valuesB[k] - _valuesA[k]) > 180)) {
                    } else {
                      Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                      Ay_LINES = append(Ay_LINES, _valuesA[k] * sy_Plot);
                      Az_LINES = append(Az_LINES, now_k * sz_Plot * STUDY_W_scale);
                      Bx_LINES = append(Bx_LINES, (j + ((i + 0.5 + TIME_Interval) / 24.0)) * sx_Plot);
                      By_LINES = append(By_LINES, _valuesB[k] * sy_Plot);
                      Bz_LINES = append(Bz_LINES, next_k * sz_Plot * STUDY_W_scale);
                    }
                  }
                }
              }
            } else {
              if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].print("not_the_case\t");
            }
          }
        }
      }

      if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) FILE_outputRaw[(j - STUDY_j_Start)].println();

      _interval += 1; 
      if ((_interval % STUDY_SumInterval) == 0) {
        for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
          _valuesSUM[k] += _valuesA[k];
          _valuesNUM[k] += 1;

          if ((_valuesSUM[k] < 0.9 * FLOAT_undefined) && (_valuesNUM[k] != 0)) {
            _valuesSUM[k] /= _valuesNUM[k];
          }
        }    
        if (STUDY_DisplayProbs == 1) {
          //SOLARCHVISION_draw_dataProbs(i, j, start_z, end_z, _valuesSUM, _valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }  

        for (int k = 0; k < (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start); k += 1) {
          _valuesSUM[k] = 0;
          _valuesNUM[k] = 0;
        }
      }        

      if (STUDY_DisplaySorted == 1) {
        SOLARCHVISION_draw_data_sorted(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }

      if (STUDY_DisplayNormals == 1) {
        SOLARCHVISION_draw_data_normals(i, j, _valuesA, _valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
      }
    }

    if ((Export_STUDY_info_node == 1) && (STUDY_DisplayRaws == 1)) {
      FILE_outputRaw[(j - STUDY_j_Start)].println("Source: Environment and Climate Change Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      FILE_outputRaw[(j - STUDY_j_Start)].println("The data might be interpolated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputRaw[(j - STUDY_j_Start)].flush(); 
      FILE_outputRaw[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      FILE_outputNorms[(j - STUDY_j_Start)].println("Source: Environment and Climate Change Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      FILE_outputNorms[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputNorms[(j - STUDY_j_Start)].println("* : SOLARCHVISION internal algorithm");
      FILE_outputNorms[(j - STUDY_j_Start)].flush(); 
      FILE_outputNorms[(j - STUDY_j_Start)].close();
    }

    if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
      FILE_outputProbs[(j - STUDY_j_Start)].println("Source: Environment and Climate Change Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/");
      FILE_outputProbs[(j - STUDY_j_Start)].println("Calculated and processed by SOLARCHVISION 2016: www.solarchvision.com");
      FILE_outputProbs[(j - STUDY_j_Start)].flush(); 
      FILE_outputProbs[(j - STUDY_j_Start)].close();
    }
  }

  if (STUDY_DisplayRaws == 1) {
    SOLARCHVISION_draw_dataRaws(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
  }    

  STUDY_Diagrams.popMatrix();
} 



void SOLARCHVISION_draw_Grid_Cartesian_TIME (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);

  float Shift_DOWN = 0;
  if (STUDY_V_belowLine[STUDY_CurrentLayer] != 0) Shift_DOWN = -100;

  for (int i = 100; i >= Shift_DOWN; i -= 25) {
    if (-STUDY_V_offset[STUDY_CurrentLayer] + roundTo(i / STUDY_V_scale[STUDY_CurrentLayer], 0.1) != 0) {
      STUDY_Diagrams.stroke(0, 63);
      STUDY_Diagrams.fill(0, 63);
    } else {
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
    }
    STUDY_Diagrams.line(STUDY_j_Start * sx_Plot, -i * STUDY_S_View, STUDY_j_End * sx_Plot, -i * STUDY_S_View); 

    if ((i >= 0) || (STUDY_V_belowLine[STUDY_CurrentLayer] != 0)) {  
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER);
      STUDY_Diagrams.text(((nf(-STUDY_V_offset[STUDY_CurrentLayer] + roundTo(i / STUDY_V_scale[STUDY_CurrentLayer], 0.1), 0, 1)) + LAYERS_Unit[STUDY_CurrentLayer]), -5, -i * STUDY_S_View);
      //STUDY_Diagrams.text(((String.valueOf(int(-STUDY_V_offset[STUDY_CurrentLayer] + roundTo(i / STUDY_V_scale[STUDY_CurrentLayer], 0.1)))) + LAYERS_Unit[STUDY_CurrentLayer]), -5, -i * STUDY_S_View);
    }
  }

  STUDY_Diagrams.stroke(0, 63);
  STUDY_Diagrams.fill(0, 63); 
  for (int i = STUDY_j_Start; i <= STUDY_j_End; i += 1) {
    if (i < STUDY_j_End) {
      int j_step = 3;
      for (int j = j_step; j <= 24; j += j_step) {
        if (j != 24) {
          STUDY_Diagrams.line((i + j / 24.0) * sx_Plot, -5 * STUDY_S_View, (i + j / 24.0) * sx_Plot, 5 * STUDY_S_View);
        } else {
          STUDY_Diagrams.line((i + j / 24.0) * sx_Plot, -105 * STUDY_S_View, (i + j / 24.0) * sx_Plot, (5 - Shift_DOWN) * STUDY_S_View);
        }
      }
    }
  }

  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textAlign(CENTER, CENTER); 

  for (int i = STUDY_j_Start; i < STUDY_j_End; i += 1) {
    if (STUDY_U_scale >= 0.75) {
      STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
      STUDY_Diagrams.text("12:00", (i - ((0 - 12) / 24.0)) * sx_Plot, 0.1 * sx_Plot / STUDY_U_scale);
    }
  }

  SOLARCHVISION_print_other_info(sx_Plot, STUDY_V_belowLine[STUDY_CurrentLayer]);
}  



void SOLARCHVISION_draw_Grid_Spherical_POSITION (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int fill_back) {
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);

  if (fill_back != 0) {
    for (int i = STUDY_j_Start; i < STUDY_j_End; i += 1) {

      STUDY_Diagrams.stroke(223);
      STUDY_Diagrams.fill(223);
      STUDY_Diagrams.ellipse((i + STUDY_rect_offset_x) * sx_Plot, 0, 2 * 90 * STUDY_rect_scale * sx_Plot, 2 * 90 * STUDY_rect_scale * sx_Plot);
    }
  }

  for (int i = STUDY_j_Start; i < STUDY_j_End; i += 1) {
    for (int t = 0; t < 360; t += 15) {

      if ((t % 45) != 0) {
        STUDY_Diagrams.stroke(0, 63);
        STUDY_Diagrams.fill(0, 63);
      } else {

        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
      }
      int r = 0;
      if ((t % 45) != 0) r = 15;

      STUDY_Diagrams.line((i + STUDY_rect_offset_x + r * STUDY_rect_scale * (cos_ang(t))) * sx_Plot, -(r * STUDY_rect_scale * (sin_ang(t))) * sx_Plot, (i + STUDY_rect_offset_x + 90 * STUDY_rect_scale * (cos_ang(t))) * sx_Plot, -(90 * STUDY_rect_scale * (sin_ang(t))) * sx_Plot); 

      if (((t + 45) % 90) == 0) {
        STUDY_Diagrams.stroke(0, 127);
        STUDY_Diagrams.fill(0, 127);
        STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(CENTER, CENTER);

        String ORI = "";
        switch((360 + 90 - t) % 360) {
        case 0 : 
          ORI = "N"; 
          break;
        case 45 : 
          ORI = "NE"; 
          break;
        case 90 : 
          ORI = "E"; 
          break;
        case 135 : 
          ORI = "SE"; 
          break;
        case 180 : 
          ORI = "S"; 
          break;
        case 225 : 
          ORI = "SW"; 
          break;
        case 270 : 
          ORI = "W"; 
          break;
        case 315 : 
          ORI = "NW"; 
          break;
        }

        STUDY_Diagrams.text(ORI, (i + STUDY_rect_offset_x + 110 * STUDY_rect_scale * (cos_ang(t))) * sx_Plot, -(110 * STUDY_rect_scale * (sin_ang(t))) * sx_Plot);
        //STUDY_Diagrams.text(String.valueOf((360 + 90 - t) % 360), (i + STUDY_rect_offset_x + 110 * STUDY_rect_scale * (cos_ang(t))) * sx_Plot, -(110 * STUDY_rect_scale * (sin_ang(t))) * sx_Plot);
      }
    }

    float impact_scale = 1;
    if ((STUDY_PlotImpacts == -2) || (STUDY_PlotImpacts == -1)) impact_scale = STUDY_V_scale[LAYER_windspd] * 45 / 50.0;

    for (int r = 90; r > 0; r -= 15) {
      if ((r % 90) != 0) {
        STUDY_Diagrams.stroke(0, 63);
        STUDY_Diagrams.noFill();
      } else {
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.noFill();
      }

      STUDY_Diagrams.ellipse((i + STUDY_rect_offset_x) * sx_Plot, 0, 2 * r * STUDY_rect_scale * sx_Plot, 2 * r * STUDY_rect_scale * sx_Plot);

      int t = 90;
      if (t == 90) {
        STUDY_Diagrams.stroke(0, 127);
        STUDY_Diagrams.fill(0, 127);
        STUDY_Diagrams.textSize(sx_Plot * 0.200 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
        STUDY_Diagrams.text(nf(int(r / impact_scale), 1), (i + STUDY_rect_offset_x + r * STUDY_rect_scale * (cos_ang(t))) * sx_Plot, -(r * STUDY_rect_scale * (sin_ang(t))) * sx_Plot);
      }
    }
  }
}  


void SOLARCHVISION_draw_Grid_DAILY (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textAlign(CENTER, CENTER); 

  for (int i = STUDY_j_Start; i < STUDY_j_End; i += 1) {
    if ((STUDY_U_scale >= 0.75) || (((i - STUDY_j_Start) % int(1.5 / STUDY_U_scale)) == 0)) {
      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

      STUDY_Diagrams.text(CalendarDay[int((365 + i * STUDY_PerDays + 286 + TIME_BeginDay) % 365)][Language_Active], (i - ((0 - 12) / 24.0)) * sx_Plot, -1.25 * sx_Plot / STUDY_U_scale);
      if (STUDY_JoinDays > 1) {
        //STUDY_Diagrams.text(("±" + int(STUDY_JoinDays / 2) + SOLARCHVISION_WORDS[2][Language_Active] + "s"), (0 + i - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
      }
    }
  }

  SOLARCHVISION_print_other_info(sx_Plot, 1);
}


void SOLARCHVISION_print_other_info (float sx_Plot, float the_STUDY_V_belowLine) {
  STUDY_Diagrams.stroke(0);
  STUDY_Diagrams.fill(0);
  STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
  STUDY_Diagrams.textAlign(LEFT, TOP);

  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) STUDY_Diagrams.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + LocationName + "\n"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + LocationName + "\n("), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + LocationName + "\n("), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);  
  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE)    STUDY_Diagrams.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + LocationName + "\n(" + nf(TIME_Year, 4) + "_" + nf(TIME_Month, 2) + "_" + nf(TIME_Day, 2) + "_" + nf(TIME_Hour, 2) + ")"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)    STUDY_Diagrams.text((SOLARCHVISION_WORDS[0][Language_Active] + ":" + LocationName + "\n(" + nf(TIME_Year, 4) + "_" + nf(TIME_Month, 2) + "_" + nf(TIME_Day, 2) + "_" + nf(TIME_Hour, 2) + ")"), -1.5 * sx_Plot / STUDY_U_scale, (1.0 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);

  switch(STUDY_skyScenario_Active) {
  case 1 : 
    STUDY_Diagrams.stroke(0, 0, 0); 
    STUDY_Diagrams.fill(0, 0, 0); 
    break;
  case 2 : 
    STUDY_Diagrams.stroke(0, 0, 255); 
    STUDY_Diagrams.fill(0, 0, 255); 
    break;
  case 3 : 
    STUDY_Diagrams.stroke(0, 127, 0); 
    STUDY_Diagrams.fill(0, 127, 0); 
    break;
  case 4 : 
    STUDY_Diagrams.stroke(255, 0, 0); 
    STUDY_Diagrams.fill(255, 0, 0); 
    break;
  }

  STUDY_Diagrams.textAlign(RIGHT, TOP);

  STUDY_Diagrams.text(STUDY_skyScenario_Title[STUDY_skyScenario_Active], (STUDY_j_End - STUDY_j_Start - 0.05) * sx_Plot, (0.3 + the_STUDY_V_belowLine) * sx_Plot / STUDY_U_scale);
}  



void SOLARCHVISION_draw_dataRaws (float[] Ax_LINES, float[] Ay_LINES, float[] Az_LINES, float[] Bx_LINES, float[] By_LINES, float[] Bz_LINES) {
  //STUDY_Diagrams.stroke(STUDY_color_data_raws);
  //STUDY_Diagrams.fill(STUDY_color_data_raws);
  //STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);

  STUDY_Diagrams.stroke(0, SOLARCHVISION_getOpacity(STUDY_O_scale));
  STUDY_Diagrams.fill(0, SOLARCHVISION_getOpacity(STUDY_O_scale));
  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.5);

  for (int i = 1; i < Ax_LINES.length; i += 1) {
    STUDY_Diagrams.line(Ax_LINES[i], Ay_LINES[i], Bx_LINES[i], By_LINES[i]);
  }
}


void SOLARCHVISION_draw_dataProbs (int i, int j, int start_z, int end_z, float[] _valuesSUM, float[] _valuesNUM, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  int PAL_TYPE = STUDY_Pallet_PROB_CLR; 
  int PAL_DIR = STUDY_Pallet_PROB_DIR;  
  float PAL_Multiplier = STUDY_Pallet_PROB_MLT;

  float txt_max_width = (STUDY_SumInterval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale;
  float txt_max_height = STUDY_Pix;
  if (txt_max_height > txt_max_width) STUDY_Diagrams.textSize(0.9 * txt_max_width);
  else STUDY_Diagrams.textSize(0.9 * txt_max_height);

  STUDY_Diagrams.textAlign(CENTER, CENTER);

  STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

  float min_v = tan_ang(89.99);
  float max_v = tan_ang(-89.99);

  for (int k = 0; k < _valuesSUM.length; k += 1) {
    if (_valuesSUM[k] < 0.9 * FLOAT_undefined) {
      if (min_v > _valuesSUM[k]) min_v = _valuesSUM[k];
      if (max_v < _valuesSUM[k]) max_v = _valuesSUM[k];
    }
  } 

  if ((min_v != tan_ang(89.99)) && (max_v != tan_ang(-89.99))) {    
    min_v = roundTo((min_v * abs(sy_Plot)), STUDY_Pix) / STUDY_Pix;
    max_v = roundTo((max_v * abs(sy_Plot)), STUDY_Pix) / STUDY_Pix;

    if (STUDY_CurrentLayer == LAYER_winddir) min_v = 0;

    int[] _probs;
    int total_probs = 0;

    _probs = new int [int((1 + max_v - min_v))];

    for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
      if (_valuesSUM[k] < 0.9 * FLOAT_undefined) {
        float the_value = _valuesSUM[k];

        if (STUDY_CurrentLayer == LAYER_winddir) {
          if (roundTo((the_value * abs(sy_Plot)), STUDY_Pix) >= (360 * abs(sy_Plot))) the_value -= 360;
        }

        int h = int(roundTo((roundTo((the_value * abs(sy_Plot)), STUDY_Pix) / STUDY_Pix) - min_v, 1));
        _probs[h] += 1;
        total_probs += 1;
      }
    }

    if (total_probs != 0) {
      for (int n = 0; n < _probs.length; n += 1) {
        float prob_V = 1.0 * _probs[n] / total_probs;

        //if (int(roundTo(100 * prob_V, 1)) > 0) {
        if ((100 * prob_V) > 0) {

          float _u = PAL_Multiplier * prob_V;

          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;

          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
          STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
          STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0); 
          STUDY_Diagrams.rect((j + ((i + 1) / 24.0)) * sx_Plot, -((min_v + n) * STUDY_Pix) - 0.5 * STUDY_Pix, -(STUDY_SumInterval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale, STUDY_Pix); 

          if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
            STUDY_Diagrams.stroke(127);
            STUDY_Diagrams.fill(127);
            STUDY_Diagrams.strokeWeight(0);
          } else {
            STUDY_Diagrams.stroke(255);
            STUDY_Diagrams.fill(255);
            STUDY_Diagrams.strokeWeight(2);
          }   
          STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (j + ((i + 1) / 24.0)) * sx_Plot - 0.5 * (STUDY_SumInterval * STUDY_S_View * 100 / 24.0) * STUDY_U_scale, -((min_v + n) * STUDY_Pix) - 0.05 * txt_max_height);

          if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
            FILE_outputProbs[(j - STUDY_j_Start)].print(nfs((min_v + n) * STUDY_Pix / abs(sy_Plot) - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + ":\t" + nf(100 * prob_V, 3, 3) + "\t");
          }
        }
      }  

      if ((Export_STUDY_info_prob == 1) && (STUDY_DisplayProbs == 1)) {
        FILE_outputProbs[(j - STUDY_j_Start)].println("");
      }
    }
  }

  float pal_length = 400;
  for (int q = 0; q < 11; q += 1) {
    float prob_V = 10 * q / 100.0;

    float _u = PAL_Multiplier * prob_V;

    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;

    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  
    STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
    STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);     

    STUDY_Diagrams.strokeWeight(0); 

    float Y_OFFSET = (0.25 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale;

    //STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, 125 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 
    STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, Y_OFFSET, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View);

    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
      STUDY_Diagrams.stroke(127);
      STUDY_Diagrams.fill(127);
      STUDY_Diagrams.strokeWeight(0);
    } else {
      STUDY_Diagrams.stroke(255);
      STUDY_Diagrams.fill(255);
      STUDY_Diagrams.strokeWeight(2);
    }   

    STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
    STUDY_Diagrams.textAlign(CENTER, CENTER);
    //STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 + 125 - 0.05 * 20) * STUDY_S_View);
    STUDY_Diagrams.text((String.valueOf(int(roundTo(100 * prob_V, 1)))), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, Y_OFFSET + (10 - 0.05 * 20) * STUDY_S_View);
  }
}


void SOLARCHVISION_draw_data_sorted (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  int PAL_TYPE = STUDY_Pallet_SORT_CLR; 
  int PAL_DIR = STUDY_Pallet_SORT_DIR;  
  float PAL_Multiplier = STUDY_Pallet_SORT_MLT;

  float[] sorted_valuesA = sort(_valuesA);
  int num_sorted_valuesA = 0;
  for (int l = 0; l < sorted_valuesA.length; l += 1) {
    if (sorted_valuesA[l] < 0.9 * FLOAT_undefined) {
      num_sorted_valuesA += 1;
    } else break;
  }

  float[] sorted_valuesB = sort(_valuesB);
  int num_sorted_valuesB = 0;
  for (int l = 0; l < sorted_valuesB.length; l += 1) {
    if (sorted_valuesB[l] < 0.9 * FLOAT_undefined) {
      num_sorted_valuesB += 1;
    } else break;
  }

  int num_sorted_valuesAB = min(num_sorted_valuesA, num_sorted_valuesB);

  for (int l = 0; l < (num_sorted_valuesAB - 1); l += 1) {
    float sort_V = 1.1 * (0.5 - ((num_sorted_valuesAB - (l + 1)) / float(num_sorted_valuesAB)));

    float _u = 0.5 + 0.5 * (PAL_Multiplier * sort_V);

    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;

    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
    STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
    STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);    

    STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.0); 
    //STUDY_Diagrams.rect((j + ((i + 1) / 24.0)) * sx_Plot, sorted_valuesA[l] * sy_Plot, -(1 * 100 / 24.0) * STUDY_U_scale, (sorted_valuesA[(l + 1)] - sorted_valuesA[l]) * sy_Plot);

    float P1x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
    float P2x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
    float P3x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
    float P4x = (j + ((i + 1.5) / 24.0)) * sx_Plot;

    float P1y = sorted_valuesA[l] * sy_Plot;
    float P2y = sorted_valuesA[(l + 1)] * sy_Plot;
    float P3y = sorted_valuesB[(l + 1)] * sy_Plot;
    float P4y = sorted_valuesB[l] * sy_Plot; 

    STUDY_Diagrams.quad(P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y);
    /*
    STUDY_Diagrams.stroke(255);
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0.5); 
     STUDY_Diagrams.line(P1x, P1y, P4x, P4y); 
     STUDY_Diagrams.line(P2x, P2y, P3x, P3y);
     */
  }

  String[] _txt = {
    "MIN", "", "25%", "", "MED", "", "75%", "", "MAX"
  }; 
  float pal_length = 400;
  for (int q = 0; q < 9; q += 1) {
    float sort_V = 1.1 * (q - 4) / 8.0;

    float _u = 0.5 + 0.5 * (PAL_Multiplier * sort_V);

    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;

    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
    STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
    STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);     

    float Y_OFFSET = (0.25 + STUDY_V_belowLine[STUDY_CurrentLayer]) * sx_Plot / STUDY_U_scale;

    //STUDY_Diagrams.strokeWeight(0.0);
    STUDY_Diagrams.stroke(255); 
    STUDY_Diagrams.strokeWeight(0.5); 
    //STUDY_Diagrams.rect((700 + q * (pal_length / 9.0)) * STUDY_S_View, 125 * STUDY_S_View, (pal_length / 9.0) * STUDY_S_View, 20 * STUDY_S_View);
    STUDY_Diagrams.rect((700 + q * (pal_length / 9.0)) * STUDY_S_View, Y_OFFSET, (pal_length / 9.0) * STUDY_S_View, 20 * STUDY_S_View);

    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
      STUDY_Diagrams.stroke(127);
      STUDY_Diagrams.fill(127);
      STUDY_Diagrams.strokeWeight(0);
    } else {
      STUDY_Diagrams.stroke(255);
      STUDY_Diagrams.fill(255);
      STUDY_Diagrams.strokeWeight(2);
    }   

    STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
    STUDY_Diagrams.textAlign(CENTER, CENTER);
    //STUDY_Diagrams.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * STUDY_S_View, (10 + 125 - 0.05 * 20) * STUDY_S_View);
    STUDY_Diagrams.text(_txt[q], (25 + 700 + q * (pal_length / 9.0)) * STUDY_S_View, Y_OFFSET + (10 - 0.05 * 20) * STUDY_S_View);
  }
}


void SOLARCHVISION_draw_data_normals (int i, int j, float[] _valuesA, float[] _valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  float[] NormalsA = SOLARCHVISION_NORMAL(_valuesA);
  float[] NormalsB = SOLARCHVISION_NORMAL(_valuesB);

  if (STUDY_CurrentLayer == LAYER_winddir) {
    float[] X_valuesA;
    float[] Y_valuesA;
    X_valuesA = new float [_valuesA.length];
    Y_valuesA = new float [_valuesA.length];

    for (int l = 0; l < _valuesA.length; l += 1) {
      if (_valuesA[l] < 0.9 * FLOAT_undefined) {
        X_valuesA[l] = cos_ang(90 - _valuesA[l]); 
        Y_valuesA[l] = sin_ang(90 - _valuesA[l]);
      } else {
        X_valuesA[l] = FLOAT_undefined; 
        Y_valuesA[l] = FLOAT_undefined;
      }
    }

    float[] X_NormalsA = SOLARCHVISION_NORMAL(X_valuesA);
    float[] Y_NormalsA = SOLARCHVISION_NORMAL(Y_valuesA);

    for (int l = 0; l < NormalsA.length; l += 1) {
      if (NormalsA[l] < 0.9 * FLOAT_undefined) {
        NormalsA[l] = 90 - atan2_ang(Y_NormalsA[l], X_NormalsA[l]);
        if (NormalsA[l] < 0) NormalsA[l] += 360;
      }

      if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
        NormalsA[l] = FLOAT_undefined;
      }
    }

    float[] X_valuesB;
    float[] Y_valuesB;
    X_valuesB = new float [_valuesB.length];
    Y_valuesB = new float [_valuesB.length];

    for (int l = 0; l < _valuesB.length; l += 1) {
      if (_valuesB[l] < 0.9 * FLOAT_undefined) {
        X_valuesB[l] = cos_ang(90 - _valuesB[l]); 
        Y_valuesB[l] = sin_ang(90 - _valuesB[l]);
      } else {
        X_valuesB[l] = FLOAT_undefined; 
        Y_valuesB[l] = FLOAT_undefined;
      }
    }

    float[] X_NormalsB = SOLARCHVISION_NORMAL(X_valuesB);
    float[] Y_NormalsB = SOLARCHVISION_NORMAL(Y_valuesB);

    for (int l = 0; l < NormalsB.length; l += 1) {
      if (NormalsB[l] < 0.9 * FLOAT_undefined) {
        NormalsB[l] = 90 - atan2_ang(Y_NormalsB[l], X_NormalsB[l]);
        if (NormalsB[l] < 0) NormalsB[l] += 360;
      }

      if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
        NormalsB[l] = FLOAT_undefined;
      }
    }
  }
  int _OPACITY = 191;

  for (int l = 0; l < 9; l += 1) {
    //for (int l = 0; l < 3; l += 1) {
    //for (int l = 3; l < 9; l += 1) {

    //for (int p = 0; p < 3; p += 1) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    //for (int p = 0; p < 1; p += 1) { 
    //int l = STUDY_ImpactLayer;


    if (l == STAT_N_Middle) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 191, 0, _OPACITY);
      STUDY_Diagrams.fill(0, 191, 0, _OPACITY);
    } else if (l == STAT_N_MidHigh) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(191, 0, 0, _OPACITY);
      STUDY_Diagrams.fill(191, 0, 0, _OPACITY);
    } else if (l == STAT_N_MidLow) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
      STUDY_Diagrams.stroke(0, 0, 191, _OPACITY);
      STUDY_Diagrams.fill(0, 0, 191, _OPACITY);
    } else if (l == STAT_N_Max) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(255, 127, 127, _OPACITY);
      STUDY_Diagrams.fill(255, 127, 127, _OPACITY);
    } else if (l == STAT_N_Min) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(127, 127, 255, _OPACITY);
      STUDY_Diagrams.fill(127, 127, 255, _OPACITY);
    } else if (l == STAT_N_M50) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 127, 0);
      STUDY_Diagrams.fill(0, 127, 0);
    } else if (l == STAT_N_M75) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(127, 0, 0);
      STUDY_Diagrams.fill(127, 0, 0);
    } else if (l == STAT_N_M25) {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 0, 127);
      STUDY_Diagrams.fill(0, 0, 127);
    } else {
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 1);
      STUDY_Diagrams.stroke(0, 0, 0);
      STUDY_Diagrams.fill(0, 0, 0);
    }


    /*
    if (l == STUDY_ImpactLayer) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(0, 191, 0, _OPACITY);
     STUDY_Diagrams.fill(0, 191, 0, _OPACITY);
     }
     */

    /////////////////////////////// 
    /*
     if (SOLARCHVISION_now_drawing == databaseNumber_CLIMATE_CWEEDS) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(0, 127, 0);
     STUDY_Diagrams.fill(0, 127, 0);
     }
     if (SOLARCHVISION_now_drawing == databaseNumber_CLIMATE_CLMREC) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(127, 127, 0);
     STUDY_Diagrams.fill(127, 127, 0);
     }     
     if (SOLARCHVISION_now_drawing == databaseNumber_FORECAST_ENSEMBLE) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(127, 0, 0);
     STUDY_Diagrams.fill(127, 0, 0);
     }
     if (SOLARCHVISION_now_drawing == databaseNumber_RECENT_OBSERVED) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(0, 0, 127);
     STUDY_Diagrams.fill(0, 0, 127);
     }
     if (SOLARCHVISION_now_drawing == databaseNumber_CLIMATE_TMYEPW) {
     STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
     STUDY_Diagrams.stroke(0, 127, 0);
     STUDY_Diagrams.fill(0, 127, 0);
     }    
     */

    //STUDY_Diagrams.strokeWeight(STUDY_T_scale * 4);
    //STUDY_Diagrams.stroke(0, 127, 0);
    //STUDY_Diagrams.fill(0, 127, 0);

    /////////////////////////////// 


    float z_l = 60; //l;
    if (l == STAT_N_M75) z_l = 61;
    if (l == STAT_N_M50) z_l = 61;
    if (l == STAT_N_M25) z_l = 61;
    if (l == STAT_N_Ave) z_l = 62;

    if ((NormalsA[l] < 0.9 * FLOAT_undefined) && (NormalsB[l] < 0.9 * FLOAT_undefined)) {
      STUDY_Diagrams.line((j + ((i + 0.5) / 24.0)) * sx_Plot, NormalsA[l] * sy_Plot, (j + ((i + 0.5 + TIME_Interval) / 24.0)) * sx_Plot, NormalsB[l] * sy_Plot);
    } 

    if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) {
      if (NormalsA[l] < 0.9 * FLOAT_undefined) FILE_outputNorms[(j - STUDY_j_Start)].print(nfs(NormalsA[l] - STUDY_V_offset[STUDY_CurrentLayer], 5, 5) + "\t"); 
      else FILE_outputNorms[(j - STUDY_j_Start)].print("[undefined]\t");
    }
  }
  if ((Export_STUDY_info_norm == 1) && (STUDY_DisplayNormals == 1)) FILE_outputNorms[(j - STUDY_j_Start)].println();
}  




void SOLARCHVISION_DevelopDATA (int data_source) {

  float keep_STUDY_PerDays = STUDY_PerDays;
  int keep_STUDY_JoinDays = STUDY_JoinDays;
  if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
    STUDY_PerDays = 1;
    STUDY_JoinDays = 1;
  }

  int start_z = STUDY_get_startZ_endZ(data_source)[0];
  int end_z = STUDY_get_startZ_endZ(data_source)[1]; 
  int layers_count = STUDY_get_startZ_endZ(data_source)[2]; 

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float RAIN, T, WS, R_dir, R_dif;

  float[] _valuesSUM; 
  _valuesSUM = new float [layers_count];

  for (int k = 0; k < layers_count; k += 1) {
    _valuesSUM[k] = FLOAT_undefined;
  }




  for (int j = STUDY_j_Start; j <= STUDY_j_End; j += 1) { 
    for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
      for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {
        for (int i = 0; i < 24; i += 1) {

          int now_k = k;
          int now_i = i;
          int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }

          int next_i = now_i + 12;
          int next_j = now_j;
          int next_k = now_k;
          if (next_i >= 24) {
            next_i = next_i - 24; 
            next_j += 1; 
            if (next_j >= 365) {
              next_j = next_j % 365;
            }
          }


          int pre_i = now_i - 12;
          int pre_j = now_j;
          int pre_k = now_k;
          if (pre_i < 0) {
            pre_i = pre_i + 24; 
            pre_j -= 1; 
            if (pre_j < 0) {
              pre_j = (pre_j + 365) % 365;
            }
          }       



          if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
          if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
          if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;

          T = FLOAT_undefined;
          R_dir = FLOAT_undefined;
          R_dif = FLOAT_undefined;

          if ((i == 0) && (j == STUDY_j_Start)) _valuesSUM[now_k] = 0; 

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            R_dir = FLOAT_undefined;
          } else {
            R_dir = Pa;
          }

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k];
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            R_dif = FLOAT_undefined;
          } else {
            R_dif = Pa;
          }

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_drybulb][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_drybulb][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_drybulb][now_k];
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_drybulb][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            T = FLOAT_undefined;
          } else {
            T = Pa;
          }

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_windspd][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_windspd][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_windspd][now_k];
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_windspd][now_k];
          if (Pa > 0.9 * FLOAT_undefined) {
            WS = FLOAT_undefined;
          } else {
            WS = Pa;
          }        

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_precipitation_A][now_k];

          if (data_source == databaseNumber_CLIMATE_TMYEPW) Pb = CLIMATE_TMYEPW_Data[next_i][next_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_CLIMATE_CWEEDS) Pb = CLIMATE_CWEEDS_Data[next_i][next_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_CLIMATE_CLMREC) Pb = CLIMATE_CLMREC_Data[next_i][next_j][LAYER_precipitation_A][now_k];
          if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pb = FORECAST_ENSEMBLE_Data[next_i][next_j][LAYER_precipitation_A][now_k];
          //if (data_source == databaseNumber_CLIMATE_TMYEPW) Pb = CLIMATE_TMYEPW_Data[pre_i][pre_j][LAYER_precipitation_A][now_k];
          //if (data_source == databaseNumber_CLIMATE_CWEEDS) Pb = CLIMATE_CWEEDS_Data[pre_i][pre_j][LAYER_precipitation_A][now_k];
          //if (data_source == databaseNumber_CLIMATE_CLMREC) Pb = CLIMATE_CLMREC_Data[pre_i][pre_j][LAYER_precipitation_A][now_k];
          //if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pb = FORECAST_ENSEMBLE_Data[pre_i][pre_j][LAYER_precipitation_A][now_k];

          if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined)) {
            RAIN = FLOAT_undefined;
          } else {
            RAIN = Pb - Pa;
            //RAIN = Pa - Pb;

            if (T <= 0) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Lewis
            //if ((T < 5) && (T > -5)) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Mojtaba
          }    


          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);
          float HOUR_ANGLE = now_i; 

          float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);






          if (Develop_Option == DEV_OP_00) {  

            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 

              if (Materials_DirectArea_Flags[now_i][now_j] == -1) {
                _valuesSUM[now_k] = FLOAT_undefined;
              } else {
                _valuesSUM[now_k] = 0.001 * (R_dir * Materials_DirectArea_Data[Materials_Selection][now_i][now_j] + R_dif * Materials_DiffuseArea_Data[Materials_Selection][now_i][now_j]);
              }



              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 0.5;
            STUDY_V_offset[LAYER_developed] = 0;
            STUDY_V_belowLine[LAYER_developed] = 1;
            LAYERS_Unit[LAYER_developed] = "KW";
            LAYERS_Title[LAYER_developed][Language_EN] = "Direct radiation on surfaces with material #" + String.valueOf(Materials_Selection);
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          }         


          if (Develop_Option == DEV_OP_01) {
            float Alpha = Develop_AngleInclination;
            float Beta = Develop_AngleOrientation;



            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 

              _valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 0.1;
            STUDY_V_offset[LAYER_developed] = 0;
            STUDY_V_belowLine[LAYER_developed] = 0;
            LAYERS_Unit[LAYER_developed] = "W/m²";
            LAYERS_Title[LAYER_developed][Language_EN] = "Radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 

          if (Develop_Option == DEV_OP_02) {
            float Alpha = Develop_AngleInclination;
            float Beta = Develop_AngleOrientation;

            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 

              _valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
            }


            STUDY_V_scale[LAYER_developed] = 2.5;
            STUDY_V_offset[LAYER_developed] = -40;
            STUDY_V_belowLine[LAYER_developed] = 1;
            LAYERS_Unit[LAYER_developed] = "kWh/m²";
            LAYERS_Title[LAYER_developed][Language_EN] = "Accumulated radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 

          if (Develop_Option == DEV_OP_03) {
            float Alpha = asin_ang(SunR[3]);
            float Beta = atan2_ang(SunR[2], SunR[1]) + 90;

            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 

              _valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 0.1;
            STUDY_V_offset[LAYER_developed] = 0;
            STUDY_V_belowLine[LAYER_developed] = 0;
            LAYERS_Unit[LAYER_developed] = "W/m²";
            LAYERS_Title[LAYER_developed][Language_EN] = "Radiation on solar tracker";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          }         

          if (Develop_Option == DEV_OP_04) {
            float Alpha = asin_ang(SunR[3]);
            float Beta = atan2_ang(SunR[2], SunR[1]) + 90;

            if ((R_dir < 0.9 * FLOAT_undefined) && (R_dif < 0.9 * FLOAT_undefined)) { 

              _valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = 0.001 * _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 2.5;
            STUDY_V_offset[LAYER_developed] = -40;
            STUDY_V_belowLine[LAYER_developed] = 1;
            LAYERS_Unit[LAYER_developed] = "kWh/m²";
            LAYERS_Title[LAYER_developed][Language_EN] = "Accumulated radiation on solar tracker";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 


          if (Develop_Option == DEV_OP_05) {

            if (T < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] += (T - 18) / 24;

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 1.0;
            STUDY_V_offset[LAYER_developed] = 0;
            STUDY_V_belowLine[LAYER_developed] = -1;
            LAYERS_Unit[LAYER_developed] = "°C";
            LAYERS_Title[LAYER_developed][Language_EN] = "Accumulated degree day (based on 18°C)";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 

          if (Develop_Option == DEV_OP_06) {

            _valuesSUM[now_k] = 0;
            float sum_count = 0;

            int num_count = STUDY_TrendJoinHours;


            for (int _count = 1; _count <= num_count; _count += 1) {

              int plus_i = - (_count - 1);

              int new_k = k;
              int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
              int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

              if (new_j >= 365) {
                new_j = new_j % 365;
              }
              if (now_j < 0) {
                new_j = (new_j + 365) % 365;
              }

              float T_new = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[new_i][new_j][STUDY_DevelopLayer][new_k];

              if (Pa > 0.9 * FLOAT_undefined) {
                T_new = FLOAT_undefined;
              } else {
                T_new = Pa;
              }            

              if (T_new < 0.9 * FLOAT_undefined) {
                float _weight = (num_count - _count + 1);
                if (STUDY_TrendJoinType == 1) _weight = 1;
                sum_count += _weight;
                _valuesSUM[now_k] += _weight * T_new;
              }
            } 

            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            } else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
            }

            _valuesSUM[now_k] = 0;


            STUDY_V_scale[LAYER_developed] = STUDY_V_scale[STUDY_DevelopLayer];
            STUDY_V_offset[LAYER_developed] = STUDY_V_offset[STUDY_DevelopLayer];
            STUDY_V_belowLine[LAYER_developed] = STUDY_V_belowLine[STUDY_DevelopLayer];
            LAYERS_Unit[LAYER_developed] = LAYERS_Unit[STUDY_DevelopLayer];
            LAYERS_Title[LAYER_developed][Language_EN] = String.valueOf(STUDY_TrendJoinHours) + "-hour PASSIVE trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_EN];
            LAYERS_Title[LAYER_developed][Language_FR] = String.valueOf(STUDY_TrendJoinHours) + "-hour PASSIVE trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_FR]; // ??
          }     


          if (Develop_Option == DEV_OP_07) {

            _valuesSUM[now_k] = 0;
            float sum_count = 0;

            int num_count = STUDY_TrendJoinHours;


            for (int _count = 1; _count <= ceil ( (num_count + 1) / 2); _count += 1) {
              for (int dir_count = -1; dir_count <= 1; dir_count += 2) {

                int plus_i = dir_count * (_count - 1);

                int new_k = k;
                int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }

                float T_new = FLOAT_undefined;

                if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
                if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
                if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
                if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[new_i][new_j][STUDY_DevelopLayer][new_k];

                if (Pa > 0.9 * FLOAT_undefined) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }            

                if (T_new < 0.9 * FLOAT_undefined) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY_TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  _valuesSUM[now_k] += _weight * T_new;
                }
              }
            } 

            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            } else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
            }

            _valuesSUM[now_k] = 0;


            STUDY_V_scale[LAYER_developed] = STUDY_V_scale[STUDY_DevelopLayer];
            STUDY_V_offset[LAYER_developed] = STUDY_V_offset[STUDY_DevelopLayer];
            STUDY_V_belowLine[LAYER_developed] = STUDY_V_belowLine[STUDY_DevelopLayer];
            LAYERS_Unit[LAYER_developed] = LAYERS_Unit[STUDY_DevelopLayer];
            LAYERS_Title[LAYER_developed][Language_EN] = String.valueOf(STUDY_TrendJoinHours) + "-hour NORMAL trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_EN];
            LAYERS_Title[LAYER_developed][Language_FR] = String.valueOf(STUDY_TrendJoinHours) + "-hour NORMAL trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_FR]; // ??
          }           

          if (Develop_Option == DEV_OP_08) {

            _valuesSUM[now_k] = 0;
            float sum_count = 0;

            int num_count = STUDY_TrendJoinHours;


            for (int _count = num_count; _count > 0; _count -= 1) {

              int plus_i = _count - 1;

              int new_k = k;
              int new_i = ((i + plus_i) + 24 * floor((i + plus_i) / 24.0)) % 24;
              int new_j = (j + TIME_BeginDay + 365 + floor((i + plus_i) / 24.0)) % 365;

              if (new_j >= 365) {
                new_j = new_j % 365;
              }
              if (now_j < 0) {
                new_j = (new_j + 365) % 365;
              }

              float T_new = FLOAT_undefined;

              if (data_source == databaseNumber_CLIMATE_TMYEPW) Pa = CLIMATE_TMYEPW_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) Pa = CLIMATE_CWEEDS_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) Pa = CLIMATE_CLMREC_Data[new_i][new_j][STUDY_DevelopLayer][new_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) Pa = FORECAST_ENSEMBLE_Data[new_i][new_j][STUDY_DevelopLayer][new_k];

              if (Pa > 0.9 * FLOAT_undefined) {
                T_new = FLOAT_undefined;
              } else {
                T_new = Pa;
              }            

              if (T_new < 0.9 * FLOAT_undefined) {
                float _weight = (num_count - _count + 1);
                if (STUDY_TrendJoinType == 1) _weight = 1;
                sum_count += _weight;
                _valuesSUM[now_k] += _weight * T_new;
              }
            } 

            if (sum_count != 0) {
              _valuesSUM[now_k] /= sum_count;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            } else {
              _valuesSUM[now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = FLOAT_undefined;
            }

            _valuesSUM[now_k] = 0;


            STUDY_V_scale[LAYER_developed] = STUDY_V_scale[STUDY_DevelopLayer];
            STUDY_V_offset[LAYER_developed] = STUDY_V_offset[STUDY_DevelopLayer];
            STUDY_V_belowLine[LAYER_developed] = STUDY_V_belowLine[STUDY_DevelopLayer];
            LAYERS_Unit[LAYER_developed] = LAYERS_Unit[STUDY_DevelopLayer];
            LAYERS_Title[LAYER_developed][Language_EN] = String.valueOf(STUDY_TrendJoinHours) + "-hour ACTIVE trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_EN];
            LAYERS_Title[LAYER_developed][Language_FR] = String.valueOf(STUDY_TrendJoinHours) + "-hour ACTIVE trend of " + LAYERS_Title[STUDY_DevelopLayer][Language_FR]; // ??
          } 


          if (Develop_Option == DEV_OP_09) {

            if (RAIN < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] = RAIN;

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 2.5;
            STUDY_V_offset[LAYER_developed] = 0; //-20.0 / (1.0 * STUDY_LevelPix); // so that we can have two views on probabilites above and below zero.
            STUDY_V_belowLine[LAYER_developed] = 0; //1;
            LAYERS_Unit[LAYER_developed] = "mm/12hours";
            LAYERS_Title[LAYER_developed][Language_EN] = "12-hour Surface Accumulated Precipitation";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 

          if (Develop_Option == DEV_OP_10) {

            if (RAIN < 0.9 * FLOAT_undefined) { 
              _valuesSUM[now_k] = RAIN;

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 4.0;
            STUDY_V_offset[LAYER_developed] = 0; 
            STUDY_V_belowLine[LAYER_developed] = 1;
            LAYERS_Unit[LAYER_developed] = "mm/h";
            LAYERS_Title[LAYER_developed][Language_EN] = "Hourly Surface Precipitation (interpolated)";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          } 


          if (Develop_Option == DEV_OP_11) {

            if (WS < 0.9 * FLOAT_undefined) { 

              _valuesSUM[now_k] = 0.5 * 1.23 * 1 * pow(WS / 3.6, 3); 

              if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
              if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k] = _valuesSUM[now_k];
            }

            STUDY_V_scale[LAYER_developed] = 0.05;
            STUDY_V_offset[LAYER_developed] = 0;
            STUDY_V_belowLine[LAYER_developed] = 0;
            LAYERS_Unit[LAYER_developed] = "W/m²";
            LAYERS_Title[LAYER_developed][Language_EN] = "Wind power";
            LAYERS_Title[LAYER_developed][Language_FR] = LAYERS_Title[LAYER_developed][Language_EN]; // ??
          }    






          if ((Develop_Option == DEV_OP_02) || (Develop_Option == DEV_OP_04)) {

            if ((i == 23) && (Develop_DayHour == 1)) {
              for (int l = i + 1 - 24; l <= i; l += 1) {
                if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[l][now_j][LAYER_developed][now_k] = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k];
              }
              //STUDY_SumInterval = 24;
              STUDY_V_scale[LAYER_developed] = 10;
              STUDY_V_offset[LAYER_developed] = 0;
              STUDY_V_belowLine[LAYER_developed] = 0;
              LAYERS_Unit[LAYER_developed] += "/day";

              _valuesSUM[now_k] = 0;
            }

            if (((i == 11) || (i == 23)) && (Develop_DayHour == 2)) {
              for (int l = i + 1 - 12; l <= i; l += 1) {
                if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[l][now_j][LAYER_developed][now_k] = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k];
              }
              //STUDY_SumInterval = 12;
              STUDY_V_scale[LAYER_developed] = 10;
              STUDY_V_offset[LAYER_developed] = 0;
              STUDY_V_belowLine[LAYER_developed] = 0;
              LAYERS_Unit[LAYER_developed] += "/12hours";

              _valuesSUM[now_k] = 0;
            }   

            if (((i == 5) || (i == 11) || (i == 17) || (i == 23)) && (Develop_DayHour == 3)) {
              for (int l = i + 1 - 6; l <= i; l += 1) {
                if (data_source == databaseNumber_CLIMATE_TMYEPW) CLIMATE_TMYEPW_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CWEEDS) CLIMATE_CWEEDS_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_CLIMATE_CLMREC) CLIMATE_CLMREC_Data[l][now_j][LAYER_developed][now_k] = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_developed][now_k];
                if (data_source == databaseNumber_FORECAST_ENSEMBLE) FORECAST_ENSEMBLE_Data[l][now_j][LAYER_developed][now_k] = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_developed][now_k];
              }
              //STUDY_SumInterval = 6;
              STUDY_V_scale[LAYER_developed] = 10;
              STUDY_V_offset[LAYER_developed] = 0;
              STUDY_V_belowLine[LAYER_developed] = 0;
              LAYERS_Unit[LAYER_developed] += "/6hours";

              _valuesSUM[now_k] = 0;
            }
          }
        }
      }
    }
  }

  STUDY_PerDays = keep_STUDY_PerDays;
  STUDY_JoinDays = keep_STUDY_JoinDays;
}





int STAT_N_MidLow = 0;
int STAT_N_Middle = 1;
int STAT_N_MidHigh = 2;

int STAT_N_M25 = 3;
int STAT_N_M50 = 4;
int STAT_N_M75 = 5;

int STAT_N_Min = 6;
int STAT_N_Ave = 7;
int STAT_N_Max = 8;

String[] STAT_N_Title = {
  "Mid-LOW*       ", 
  "MIDDLE*        ", 
  "Mid-HIGH*      ", 

  "25th Percentile", 
  "50th P.(Median)", 
  "75th Percentile", 

  "MINIMUM        ", 
  "AVERAGE        ", 
  "MAXIMUM        "
};

int[] STAT_reverse_N;
{
  STAT_reverse_N = new int [9];
  STAT_reverse_N[STAT_N_MidLow] = STAT_N_MidHigh;
  STAT_reverse_N[STAT_N_Middle] = STAT_N_Middle;
  STAT_reverse_N[STAT_N_MidHigh] = STAT_N_MidLow;
  STAT_reverse_N[STAT_N_M25] = STAT_N_M75;
  STAT_reverse_N[STAT_N_M50] = STAT_N_M50;
  STAT_reverse_N[STAT_N_M75] = STAT_N_M25;
  STAT_reverse_N[STAT_N_Min] = STAT_N_Max;
  STAT_reverse_N[STAT_N_Ave] = STAT_N_Ave;
  STAT_reverse_N[STAT_N_Max] = STAT_N_Min;
}

float[] SOLARCHVISION_NORMAL (float[] _values) {

  float[] weight_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  float[] return_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };

  int NV = 0; // the number of values without counting undefined values
  float _weight = 0; 

  _values = sort(_values);
  for (int i = 0; i < _values.length; i += 1) {
    if (_values[i] < 0.9 * FLOAT_undefined) NV += 1;
  }

  if (NV > 0) {
    for (int i = 0; i < NV; i += 1) {
      if (_values[i] < 0.9 * FLOAT_undefined) {
        _weight = 1;
        weight_array[STAT_N_Ave] += _weight;
        return_array[STAT_N_Ave] += _values[i];

        _weight = (0.5 * (NV + 1)) - abs((0.5 * (NV + 1)) - (i + 1));
        weight_array[STAT_N_Middle] += _weight;
        return_array[STAT_N_Middle] += _values[i] * _weight;

        _weight = (i + 1);
        weight_array[STAT_N_MidHigh] += _weight;
        return_array[STAT_N_MidHigh] += _values[i] * _weight;

        _weight = (NV + 1 - i);
        weight_array[STAT_N_MidLow] += _weight;
        return_array[STAT_N_MidLow] += _values[i] * _weight;
      }
    }

    return_array[STAT_N_Ave] /= weight_array[STAT_N_Ave];
    return_array[STAT_N_Middle] /= weight_array[STAT_N_Middle];
    return_array[STAT_N_MidHigh] /= weight_array[STAT_N_MidHigh];
    return_array[STAT_N_MidLow] /= weight_array[STAT_N_MidLow];

    return_array[STAT_N_Max] = _values[(NV - 1)];
    return_array[STAT_N_Min] = _values[0];

    if ((NV % 2) == 1) {

      return_array[STAT_N_M50] = _values[(floor(NV / 2))];
    } else {

      return_array[STAT_N_M50] = 0.5 * (_values[(floor(NV / 2))] + _values[(floor(NV / 2) - 1)]);
    }

    int q;

    q = int(roundTo((NV * 0.75), 1));
    if (q > NV - 1) q = NV - 1;
    return_array[STAT_N_M75] = _values[q];

    q = int(roundTo((NV * 0.25), 1));
    if (q < 0) q = 0;
    return_array[STAT_N_M25] = _values[q];
  } else {
    for (int i = 0; i < return_array.length; i += 1) {
      return_array[i] = FLOAT_undefined;
    }
  }

  return return_array;
}



int SOLARCHVISION_filter (String data_type, int LAYER_cloudcover, int type_of_filter, int scenario_of_sky, int now_i, int now_j, int now_k) {

  float total_sky = 0;
  int num_sky = 0;

  int start_q = now_i;
  int end_q = now_i;

  if (type_of_filter == FILTER_Daily) {
    start_q = 0;
    end_q = 23;
  }

  for (int q = start_q; q <= end_q; q += 1) {
    float _sky = FLOAT_undefined;
    if (data_type.equals("RECENT_OBSERVED_Data")) _sky = RECENT_OBSERVED_Data[q][now_j][LAYER_cloudcover][now_k];
    if (data_type.equals("FORECAST_ENSEMBLE_Data")) _sky = FORECAST_ENSEMBLE_Data[q][now_j][LAYER_cloudcover][now_k];
    if (data_type.equals("CLIMATE_CWEEDS_Data")) _sky = CLIMATE_CWEEDS_Data[q][now_j][LAYER_cloudcover][now_k];
    if (data_type.equals("CLIMATE_CLMREC_Data")) _sky = CLIMATE_CLMREC_Data[q][now_j][LAYER_cloudcover][now_k];
    if (data_type.equals("CLIMATE_TMYEPW_Data")) _sky = CLIMATE_TMYEPW_Data[q][now_j][LAYER_cloudcover][now_k];

    if (_sky > 0.9 * FLOAT_undefined) {
    } else {
      total_sky += _sky;
      num_sky += 1;
    }
  }


  int _return = 0;

  if (num_sky != 0) {
    total_sky /= num_sky;

    if (scenario_of_sky == 1) _return = 1;
    else if ((scenario_of_sky == 4) && (total_sky <= 3.33)) _return = 1;
    else if ((scenario_of_sky == 3) && (total_sky > 3.33) && (total_sky <= 6.66)) _return = 1; 
    else if ((scenario_of_sky == 2) && (total_sky > 6.66)) _return = 1;
  }

  return _return;
}


int[] SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS (float[] _values) {

  float[] _normals = SOLARCHVISION_NORMAL(_values);

  int[] return_array = new int [9];

  for (int l = 0; l < 9; l += 1) {
    return_array[l] = -1;
    if (_normals[l] < 0.9 * FLOAT_undefined) {

      float _dist = FLOAT_undefined;

      for (int i = 0; i < _values.length; i += 1) {
        if (_dist > abs(_normals[l] - _values[i])) {
          _dist = abs(_normals[l] - _values[i]);
          return_array[l] = i;
        }
      }
    } else return_array[l] = -1;
  }

  return return_array;
}


int[] SOLARCHVISION_PROCESS_DAILY_SCENARIOS (int layers_count, int start_z, int end_z, int j, float DATE_ANGLE) {

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  float[] _valuesSUM_RAD; 
  float[] _valuesSUM_EFF;
  float[] _valuesNUM;
  _valuesSUM_RAD = new float [(layers_count * STUDY_JoinDays)];
  _valuesSUM_EFF = new float [(layers_count * STUDY_JoinDays)];
  _valuesNUM = new float [(layers_count * STUDY_JoinDays)];

  for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {
    for (int k = 0; k < layers_count; k += 1) { 
      _valuesSUM_RAD[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
      _valuesSUM_EFF[(k * STUDY_JoinDays + j_ADD)] = FLOAT_undefined;
      _valuesNUM[(k * STUDY_JoinDays + j_ADD)] = 0;
    }
  }

  for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {

    for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

      for (int i = 0; i < 24; i += 1) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

        int now_k = k;
        int now_i = i;
        int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
          Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
          Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
          Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
        }
        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
          Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
          Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
          Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
        }        
        if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
          Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
          Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
          Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
        }            
        if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
          Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
          Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
          Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
        }   
        if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
          Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
          Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
          Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
          Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
        }   

        if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
        } else {

          int drw_count = 0;
          if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
          if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
          if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
          if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
          if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

          if (drw_count == 1) {
            _values_R_dir = 0.001 * Pa;
            _values_R_dif = 0.001 * Pb;
            _values_E_dir = 0.0001 * Pc;
            _values_E_dif = 0; //0.0001 * Pd;

            if (_valuesSUM_RAD[(k * STUDY_JoinDays + j_ADD)] > 0.9 * FLOAT_undefined) {
              _valuesSUM_RAD[(k * STUDY_JoinDays + j_ADD)] = 0;
              _valuesSUM_EFF[(k * STUDY_JoinDays + j_ADD)] = 0;
              _valuesNUM[(k * STUDY_JoinDays + j_ADD)] = 0;
            }                  

            _valuesSUM_RAD[(k * STUDY_JoinDays + j_ADD)] += ((_values_R_dir * SunR[3]) + (_values_R_dif)); // calculates total horizontal radiation
            _valuesSUM_EFF[(k * STUDY_JoinDays + j_ADD)] += ((_values_E_dir * SunR[3]) + (_values_E_dif)); // calculates total horizontal effects
            _valuesNUM[(k * STUDY_JoinDays + j_ADD)] += 1;
          }
        }
      }
    }
  }

  if (Impact_TYPE == Impact_PASSIVE) 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_EFF);
  else 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(_valuesSUM_RAD);
}


void SOLARCHVISION_PlotIMPACT (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

  STUDY_Diagrams.pushMatrix();
  STUDY_Diagrams.translate(x_Plot, y_Plot);

  float keep_STUDY_PerDays = STUDY_PerDays;
  int keep_STUDY_JoinDays = STUDY_JoinDays;

  if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
    STUDY_PerDays = 1;
    STUDY_JoinDays = 1;
  }

  int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
  int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
  int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2]; 


  if ((STUDY_PlotImpacts == -2) || (STUDY_PlotImpacts == -1)) {

    SOLARCHVISION_build_WindRose_Image_array(); 

    int RES = WindRose_RES;

    Rendered_WindRose_RES = RES;

    if (STUDY_PlotImpacts == -2) Impact_TYPE = Impact_WIND_Overlay; 
    if (STUDY_PlotImpacts == -1) Impact_TYPE = Impact_WIND_Temperature;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;

    float[] _values_w_dir;
    float[] _values_w_spd; 
    float[] _values_w_tmp; 
    _values_w_dir = new float [layers_count];
    _values_w_spd = new float [layers_count]; 
    _values_w_tmp = new float [layers_count]; 

    for (int k = 0; k < layers_count; k += 1) { 
      _values_w_dir[k] = FLOAT_undefined;
      _values_w_spd[k] = FLOAT_undefined;
      _values_w_tmp[k] = FLOAT_undefined;
    }

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_WIND_Overlay) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_WIND_Temperature) {  
      //PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
      PAL_TYPE = 12; 
      PAL_DIR = -1;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_WIND_Overlay) PAL_Multiplier = 1.0;
    if (Impact_TYPE == Impact_WIND_Temperature) PAL_Multiplier = 1.0 / 30.0;

    for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 

      PGraphics WIND_Diagrams = createGraphics(RES, RES); 
      WIND_Diagrams.beginDraw();
      //WIND_Diagrams.background(255);
      WIND_Diagrams.translate(0.5 * RES, 0.5 * RES);

      for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {    
        for (int i = 0; i < 24; i += 1) {
          if (STUDY_isInHourlyRange(i) == 1) {

            for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;

              int _plot = 1;

              if (_plot == 1) {

                int now_k = k;
                int now_i = i;
                int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                  Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_drybulb][now_k];
                }
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                  Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_drybulb][now_k];
                }                
                if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                  Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_drybulb][now_k];
                }            
                if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                  Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_drybulb][now_k];
                }   
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                  Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_drybulb][now_k];
                }   

                if (Pa > 0.9 * FLOAT_undefined || Pb > 0.9 * FLOAT_undefined || Pc > 0.9 * FLOAT_undefined) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                } else {
                  int drw_count = 0;
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                  if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) && (FORECAST_ENSEMBLE_Flags[now_i][now_j][LAYER_winddir][now_k] != 1)) drw_count = 0;

                  if (drw_count == 1) {

                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;

                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (STUDY_V_scale[LAYER_windspd] / 2.0) * (_values_w_spd[k] / 50.0);

                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 

                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));

                    float _u = 0;

                    if (Impact_TYPE == Impact_WIND_Overlay) {

                      float _s = (STUDY_O_scale / 100) * 255 / (0.333 * layers_count); 

                      if (STUDY_skyScenario_Active > 1) _s *= 3; // to improve visibility of those cases.

                      _s /= float(STUDY_JoinDays);

                      if (_s < 10) _s = 10;

                      WIND_Diagrams.stroke(0, _s);
                      WIND_Diagrams.fill(0, _s); 

                      WIND_Diagrams.strokeWeight(STUDY_T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_WIND_Temperature) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);

                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;

                      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

                      WIND_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);

                      WIND_Diagrams.strokeWeight(STUDY_T_scale * 2);
                      WIND_Diagrams.noFill();
                    }

                    WIND_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  }
                }
              }
            }
          }
        }
      }
      WIND_Diagrams.endDraw();
      WindRose_Image[j + 1] = WIND_Diagrams;
    }




    PGraphics total_WIND_Diagrams = createGraphics(RES, RES); 
    total_WIND_Diagrams.beginDraw();
    //total_WIND_Diagrams.background(255);
    total_WIND_Diagrams.translate(0.5 * RES, 0.5 * RES);

    for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 
      for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {    
        for (int i = 0; i < 24; i += 1) {
          if (STUDY_isInHourlyRange(i) == 1) {

            for (int k = (start_z - 1); k <= (end_z - 1); k += 1) {

              _values_w_dir[k] = FLOAT_undefined;
              _values_w_spd[k] = FLOAT_undefined;
              _values_w_tmp[k] = FLOAT_undefined;

              int _plot = 1;

              if (_plot == 1) {

                int now_k = k;
                int now_i = i;
                int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                  Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_drybulb][now_k];
                }
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                  Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_drybulb][now_k];
                }                
                if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                  Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_drybulb][now_k];
                }            
                if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                  Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_drybulb][now_k];
                }   
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                  Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_winddir][now_k]; 
                  Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_windspd][now_k]; 
                  Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_drybulb][now_k];
                }   

                if (Pa > 0.9 * FLOAT_undefined || Pb > 0.9 * FLOAT_undefined || Pc > 0.9 * FLOAT_undefined) {
                  _values_w_dir[k] = FLOAT_undefined;
                  _values_w_spd[k] = FLOAT_undefined;
                  _values_w_tmp[k] = FLOAT_undefined;
                } else {
                  int drw_count = 0;
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                  if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) && (FORECAST_ENSEMBLE_Flags[now_i][now_j][LAYER_winddir][now_k] != 1)) drw_count = 0;

                  if (drw_count == 1) {

                    _values_w_dir[k] = Pa;
                    _values_w_spd[k] = Pb;
                    _values_w_tmp[k] = Pc;

                    float T = _values_w_tmp[k];
                    float teta = _values_w_dir[k];
                    float D_teta = 15; 
                    float R = (0.5 * RES) * (STUDY_V_scale[LAYER_windspd] / 2.0) * (_values_w_spd[k] / 50.0);

                    float R_in = 0; //0.75 * R; 
                    float x1 = R_in * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y1 = R_in * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x2 = R_in * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y2 = R_in * -sin_ang(90 - (teta + 0.5 * D_teta)); 

                    float x4 = R * cos_ang(90 - (teta - 0.5 * D_teta));
                    float y4 = R * -sin_ang(90 - (teta - 0.5 * D_teta));
                    float x3 = R * cos_ang(90 - (teta + 0.5 * D_teta));
                    float y3 = R * -sin_ang(90 - (teta + 0.5 * D_teta));

                    float _u = 0;

                    if (Impact_TYPE == Impact_WIND_Overlay) {

                      float _s = (STUDY_O_scale / 100) * 255 / (0.333 * layers_count) / (STUDY_j_End - STUDY_j_Start);

                      if (STUDY_skyScenario_Active > 1) _s *= 3; // to improve visibility of those cases.

                      _s /= float(STUDY_JoinDays);

                      if (_s < 10) _s = 10;

                      total_WIND_Diagrams.stroke(0, _s);
                      total_WIND_Diagrams.fill(0, _s); 

                      total_WIND_Diagrams.strokeWeight(STUDY_T_scale * 0);
                    }
                    if (Impact_TYPE == Impact_WIND_Temperature) {
                      _u = 0.5 + 0.5 * (PAL_Multiplier * T);

                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;

                      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
                      total_WIND_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);

                      total_WIND_Diagrams.strokeWeight(STUDY_T_scale * 2);
                      total_WIND_Diagrams.noFill();
                    }

                    total_WIND_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  }
                }
              }
            }
          }
        }
      }
    }
    total_WIND_Diagrams.endDraw();
    WindRose_Image[0] = total_WIND_Diagrams;          

    for (int j = STUDY_j_Start - 1; j < STUDY_j_End; j += 1) {
      if ((j != -1) || (STUDY_impact_summary == 1)) {
        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
        STUDY_Diagrams.stroke(223);
        STUDY_Diagrams.fill(223); 
        STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.noFill(); 
        STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

        STUDY_Diagrams.imageMode(CENTER); 
        STUDY_Diagrams.image(WindRose_Image[j + 1], (j + 100 * STUDY_rect_scale) * sx_Plot, 0, int((180 * STUDY_rect_scale) * sx_Plot), int((180 * STUDY_rect_scale) * sx_Plot));
      }
    }   

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

    if (STUDY_impact_summary == 1) {
      int j = -1; // << to put the summary graph before the daily graphs

      int keep_STUDY_j_Start = STUDY_j_Start;
      int keep_STUDY_j_End = STUDY_j_End;
      STUDY_j_Start = j;
      STUDY_j_End = j + 1;
      SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
      STUDY_j_Start = keep_STUDY_j_Start;
      STUDY_j_End = keep_STUDY_j_End;

      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.noFill(); 
      STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);
    }

    if (Impact_TYPE != Impact_WIND_Overlay) { 

      float pal_length = 400;
      for (int q = 0; q < 11; q += 1) {
        float _u = 0;

        if (Impact_TYPE == Impact_WIND_Temperature) _u = 0.1 * q;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
        STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
        STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);         

        STUDY_Diagrams.strokeWeight(0);
        STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          STUDY_Diagrams.stroke(127);
          STUDY_Diagrams.fill(127);
          STUDY_Diagrams.strokeWeight(0);
        } else {
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.fill(255);
          STUDY_Diagrams.strokeWeight(2);
        }  

        STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
        STUDY_Diagrams.textAlign(CENTER, CENTER);

        if (Impact_TYPE == Impact_WIND_Temperature) STUDY_Diagrams.text(nf(0.2 * (q - 5) / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      }
    }         


    if (STUDY_PrintTtitle != 0) {

      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_WIND_Overlay) {  
        STUDY_Diagrams.text(("Wind direction and speed"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_WIND_Temperature) {  
        STUDY_Diagrams.text(("Wind direction and speed with air temperature"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
    }

    if (Display_WindRoseImage != 0) WIN3D_Update = 1;
  } 





  if ((STUDY_PlotImpacts == 0) || (STUDY_PlotImpacts == 1)) {

    if (STUDY_Impacts_Update == 1) {

      SOLARCHVISION_calculate_SolarImpact_CurrentSection();

      int RES1 = SolarImpact_RES1;
      int RES2 = SolarImpact_RES2;

      if (STUDY_PlotImpacts == 0) Impact_TYPE = Impact_ACTIVE; 
      if (STUDY_PlotImpacts == 1) Impact_TYPE = Impact_PASSIVE;

      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;

      float _values_R_dir;
      float _values_R_dif;

      float _values_E_dir;
      float _values_E_dif;

      int now_k = 0;
      int now_i = 0;
      int now_j = 0;

      int PAL_TYPE = 0; 
      int PAL_DIR = 1;
      float PAL_Multiplier = 1; 

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
        PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
        PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
      }        

      for (int p = 0; p < 1; p += 1) { 
        int l = STUDY_ImpactLayer;

        for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

          now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }


          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
          STUDY_Diagrams.stroke(223);
          STUDY_Diagrams.fill(223); 
          STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.noFill(); 
          STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

          STUDY_Diagrams.imageMode(CENTER); 
          STUDY_Diagrams.image(SolarImpact_Image[j + 1], (j + 100 * STUDY_rect_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY_U_scale), int((180 * STUDY_rect_scale) * sx_Plot), int((180 * STUDY_rect_scale) * sx_Plot));

          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.fill(0);
          STUDY_Diagrams.textAlign(CENTER, CENTER); 
          STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

          String scenario_text = "";
          //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
          //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
          //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);
        }

        //----------------------
        if (Camera_Variation == 0) STUDY_impact_summary = 1; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        //----------------------

        if (STUDY_impact_summary == 1) { 
          int j = -1; // << to put the summary graph before the daily graphs

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);
          STUDY_Diagrams.stroke(223);
          STUDY_Diagrams.fill(223); 
          //STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

          STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.noFill(); 
          //STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);

          STUDY_Diagrams.imageMode(CENTER); 
          //STUDY_Diagrams.image(SolarImpact_Image[j + 1], (j + 100 * STUDY_rect_scale) * sx_Plot, - (1 * p * sx_Plot / STUDY_U_scale), int((180 * STUDY_rect_scale) * sx_Plot), int((180 * STUDY_rect_scale) * sx_Plot));

          STUDY_Diagrams.stroke(0);
          STUDY_Diagrams.fill(0);
          STUDY_Diagrams.textAlign(CENTER, CENTER); 
          STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        }

        String scenario_text = "";
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY_Diagrams.text(scenario_text, ((STUDY_j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, CENTER); 
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(0); 

        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, CENTER); 
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(0); 

        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY_Diagrams.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY_Diagrams.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
        }            
        //?? French
      }

      float pal_length = 400;
      for (int q = 0; q < 11; q += 1) {
        float _u = 0;

        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
        STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
        STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);         

        STUDY_Diagrams.strokeWeight(0);
        STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          STUDY_Diagrams.stroke(127);
          STUDY_Diagrams.fill(127);
          STUDY_Diagrams.strokeWeight(0);
        } else {
          STUDY_Diagrams.stroke(255);
          STUDY_Diagrams.fill(255);
          STUDY_Diagrams.strokeWeight(2);
        }  

        STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
        if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
        if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      }

      if (STUDY_PrintTtitle != 0) {

        STUDY_Diagrams.stroke(0); 
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(RIGHT, TOP); 
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);

        String Model_Description = "";
        //if (Camera_Variation == 1) Model_Description = "TR: Place-des-Arts";
        //if (Camera_Variation == 2) Model_Description = "EV_BUILDING";

        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
        STUDY_Diagrams.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          STUDY_Diagrams.text((Model_Description + "Analysis of Active Potentials (kW/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          STUDY_Diagrams.text((Model_Description + "Analysis of Passive Potentials (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
          //?? French
        }
      }
    }

    if (Display_SolarImpactImage != 0) WIN3D_Update = 1;
  }





  if ((STUDY_PlotImpacts == 2) || (STUDY_PlotImpacts == 3)) {

    if (rebuild_SolarProjection_array != 0) {
      SOLARCHVISION_build_SolarProjection_array();
    }

    if (STUDY_PlotImpacts == 2) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY_PlotImpacts == 3) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT; 

    //for (int p = 0; p < 3; p += 1) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p += 1) { 
      int l = STUDY_ImpactLayer;

      //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(STUDY_ImpactLayer / 3) + 1; //STUDY_ImpactLayer;    

      float[][] TOTAL_valuesSUM_RAD = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
      int[][] TOTAL_valuesNUM = new int [1 + int(90 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];

      for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
        for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
          TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
          TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
          TOTAL_valuesNUM[a][b] = 0;
        }
      }

      for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

        now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / STUDY_JoinDays);
            int j_ADD = nk % STUDY_JoinDays; 

            for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
              float Alpha = a * SOLARCHVISION_GLOBE_stp_slp;
              for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
                float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

                float _valuesSUM_RAD = 0;
                float _valuesSUM_EFF_P = 0;
                float _valuesSUM_EFF_N = 0;
                int _valuesNUM = 0; 


                for (int i = 0; i < 24; i += 1) {
                  if (STUDY_isInHourlyRange(i) == 1) {              
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                    if (SunR[3] > 0) {

                      now_k = k;
                      now_i = i;
                      now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }

                      if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                        Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                        Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                        Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
                        Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
                      }
                      if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                        Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                        Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                        Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
                        Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
                      }                      
                      if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                        Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                        Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                        Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
                        Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
                      }            
                      if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                        Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                        Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                        Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
                        Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
                      }   
                      if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                        Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                        Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                        Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
                        Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
                      }       

                      if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                        _values_R_dir = FLOAT_undefined;
                        _values_R_dif = FLOAT_undefined;
                        _values_E_dir = FLOAT_undefined;
                        _values_E_dif = FLOAT_undefined;
                      } else {

                        int drw_count = 0;
                        if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                        if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                        if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                        if (drw_count == 1) {
                          _values_R_dir = 0.001 * Pa;
                          _values_R_dif = 0.001 * Pb;
                          _values_E_dir = 0.001 * Pc;
                          _values_E_dif = 0.001 * Pd;

                          if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                            _valuesSUM_RAD = 0;
                            _valuesSUM_EFF_P = 0;
                            _valuesSUM_EFF_N = 0;
                            _valuesNUM = 0;
                          } else {

                            if (_values_E_dir < 0) {
                              _valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                            } else {
                              _valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                            }

                            _valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 

                            _valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }


                if (_valuesNUM != 0) {
                  //float _valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
                  //float _valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
                  float _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);

                  _valuesSUM_RAD *= _valuesMUL;
                  _valuesSUM_EFF_P *= _valuesMUL;
                  _valuesSUM_EFF_N *= _valuesMUL;

                  if (TOTAL_valuesNUM[a][b] == 0) {
                    TOTAL_valuesSUM_RAD[a][b] = 0;
                    TOTAL_valuesSUM_EFF_P[a][b] = 0;
                    TOTAL_valuesSUM_EFF_N[a][b] = 0;
                  }

                  TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
                  TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
                  TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
                  TOTAL_valuesNUM[a][b] += 1;
                } else {
                  _valuesSUM_RAD = FLOAT_undefined;
                  _valuesSUM_EFF_P = FLOAT_undefined;
                  _valuesSUM_EFF_N = FLOAT_undefined;
                }


                float AVERAGE, PERCENTAGE, COMPARISON;

                AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
                if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


                float _valuesSUM = FLOAT_undefined;
                if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

                //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> _valuesSUM_RAD:", _valuesSUM_RAD, "COMPARISON:", COMPARISON);  

                if (_valuesSUM < 0.9 * FLOAT_undefined) {

                  float _u = 0;

                  if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;

                  //float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
                  float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, roundTo(_u, 0.1));
                  STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
                  STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 


                  STUDY_Diagrams.strokeWeight(0);

                  float x1 = (j + STUDY_rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y1 = (                  -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float x2 = (j + STUDY_rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y2 = (                  -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

                  float x3 = (j + STUDY_rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y3 = (                  -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 
                  float x4 = (j + STUDY_rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
                  float y4 = (                  -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

                  STUDY_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                }
              }
            }

            STUDY_Diagrams.stroke(0);
            STUDY_Diagrams.fill(0);
            STUDY_Diagrams.textAlign(CENTER, CENTER); 
            STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

            String scenario_text = "";
            //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY_U_scale);
          }
        }
      }



      if (STUDY_impact_summary == 1) { 

        int j = -1; // << to put the summary graph before the daily graphs

        for (int a = 0; a <= int (90 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
          float Alpha = a * SOLARCHVISION_GLOBE_stp_slp;
          for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
            float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

            if (TOTAL_valuesNUM[a][b] != 0) {
              TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
              TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
            } else {
              TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
              TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
            if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD[a][b];
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

            //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> (TOTAL) _valuesSUM_RAD:", TOTAL_valuesSUM_RAD[a][b], "COMPARISON:", COMPARISON);  

            if (_valuesSUM < 0.9 * FLOAT_undefined) {

              float _u = 0;

              if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
              if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;

              //float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
              float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, roundTo(_u, 0.1));
              STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
              STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);               

              STUDY_Diagrams.strokeWeight(0);

              float x1 = (j + STUDY_rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y1 = (                  -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float x2 = (j + STUDY_rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y2 = (                  -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 - 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

              float x3 = (j + STUDY_rect_offset_x + (90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y3 = (                  -(90 - Alpha + 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 
              float x4 = (j + STUDY_rect_offset_x + (90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (cos_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot;
              float y4 = (                  -(90 - Alpha - 0.5 * SOLARCHVISION_GLOBE_stp_slp) * STUDY_rect_scale * (sin_ang(Beta - 90 + 0.5 * SOLARCHVISION_GLOBE_stp_dir))) * sx_Plot; 

              STUDY_Diagrams.quad(x1, y1, x2, y2, x3, y3, x4, y4);
            }
          }
        }

        STUDY_Diagrams.strokeWeight(STUDY_T_scale * 2);
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.noFill(); 
        STUDY_Diagrams.rect((j + STUDY_rect_offset_x - 100 * STUDY_rect_scale) * sx_Plot, (-100 * STUDY_rect_scale) * sx_Plot - (1 * p * sx_Plot / STUDY_U_scale), (200 * STUDY_rect_scale) * sx_Plot, (200 * STUDY_rect_scale) * sx_Plot);


        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.textAlign(CENTER, CENTER); 
        STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

        String scenario_text = "";
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / STUDY_U_scale);

        int keep_STUDY_j_Start = STUDY_j_Start;
        int keep_STUDY_j_End = STUDY_j_End;
        STUDY_j_Start = j;
        STUDY_j_End = j + 1;
        SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
        STUDY_j_Start = keep_STUDY_j_Start;
        STUDY_j_End = keep_STUDY_j_End;
      }


      String scenario_text = "";
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French
    }

    float pal_length = 400;
    for (int q = 0; q < 11; q += 1) {
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      } else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   

      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf((roundTo(0.1 * q / PAL_Multiplier, 0.1)), 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
    }


    if (STUDY_PrintTtitle != 0) {

      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Solar radiation on hemisphere (kW/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Solar effects on hemisphere (%kW°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
    }

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  } 



  if ((STUDY_PlotImpacts == 4) || (STUDY_PlotImpacts == 5)) {
    if (STUDY_PlotImpacts == 4) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY_PlotImpacts == 5) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

    //for (int p = 0; p < 3; p += 1) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p += 1) { 
      int l = STUDY_ImpactLayer;

      //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(STUDY_ImpactLayer / 3) + 1; //STUDY_ImpactLayer;    

      for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

        now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / STUDY_JoinDays);
            int j_ADD = nk % STUDY_JoinDays; 

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i += 1) {
              if (STUDY_isInHourlyRange(i) == 1) {
                if ((i > _sunrise) && (i < _sunset)) {

                  float HOUR_ANGLE = i; 
                  float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                  float Alpha = 90 - acos_ang(SunR[3]);
                  float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

                  now_k = k;
                  now_i = i;
                  now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }                  
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }            
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                    Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }          

                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int drw_count = 0;
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF = 0;
                        _valuesNUM = 0;
                      } else {
                        _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                        _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                        _valuesNUM = 1;
                      }
                    }
                  }

                  float _valuesSUM = FLOAT_undefined;
                  if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 

                  if (_valuesSUM < 0.9 * FLOAT_undefined) {

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * _valuesSUM);

                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;

                    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
                    STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
                    STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);                     

                    STUDY_Diagrams.strokeWeight(0);

                    STUDY_Diagrams.ellipse((j + STUDY_rect_offset_x + (90 - Alpha) * STUDY_rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY_rect_scale * (sin_ang(Beta - 90))) * sx_Plot, 0.075 * sx_Plot, 0.075 * sx_Plot);

                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      STUDY_Diagrams.stroke(127);
                      STUDY_Diagrams.fill(127);
                      STUDY_Diagrams.strokeWeight(0);
                    } else {
                      STUDY_Diagrams.stroke(255);
                      STUDY_Diagrams.fill(255);
                      STUDY_Diagrams.strokeWeight(2);
                    }   

                    STUDY_Diagrams.textSize(STUDY_S_View * 4.0 * STUDY_U_scale);

                    STUDY_Diagrams.textAlign(CENTER, CENTER);
                    if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(_valuesSUM, 1, 1), (j + STUDY_rect_offset_x + (90 - Alpha) * STUDY_rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY_rect_scale * (sin_ang(Beta - 90))) * sx_Plot);
                    if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(_valuesSUM), 1), (j + STUDY_rect_offset_x + (90 - Alpha) * STUDY_rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY_rect_scale * (sin_ang(Beta - 90))) * sx_Plot);
                  }
                }
              }
            }

            STUDY_Diagrams.stroke(0);
            STUDY_Diagrams.fill(0);
            STUDY_Diagrams.textAlign(CENTER, CENTER); 
            STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);

            String scenario_text = "";
            //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            STUDY_Diagrams.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95  * sx_Plot / STUDY_U_scale);
          }
        }
      }

      String scenario_text = "";
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French
    }

    float pal_length = 400;
    for (int q = 0; q < 11; q += 1) {
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -175 * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View); 

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      } else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   

      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - 175 - 0.05 * 20) * STUDY_S_View);
    } 


    if (STUDY_PrintTtitle != 0) {

      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Direct solar radiation (kWh/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Direct solar effects (kWh°C/m²)"), 0, 1.4 * sx_Plot / STUDY_U_scale);
        //?? French
      }
    }
  } 



  if ((STUDY_PlotImpacts == 6) || (STUDY_PlotImpacts == 7)) {
    if (STUDY_PlotImpacts == 6) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY_PlotImpacts == 7) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;
    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

    SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);


    for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

      now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

      if (now_j >= 365) {
        now_j = now_j % 365;
      }
      if (now_j < 0) {
        now_j = (now_j + 365) % 365;
      }

      float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

      float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
      float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

      int[] Normals_COL_N;
      Normals_COL_N = new int [9];
      Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

      for (int i = 0; i < 24; i += 1) {
        //for (int i = 10; i <= 14; i += 2) {
        //for (int i = 12; i <= 12; i += 2) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

        float Alpha = 90 - acos_ang(SunR[3]);
        float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

        now_i = i;
        now_j = int(j * STUDY_PerDays + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }


        { // Direct 
          int RES1 = 50; // 100; 
          int RES2 = RES1;
          float ZOOM = 7200 / float(RES1); // ??? might not be correct!!!!

          PGraphics Image_RGBA = ViewFromTheSky(RES1, RES2, ZOOM, 0, 0, 0, 90-Alpha, 0, Beta);

          STUDY_Diagrams.imageMode(CENTER); 
          STUDY_Diagrams.image(Image_RGBA, (j + STUDY_rect_offset_x + (90 - Alpha) * STUDY_rect_scale * (cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * STUDY_rect_scale * (sin_ang(Beta - 90))) * sx_Plot, RES1, RES2);

          if (Materials_DirectArea_Flags[now_i][now_j] == -1) {

            Materials_DirectArea_Flags[now_i][now_j] = 1; 

            for (int mt = 0; mt < Materials_Number; mt++) {                 
              Materials_DirectArea_Data[mt][now_i][now_j] = 0;
            }   

            if ((i > _sunrise) && (i < _sunset)) {

              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;

                color COL = Image_RGBA.get(Image_X, Image_Y);

                int COL_A = COL >> 24 & 0xFF;

                if (COL_A != 0) {
                  int COL_R = COL >> 16 & 0xFF; 
                  int COL_G = COL >> 8 & 0xFF; 
                  int COL_B = COL & 0xFF;

                  for (int mt = 0; mt < Materials_Number; mt++) {  

                    if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                      Materials_DirectArea_Data[mt][now_i][now_j] += 1;
                    }
                  }
                }
              }  

              for (int mt = 0; mt < Materials_Number; mt++) {                 
                Materials_DirectArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2) ; //???

                if (Materials_Selection == mt) println("Direct:", mt, now_i, now_j, Materials_DirectArea_Data[mt][now_i][now_j]);
              }

              STUDY_Diagrams.imageMode(CORNER);
            }
          }
        }

        /*

         { // Diffuse
         int RES1 = 25; // 100; 
         int RES2 = RES1;
         float ZOOM = 7200 / float(RES1); // ??? might not be correct!!!!
         
         if (Materials_DiffuseArea_Flags[now_i][now_j] == -1) {
         
         Materials_DiffuseArea_Flags[now_i][now_j] = 1; 
         
         for (int mt = 0; mt < Materials_Number; mt++) {                 
         Materials_DiffuseArea_Data[mt][now_i][now_j] = 0;
         }                 
         
         int num_diffuse_views = 0;
         
         for (int vNo = 1; vNo < skyVertices.length; vNo++) {
         
         float skyAngle_Alpha = asin_ang(skyVertices[vNo][2]);
         float skyAngle_Beta = atan2_ang(skyVertices[vNo][1], skyVertices[vNo][0]) + 90;
         
         if (skyAngle_Alpha >= 0) {
         
         num_diffuse_views += 1;
         
         PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-skyAngle_Alpha,0,skyAngle_Beta);
         
         STUDY_Diagrams.imageMode(CENTER); 
         STUDY_Diagrams.image(Image_RGBA, (j + STUDY_rect_offset_x + (90 - skyAngle_Alpha) * STUDY_rect_scale * (cos_ang(skyAngle_Beta - 90))) * sx_Plot, -((90 - skyAngle_Alpha) * STUDY_rect_scale * (sin_ang(skyAngle_Beta - 90))) * sx_Plot, RES1, RES2);
         
         for (int np = 0; np < (RES1 * RES2); np++) {
         int Image_X = np % RES1;
         int Image_Y = np / RES1;
         
         color COL = Image_RGBA.get(Image_X, Image_Y);
         
         int COL_A = COL >> 24 & 0xFF;
         
         if (COL_A != 0) {
         int COL_R = COL >> 16 & 0xFF; 
         int COL_G = COL >> 8 & 0xFF; 
         int COL_B = COL & 0xFF;
         
         for (int mt = 0; mt < Materials_Number; mt++) {  
         
         if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
         Materials_DiffuseArea_Data[mt][now_i][now_j] += 1;
         }
         }
         }
         }  
         
         STUDY_Diagrams.imageMode(CORNER);
         }
         }
         for (int mt = 0; mt < Materials_Number; mt++) {                 
         Materials_DiffuseArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2); //???
         Materials_DiffuseArea_Data[mt][now_i][now_j] *= 2.0 / float(num_diffuse_views); // note: multiply by 2 to have a area equal to roof!
         
         if (Materials_Selection == mt) println("Diffuse:", mt, now_i, now_j, Materials_DiffuseArea_Data[mt][now_i][now_j]); 
         }
         
         //---------------------------------------------
         // applying calculated diffuse model at this time for the rest of year.
         for (int mt = 0; mt < Materials_Number; mt++) {
         for (int loop_i = 0; loop_i < 24; loop_i += 1) {
         for (int loop_j = 0; loop_j < 365; loop_j += 1) {
         Materials_DiffuseArea_Data[mt][loop_i][loop_j] = Materials_DiffuseArea_Data[mt][now_i][now_j];
         Materials_DiffuseArea_Flags[loop_i][loop_j] = 1;
         }
         }  
         }
         //---------------------------------------------                          
         }
         }
         
         */
      }
    }

    if (STUDY_PrintTtitle != 0) {

      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(LEFT, TOP); 

      STUDY_Diagrams.text(("Solar perspectives"), 0, 1.4 * sx_Plot / STUDY_U_scale);
    }
  } 


  if ((STUDY_PlotImpacts == 8) || (STUDY_PlotImpacts == 9)) {

    //for (int p = 0; p < 3; p += 1) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    //for (int p = 0; p < 3; p += 2) { 
    //int l = 3 * int(STUDY_ImpactLayer / 3) + p;

    for (int p = 0; p < 1; p += 1) { 
      int l = STUDY_ImpactLayer;

      //for (int p = 0; p < 1; p += 1) { 
      //int l = 3 * int(STUDY_ImpactLayer / 3) + 1; //STUDY_ImpactLayer;    

      int target_window = 1;
      SOLARCHVISION_draw_SunPathCycles(x_Plot, y_Plot - (1 * p * sx_Plot / STUDY_U_scale), z_Plot, sx_Plot, sy_Plot, sz_Plot, l, target_window);

      SOLARCHVISION_draw_Grid_Spherical_POSITION(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);

      String scenario_text = "";
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
      STUDY_Diagrams.text(scenario_text, ((STUDY_j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, CENTER); 
      STUDY_Diagrams.stroke(0);
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(0); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / STUDY_U_scale));
      }            
      //?? French
    }    


    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

    float pal_length = 400;

    float pal_offsetY = 175;    
    if (STUDY_j_End == 2) {
      pal_offsetY = 325;
    }

    for (int q = 0; q < 11; q += 1) {
      float _u = 0;

      if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;

      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);
      STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
      STUDY_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);       

      STUDY_Diagrams.strokeWeight(0);
      STUDY_Diagrams.rect((700 + q * (pal_length / 11.0)) * STUDY_S_View, -pal_offsetY * STUDY_S_View, (pal_length / 11.0) * STUDY_S_View, 20 * STUDY_S_View);

      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        STUDY_Diagrams.stroke(127);
        STUDY_Diagrams.fill(127);
        STUDY_Diagrams.strokeWeight(0);
      } else {
        STUDY_Diagrams.stroke(255);
        STUDY_Diagrams.fill(255);
        STUDY_Diagrams.strokeWeight(2);
      }   

      STUDY_Diagrams.textSize(15.0 * STUDY_S_View);
      STUDY_Diagrams.textAlign(CENTER, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) STUDY_Diagrams.text(nf(0.1 * q / PAL_Multiplier, 1, 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY_S_View);
      if (Impact_TYPE == Impact_PASSIVE) STUDY_Diagrams.text(nf(int(roundTo(0.4 * (q - 5) / PAL_Multiplier, 1)), 1), (20 + 700 + q * (pal_length / 11.0)) * STUDY_S_View, (10 - pal_offsetY - 0.05 * 20) * STUDY_S_View);
    } 


    if (STUDY_PrintTtitle != 0) {

      STUDY_Diagrams.stroke(0); 
      STUDY_Diagrams.fill(0);
      STUDY_Diagrams.strokeWeight(STUDY_T_scale * 0);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(RIGHT, TOP); 
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CWEEDS_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CWEEDS_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) STUDY_Diagrams.text(("[" + String.valueOf(start_z + CLIMATE_CLMREC_start - 1) + "-" + String.valueOf(end_z + CLIMATE_CLMREC_start - 1) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);
      //if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) //STUDY_Diagrams.text(("[Members:" + String.valueOf(start_z) + "-" + String.valueOf(end_z) + "] "), 0, 1.4 * sx_Plot / STUDY_U_scale);

      STUDY_Diagrams.textSize(sx_Plot * 0.250 / STUDY_U_scale);
      STUDY_Diagrams.textAlign(CENTER, TOP); 
      if (Impact_TYPE == Impact_ACTIVE) {  
        STUDY_Diagrams.text(("Direct solar radiation (kWh/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY_S_View + (pal_length / 11.0) * STUDY_S_View, -pal_offsetY * STUDY_S_View + 20 * STUDY_S_View);
        //?? French
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        STUDY_Diagrams.text(("Direct solar effects (kWh°C/m²)"), (700 + 5 * (pal_length / 11.0)) * STUDY_S_View + (pal_length / 11.0) * STUDY_S_View, -pal_offsetY * STUDY_S_View + 20 * STUDY_S_View);
        //?? French
      }
    }
  } 





  if ((STUDY_PlotImpacts == 8) || (STUDY_PlotImpacts == 9)) {
  } else {
    SOLARCHVISION_draw_Grid_DAILY(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  }

  keep_STUDY_PerDays = STUDY_PerDays;
  STUDY_JoinDays = keep_STUDY_JoinDays;


  STUDY_Diagrams.popMatrix();
} 



void SOLARCHVISION_draw_SunPathCycles (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int l, int target_window) {

  // target_window: 1:STUDY, 2:WORLD, 3:WIN3D 4:OBJ-export

  int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
  int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
  int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2]; 



  int TES_hour = 1; //4; // 1 = every 1 hour, 4 = every 15 minutes

  if (STUDY_PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE;
  else Impact_TYPE = Impact_PASSIVE;

  float Pa1 = FLOAT_undefined;
  float Pb1 = FLOAT_undefined;
  float Pc1 = FLOAT_undefined;
  float Pd1 = FLOAT_undefined;

  float Pa2 = FLOAT_undefined;
  float Pb2 = FLOAT_undefined;
  float Pc2 = FLOAT_undefined;
  float Pd2 = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  int now_k = 0;
  int now_i1 = 0;
  int now_i2 = 0;
  int now_j = 0;

  int PAL_TYPE = 0; 
  int PAL_DIR = 1;

  float PAL_Multiplier = 1; 
  if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * STUDY_Pallet_ACTIVE_MLT;
  if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * STUDY_Pallet_PASSIVE_MLT;

  if ((target_window == 3) || (target_window == 4)) {

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath3D_Pallet_ACTIVE_CLR; 
      PAL_DIR = SunPath3D_Pallet_ACTIVE_DIR;
      PAL_Multiplier = SunPath3D_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath3D_Pallet_PASSIVE_CLR; 
      PAL_DIR = SunPath3D_Pallet_PASSIVE_DIR;
      PAL_Multiplier = SunPath3D_Pallet_PASSIVE_MLT;
    }
  } else {

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = STUDY_Pallet_ACTIVE_CLR; 
      PAL_DIR = STUDY_Pallet_ACTIVE_DIR;
      PAL_Multiplier = STUDY_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = STUDY_Pallet_PASSIVE_CLR; 
      PAL_DIR = STUDY_Pallet_PASSIVE_DIR;
      PAL_Multiplier = STUDY_Pallet_PASSIVE_MLT;
    }
  }  




  String the_filename = "";
  String TEXTURE_path = "";

  if (target_window == 4) {

    num_vertices_added = 0;

    if (objExport_MaterialLibrary != 0) {

      the_filename = "sunPattern_Pallet.bmp";

      TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

      println("Saving texture:", TEXTURE_path);

      int RES1 = objExport_PalletResolution; 
      int RES2 = objExport_PalletResolution / 16;      

      PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


      Pallet_Texture.loadPixels();

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;

        float _val = (Image_X / (0.5 * RES1)) - 1; 

        float _u = 0.5 + _val;

        if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

        float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  

        Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
      }

      Pallet_Texture.updatePixels();   

      Pallet_Texture.save(TEXTURE_path);      


      mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
      mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
    }
  }  



  num_vertices_added = 0;

  int end_turn = 1;
  if (target_window == 4) end_turn = 3;
  for (int _turn = 1; _turn <= end_turn; _turn += 1) {


    if (target_window == 4) {

      if (_turn == 3) {

        obj_lastGroupNumber += 1;
        objOutput.println("g sunPattern");

        if (objExport_MaterialLibrary != 0) {      
          objOutput.println("usemtl " +  the_filename.replace('.', '_'));
        }
      }
    }    


    for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

      float[][][] SunPathMesh = new float [24 * TES_hour][1 + int(STUDY_PerDays / STUDY_JoinDays)][3];        

      for (int more_J = 0; more_J < STUDY_PerDays; more_J += STUDY_JoinDays) {

        now_j = (more_J + j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        {
          int keep_filter_type = FILTER_Active;
          FILTER_Active = FILTER_Hourly;

          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, more_J + j, DATE_ANGLE);

          FILTER_Active = keep_filter_type;
        }

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / STUDY_JoinDays);
            int j_ADD = nk % STUDY_JoinDays; 

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF = 0;
            int _valuesNUM = 0; 

            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

              float HOUR_ANGLE = i; 
              float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

              float Alpha = 90 - acos_ang(SunR[3]);
              float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

              //-------------- to extend graph to the horizon ---------------
              if (Alpha < 0) {              

                if (SunR[1] > 0) { 
                  float[] SunR_rise = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, _sunrise);

                  Alpha = 0;
                  Beta = 180 - atan2_ang(SunR_rise[1], SunR_rise[2]);
                } else {
                  float[] SunR_set = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, _sunset);

                  Alpha = 0;
                  Beta = 180 - atan2_ang(SunR_set[1], SunR_set[2]);
                }
              }
              //-----------------------------------------------------------

              now_k = k;

              now_i1 = floor(i);
              now_i2 = (1 + now_i1) % 24;
              float i_ratio = i - now_i1; 

              now_j = int(more_J + j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }

              if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                Pa1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                Pb1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_difhorrad][now_k]; 
                Pc1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                Pd1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_difeffect][now_k]; 

                Pa2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_dirnorrad][now_k]; 
                Pb2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_difhorrad][now_k]; 
                Pc2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_direffect][now_k]; 
                Pd2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_difeffect][now_k];
              }
              if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                Pa1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                Pb1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_difhorrad][now_k]; 
                Pc1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                Pd1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_difeffect][now_k]; 

                Pa2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_dirnorrad][now_k]; 
                Pb2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_difhorrad][now_k]; 
                Pc2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_direffect][now_k]; 
                Pd2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_difeffect][now_k];
              }              
              if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                Pa1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                Pb1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_difhorrad][now_k]; 
                Pc1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                Pd1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_difeffect][now_k]; 

                Pa2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_dirnorrad][now_k]; 
                Pb2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_difhorrad][now_k]; 
                Pc2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_direffect][now_k]; 
                Pd2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_difeffect][now_k];
              }            
              if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                Pa1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                Pb1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_difhorrad][now_k]; 
                Pc1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                Pd1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_difeffect][now_k]; 

                Pa2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_dirnorrad][now_k]; 
                Pb2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_difhorrad][now_k]; 
                Pc2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_direffect][now_k]; 
                Pd2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_difeffect][now_k];
              }   
              if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                Pa1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                Pb1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_difhorrad][now_k]; 
                Pc1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                Pd1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_difeffect][now_k]; 

                Pa2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_dirnorrad][now_k]; 
                Pb2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_difhorrad][now_k]; 
                Pc2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_direffect][now_k]; 
                Pd2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_difeffect][now_k];
              }          

              if ((Pa1 > 0.9 * FLOAT_undefined) || (Pb1 > 0.9 * FLOAT_undefined) || (Pc1 > 0.9 * FLOAT_undefined) || (Pd1 > 0.9 * FLOAT_undefined)
                || (Pa2 > 0.9 * FLOAT_undefined) || (Pb2 > 0.9 * FLOAT_undefined) || (Pc2 > 0.9 * FLOAT_undefined) || (Pd2 > 0.9 * FLOAT_undefined)) {
                _values_R_dir = FLOAT_undefined;
                _values_R_dif = FLOAT_undefined;
                _values_E_dir = FLOAT_undefined;
                _values_E_dif = FLOAT_undefined;
              } else {

                int drw_count = 0;
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i1, now_j, now_k);
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i1, now_j, now_k);
                if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i1, now_j, now_k);
                if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i1, now_j, now_k);
                if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i1, now_j, now_k);

                if (drw_count == 1) {
                  _values_R_dir = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                  _values_R_dif = 0.001 * (Pb1 * (1 - i_ratio) + Pb2 * i_ratio);
                  _values_E_dir = 0.001 * (Pc1 * (1 - i_ratio) + Pc2 * i_ratio);
                  _values_E_dif = 0.001 * (Pd1 * (1 - i_ratio) + Pd2 * i_ratio);

                  if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                    _valuesSUM_RAD = 0;
                    _valuesSUM_EFF = 0;
                    _valuesNUM = 0;
                  } else {
                    _valuesSUM_RAD = (_values_R_dir); // direct beam radiation
                    _valuesSUM_EFF = (_values_E_dir); // direct beam effect
                    _valuesNUM = 1;
                  }
                }
              }

              float _valuesSUM = FLOAT_undefined;
              if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
              if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = _valuesSUM_EFF; 

              int row_J = more_J / STUDY_JoinDays;

              SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
              SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
              SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;
            }
          } else {
            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {

              float _valuesSUM = FLOAT_undefined; 

              float HOUR_ANGLE = i; 
              float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

              float Alpha = 90 - acos_ang(SunR[3]);
              float Beta = 180 - atan2_ang(SunR[1], SunR[2]);

              int row_J = more_J / STUDY_JoinDays;

              SunPathMesh[int(i * TES_hour)][row_J][0] = Alpha;
              SunPathMesh[int(i * TES_hour)][row_J][1] = Beta;
              SunPathMesh[int(i * TES_hour)][row_J][2] = _valuesSUM;
            }
          }
        }
      }



      for (int more_J = 0; more_J < STUDY_PerDays - STUDY_JoinDays; more_J += STUDY_JoinDays) { //count one less!

        now_j = (more_J + j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {  
          if (STUDY_isInHourlyRange(i) == 1) {
            if ((i > _sunrise - 1.0 / float(TES_hour)) && (i < _sunset + 1.0 / float(TES_hour))) {              

              if (target_window == 4) {
              } else if (target_window == 3) {
                WIN3D_Diagrams.beginShape();
                WIN3D_Diagrams.noStroke();
              } else if (target_window == 2) {
                WORLD_Diagrams.beginShape();
                WORLD_Diagrams.noStroke();
              } else if (target_window == 1) {
                STUDY_Diagrams.beginShape();
                STUDY_Diagrams.noStroke();
              }  

              for (int s = 0; s < 4; s += 1) {

                int a = int(i * TES_hour);
                int b = more_J / STUDY_JoinDays;

                if ((s == 1) || (s == 2)) {
                  a += 1;
                }

                if ((s == 2) || (s == 3)) {
                  b += 1;
                }

                if (a > (24 * TES_hour - 1)) a = a % (24 * TES_hour);

                float Alpha = SunPathMesh[a][b][0];
                float Beta = SunPathMesh[a][b][1];
                float _valuesSUM = SunPathMesh[a][b][2];

                if (Alpha >= 0) {

                  if (_valuesSUM < 0.9 * FLOAT_undefined) {

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * _valuesSUM);

                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;

                    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

                    float r = sx_Plot;

                    if (target_window == 4) {

                      float x = cos_ang(Alpha) * (cos_ang(Beta - 90)) * WIN3D_Scale3D * r + x_Plot;
                      float y = cos_ang(Alpha) * (sin_ang(Beta - 90)) * WIN3D_Scale3D * r + y_Plot;
                      float z = sin_ang(Alpha) * WIN3D_Scale3D * sz_Plot + z_Plot;

                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(x, y, z);
                      }

                      if (_turn == 2) { 
                        float u1 = 0.5 * (_u + 0.5);

                        if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {
                          if (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                        }

                        if (u1 > 0.999) u1 = 0.999;
                        if (u1 < 0.001) u1 = 0.001;

                        SOLARCHVISION_OBJprintVtexture(u1, 0, 0);
                      }

                      if (_turn == 3) {
                        num_vertices_added += 1;
                      }
                    } else if (target_window == 3) {
                      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], 127);

                      float x = cos_ang(Alpha) * (cos_ang(Beta - 90)) * WIN3D_Scale3D * r + x_Plot;
                      float y = cos_ang(Alpha) * (sin_ang(Beta - 90)) * WIN3D_Scale3D * r + y_Plot;
                      float z = sin_ang(Alpha) * WIN3D_Scale3D * sz_Plot + z_Plot;

                      WIN3D_Diagrams.vertex(x, -y, z);
                    } else if (target_window == 2) {
                      // ??????????????????????????
                    } else if (target_window == 1) {

                      STUDY_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

                      float x = (90 - Alpha) * (cos_ang(Beta - 90)) * STUDY_rect_scale * r + x_Plot * STUDY_rect_scale;
                      float y = (90 - Alpha) * (sin_ang(Beta - 90)) * STUDY_rect_scale * r + y_Plot * STUDY_rect_scale;

                      float ox = (j + STUDY_rect_offset_x) * sx_Plot;

                      STUDY_Diagrams.vertex(ox + x, -y);
                    }
                  }
                }
              }

              if (target_window == 4) {

                if (_turn == 3) {

                  String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                  String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                  String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                  String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                  String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                  String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                  String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                  String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                }
              } else if (target_window == 3) {
                WIN3D_Diagrams.endShape(CLOSE);
              } else if (target_window == 2) {
                WORLD_Diagrams.endShape(CLOSE);
              } else if (target_window == 1) {
                STUDY_Diagrams.endShape(CLOSE);
              }
            }
          }
        }
      }
    }


    if (target_window == 4) {
      obj_lastVertexNumber += num_vertices_added;
      obj_lastVtextureNumber += num_vertices_added;
    }
  }  




  if (target_window == 3) {
    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(127);
  } else if (target_window == 2) {
    WORLD_Diagrams.strokeWeight(1);
    WORLD_Diagrams.stroke(127);
  } else if (target_window == 1) {
    STUDY_Diagrams.strokeWeight(1);
    STUDY_Diagrams.stroke(127);
  }

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {    

    int max_j_to_draw_grid = STUDY_j_End;
    if ((target_window == 3) || (target_window == 4)) {
      max_j_to_draw_grid = 1; // draw it just once!
    }
    if (j < max_j_to_draw_grid) {


      float s_SunPath = sx_Plot;

      for (int myDATE = 90; myDATE <= 270; myDATE += 30) {

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, myDATE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, myDATE);        

        float myHOUR_step = 1.0 / float(TES_hour);

        for (float myHOUR = 0; myHOUR < 24; myHOUR += myHOUR_step) {



          float HourA = myHOUR;
          float HourB = myHOUR + myHOUR_step;

          float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, HourA);
          float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, HourB);

          if ((SunA[3] < 0) && (SunB[3] > 0)) {
            SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, _sunrise);
            SunA[3] = 0;
          }
          if ((SunA[3] > 0) && (SunB[3] < 0)) {
            SunB = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, _sunset);
            SunB[3] = 0;
          }



          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == 3) {

              float x1 = SunA[1] * WIN3D_Scale3D * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D_Scale3D * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D_Scale3D * s_SunPath + z_Plot;

              float x2 = SunB[1] * WIN3D_Scale3D * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D_Scale3D * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D_Scale3D * s_SunPath + z_Plot;

              WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
            } else if (target_window == 2) {
              // ??????????????????????????
            } else if (target_window == 1) {

              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          

              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          

              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * STUDY_rect_scale * s_SunPath + x_Plot * STUDY_rect_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * STUDY_rect_scale * s_SunPath + y_Plot * STUDY_rect_scale;

              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * STUDY_rect_scale * s_SunPath + x_Plot * STUDY_rect_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * STUDY_rect_scale * s_SunPath + y_Plot * STUDY_rect_scale;

              float ox = (j + STUDY_rect_offset_x) * sx_Plot;

              STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);
            }
          }
        }
      }

      for (float myHOUR = 0; myHOUR < 24; myHOUR += 1) {

        int myDATE_step = STUDY_JoinDays;

        int myDATE_start = 0;
        int myDATE_end = 360; 

        if (target_window != 3) {
          if (STUDY_j_End == 2) {
            if (j == 0) {
              myDATE_start = 90;
              myDATE_end = 270;
            }
            if (j == 1) {
              myDATE_start = 270;
              myDATE_end = 450;
            }
          }
        }

        for (int myDATE = myDATE_start; myDATE <= myDATE_end; myDATE += myDATE_step) {
          float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, myDATE, myHOUR);
          float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, (myDATE + myDATE_step), myHOUR);
          if ((SunA[3] >= 0) && (SunB[3] >= 0)) {

            if (target_window == 3) {        

              float x1 = SunA[1] * WIN3D_Scale3D * s_SunPath + x_Plot;
              float y1 = SunA[2] * WIN3D_Scale3D * s_SunPath + y_Plot;
              float z1 = SunA[3] * WIN3D_Scale3D * s_SunPath + z_Plot;

              float x2 = SunB[1] * WIN3D_Scale3D * s_SunPath + x_Plot;
              float y2 = SunB[2] * WIN3D_Scale3D * s_SunPath + y_Plot;
              float z2 = SunB[3] * WIN3D_Scale3D * s_SunPath + z_Plot;

              float ox = (j + STUDY_rect_offset_x) * sx_Plot;

              WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
            } else if (target_window == 2) {
              // ??????????????????????????
            } else if (target_window == 1) {

              float Alpha1 = asin_ang(SunA[3]);
              float Beta1 = atan2_ang(SunA[2], SunA[1]) + 90;          

              float Alpha2 = asin_ang(SunB[3]);
              float Beta2 = atan2_ang(SunB[2], SunB[1]) + 90;          

              float x1 = (90 - Alpha1) * (cos_ang(Beta1 - 90)) * STUDY_rect_scale * s_SunPath + x_Plot * STUDY_rect_scale;
              float y1 = (90 - Alpha1) * (sin_ang(Beta1 - 90)) * STUDY_rect_scale * s_SunPath + y_Plot * STUDY_rect_scale;

              float x2 = (90 - Alpha2) * (cos_ang(Beta2 - 90)) * STUDY_rect_scale * s_SunPath + x_Plot * STUDY_rect_scale;
              float y2 = (90 - Alpha2) * (sin_ang(Beta2 - 90)) * STUDY_rect_scale * s_SunPath + y_Plot * STUDY_rect_scale;

              float ox = (j + STUDY_rect_offset_x) * sx_Plot;

              STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);
            }
          }
        }
      }



      if (target_window == 3) {  
        WIN3D_Diagrams.stroke(0);
        WIN3D_Diagrams.fill(0);
        WIN3D_Diagrams.textAlign(CENTER, CENTER);
      } else if (target_window == 2) {  
        WORLD_Diagrams.stroke(0);
        WORLD_Diagrams.fill(0);
        WORLD_Diagrams.textAlign(CENTER, CENTER);
      } else if (target_window == 1) {  
        STUDY_Diagrams.stroke(0);
        STUDY_Diagrams.fill(0);
        STUDY_Diagrams.textAlign(CENTER, CENTER);
      }      

      for (int i = 0; i < 360; i += 1) {
        if (target_window == 3) {  

          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D_Scale3D + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D_Scale3D + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = s_SunPath * cos((i + 5) * PI / 180) * WIN3D_Scale3D + x_Plot;
          float y2 = s_SunPath * sin((i + 5) * PI / 180) * WIN3D_Scale3D + y_Plot;
          float z2 = 0 + z_Plot;

          WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
        } else if (target_window == 2) {
          // ??????????????????????????
        } else if (target_window == 1) {
          // no nead for a circle here in this case!
        }
      }

      for (int i = 0; i < 360; i += 5) {
        if (target_window == 3) {  

          float x1 = s_SunPath * cos(i * PI / 180) * WIN3D_Scale3D + x_Plot;
          float y1 = s_SunPath * sin(i * PI / 180) * WIN3D_Scale3D + y_Plot;
          float z1 = 0 + z_Plot;

          float x2 = 1.05 * s_SunPath * cos((i) * PI / 180) * WIN3D_Scale3D + x_Plot;
          float y2 = 1.05 * s_SunPath * sin((i) * PI / 180) * WIN3D_Scale3D + y_Plot;
          float z2 = 0 + z_Plot;

          WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
        } else if (target_window == 2) {
          // ??????????????????????????
        } else if (target_window == 1) {

          float x1 = 90 * s_SunPath * cos(i * PI / 180) * STUDY_rect_scale + x_Plot * STUDY_rect_scale;
          float y1 = 90 * s_SunPath * sin(i * PI / 180) * STUDY_rect_scale + y_Plot * STUDY_rect_scale;

          float x2 = 90 * 1.05 * s_SunPath * cos((i) * PI / 180) * STUDY_rect_scale + x_Plot * STUDY_rect_scale;
          float y2 = 90 * 1.05 * s_SunPath * sin((i) * PI / 180) * STUDY_rect_scale + y_Plot * STUDY_rect_scale;

          float ox = (j + STUDY_rect_offset_x) * sx_Plot;

          STUDY_Diagrams.line(ox + x1, -y1, ox + x2, -y2);
        }
      }


      for (int i = 0; i < 360; i += 15) {

        String txt = nf((90 - i + 360) % 360, 0);
        if (i == 0) {
          txt = "E";
        } else if (i == 90) {
          txt = "N";
        } else if (i == 180) {
          txt = "W";
        } else if (i == 270) {
          txt = "S";
        }

        float txtSize = 0.1;
        if (txt.length() > 1) txtSize *= 0.75;

        if (target_window == 3) {

          float x = 1.10 * s_SunPath * cos(i * PI / 180) * WIN3D_Scale3D + x_Plot;
          float y = 1.10 * s_SunPath * sin(i * PI / 180) * WIN3D_Scale3D + y_Plot;
          float z = 0 + z_Plot;

          WIN3D_Diagrams.textSize(txtSize * WIN3D_Scale3D * s_SunPath);
          WIN3D_Diagrams.text(txt, x, -y, z);
        } else if (target_window == 2) {
          // ??????????????????????????
        } else if (target_window == 1) {
          float x = 90 * 1.10 * s_SunPath * cos(i * PI / 180) * STUDY_rect_scale+ x_Plot * STUDY_rect_scale;
          float y = 90 * 1.10 * s_SunPath * sin(i * PI / 180) * STUDY_rect_scale + y_Plot * STUDY_rect_scale;

          float ox = (j + STUDY_rect_offset_x) * sx_Plot;

          STUDY_Diagrams.textSize(txtSize * 0.4 * s_SunPath);
          STUDY_Diagrams.text(txt, ox + x, -y);
        }
      }
    }
  }
}

void STUDY_keyPressed (KeyEvent e) {



  if (e.isAltDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {
      case '0' : 
        Camera_Variation = 0; 
        STUDY_Update = 1; 
        break;
      case '1' : 
        Camera_Variation = 1; 
        STUDY_Update = 1; 
        break;
      case '2' : 
        Camera_Variation = 2; 
        STUDY_Update = 1; 
        break;
      case '3' : 
        Camera_Variation = 3; 
        STUDY_Update = 1; 
        break;
      case '4' : 
        Camera_Variation = 4; 
        STUDY_Update = 1; 
        break;
      case '5' : 
        Camera_Variation = 5; 
        STUDY_Update = 1; 
        break;
      case '6' : 
        Camera_Variation = 6; 
        STUDY_Update = 1; 
        break;
        //case '7' : Camera_Variation = 7; STUDY_Update = 1; break;
        //case '8' : Camera_Variation = 8; STUDY_Update = 1; break;
        //case '9' : Camera_Variation = 9; STUDY_Update = 1; break;
      }
    }
  } else if (e.isControlDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

      case 35  :
        TIME_Date += 1;
        if (int(TIME_Date) == 365) TIME_Date -= 365;
        if (int(TIME_Date) == 286) TIME_Year += 1;
        SOLARCHVISION_update_date(); 
        SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        Update_DevelopData = 1;
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 36  :
        TIME_Date -= 1;
        if (int(TIME_Date) < 0) TIME_Date += 365;
        if (int(TIME_Date) == 285) TIME_Year -= 1;
        SOLARCHVISION_update_date(); 
        SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        Update_DevelopData = 1;
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 33:
        TIME_Date += 1; 
        if (TIME_Date >= 365) TIME_Date -= 365;
        if ((TIME_Date == 286) || (TIME_Date == 286.5)) TIME_Year += 1;
        SOLARCHVISION_update_date(); 
        TIME_BeginDay = int(TIME_BeginDay + 1) % 365; 
        SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        Update_DevelopData = 1;
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case 34 :
        TIME_Date -= 1; 
        if (TIME_Date < 0) TIME_Date += 365;
        if ((TIME_Date == 285) || (TIME_Date == 285.5)) TIME_Year -= 1;
        SOLARCHVISION_update_date(); 
        TIME_BeginDay = int(365 + TIME_BeginDay - 1) % 365;
        SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        Update_DevelopData = 1;
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case LEFT  :
        TIME_BeginDay = (365 + TIME_BeginDay - 1) % 365; 
        Update_DevelopData = 1; 
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case RIGHT :
        TIME_BeginDay = (TIME_BeginDay + 1) % 365; 
        Update_DevelopData = 1; 
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case UP   :
        STUDY_CurrentLayer = (STUDY_CurrentLayer + 1) % num_Layers; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case DOWN :
        STUDY_CurrentLayer = (STUDY_CurrentLayer + num_Layers - 1) % num_Layers; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      }
    } else {
      switch(key) {

      case 's' :
        STATION_Number = (STATION_Number + 1) % Defined_Stations.length; 
        //SOLARCHVISION_update_station(0); 
        WORLD_Update = 1;
        WIN3D_Update = 1; 
        STUDY_Update = 1;
        ROLLOUT_Update = 1;

        InitializationStep = 8; 
        frameCount = InitializationStep; 
        textAlign(CENTER, CENTER); 
        textSize(MessageSize);                    
        loop(); 
        break;
      case 'S' :
        STATION_Number = (STATION_Number - 1 + Defined_Stations.length) % Defined_Stations.length; 
        //SOLARCHVISION_update_station(0); 
        WORLD_Update = 1;
        WIN3D_Update = 1; 
        STUDY_Update = 1;
        ROLLOUT_Update = 1;

        InitializationStep = 8; 
        frameCount = InitializationStep; 
        textAlign(CENTER, CENTER); 
        textSize(MessageSize);                    
        loop(); 
        break;              

      case 'r' : 
        STUDY_record_AUTO = (STUDY_record_AUTO + 1) % 2; 
        STUDY_Update = 0; 
        ROLLOUT_Update = 1; 
        break;
      case 'R' : 
        STUDY_record_AUTO = (STUDY_record_AUTO + 1) % 2; 
        STUDY_Update = 0; 
        ROLLOUT_Update = 1; 
        break;


      case '^' : 
        STUDY_DisplayRaws = 1; 
        Export_STUDY_info_node = 1; 
        STUDY_record_JPG = 0; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '&' : 
        STUDY_DisplayNormals = 1; 
        Export_STUDY_info_norm = 1; 
        STUDY_record_JPG = 0; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '%' : 
        STUDY_DisplayProbs = 1; 
        Export_STUDY_info_prob = 1; 
        STUDY_record_JPG = 0; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      }
    }
  } else if (e.isShiftDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    }
  }


  if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {

    if (key == CODED) { 
      switch(keyCode) {

      case 112 : 
        IMPACTS_DataSource = databaseNumber_FORECAST_ENSEMBLE; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 113 : 
        IMPACTS_DataSource = databaseNumber_RECENT_OBSERVED; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 114 : 
        IMPACTS_DataSource = databaseNumber_CLIMATE_CWEEDS; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 115 : 
        IMPACTS_DataSource = databaseNumber_CLIMATE_TMYEPW; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;          

      case 116 : 
        if (((abs(STUDY_PlotImpacts) % 2 == 0) && (STUDY_PlotImpacts != 4)) || (STUDY_PlotImpacts == 5)) STUDY_PlotImpacts = 4;
        else STUDY_PlotImpacts = 5; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 117 : 
        if (((abs(STUDY_PlotImpacts) % 2 == 0) && (STUDY_PlotImpacts != 2)) || (STUDY_PlotImpacts == 3)) STUDY_PlotImpacts = 2;
        else STUDY_PlotImpacts = 3; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;                   
      case 118 : 
        if (((abs(STUDY_PlotImpacts) % 2 == 0) && (STUDY_PlotImpacts != 0)) || (STUDY_PlotImpacts == 1)) STUDY_PlotImpacts = 0;
        else STUDY_PlotImpacts = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;           
      case 119 : 
        if (((abs(STUDY_PlotImpacts) % 2 == 0) && (STUDY_PlotImpacts != -2)) || (STUDY_PlotImpacts == -1)) STUDY_PlotImpacts = -2;
        else STUDY_PlotImpacts = -1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      }
    }
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key != CODED) { 
      switch(key) {

      case '|' :
        if (TIME_Date == 1.0 * int(TIME_Date)) TIME_Date += 0.5;
        else TIME_Date -= 0.5;
        SOLARCHVISION_update_date(); 
        SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case ';': 
        STUDY_impact_summary = (STUDY_impact_summary + 1) % 2;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case TAB :
        SOALRCHVISION_refreshDateTabs();                   
        Update_DevelopData = 1;
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '}' :
        STUDY_j_End += 1; 
        if (STUDY_j_End > STUDY_j_Start + 61) STUDY_j_End -= 1;
        STUDY_U_scale = 18.0 / float(STUDY_j_End - STUDY_j_Start);
        /*
         if ((IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) || IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) || (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW)) { 
         STUDY_PerDays = int(365 / float(STUDY_j_End - STUDY_j_Start));
         } 
         if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
         STUDY_PerDays = 1;
         }
         */
        Update_DevelopData = 1;

        rebuild_SolarProjection_array = 1;
        rebuild_SolarImpactImage_array = 1;
        rebuild_WindRoseImage_array = 1;
        SOLARCHVISION_resize_allSections_Solar_Impact_Array();

        SOLARCHVISION_UI_BAR_d_Update = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '{' :
        STUDY_j_End -= 1; 
        if (STUDY_j_End <= STUDY_j_Start) STUDY_j_End += 1;
        STUDY_U_scale = 18.0 / float(STUDY_j_End - STUDY_j_Start);
        /*
         if ((IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) || IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) || (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW)) { 
         STUDY_PerDays = int(365 / float(STUDY_j_End - STUDY_j_Start));
         } 
         if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
         STUDY_PerDays = 1;
         }                  
         */
        Update_DevelopData = 1;

        rebuild_SolarProjection_array = 1;
        rebuild_SolarImpactImage_array = 1;
        rebuild_WindRoseImage_array = 1;   
        SOLARCHVISION_resize_allSections_Solar_Impact_Array();

        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

        /*      
         case '*' :STUDY_TrendJoinType *= -1;
         Update_DevelopData = 1;
         SOLARCHVISION_UI_BAR_d_Update = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break; 
         */


      case 'a'  :
        Develop_AngleInclination -= 5;
        if (Develop_AngleInclination < -90) Develop_AngleInclination = -90;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case 'A'  :
        Develop_AngleInclination += 5;
        if (Develop_AngleInclination > 90) Develop_AngleInclination = 90;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'z' :
        Develop_AngleOrientation = (Develop_AngleOrientation - 5 + 360) % 360;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case 'Z' :
        Develop_AngleOrientation = (Develop_AngleOrientation + 5) % 360;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case 'd' :
        Develop_DayHour = (Develop_DayHour + 1) % 4;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case 'D' :
        Develop_DayHour = (Develop_DayHour - 1 + 4) % 4;
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case '>' :
        if ((STUDY_PlotImpacts == -2) || (STUDY_PlotImpacts == -1)) {
          STUDY_O_scale *= ROLLOUT_Update = 1; 
          pow(2.0, (1.0 / 4.0));
        } else {
          STUDY_ImpactLayer = (STUDY_ImpactLayer + 1) % 9;
        }
        STUDY_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case '<' :
        if ((STUDY_PlotImpacts == -2) || (STUDY_PlotImpacts == -1)) {
          STUDY_O_scale *= ROLLOUT_Update = 1; 
          pow(0.5, (1.0 / 4.0));
        } else {
          STUDY_ImpactLayer = (STUDY_ImpactLayer + 9 - 1) % 9;
        }
        STUDY_Update = 1;
        ROLLOUT_Update = 1; 
        break;

      case 'h' :
        H_Layer_Option = (H_Layer_Option + 1) % 8; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'H' :
        H_Layer_Option = (H_Layer_Option + 8 - 1) % 8; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'f' :
        F_Layer_Option = (F_Layer_Option + 1) % 6; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'F' :
        F_Layer_Option = (F_Layer_Option + 6 - 1) % 6; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

        //case 'g' :FILTER_Active = (FILTER_Active + 1) % 2; Update_DevelopData = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;
        //case 'G' :FILTER_Active = (FILTER_Active + 2 - 1) % 2; Update_DevelopData = 1; STUDY_Update = 1; ROLLOUT_Update = 1; break;

      case '=' :
        STUDY_V_scale[STUDY_CurrentLayer] *= pow(2.0, (1.0 / 2.0)); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '_' :
        STUDY_V_scale[STUDY_CurrentLayer] *= pow(0.5, (1.0 / 2.0)); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'c' :
        COLOR_STYLE_Active = (COLOR_STYLE_Active + 1) % COLOR_STYLE_Number; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'C' :
        COLOR_STYLE_Active = (COLOR_STYLE_Active - 1 + COLOR_STYLE_Number) % COLOR_STYLE_Number; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'V' :
        STUDY_DisplayRaws = int((STUDY_DisplayRaws + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'v' :
        STUDY_DisplayRaws = int((STUDY_DisplayRaws + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '`' :
        STUDY_JoinDays += 2;
        if (STUDY_JoinDays > 365) STUDY_JoinDays = 365;
        Update_DevelopData = 1; 
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '~' :
        STUDY_JoinDays -= 2;
        if (STUDY_JoinDays < 1) STUDY_JoinDays = 1;
        Update_DevelopData = 1; 
        SOLARCHVISION_UI_BAR_d_Update = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'l' :
        Materials_Selection += 1;
        Materials_Selection %= Materials_Number; 
        Update_DevelopData = 1;
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'L' :
        Materials_Selection += Materials_Number - 1;
        Materials_Selection %= Materials_Number;
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;  

      case 'm' :
        STUDY_DisplaySorted = int((STUDY_DisplaySorted + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'M' :
        STUDY_DisplaySorted = int((STUDY_DisplaySorted + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'n' :
        STUDY_DisplayNormals = int((STUDY_DisplayNormals + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'N' :
        STUDY_DisplayNormals = int((STUDY_DisplayNormals + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'b' :
        STUDY_DisplayProbs = int((STUDY_DisplayProbs + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'B' :
        STUDY_DisplayProbs = int((STUDY_DisplayProbs + 1) % 2); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'j' :
        if (STUDY_LevelPix < 32) STUDY_LevelPix *= pow(2.0, (1.0 / 1.0)); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'J' :
        if (STUDY_LevelPix > 2) STUDY_LevelPix *= pow(0.5, (1.0 / 1.0)); 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'i' :
        if (STUDY_SumInterval > 24) STUDY_SumInterval -= 24;
        if (STUDY_SumInterval > 6) STUDY_SumInterval -= 6; 
        else if (STUDY_SumInterval > 1) STUDY_SumInterval -= 1;
        if (STUDY_SumInterval == 5) STUDY_SumInterval = 4;
        println("STUDY_SumInterval =", STUDY_SumInterval);
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'I' :
        if (STUDY_SumInterval < 6) STUDY_SumInterval += 1;
        else if (STUDY_SumInterval < 24) STUDY_SumInterval += 6;
        else STUDY_SumInterval += 24;
        if (STUDY_SumInterval == 5) STUDY_SumInterval = 6;
        println("STUDY_SumInterval =", STUDY_SumInterval);
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '!' :
        STUDY_skyScenario_Active = 1; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '@' :
        STUDY_skyScenario_Active = 2; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '#' :
        STUDY_skyScenario_Active = 3; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '$' :
        STUDY_skyScenario_Active = 4; 
        Update_DevelopData = 1; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 's' : 
        STUDY_record_JPG = 1; 
        STUDY_record_PDF = 0; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'S' : 
        STUDY_record_PDF = 1; 
        STUDY_record_JPG = 0; 
        STUDY_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      }
    }
  }
}


float[] SOLARCHVISION_DRYW (float _variable) {
  _variable = 1 - _variable;
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }

  return COL;
}

float[] SOLARCHVISION_WYRD (float _variable) {
  _variable *= -3;

  float v;
  float[] COL = {
    255, 0, 0, 0
  };
  if (_variable < -3) {
    COL[1] = 0;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -2) {
    v = (-(_variable + 2) * 255);
    COL[1] = 255 - v;
    COL[2] = 0;
    COL[3] = 0;
  } else if (_variable < -1) {
    v = (-(_variable + 1) * 255);
    COL[1] = 255;
    COL[2] = 255 - v;
    COL[3] = 0;
  } else if (_variable < 0) {
    v = (-_variable * 255);
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255 - v;
  } else {
    COL[1] = 255;
    COL[2] = 255;
    COL[3] = 255;
  }

  return COL;
}




void SOLARCHVISION_draw_SunPattern3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 

  if (FrameVariation == 1) Display_SUN3D_Pattern = 0; // <<<<<<<<<<< to avoid memory problem!

  if (Display_SUN3D_Pattern != 0) {

    float keep_STUDY_PerDays = STUDY_PerDays;
    int keep_STUDY_JoinDays = STUDY_JoinDays;
    if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
      STUDY_PerDays = 1;
      STUDY_JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;

    SOLARCHVISION_draw_SunPathCycles(x_SunPath, x_SunPath, x_SunPath, s_SunPath, s_SunPath, s_SunPath, STUDY_ImpactLayer, 3);

    STUDY_PerDays = keep_STUDY_PerDays;
    STUDY_JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }
}

void SOLARCHVISION_draw_SunPath3D (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath, float LocationLatitude) { 

  if (Display_SUN3D_Path != 0) {

    float keep_STUDY_PerDays = STUDY_PerDays;
    int keep_STUDY_JoinDays = STUDY_JoinDays;
    if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
      STUDY_PerDays = 1;
      STUDY_JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;




    int TES_hour = 4; // 1 = every 1 hour, 4 = every 15 minutes

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;

    if (Impact_TYPE == Impact_ACTIVE) {  
      PAL_TYPE = SunPath3D_Pallet_ACTIVE_CLR; 
      PAL_DIR = SunPath3D_Pallet_ACTIVE_DIR;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = SunPath3D_Pallet_PASSIVE_CLR; 
      PAL_DIR = SunPath3D_Pallet_PASSIVE_DIR;
    }             

    float PAL_Multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * SunPath3D_Pallet_ACTIVE_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * SunPath3D_Pallet_PASSIVE_MLT;



    WIN3D_Diagrams.pushMatrix();
    WIN3D_Diagrams.translate(x_SunPath, y_SunPath, z_SunPath);

    WIN3D_Diagrams.strokeWeight(0); 
    WIN3D_Diagrams.stroke(0, 0, 0);
    WIN3D_Diagrams.fill(0, 0, 0);

    WIN3D_Diagrams.line(-1 * s_SunPath, 0, 0, 1 * s_SunPath, 0, 0); 
    WIN3D_Diagrams.line(0, -1 * s_SunPath, 0, 0, 1 * s_SunPath, 0);

    WIN3D_Diagrams.stroke(255, 255, 0);



    int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
    int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
    int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2]; 

    for (int p = 0; p < 1; p += 1) { 

      int l = STUDY_ImpactLayer;

      int DATE_step = 1;

      int J_START = STUDY_j_Start;
      int J_END = STUDY_j_End;

      if (IMPACTS_DisplayDay > 0) {
        J_START = IMPACTS_DisplayDay - 1;
        J_END = IMPACTS_DisplayDay;
      }

      for (int j = J_START; j < J_END; j += DATE_step) {

        int now_k = 0;
        int now_i1 = 0;
        int now_i2 = 0;
        int now_j = 0;

        now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        //println(j, now_j, DATE_ANGLE);

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / STUDY_JoinDays);
            int j_ADD = nk % STUDY_JoinDays; 

            for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
              if (STUDY_isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                now_k = k;

                now_i1 = floor(i);
                now_i2 = (1 + now_i1) % 24;
                float i_ratio = i - now_i1;

                now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }

                float Pa1 = FLOAT_undefined;
                float Pa2 = FLOAT_undefined;

                if (Impact_TYPE == Impact_ACTIVE) {
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    Pa1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                    Pa2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_dirnorrad][now_k];
                  }
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    Pa1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                    Pa2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_dirnorrad][now_k];
                  }                  
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Pa1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                    Pa2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_dirnorrad][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    Pa1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                    Pa2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_dirnorrad][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                    Pa1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_dirnorrad][now_k]; 
                    Pa2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_dirnorrad][now_k];
                  }
                } 

                if (Impact_TYPE == Impact_PASSIVE) {
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    Pa1 = CLIMATE_CWEEDS_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                    Pa2 = CLIMATE_CWEEDS_Data[now_i2][now_j][LAYER_direffect][now_k];
                  }
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    Pa1 = CLIMATE_CLMREC_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                    Pa2 = CLIMATE_CLMREC_Data[now_i2][now_j][LAYER_direffect][now_k];
                  }                  
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Pa1 = FORECAST_ENSEMBLE_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                    Pa2 = FORECAST_ENSEMBLE_Data[now_i2][now_j][LAYER_direffect][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    Pa1 = RECENT_OBSERVED_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                    Pa2 = RECENT_OBSERVED_Data[now_i2][now_j][LAYER_direffect][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                    Pa1 = CLIMATE_TMYEPW_Data[now_i1][now_j][LAYER_direffect][now_k]; 
                    Pa2 = CLIMATE_TMYEPW_Data[now_i2][now_j][LAYER_direffect][now_k];
                  }
                }                  

                if ((Pa1 > 0.9 * FLOAT_undefined) && (Pa2 > 0.9 * FLOAT_undefined)) {
                } else {

                  float sun_V = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);

                  float _u = 0;

                  if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_Multiplier * sun_V);
                  if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_Multiplier * sun_V);

                  if (PAL_DIR == -1) _u = 1 - _u;
                  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_DIR == 2) _u =  0.5 * _u;

                  float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);    

                  WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
                  WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

                  WIN3D_Diagrams.strokeWeight(4);

                  float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE - 0.5 * (1.0 / float(TES_hour)));
                  float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE + 0.5 * (1.0 / float(TES_hour)));

                  float x1 = SunA[1] * WIN3D_Scale3D * s_SunPath;
                  float y1 = SunA[2] * WIN3D_Scale3D * s_SunPath;
                  float z1 = SunA[3] * WIN3D_Scale3D * s_SunPath;

                  float x2 = SunB[1] * WIN3D_Scale3D * s_SunPath;
                  float y2 = SunB[2] * WIN3D_Scale3D * s_SunPath;
                  float z2 = SunB[3] * WIN3D_Scale3D * s_SunPath;

                  WIN3D_Diagrams.line(x1, -y1, z1, x2, -y2, z2);
                }
              }
            }
          }
        }
      }
    }  

    WIN3D_Diagrams.popMatrix();



    STUDY_PerDays = keep_STUDY_PerDays;
    STUDY_JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }
} 


int Display_SolarRotation = 0;

void SOLARCHVISION_draw_SolarRotation (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath, float LocationLatitude) { 

  if (Display_SolarRotation != 0) {

    WIN3D_Diagrams.pushMatrix();
    WIN3D_Diagrams.translate(x_SunPath, y_SunPath, z_SunPath);

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0);

    for (int j = 90; j <= 270; j += 30) {
      float HOUR_step = 1;
      for (float HOUR = 0; HOUR <= 24; HOUR += HOUR_step) {
        float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, j, (HOUR + HOUR_step));
        WIN3D_Diagrams.line(s_SunPath * SunA[1] * WIN3D_Scale3D, -s_SunPath * SunA[2] * WIN3D_Scale3D, s_SunPath * SunA[3] * WIN3D_Scale3D, s_SunPath * SunB[1] * WIN3D_Scale3D, -s_SunPath * SunB[2] * WIN3D_Scale3D, s_SunPath * SunB[3] * WIN3D_Scale3D);
      }
    }

    for (int HOUR = 0; HOUR <= 24; HOUR += 1) {
      float DATE_step = 1;
      for (int j = 0; j <= 360; j += DATE_step) {
        float[] SunA = SOLARCHVISION_SunPosition(LocationLatitude, j, HOUR);
        float[] SunB = SOLARCHVISION_SunPosition(LocationLatitude, (j + DATE_step), HOUR);
        WIN3D_Diagrams.line(s_SunPath * SunA[1] * WIN3D_Scale3D, -s_SunPath * SunA[2] * WIN3D_Scale3D, s_SunPath * SunA[3] * WIN3D_Scale3D, s_SunPath * SunB[1] * WIN3D_Scale3D, -s_SunPath * SunB[2] * WIN3D_Scale3D, s_SunPath * SunB[3] * WIN3D_Scale3D);
      }
    }

    WIN3D_Diagrams.popMatrix();
  }
} 



void WIN3D_keyPressed (KeyEvent e) {

  if (e.isAltDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {

      case RIGHT :
        SolidImpact_Rotation[SolidImpact_sectionType] = (SolidImpact_Rotation[SolidImpact_sectionType] + 15) % 360; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;
      case LEFT :
        SolidImpact_Rotation[SolidImpact_sectionType] = (SolidImpact_Rotation[SolidImpact_sectionType] + 360 - 15) % 360; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;           

      case UP   :
        SolidImpact_Elevation[SolidImpact_sectionType] += SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;        
      case DOWN :
        SolidImpact_Elevation[SolidImpact_sectionType] -= SolidImpact_positionStep; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1;  
        break; 

      case 33 :
        SolidImpact_Elevation[SolidImpact_sectionType] += 4 * SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;        
      case 34 :
        SolidImpact_Elevation[SolidImpact_sectionType] -= 4 * SolidImpact_positionStep; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break; 

      case 35 :
        SolidImpact_scale_U[SolidImpact_sectionType] *= pow(2.0, 0.5); 
        SolidImpact_scale_V[SolidImpact_sectionType] *= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case 36 :
        SolidImpact_scale_U[SolidImpact_sectionType] /= pow(2.0, 0.5); 
        SolidImpact_scale_V[SolidImpact_sectionType] /= pow(2.0, 0.5);                   
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      }
    } else {
      switch(key) {

      case 'U' :
        SolidImpact_offset_U[SolidImpact_sectionType] += SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case 'u' :
        SolidImpact_offset_U[SolidImpact_sectionType] -= SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;        
      case 'V' :
        SolidImpact_offset_V[SolidImpact_sectionType] += SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case 'v' :
        SolidImpact_offset_V[SolidImpact_sectionType] -= SolidImpact_positionStep;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;  

      case ']' :
        SolidImpact_sectionType = (SolidImpact_sectionType + 1) % 4;
        SolarImpact_sectionType = SolidImpact_sectionType; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case '[' :
        SolidImpact_sectionType = (SolidImpact_sectionType + 4 - 1) % 4;
        SolarImpact_sectionType = SolidImpact_sectionType;
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;        

      case '0' :
        SolidImpact_Elevation[SolidImpact_sectionType] = 0; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;

      case '.' :
        SolidImpact_Rotation[SolidImpact_sectionType] = 0; 
        SOLARCHVISION_calculate_SolidImpact_selectedSections();
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;                   
        break;                  

      case '/' :
        SolidImpact_Power *= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;
      case '*' :
        SolidImpact_Power /= pow(2.0, 0.5);  
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;

      case '+' :
        SolidImpact_Grade *= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;
      case '-' :
        SolidImpact_Grade /= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;

      case '>' :
        SolidImpact_Grade /= pow(2.0, 0.25); 
        SolidImpact_Power /= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;
      case '<' :
        SolidImpact_Grade *= pow(2.0, 0.25); 
        SolidImpact_Power *= pow(2.0, 0.5); 
        SOLARCHVISION_calculate_SolidImpact_selectedSections(); 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;



      case ENTER :
        SOLARCHVISION_calculate_WindFlow(); 
        WIN3D_Update = 1; 
        break;
      }
    }
  } else if (e.isControlDown() == true) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {

      case '*': 
        SOLARCHVISION_select_All();
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;
        break;             

      case '.' :
        WIN3D_X_Coordinate = 0;
        WIN3D_Y_Coordinate = 0;
        //WIN3D_Zoom = 60;
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '-' :
        WIN3D_RX_Coordinate = 90; 
        SOLARCHVISION_reverseTransform_3DViewport(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;  


      case '+' :
        WIN3D_RX_Coordinate = 0;
        WIN3D_RY_Coordinate = 0;
        WIN3D_RZ_Coordinate = 0; 

        WIN3D_X_Coordinate = 0;
        WIN3D_Y_Coordinate = 0;
        WIN3D_Z_Coordinate = 0;   

        WIN3D_S_Coordinate = 1;

        WIN3D_Zoom = 60;        

        WIN3D_CurrentCamera = 0;
        SOLARCHVISION_modify_Viewport_Title();

        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '0' :
        Display_LAND_MESH = (Display_LAND_MESH + 1) % 2;
        if (Display_LAND_MESH != 0) {
          Current_ObjectCategory = ObjectCategory_LandPoint;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        }
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '1' :
        Display_Fractals = (Display_Fractals + 1) % 2;
        if (Display_Fractals != 0) {
          Current_ObjectCategory = ObjectCategory_Fractals;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        }
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '2' :
        Display_Model2Ds = (Display_Model2Ds + 1) % 2;
        if (Display_Model2Ds != 0) {
          Current_ObjectCategory = ObjectCategory_Object2Ds;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        }
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '3' :
        Display_Model3Ds = (Display_Model3Ds + 1) % 2;
        if (Display_Model3Ds != 0) {
          Current_ObjectCategory = ObjectCategory_Group3Ds;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '4' :
        Display_Model3Ds = (Display_Model3Ds + 1) % 2;
        if (Display_Model3Ds != 0) {
          Current_ObjectCategory = ObjectCategory_Faces;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;                  

      case '5' :
        Display_Model3Ds = (Display_Model3Ds + 1) % 2;
        if (Display_Model3Ds != 0) {
          Current_ObjectCategory = ObjectCategory_Vertices;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;  

      case '6' :
        Display_Model3Ds = (Display_Model3Ds + 1) % 2;
        if (Display_Model3Ds != 0) {
          Current_ObjectCategory = ObjectCategory_SoftVerts;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;                      

      case '7' :
        Display_Solids = (Display_Solids + 1) % 2;
        if (Display_Solids != 0) {
          Current_ObjectCategory = ObjectCategory_Solids;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case '8' :
        Display_Sections = (Display_Sections + 1) % 2;
        if (Display_Sections != 0) {
          Current_ObjectCategory = ObjectCategory_Sections;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case '9' :
        Display_Cameras = (Display_Cameras + 1) % 2;
        if (Display_Cameras != 0) {
          Current_ObjectCategory = ObjectCategory_Cameras;
          SOLARCHVISION_UI_BAR_b_Update = 1;
        } 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 





      case ' ' :
        SOLARCHVISION_render_Shadows_selectedSections(); 
        WIN3D_Update = 1;
        break;

      case ENTER :
        SOLARCHVISION_calculate_SolarImpact_selectedSections();
        WIN3D_Update = 1;
        break;
      }
    }
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key == CODED) { 
      switch(keyCode) {

      case DOWN :
        SOLARCHVISION_rotateZ_3DViewport_around_Selection(WIN3D_RS_Coordinate);
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case LEFT :
        SOLARCHVISION_rotateXY_3DViewport_around_Selection(-WIN3D_RS_Coordinate);
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case RIGHT :
        SOLARCHVISION_rotateXY_3DViewport_around_Selection(WIN3D_RS_Coordinate);
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case UP :
        SOLARCHVISION_rotateZ_3DViewport_around_Selection(-WIN3D_RS_Coordinate);
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;     

      case 33: 
        WIN3D_CurrentCamera += 1;
        if (WIN3D_CurrentCamera > allCameras_num) WIN3D_CurrentCamera = 0;
        SOLARCHVISION_apply_currentCamera();

        SOLARCHVISION_modify_Viewport_Title();

        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 34: 
        WIN3D_CurrentCamera -= 1;
        if (WIN3D_CurrentCamera < 0) WIN3D_CurrentCamera = allCameras_num;
        SOLARCHVISION_apply_currentCamera();

        SOLARCHVISION_modify_Viewport_Title();

        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 35: 
        if (Current_ObjectCategory == ObjectCategory_LandPoint) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedLandPoint_numbers.length - 1);
          if (nextIndex != -1) selectedLandPoint_numbers[selectedLandPoint_numbers.length - 1] = nextIndex;
        }   

        if (Current_ObjectCategory == ObjectCategory_Fractals) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedFractal_numbers.length - 1);
          if (nextIndex != -1) selectedFractal_numbers[selectedFractal_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedObject2D_numbers.length - 1);
          if (nextIndex != -1) selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = nextIndex;
        }        

        if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedGroup3D_numbers.length - 1);
          if (nextIndex != -1) selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Faces) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedFace_numbers.length - 1);
          if (nextIndex != -1) selectedFace_numbers[selectedFace_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Vertices) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedVertex_numbers.length - 1);
          if (nextIndex != -1) selectedVertex_numbers[selectedVertex_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
        }

        if (Current_ObjectCategory == ObjectCategory_Solids) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedSolid_numbers.length - 1);
          if (nextIndex != -1) selectedSolid_numbers[selectedSolid_numbers.length - 1] = nextIndex;
        }                   

        if (Current_ObjectCategory == ObjectCategory_Sections) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedSection_numbers.length - 1);
          if (nextIndex != -1) selectedSection_numbers[selectedSection_numbers.length - 1] = nextIndex;
        }     

        if (Current_ObjectCategory == ObjectCategory_Cameras) {
          int nextIndex = SOLARCHVISION_nextUnselected(-1, selectedCamera_numbers.length - 1);
          if (nextIndex != -1) selectedCamera_numbers[selectedCamera_numbers.length - 1] = nextIndex;
        }         

        println("SOLARCHVISION_calculate_selection_BoundingBox 27");
        SOLARCHVISION_calculate_selection_BoundingBox();

        SOLARCHVISION_reset_selectedRefValues();  

        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;  

      case 36: 
        if (Current_ObjectCategory == ObjectCategory_LandPoint) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedLandPoint_numbers.length - 1);
          if (nextIndex != -1) selectedLandPoint_numbers[selectedLandPoint_numbers.length - 1] = nextIndex;
        }   
        if (Current_ObjectCategory == ObjectCategory_Fractals) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedFractal_numbers.length - 1);
          if (nextIndex != -1) selectedFractal_numbers[selectedFractal_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedObject2D_numbers.length - 1);
          if (nextIndex != -1) selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = nextIndex;
        }        

        if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedGroup3D_numbers.length - 1);
          if (nextIndex != -1) selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Faces) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedFace_numbers.length - 1);
          if (nextIndex != -1) selectedFace_numbers[selectedFace_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_Vertices) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedVertex_numbers.length - 1);
          if (nextIndex != -1) selectedVertex_numbers[selectedVertex_numbers.length - 1] = nextIndex;
        }

        if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
        }

        if (Current_ObjectCategory == ObjectCategory_Solids) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedSolid_numbers.length - 1);
          if (nextIndex != -1) selectedSolid_numbers[selectedSolid_numbers.length - 1] = nextIndex;
        }                   

        if (Current_ObjectCategory == ObjectCategory_Sections) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedSection_numbers.length - 1);
          if (nextIndex != -1) selectedSection_numbers[selectedSection_numbers.length - 1] = nextIndex;
        }     

        if (Current_ObjectCategory == ObjectCategory_Cameras) {
          int nextIndex = SOLARCHVISION_nextUnselected(1, selectedCamera_numbers.length - 1);
          if (nextIndex != -1) selectedCamera_numbers[selectedCamera_numbers.length - 1] = nextIndex;
        }         


        println("SOLARCHVISION_calculate_selection_BoundingBox 28");
        SOLARCHVISION_calculate_selection_BoundingBox();

        SOLARCHVISION_reset_selectedRefValues();  

        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;          



      case 155: // INSERT 
        SOLARCHVISION_deselect_All();

        WIN3D_Update = 1;
        ROLLOUT_Update = 1;
        break;
      }
    } else {
      switch(key) {

      case DELETE: 
        SOLARCHVISION_delete_Selection();

        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 

        break;        

      case ',' :
        if (WIN3D_ViewType == 1) {
          WIN3D_Z_Coordinate += WIN3D_S_Coordinate * OBJECTS_scale; 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        } else {
          WIN3D_Zoom /= pow(2.0, 0.25); 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        }
        break;

      case '.' :
        if (WIN3D_ViewType == 1) {
          WIN3D_Z_Coordinate -= WIN3D_S_Coordinate * OBJECTS_scale; 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        } else {
          WIN3D_Zoom *= pow(2.0, 0.25); 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        }
        break;

      case '0' :
        if (WIN3D_ViewType == 1) {
          WIN3D_Z_Coordinate += WIN3D_S_Coordinate * OBJECTS_scale; 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        } else {
          WIN3D_Zoom /= pow(2.0, 0.25); 
          WIN3D_Update = 1; 
          ROLLOUT_Update = 1;
        }
        break;

      case '5' :
        SOLARCHVISION_look_3DViewport_towards_Selection(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '4' :
        WIN3D_RZ_Coordinate += WIN3D_RS_Coordinate; 
        SOLARCHVISION_reverseTransform_3DViewport(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '6' :
        WIN3D_RZ_Coordinate -= WIN3D_RS_Coordinate; 
        SOLARCHVISION_reverseTransform_3DViewport();
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '2' :
        WIN3D_RX_Coordinate -= WIN3D_RS_Coordinate; 
        SOLARCHVISION_reverseTransform_3DViewport(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '8' :
        WIN3D_RX_Coordinate += WIN3D_RS_Coordinate; 
        SOLARCHVISION_reverseTransform_3DViewport(); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case '1' :
        WIN3D_X_Coordinate += WIN3D_S_Coordinate * OBJECTS_scale; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '3' :
        WIN3D_X_Coordinate -= WIN3D_S_Coordinate * OBJECTS_scale; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case '9' :
        WIN3D_Y_Coordinate += WIN3D_S_Coordinate * OBJECTS_scale; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '7' :
        WIN3D_Y_Coordinate -= WIN3D_S_Coordinate * OBJECTS_scale; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;                  


      case '*' : 
        SOLARCHVISION_move_3DViewport_towards_Selection(2.0);
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;        
      case '/' :
        SOLARCHVISION_move_3DViewport_towards_Selection(0.5); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;


      case '+' :
        WIN3D_Zoom = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * WIN3D_Zoom)); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case '-' :
        WIN3D_Zoom = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * WIN3D_Zoom)); 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case 'O' :
        WIN3D_ViewType = 0; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        ROLLOUT_Update = 1; 
        break;
      case 'o' :
        WIN3D_ViewType = 0; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case 'P' ://WIN3D_Zoom = 60;
        WIN3D_ViewType = 1; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case 'p' ://WIN3D_Zoom = 60;
        WIN3D_ViewType = 1; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 

      case 'K' :
        WIN3D_FacesShade = (WIN3D_FacesShade + 5 - 1) % 5; 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break;
      case 'k' :
        WIN3D_FacesShade = (WIN3D_FacesShade + 1) % 5; 
        WIN3D_Update = 1;
        ROLLOUT_Update = 1; 
        break; 

      case 't' :
        MODEL3D_Tessellation += 1; 
        WIN3D_VerticesSolarValue_Update = 1; 
        WIN3D_Update = 1; 
        break; 
      case 'T' :
        MODEL3D_Tessellation -= 1;
        if (MODEL3D_Tessellation < 0) MODEL3D_Tessellation = 0;
        WIN3D_VerticesSolarValue_Update = 1; 
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break;

      case ']' :
        IMPACTS_DisplayDay += 1;
        if (IMPACTS_DisplayDay > STUDY_j_End) IMPACTS_DisplayDay = 0;
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 
      case '[' :
        IMPACTS_DisplayDay -= 1;
        if (IMPACTS_DisplayDay < 0) IMPACTS_DisplayDay = STUDY_j_End;
        WIN3D_Update = 1; 
        ROLLOUT_Update = 1; 
        break; 


      case '?': 
        SOLARCHVISION_PreBakeViewport();
        break; 

      case ENTER: 
        if (WIN3D_FacesShade == Shade_Global_Solar) rebuild_SolarProjection_array = 1;   
        if (WIN3D_FacesShade == Shade_Vertex_Solar) WIN3D_VerticesSolarValue_Update = 1;
        WIN3D_Update = 1;
        ROLLOUT_Update = 1;  
        break;                  

      case ' ': 
        SOLARCHVISION_RecordFrame();
        ROLLOUT_Update = 1; 
        break;       
       
      }

    }
  }
}





int FrameVariation = 0;

void SOLARCHVISION_update_frame_layout () {

  if (FrameVariation == 0) {

    STUDY_Include = 1;
    WIN3D_Include = 1;
    WORLD_Include = 1;

    WIN3D_CX_View = 0;
    WIN3D_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WIN3D_X_View = int(1.25 * SOLARCHVISION_H_Pixel);
    WIN3D_Y_View = SOLARCHVISION_H_Pixel;
    WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);
    WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);

    WORLD_CX_View = int(1.25 * SOLARCHVISION_H_Pixel);
    WORLD_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WORLD_X_View = int(1.75 * SOLARCHVISION_H_Pixel);
    WORLD_Y_View = SOLARCHVISION_H_Pixel;
    WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);
    WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);

    STUDY_CX_View = 0;
    STUDY_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + SOLARCHVISION_H_Pixel;
    STUDY_X_View = 2 * SOLARCHVISION_W_Pixel;
    STUDY_Y_View = 1 * SOLARCHVISION_H_Pixel;
    STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);   
    STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
  } else if (FrameVariation == 1) {

    STUDY_Include = 0;
    WIN3D_Include = 1;
    WORLD_Include = 0;

    WIN3D_CX_View = 0;
    WIN3D_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WIN3D_X_View = 3 * SOLARCHVISION_H_Pixel;
    WIN3D_Y_View = 2 * SOLARCHVISION_H_Pixel;
    WIN3D_R_View = float(WIN3D_Y_View) / float(WIN3D_X_View);
    WIN3D_Diagrams = createGraphics(WIN3D_X_View, WIN3D_Y_View, P3D);
  } else if (FrameVariation == 2) {

    STUDY_Include = 1;
    WIN3D_Include = 0;
    WORLD_Include = 0;

    STUDY_CX_View = 0;
    STUDY_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    STUDY_X_View = 2 * SOLARCHVISION_W_Pixel;
    STUDY_Y_View = 2 * SOLARCHVISION_H_Pixel;
    STUDY_R_View = float(STUDY_Y_View) / float(STUDY_X_View);   
    STUDY_Diagrams = createGraphics(STUDY_X_View, STUDY_Y_View, P2D);
  } else if (FrameVariation == 3) {

    STUDY_Include = 0;
    WIN3D_Include = 0;
    WORLD_Include = 1;

    WORLD_CX_View = 0;
    WORLD_CY_View = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 0;
    WORLD_X_View = 2 * SOLARCHVISION_W_Pixel;
    WORLD_Y_View = 2 * SOLARCHVISION_H_Pixel;
    WORLD_R_View = float(WORLD_Y_View) / float(WORLD_X_View);
    WORLD_Diagrams = createGraphics(WORLD_X_View, WORLD_Y_View, P2D);
  } 

  WORLD_Update = 1;
  WIN3D_Update = 1; 
  STUDY_Update = 1;
}




void keyPressed (KeyEvent e) {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;

      if ((SOLARCHVISION_UI_BAR_a_selected_parent != -1) || (SOLARCHVISION_UI_BAR_a_selected_child != 0)) {

        SOLARCHVISION_UI_BAR_a_selected_parent = -1;
        SOLARCHVISION_UI_BAR_a_selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);
      }

      addNewSelectionToPreviousSelection = 0;

      //println("key: " + key);
      //println("keyCode: " + keyCode);



      STUDY_keyPressed(e);

      WIN3D_keyPressed(e);

      if (e.isAltDown() == true) {

        if (key == CODED) { 
          switch(keyCode) {
          }
        } else {
          switch(key) {
          case 'l' : 
            FrameVariation = (FrameVariation + 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT_Update = 1; 
            break;
          case 'L' : 
            FrameVariation = (FrameVariation + 4 - 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT_Update = 1; 
            break;
          }
        }
      } else if (e.isControlDown() == true) {

        addNewSelectionToPreviousSelection = 1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : 
            SOLARCHVISION_ROLLOUT_parent = 0; 
            ROLLOUT_Update = 1; 
            break;
          case 113 : 
            SOLARCHVISION_ROLLOUT_parent = 1; 
            ROLLOUT_Update = 1; 
            break;
          case 114 : 
            SOLARCHVISION_ROLLOUT_parent = 2; 
            ROLLOUT_Update = 1; 
            break;
          case 115 : 
            SOLARCHVISION_ROLLOUT_parent = 3; 
            ROLLOUT_Update = 1; 
            break;
          case 116 : 
            SOLARCHVISION_ROLLOUT_parent = 4; 
            ROLLOUT_Update = 1; 
            break;
          case 117 : 
            SOLARCHVISION_ROLLOUT_parent = 5; 
            ROLLOUT_Update = 1; 
            break;
          case 118 : 
            SOLARCHVISION_ROLLOUT_parent = 6; 
            ROLLOUT_Update = 1; 
            break;
          case 119 : 
            SOLARCHVISION_ROLLOUT_parent = 7; 
            ROLLOUT_Update = 1; 
            break;
          }
        } else {
          switch(key) {

          case 'f' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD_Update = 1;
            WIN3D_Update = 1; 
            STUDY_Update = 1;
            ROLLOUT_Update = 1; 
            break;

          case 'F' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD_Update = 1;
            WIN3D_Update = 1; 
            STUDY_Update = 1;
            ROLLOUT_Update = 1; 
            break;
          }
        }
      } else if (e.isShiftDown() == true) {

        addNewSelectionToPreviousSelection = -1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : 
            SOLARCHVISION_ROLLOUT_child = 1; 
            ROLLOUT_Update = 1; 
            break;
          case 113 : 
            SOLARCHVISION_ROLLOUT_child = 2; 
            ROLLOUT_Update = 1; 
            break;
          case 114 : 
            SOLARCHVISION_ROLLOUT_child = 3; 
            ROLLOUT_Update = 1; 
            break;
          case 115 : 
            SOLARCHVISION_ROLLOUT_child = 4; 
            ROLLOUT_Update = 1; 
            break;
          case 116 : 
            SOLARCHVISION_ROLLOUT_child = 5; 
            ROLLOUT_Update = 1; 
            break;
          case 117 : 
            SOLARCHVISION_ROLLOUT_child = 6; 
            ROLLOUT_Update = 1; 
            break;
          case 118 : 
            SOLARCHVISION_ROLLOUT_child = 7; 
            ROLLOUT_Update = 1; 
            break;
          case 119 : 
            SOLARCHVISION_ROLLOUT_child = 8; 
            ROLLOUT_Update = 1; 
            break;
          }
        }
      }


      if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
        if (key == CODED) { 
          switch(key) {
          }
        }
      }

      if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

        if (key != CODED) { 
          switch(key) {



          case 'g' :
            AERIAL_graphOption = (AERIAL_graphOption + 1) % 2;
            WORLD_Update = 1;
            WIN3D_Update = 1; 
            ROLLOUT_Update = 1; 
            break;

          case 'G' :
            AERIAL_graphOption = (AERIAL_graphOption + 2 - 1) % 2;
            WORLD_Update = 1;
            WIN3D_Update = 1; 
            ROLLOUT_Update = 1; 
            break;
          }
        }
      }      

      if ((STUDY_Update != 0) || (WORLD_Update != 0) || (WIN3D_Update != 0) || (ROLLOUT_Update != 0)) redraw();
    }
  }
}

void keyReleased () {   

  addNewSelectionToPreviousSelection = 0;
}


float EquationOfTime (float DateAngle) {
  float b = DateAngle;

  return 0.01  * (9.87 * sin_ang(2 * b) - 7.53 * cos_ang(b) - 1.5 * sin_ang(b));
}

float FLOAT_e = 2.7182818284;

float[] SOLARCHVISION_SunPositionRadiation (float LocationLatitude, float DateAngle, float HourAngleOrigin, float CloudCover) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle); 

  float Declination = 23.45 * sin_ang(DateAngle - 180.0);

  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngleOrigin);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngleOrigin);

  float x = c; 
  float y = -(a * cos_ang(LocationLatitude) + b * sin_ang(LocationLatitude));
  float z = -a * sin_ang(LocationLatitude) + b * cos_ang(LocationLatitude);

  float Io = 1367.0; // W/m²
  Io = Io * (1.0 - (0.0334 * sin_ang(DateAngle)));

  float ALT_ = (asin_ang(z)) * PI / 180; 
  float ALT_true = ALT_ + 0.061359 * (0.1594 + 1.1230 * ALT_ + 0.065656 * ALT_ * ALT_) / (1 + 28.9344 * ALT_ + 277.3971 * ALT_ * ALT_);

  float PPo = pow(FLOAT_e, (-LocationElevation / 8435.2));
  float Bb = ((sin_ang (ALT_true * 180 / PI)) + (0.50572 * pow((57.29578 * ALT_true + 6.07995), -1.6364)));
  float m = PPo / Bb;

  float StationTurbidity;

  StationTurbidity = (2.0 - 0.2) * (0.1 * CloudCover) + 0.2;

  float AtmosphereRatio;
  if (z < 0.01) AtmosphereRatio = 0.0; 
  else AtmosphereRatio = pow(FLOAT_e, (-m * StationTurbidity));

  float Idirect = Io * AtmosphereRatio; // Optical air mass: global Meteorological Database for Engineers, Planners and Education; Version 5.00 - Edition 2003

  float Idiffuse;
  if (z < 0.01) Idiffuse = 0.0;
  else Idiffuse = ((0.5 + 0.5 * (0.1 * CloudCover)) * z * (Io - Idirect)) / (1.0 - 1.4 * z * log(Idirect / Io));

  float[] return_array = {
    0, x, y, z, Idirect, Idiffuse
  }; 
  return return_array;
}

float[] SOLARCHVISION_SunPosition (float Latitude, float DateAngle, float HourAngleOrigin) {
  float HourAngle = HourAngleOrigin + EquationOfTime(DateAngle);

  float Declination = 23.45 * sin_ang(DateAngle - 180.0);

  float a = sin_ang(Declination);
  float b = cos_ang(Declination) * -cos_ang(15.0 * HourAngle);
  float c = cos_ang(Declination) *  sin_ang(15.0 * HourAngle);

  float x = c; 
  float y = -(a * cos_ang(Latitude) + b * sin_ang(Latitude));
  float z = -a * sin_ang(Latitude) + b * cos_ang(Latitude);

  float[] return_array = {
    0, x, y, z
  }; 
  return return_array;
}

float SOLARCHVISION_Sunrise (float Latitude, float DateAngle) {

  float a = 0;

  float Declination = 23.5 * sin_ang(DateAngle - 180.0);

  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  } else if (q < -1.0) {
    a = 24.0;
  } else a = acos_ang(q) / 15.0;

  //return (a - EquationOfTime(DateAngle));
  return a;
}

float SOLARCHVISION_Sunset (float Latitude, float DateAngle) {

  float a = 0;

  float Declination = 23.5 * sin_ang(DateAngle - 180.0);

  float q = -(tan_ang(Declination) * tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  } else if (q < -1.0) {
    a = 24.0;
  } else a = acos_ang(q) / 15.0;


  //return ((24 - a) - EquationOfTime(DateAngle));
  return (24 - a);
}

float SOLARCHVISION_DayTime (float Latitude, float DateAngle) {
  return abs((SOLARCHVISION_Sunset(Latitude, DateAngle)) -(SOLARCHVISION_Sunrise(Latitude, DateAngle)));
}

String Default_Font = "MS Sans Serif";

/*
"MS Sans Serif"
 "Microsoft Sans Serif"
 "Arial Narrow"
 "Arial"
 "Times New Roman"
 "Calibri"
 "Cambria"
 "Georgia"
 "Courier New"
 "Franklin Gothic Medium"
 "BankGothic Md BT"
 */

PFont SOLARCHVISION_font;

void SOLARCHVISION_LoadDefaultFontStyle () {

  println("Loading font:", Default_Font);

  SOLARCHVISION_font = createFont(Default_Font, 36, true);

  SOLARCHVISION_ResetFontStyle();
}

void SOLARCHVISION_ResetFontStyle () {

  textFont(SOLARCHVISION_font);
  WORLD_Diagrams.textFont(SOLARCHVISION_font);
  WIN3D_Diagrams.textFont(SOLARCHVISION_font);
  STUDY_Diagrams.textFont(SOLARCHVISION_font);
}

void SOLARCHVISION_add_Object2D_single (String t, int m, float x, float y, float z, float s) {

  if (allGroup3Ds_num == 0) SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  {

    int n1 = Object2D_PEOPLE_Files_Num;    
    int n2 = Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num;

    int n = m;

    if (n == 0) {
      if (t.equals("PEOPLE")) n = int(random(1, 1 + n1));
      else if (t.equals("TREES")) n = int(random(1 + n1, 1 + n2));
    }

    int d = 1; 
    int r = int(random(2));
    if (r == 0) d = -1; 

    int[] TempObject2D_MAP = {
      d * n
    }; 
    allObject2Ds_MAP = concat(allObject2Ds_MAP, TempObject2D_MAP);

    float[][] TempObject2D_XYZS = {
      {
        x, y, z, s
      }
    };
    allObject2Ds_XYZS = (float[][]) concat(allObject2Ds_XYZS, TempObject2D_XYZS);

    allObject2Ds_num += 1;

    if (abs(n) > n1) {

      if (CreateInput_MeshOrSolid != 0) {

        float x0 = x;
        float y0 = y;
        float z0 = 0.5 * s + z;
        float r0 = 0.4 * s; // <<<<<<< approximate

        SOLARCHVISION_add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, CreateInput_MeshOrSolid);
      }
    }
  }

  allGroup3Ds_Object2Ds[allGroup3Ds_num][1] = allObject2Ds_num;
}



PImage[] Object2D_Images;
float[] Object2D_ImageRatios;

void SOLARCHVISION_LoadObject2DImages () {

  Object2D_ImagePath = new String [1];
  Object2D_ImagePath[0] = "";

  String[] Object2D_Filenames_PEOPLE = sort(SOLARCHVISION_getfiles(Object2DFolder_PEOPLE));
  String[] Object2D_Filenames_TREES = sort(SOLARCHVISION_getfiles(Object2DFolder_TREES));  

  Object2D_ImagePath = concat(Object2D_ImagePath, Object2D_Filenames_PEOPLE);
  Object2D_ImagePath = concat(Object2D_ImagePath, Object2D_Filenames_TREES);

  Object2D_PEOPLE_Files_Num = Object2D_Filenames_PEOPLE.length;
  Object2D_TREES_Files_Num = Object2D_Filenames_TREES.length;


  int n = Object2D_ImagePath.length;

  Object2D_Images = new PImage [n + 1];
  Object2D_ImageRatios = new float [n + 1];

  for (int i = 1; i < n; i += 1) { // leaving [0] null  

    if (i <= Object2D_PEOPLE_Files_Num) {
      Object2D_ImagePath[i] = Object2DFolder_PEOPLE + "/" + Object2D_ImagePath[i];
    } else {
      Object2D_ImagePath[i] = Object2DFolder_TREES + "/" + Object2D_ImagePath[i];
    }
  }

  for (int i = 1; i < n; i += 1) {
    //println(Object2D_ImagePath[i]);
    Object2D_Images[i] = loadImage(Object2D_ImagePath[i]);

    if (Object2D_Images[i].height != 0) {
      Object2D_ImageRatios[i] = float(Object2D_Images[i].width) / float(Object2D_Images[i].height);
    } else {
      Object2D_ImageRatios[i] = 1;
    }
  }
}



void SOLARCHVISION_ListWorldImages () {

  WORLD_VIEW_Filenames = sort(SOLARCHVISION_getfiles(WorldViewFolder));

  WORLD_Viewports_num = WORLD_VIEW_Filenames.length;

  WORLD_VIEW_Name = new String [WORLD_Viewports_num][2];

  WORLD_VIEW_BoundariesX = new float [WORLD_Viewports_num][2];
  WORLD_VIEW_BoundariesY = new float [WORLD_Viewports_num][2];

  WORLD_VIEW_GridDisplay = new int [WORLD_Viewports_num];

  for (int i = 0; i < WORLD_Viewports_num; i += 1) {
    String MapFilename = WorldViewFolder + "/" + WORLD_VIEW_Filenames[i];

    String[] Parts = split(WORLD_VIEW_Filenames[i], '_');

    WORLD_VIEW_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
    WORLD_VIEW_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
    WORLD_VIEW_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
    WORLD_VIEW_BoundariesY[i][1] =  float(Parts[4]) * 0.001;

    WORLD_VIEW_Name[i][0] = Parts[5];
    WORLD_VIEW_Name[i][1] = Parts[6];

    float a = (WORLD_VIEW_BoundariesY[i][1] - WORLD_VIEW_BoundariesY[i][0]) / 2;
    if (a < 1) a = 1;
    WORLD_VIEW_GridDisplay[i] = int(a);
  }
}





int WORLD_FindGoodViewport (float pointLongitude, float pointLatitude) {

  int return_VIEWPORT = WORLD_VIEW_Number;

  if (WORLD_AutoView == 1) {

    float d1 = FLOAT_undefined;
    float d2 = FLOAT_undefined;

    for (int i = 0; i < WORLD_Viewports_num; i++) {

      int check_it = 0; 

      String started_with = WORLD_VIEW_Filenames[i].substring(0, 1);

      if (WORLD_Viewport_ZOOM == 1) {
        if (started_with.equals("A")) check_it = 1;
      } else if (WORLD_Viewport_ZOOM == 2) {
        if (started_with.equals("B")) check_it = 1;
      } else if (WORLD_Viewport_ZOOM == 3) {
        if (started_with.equals("C")) check_it = 1;
      } else if (WORLD_Viewport_ZOOM == 4) {
        if (started_with.equals("D")) check_it = 1;
      } else if (WORLD_Viewport_ZOOM == 5) {
        if (started_with.equals("E")) check_it = 1;
      } else {
        check_it = 1;
      }

      if (check_it == 1) {  

        if (isInside(pointLongitude, pointLatitude, WORLD_VIEW_BoundariesX[i][0], WORLD_VIEW_BoundariesY[i][0], WORLD_VIEW_BoundariesX[i][1], WORLD_VIEW_BoundariesY[i][1]) == 1) {
          float d_Center = dist(pointLongitude, pointLatitude, 0.5 * (WORLD_VIEW_BoundariesX[i][0] + WORLD_VIEW_BoundariesX[i][1]), 0.5 * (WORLD_VIEW_BoundariesY[i][0] + WORLD_VIEW_BoundariesY[i][1]));
          float d_Size = dist(WORLD_VIEW_BoundariesX[i][0], WORLD_VIEW_BoundariesY[i][0], WORLD_VIEW_BoundariesX[i][1], WORLD_VIEW_BoundariesY[i][1]);

          if (d2 > 0.95 * d_Size) {
            if (d1 > d_Center) {
              d1 = d_Center;
              d2 = d_Size;

              return_VIEWPORT = i;
            }
          }
        }
      }
    }
  }

  if (return_VIEWPORT != WORLD_VIEW_Number) {
    SOLARCHVISION_Load_WorldViewImage(return_VIEWPORT);

    if (Display_EARTH3D_Surface != 0) WIN3D_Update = 1;
  }

  return (return_VIEWPORT);
}


PImage WORLDViewImage;

void SOLARCHVISION_Load_WorldViewImage (int n) {

  println("Loading:", WorldViewFolder + "/" + WORLD_VIEW_Filenames[n]);

  WORLDViewImage = loadImage(WorldViewFolder + "/" + WORLD_VIEW_Filenames[n]);
}










int STATION_NAEFS_NUMBER = 0;
String[][] STATION_NAEFS_INFO;

void SOLARCHVISION_getNAEFS_Coordinates () {
  try {
    String[] FileALL = loadStrings(NAEFSFolder + "/NAEFS_UTF8.txt");

    String lineSTR;
    String[] input;

    STATION_NAEFS_NUMBER = FileALL.length - 1; // to skip the first description line 

    STATION_NAEFS_INFO = new String [STATION_NAEFS_NUMBER][7]; 

    int n_Locations = 0;

    for (int f = 0; f < STATION_NAEFS_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";      
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationFilename = "";

      String[] parts = split(lineSTR, '\t');

      if (3 < parts.length) {

        StationFilename = parts[0];

        StationNameEnglish = split(StationFilename, '_')[0];
        StationProvince = split(StationFilename, '_')[1];
        StationCountry = split(StationFilename, '_')[2];

        int l = 0;

        l = parts[1].length();
        if (((parts[1].substring(l - 1, l)).equals("N")) || ((parts[1].substring(l - 1, l)).equals("S"))) {
          String[] the_parts = split(parts[1], ':');
          StationLatitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
          if ((parts[1].substring(l - 1, l)).equals("S")) StationLatitude *= -1;
        } else {
          StationLatitude = float(parts[1]);
        }

        l = parts[2].length();
        if (((parts[2].substring(l - 1, l)).equals("E")) || ((parts[2].substring(l - 1, l)).equals("W"))) {
          String[] the_parts = split(parts[2], ':');
          StationLongitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
          if ((parts[2].substring(l - 1, l)).equals("W")) StationLongitude *= -1;
        } else {
          StationLongitude = float(parts[2]);
        }

        l = parts[3].length();
        StationElevation = float(parts[3].substring(0, l - 1));

        STATION_NAEFS_INFO[n_Locations][0] = StationNameEnglish;
        STATION_NAEFS_INFO[n_Locations][1] = StationProvince;
        STATION_NAEFS_INFO[n_Locations][2] = StationCountry;        
        STATION_NAEFS_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_NAEFS_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_NAEFS_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_NAEFS_INFO[n_Locations][6] = StationFilename;

        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading NAEFS coordinates.");
  }
}


int STATION_CWEEDS_NUMBER = 0;
String[][] STATION_CWEEDS_INFO;

void SOLARCHVISION_getCWEEDS_Coordinates () {
  try {
    String[] FileALL = loadStrings(CWEEDSFolder + "/CWEEDS_UTF8.txt");

    String lineSTR;
    String[] input;

    STATION_CWEEDS_NUMBER = FileALL.length - 1; // to skip the first description line 

    STATION_CWEEDS_INFO = new String [STATION_CWEEDS_NUMBER][7]; 

    int n_Locations = 0;

    for (int f = 0; f < STATION_CWEEDS_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationFilename = "";

      String[] parts = split(lineSTR, '_');

      if (4 < parts.length) {

        StationFilename = lineSTR; 

        StationCountry = "CA";
        StationProvince = parts[0];
        StationNameEnglish = parts[1];


        StationLatitude = float(parts[2]) * 0.01;
        StationLongitude = float(parts[3]) * -0.01;
        StationElevation = 0; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

        STATION_CWEEDS_INFO[n_Locations][0] = StationNameEnglish;
        STATION_CWEEDS_INFO[n_Locations][1] = StationProvince;
        STATION_CWEEDS_INFO[n_Locations][2] = StationCountry;
        STATION_CWEEDS_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_CWEEDS_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_CWEEDS_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_CWEEDS_INFO[n_Locations][6] = StationFilename;

        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading CWEEDS coordinates.");
  }
}


int STATION_CLMREC_NUMBER = 0;
String[][] STATION_CLMREC_INFO;

void SOLARCHVISION_getCLMREC_Coordinates () {
  
  try {
    String[] FileALL = loadStrings(CLMRECFolder + "/CLMREC_UTF8.txt");

    String lineSTR;
    String[] input;

    STATION_CLMREC_NUMBER = FileALL.length - 1; // to skip the first description line 

    STATION_CLMREC_INFO = new String [STATION_CLMREC_NUMBER][11]; 

    int n_Locations = 0;

    for (int f = 0; f < STATION_CLMREC_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationICAO = "";
      String StationWMO = ""; 
      String StationClimate = "";
      int StationStart = -1;
      int StationEnd = -1;

      String[] parts = split(lineSTR, ',');

      if (12 < parts.length) {
        
        StationCountry = "CA";
        StationProvince = parts[1];
        StationNameEnglish = parts[0].replace('/', '_');

        StationLatitude = float(parts[6]);
        StationLongitude = float(parts[7]);
        StationElevation = float(parts[10]);

        StationICAO = parts[3];
        StationWMO = parts[4];
        StationClimate = parts[2];
        
        StationStart = int(parts[11]);
        StationEnd = int(parts[12]);

        STATION_CLMREC_INFO[n_Locations][0] = StationNameEnglish;
        STATION_CLMREC_INFO[n_Locations][1] = StationProvince;
        STATION_CLMREC_INFO[n_Locations][2] = StationCountry;
        STATION_CLMREC_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_CLMREC_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_CLMREC_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_CLMREC_INFO[n_Locations][6] = StationICAO;
        STATION_CLMREC_INFO[n_Locations][7] = StationWMO;
        STATION_CLMREC_INFO[n_Locations][8] = StationClimate;
        STATION_CLMREC_INFO[n_Locations][9] = String.valueOf(StationStart);
        STATION_CLMREC_INFO[n_Locations][10] = String.valueOf(StationEnd);

        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading CLMREC coordinates.");
  }
}



int STATION_SWOB_NUMBER = 0;
String[][] STATION_SWOB_INFO;

void SOLARCHVISION_getSWOB_Coordinates () {
  try {
    String[] FileALL = loadStrings(SWOBFolder + "/SWOB_UTF8.txt");

    String lineSTR;
    String[] input;

    STATION_SWOB_NUMBER = FileALL.length - 1; // to skip the first description line 

    STATION_SWOB_INFO = new String [STATION_SWOB_NUMBER][12]; 

    int n_Locations = 0;

    for (int f = 0; f < STATION_SWOB_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationNameFrench = "";
      String StationProvince = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      String StationICAO = "";
      String StationWMO = ""; 
      String StationClimate = "";
      String StationDST = ""; //Daylight saving time
      String StationSTD = ""; //Standard Time      
      String StationType = ""; // MAN/AUTO

      String[] parts = split(lineSTR, '\t');

      if (12 < parts.length) {

        StationNameFrench = parts[1];
        StationNameEnglish = parts[2];
        StationProvince = parts[3];

        StationType = parts[4];
        if (StationType.equals("Manned")) StationType = "MAN";
        if (StationType.equals("Auto")) StationType = "AUTO";

        StationLatitude = float(parts[5]);
        StationLongitude = float(parts[6]);
        StationElevation = float(parts[7]);

        StationICAO = parts[8];
        StationWMO = parts[9];
        StationClimate = parts[10];
        StationDST = parts[11];
        StationSTD = parts[12]; 

        STATION_SWOB_INFO[n_Locations][0] = StationNameEnglish;
        STATION_SWOB_INFO[n_Locations][1] = StationNameFrench;
        STATION_SWOB_INFO[n_Locations][2] = StationProvince;
        STATION_SWOB_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_SWOB_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_SWOB_INFO[n_Locations][5] = String.valueOf(StationElevation);
        STATION_SWOB_INFO[n_Locations][6] = StationICAO;
        STATION_SWOB_INFO[n_Locations][7] = StationWMO;
        STATION_SWOB_INFO[n_Locations][8] = StationClimate;
        STATION_SWOB_INFO[n_Locations][9] = StationDST;
        STATION_SWOB_INFO[n_Locations][10] = StationSTD;
        STATION_SWOB_INFO[n_Locations][11] = StationType;

        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading SWOB coordinates.");
  }
}


int STATION_TMYEPW_NUMBER = 0;
String[][] STATION_TMYEPW_INFO;

void SOLARCHVISION_getTMYEPW_Coordinates () {
  try {
    String[] FileALL = loadStrings(TMYEPWFolder + "/EPW_UTF8.txt");

    String lineSTR;
    String[] input;

    STATION_TMYEPW_NUMBER = FileALL.length - 1; // to skip the first description line 

    STATION_TMYEPW_INFO = new String [STATION_TMYEPW_NUMBER][9]; 

    int n_Locations = 0;

    for (int f = 0; f < STATION_TMYEPW_NUMBER; f += 1) {
      lineSTR = FileALL[f + 1]; // to skip the first description line  

      String StationNameEnglish = "";
      String StationProvince = "";
      String StationCountry = "";
      float StationLatitude = 0.0;
      float StationLongitude = 0.0;
      float StationElevation = 0.0; 
      float StationTimeZone = 0.0;      
      String StationWMO = ""; 
      String StationFilename = "";


      String[] parts = split(lineSTR, ',');

      if (10 < parts.length) {
        StationNameEnglish = parts[1];
        StationProvince = parts[2];
        StationCountry = parts[3];

        StationWMO = parts[5];

        StationLatitude = float(parts[6]);
        StationLongitude = float(parts[7]);
        StationTimeZone = 15 * float(parts[8]); 
        StationElevation = float(parts[9]);

        StationFilename = parts[10]; 

        STATION_TMYEPW_INFO[n_Locations][0] = StationNameEnglish;
        STATION_TMYEPW_INFO[n_Locations][1] = StationProvince;
        STATION_TMYEPW_INFO[n_Locations][2] = StationCountry;
        STATION_TMYEPW_INFO[n_Locations][3] = String.valueOf(StationLatitude);
        STATION_TMYEPW_INFO[n_Locations][4] = String.valueOf(StationLongitude);
        STATION_TMYEPW_INFO[n_Locations][5] = String.valueOf(StationElevation);      
        STATION_TMYEPW_INFO[n_Locations][6] = String.valueOf(StationTimeZone);
        STATION_TMYEPW_INFO[n_Locations][7] = StationWMO;
        STATION_TMYEPW_INFO[n_Locations][8] = StationFilename;

        n_Locations += 1;
      }
    }
  }
  catch (Exception e) {
    println("ERROR reading TMYEPW coordinates.");
  }
}



int SOLARCHVISION_add_Vertex (float x, float y, float z) {

  float[][] newVertex = {
    {
      x, y, z
    }
  }; 

  allVertices = (float[][]) concat(allVertices, newVertex);

  return(allVertices.length - 1);
}

int SOLARCHVISION_add_Face (int[] f) {

  if (allGroup3Ds_num == 0) SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  {

    int[][] newFace_MTLV = {
      {
        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
      }
    }; 

    allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);

    int[][] newFace = {
      f
    }; 

    allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
  }

  allGroup3Ds_Faces[allGroup3Ds_num][1] = allFaces_PNT.length - 1;



  return(allFaces_PNT.length - 1);
}


int SOLARCHVISION_add_Solid (float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz, float v) {

  if (allGroup3Ds_num == 0) SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  {

    float[][] newSolid = {
      {
        x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz, v
      }
    };
    allSolids_DEF = (float[][]) concat(allSolids_DEF, newSolid);
  }

  allGroup3Ds_Solids[allGroup3Ds_num][1] = allSolids_DEF.length - 1;


  return(allSolids_DEF.length - 1);
}


void SOLARCHVISION_beginNewGroup3D (float x, float y, float z, float sx, float sy, float sz, float rx, float ry, float rz) {


  float[][] newObject_PivotXYZ = {
    {
      x, y, z, sx, sy, sz, rx, ry, rz
    }
  }; 

  allGroup3Ds_PivotXYZ = (float[][]) concat(allGroup3Ds_PivotXYZ, newObject_PivotXYZ);

  int[][] newObject_Pivot = {
    {
      defaultPivotType
    }
  };

  allGroup3Ds_PivotType = (int[][]) concat(allGroup3Ds_PivotType, newObject_Pivot);  


  int[][] newObject_Fractals = {
    {
      allFractals_num + 1, 0
    }
  }; // i.e. null because start > end 

  allGroup3Ds_Fractals = (int[][]) concat(allGroup3Ds_Fractals, newObject_Fractals);     

  int[][] newObject_Object2Ds = {
    {
      allObject2Ds_num + 1, 0
    }
  }; // i.e. null because start > end 

  allGroup3Ds_Object2Ds = (int[][]) concat(allGroup3Ds_Object2Ds, newObject_Object2Ds);   

  int[][] newObject_Solids = {
    {
      allSolids_DEF.length, 0
    }
  }; // i.e. null because start > end 

  allGroup3Ds_Solids = (int[][]) concat(allGroup3Ds_Solids, newObject_Solids);      

  int[][] newObject_Faces = {
    {
      allFaces_PNT.length, 0
    }
  }; // i.e. null because start > end   

  allGroup3Ds_Faces = (int[][]) concat(allGroup3Ds_Faces, newObject_Faces);


  allGroup3Ds_num += 1;
}



void SOLARCHVISION_duplicate_Selection (int produce_another_variation) {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
  }

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    int number_of_Fractal_before = allFractals_num + 1; 

    for (int o = 0; o < selectedFractal_numbers.length; o++) {

      int OBJ_NUM = selectedFractal_numbers[o];

      if (OBJ_NUM != 0) {    

        float x = allFractals_XYZSR[OBJ_NUM][0];
        float y = allFractals_XYZSR[OBJ_NUM][1];
        float z = allFractals_XYZSR[OBJ_NUM][2];
        float d = allFractals_XYZSR[OBJ_NUM][3];
        float rot = allFractals_XYZSR[OBJ_NUM][4];

        int n = allFractals_Type[OBJ_NUM];
        int dMin = allFractals_DegreeMin[OBJ_NUM];
        int dMax = allFractals_DegreeMax[OBJ_NUM];
        int s = allFractals_Seed[OBJ_NUM];
        float TrunkSize = allFractals_TrunkSize[OBJ_NUM];
        float LeafSize = allFractals_LeafSize[OBJ_NUM];

        if (produce_another_variation == 1) randomSeed(millis());
        SOLARCHVISION_add_Fractal(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
      }
    }

    // selecting new objetcs

    selectedFractal_numbers = new int [1];
    selectedFractal_numbers[0] = 0;

    for (int o = number_of_Fractal_before; o < allFractals_num + 1; o++) {

      int[] newlyAddedFractal = {
        o
      };

      selectedFractal_numbers = concat(selectedFractal_numbers, newlyAddedFractal);
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    int n1 = Object2D_PEOPLE_Files_Num;

    int number_of_Object2D_before = allObject2Ds_num + 1; 

    for (int o = 0; o < selectedObject2D_numbers.length; o++) {

      int OBJ_NUM = selectedObject2D_numbers[o];

      if (OBJ_NUM != 0) {    

        float x = allObject2Ds_XYZS[OBJ_NUM][0];
        float y = allObject2Ds_XYZS[OBJ_NUM][1];
        float z = allObject2Ds_XYZS[OBJ_NUM][2];
        float s = allObject2Ds_XYZS[OBJ_NUM][3];

        int n = allObject2Ds_MAP[OBJ_NUM];
        if (abs(n) > n1) {
          if (produce_another_variation == 1) n = 0; // this makes it random
          SOLARCHVISION_add_Object2D_single("TREES", n, x, y, z, s);
        } else {
          if (produce_another_variation == 1) n = 0; // this makes it random
          SOLARCHVISION_add_Object2D_single("PEOPLE", n, x, y, z, s);
        }
      }
    }

    // selecting new objetcs

      selectedObject2D_numbers = new int [1];
    selectedObject2D_numbers[0] = 0;

    for (int o = number_of_Object2D_before; o < allObject2Ds_num + 1; o++) {

      int[] newlyAddedObject2D = {
        o
      };

      selectedObject2D_numbers = concat(selectedObject2D_numbers, newlyAddedObject2D);
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Faces) {

    int number_of_Faces_before = allFaces_PNT.length;

    for (int o = 0; o < selectedFace_numbers.length; o++) {

      int f = selectedFace_numbers[o];        

      int number_of_Vertices_before = allVertices.length;

      int[] PolymeshVertices_OLD = {
        0
      }; // keeps the list of exiting vertex numbers
      int[] PolymeshVertices_NEW = {
        0
      }; // keeps the list of new vertex numbers

      if ((0 < f) && (f < allFaces_PNT.length)) {

        int[] newFace = {
        };

        for (int j = 0; j < allFaces_PNT[f].length; j++) {
          int vNo = allFaces_PNT[f][j];

          int vertex_listed = 0;

          for (int q = 1; q < PolymeshVertices_OLD.length; q++) {
            if (vNo == PolymeshVertices_OLD[q]) {
              vertex_listed = q;
              break;
            }
          }         

          if (vertex_listed == 0) {
            int[] newVertexListed = {
              vNo
            };
            PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

            float x = allVertices[vNo][0];
            float y = allVertices[vNo][1];
            float z = allVertices[vNo][2];

            int[] newVertexAdded = {
              SOLARCHVISION_add_Vertex(x, y, z)
            };
            PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

            vertex_listed = PolymeshVertices_OLD.length - 1;
          } 

          //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);

          int[] new_vertexItem = {
            number_of_Vertices_before + vertex_listed - 1
          };

          newFace = concat(newFace, new_vertexItem);
        }

        defaultMaterial = allFaces_MTLV[f][0];
        defaultTessellation = allFaces_MTLV[f][1];
        defaultLayer = allFaces_MTLV[f][2];
        defaultVisibility = allFaces_MTLV[f][3];        

        SOLARCHVISION_add_Face(newFace);
      }
    }


    // selecting new objetcs

    selectedFace_numbers = new int [1];
    selectedFace_numbers[0] = 0;

    for (int o = number_of_Faces_before; o < allFaces_PNT.length; o++) {

      int[] newlyAddedFace = {
        o
      };

      selectedFace_numbers = concat(selectedFace_numbers, newlyAddedFace);
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Solids) {

    int number_of_Solid_before = allSolids_DEF.length; 

    for (int o = 0; o < selectedSolid_numbers.length; o++) {

      int OBJ_NUM = selectedSolid_numbers[o];

      if (OBJ_NUM != 0) {    

        float Solid_posX = Solid_get_posX(OBJ_NUM);
        float Solid_posY = Solid_get_posY(OBJ_NUM);
        float Solid_posZ = Solid_get_posZ(OBJ_NUM);
        float Solid_powX = Solid_get_powX(OBJ_NUM);
        float Solid_powY = Solid_get_powY(OBJ_NUM);
        float Solid_powZ = Solid_get_powZ(OBJ_NUM);
        float Solid_scaleX = Solid_get_scaleX(OBJ_NUM);
        float Solid_scaleY = Solid_get_scaleY(OBJ_NUM);
        float Solid_scaleZ = Solid_get_scaleZ(OBJ_NUM);
        float Solid_rotX = Solid_get_rotX(OBJ_NUM);
        float Solid_rotY = Solid_get_rotY(OBJ_NUM);
        float Solid_rotZ = Solid_get_rotZ(OBJ_NUM);
        float Solid_value = Solid_get_value(OBJ_NUM);

        SOLARCHVISION_add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
      }
    }

    // selecting new objetcs

    selectedSolid_numbers = new int [1];
    selectedSolid_numbers[0] = 0;

    for (int o = number_of_Solid_before; o < allSolids_DEF.length; o++) {

      int[] newlyAddedSolid = {
        o
      };

      selectedSolid_numbers = concat(selectedSolid_numbers, newlyAddedSolid);
    }
  }    


  if (Current_ObjectCategory == ObjectCategory_Sections) {

    int number_of_Section_before = allSections_num + 1; 

    for (int o = 0; o < selectedSection_numbers.length; o++) {

      int OBJ_NUM = selectedSection_numbers[o];

      if (OBJ_NUM != 0) {    

        float Section_offset_U = allSections_UVERAB[OBJ_NUM][0];
        float Section_offset_V = allSections_UVERAB[OBJ_NUM][1];
        float Section_Elevation = allSections_UVERAB[OBJ_NUM][2];
        float Section_Rotation = allSections_UVERAB[OBJ_NUM][3];
        float Section_scale_U = allSections_UVERAB[OBJ_NUM][4];
        float Section_scale_V = allSections_UVERAB[OBJ_NUM][5];

        int Section_Type = allSections_Type[OBJ_NUM];
        int Section_RES1 = allSections_RES1[OBJ_NUM];
        int Section_RES2 = allSections_RES2[OBJ_NUM];

        SOLARCHVISION_add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
      }
    }

    // selecting new objetcs

    selectedSection_numbers = new int [1];
    selectedSection_numbers[0] = 0;

    for (int o = number_of_Section_before; o < allSections_num + 1; o++) {

      int[] newlyAddedSection = {
        o
      };

      selectedSection_numbers = concat(selectedSection_numbers, newlyAddedSection);
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    int number_of_Camera_before = allCameras_num + 1; 

    for (int o = 0; o < selectedCamera_numbers.length; o++) {

      int OBJ_NUM = selectedCamera_numbers[o];

      if (OBJ_NUM != 0) {    

        float Camera_X = allCameras_PPPSRRRF[OBJ_NUM][0];
        float Camera_Y = allCameras_PPPSRRRF[OBJ_NUM][1];
        float Camera_Z = allCameras_PPPSRRRF[OBJ_NUM][2];
        float Camera_S = allCameras_PPPSRRRF[OBJ_NUM][3];
        float Camera_RX = allCameras_PPPSRRRF[OBJ_NUM][4];
        float Camera_RY = allCameras_PPPSRRRF[OBJ_NUM][5];
        float Camera_RZ = allCameras_PPPSRRRF[OBJ_NUM][6];
        float Camera_ZOOM = allCameras_PPPSRRRF[OBJ_NUM][7];

        int Camera_Type = allCameras_Type[OBJ_NUM];

        SOLARCHVISION_add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);
      }
    }

    // selecting new objetcs

    selectedCamera_numbers = new int [1];
    selectedCamera_numbers[0] = 0;

    for (int o = number_of_Camera_before; o < allCameras_num + 1; o++) {

      int[] newlyAddedCamera = {
        o
      };

      selectedCamera_numbers = concat(selectedCamera_numbers, newlyAddedCamera);
    }
  }  


  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    int n1 = Object2D_PEOPLE_Files_Num;

    int SOLID_added = 0;

    int number_of_Group3Ds_before = allGroup3Ds_num + 1;

    for (int o = 0; o < selectedGroup3D_numbers.length; o++) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        if ((0 < allGroup3Ds_Faces[OBJ_NUM][0]) && (allGroup3Ds_Faces[OBJ_NUM][0] <= allGroup3Ds_Faces[OBJ_NUM][1])) { 

          int number_of_Vertices_before = allVertices.length;

          SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

          int new_OBJ_NUM = allGroup3Ds_num;

          allGroup3Ds_PivotType[new_OBJ_NUM][0] = allGroup3Ds_PivotType[OBJ_NUM][0];

          for (int j = 0; j < allGroup3Ds_PivotXYZ[OBJ_NUM].length; j++) { 
            allGroup3Ds_PivotXYZ[new_OBJ_NUM][j] = allGroup3Ds_PivotXYZ[OBJ_NUM][j];
          }

          if ((0 < allGroup3Ds_Fractals[OBJ_NUM][1]) && (allGroup3Ds_Fractals[OBJ_NUM][0] <= allGroup3Ds_Fractals[OBJ_NUM][1])) { 
            for (int q = allGroup3Ds_Fractals[OBJ_NUM][0]; q <= allGroup3Ds_Fractals[OBJ_NUM][1]; q++) {

              if (q != 0) {

                float x = allFractals_XYZSR[q][0];
                float y = allFractals_XYZSR[q][1];
                float z = allFractals_XYZSR[q][2];

                float d = allFractals_XYZSR[q][3];
                float rot = allFractals_XYZSR[q][4];

                int n = allFractals_Type[q];

                int dMin = allFractals_DegreeMin[q];

                int dMax = allFractals_DegreeMax[q];

                int s = allFractals_Seed[q];

                float TrunkSize = allFractals_TrunkSize[q];

                float LeafSize = allFractals_LeafSize[q];

                if (produce_another_variation == 1) {
                  randomSeed(millis());

                  rot = random(360);
                  s = int(random(32767));
                }
                SOLARCHVISION_add_Fractal(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
              }
            }
          }

          if ((0 < allGroup3Ds_Object2Ds[OBJ_NUM][1]) && (allGroup3Ds_Object2Ds[OBJ_NUM][0] <= allGroup3Ds_Object2Ds[OBJ_NUM][1])) { 
            for (int q = allGroup3Ds_Object2Ds[OBJ_NUM][0]; q <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; q++) {

              if (q != 0) {

                float x = allObject2Ds_XYZS[q][0];
                float y = allObject2Ds_XYZS[q][1];
                float z = allObject2Ds_XYZS[q][2];
                float s = allObject2Ds_XYZS[q][3];

                int n = allObject2Ds_MAP[q];

                if (abs(n) > n1) {
                  if (produce_another_variation == 1) n = 0; // this makes it random
                  SOLARCHVISION_add_Object2D_single("TREES", n, x, y, z, s);
                } else {
                  if (produce_another_variation == 1) n = 0; // this makes it random
                  SOLARCHVISION_add_Object2D_single("PEOPLE", n, x, y, z, s);
                }
              }
            }
          }

          if ((0 < allGroup3Ds_Solids[OBJ_NUM][1]) && (allGroup3Ds_Solids[OBJ_NUM][0] <= allGroup3Ds_Solids[OBJ_NUM][1])) { 
            for (int q = allGroup3Ds_Solids[OBJ_NUM][0]; q <= allGroup3Ds_Solids[OBJ_NUM][1]; q++) {

              if (q != 0) {

                float Solid_posX = Solid_get_posX(q);
                float Solid_posY = Solid_get_posY(q);
                float Solid_posZ = Solid_get_posZ(q);
                float Solid_powX = Solid_get_powX(q);
                float Solid_powY = Solid_get_powY(q);
                float Solid_powZ = Solid_get_powZ(q);
                float Solid_scaleX = Solid_get_scaleX(q);
                float Solid_scaleY = Solid_get_scaleY(q);
                float Solid_scaleZ = Solid_get_scaleZ(q);
                float Solid_rotX = Solid_get_rotX(q);
                float Solid_rotY = Solid_get_rotY(q);
                float Solid_rotZ = Solid_get_rotZ(q);
                float Solid_value = Solid_get_value(q);

                SOLARCHVISION_add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

                SOLID_added += 1;
              }
            }
          }


          int[] PolymeshVertices_OLD = {
            0
          }; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = {
            0
          }; // keeps the list of new vertex numbers

          for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {

            if ((0 < f) && (f < allFaces_PNT.length)) {

              int[] newFace = {
              };

              for (int j = 0; j < allFaces_PNT[f].length; j++) {
                int vNo = allFaces_PNT[f][j];

                int vertex_listed = 0;

                for (int q = 1; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;
                  }
                }         

                if (vertex_listed == 0) {
                  int[] newVertexListed = {
                    vNo
                  };
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

                  float x = allVertices[vNo][0];
                  float y = allVertices[vNo][1];
                  float z = allVertices[vNo][2];

                  int[] newVertexAdded = {
                    SOLARCHVISION_add_Vertex(x, y, z)
                  };
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

                  vertex_listed = PolymeshVertices_OLD.length - 1;
                } 

                //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);

                int[] new_vertexItem = {
                  number_of_Vertices_before + vertex_listed - 1
                };

                newFace = concat(newFace, new_vertexItem);
              }

              defaultMaterial = allFaces_MTLV[f][0];
              defaultTessellation = allFaces_MTLV[f][1];
              defaultLayer = allFaces_MTLV[f][2];
              defaultVisibility = allFaces_MTLV[f][3];

              SOLARCHVISION_add_Face(newFace);
            }
          }
        }
      }
    }    


    // selecting new objetcs

    selectedGroup3D_numbers = new int [1];
    selectedGroup3D_numbers[0] = 0;

    for (int o = number_of_Group3Ds_before; o < allGroup3Ds_num + 1; o++) {

      int[] newlyAddedGroup3D = {
        o
      };

      selectedGroup3D_numbers = concat(selectedGroup3D_numbers, newlyAddedGroup3D);
    }       


    if (SOLID_added != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
  }
}





void SOLARCHVISION_group_Selection (int createNewGroup) { // if this option == 0 then the objects are added to the last group


    int run_process = 0;

  if (Current_ObjectCategory == ObjectCategory_Solids) run_process = 1;
  if (Current_ObjectCategory == ObjectCategory_Faces) run_process = 1;
  if (Current_ObjectCategory == ObjectCategory_Object2Ds) run_process = 1;
  if (Current_ObjectCategory == ObjectCategory_Fractals) run_process = 1;

  if (run_process == 1) {

    if (createNewGroup == 1) {
      float x = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
      float y = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][1];
      float z = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][2];

      float rot = CreateInput_Orientation;
      if (rot == 360) rot = WIN3D_RZ_Coordinate;

      SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    }


    int pre_addToLastGroup3D = addToLastGroup3D;
    addToLastGroup3D = 1;


    if (Current_ObjectCategory == ObjectCategory_Fractals) {

      for (int o = 0; o < selectedFractal_numbers.length; o++) {

        int OBJ_NUM = selectedFractal_numbers[o];

        if (OBJ_NUM != 0) {    

          float x = allFractals_XYZSR[OBJ_NUM][0];
          float y = allFractals_XYZSR[OBJ_NUM][1];
          float z = allFractals_XYZSR[OBJ_NUM][2];
          float d = allFractals_XYZSR[OBJ_NUM][3];
          float rot = allFractals_XYZSR[OBJ_NUM][4];

          int n = allFractals_Type[OBJ_NUM];
          int dMin = allFractals_DegreeMin[OBJ_NUM];
          int dMax = allFractals_DegreeMax[OBJ_NUM];
          int s = allFractals_Seed[OBJ_NUM];
          float TrunkSize = allFractals_TrunkSize[OBJ_NUM];
          float LeafSize = allFractals_LeafSize[OBJ_NUM];

          SOLARCHVISION_add_Fractal(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
        }
      }
    }  

    if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

      int n1 = Object2D_PEOPLE_Files_Num;

      for (int o = 0; o < selectedObject2D_numbers.length; o++) {

        int OBJ_NUM = selectedObject2D_numbers[o];

        if (OBJ_NUM != 0) {    

          float x = allObject2Ds_XYZS[OBJ_NUM][0];
          float y = allObject2Ds_XYZS[OBJ_NUM][1];
          float z = allObject2Ds_XYZS[OBJ_NUM][2];
          float s = allObject2Ds_XYZS[OBJ_NUM][3];

          int n = allObject2Ds_MAP[OBJ_NUM];
          if (abs(n) > n1) {
            SOLARCHVISION_add_Object2D_single("TREES", n, x, y, z, s);
          } else {
            SOLARCHVISION_add_Object2D_single("PEOPLE", n, x, y, z, s);
          }
        }
      }
    }


    if (Current_ObjectCategory == ObjectCategory_Solids) {

      for (int o = 0; o < selectedSolid_numbers.length; o++) {

        int OBJ_NUM = selectedSolid_numbers[o];

        if (OBJ_NUM != 0) {    

          float Solid_posX = Solid_get_posX(OBJ_NUM);
          float Solid_posY = Solid_get_posY(OBJ_NUM);
          float Solid_posZ = Solid_get_posZ(OBJ_NUM);
          float Solid_powX = Solid_get_powX(OBJ_NUM);
          float Solid_powY = Solid_get_powY(OBJ_NUM);
          float Solid_powZ = Solid_get_powZ(OBJ_NUM);
          float Solid_scaleX = Solid_get_scaleX(OBJ_NUM);
          float Solid_scaleY = Solid_get_scaleY(OBJ_NUM);
          float Solid_scaleZ = Solid_get_scaleZ(OBJ_NUM);
          float Solid_rotX = Solid_get_rotX(OBJ_NUM);
          float Solid_rotY = Solid_get_rotY(OBJ_NUM);
          float Solid_rotZ = Solid_get_rotZ(OBJ_NUM);
          float Solid_value = Solid_get_value(OBJ_NUM);

          SOLARCHVISION_add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
        }
      }
    }    



    if (Current_ObjectCategory == ObjectCategory_Faces) {

      for (int o = 0; o < selectedFace_numbers.length; o++) {

        int f = selectedFace_numbers[o];        

        int number_of_Vertices_before = allVertices.length;

        int[] PolymeshVertices_OLD = {
          0
        }; // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = {
          0
        }; // keeps the list of new vertex numbers

        if ((0 < f) && (f < allFaces_PNT.length)) {

          int[] newFace = {
          };

          for (int j = 0; j < allFaces_PNT[f].length; j++) {
            int vNo = allFaces_PNT[f][j];

            int vertex_listed = 0;

            for (int q = 1; q < PolymeshVertices_OLD.length; q++) {
              if (vNo == PolymeshVertices_OLD[q]) {
                vertex_listed = q;
                break;
              }
            }         

            if (vertex_listed == 0) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);

              float x = allVertices[vNo][0];
              float y = allVertices[vNo][1];
              float z = allVertices[vNo][2];

              int[] newVertexAdded = {
                SOLARCHVISION_add_Vertex(x, y, z)
              };
              PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);

              vertex_listed = PolymeshVertices_OLD.length - 1;
            } 

            //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);

            int[] new_vertexItem = {
              number_of_Vertices_before + vertex_listed - 1
            };

            newFace = concat(newFace, new_vertexItem);
          }

          defaultMaterial = allFaces_MTLV[f][0];
          defaultTessellation = allFaces_MTLV[f][1];
          defaultLayer = allFaces_MTLV[f][2];
          defaultVisibility = allFaces_MTLV[f][3];        

          SOLARCHVISION_add_Face(newFace);
        }
      }
    }






    addToLastGroup3D = pre_addToLastGroup3D;


    SOLARCHVISION_delete_Selection();


    selectedGroup3D_numbers = new int [2];
    selectedGroup3D_numbers[0] = 0;
    selectedGroup3D_numbers[1] = allGroup3Ds_num;


    Current_ObjectCategory = ObjectCategory_Group3Ds;
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 731");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_ungroup_Selection () {

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    selectedGroup3D_numbers = sort(selectedGroup3D_numbers);


    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        allGroup3Ds_Faces[OBJ_NUM][0] = 0;
        allGroup3Ds_Faces[OBJ_NUM][1] = -1;

        allGroup3Ds_Fractals[OBJ_NUM][0] = 0;
        allGroup3Ds_Fractals[OBJ_NUM][1] = -1;

        allGroup3Ds_Object2Ds[OBJ_NUM][0] = 0;
        allGroup3Ds_Object2Ds[OBJ_NUM][1] = -1;

        allGroup3Ds_Solids[OBJ_NUM][0] = 0;
        allGroup3Ds_Solids[OBJ_NUM][1] = -1;
      }
    }

    SOLARCHVISION_delete_Selection();
  }
}


void SOLARCHVISION_dettachFromGroups_Selection () {

  SOLARCHVISION_group_Selection(1);
  SOLARCHVISION_ungroup_Selection();
}


void SOLARCHVISION_deleteEmptyGroups_Scene () {

  int pre_Current_ObjectCategory = Current_ObjectCategory;

  Current_ObjectCategory = ObjectCategory_Group3Ds;

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {  

    selectedGroup3D_numbers = new int [1];
    selectedGroup3D_numbers[0] = 0;

    for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

      int notEmpty = 0;

      if ((0 < allGroup3Ds_Faces[OBJ_NUM][0]) && (allGroup3Ds_Faces[OBJ_NUM][0] <= allGroup3Ds_Faces[OBJ_NUM][1])) notEmpty = 1;
      if ((0 < allGroup3Ds_Fractals[OBJ_NUM][0]) && (allGroup3Ds_Fractals[OBJ_NUM][0] <= allGroup3Ds_Fractals[OBJ_NUM][1])) notEmpty = 1;
      if ((0 < allGroup3Ds_Object2Ds[OBJ_NUM][0]) && (allGroup3Ds_Object2Ds[OBJ_NUM][0] <= allGroup3Ds_Object2Ds[OBJ_NUM][1])) notEmpty = 1;
      if ((0 < allGroup3Ds_Solids[OBJ_NUM][0]) && (allGroup3Ds_Solids[OBJ_NUM][0] <= allGroup3Ds_Solids[OBJ_NUM][1])) notEmpty = 1;

      if (notEmpty == 0) {

        int[] emptyGroup3D = {
          OBJ_NUM
        };

        selectedGroup3D_numbers = concat(selectedGroup3D_numbers, emptyGroup3D);
      }
    }

    SOLARCHVISION_delete_Selection();
  }

  Current_ObjectCategory = pre_Current_ObjectCategory;
}



void SOLARCHVISION_delete_Selection () {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
  }


  if (Current_ObjectCategory == ObjectCategory_Sections) {

    selectedSection_numbers = sort(selectedSection_numbers);

    for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSection_numbers[o];

      if (OBJ_NUM != 0) {    

        {
          float[][] startList = (float[][]) subset(allSections_UVERAB, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSections_UVERAB, OBJ_NUM + 1);

          allSections_UVERAB = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allSections_Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections_Type, OBJ_NUM + 1);

          allSections_Type = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allSections_RES1, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections_RES1, OBJ_NUM + 1);

          allSections_RES1 = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allSections_RES2, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections_RES2, OBJ_NUM + 1);

          allSections_RES2 = (int[]) concat(startList, endList);
        }

        {
          PImage[] startList = (PImage[]) subset(allSections_SolidImpact, 0, OBJ_NUM);
          PImage[] endList = (PImage[]) subset(allSections_SolidImpact, OBJ_NUM + 1);

          allSections_SolidImpact = (PImage[]) concat(startList, endList);
        }

        {
          PImage[][] startList = (PImage[][]) subset(allSections_SolarImpact, 0, OBJ_NUM);
          PImage[][] endList = (PImage[][]) subset(allSections_SolarImpact, OBJ_NUM + 1);

          allSections_SolarImpact = (PImage[][]) concat(startList, endList);
        }        

        allSections_num -= 1;
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    selectedCamera_numbers = sort(selectedCamera_numbers);

    for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedCamera_numbers[o];

      if (OBJ_NUM != 0) {    

        {
          float[][] startList = (float[][]) subset(allCameras_PPPSRRRF, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allCameras_PPPSRRRF, OBJ_NUM + 1);

          allCameras_PPPSRRRF = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allCameras_Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allCameras_Type, OBJ_NUM + 1);

          allCameras_Type = (int[]) concat(startList, endList);
        }

        allCameras_num -= 1;
      }

      if (OBJ_NUM == WIN3D_CurrentCamera) {

        WIN3D_CurrentCamera = 0;
        SOLARCHVISION_modify_Viewport_Title();
      }
    }
  }



  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    selectedFractal_numbers = sort(selectedFractal_numbers);

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFractal_numbers[o];

      if (OBJ_NUM != 0) {    

        for (int q = 0; q < allGroup3Ds_num + 1; q++) {

          if ((allGroup3Ds_Fractals[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroup3Ds_Fractals[q][1])) {
            if (allGroup3Ds_Fractals[q][1] > 0) allGroup3Ds_Fractals[q][1] -= 1;
          } else if (allGroup3Ds_Fractals[q][0] > OBJ_NUM) {
            if (allGroup3Ds_Fractals[q][0] > 0) allGroup3Ds_Fractals[q][0] -= 1;
            if (allGroup3Ds_Fractals[q][1] > 0) allGroup3Ds_Fractals[q][1] -= 1;
          }
        }


        {
          float[][] startList = (float[][]) subset(allFractals_XYZSR, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allFractals_XYZSR, OBJ_NUM + 1);

          allFractals_XYZSR = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractals_Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractals_Type, OBJ_NUM + 1);

          allFractals_Type = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractals_DegreeMin, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractals_DegreeMin, OBJ_NUM + 1);

          allFractals_DegreeMin = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractals_DegreeMax, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractals_DegreeMax, OBJ_NUM + 1);

          allFractals_DegreeMax = (int[]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allFractals_Seed, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allFractals_Seed, OBJ_NUM + 1);

          allFractals_Seed = (int[]) concat(startList, endList);
        }

        {
          float[] startList = (float[]) subset(allFractals_TrunkSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allFractals_TrunkSize, OBJ_NUM + 1);

          allFractals_TrunkSize = (float[]) concat(startList, endList);
        }

        {
          float[] startList = (float[]) subset(allFractals_LeafSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allFractals_LeafSize, OBJ_NUM + 1);

          allFractals_LeafSize = (float[]) concat(startList, endList);
        }

        allFractals_num -= 1;
      }
    }
  }



  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    selectedObject2D_numbers = sort(selectedObject2D_numbers);

    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedObject2D_numbers[o];

      if (OBJ_NUM != 0) {    

        for (int q = 0; q < allGroup3Ds_num + 1; q++) {

          if ((allGroup3Ds_Object2Ds[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroup3Ds_Object2Ds[q][1])) {
            if (allGroup3Ds_Object2Ds[q][1] > 0) allGroup3Ds_Object2Ds[q][1] -= 1;
          } else if (allGroup3Ds_Object2Ds[q][0] > OBJ_NUM) {
            if (allGroup3Ds_Object2Ds[q][0] > 0) allGroup3Ds_Object2Ds[q][0] -= 1;
            if (allGroup3Ds_Object2Ds[q][1] > 0) allGroup3Ds_Object2Ds[q][1] -= 1;
          }
        }


        {
          float[][] startList = (float[][]) subset(allObject2Ds_XYZS, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allObject2Ds_XYZS, OBJ_NUM + 1);

          allObject2Ds_XYZS = (float[][]) concat(startList, endList);
        }

        {
          int[] startList = (int[]) subset(allObject2Ds_MAP, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allObject2Ds_MAP, OBJ_NUM + 1);

          allObject2Ds_MAP = (int[]) concat(startList, endList);
        }   

        allObject2Ds_num -= 1;
      }
    }
  }  





  if (Current_ObjectCategory == ObjectCategory_Solids) {

    selectedSolid_numbers = sort(selectedSolid_numbers);

    for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSolid_numbers[o];

      if (OBJ_NUM != 0) {    

        for (int q = 0; q < allGroup3Ds_num + 1; q++) {

          if ((allGroup3Ds_Solids[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroup3Ds_Solids[q][1])) {
            if (allGroup3Ds_Solids[q][1] > 0) allGroup3Ds_Solids[q][1] -= 1;
          } else if (allGroup3Ds_Solids[q][0] > OBJ_NUM) {
            if (allGroup3Ds_Solids[q][0] > 0) allGroup3Ds_Solids[q][0] -= 1;
            if (allGroup3Ds_Solids[q][1] > 0) allGroup3Ds_Solids[q][1] -= 1;
          }
        }


        {
          float[][] startList = (float[][]) subset(allSolids_DEF, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSolids_DEF, OBJ_NUM + 1);

          allSolids_DEF = (float[][]) concat(startList, endList);
        }
      }
    }
  }  







  if (Current_ObjectCategory == ObjectCategory_Faces) {

    selectedFace_numbers = sort(selectedFace_numbers);

    for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFace_numbers[o];

      if (OBJ_NUM != 0) {    

        for (int q = 0; q < allGroup3Ds_num + 1; q++) {

          if ((allGroup3Ds_Faces[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroup3Ds_Faces[q][1])) {
            if (allGroup3Ds_Faces[q][1] > 0) allGroup3Ds_Faces[q][1] -= 1;
          } else if (allGroup3Ds_Faces[q][0] > OBJ_NUM) {
            if (allGroup3Ds_Faces[q][0] > 0) allGroup3Ds_Faces[q][0] -= 1;
            if (allGroup3Ds_Faces[q][1] > 0) allGroup3Ds_Faces[q][1] -= 1;
          }
        }


        {
          int[][] startList = (int[][]) subset(allFaces_PNT, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces_PNT, OBJ_NUM + 1);

          allFaces_PNT = (int[][]) concat(startList, endList);
        }

        {
          int[][] startList = (int[][]) subset(allFaces_MTLV, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces_MTLV, OBJ_NUM + 1);

          allFaces_MTLV = (int[][]) concat(startList, endList);
        }
      }
    }
  }  


  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    SOLARCHVISION_convert_Group3D_to_Vertex(); // finding vertices so that we could delete the isolated ones later  

    selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

    int Solids_updated = 0;  

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
        int endFace = allGroup3Ds_Faces[OBJ_NUM][1];

        {

          if ((0 < startFace) && (startFace <= endFace)) {

            for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
              for (int j = 0; j < 2; j++) {
                allGroup3Ds_Faces[i][j] -= 1 + endFace - startFace;

                if (allGroup3Ds_Faces[i][j] < 0) allGroup3Ds_Faces[i][j] = 0;
              }
            }
          }  

          int[][] startList = (int[][]) subset(allGroup3Ds_Faces, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroup3Ds_Faces, OBJ_NUM + 1);

          allGroup3Ds_Faces = (int[][]) concat(startList, endList);
        }  

        if ((0 < startFace) && (startFace <= endFace)) {
          {
            int[][] startList = (int[][]) subset(allFaces_PNT, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces_PNT, endFace + 1);

            allFaces_PNT = (int[][]) concat(startList, endList);
          }

          {
            int[][] startList = (int[][]) subset(allFaces_MTLV, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces_MTLV, endFace + 1);

            allFaces_MTLV = (int[][]) concat(startList, endList);
          }
        }

        int startFractal = allGroup3Ds_Fractals[OBJ_NUM][0];
        int endFractal = allGroup3Ds_Fractals[OBJ_NUM][1];

        {

          if ((0 < startFractal) && (startFractal <= endFractal)) {

            for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {

              for (int j = 0; j < 2; j++) {

                allGroup3Ds_Fractals[i][j] -= 1 + endFractal - startFractal;

                if (allGroup3Ds_Fractals[i][j] < 0) allGroup3Ds_Fractals[i][j] = 0;
              }
            }
          }   

          int[][] startList = (int[][]) subset(allGroup3Ds_Fractals, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroup3Ds_Fractals, OBJ_NUM + 1);

          allGroup3Ds_Fractals = (int[][]) concat(startList, endList);
        }  

        if ((0 < startFractal) && (startFractal <= endFractal)) {

          {
            float[][] startList = (float[][]) subset(allFractals_XYZSR, 0, startFractal);
            float[][] endList = (float[][]) subset(allFractals_XYZSR, endFractal + 1);

            allFractals_XYZSR = (float[][]) concat(startList, endList);
          }

          {
            int[] startList = (int[]) subset(allFractals_Type, 0, startFractal);
            int[] endList = (int[]) subset(allFractals_Type, endFractal + 1);

            allFractals_Type = (int[]) concat(startList, endList);
          }

          {
            int[] startList = (int[]) subset(allFractals_DegreeMin, 0, startFractal);
            int[] endList = (int[]) subset(allFractals_DegreeMin, endFractal + 1);

            allFractals_DegreeMin = (int[]) concat(startList, endList);
          }

          {
            int[] startList = (int[]) subset(allFractals_DegreeMax, 0, startFractal);
            int[] endList = (int[]) subset(allFractals_DegreeMax, endFractal + 1);

            allFractals_DegreeMax = (int[]) concat(startList, endList);
          }

          {
            int[] startList = (int[]) subset(allFractals_Seed, 0, startFractal);
            int[] endList = (int[]) subset(allFractals_Seed, endFractal + 1);

            allFractals_Seed = (int[]) concat(startList, endList);
          }

          {
            float[] startList = (float[]) subset(allFractals_TrunkSize, 0, startFractal);
            float[] endList = (float[]) subset(allFractals_TrunkSize, endFractal + 1);

            allFractals_TrunkSize = (float[]) concat(startList, endList);
          }

          {
            float[] startList = (float[]) subset(allFractals_LeafSize, 0, startFractal);
            float[] endList = (float[]) subset(allFractals_LeafSize, endFractal + 1);

            allFractals_LeafSize = (float[]) concat(startList, endList);
          }


          allFractals_num = allFractals_XYZSR.length - 1;
        }

        int startObject2D = allGroup3Ds_Object2Ds[OBJ_NUM][0];
        int endObject2D = allGroup3Ds_Object2Ds[OBJ_NUM][1];

        {

          if ((0 < startObject2D) && (startObject2D <= endObject2D)) {

            for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {

              for (int j = 0; j < 2; j++) {

                allGroup3Ds_Object2Ds[i][j] -= 1 + endObject2D - startObject2D;

                if (allGroup3Ds_Object2Ds[i][j] < 0) allGroup3Ds_Object2Ds[i][j] = 0;
              }
            }
          }   

          int[][] startList = (int[][]) subset(allGroup3Ds_Object2Ds, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroup3Ds_Object2Ds, OBJ_NUM + 1);

          allGroup3Ds_Object2Ds = (int[][]) concat(startList, endList);
        }  

        if ((0 < startObject2D) && (startObject2D <= endObject2D)) {

          {
            float[][] startList = (float[][]) subset(allObject2Ds_XYZS, 0, startObject2D);
            float[][] endList = (float[][]) subset(allObject2Ds_XYZS, endObject2D + 1);

            allObject2Ds_XYZS = (float[][]) concat(startList, endList);
          }

          {
            int[] startList = (int[]) subset(allObject2Ds_MAP, 0, startObject2D);
            int[] endList = (int[]) subset(allObject2Ds_MAP, endObject2D + 1);

            allObject2Ds_MAP = (int[]) concat(startList, endList);
          }

          allObject2Ds_num = allObject2Ds_XYZS.length - 1;
        }


        int startSolid = allGroup3Ds_Solids[OBJ_NUM][0];
        int endSolid = allGroup3Ds_Solids[OBJ_NUM][1];

        {
          if ((0 < startSolid) && (startSolid <= endSolid)) {
            for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {

              for (int j = 0; j < 2; j++) {
                allGroup3Ds_Solids[i][j] -= 1 + endSolid - startSolid;

                if (allGroup3Ds_Solids[i][j] < 0) allGroup3Ds_Solids[i][j] = 0;
              }
            }
          }  

          int[][] startList = (int[][]) subset(allGroup3Ds_Solids, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroup3Ds_Solids, OBJ_NUM + 1);

          allGroup3Ds_Solids = (int[][]) concat(startList, endList);
        }  

        if ((0 < startSolid) && (startSolid <= endSolid)) {

          float[][] startList = (float[][]) subset(allSolids_DEF, 0, startSolid);
          float[][] endList = (float[][]) subset(allSolids_DEF, endSolid + 1);

          allSolids_DEF = (float[][]) concat(startList, endList);

          Solids_updated = 1;
        }


        {
          float[][] startList = (float[][]) subset(allGroup3Ds_PivotXYZ, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allGroup3Ds_PivotXYZ, OBJ_NUM + 1);

          allGroup3Ds_PivotXYZ = (float[][]) concat(startList, endList);
        } 

        {
          int[][] startList = (int[][]) subset(allGroup3Ds_PivotType, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroup3Ds_PivotType, OBJ_NUM + 1);

          allGroup3Ds_PivotType = (int[][]) concat(startList, endList);
        } 

        allGroup3Ds_num -= 1;
      }
    }

    if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();

    WIN3D_VerticesSolarValue_Update = 1;
  }





  if ((Current_ObjectCategory == ObjectCategory_Vertices) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Group3Ds)) { 

    println("deleteIsolatedVerticesSelection");

    SOLARCHVISION_deleteIsolatedVertices_Selection();
  }  



  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_deleteIsolatedVertices_Selection () { 

  selectedVertex_numbers = sort(selectedVertex_numbers);

  for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) { 

    int vNo = selectedVertex_numbers[o];

    if (vNo != 0) {

      int found = -1;

      for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
        for (int j = 0; j < allFaces_PNT[i].length; j++) {
          if (allFaces_PNT[i][j] == vNo) {

            found = 1;
          }

          if (found != -1) break;
        }

        if (found != -1) break;
      }  

      if (found == -1) {

        for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
          for (int j = 0; j < allFaces_PNT[i].length; j++) {
            if (allFaces_PNT[i][j] > vNo) {

              allFaces_PNT[i][j] -= 1;
            }
          }
        }             

        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);

        allVertices = (float[][]) concat(startList, endList);
      }
    }
  } 

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;
}


void SOLARCHVISION_deleteIsolatedVertices_Scene () {

  for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null

    int found = -1;

    for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
      for (int j = 0; j < allFaces_PNT[i].length; j++) {
        if (allFaces_PNT[i][j] == vNo) {
          found = 1;
        }
      }
    }

    if (found == -1) {
      {
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);

        allVertices = (float[][]) concat(startList, endList);
      }

      for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
        for (int j = 0; j < allFaces_PNT[i].length; j++) {
          if (allFaces_PNT[i][j] > vNo) {

            allFaces_PNT[i][j] -= 1;
          }
        }
      }
    }


    WIN3D_VerticesSolarValue_Update = 1;
  } 

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;
}


void SOLARCHVISION_selectIsolatedVertices_Scene () {

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0;  

  for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null

    int found = -1;

    for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
      for (int j = 0; j < allFaces_PNT[i].length; j++) {
        if (allFaces_PNT[i][j] == vNo) {
          found = 1;
        }
      }
    }

    if (found == -1) {

      int[] newIsolatedVertex = {
        vNo
      };

      selectedVertex_numbers = concat(selectedVertex_numbers, newIsolatedVertex);


      WIN3D_VerticesSolarValue_Update = 1;
    }
  } 

  Current_ObjectCategory = ObjectCategory_Vertices; 
  SOLARCHVISION_UI_BAR_b_Update = 1;

  println("SOLARCHVISION_calculate_selection_BoundingBox 31");
  SOLARCHVISION_calculate_selection_BoundingBox();
}



void SOLARCHVISION_selectNearVertices_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Vertex();
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      SOLARCHVISION_convert_Face_to_Vertex();
    }

    selectedVertex_numbers = sort(selectedVertex_numbers);

    int[] pre_selectedVertex_numbers = selectedVertex_numbers;

    for (int vNo = allVertices.length - 1; vNo > 0; vNo--) { // the first node is null 

      int isNearEnough = -1;

      for (int i = 0; i < pre_selectedVertex_numbers.length; i++) {

        int q = pre_selectedVertex_numbers[i];

        if (q != 0) {

          int found = -1;

          for (int j = 0; j < selectedVertex_numbers.length; j++) {

            if (vNo == selectedVertex_numbers[j]) {

              found = 1;

              break;
            }
          } 

          if (found == -1) { 

            float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);

            if (d <= ModifyInput_WeldTreshold) { 

              isNearEnough = 1;

              break;
            }
          }
        }
      }

      if (isNearEnough == 1) {

        int[] newVertex_number = {
          vNo
        };

        selectedVertex_numbers = concat(selectedVertex_numbers, newVertex_number);
      }
    } 

    println("SOLARCHVISION_calculate_selection_BoundingBox 32");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_weldSceneVertices_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Vertex();
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      SOLARCHVISION_convert_Face_to_Vertex();
    }

    selectedVertex_numbers = sort(selectedVertex_numbers);

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        int found = -1;

        for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
          for (int j = 0; j < allFaces_PNT[i].length; j++) {

            int q = allFaces_PNT[i][j];

            if (q > vNo) { // it is faster than (q != vNo)

              float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);

              if (d <= ModifyInput_WeldTreshold) { 

                allFaces_PNT[i][j] = vNo;

                found = q;
              }
            }
          }
        }

        if (found != -1) {

          int q = found;

          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);

            allVertices = (float[][]) concat(startList, endList);
          }

          for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
            for (int j = 0; j < allFaces_PNT[i].length; j++) {
              if (allFaces_PNT[i][j] > q) {

                allFaces_PNT[i][j] -= 1;
              }
            }
          }
        }
      }
    } 

    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  

    println("SOLARCHVISION_calculate_selection_BoundingBox 33");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_weldObjectsVertices_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Vertex();
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      SOLARCHVISION_convert_Face_to_Vertex();
    }

    SOLARCHVISION_convert_Vertex_to_Face();

    selectedVertex_numbers = sort(selectedVertex_numbers);

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {  

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        int found = -1;

        for (int m = o - 1; m >= 0; m--) {

          int q = selectedVertex_numbers[m];

          if (q != 0) {

            float d = dist(allVertices[q][0], allVertices[q][1], allVertices[q][2], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);

            if (d <= ModifyInput_WeldTreshold) { 

              for (int i = 0; i < selectedFace_numbers.length; i++) {
                int f = selectedFace_numbers[i];

                if (f != 0) {

                  for (int j = 0; j < allFaces_PNT[f].length; j++) {
                    if (allFaces_PNT[f][j] == q) {

                      allFaces_PNT[f][j] = vNo;

                      found = q;
                    }
                  }
                }
              }
            }
          }
        }

        if (found != -1) {

          int q = found;

          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);

            allVertices = (float[][]) concat(startList, endList);
          }

          for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
            for (int j = 0; j < allFaces_PNT[i].length; j++) {
              if (allFaces_PNT[i][j] > q) {

                allFaces_PNT[i][j] -= 1;
              }
            }
          }
        }
      }
    } 

    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  

    println("SOLARCHVISION_calculate_selection_BoundingBox 34");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_repositionVertices_Selection () {

  if (Current_ObjectCategory == ObjectCategory_Vertices) { 

    SOLARCHVISION_calculate_selection_BoundingBox();

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) { 

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        allVertices[vNo][0] = SOLARCHVISION_selection_BoundingBox[1][0]; // center
        allVertices[vNo][1] = SOLARCHVISION_selection_BoundingBox[1][1]; // center
        allVertices[vNo][2] = SOLARCHVISION_selection_BoundingBox[1][2]; // center
      }
    } 

    println("SOLARCHVISION_calculate_selection_BoundingBox 35");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_separateVertices_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Vertex();
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      SOLARCHVISION_convert_Face_to_Vertex();
    }

    selectedVertex_numbers = sort(selectedVertex_numbers);

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) { 

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        for (int i = 1; i < allFaces_PNT.length; i++) { // the first node is null
          for (int j = 0; j < allFaces_PNT[i].length; j++) {

            if (allFaces_PNT[i][j] == vNo) { 

              allFaces_PNT[i][j] = SOLARCHVISION_add_Vertex(allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);
            }
          }
        }
      }
    } 

    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  

    println("SOLARCHVISION_calculate_selection_BoundingBox 36");
    SOLARCHVISION_calculate_selection_BoundingBox();
  }
}



void SOLARCHVISION_inserCornerOpennings_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) { 

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += allFaces_PNT[f].length;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += allFaces_PNT[f].length; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) {

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += allFaces_PNT[f].length;
                  }
                }
              }              


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = (int[][]) subset(allFaces_PNT, f, 1);
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }

                float[][] new_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {

                    new_Vertices[i][j] = pow(ModifyInput_OpenningArea, 0.5) * base_Vertices[i][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                  }
                }

                int[] new_Vertex_numbers = new int [allFaces_PNT[f].length];

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  new_Vertex_numbers[s] = SOLARCHVISION_add_Vertex(new_Vertices[s][0], new_Vertices[s][1], new_Vertices[s][2]);
                } 

                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];              

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  int[][] newFace = {
                    {
                      new_Vertex_numbers[s], allFaces_PNT[f][s], allFaces_PNT[f][s_next], new_Vertex_numbers[s_next]
                    }
                  };
                  int[][] newFace_MTLV = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                    }
                  }; 

                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                }


                { // modifying the base face to shape the openning  
                  for (int s = 0; s < allFaces_PNT[f].length; s++) {
                    allFaces_PNT[f][s] = new_Vertex_numbers[s];
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }



    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 37");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}


void SOLARCHVISION_insertParallelOpennings_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) {

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += 2 * allFaces_PNT[f].length;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += 2 * allFaces_PNT[f].length; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) { 

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += 2 * allFaces_PNT[f].length;
                  }
                }
              }              


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = (int[][]) subset(allFaces_PNT, f, 1);
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }


                float[][] new_A_EdgeVertices = new float [allFaces_PNT[f].length][3];
                float[][] new_B_EdgeVertices = new float [allFaces_PNT[f].length][3];
                float[][] new_CenterVertices = new float [allFaces_PNT[f].length][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  int s_prev = (s + allFaces_PNT[f].length - 1) % allFaces_PNT[f].length;
                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  for (int j = 0; j < 3; j++) {

                    new_A_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * 0.5 * (base_Vertices[s_prev][j] + base_Vertices[s][j]);
                    new_B_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * 0.5 * (base_Vertices[s_next][j] + base_Vertices[s][j]);

                    new_CenterVertices[s][j] = pow(ModifyInput_OpenningArea, 0.5) * base_Vertices[s][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                  }
                }

                int[] new_A_EdgeVertex_numbers = new int [allFaces_PNT[f].length]; // on the edge (1/3)
                int[] new_B_EdgeVertex_numbers = new int [allFaces_PNT[f].length]; // on the other edge (2/3)
                int[] new_CenterVertex_numbers = new int [allFaces_PNT[f].length]; // in the center

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  new_A_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_A_EdgeVertices[s][0], new_A_EdgeVertices[s][1], new_A_EdgeVertices[s][2]); 
                  new_B_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_B_EdgeVertices[s][0], new_B_EdgeVertices[s][1], new_B_EdgeVertices[s][2]);
                  new_CenterVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
                }               



                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  {
                    int[][] newFace = {
                      {
                        allFaces_PNT[f][s], new_B_EdgeVertex_numbers[s], new_CenterVertex_numbers[s], new_A_EdgeVertex_numbers[s]
                      }
                    };
                    int[][] newFace_MTLV = {
                      {
                        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                      }
                    }; 

                    midList_Faces = (int[][]) concat(midList_Faces, newFace);
                    midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                  }   

                  {
                    int[][] newFace = {
                      {
                        new_B_EdgeVertex_numbers[s], new_A_EdgeVertex_numbers[s_next], new_CenterVertex_numbers[s_next], new_CenterVertex_numbers[s]
                      }
                    };
                    int[][] newFace_MTLV = {
                      {
                        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                      }
                    }; 

                    midList_Faces = (int[][]) concat(midList_Faces, newFace);
                    midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                  }
                }


                { // modifying the base face to shape the openning  
                  for (int s = 0; s < allFaces_PNT[f].length; s++) {
                    allFaces_PNT[f][s] = new_CenterVertex_numbers[s];
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }


    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 38");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}



void SOLARCHVISION_insertRotatedOpennings_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) {

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += allFaces_PNT[f].length;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += allFaces_PNT[f].length; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) {

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += allFaces_PNT[f].length;
                  }
                }
              }              


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = (int[][]) subset(allFaces_PNT, f, 1);
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }

                float[][] new_EdgeVertices = new float [allFaces_PNT[f].length][3];
                float[][] new_CenterVertices = new float [allFaces_PNT[f].length][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  int s_prev = (s + allFaces_PNT[f].length - 1) % allFaces_PNT[f].length;

                  for (int j = 0; j < 3; j++) {

                    new_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * base_Vertices[s_prev][j];

                    new_CenterVertices[s][j] = pow(ModifyInput_OpenningArea, 0.5) * new_EdgeVertices[s][j] + (1 - pow(ModifyInput_OpenningArea, 0.5)) * G_face[j];
                  }
                }

                int[] new_EdgeVertex_numbers = new int [allFaces_PNT[f].length]; // on the edge
                int[] new_CenterVertex_numbers = new int [allFaces_PNT[f].length]; // in the center

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  new_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
                  new_CenterVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
                } 



                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  int[][] newFace = {
                    {
                      new_EdgeVertex_numbers[s], allFaces_PNT[f][s], new_EdgeVertex_numbers[s_next], new_CenterVertex_numbers[s_next], new_CenterVertex_numbers[s]
                    }
                  };
                  int[][] newFace_MTLV = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                    }
                  }; 

                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                }


                { // modifying the base face to match new center face
                  for (int s = 0; s < allFaces_PNT[f].length; s++) {
                    allFaces_PNT[f][s] = new_CenterVertex_numbers[s];
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }



    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 39");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}


void SOLARCHVISION_insertEdgeOpennings_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) { 

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += allFaces_PNT[f].length;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += allFaces_PNT[f].length; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) {

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += allFaces_PNT[f].length;
                  }
                }
              }              


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = (int[][]) subset(allFaces_PNT, f, 1);
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f, 1);
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }

                float[][] new_EdgeVertices = new float [allFaces_PNT[f].length][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  int s_prev = (s + allFaces_PNT[f].length - 1) % allFaces_PNT[f].length;

                  for (int j = 0; j < 3; j++) {

                    new_EdgeVertices[s][j] = ModifyInput_OpenningDeviation * base_Vertices[s][j] + (1 - ModifyInput_OpenningDeviation) * base_Vertices[s_prev][j];
                  }
                }

                int[] new_EdgeVertex_numbers = new int [allFaces_PNT[f].length]; // on the edge

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  new_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                } 



                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  int[][] newFace = {
                    {
                      new_EdgeVertex_numbers[s], allFaces_PNT[f][s], new_EdgeVertex_numbers[s_next]
                    }
                  };
                  int[][] newFace_MTLV = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                    }
                  }; 

                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV);
                }


                { // modifying the base face to match new center face
                  for (int s = 0; s < allFaces_PNT[f].length; s++) {
                    allFaces_PNT[f][s] = new_EdgeVertex_numbers[s];
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }



    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 40");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}


void SOLARCHVISION_tessellateRowsColumnsFaceSelection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) { 

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              if (allFaces_PNT[f].length == 4) {

                for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                  for (int j = 0; j < 2; j++) {
                    allGroup3Ds_Faces[i][j] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1;
                  }
                }  
                allGroup3Ds_Faces[OBJ_NUM][1] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1; // because adding the faces also changes the end pointer of the same object 

                for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                  if (new_selectedFace_numbers[p] != 0) {

                    if (new_selectedFace_numbers[p] > f) {  
                      new_selectedFace_numbers[p] += ModifyInput_TessellateColumns * ModifyInput_TessellateRows - 1;
                    }
                  }
                }             


                int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
                int[][] midList_Faces = new int [0][0];
                int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


                int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
                int[][] midList_Faces_MTLV = new int [0][0];
                int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

                { 
                  float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                  for (int i = 0; i < allFaces_PNT[f].length; i++) {
                    for (int j = 0; j < 3; j++) {
                      base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                    }
                  }



                  float[][] new_EdgeVertices = new float [(ModifyInput_TessellateColumns + 1) * (ModifyInput_TessellateRows + 1)][3];

                  for (int i = 0; i <= ModifyInput_TessellateColumns; i++) {

                    for (int j = 0; j <= ModifyInput_TessellateRows; j++) {

                      int s = i * (ModifyInput_TessellateRows + 1) + j;

                      for (int k = 0; k < 3; k++) {

                        float u = i / float(ModifyInput_TessellateColumns);
                        float v = j / float(ModifyInput_TessellateRows);

                        new_EdgeVertices[s][k] = SOLARCHVISION_Bilinear(base_Vertices[0][k], base_Vertices[1][k], base_Vertices[2][k], base_Vertices[3][k], u, v);
                      }
                    }
                  }

                  int[] new_EdgeVertex_numbers = new int [(ModifyInput_TessellateColumns + 1) * (ModifyInput_TessellateRows + 1)]; // on the edge

                  for (int i = 0; i <= ModifyInput_TessellateColumns; i++) {

                    for (int j = 0; j <= ModifyInput_TessellateRows; j++) {

                      int s = i * (ModifyInput_TessellateRows + 1) + j;

                      if ((i == 0) && (j == 0)) {
                        new_EdgeVertex_numbers[s] = allFaces_PNT[f][0];
                      } else if ((i == ModifyInput_TessellateColumns) && (j == 0)) {
                        new_EdgeVertex_numbers[s] = allFaces_PNT[f][1];
                      } else if ((i == ModifyInput_TessellateColumns) && (j == ModifyInput_TessellateRows)) {
                        new_EdgeVertex_numbers[s] = allFaces_PNT[f][2];
                      } else if ((i == 0) && (j == ModifyInput_TessellateRows)) {
                        new_EdgeVertex_numbers[s] = allFaces_PNT[f][3];
                      } else {
                        new_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                      }
                    }
                  }


                  defaultMaterial = allFaces_MTLV[f][0];
                  defaultTessellation = allFaces_MTLV[f][1];
                  defaultLayer = allFaces_MTLV[f][2];
                  defaultVisibility = allFaces_MTLV[f][3];

                  for (int i = 0; i < ModifyInput_TessellateColumns; i++) {

                    for (int j = 0; j < ModifyInput_TessellateRows; j++) {

                      int s = i * ModifyInput_TessellateRows + j;  // number of face

                      // number of vertices
                      int s00 = i * (ModifyInput_TessellateRows + 1) + j; 
                      int s01 = s00 + 1;
                      int s10 = s00 + (ModifyInput_TessellateRows + 1);
                      int s11 = s00 + (ModifyInput_TessellateRows + 1) + 1;

                      int[][] newFace = {
                        {
                          new_EdgeVertex_numbers[s00], new_EdgeVertex_numbers[s10], new_EdgeVertex_numbers[s11], new_EdgeVertex_numbers[s01]
                        }
                      };
                      int[][] newFace_MTLV = {
                        {
                          defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                        }
                      }; 

                      midList_Faces = (int[][]) concat(midList_Faces, newFace);
                      midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 

                      if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                        int[] newFace_number = {
                          f + s
                        }; 
                        new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);
                      }
                    }
                  }
                }

                startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
                startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

                allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
                allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

                { // to avoid processing the faces twice they should be deleted from the list.
                  for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                    selectedFace_numbers[i] -= 1;
                  }              

                  int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                  int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                  selectedFace_numbers = (int[]) concat(startList, endList);
                }
              }
            }
          }
        }
      }
    }

    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 41");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}



void SOLARCHVISION_tessellateRectangularFaceSelection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) { 

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += allFaces_PNT[f].length - 1;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += allFaces_PNT[f].length - 1; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) {

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += allFaces_PNT[f].length - 1;
                  }
                }
              }             


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = new int [0][0];
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = new int [0][0];
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }

                float[][] new_EdgeVertices = new float [allFaces_PNT[f].length][3];

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  int s_prev = (s + allFaces_PNT[f].length - 1) % allFaces_PNT[f].length;

                  for (int j = 0; j < 3; j++) {
                    new_EdgeVertices[s][j] = 0.5 * base_Vertices[s][j] + 0.5 * base_Vertices[s_prev][j];
                  }
                }

                int[] new_EdgeVertex_numbers = new int [allFaces_PNT[f].length]; // on the edge

                for (int s = 0; s < allFaces_PNT[f].length; s++) {

                  new_EdgeVertex_numbers[s] = SOLARCHVISION_add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                } 

                int new_CenterVertex_number = 0; // at the center
                new_CenterVertex_number = SOLARCHVISION_add_Vertex(G_face[0], G_face[1], G_face[2]); 


                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];              

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  int[][] newFace = {
                    {
                      new_EdgeVertex_numbers[s], allFaces_PNT[f][s], new_EdgeVertex_numbers[s_next], new_CenterVertex_number
                    }
                  };
                  int[][] newFace_MTLV = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                    }
                  }; 

                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 

                  if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                    int[] newFace_number = {
                      f + s
                    }; 
                    new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }

    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 42");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}



void SOLARCHVISION_tessellateTriangularFaceSelection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = selectedFace_numbers;

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) {

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              for (int i = OBJ_NUM + 1; i < allGroup3Ds_num + 1; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroup3Ds_Faces[i][j] += allFaces_PNT[f].length - 1;
                }
              }  
              allGroup3Ds_Faces[OBJ_NUM][1] += allFaces_PNT[f].length - 1; // because adding the faces also changes the end pointer of the same object 

              for (int p = new_selectedFace_numbers.length - 1; p >= 0; p--) {

                if (new_selectedFace_numbers[p] != 0) {

                  if (new_selectedFace_numbers[p] > f) {  
                    new_selectedFace_numbers[p] += allFaces_PNT[f].length - 1;
                  }
                }
              }             


              int[][] startList_Faces = (int[][]) subset(allFaces_PNT, 0, f);
              int[][] midList_Faces = new int [0][0];
              int[][] endList_Faces = (int[][]) subset(allFaces_PNT, f + 1);


              int[][] startList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, 0, f);
              int[][] midList_Faces_MTLV = new int [0][0];
              int[][] endList_Faces_MTLV = (int[][]) subset(allFaces_MTLV, f + 1);

              { 
                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    base_Vertices[i][j] = allVertices[(allFaces_PNT[f][i])][j];
                  }
                }

                float[] G_face = {
                  0, 0, 0
                };  

                for (int i = 0; i < allFaces_PNT[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces_PNT[f].length);
                  }
                }


                int new_CenterVertex_number = 0; // at the center
                new_CenterVertex_number = SOLARCHVISION_add_Vertex(G_face[0], G_face[1], G_face[2]); 


                defaultMaterial = allFaces_MTLV[f][0];
                defaultTessellation = allFaces_MTLV[f][1];
                defaultLayer = allFaces_MTLV[f][2];
                defaultVisibility = allFaces_MTLV[f][3];                

                for (int s = 0; s < allFaces_PNT[f].length; s++) { 

                  int s_next = (s + 1) % allFaces_PNT[f].length;

                  int[][] newFace = {
                    {
                      allFaces_PNT[f][s], allFaces_PNT[f][s_next], new_CenterVertex_number
                    }
                  };
                  int[][] newFace_MTLV = {
                    {
                      defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
                    }
                  }; 

                  midList_Faces = (int[][]) concat(midList_Faces, newFace);
                  midList_Faces_MTLV = (int[][]) concat(midList_Faces_MTLV, newFace_MTLV); 

                  if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                    int[] newFace_number = {
                      f + s
                    }; 
                    new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, newFace_number);
                  }
                }
              }

              startList_Faces = (int[][]) concat(startList_Faces, midList_Faces);
              startList_Faces_MTLV = (int[][]) concat(startList_Faces_MTLV, midList_Faces_MTLV);  

              allFaces_PNT = (int[][]) concat(startList_Faces, endList_Faces);
              allFaces_MTLV = (int[][]) concat(startList_Faces_MTLV, endList_Faces_MTLV);                      

              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < selectedFace_numbers.length; i++) {
                  selectedFace_numbers[i] -= 1;
                }              

                int[] startList = (int[]) subset(selectedFace_numbers, 0, q);
                int[] endList = (int[]) subset(selectedFace_numbers, q + 1);

                selectedFace_numbers = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
    }

    selectedFace_numbers = new_selectedFace_numbers;

    Current_ObjectCategory = ObjectCategory_Faces; 
    SOLARCHVISION_UI_BAR_b_Update = 1;

    println("SOLARCHVISION_calculate_selection_BoundingBox 43");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}

void SOLARCHVISION_extrudeFaceEdges_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);

      SOLARCHVISION_convert_Group3D_to_Face();    

      selectedFace_numbers = sort(selectedFace_numbers);
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      selectedFace_numbers = sort(selectedFace_numbers);

      SOLARCHVISION_convert_Face_to_Group3D();    

      selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    }

    int[] new_selectedFace_numbers = {
      0
    };

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) { 

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {

        SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

        for (int q = selectedFace_numbers.length - 1; q >= 0; q--) { 

          int f = selectedFace_numbers[q];

          if (f != 0) {

            int startFace = allGroup3Ds_Faces[OBJ_NUM][0];
            int endFace = allGroup3Ds_Faces[OBJ_NUM][1];          

            if ((startFace <= f) && (f <= endFace)) {

              float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
              float[][] top_Vertices = new float [allFaces_PNT[f].length][3];

              for (int s = 0; s < allFaces_PNT[f].length; s++) {
                int vNo = allFaces_PNT[f][s];

                base_Vertices[s][0] = allVertices[vNo][0];
                base_Vertices[s][1] = allVertices[vNo][1];
                base_Vertices[s][2] = allVertices[vNo][2];

                top_Vertices[s][0] = allVertices[vNo][0];
                top_Vertices[s][1] = allVertices[vNo][1];
                top_Vertices[s][2] = allVertices[vNo][2];
              }

              for (int s = 0; s < allFaces_PNT[f].length; s++) {

                int s_next = (s + 1) % allFaces_PNT[f].length;
                int s_prev = (s + allFaces_PNT[f].length - 1) % allFaces_PNT[f].length;

                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
                PVector UV = U.cross(V);
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = SOLARCHVISION_fn_normalize(W);

                top_Vertices[s][0] += W[0] * ModifyInput_OpenningDepth;
                top_Vertices[s][1] += W[1] * ModifyInput_OpenningDepth;
                top_Vertices[s][2] += W[2] * ModifyInput_OpenningDepth;
              }  

              int[] base_Vertex_numbers = new int [allFaces_PNT[f].length];
              int[] top_Vertex_numbers = new int [allFaces_PNT[f].length];

              for (int s = 0; s < allFaces_PNT[f].length; s++) {

                base_Vertex_numbers[s] = SOLARCHVISION_add_Vertex(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
                top_Vertex_numbers[s] = SOLARCHVISION_add_Vertex(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
              }        

              for (int s = 0; s < allFaces_PNT[f].length; s++) {

                int s_next = (s + 1) % allFaces_PNT[f].length;

                if (ModifyInput_OpenningDepth < 0) { // reverse direction for negative extrude heights
                  int[][] newFace = {
                    {
                      base_Vertex_numbers[s], top_Vertex_numbers[s], top_Vertex_numbers[s_next], base_Vertex_numbers[s_next]
                    }
                  };  
                  allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
                } else {
                  int[][] newFace = {
                    {
                      base_Vertex_numbers[s], base_Vertex_numbers[s_next], top_Vertex_numbers[s_next], top_Vertex_numbers[s]
                    }
                  };  
                  allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
                }       

                int[][] newFace_MTLV = {
                  {
                    allFaces_MTLV[f][0], allFaces_MTLV[f][1], allFaces_MTLV[f][2], allFaces_MTLV[f][3]
                  }
                }; 
                allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);
              }  

              { // adding the cap
                int[][] newFace = {
                  top_Vertex_numbers
                };  
                allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);         

                int[][] newFace_MTLV = {
                  {
                    allFaces_MTLV[f][0], allFaces_MTLV[f][1], allFaces_MTLV[f][2], allFaces_MTLV[f][3]
                  }
                }; 
                allFaces_MTLV =  (int[][]) concat(allFaces_MTLV, newFace_MTLV);  

                int[] lastFace = {
                  allFaces_PNT.length - 1
                };

                new_selectedFace_numbers = (int[]) concat(new_selectedFace_numbers, lastFace);
              }

              allGroup3Ds_Faces[allGroup3Ds_num][1] = allFaces_PNT.length - 1;
            }
          }
        }
      }
    }

    selectedFace_numbers = new_selectedFace_numbers;

    println("SOLARCHVISION_calculate_selection_BoundingBox 101");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}



void SOLARCHVISION_offsetVertices_Selection (int _type, float _amount) {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Vertex();
    }

    if (Current_ObjectCategory == ObjectCategory_Faces) { 

      SOLARCHVISION_convert_Face_to_Vertex();
    }

    float[][] selectedVertex_offsetValues = new float [selectedVertex_numbers.length][3];
    int[] selectedVertex_offsetNum = new int [selectedVertex_numbers.length];

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) { 
      selectedVertex_offsetValues[o][0] = 0;
      selectedVertex_offsetValues[o][1] = 0;
      selectedVertex_offsetValues[o][2] = 0;

      selectedVertex_offsetNum[o] = 0;
    }

    selectedVertex_numbers = sort(selectedVertex_numbers);

    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        for (int f = 1; f < allFaces_PNT.length; f++) { // the first node is null
          for (int j = 0; j < allFaces_PNT[f].length; j++) {

            if (allFaces_PNT[f][j] == vNo) { 

              float[][] base_Vertices = new float [allFaces_PNT[f].length][3];

              for (int s = 0; s < allFaces_PNT[f].length; s++) {

                base_Vertices[s][0] = allVertices[allFaces_PNT[f][s]][0];
                base_Vertices[s][1] = allVertices[allFaces_PNT[f][s]][1];
                base_Vertices[s][2] = allVertices[allFaces_PNT[f][s]][2];
              }

              for (int s = 0; s < base_Vertices.length; s++) {

                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;

                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
                PVector UV = new PVector(0, 0, 0);

                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);

                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = SOLARCHVISION_fn_normalize(W);

                selectedVertex_offsetValues[o][0] += W[0] * _amount;
                selectedVertex_offsetValues[o][1] += W[1] * _amount;
                selectedVertex_offsetValues[o][2] += W[2] * _amount;

                selectedVertex_offsetNum[o] += 1;
              }
            }
          }
        }
      }

      if (selectedVertex_offsetNum[o] != 0) {
        selectedVertex_offsetValues[o][0] /= float(selectedVertex_offsetNum[o]);
        selectedVertex_offsetValues[o][1] /= float(selectedVertex_offsetNum[o]);
        selectedVertex_offsetValues[o][2] /= float(selectedVertex_offsetNum[o]);
      }
    } 


    for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {

      int vNo = selectedVertex_numbers[o];

      if (vNo != 0) {

        allVertices[vNo][0] += selectedVertex_offsetValues[o][0];
        allVertices[vNo][1] += selectedVertex_offsetValues[o][1];
        allVertices[vNo][2] += selectedVertex_offsetValues[o][2];
      }
    } 

    println("SOLARCHVISION_calculate_selection_BoundingBox 102");
    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_VerticesSolarValue_Update = 1;
  }
}





void SOLARCHVISION_changeVisibilityFaces_Selection (int new_vsb) {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

      SOLARCHVISION_convert_Group3D_to_Face();
    }

    if (Current_ObjectCategory == ObjectCategory_Vertices) { 

      SOLARCHVISION_convert_Vertex_to_Face();
    }

    for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

      int f = selectedFace_numbers[o];

      if (f != 0) {
        allFaces_MTLV[f][3] = new_vsb;
      }
    }
  }
}


void SOLARCHVISION_changeVisibilityFaces_Scene (int new_vsb) {

  for (int f = allFaces_PNT.length - 1; f > 0; f--) { // the first node is null
    allFaces_MTLV[f][3] = new_vsb;
  }
}


void SOLARCHVISION_reverseVisibilityFaces_Scene () {

  for (int f = allFaces_PNT.length - 1; f > 0; f--) { // the first node is null

    int vsb = allFaces_MTLV[f][3];
    int new_vsb = vsb;

    if (vsb == 0) new_vsb = 1;
    else if (vsb == 1) new_vsb = 0;

    allFaces_MTLV[f][3] = new_vsb;
  }
}


void SOLARCHVISION_isolate_Selection () {

  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices)) { 

    SOLARCHVISION_changeVisibilityFaces_Scene(0);
    SOLARCHVISION_changeVisibilityFaces_Selection(1);
  }
}






void SOLARCHVISION_deselect_All () {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
    selectedLandPoint_numbers = new int [1];
    selectedLandPoint_numbers[0] = 0;
  }  

  if (Current_ObjectCategory == ObjectCategory_Sections) {  
    selectedSection_numbers = new int [1];
    selectedSection_numbers[0] = 0;
  }  

  if (Current_ObjectCategory == ObjectCategory_Cameras) {  
    selectedCamera_numbers = new int [1];
    selectedCamera_numbers[0] = 0;
  }  



  if ((Current_ObjectCategory == ObjectCategory_Fractals) || (Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Object2Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices) || (Current_ObjectCategory == ObjectCategory_SoftVerts) || (Current_ObjectCategory == ObjectCategory_Solids)) {  

    selectedFractal_numbers = new int [1];
    selectedFractal_numbers[0] = 0;    

    selectedGroup3D_numbers = new int [1];
    selectedGroup3D_numbers[0] = 0;

    selectedObject2D_numbers = new int [1];
    selectedObject2D_numbers[0] = 0;

    selectedFace_numbers = new int [1];
    selectedFace_numbers[0] = 0;

    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;  

    selectedSolid_numbers = new int [1];
    selectedSolid_numbers[0] = 0;
  }  

  println("SOLARCHVISION_calculate_selection_BoundingBox 0");
  SOLARCHVISION_calculate_selection_BoundingBox();
}

void SOLARCHVISION_select_All () {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
    selectedLandPoint_numbers = new int [1 + LAND_n_I * LAND_n_J];
    for (int i = 0; i < selectedLandPoint_numbers.length; i++) { 
      selectedLandPoint_numbers[i] = i;
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Fractals) {
    selectedFractal_numbers = new int [allFractals_num + 1];
    for (int i = 0; i < selectedFractal_numbers.length; i++) { 
      selectedFractal_numbers[i] = i;
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
    selectedObject2D_numbers = new int [allObject2Ds_num + 1];
    for (int i = 0; i < selectedObject2D_numbers.length; i++) { 
      selectedObject2D_numbers[i] = i;
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
    selectedGroup3D_numbers = new int [allGroup3Ds_num + 1];
    for (int i = 0; i < selectedGroup3D_numbers.length; i++) { 
      selectedGroup3D_numbers[i] = i;
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Faces) {
    selectedFace_numbers = new int [allFaces_PNT.length];
    for (int i = 0; i < selectedFace_numbers.length; i++) { 
      selectedFace_numbers[i] = i;
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Vertices) {
    selectedVertex_numbers = new int [allVertices.length];
    for (int i = 0; i < selectedVertex_numbers.length; i++) { 
      selectedVertex_numbers[i] = i;
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Solids) {
    selectedSolid_numbers = new int [allSolids_DEF.length];
    for (int i = 0; i < selectedSolid_numbers.length; i++) { 
      selectedSolid_numbers[i] = i;
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Sections) {
    selectedSection_numbers = new int [allSections_num + 1];
    for (int i = 0; i < selectedSection_numbers.length; i++) { 
      selectedSection_numbers[i] = i;
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Cameras) {
    selectedCamera_numbers = new int [allCameras_num + 1];
    for (int i = 0; i < selectedCamera_numbers.length; i++) { 
      selectedCamera_numbers[i] = i;
    }
  }  

  println("SOLARCHVISION_calculate_selection_BoundingBox 44");
  SOLARCHVISION_calculate_selection_BoundingBox();
}


void SOLARCHVISION_reverse_Selection () {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
    int[] pre_selectedLandPoint_numbers = sort(selectedLandPoint_numbers);
    selectedLandPoint_numbers[0] = 0; 

    selectedLandPoint_numbers = new int [1];
    selectedLandPoint_numbers[0] = 0;

    for (int i = 1; i < 1 + LAND_n_I * LAND_n_J; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedLandPoint_numbers.length; j++) {

        if (pre_selectedLandPoint_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedLandPoint_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedLandPoint_numbers = concat(selectedLandPoint_numbers, new_Item);
      }
    }
  }     

  if (Current_ObjectCategory == ObjectCategory_Fractals) {
    int[] pre_selectedFractal_numbers = sort(selectedFractal_numbers);
    selectedFractal_numbers[0] = 0; 

    selectedFractal_numbers = new int [1];
    selectedFractal_numbers[0] = 0;

    for (int i = 1; i < allFractals_num + 1; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedFractal_numbers.length; j++) {

        if (pre_selectedFractal_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedFractal_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedFractal_numbers = concat(selectedFractal_numbers, new_Item);
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
    int[] pre_selectedObject2D_numbers = sort(selectedObject2D_numbers);
    selectedObject2D_numbers[0] = 0; 

    selectedObject2D_numbers = new int [1];
    selectedObject2D_numbers[0] = 0;

    for (int i = 1; i < allObject2Ds_num + 1; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedObject2D_numbers.length; j++) {

        if (pre_selectedObject2D_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedObject2D_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedObject2D_numbers = concat(selectedObject2D_numbers, new_Item);
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
    int[] pre_selectedGroup3D_numbers = sort(selectedGroup3D_numbers);
    selectedGroup3D_numbers[0] = 0; 

    selectedGroup3D_numbers = new int [1];
    selectedGroup3D_numbers[0] = 0;

    for (int i = 1; i < allGroup3Ds_num + 1; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedGroup3D_numbers.length; j++) {

        if (pre_selectedGroup3D_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedGroup3D_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Faces) {
    int[] pre_selectedFace_numbers = sort(selectedFace_numbers);
    selectedFace_numbers[0] = 0; 

    selectedFace_numbers = new int [1];
    selectedFace_numbers[0] = 0;

    for (int i = 1; i < allFaces_PNT.length; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedFace_numbers.length; j++) {

        if (pre_selectedFace_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedFace_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedFace_numbers = concat(selectedFace_numbers, new_Item);
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Vertices) {
    int[] pre_selectedVertex_numbers = sort(selectedVertex_numbers);
    selectedVertex_numbers[0] = 0; 

    selectedVertex_numbers = new int [1];
    selectedVertex_numbers[0] = 0;

    for (int i = 1; i < allVertices.length; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedVertex_numbers.length; j++) {

        if (pre_selectedVertex_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedVertex_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Solids) {
    int[] pre_selectedSolid_numbers = sort(selectedSolid_numbers);
    selectedSolid_numbers[0] = 0; 

    selectedSolid_numbers = new int [1];
    selectedSolid_numbers[0] = 0;

    for (int i = 1; i < allSolids_DEF.length; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedSolid_numbers.length; j++) {

        if (pre_selectedSolid_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedSolid_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedSolid_numbers = concat(selectedSolid_numbers, new_Item);
      }
    }
  }      

  if (Current_ObjectCategory == ObjectCategory_Sections) {
    int[] pre_selectedSection_numbers = sort(selectedSection_numbers);
    selectedSection_numbers[0] = 0; 

    selectedSection_numbers = new int [1];
    selectedSection_numbers[0] = 0;

    for (int i = 1; i < allSections_num + 1; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedSection_numbers.length; j++) {

        if (pre_selectedSection_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedSection_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedSection_numbers = concat(selectedSection_numbers, new_Item);
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Cameras) {
    int[] pre_selectedCamera_numbers = sort(selectedCamera_numbers);
    selectedCamera_numbers[0] = 0; 

    selectedCamera_numbers = new int [1];
    selectedCamera_numbers[0] = 0;

    for (int i = 1; i < allCameras_num + 1; i++) {
      int found = -1; 

      for (int j = 1; j < pre_selectedCamera_numbers.length; j++) {

        if (pre_selectedCamera_numbers[j] == i) {
          found = 1;
          break;
        } else if (pre_selectedCamera_numbers[j] > i) {
          break;
        }
      }

      if (found == -1) {
        int[] new_Item = {
          i
        };

        selectedCamera_numbers = concat(selectedCamera_numbers, new_Item);
      }
    }
  }    

  println("SOLARCHVISION_calculate_selection_BoundingBox 45");
  SOLARCHVISION_calculate_selection_BoundingBox();
}  


void SOLARCHVISION_convert_Fractal_to_Group3D () {

  selectedGroup3D_numbers = new int [1];
  selectedGroup3D_numbers[0] = 0; 

  for (int i = 1; i < selectedFractal_numbers.length; i++) {

    int f = selectedFractal_numbers[i];

    for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

      if ((allGroup3Ds_Fractals[OBJ_NUM][0] <= f) && (f <= allGroup3Ds_Fractals[OBJ_NUM][1])) { 

        int previously_added = 0;
        for (int q = 0; q < selectedGroup3D_numbers.length; q++) {
          if (selectedGroup3D_numbers[q] == OBJ_NUM) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            OBJ_NUM
          };
          selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Object2D_to_Group3D () {

  selectedGroup3D_numbers = new int [1];
  selectedGroup3D_numbers[0] = 0; 

  for (int i = 1; i < selectedObject2D_numbers.length; i++) {

    int f = selectedObject2D_numbers[i];

    for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

      if ((allGroup3Ds_Object2Ds[OBJ_NUM][0] <= f) && (f <= allGroup3Ds_Object2Ds[OBJ_NUM][1])) { 

        int previously_added = 0;
        for (int q = 0; q < selectedGroup3D_numbers.length; q++) {
          if (selectedGroup3D_numbers[q] == OBJ_NUM) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            OBJ_NUM
          };
          selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Solid_to_Group3D () {

  selectedGroup3D_numbers = new int [1];
  selectedGroup3D_numbers[0] = 0; 

  for (int i = 1; i < selectedSolid_numbers.length; i++) {

    int f = selectedSolid_numbers[i];

    for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

      if ((allGroup3Ds_Solids[OBJ_NUM][0] <= f) && (f <= allGroup3Ds_Solids[OBJ_NUM][1])) { 

        int previously_added = 0;
        for (int q = 0; q < selectedGroup3D_numbers.length; q++) {


          if (selectedGroup3D_numbers[q] == OBJ_NUM) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            OBJ_NUM
          };
          selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
        }
      }
    }
  }
}

void SOLARCHVISION_convert_Face_to_Group3D () {

  selectedGroup3D_numbers = new int [1];
  selectedGroup3D_numbers[0] = 0; 

  for (int i = 1; i < selectedFace_numbers.length; i++) {

    int f = selectedFace_numbers[i];

    for (int j = 0; j < allFaces_PNT[f].length; j++) {

      for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

        if ((allGroup3Ds_Faces[OBJ_NUM][0] <= f) && (f <= allGroup3Ds_Faces[OBJ_NUM][1])) { 

          int previously_added = 0;
          for (int q = 0; q < selectedGroup3D_numbers.length; q++) {
            if (selectedGroup3D_numbers[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
          }
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Vertex_to_Group3D () {

  selectedGroup3D_numbers = new int [1];
  selectedGroup3D_numbers[0] = 0; 

  for (int i = 1; i < selectedVertex_numbers.length; i++) {

    int vNo = selectedVertex_numbers[i];

    for (int f = 1; f < allFaces_PNT.length; f++) {

      for (int j = 0; j < allFaces_PNT[f].length; j++) {

        if (allFaces_PNT[f][j] == vNo) { 

          for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

            if ((allGroup3Ds_Faces[OBJ_NUM][0] <= f) && (f <= allGroup3Ds_Faces[OBJ_NUM][1])) { 

              int previously_added = 0;
              for (int q = 0; q < selectedGroup3D_numbers.length; q++) {
                if (selectedGroup3D_numbers[q] == OBJ_NUM) {
                  previously_added = 1;
                  break;
                }
              }
              if (previously_added == 0) {
                int[] new_Item = {
                  OBJ_NUM
                };
                selectedGroup3D_numbers = concat(selectedGroup3D_numbers, new_Item);
              }
            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Vertex_to_Face () {

  selectedFace_numbers = new int [1];
  selectedFace_numbers[0] = 0; 

  for (int i = 1; i < selectedVertex_numbers.length; i++) {

    int vNo = selectedVertex_numbers[i];

    for (int f = 1; f < allFaces_PNT.length; f++) {

      for (int j = 0; j < allFaces_PNT[f].length; j++) {

        if (allFaces_PNT[f][j] == vNo) { 

          int previously_added = 0;
          for (int q = 0; q < selectedFace_numbers.length; q++) {
            if (selectedFace_numbers[q] == f) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              f
            };
            selectedFace_numbers = concat(selectedFace_numbers, new_Item);
          }
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Group3D_to_Fractal () {

  selectedFractal_numbers = new int [1];
  selectedFractal_numbers[0] = 0; 

  for (int i = 1; i < selectedGroup3D_numbers.length; i++) {

    int OBJ_NUM = selectedGroup3D_numbers[i];

    for (int f = allGroup3Ds_Fractals[OBJ_NUM][0]; f <= allGroup3Ds_Fractals[OBJ_NUM][1]; f++) { 

      int previously_added = 0;
      for (int q = 0; q < selectedFractal_numbers.length; q++) {
        if (selectedFractal_numbers[q] == f) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {
          f
        };
        selectedFractal_numbers = concat(selectedFractal_numbers, new_Item);
      }
    }
  }
}



void SOLARCHVISION_convert_Group3D_to_Object2D () {

  selectedObject2D_numbers = new int [1];
  selectedObject2D_numbers[0] = 0; 

  for (int i = 1; i < selectedGroup3D_numbers.length; i++) {

    int OBJ_NUM = selectedGroup3D_numbers[i];

    for (int f = allGroup3Ds_Object2Ds[OBJ_NUM][0]; f <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; f++) { 

      int previously_added = 0;
      for (int q = 0; q < selectedObject2D_numbers.length; q++) {
        if (selectedObject2D_numbers[q] == f) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {
          f
        };
        selectedObject2D_numbers = concat(selectedObject2D_numbers, new_Item);
      }
    }
  }
}



void SOLARCHVISION_convert_Group3D_to_Solid () {

  selectedSolid_numbers = new int [1];
  selectedSolid_numbers[0] = 0; 

  for (int i = 1; i < selectedGroup3D_numbers.length; i++) {

    int OBJ_NUM = selectedGroup3D_numbers[i];

    for (int f = allGroup3Ds_Solids[OBJ_NUM][0]; f <= allGroup3Ds_Solids[OBJ_NUM][1]; f++) { 

      int previously_added = 0;
      for (int q = 0; q < selectedSolid_numbers.length; q++) {
        if (selectedSolid_numbers[q] == f) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {
          f
        };
        selectedSolid_numbers = concat(selectedSolid_numbers, new_Item);
      }
    }
  }
}



void SOLARCHVISION_convert_Group3D_to_Face () {

  selectedFace_numbers = new int [1];
  selectedFace_numbers[0] = 0; 

  for (int i = 1; i < selectedGroup3D_numbers.length; i++) {

    int OBJ_NUM = selectedGroup3D_numbers[i];

    for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) { 

      int previously_added = 0;
      for (int q = 0; q < selectedFace_numbers.length; q++) {
        if (selectedFace_numbers[q] == f) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {
          f
        };
        selectedFace_numbers = concat(selectedFace_numbers, new_Item);
      }
    }
  }
}


void SOLARCHVISION_convert_Group3D_to_Vertex () {

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0; 

  for (int i = 1; i < selectedGroup3D_numbers.length; i++) {

    int OBJ_NUM = selectedGroup3D_numbers[i];

    for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) { 

      for (int j = 0; j < allFaces_PNT[f].length; j++) {

        int vNo = allFaces_PNT[f][j];

        int previously_added = 0;
        for (int q = 0; q < selectedVertex_numbers.length; q++) {
          if (selectedVertex_numbers[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
        }
      }
    }
  }
}


void SOLARCHVISION_convert_Face_to_Vertex () {

  selectedVertex_numbers = new int [1];
  selectedVertex_numbers[0] = 0; 

  for (int i = 1; i < selectedFace_numbers.length; i++) {

    int f = selectedFace_numbers[i];

    for (int j = 0; j < allFaces_PNT[f].length; j++) {

      int vNo = allFaces_PNT[f][j];

      int previously_added = 0;
      for (int q = 0; q < selectedVertex_numbers.length; q++) {
        if (selectedVertex_numbers[q] == vNo) {
          previously_added = 1;
          break;
        }
      }
      if (previously_added == 0) {
        int[] new_Item = {
          vNo
        };
        selectedVertex_numbers = concat(selectedVertex_numbers, new_Item);
      }
    }
  }
}


int[] selectedVertex_softSelectionVertices = new int[0]; 
float[] selectedVertex_softSelectionValues = new float[0];

void SOLARCHVISION_convert_Vertex_to_softSelection () { 

  int[] keep_selectedVertex_numbers = selectedVertex_numbers;

  SOLARCHVISION_convert_Vertex_to_Group3D();

  SOLARCHVISION_convert_Group3D_to_Vertex();

  selectedVertex_softSelectionVertices = new int[selectedVertex_numbers.length]; 
  selectedVertex_softSelectionValues = new float[selectedVertex_numbers.length];

  for (int q = 1; q < selectedVertex_numbers.length; q++) {

    int n = selectedVertex_numbers[q];

    float d_min = FLOAT_undefined;

    for (int p = 1; p < keep_selectedVertex_numbers.length; p++) {

      int m = keep_selectedVertex_numbers[p];

      float d = dist(allVertices[m][0], allVertices[m][1], allVertices[m][2], allVertices[n][0], allVertices[n][1], allVertices[n][2]);

      if (d_min > d) {
        d_min = d;
      }
    }

    selectedVertex_softSelectionValues[q] = SOLARCHVISION_softVertexSelectionFunction(d_min);
  }

  selectedVertex_softSelectionVertices = selectedVertex_numbers;

  selectedVertex_numbers = keep_selectedVertex_numbers;
}



void SOLARCHVISION_add_Octahedron (int m, int tes, int lyr, int vsb, int xtr, float x, float y, float z, float rx, float ry, float rz, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  float teta = rot * PI / 180.0;

  float[] X_ = new float [6];
  float[] Y_ = new float [6];
  float[] Z_ = new float [6];

  float q = pow(2, 0.5);

  X_[0] = 0;  
  Y_[0] = 0;  
  Z_[0] = q;
  X_[1] = q;  
  Y_[1] = 0;  
  Z_[1] = 0;
  X_[2] = 0;  
  Y_[2] = q;  
  Z_[2] = 0;
  X_[3] = -q;  
  Y_[3] = 0;  
  Z_[3] = 0;
  X_[4] = 0;  
  Y_[4] = -q;  
  Z_[4] = 0;
  X_[5] = 0;  
  Y_[5] = 0;  
  Z_[5] = -q;

  for (int i = 0; i < 6; i += 1) {
    X_[i] *= rx;
    Y_[i] *= ry;
    Z_[i] *= rz;

    float X_r = X_[i] * cos(teta) - Y_[i] * sin(teta);
    float Y_r = X_[i] * sin(teta) + Y_[i] * cos(teta);
    float Z_r = Z_[i];

    X_[i] = X_r + x;
    Y_[i] = Y_r + y;
    Z_[i] = Z_r + z;
  }

  int[] v = new int [6];

  for (int i = 0; i < 6; i++) {
    v[i] = SOLARCHVISION_add_Vertex(X_[i], Y_[i], Z_[i]);
  } 

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  {
    int[] newFace = {
      v[1], v[2], v[0]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      

  {
    int[] newFace = {
      v[2], v[3], v[0]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      

  {
    int[] newFace = {
      v[3], v[4], v[0]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      

  {
    int[] newFace = {
      v[4], v[1], v[0]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      

  {
    int[] newFace = {
      v[1], v[5], v[2]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      

  {
    int[] newFace = {
      v[2], v[5], v[3]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }      
  {
    int[] newFace = {
      v[3], v[5], v[4]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }  

  {
    int[] newFace = {
      v[4], v[5], v[1]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
}            



void SOLARCHVISION_add_House_Core (int m, int tes, int lyr, int vsb, int xtr, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  float teta = rot * PI / 180.0;

  float x1 = rx;  
  float x2 = -rx;
  float x3 = -rx;
  float x4 = rx;

  float y1 = ry;  
  float y2 = ry;
  float y3 = -ry;
  float y4 = -ry;

  float z0 = -rz; 
  float z1 = rz;
  float z2 = h2;

  float[] vx = { 
    1, -1, -1, 1, 1, -1, -1, 1, 1, -1
  };
  float[] vy = { 
    1, 1, -1, -1, 1, 1, -1, -1, 0, 0
  };
  //float[] vz = {-1,-1,-1,-1, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz};
  float[] vz = {
    0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
  };

  for (int i = 0; i < 10; i++) {
    vx[i] *= rx;
    vy[i] *= ry;
    vz[i] *= rz;

    float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
    float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
    float vz_rot = z + vz[i];

    vx[i] = vx_rot;
    vy[i] = vy_rot;
    vz[i] = vz_rot;
  }  

  int b1 = SOLARCHVISION_add_Vertex(vx[0], vy[0], vz[0]);
  int b2 = SOLARCHVISION_add_Vertex(vx[1], vy[1], vz[1]);
  int b3 = SOLARCHVISION_add_Vertex(vx[2], vy[2], vz[2]);
  int b4 = SOLARCHVISION_add_Vertex(vx[3], vy[3], vz[3]);

  int t1 = SOLARCHVISION_add_Vertex(vx[4], vy[4], vz[4]);
  int t2 = SOLARCHVISION_add_Vertex(vx[5], vy[5], vz[5]);
  int t3 = SOLARCHVISION_add_Vertex(vx[6], vy[6], vz[6]);
  int t4 = SOLARCHVISION_add_Vertex(vx[7], vy[7], vz[7]);

  int m1 = SOLARCHVISION_add_Vertex(vx[8], vy[8], vz[8]);
  int m2 = SOLARCHVISION_add_Vertex(vx[9], vy[9], vz[9]);


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;


  {//West
    int[] newFace = {
      t3, m2, t2, b2, b3
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }  
  {//Roof-South
    int[] newFace = {
      m1, m2, t3, t4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }  
  {//East
    int[] newFace = {
      t1, m1, t4, b4, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }    
  {//North
    int[] newFace = {
      t2, t1, b1, b2
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }  
  {//South
    int[] newFace = {
      t4, t3, b3, b4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }    
  {//Roof-North
    int[] newFace = {
      m2, m1, t1, t2
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }    
  {//Bottom
    int[] newFace = {
      b4, b3, b2, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
}



void SOLARCHVISION_add_Box_Core (int m, int tes, int lyr, int vsb, int xtr, float x, float y, float z, float rx, float ry, float rz, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  float teta = rot * PI / 180.0;

  int t1 = SOLARCHVISION_add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z + rz);
  int t2 = SOLARCHVISION_add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z + rz);
  int t3 = SOLARCHVISION_add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z + rz);
  int t4 = SOLARCHVISION_add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z + rz);

  int b1 = SOLARCHVISION_add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z - rz);
  int b2 = SOLARCHVISION_add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z - rz);
  int b3 = SOLARCHVISION_add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z - rz);
  int b4 = SOLARCHVISION_add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z - rz);

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;


  {//West
    int[] newFace = {
      t3, t2, b2, b3
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//Roof
    int[] newFace = {
      t1, t2, t3, t4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//East
    int[] newFace = {
      t1, t4, b4, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//North
    int[] newFace = {
      t2, t1, b1, b2
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//South
    int[] newFace = {
      t4, t3, b3, b4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//Bottom
    int[] newFace = {
      b4, b3, b2, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
}


void SOLARCHVISION_add_Box_Corners (int m, int tes, int lyr, int vsb, int xtr, float x1, float y1, float z1, float x2, float y2, float z2) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int t1 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int t2 = SOLARCHVISION_add_Vertex(x1, y2, z2);
  int t3 = SOLARCHVISION_add_Vertex(x1, y1, z2);
  int t4 = SOLARCHVISION_add_Vertex(x2, y1, z2);

  int b1 = SOLARCHVISION_add_Vertex(x2, y2, z1);
  int b2 = SOLARCHVISION_add_Vertex(x1, y2, z1);
  int b3 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int b4 = SOLARCHVISION_add_Vertex(x2, y1, z1);

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;


  {//West
    int[] newFace = {
      t3, t2, b2, b3
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//Roof
    int[] newFace = {
      t1, t2, t3, t4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//East
    int[] newFace = {
      t1, t4, b4, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//North
    int[] newFace = {
      t2, t1, b1, b2
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//South
    int[] newFace = {
      t4, t3, b3, b4
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
  {//Bottom
    int[] newFace = {
      b4, b3, b2, b1
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
    SOLARCHVISION_add_Face(newFace);
  }
}


void SOLARCHVISION_add_H_shade (int m, int tes, int lyr, int vsb, int xtr, float x0, float y0, float z0, float d, float w, float Alpha, float Beta) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  float rx = 0.5 * d * cos_ang(Beta);
  float ry = 0.5 * d * sin_ang(Beta);

  float wx = w * cos_ang(Beta - 90) * cos_ang(Alpha);
  float wy = w * sin_ang(Beta - 90) * cos_ang(Alpha);
  float wz = w * sin_ang(Alpha);

  float x1 = x0 + rx;
  float y1 = y0 + ry;
  float z1 = z0;

  float x2 = x0 - rx;
  float y2 = y0 - ry;
  float z2 = z0;

  float x3 = wx + x0 - rx;
  float y3 = wy + y0 - ry;
  float z3 = wz + z0;

  float x4 = wx + x0 + rx;
  float y4 = wy + y0 + ry;
  float z4 = wz + z0;

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);
  int v4 = SOLARCHVISION_add_Vertex(x4, y4, z4);

  {
    int[] newFace = {
      v1, v2, v3, v4
    };
    SOLARCHVISION_add_Face(newFace);
  }
}


void SOLARCHVISION_add_V_shade (int m, int tes, int lyr, int vsb, int xtr, float x0, float y0, float z0, float h, float d, float t, float t0) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  float dx = d * cos_ang(t + t0 - 90);
  float dy = d * sin_ang(t + t0 - 90);

  float x1 = x0;
  float y1 = y0;
  float z1 = z0 - 0.5 * h;

  float x2 = x0;
  float y2 = y0;
  float z2 = z0 + 0.5 * h;

  float x3 = x0 + dx;
  float y3 = y0 + dy;
  float z3 = z0 + 0.5 * h;

  float x4 = x0 + dx;
  float y4 = y0 + dy;
  float z4 = z0 - 0.5 * h;

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);
  int v4 = SOLARCHVISION_add_Vertex(x4, y4, z4);

  {
    int[] newFace = {
      v1, v2, v3, v4
    };
    SOLARCHVISION_add_Face(newFace);
  }
}



void SOLARCHVISION_add_Mesh2 (int m, int tes, int lyr, int vsb, int xtr, float x1, float y1, float z1, float x3, float y3, float z3) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr; 

  float x2 = x3;
  float y2 = y3;
  float z2 = z3;

  float x4 = x1;
  float y4 = y1;
  float z4 = z1;

  if (z1 == z3) {
    y2 = y1;
    y4 = y3;
  } else if (y1 == y3) {
    x2 = x1;
    x4 = x3;
  } else if (x1 == x3) {
    z2 = z1;
    z4 = z3;
  }  

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);
  int v4 = SOLARCHVISION_add_Vertex(x4, y4, z4);


  {
    int[] newFace = {
      v1, v2, v3, v4
    };
    SOLARCHVISION_add_Face(newFace);
  }
}

void SOLARCHVISION_add_Mesh4 (int m, int tes, int lyr, int vsb, int xtr, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;  

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);
  int v4 = SOLARCHVISION_add_Vertex(x4, y4, z4);

  {
    int[] newFace = {
      v1, v2, v3, v4
    };
    SOLARCHVISION_add_Face(newFace);
  }
}

void SOLARCHVISION_add_Mesh3 (int m, int tes, int lyr, int vsb, int xtr, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);

  {
    int[] newFace = {
      v1, v2, v3
    };
    SOLARCHVISION_add_Face(newFace);
  }
}

void SOLARCHVISION_add_Mesh5 (int m, int tes, int lyr, int vsb, int xtr, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int v1 = SOLARCHVISION_add_Vertex(x1, y1, z1);
  int v2 = SOLARCHVISION_add_Vertex(x2, y2, z2);
  int v3 = SOLARCHVISION_add_Vertex(x3, y3, z3);
  int v4 = SOLARCHVISION_add_Vertex(x4, y4, z4);
  int v5 = SOLARCHVISION_add_Vertex(x5, y5, z5);

  {
    int[] newFace = {
      v1, v2, v3, v4, v5
    };
    SOLARCHVISION_add_Face(newFace);
  }
}

void SOLARCHVISION_add_PolygonMesh (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int[] newFace = {
    SOLARCHVISION_add_Vertex(cx + r * cos_ang(0), cy + r * sin_ang(0), cz)
  };
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n) + rot;
    int[] f = {
      SOLARCHVISION_add_Vertex(cx + r * cos_ang(t), cy + r * sin_ang(t), cz)
    };
    newFace = concat(newFace, f);
  } 

  SOLARCHVISION_add_Face(newFace);
}



void SOLARCHVISION_add_PolygonExtrude (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, float h, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int[] vT = new int [n];
  int[] vB = new int [n];

  vT[0] = SOLARCHVISION_add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz + 0.5 * h);
  vB[0] = SOLARCHVISION_add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h);

  int[] newFaceT = {
    vT[0]
  };
  int[] newFaceB = {
    vB[0]
  };
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n);

    vT[i] = SOLARCHVISION_add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + 0.5 * h);
    vB[i] = SOLARCHVISION_add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz - 0.5 * h);
    int[] fT = {
      vT[i]
    };
    int[] fB = {
      vB[i]
    };

    newFaceT = concat(newFaceT, fT);
    newFaceB = concat(newFaceB, fB);
  } 

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  SOLARCHVISION_add_Face(newFaceT);

  if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
  SOLARCHVISION_add_Face(newFaceB);

  for (int i = 0; i < n; i++) {
    int next_i = (i + 1) % n;

    int[] newFace = {
      vT[i], vB[i], vB[next_i], vT[next_i]
    };
    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1)); 
    SOLARCHVISION_add_Face(newFace);
  }
}


void SOLARCHVISION_add_PolygonHyper (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, float h, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int[] newFace = {
    SOLARCHVISION_add_Vertex(cx + r * cos_ang(rot), cy + r * sin_ang(rot), cz - 0.5 * h)
  };
  for (int i = 1; i < n; i++) {
    float t = i * 360.0 / float(n);
    int[] f = {
      SOLARCHVISION_add_Vertex(cx + r * cos_ang(t + rot), cy + r * sin_ang(t + rot), cz + (2 * (i % 2) - 1) * 0.5 * h)
    };
    newFace = concat(newFace, f);
  } 

  SOLARCHVISION_add_Face(newFace);
}



void SOLARCHVISION_add_Icosahedron (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int[] vT = new int [6];
  int[] vB = new int [6];

  vT[0] = SOLARCHVISION_add_Vertex(cx, cy, cz + r);
  vB[0] = SOLARCHVISION_add_Vertex(cx, cy, cz - r);

  for (int i = 1; i <= 5; i++) {
    float t = i * 72;

    float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;

    vT[i] = SOLARCHVISION_add_Vertex(cx + R_in * cos_ang(t + rot), cy + R_in * sin_ang(t + rot), cz + H_in);
    vB[i] = SOLARCHVISION_add_Vertex(cx + R_in * cos_ang(t + 36 + rot), cy + R_in * sin_ang(t + 36 + rot), cz - H_in);
  } 


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  for (int i = 1; i <= 5; i++) {

    int next_i = (i % 5) + 1;

    {
      int[] newFaceT = new int [3];
      int[] newFaceB = new int [3];

      newFaceT[0] = vT[i];
      newFaceT[1] = vT[next_i];
      newFaceT[2] = vT[0];

      newFaceB[0] = vB[i];
      newFaceB[1] = vB[next_i];
      newFaceB[2] = vT[next_i]; 

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));   
      SOLARCHVISION_add_Face(newFaceT);
      SOLARCHVISION_add_Face(newFaceB);
    }

    {
      int[] newFaceT = new int [3];
      int[] newFaceB = new int [3];

      newFaceT[0] = vT[next_i];
      newFaceT[1] = vT[i];
      newFaceT[2] = vB[i];

      newFaceB[0] = vB[next_i];
      newFaceB[1] = vB[i];
      newFaceB[2] = vB[0];    

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));
      SOLARCHVISION_add_Face(newFaceT);
      SOLARCHVISION_add_Face(newFaceB);
    }
  }
}  


void SOLARCHVISION_add_QuadSphere (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, int Tessellation) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr; 

  // i.e. Rhombic Triacontahedron

  int[] vT = new int [6];
  int[] vB = new int [6];

  vT[0] = SOLARCHVISION_add_Vertex(cx, cy, cz + r);
  vB[0] = SOLARCHVISION_add_Vertex(cx, cy, cz - r);

  for (int i = 1; i <= 5; i++) {
    float t = i * 72;

    float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;

    vT[i] = SOLARCHVISION_add_Vertex(cx + R_in * cos_ang(t), cy + R_in * sin_ang(t), cz + H_in);
    vB[i] = SOLARCHVISION_add_Vertex(cx + R_in * cos_ang(t + 36), cy + R_in * sin_ang(t + 36), cz - H_in);
  } 

  int[] vM1 = new int [6]; // between T0 and Ti  
  int[] vM2 = new int [6]; // between Ti and Bi
  int[] vM3 = new int [6]; // between Ti and Bi
  int[] vM4 = new int [6]; // between Bi and B0
  //CAUTION: VMx[0] will remain undefined below to keep simillar i variables! 
  for (int i = 1; i <= 5; i++) {

    int next_i = (i % 5) + 1;

    float[] G;

    int A, B, C;

    { 
      A = i;
      B = next_i;
      C = 0;

      float[][] the_points = {
        {
          allVertices[vT[A]][0] - cx, allVertices[vT[A]][1] - cy, allVertices[vT[A]][2] - cz
        }
        , {
          allVertices[vT[B]][0] - cx, allVertices[vT[B]][1] - cy, allVertices[vT[B]][2] - cz
        }
        , {
          allVertices[vT[C]][0] - cx, allVertices[vT[C]][1] - cy, allVertices[vT[C]][2] - cz
        }
      };

      G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
      vM1[i] = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }

    { 
      A = next_i;
      B = i;
      C = i;

      float[][] the_points = {
        {
          allVertices[vT[A]][0] - cx, allVertices[vT[A]][1] - cy, allVertices[vT[A]][2] - cz
        }
        , {
          allVertices[vT[B]][0] - cx, allVertices[vT[B]][1] - cy, allVertices[vT[B]][2] - cz
        }
        , {
          allVertices[vB[C]][0] - cx, allVertices[vB[C]][1] - cy, allVertices[vB[C]][2] - cz
        }
      };

      G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
      vM2[i] = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    } 

    { 
      A = i;
      B = next_i;
      C = next_i;

      float[][] the_points = {
        {
          allVertices[vB[A]][0] - cx, allVertices[vB[A]][1] - cy, allVertices[vB[A]][2] - cz
        }
        , {
          allVertices[vB[B]][0] - cx, allVertices[vB[B]][1] - cy, allVertices[vB[B]][2] - cz
        }
        , {
          allVertices[vT[C]][0] - cx, allVertices[vT[C]][1] - cy, allVertices[vT[C]][2] - cz
        }
      };

      G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
      vM3[i] = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }    

    { 
      A = next_i;
      B = i;
      C = 0;

      float[][] the_points = {
        {
          allVertices[vB[A]][0] - cx, allVertices[vB[A]][1] - cy, allVertices[vB[A]][2] - cz
        }
        , {
          allVertices[vB[B]][0] - cx, allVertices[vB[B]][1] - cy, allVertices[vB[B]][2] - cz
        }
        , {
          allVertices[vB[C]][0] - cx, allVertices[vB[C]][1] - cy, allVertices[vB[C]][2] - cz
        }
      };

      G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
      vM4[i] = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    }
  }    


  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  for (int i = 1; i <= 5; i++) {

    int next_i = (i % 5) + 1;
    int prev_i = ((i + 5 - 2) % 5) + 1;

    {
      int[] newFace = new int [4];

      newFace[0] = vT[0];
      newFace[1] = vM1[prev_i];
      newFace[2] = vT[i];
      newFace[3] = vM1[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }

    {
      int[] newFace = new int [4];

      newFace[0] = vT[i];
      newFace[1] = vM2[i];
      newFace[2] = vT[next_i];
      newFace[3] = vM1[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }

    {
      int[] newFace = new int [4];

      newFace[0] = vT[i];
      newFace[1] = vM3[prev_i];
      newFace[2] = vB[i];
      newFace[3] = vM2[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }    

    {
      int[] newFace = new int [4];

      newFace[0] = vT[next_i];
      newFace[1] = vM2[i];
      newFace[2] = vB[i];
      newFace[3] = vM3[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }     

    {
      int[] newFace = new int [4];

      newFace[0] = vB[i];
      newFace[1] = vM4[i];
      newFace[2] = vB[next_i];
      newFace[3] = vM3[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }

    {
      int[] newFace = new int [4];

      newFace[0] = vB[i];
      newFace[1] = vM4[prev_i];
      newFace[2] = vB[0];
      newFace[3] = vM4[i];

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));

      if (Tessellation == 0) {
        SOLARCHVISION_add_Face(newFace);
      } else {
        SOLARCHVISION_create_Face_afterSphericalTessellation(m, tes, lyr, vsb, xtr, cx, cy, cz, r, newFace);
      }
    }
  }
}


void SOLARCHVISION_create_Face_afterSphericalTessellation (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, int[] f) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int A = f[0];
  int B = f[1];
  int C = f[2];
  int D = f[3];

  int M, N;  // 
  int MM, NN; // MM: mirror of M based on AB; NN: mirror of N baesd on CD

  float[] G;

  { 
    float[][] the_points = {
      {
        allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz
      }
      , {
        allVertices[A][0] - cx, allVertices[A][1] - cy, allVertices[A][2] - cz
      }
      , {
        allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz
      }
    };

    G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
    M = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);

    G[0] = (allVertices[C][0] - cx) + (allVertices[D][0] - cx) - (allVertices[M][0] - cx);
    G[1] = (allVertices[C][1] - cy) + (allVertices[D][1] - cy) - (allVertices[M][1] - cy);
    G[2] = (allVertices[C][2] - cz) + (allVertices[D][2] - cz) - (allVertices[M][2] - cz);
    G = SOLARCHVISION_fn_normalize(G);
    MM = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
  }   


  { 
    float[][] the_points = {
      {
        allVertices[B][0] - cx, allVertices[B][1] - cy, allVertices[B][2] - cz
      }
      , {
        allVertices[C][0] - cx, allVertices[C][1] - cy, allVertices[C][2] - cz
      }
      , {
        allVertices[D][0] - cx, allVertices[D][1] - cy, allVertices[D][2] - cz
      }
    };

    G = SOLARCHVISION_fn_normalize(SOLARCHVISION_fn_G(the_points));
    N = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);


    G[0] = (allVertices[A][0] - cx) + (allVertices[B][0] - cx) - (allVertices[N][0] - cx);
    G[1] = (allVertices[A][1] - cy) + (allVertices[B][1] - cy) - (allVertices[N][1] - cy);
    G[2] = (allVertices[A][2] - cz) + (allVertices[B][2] - cz) - (allVertices[N][2] - cz);
    G = SOLARCHVISION_fn_normalize(G);    
    NN = SOLARCHVISION_add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
  }





  {
    int[][] newFace_MTLV = {
      {
        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
      }
    }; 

    allFaces_MTLV = (int[][]) concat(allFaces_MTLV, newFace_MTLV);


    int[][] newFace = {
      {
        M, B, N, D
      }
    }; 

    allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
  }

  {
    int[][] newFace_MTLV = {
      {
        defaultMaterial, defaultTessellation, defaultLayer, defaultVisibility
      }
    }; 

    //allFaces_MTLV = (int[][]) concat(allFaces_MTLV, newFace_MTLV);


    int[][] newFace = {
      {
        MM, B, M, A
      }
    }; 

    //allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
  }
}




void SOLARCHVISION_export_objects_SCR () {
  
  String fileBasename = ProjectName;

  String scrFilename = Model3DFolder + "/" + fileBasename + ".scr";  

  PrintWriter scrOutput = createWriter(scrFilename);

  scrOutput.println("-osnap off");

  for (int f = 1; f < allFaces_PNT.length; f++) {

    if ((allFaces_PNT[f].length == 3) || (allFaces_PNT[f].length == 4)) {

      scrOutput.println("3dface");

      for (int j = 0; j < allFaces_PNT[f].length; j++) {

        float x = allVertices[allFaces_PNT[f][j]][0];
        float y = allVertices[allFaces_PNT[f][j]][1];
        float z = allVertices[allFaces_PNT[f][j]][2];

        /*
        { 
         z += 20;
         x *= 1000000;
         y *= 1000000;
         z *= 1000000;
         }
         */

        scrOutput.println(nf(x, 0, objExport_PrecisionVertex) + "," + nf(y, 0, objExport_PrecisionVertex) + "," + nf(z, 0, objExport_PrecisionVertex));
      }
      scrOutput.println();
      scrOutput.println();
    }
  }

  scrOutput.println("zoom e");

  scrOutput.flush(); 
  scrOutput.close();   

  println("End of scripting the mesh."); 

  SOLARCHVISION_explore_output(scrFilename);
}


PrintWriter radOutput;

void SOLARCHVISION_export_objects_RAD () {

  String fileBasename = ProjectName;

  String radFilename = Model3DFolder + "/" + fileBasename + ".rad";  

  radOutput = createWriter(radFilename);

  radOutput.println("#SOLARCHVISION");
  radOutput.println();


  if (Display_LAND_MESH != 0) {

    SOLARCHVISION_draw_land(5);
  }

  if (Display_Model3Ds != 0) {

    int[] Materials_Used = new int [Materials_Number];

    for (int i = 0; i < Materials_Used.length; i++) {
      Materials_Used[i] = 0;
    }

    for (int f = 1; f < allFaces_PNT.length; f++) {

      int mt = allFaces_MTLV[f][0];

      Materials_Used[mt] += 1;
    }    

    for (int mt = 0; mt < Materials_Number; mt++) {

      if (Materials_Used[mt] != 0) {

        float a = Materials_Color[mt][0] / 255.0; 
        float r = Materials_Color[mt][1] / 255.0; 
        float g = Materials_Color[mt][2] / 255.0; 
        float b = Materials_Color[mt][3] / 255.0; 

        radOutput.println("void plastic " + "SurfaceMaterial_" + nf(mt, 0));
        radOutput.println("0");
        radOutput.println("0");
        radOutput.println("5 " + nf(r, 0, objExport_PrecisionVtexture) + " " + nf(g, 0, objExport_PrecisionVtexture) + " " + nf(b, 0, objExport_PrecisionVtexture) + " 0 0");

      }
    }
  
    for (int f = 1; f < allFaces_PNT.length; f++) {
  
      if (allFaces_PNT[f].length > 2) {

        int mt = allFaces_MTLV[f][0];

        int Tessellation = allFaces_MTLV[f][1];

        int TotalSubNo = 1;  
        if (allFaces_MTLV[f][0] == 0) {
          Tessellation += MODEL3D_Tessellation;
        }

        if ((allFaces_PNT[f].length > 4) && (Tessellation == 0)) { // don't need it for triangles
          Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
        }

        if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

        float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
        for (int j = 0; j < allFaces_PNT[f].length; j++) {
          int vNo = allFaces_PNT[f][j];
          base_Vertices[j][0] = allVertices[vNo][0];
          base_Vertices[j][1] = allVertices[vNo][1];
          base_Vertices[j][2] = allVertices[vNo][2];
        }

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
          
          for (int back_or_front = 1 - objExport_BackSides; back_or_front <= 1; back_or_front++) {

            if (back_or_front == 1) {

              radOutput.println("SurfaceMaterial_" + nf(mt, 0) + " polygon " + "FACE");
              radOutput.println("0");
              radOutput.println("0");
              radOutput.println("9");      
              
              radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));                
              radOutput.println(" " + nf(subFace[1][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][2], 0, objExport_PrecisionVertex));
              radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));
              
              if (subFace.length == 4) {

                radOutput.println("SurfaceMaterial_" + nf(mt, 0) + " polygon " + "FACE");
                radOutput.println("0");
                radOutput.println("0");
                radOutput.println("9");      
                
                radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));                
                radOutput.println(" " + nf(subFace[3][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][2], 0, objExport_PrecisionVertex));
                radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));
              }
              
              
            } else {

              radOutput.println("SurfaceMaterial_" + nf(mt, 0) + " polygon " + "FACE");
              radOutput.println("0");
              radOutput.println("0");
              radOutput.println("9");    
              
              radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));                
              radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));
              radOutput.println(" " + nf(subFace[1][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][2], 0, objExport_PrecisionVertex));
              
              if (subFace.length == 4) { 
                
                radOutput.println("SurfaceMaterial_" + nf(mt, 0) + " polygon " + "FACE");
                radOutput.println("0");
                radOutput.println("0");
                radOutput.println("9");                   
                
                radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));                
                radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));
                radOutput.println(" " + nf(subFace[3][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][2], 0, objExport_PrecisionVertex));
              }
            }
          }
        }
          
        radOutput.println();
      }
    }
  }
  
  for (int i = 15; i < 180; i += 15) {
    radOutput.println("!gensky -ang " + nf(i, 0) + " 45 +s -trb 4.0");
  }   
  
  radOutput.flush(); 
  radOutput.close();   

  println("End of creating rad file."); 

  SOLARCHVISION_explore_output(radFilename);
  
  
  String batFilename = radFilename.replace(".rad", ".bat");
  PrintWriter batOutput = createWriter(batFilename);

  String Command1 = "oconv " + radFilename;
  String octFilename = radFilename.replace(".rad", ".oct");
  Command1 += " > " + octFilename;
  batOutput.println(Command1);
  
  String Command2 = "rvu";

  //Command2 += " -vtl"; //parallel
  Command2 += " -vtv"; //perspective
  //Command2 += " -vth"; //hemispherical
  //Command2 += " -vtc"; //cylindrical
  //Command2 += " -vta"; //angular
  //Command2 += " -vts"; //stereographic 
  
  Command2 += " -vv " + nf(WIN3D_Zoom, 0, 0);
  Command2 += " -vh " + nf(2 * atan_ang((WIN3D_X_View / float(WIN3D_Y_View)) * tan_ang(0.5 * WIN3D_Zoom)), 0, 0);  

  Command2 += " -vp " + nf(WIN3D_CAM_x, 0, 0) + " " + nf(WIN3D_CAM_y, 0, 0) + " " + nf(WIN3D_CAM_z, 0, 0);

  float dx = cos_ang(90 - WIN3D_RX_Coordinate) * cos_ang(90 - WIN3D_RZ_Coordinate);
  float dy = cos_ang(90 - WIN3D_RX_Coordinate) * sin_ang(90 - WIN3D_RZ_Coordinate);
  float dz = sin_ang(90 - WIN3D_RX_Coordinate);
  
  Command2 += " -vd " + nf(-dx , 0, 0) + " " + nf(dy, 0, 0) + " " + nf(-dz, 0, 0);

  float ux = 0;
  float uy = 0;
  float uz = 1;
  if (abs(dz) > 0.99) {
    ux = cos_ang(90 + WIN3D_RZ_Coordinate);
    uy = sin_ang(90 + WIN3D_RZ_Coordinate);
    uz = 0; 
  }
  Command2 += " -vu " + nf(ux, 0, 0) + " " + nf(uy, 0, 0) + " " + nf(uz, 0, 0);



  

 
  
  Command2 += " -av 0.5 0.5 0.5";
  Command2 += " -pe 0.001";
  Command2 += " -ab 1";
  Command2 += " " + octFilename.replace('/', char(92));
  batOutput.println(Command2);
  
  batOutput.println("cmd /k"); // leave command prompt open

  batOutput.flush(); 
  batOutput.close();   


}





String obj_MapsSubfolder = "maps/";

PrintWriter mtlOutput;
PrintWriter objOutput;


int obj_lastVertexNumber;
int obj_lastVtextureNumber;
int obj_lastFaceNumber;
int obj_lastGroupNumber;



int num_vertices_added = 0;

void SOLARCHVISION_export_objects_OBJ () {

  String fileBasename = ProjectName;

  String objFilename = Model3DFolder + "/" + fileBasename + ".obj";
  String mtlFilename = Model3DFolder + "/" + fileBasename + ".mtl";


  if (objExport_MaterialLibrary != 0) {
    mtlOutput = createWriter(mtlFilename);
    mtlOutput.println("#SOLARCHVISION");
  }

  objOutput = createWriter(objFilename);
  objOutput.println("#SOLARCHVISION");
  if (objExport_MaterialLibrary != 0) {
    objOutput.println("mtllib " + fileBasename + ".mtl");
  }

  obj_lastVertexNumber = 0; 
  obj_lastVtextureNumber = 0; 
  obj_lastFaceNumber = 0;
  obj_lastGroupNumber = 0;





  if (Display_TROPO3D_Surface != 0) {

    for (int TROPO_level = 0; TROPO_level < TROPO_IMAGES_Map.length; TROPO_level++) {    

      if (objExport_MaterialLibrary != 0) {

        mtlOutput.println("newmtl TropoSphere_" + nf(TROPO_level, 0));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

        if (Display_TROPO3D_Texture != 0) {

          //int n = 0;
          //if (IMPACTS_DisplayDay < TROPO_IMAGES_Map.length) n = IMPACTS_DisplayDay;

          int n = TROPO_level; // <<<<<<<<

          String old_Texture_path = TROPO_IMAGES_Path + "/" + TROPO_IMAGES_Filenames[n];

          String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

          String new_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

          println("Copying texture:", old_Texture_path, ">", new_Texture_path);
          saveBytes(new_Texture_path, loadBytes(old_Texture_path));

          //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map        
          mtlOutput.println("\tmap_d " + obj_MapsSubfolder + the_filename); // diffuse map
        }
      }


      if (objExport_PolyToPoly == 1) {
        obj_lastGroupNumber += 1;  
        objOutput.println("g TropoSphere_" + nf(TROPO_level, 0));
      }

      if (objExport_MaterialLibrary != 0) {
        objOutput.println("usemtl TropoSphere_" + nf(TROPO_level, 0));
      }


      float TROPO_IMAGES_OffsetX = 0; //TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + 180;
      float TROPO_IMAGES_OffsetY = 0; //TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - 90;

      float TROPO_IMAGES_ScaleX = 1; //(TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0]) / 360.0;
      float TROPO_IMAGES_ScaleY = 1; //(TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0]) / 180.0;

      float CEN_lon = 0; //0.5 * (TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1]);
      float CEN_lat = 0; //0.5 * (TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1]);

      float delta_Alpha = -BIOSPHERE_drawResolution; 
      float delta_Beta = -BIOSPHERE_drawResolution;

      float r = FLOAT_r_Earth + (TROPO_IMAGES_Map.length - TROPO_level) * 17000;


      for (int _turn = 1; _turn < 4; _turn += 1) {

        int f = 0;
        for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
          for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
            f += 1;

            float[][] subFace = new float [4][5];

            for (int s = 0; s < 4; s += 1) {

              float a = Alpha;
              float b = Beta;

              if ((s == 2) || (s == 3)) {
                a += delta_Alpha;
              }

              if ((s == 1) || (s == 2)) {
                b += delta_Beta;
              }

              float x0 = r * cos_ang(b - 90) * cos_ang(a); 
              float y0 = r * sin_ang(b - 90) * cos_ang(a);
              float z0 = r * sin_ang(a);

              float _lon = b - CEN_lon;
              float _lat = a - CEN_lat;


              // calculating u and v
              subFace[s][3] = (_lon / TROPO_IMAGES_ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / TROPO_IMAGES_ScaleY / 180.0 + 0.5);


              // rotating to location coordinates 
              float tb = -LocationLongitude;
              float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
              float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
              float z1 = z0;

              float ta = 90 - LocationLatitude;
              float x2 = x1;
              float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
              float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

              // move it down!
              z2 -= FLOAT_r_Earth;

              subFace[s][0] = x2;
              subFace[s][1] = y2;
              subFace[s][2] = z2;
            }

            for (int s = 0; s < subFace.length; s++) {

              float x = subFace[s][0];
              float y = subFace[s][1];
              float z = subFace[s][2];
              float u = subFace[s][3];
              float v = subFace[s][4];

              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

              if (_turn == 1) {
                SOLARCHVISION_OBJprintVertex(x, y, z);
              }

              if (_turn == 2) {

                if (u > 1) u = 1;
                if (u < 0) u = 0;
                if (v > 1) v = 1;
                if (v < 0) v = 0;

                SOLARCHVISION_OBJprintVtexture(u, v, 0);
              }

              if (_turn == 3) {
                obj_lastVertexNumber += 1;
                obj_lastVtextureNumber += 1;
              }
            }

            String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber - 0, 0);

            String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      

            if (objExport_PolyToPoly == 0) {
              if (_turn == 3) {
                obj_lastGroupNumber += 1;
                objOutput.println("g TropoSphere_" + nf(TROPO_level, 0) + "_" + nf(f, 0));
              }
            } 

            if (_turn == 3) {
              obj_lastFaceNumber += 1;            
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              if (objExport_BackSides != 0) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
              }
            }
          }
        }
      }
    }
  }






  if (Display_EARTH3D_Surface != 0) {

    float EARTH_IMAGES_OffsetX = 0;
    float EARTH_IMAGES_OffsetY = 0;

    float EARTH_IMAGES_ScaleX = 1;
    float EARTH_IMAGES_ScaleY = 1;

    float CEN_lon = 0;
    float CEN_lat = 0;    

    if (objExport_MaterialLibrary != 0) {

      mtlOutput.println("newmtl EarthSphere");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      if (Display_EARTH3D_Texture != 0) {

        int n = 0;
        if (IMPACTS_DisplayDay < EARTH_IMAGES_Map.length) n = IMPACTS_DisplayDay;

        String old_Texture_path = EARTH_IMAGES_Path + "/" + EARTH_IMAGES_Filenames[n];

        String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

        String new_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

        println("Copying texture:", old_Texture_path, ">", new_Texture_path);
        saveBytes(new_Texture_path, loadBytes(old_Texture_path));

        //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map        
        mtlOutput.println("\tmap_d " + obj_MapsSubfolder + the_filename); // diffuse map

        EARTH_IMAGES_OffsetX = EARTH_IMAGES_BoundariesX[n][0] + 180;
        EARTH_IMAGES_OffsetY = EARTH_IMAGES_BoundariesY[n][1] - 90;

        EARTH_IMAGES_ScaleX = (EARTH_IMAGES_BoundariesX[n][1] - EARTH_IMAGES_BoundariesX[n][0]) / 360.0;
        EARTH_IMAGES_ScaleY = (EARTH_IMAGES_BoundariesY[n][1] - EARTH_IMAGES_BoundariesY[n][0]) / 180.0;

        CEN_lon = 0.5 * (EARTH_IMAGES_BoundariesX[n][0] + EARTH_IMAGES_BoundariesX[n][1]);
        CEN_lat = 0.5 * (EARTH_IMAGES_BoundariesY[n][0] + EARTH_IMAGES_BoundariesY[n][1]);
      }
    }


    if (objExport_PolyToPoly == 1) {
      obj_lastGroupNumber += 1;  
      objOutput.println("g EarthSphere");
    }

    if (objExport_MaterialLibrary != 0) {
      objOutput.println("usemtl EarthSphere");
    }




    float delta_Alpha = -BIOSPHERE_drawResolution;
    float delta_Beta = -BIOSPHERE_drawResolution; 

    float r = FLOAT_r_Earth;


    for (int _turn = 1; _turn < 4; _turn += 1) {

      int f = 0;
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
          f += 1;

          float[][] subFace = new float [4][5];

          for (int s = 0; s < 4; s += 1) {

            float a = Alpha;
            float b = Beta;

            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }

            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }

            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);

            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;


            // calculating u and v
            subFace[s][3] = (_lon / EARTH_IMAGES_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / EARTH_IMAGES_ScaleY / 180.0 + 0.5);


            // rotating to location coordinates 
            float tb = -LocationLongitude;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;

            float ta = 90 - LocationLatitude;
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

            // move it down!
            z2 -= FLOAT_r_Earth;

            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }

          for (int s = 0; s < subFace.length; s++) {

            float x = subFace[s][0];
            float y = subFace[s][1];
            float z = subFace[s][2];
            float u = subFace[s][3];
            float v = subFace[s][4];

            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

            if (_turn == 1) {
              SOLARCHVISION_OBJprintVertex(x, y, z);
            }

            if (_turn == 2) {

              if (u > 1) u = 1;
              if (u < 0) u = 0;
              if (v > 1) v = 1;
              if (v < 0) v = 0;

              SOLARCHVISION_OBJprintVtexture(u, v, 0);
            }

            if (_turn == 3) {
              obj_lastVertexNumber += 1;
              obj_lastVtextureNumber += 1;
            }
          }

          String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber - 0, 0);

          String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      

          if (objExport_PolyToPoly == 0) {
            if (_turn == 3) {
              obj_lastGroupNumber += 1;
              objOutput.println("g EarthSphere_" + nf(f, 0));
            }
          } 

          if (_turn == 3) {
            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (objExport_BackSides != 0) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
          }
        }
      }
    }
  }


  if (Display_LAND_MESH != 0) {

    SOLARCHVISION_draw_land(4);
  }



  if (Display_Sections != 0) {

    for (int f = 1; f <= allSections_num; f++) {

      float Section_offset_U = allSections_UVERAB[f][0];
      float Section_offset_V = allSections_UVERAB[f][1];
      float Section_Elevation = allSections_UVERAB[f][2];
      float Section_Rotation = allSections_UVERAB[f][3];
      float Section_scale_U = allSections_UVERAB[f][4];
      float Section_scale_V = allSections_UVERAB[f][5];

      int Section_Type = allSections_Type[f];
      int Section_RES1 = allSections_RES1[f];
      int Section_RES2 = allSections_RES2[f];

      if (Section_Type != 0) {

        String the_filename = "Impact_" + nf(f, 0) + ".bmp";

        if (objExport_MaterialLibrary != 0) {

          String new_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

          if (Display_SolarImpactImage != 0) {
            println("Saving texture:", new_Texture_path);
            allSections_SolarImpact[f][IMPACTS_DisplayDay].save(new_Texture_path);
          } else if (Display_SolidImpactImage != 0) {
            println("Saving texture:", new_Texture_path);
            allSections_SolidImpact[f].save(new_Texture_path);
          }

          mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

          //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
        }

        int Display_solarch_texture = 0;

        if (Section_Type != 0) {

          if (objExport_PolyToPoly == 1) {
            obj_lastGroupNumber += 1;  
            objOutput.println("g Impact_" + nf(f, 0));
          }

          if (objExport_MaterialLibrary != 0) {
            objOutput.println("usemtl " + the_filename.replace('.', '_'));
          }

          for (int _turn = 1; _turn < 4; _turn += 1) {

            float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

            for (int q = 1; q <= 4; q++) { //  skip the center point

              float x = ImageVertex[q][0];
              float y = ImageVertex[q][1];
              float z = ImageVertex[q][2];
              float u = ImageVertex[q][3];
              float v = ImageVertex[q][4];


              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

              if (_turn == 1) {
                SOLARCHVISION_OBJprintVertex(x, y, z);
              }

              if (_turn == 2) {
                SOLARCHVISION_OBJprintVtexture(u, v, 0);
              }

              if (_turn == 3) {
                obj_lastVertexNumber += 1;
                obj_lastVtextureNumber += 1;
              }
            }
          }   


          String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber - 0, 0);

          String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      

          obj_lastFaceNumber += 1;            
          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          if (objExport_BackSides != 0) {
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
          }
        }
      }
    }
  }




  if (Display_Model2Ds != 0) {

    if (objExport_MaterialLibrary != 0) {

      int[] Object2D_ImageUsed = new int [Object2D_ImagePath.length];

      for (int i = 0; i < Object2D_ImageUsed.length; i++) {
        Object2D_ImageUsed[i] = 0;
      }

      for (int f = 1; f <= allObject2Ds_num; f++) {

        int n = abs(allObject2Ds_MAP[f]);

        Object2D_ImageUsed[n] += 1;
      }

      for (int i = 1; i < Object2D_ImagePath.length; i++) {

        if (Object2D_ImageUsed[i] != 0) {

          String old_Texture_path = Object2D_ImagePath[i];

          String new_Texture_path = "";

          String opacity_Texture_path = "";

          String the_filename = "";

          if (Object2D_ImagePath[i].equals("")) {
          } else {

            the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

            new_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;
            opacity_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + "opacity_" + the_filename;

            println("Copying texture:", old_Texture_path, ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(old_Texture_path));

            println("Making opacity texture:", new_Texture_path);

            int RES1 = Object2D_Images[i].width;
            int RES2 = Object2D_Images[i].height;

            PImage Opacity_Texture = createImage(RES1, RES2, ARGB);

            Opacity_Texture.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              color COL = Object2D_Images[i].get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;

              float COL_V = (COL >> 24 & 0xFF);

              Opacity_Texture.pixels[np] = color(COL_V, COL_V, COL_V, COL_V);
            }

            Opacity_Texture.updatePixels();

            Opacity_Texture.save(opacity_Texture_path);


            mtlOutput.println("newmtl " + "Object2D_" + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

            //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map        
            mtlOutput.println("\tmap_d " + obj_MapsSubfolder + "opacity_" + the_filename); // diffuse map
          }
        }
      }
    }

    for (int f = 1; f <= allObject2Ds_num; f++) {

      int n = abs(allObject2Ds_MAP[f]);

      int w = Object2D_Images[n].width; 
      int h = Object2D_Images[n].height;

      float x = allObject2Ds_XYZS[f][0];
      float y = allObject2Ds_XYZS[f][1];
      float z = allObject2Ds_XYZS[f][2];

      float rh = allObject2Ds_XYZS[f][3] * 0.5;
      float rw = rh * Object2D_ImageRatios[n];

      float t = 0; //WIN3D_RZ_Coordinate * PI / 180.0;
      //if (WIN3D_ViewType == 1) t = atan2(y - WIN3D_CAM_y, x - WIN3D_CAM_x) + 0.5 * PI; 

      if (allObject2Ds_MAP[f] < 0) t += PI;            

      if (objExport_PolyToPoly == 1) {
        obj_lastGroupNumber += 1;  
        objOutput.println("g Object2D_" + nf(f, 0) + "_type" + nf(n, 0));
      }

      if (objExport_MaterialLibrary != 0) {
        objOutput.println("usemtl Object2D_" + Object2D_ImagePath[n].substring(Object2D_ImagePath[n].lastIndexOf("/") + 1).replace('.', '_'));
      }

      num_vertices_added = 0;

      for (int _turn = 1; _turn < 4; _turn += 1) {

        { 

          if (_turn == 1) {
            float x1 = x - rw * cos(t);
            float y1 = y - rw * sin(t);
            float z1 = z;

            float x2 = x + rw * cos(t);
            float y2 = y + rw * sin(t);
            float z2 = z;

            float x3 = x + rw * cos(t);
            float y3 = y + rw * sin(t);
            float z3 = z + 2 * rh;

            float x4 = x - rw * cos(t);
            float y4 = y - rw * sin(t);
            float z4 = z + 2 * rh;

            SOLARCHVISION_OBJprintVertex(x1, y1, z1);
            SOLARCHVISION_OBJprintVertex(x2, y2, z2);
            SOLARCHVISION_OBJprintVertex(x3, y3, z3);
            SOLARCHVISION_OBJprintVertex(x4, y4, z4);

            num_vertices_added += 4;
          }

          if (_turn == 2) {
            SOLARCHVISION_OBJprintVtexture(0, 0, 0);
            SOLARCHVISION_OBJprintVtexture(1, 0, 0);
            SOLARCHVISION_OBJprintVtexture(1, 1, 0);
            SOLARCHVISION_OBJprintVtexture(0, 1, 0);
          }

          if (_turn == 3) {
            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;

            String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 1, 0); 
            String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 3, 0);
            String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4, 0);

            String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 1, 0); 
            String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 3, 0);
            String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4, 0);      

            if (objExport_PolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println("g Object2D_" + nf(f, 0) + "_ver");
            } 

            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (objExport_BackSides != 0) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
          }
        }


        if (n > Object2D_PEOPLE_Files_Num) { // case: trees    

          float ratio = 0.5;

          for (int back_front = -1; back_front <= 1; back_front += 2) {

            if (_turn == 1) {

              float rot = back_front * PI / 2 + t;

              float x1 = x - rw * cos(t);
              float y1 = y - rw * sin(t);
              float z1 = z + 2 * rh * ratio;

              float x2 = x + rw * cos(t);
              float y2 = y + rw * sin(t);
              float z2 = z + 2 * rh * ratio;

              float x3 = x + rw * cos(t) + rw * cos(rot);
              float y3 = y + rw * sin(t) + rw * sin(rot);
              float z3 = z + 2 * rh * ratio;

              float x4 = x - rw * cos(t) + rw * cos(rot);
              float y4 = y - rw * sin(t) + rw * sin(rot);
              float z4 = z + 2 * rh * ratio;

              SOLARCHVISION_OBJprintVertex(x1, y1, z1);
              SOLARCHVISION_OBJprintVertex(x2, y2, z2);
              SOLARCHVISION_OBJprintVertex(x3, y3, z3);
              SOLARCHVISION_OBJprintVertex(x4, y4, z4);

              num_vertices_added += 4;
            }

            if (_turn == 2) {

              SOLARCHVISION_OBJprintVtexture(0, 1 - ratio, 0);
              SOLARCHVISION_OBJprintVtexture(1, 1 - ratio, 0);
              SOLARCHVISION_OBJprintVtexture(1, 1, 0);
              SOLARCHVISION_OBJprintVtexture(0, 1, 0);
            }

            if (_turn == 3) {

              int q = (back_front + 1) / 2;

              String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
              String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
              String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
              String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 4, 0);

              String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
              String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
              String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 4, 0);      

              if (objExport_PolyToPoly == 0) {
                obj_lastGroupNumber += 1;
                objOutput.println("g Object2D_" + nf(f, 0) + "_hor" + nf(q, 0));
              } 

              obj_lastFaceNumber += 1;            
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              if (objExport_BackSides != 0) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
              }
            }
          }
        }
      }
    }
  }


  if (Display_Model3Ds != 0) {



    int Create_Face_Texture = 0;

    if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solid) || (WIN3D_FacesShade == Shade_Vertex_Elevation)) {
      Create_Face_Texture = 1;
    }

    if (Create_Face_Texture == 0) {

      if (objExport_MaterialLibrary != 0) {

        int[] Materials_Used = new int [Materials_Number];

        for (int i = 0; i < Materials_Used.length; i++) {
          Materials_Used[i] = 0;
        }

        for (int f = 1; f < allFaces_PNT.length; f++) {

          int mt = allFaces_MTLV[f][0];

          Materials_Used[mt] += 1;
        }    

        for (int mt = 0; mt < Materials_Number; mt++) {

          if (Materials_Used[mt] != 0) {

            float a = Materials_Color[mt][0] / 255.0; 
            float r = Materials_Color[mt][1] / 255.0; 
            float g = Materials_Color[mt][2] / 255.0; 
            float b = Materials_Color[mt][3] / 255.0; 

            mtlOutput.println("newmtl SurfaceMaterial_" + nf(mt, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // ambient
            mtlOutput.println("\tKd " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td " + nf(a, 0, 3)); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr " + nf(a, 0, 3)); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
        }
      }


      for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

        if (allGroup3Ds_Faces[OBJ_NUM][0] <= allGroup3Ds_Faces[OBJ_NUM][1]) {

          for (int back_or_front = 1 - objExport_BackSides; back_or_front <= 1; back_or_front++) {

            num_vertices_added = 0;

            for (int _turn = 1; _turn < 4; _turn += 1) {

              if (_turn == 3) {
                if (objExport_PolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }
              }  

              int prev_mt = -1;

              for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {

                if (_turn == 3) {
                  if (objExport_MaterialLibrary != 0) {
                    int mt = allFaces_MTLV[f][0];
                    if (prev_mt != mt) {
                      objOutput.println("usemtl SurfaceMaterial_" + nf(mt, 0));
                      prev_mt = mt;
                    }
                  }
                }                  

                int Tessellation = allFaces_MTLV[f][1];

                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_Tessellation;
                }

                if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
                for (int j = 0; j < allFaces_PNT[f].length; j++) {
                  int vNo = allFaces_PNT[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }

                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                  for (int s = 0; s < subFace.length; s++) {

                    if (_turn == 1) {
                      SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                    }

                    if (_turn == 2) {

                      float t = PI / float(subFace.length);

                      float u = 0.5 * cos((2 * s + 1) * t) / cos(t) + 0.5;
                      float v = 0.5 * sin((2 * s + 1) * t) / cos(t) + 0.5;

                      SOLARCHVISION_OBJprintVtexture(u, v, 0);
                    }
                  }


                  if (_turn == 3) {

                    num_vertices_added += subFace.length;

                    if (objExport_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }                    

                    obj_lastFaceNumber += 1;

                    objOutput.print("f ");
                    if (back_or_front == 1) {
                      for (int s = 0; s < subFace.length; s++) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s < subFace.length - 1) {
                          objOutput.print(" ");
                        }
                      }
                    } else {
                      for (int s = subFace.length - 1; s >= 0; s--) {
                        String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                        String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                        objOutput.print(n_txt + "/" + m_txt);
                        if (s > 0) {
                          objOutput.print(" ");
                        }
                      }
                    }
                    objOutput.println("");
                  }
                }
              }
            }

            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;
          }
        }
      }
    } else {

      int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
      int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
      float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 

      String the_filename = "";
      String TEXTURE_path = "";

      if (objExport_MaterialLibrary != 0) {
        if (objExport_UsePalletOrBakeFaces == 0) {
          the_filename = "shade_Pallet.bmp";

          TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

          println("Saving texture:", TEXTURE_path);

          int RES1 = objExport_PalletResolution; 
          int RES2 = objExport_PalletResolution / 16;      

          PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


          Pallet_Texture.loadPixels();

          for (int np = 0; np < (RES1 * RES2); np++) {
            int Image_X = np % RES1;
            int Image_Y = np / RES1;

            float _val = (Image_X / (0.5 * RES1)) - 1; 

            float _u = 0.5 + _val;

            if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {
              if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
            }            

            float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  

            Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
          }

          Pallet_Texture.updatePixels();   

          Pallet_Texture.save(TEXTURE_path);      


          mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

          //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
        }
      }


      for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

        if (allGroup3Ds_Faces[OBJ_NUM][0] <= allGroup3Ds_Faces[OBJ_NUM][1]) {

          int Number_Of_Face_Subdivisions = 0; // for combined materials we need to know this number before baking each object.

          if (objExport_UsePalletOrBakeFaces == 1) {

            if (objExport_MaterialLibrary != 0) {

              for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {

                int Tessellation = allFaces_MTLV[f][1];

                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_Tessellation;
                }


                if ((allFaces_PNT[f].length != 4) && (Tessellation == 0)) {
                  Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
                }

                if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                for (int n = 0; n < TotalSubNo; n++) {

                  Number_Of_Face_Subdivisions += 1;
                }
              }
            }

            println("Number_Of_Face_Subdivisions", Number_Of_Face_Subdivisions);
          }



          for (int back_or_front = 1 - objExport_BackSides; back_or_front <= 1; back_or_front++) {

            PGraphics[] Face_Texture = new PGraphics [1 + Number_Of_Face_Subdivisions];

            num_vertices_added = 0;

            if (objExport_MaterialLibrary != 0) {
              if (objExport_UsePalletOrBakeFaces == 1) {
                if (objExport_CombinedMaterial == 1) {            

                  the_filename = "Combined_Texture" + "_obj" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + ".bmp";

                  TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

                  println("Combined texture:", TEXTURE_path);

                  mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                  mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                  mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                  mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                  mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                  mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                  mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                  mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                  mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                  mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

                  //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
                }
              }
            }         

            for (int _turn = 1; _turn < 4; _turn += 1) {

              int CurrentFaceTextureNumber = -1;

              if (_turn == 3) {

                if (objExport_PolyToPoly == 1) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                }

                if (objExport_MaterialLibrary != 0) {
                  if (objExport_CombinedMaterial == 1) { 
                    objOutput.println("usemtl " +  the_filename.replace('.', '_'));
                  }
                }
              }  

              for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {

                int Tessellation = allFaces_MTLV[f][1];

                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_Tessellation;
                }


                if ((allFaces_PNT[f].length != 4) && (Tessellation == 0)) {
                  Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
                }

                if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                float x3 = 0;
                float y3 = 0;
                float z3 = 0;

                float x4 = 0;
                float y4 = 0;
                float z4 = 0;

                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
                for (int j = 0; j < allFaces_PNT[f].length; j++) {
                  int vNo = allFaces_PNT[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }

                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                  CurrentFaceTextureNumber += 1;

                  if (_turn == 1) {   

                    if (objExport_MaterialLibrary != 0) {


                      if (objExport_UsePalletOrBakeFaces == 1) {
                        if (objExport_CombinedMaterial == 0) { 
                          the_filename = "Face_Texture" + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0) + ".jpg";

                          TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

                          println("Baking texture:", TEXTURE_path);
                        }
                      }

                      int RES1 = objExport_BakingResolution;
                      int RES2 = objExport_BakingResolution;                      

                      if (objExport_UsePalletOrBakeFaces == 1) {
                        Face_Texture[CurrentFaceTextureNumber] = createGraphics(RES1, RES2, P2D);

                        Face_Texture[CurrentFaceTextureNumber].beginDraw();
                      }



                      if (objExport_UsePalletOrBakeFaces == 1) {
                        Face_Texture[CurrentFaceTextureNumber].noStroke();
                        Face_Texture[CurrentFaceTextureNumber].beginShape(QUADS);
                      }

                      for (int s = 0; s < subFace.length; s++) {

                        float[] COL = {
                          255, 255, 255, 255
                        };

                        if (objExport_UsePalletOrBakeFaces == 1) {

                          if (WIN3D_FacesShade == Shade_Global_Solar) {
                            int s_next = (s + 1) % subFace.length;
                            int s_prev = (s + subFace.length - 1) % subFace.length;

                            if (back_or_front == 0) {
                              int s_temp = s_next;
                              s_next = s_prev;
                              s_prev = s_temp;
                            }

                            COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }              

                          if (WIN3D_FacesShade == Shade_Vertex_Solid) {

                            COL = SOLARCHVISION_vertexRender_Shade_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }                  

                          if (WIN3D_FacesShade == Shade_Vertex_Elevation) {

                            COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }

                          Face_Texture[CurrentFaceTextureNumber].fill(COL[1], COL[2], COL[3], COL[0]);
                        }

                        if (s == 0) {
                          if (objExport_UsePalletOrBakeFaces == 1) {
                            Face_Texture[CurrentFaceTextureNumber].vertex(0, 0);
                          }
                          x1 = subFace[s][0];
                          y1 = subFace[s][1];
                          z1 = subFace[s][2];
                        }
                        if (s == 1) {
                          if (objExport_UsePalletOrBakeFaces == 1) {
                            Face_Texture[CurrentFaceTextureNumber].vertex(RES1, 0);
                          }
                          x2 = subFace[s][0];
                          y2 = subFace[s][1];
                          z2 = subFace[s][2];
                        }            
                        if (s == 2) { 
                          if (objExport_UsePalletOrBakeFaces == 1) {
                            Face_Texture[CurrentFaceTextureNumber].vertex(RES1, RES2);
                          }
                          x3 = subFace[s][0];
                          y3 = subFace[s][1];
                          z3 = subFace[s][2];
                        }          
                        if (s == 3) {
                          if (objExport_UsePalletOrBakeFaces == 1) {
                            Face_Texture[CurrentFaceTextureNumber].vertex(0, RES2);
                          }
                          x4 = subFace[s][0];
                          y4 = subFace[s][1];
                          z4 = subFace[s][2];
                        }
                      }

                      if (objExport_UsePalletOrBakeFaces == 1) {

                        //Face_Texture[CurrentFaceTextureNumber].endShape(CLOSE);
                        Face_Texture[CurrentFaceTextureNumber].endShape();

                        Face_Texture[CurrentFaceTextureNumber].endDraw();

                        if (objExport_CombinedMaterial == 0) {
                          Face_Texture[CurrentFaceTextureNumber].save(TEXTURE_path);

                          mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

                          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

                          //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
                          mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
                        }
                      }
                    }

                    SOLARCHVISION_OBJprintVertex(x1, y1, z1);
                    SOLARCHVISION_OBJprintVertex(x2, y2, z2);
                    SOLARCHVISION_OBJprintVertex(x3, y3, z3);
                    SOLARCHVISION_OBJprintVertex(x4, y4, z4);
                  }

                  if (_turn == 2) {

                    float u1 = 0;
                    float v1 = 1;

                    float u2 = 1;
                    float v2 = 1;

                    float u3 = 1;
                    float v3 = 0;

                    float u4 = 0;
                    float v4 = 0;

                    if (objExport_CombinedMaterial == 1) {

                      if (objExport_UsePalletOrBakeFaces == 1) {

                        // also considering two pixles added to the left and right

                        u1 = (CurrentFaceTextureNumber * (2 + objExport_BakingResolution) + 1) / float(Number_Of_Face_Subdivisions * (2 + objExport_BakingResolution));
                        v1 = 1;

                        u2 = (CurrentFaceTextureNumber * (2 + objExport_BakingResolution) + objExport_BakingResolution + 1) / float(Number_Of_Face_Subdivisions * (2 + objExport_BakingResolution));
                        v2 = 1;

                        u3 = u2;
                        v3 = 0;

                        u4 = u1;
                        v4 = 0;
                      } else { 

                        for (int s = 0; s < subFace.length; s++) {

                          float _u = 0;

                          if (WIN3D_FacesShade == Shade_Global_Solar) {
                            int s_next = (s + 1) % subFace.length;
                            int s_prev = (s + subFace.length - 1) % subFace.length;

                            if (back_or_front == 0) {
                              int s_temp = s_next;
                              s_next = s_prev;
                              s_prev = s_temp;
                            }

                            _u = SOLARCHVISION_vertexU_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }              

                          if (WIN3D_FacesShade == Shade_Vertex_Solid) {

                            _u = SOLARCHVISION_vertexU_Shade_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }                  

                          if (WIN3D_FacesShade == Shade_Vertex_Elevation) {

                            _u = SOLARCHVISION_vertexU_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                          }


                          float u0 = 0.5 * (_u + 0.5);

                          if (WIN3D_FacesShade == Shade_Global_Solar) {
                            if (Impact_TYPE == Impact_ACTIVE) {
                              u0 = _u;
                            }
                          }


                          if (u0 > 0.999) u0 = 0.999;
                          if (u0 < 0.001) u0 = 0.001;


                          if (s == 0) {
                            u1 = u0;
                            v1 = 0;
                          }
                          if (s == 1) {
                            u2 = u0;
                            v2 = 0;
                          }            
                          if (s == 2) { 
                            u3 = u0;
                            v3 = 0;
                          }          
                          if (s == 3) {
                            u4 = u0;
                            v4 = 0;
                          }
                        }
                      }
                    }

                    SOLARCHVISION_OBJprintVtexture(u1, v1, 0);
                    SOLARCHVISION_OBJprintVtexture(u2, v2, 0);
                    SOLARCHVISION_OBJprintVtexture(u3, v3, 0);
                    SOLARCHVISION_OBJprintVtexture(u4, v4, 0);
                  }

                  if (_turn == 3) {

                    num_vertices_added += 4;

                    if (objExport_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                    }

                    if (objExport_MaterialLibrary != 0) {
                      if (objExport_CombinedMaterial == 0) {
                        objOutput.println("usemtl " +  the_filename.replace('.', '_'));
                      }
                    }

                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

                    obj_lastFaceNumber += 1;
                    if (back_or_front == 1) {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    } else {
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }
              }
            }


            if (objExport_MaterialLibrary != 0) {

              if (objExport_UsePalletOrBakeFaces == 1) {

                if (objExport_CombinedMaterial == 1) {            

                  int RES1 = (2 + objExport_BakingResolution) * Number_Of_Face_Subdivisions; // adding two pixels to left and right as margin
                  int RES2 = objExport_BakingResolution;      

                  PGraphics Combined_Texture = createGraphics(RES1, RES2, P2D);          

                  Combined_Texture.beginDraw();

                  for (int i = 0; i < Number_Of_Face_Subdivisions; i++) {

                    int w = Face_Texture[i].width;
                    int h = Face_Texture[i].height;

                    Combined_Texture.image(Face_Texture[i], i * (2 + objExport_BakingResolution), 0, w + 2, h); // first stretching the image by 2 pixel below!
                    Combined_Texture.image(Face_Texture[i], i * (2 + objExport_BakingResolution) + 1, 0); // then adding the original on top.
                  }

                  Combined_Texture.endDraw();

                  Combined_Texture.save(TEXTURE_path);
                }
              }
            }            

            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;
          }
        }
      }
    }
  }




  if (Display_Fractals != 0) {

    if (objExport_MaterialLibrary != 0) {

      if (allFractals_num != 0) {

        mtlOutput.println("newmtl " + "Fractal_Trunk");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 0.750 0.500"); // ambient
        mtlOutput.println("\tKd 1.000 0.750 0.500"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter


        mtlOutput.println("newmtl " + "Fractal_Leaf");
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 0.500 0.750 0.250"); // ambient
        mtlOutput.println("\tKd 0.500 0.750 0.250"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      }
    }


    for (int f = 1; f <= allFractals_num; f++) {

      float x = allFractals_XYZSR[f][0];
      float y = allFractals_XYZSR[f][1];
      float z = allFractals_XYZSR[f][2];

      float r = allFractals_XYZSR[f][3] * 0.5;
      float rot = allFractals_XYZSR[f][4];

      int n = allFractals_Type[f];

      int dMin = allFractals_DegreeMin[f];

      int dMax = allFractals_DegreeMax[f];

      int s = allFractals_Seed[f];

      float TrunkSize = allFractals_TrunkSize[f];

      float LeafSize = allFractals_LeafSize[f];

      randomSeed(s);

      if (n == 0) {

        num_vertices_added = 0;

        if (objExport_PolyToPoly == 1) {
          obj_lastGroupNumber += 1;
          objOutput.println("g Fractal_" + nf(f, 0));
        }    

        float Alpha = 0;
        float Beta = rot; 

        for (int _turn = 1; _turn < 4; _turn += 1) {
          SOLARCHVISION_Plant_branch_objExport_(_turn, x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);
        }

        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }
    }
  }  



  if (Display_WindFlow != 0) {  

    int PAL_TYPE = WindFlow_Pallet_CLR; 
    int PAL_DIR = WindFlow_Pallet_DIR; 
    float PAL_Multiplier = WindFlow_Pallet_MLT;

    String the_filename = "";

    if (objExport_MaterialLibrary != 0) {

      the_filename = "WindFlow_Pallet.bmp";

      String TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

      println("Saving texture:", TEXTURE_path);

      int RES1 = objExport_PalletResolution; 
      int RES2 = objExport_PalletResolution / 16;       

      PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


      Pallet_Texture.loadPixels();

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;

        float _val = (Image_X / (0.5 * RES1)) - 1; 

        float _u = 0.5 + 0.5 * _val;

        float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  

        Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
      }

      Pallet_Texture.updatePixels();   

      Pallet_Texture.save(TEXTURE_path);      


      mtlOutput.println("newmtl " + "WindFlow");
      mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
      mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
      mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
      mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
      mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
      mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

      mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
      mtlOutput.println("\tTr 1.000"); //  0-1 transparency
      mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

      //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
      mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
    }    

    num_vertices_added = 0;

    for (int _turn = 1; _turn < 4; _turn += 1) {    

      if (_turn == 3) {
        obj_lastGroupNumber += 1;
        objOutput.println("g WindFlow");

        if (objExport_MaterialLibrary != 0) {
          objOutput.println("usemtl WindFlow");
        }
      }        

      for (int q = 1; q < WindFlow_Lines.length; q++) {

        int n1 = WindFlow_Lines[q][0];
        int n2 = WindFlow_Lines[q][1];

        float x1 = WindFlow_Vertices[n1][0];
        float y1 = WindFlow_Vertices[n1][1];
        float z1 = WindFlow_Vertices[n1][2];

        float x2 = WindFlow_Vertices[n2][0];
        float y2 = WindFlow_Vertices[n2][1];
        float z2 = WindFlow_Vertices[n2][2];


        float _val = WindFlow_Pallet_MLT * WindFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

        float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float the_dist = dist(x1, y1, z1, x2, y2, z2);

        float[] W = {
          x2 - x1, y2 - y1, z2 - z1
        };
        W = SOLARCHVISION_fn_normalize(W);

        float Alpha = asin_ang(W[2]);
        float Beta = atan2_ang(W[1], W[0]) + 90;   


        if (_turn == 1) {

          SOLARCHVISION_OBJprintVertex(x1, y1, z1);
          SOLARCHVISION_OBJprintVertex(x2, y2, z2);

          for (int i = 0; i < 4; i++) {

            float px = 0.1 * the_dist * cos(i * HALF_PI);
            float py = 0;
            float pz = 0.1 * the_dist * sin(i * HALF_PI); 

            float pz_rot = pz;
            float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
            float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  

            px = px_rot;
            py = py_rot;
            pz = pz_rot;

            px_rot = px;
            py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
            pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);

            px = px_rot;
            py = py_rot;
            pz = pz_rot;    

            SOLARCHVISION_OBJprintVertex(x1, y1, z1);
          }
        }


        if (_turn == 2) {
          for (int i = 0; i < 6; i++) {

            float u1 = 0.5 * (_u + 0.5);

            if (u1 > 0.999) u1 = 0.999;
            if (u1 < 0.001) u1 = 0.001;

            SOLARCHVISION_OBJprintVtexture(u1, 0, 0);
          }
        }

        if (_turn == 3) {
          num_vertices_added += 6;

          String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 5, 0); 
          String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 4, 0);
          String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
          String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
          String n5_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
          String n6_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

          String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 5, 0); 
          String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 4, 0);
          String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
          String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
          String m5_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
          String m6_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n4_txt + "/" + m4_txt + " " + n5_txt + "/" + m5_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n5_txt + "/" + m5_txt + " " + n6_txt + "/" + m6_txt);
          objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n6_txt + "/" + m6_txt + " " + n3_txt + "/" + m3_txt);

          obj_lastFaceNumber += 4;
        }
      }
    }

    obj_lastVertexNumber += num_vertices_added;
    obj_lastVtextureNumber += num_vertices_added;
  }


  if (Display_SKY3D != 0) {

    if (WIN3D_FacesShade == Shade_Global_Solar) {

      int PAL_TYPE = 0; 
      int PAL_DIR = 1;
      float PAL_Multiplier = 1; 

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = SKY3D_Pallet_ACTIVE_CLR; 
        PAL_DIR = SKY3D_Pallet_ACTIVE_DIR;  
        PAL_Multiplier = 1.0 * SKY3D_Pallet_ACTIVE_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_TYPE = SKY3D_Pallet_PASSIVE_CLR; 
        PAL_DIR = SKY3D_Pallet_PASSIVE_DIR;  
        PAL_Multiplier = 0.05 * SKY3D_Pallet_PASSIVE_MLT;
      }             



      String the_filename = "";
      String TEXTURE_path = "";  

      if (objExport_MaterialLibrary != 0) {

        the_filename = "skyPattern_Pallet.bmp";

        TEXTURE_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

        println("Saving texture:", TEXTURE_path);

        int RES1 = objExport_PalletResolution; 
        int RES2 = objExport_PalletResolution / 16;      

        PImage Pallet_Texture = createImage(RES1, RES2, ARGB);       


        Pallet_Texture.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float _val = (Image_X / (0.5 * RES1)) - 1; 

          float _u = 0.5 + _val;

          if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;

          float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  

          Pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }

        Pallet_Texture.updatePixels();   

        Pallet_Texture.save(TEXTURE_path);      


        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter

        //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map
      }      

      obj_lastGroupNumber += 1;
      objOutput.println("g skyPattern");

      if (objExport_MaterialLibrary != 0) {      
        objOutput.println("usemtl " +  the_filename.replace('.', '_'));
      }      

      num_vertices_added = 0;

      for (int _turn = 1; _turn < 4; _turn += 1) {

        for (int f = 1; f < skyFaces.length; f++) {

          int Tessellation = 0;

          int TotalSubNo = 1;  
          Tessellation = SKY3D_TESSELLATION;
          if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

          float[][] base_Vertices = new float [skyFaces[f].length][3];
          for (int j = 0; j < skyFaces[f].length; j++) {
            int vNo = skyFaces[f][j];
            base_Vertices[j][0] = skyVertices[vNo][0];
            base_Vertices[j][1] = skyVertices[vNo][1];
            base_Vertices[j][2] = skyVertices[vNo][2];
          }

          for (int n = 0; n < TotalSubNo; n++) {

            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

            for (int j = 0; j < subFace.length; j++) {
              subFace[j] = SOLARCHVISION_fn_normalize(subFace[j]);
            }



            for (int s = 0; s < subFace.length; s++) {

              int s_next = (s + 1) % subFace.length;
              int s_prev = (s + subFace.length - 1) % subFace.length;

              //if ((subFace[s][2] > -0.2) && (subFace[s_prev][2] > -0.2) && (subFace[s_next][2] > -0.2)) // to remove below
              { 

                float x = subFace[s][0] * SKY3D_scale * WIN3D_Scale3D;
                float y = subFace[s][1] * SKY3D_scale * WIN3D_Scale3D;
                float z = subFace[s][2] * SKY3D_scale * WIN3D_Scale3D;

                float _u = SOLARCHVISION_vertexU_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);


                if (_turn == 1) {

                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }

                if (_turn == 2) { 
                  float u1 = 0.5 * (_u + 0.5);

                  if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) { 
                    if  (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                  }

                  if (u1 > 0.999) u1 = 0.999;
                  if (u1 < 0.001) u1 = 0.001;

                  SOLARCHVISION_OBJprintVtexture(u1, 0, 0);
                }

                if (_turn == 3) {
                  num_vertices_added += 1;
                }
              }
            }

            if (_turn == 3) {
              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);  
              if (objExport_BackSides != 0) {
                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              }
            }
          }
        }
      }

      obj_lastVertexNumber += num_vertices_added;
      obj_lastVtextureNumber += num_vertices_added;
    }
  }


  if (Display_SUN3D_Pattern != 0) {

    float keep_STUDY_PerDays = STUDY_PerDays;
    int keep_STUDY_JoinDays = STUDY_JoinDays;
    if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
      STUDY_PerDays = 1;
      STUDY_JoinDays = 1;
    }    

    float previous_DATE = TIME_Date;

    SOLARCHVISION_draw_SunPathCycles(0, 0, 0, 0.975 * SKY3D_scale, 0.975 * SKY3D_scale, 0.975 * SKY3D_scale, STUDY_ImpactLayer, 4);

    STUDY_PerDays = keep_STUDY_PerDays;
    STUDY_JoinDays = keep_STUDY_JoinDays; 
    TIME_Date = previous_DATE;
    SOLARCHVISION_update_date();
  }

  if (objExport_MaterialLibrary != 0) {
    mtlOutput.flush(); 
    mtlOutput.close();
  }

  objOutput.flush(); 
  objOutput.close();   


  println("End of exporting the mesh."); 

  SOLARCHVISION_explore_output(objFilename);
}

void SOLARCHVISION_OBJprintVertex (float x, float y, float z) {

  float a = x * objExport_Scale;
  float b = y * objExport_Scale;
  float c = z * objExport_Scale;

  if (objExport_FlipZYaxis == 0) {

    objOutput.println("v " + nf(a, 0, objExport_PrecisionVertex) + " " +  nf(b, 0, objExport_PrecisionVertex) + " " +  nf(c, 0, objExport_PrecisionVertex));
  } else {

    objOutput.println("v " + nf(-a, 0, objExport_PrecisionVertex) + " " +  nf(c, 0, objExport_PrecisionVertex) + " " +  nf(b, 0, objExport_PrecisionVertex));
  }
}



void SOLARCHVISION_OBJprintVtexture (float u, float v, float w) {

  objOutput.println("vt " + nf(u, 0, objExport_PrecisionVtexture) + " " + nf(v, 0, objExport_PrecisionVtexture) + " " + nf(w, 0, objExport_PrecisionVtexture));
}  





void SOLARCHVISION_import_objects_OBJ (String FileName, int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float sx, float sy, float sz) {

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  int[] importVerticeNumber = {
    0
  };

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  float Progress = 0;

  for (int f = 0; f < FileALL.length; f += 1) {

    if (10 + Progress < 100 * f / float(FileALL.length)) { 
      Progress = 100 * f / float(FileALL.length);
      println("Progress:", int(Progress), "%");
    }

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("g")) {
      if (m == -1) defaultMaterial = 1 + (defaultMaterial % 8);

      if (addToLastGroup3D == 0) SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      int[] v = {
        SOLARCHVISION_add_Vertex(x, y, z)
      };

      importVerticeNumber = concat(importVerticeNumber, v);
    }

    if (parts[0].toLowerCase().equals("f")) {

      //println(parts);

      int FaceDegree = parts.length - 1; // if we don't have space at the end of the line.

      if (parts[FaceDegree].equals("")) {  // if we have 1 space at the end of the line.
        FaceDegree -= 1;
      }

      int[] newFace = new int [FaceDegree]; 

      for (int n = 0; n < newFace.length; n += 1) {

        String[] the_numbers = split(parts[n + 1], '/');

        int vertexNumber = int(the_numbers[0]);

        if (vertexNumber > 0) {
          newFace[n] = importVerticeNumber[vertexNumber];
        } else if (vertexNumber < 0) { // for negative numbering
          newFace[n] = allVertices.length - abs(vertexNumber);
        } else { // case 0
        }
      }

      //println(newFace);

      SOLARCHVISION_add_Face(newFace);
    }
  }

  println("Progress: 100 %");
}  


float SOLARCHVISION_import_objects_asParametricBox_OBJ (String FileName, int m, float cx, float cy, float cz, float sx, float sy, float sz) {

  float[][] importVertices = {
    {
    }
  };

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f += 1) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      float[][] v = {
        {
          x, y, z
        }
      };

      importVertices = (float[][]) concat(importVertices, v);
    }
  }

  float min_X = FLOAT_undefined;
  float max_X = -FLOAT_undefined;
  float min_Y = FLOAT_undefined;
  float max_Y = -FLOAT_undefined;
  float min_Z = FLOAT_undefined;
  float max_Z = -FLOAT_undefined;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    if (min_X > x) min_X = x;
    if (max_X < x) max_X = x;
    if (min_Y > y) min_Y = y;
    if (max_Y < y) max_Y = y;
    if (min_Z > z) min_Z = z;
    if (max_Z < z) max_Z = z;
  }

  float cen_X = 0.5 * (min_X + max_X);
  float cen_Y = 0.5 * (min_Y + max_Y);
  float cen_Z = 0.5 * (min_Z + max_Z);

  float R_out = 0;
  float X_out = 0;
  float Y_out = 0;
  float Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    float r = dist(cen_X, cen_Y, cen_Z, x, y, z);

    if (R_out < r) {
      R_out = r;

      X_out = x;
      Y_out = y;
      Z_out = z;
    }
  }  

  float T_out = atan2_ang(Y_out, X_out);

  X_out = 0;
  Y_out = 0;
  Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = (importVertices[vNo][0] - cen_X) * cos_ang(-T_out) - (importVertices[vNo][1] - cen_Y) * sin_ang(-T_out);
    float y = (importVertices[vNo][0] - cen_X) * sin_ang(-T_out) + (importVertices[vNo][1] - cen_Y) * cos_ang(-T_out);
    float z = importVertices[vNo][2];

    if (X_out < abs(x)) X_out = abs(x);
    if (Y_out < abs(y)) Y_out = abs(y);
    if (Z_out < abs(z)) Z_out = abs(z);
  }  

  //SOLARCHVISION_add_Box_Core(m, cen_X,cen_Y,cen_Z, X_out,Y_out,Z_out, T_out);
  SOLARCHVISION_add_Solid(cen_X, cen_Y, cen_Z, CubePower, CubePower, CubePower, X_out, Y_out, Z_out, 0, 0, T_out, 1);

  return min_Z;
}  




void SOLARCHVISION_add_Object2Ds_onLand (int people_or_trees) {


  println("SOLARCHVISION_add_Object2Ds_onLand");

  randomSeed(0);

  float[][] treesXYZS = {
    {
      0, 0, 0, 0
    }
  };

  int Tessellation = LAND_TESSELLATION;
  if (WIN3D_FacesShade == Shade_Surface_Base) {
    Tessellation = 0;
  }

  int TotalSubNo = 1;  
  if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.



  if ((Display_LAND_Texture != 0) && (people_or_trees != 1)) { // using another algorithm for people << i.e. no image processing from green colors of the map!

    for (int i = Skip_LAND_MESH_Center; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {

        float[][] base_Vertices = new float [4][3];

        base_Vertices[0][0] = LAND_MESH[i][j][0];
        base_Vertices[0][1] = LAND_MESH[i][j][1];
        base_Vertices[0][2] = LAND_MESH[i][j][2];

        base_Vertices[1][0] = LAND_MESH[i+1][j][0];
        base_Vertices[1][1] = LAND_MESH[i+1][j][1];
        base_Vertices[1][2] = LAND_MESH[i+1][j][2];

        base_Vertices[2][0] = LAND_MESH[i+1][j+1][0];
        base_Vertices[2][1] = LAND_MESH[i+1][j+1][1];
        base_Vertices[2][2] = LAND_MESH[i+1][j+1][2];

        base_Vertices[3][0] = LAND_MESH[i][j+1][0];
        base_Vertices[3][1] = LAND_MESH[i][j+1][1];
        base_Vertices[3][2] = LAND_MESH[i][j+1][2];

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

          int n_Map = 0; 
          for (int q = 1; q <= LAND_Texture_num; q++) { // increase the resolution until all the vertices located inside the appropriate map

            n_Map = q; 

            for (int s = 0; s < subFace.length; s++) {

              float u = (subFace[s][0] / LAND_Texture_scale_U[q] + 0.5);
              float v = (-subFace[s][1] / LAND_Texture_scale_V[q] + 0.5);

              if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {

                n_Map = 0;

                break;
              }
            }            

            if (n_Map == q) break;
          }

          if (n_Map != 0) {

            int max_o = int(10000 / pow(2, LAND_TESSELLATION)); // number of tries to find green points!

            //if (max_o > 100) max_o = 100;

            if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
            //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
            //if (i < 4) max_o = 0; // <<<<<<< do not create at near distances <<<<<<<<<<<<<<<

            for (int o = 0; o < max_o; o += 1) {

              float di = random(1);
              float dj = random(1);

              float x = SOLARCHVISION_Bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
              float y = SOLARCHVISION_Bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
              float z = SOLARCHVISION_Bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);

              float u = (x / LAND_Texture_scale_U[n_Map] + 0.5);
              float v = (-y / LAND_Texture_scale_V[n_Map] + 0.5);

              int uSTUDY_Pixel = int(u * LAND_Texture_Map[n_Map].width);
              int vSTUDY_Pixel = int(v * LAND_Texture_Map[n_Map].height);

              color COL = LAND_Texture_Map[n_Map].get(uSTUDY_Pixel, vSTUDY_Pixel);
              //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              float r = COL >> 16 & 0xFF; 
              float g = COL >> 8 & 0xFF;
              float b = COL & 0xFF;

              //if ((g > r + 8) && (g > b + 16)) { // looks more green
              if ((g > r - 4) && (g > b + 16)) { // looks more green, slightly red is acceptible

                if (g < 56) { // not on grass (light green) 

                  //if (z + LocationElevation > 5) { // not in water (below see level)

                  //float s = 5 + random(10); 
                  float s = 5 + random(12.5);
                  //float s = 10 + random(20); // bigger trees        

                  int foundNearTree = 0;

                  for (int f = 1; f < treesXYZS.length; f++) {

                    float x0 = treesXYZS[f][0];
                    float y0 = treesXYZS[f][1];
                    float z0 = treesXYZS[f][2];
                    float s0 = treesXYZS[f][3];

                    //if (dist(x0, y0, z0, x, y, z) < 0.25 * (s0 + s)) { //avoids creating trees close to each other 
                    if (dist(x0, y0, z0, x, y, z) < 0.5 * (s0 + s)) { //avoids creating trees close to each other
                      foundNearTree = 1;

                      break;
                    }
                  }

                  if (foundNearTree == 0) {

                    if (people_or_trees == 2) {
                      SOLARCHVISION_add_Object2D_single("TREES", 0, x, y, z, s);
                    } else {
                      SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, s, random(360), CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
                    }                  


                    float[][] newTree = {
                      {
                        x, y, z, s
                      }
                    };
                    treesXYZS = (float [][]) concat(treesXYZS, newTree);
                  }
                  //}
                }
              }
            }
          }
        }
      }
    }
  } else {

    for (int i = Skip_LAND_MESH_Center; i < LAND_n_I - 1; i += 1) {
      for (int j = 0; j < LAND_n_J - 1; j += 1) {

        float[][] base_Vertices = new float [4][3];

        base_Vertices[0][0] = LAND_MESH[i][j][0];
        base_Vertices[0][1] = LAND_MESH[i][j][1];
        base_Vertices[0][2] = LAND_MESH[i][j][2];

        base_Vertices[1][0] = LAND_MESH[i+1][j][0];
        base_Vertices[1][1] = LAND_MESH[i+1][j][1];
        base_Vertices[1][2] = LAND_MESH[i+1][j][2];

        base_Vertices[2][0] = LAND_MESH[i+1][j+1][0];
        base_Vertices[2][1] = LAND_MESH[i+1][j+1][1];
        base_Vertices[2][2] = LAND_MESH[i+1][j+1][2];

        base_Vertices[3][0] = LAND_MESH[i][j+1][0];
        base_Vertices[3][1] = LAND_MESH[i][j+1][1];
        base_Vertices[3][2] = LAND_MESH[i][j+1][2];      

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

          int max_o = int((16.0 / pow(2, LAND_TESSELLATION)) * pow(random(1), 8)); // i.e. maximum 3 people in each pixel for tes=2


          if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
          //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<

          for (int o = 0; o < max_o; o += 1) {

            float di = random(1);
            float dj = random(1);

            float x = SOLARCHVISION_Bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
            float y = SOLARCHVISION_Bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
            float z = SOLARCHVISION_Bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);

            if (z + LocationElevation > 0) { // i.e. above sea level 

              if (dist(x, y, 0, 0) > 10.0) { // i.e. No 2D at the center!

                if (people_or_trees == 1) {
                  SOLARCHVISION_add_Object2D_single("PEOPLE", 0, x, y, z, 2.5);
                } else if (people_or_trees == 2) {
                  SOLARCHVISION_add_Object2D_single("TREES", 0, x, y, z, 5 + random(10));
                } else {
                  SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, 5 + random(10), random(360), CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
                }
              }
            }
          }
        }
      }
    }
  }
}

void SOLARCHVISION_add_Object2Ds_polar (int people_or_trees, int n, float x0, float y0, float z0, float r1, float r2) {

  for (int i = 0; i < n; i += 1) {

    float a = random(360);
    float b = pow(random(pow(r1, 2), pow(r2, 2)), 0.5); // to make it uniform on the surface

    float x = x0 + b * cos_ang(a);
    float y = y0 + b * sin_ang(a);
    float z = z0;

    if (people_or_trees == 1) {
      SOLARCHVISION_add_Object2D_single("PEOPLE", 0, x, y, z, 2.5);
    } else if (people_or_trees == 2) {
      SOLARCHVISION_add_Object2D_single("TREES", 0, x, y, z, 5 + random(10));
    } else {
      SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, 5 + random(10), random(360), CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
    }
  }
}

void SOLARCHVISION_add_Object2Ds_plane (int people_or_trees, int n, float x0, float y0, float z0, float rx, float ry) {

  for (int i = 0; i < n; i += 1) {

    //float a = random(-rx, rx); 
    //float b = random(-ry, ry);

    // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
    float a = random(1-rx, rx-1);  
    float b = random(1-ry, ry-1);

    float x = x0 + a;
    float y = y0 + b;
    float z = z0;

    if (people_or_trees == 1) {
      SOLARCHVISION_add_Object2D_single("PEOPLE", 0, x, y, z, 2.5);
    } else if (people_or_trees == 2) {
      SOLARCHVISION_add_Object2D_single("TREES", 0, x, y, z, 5 + random(10));
    } else {
      SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, 5 + random(10), random(360), CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
    }
  }
}

void SOLARCHVISION_add_Object2Ds_Mesh2 (int people_or_trees, int n, float x1, float y1, float z1, float x2, float y2, float z2) {

  float x0 = 0.5 * (x1 + x2);
  float y0 = 0.5 * (y1 + y2);
  float z0 = 0.5 * (z1 + z2);

  float rx = 0.5 * abs(x2 - x1);
  float ry = 0.5 * abs(y2 - y1);

  for (int i = 0; i < n; i += 1) {

    //float a = random(-rx, rx); 
    //float b = random(-ry, ry);

    // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
    float a = random(1-rx, rx-1);  
    float b = random(1-ry, ry-1);

    float x = x0 + a;
    float y = y0 + b;
    float z = z0;

    if (people_or_trees == 1) {
      SOLARCHVISION_add_Object2D_single("PEOPLE", 0, x, y, z, 2.5);
    } else if (people_or_trees == 2) {
      SOLARCHVISION_add_Object2D_single("TREES", 0, x, y, z, 5 + random(10));
    } else {
      SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, 5 + random(10), random(360), CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
    }
  }
}







void SOLARCHVISION_delete_All () {

  SOLARCHVISION_delete_Fractals();

  SOLARCHVISION_delete_Object2Ds();
  SOLARCHVISION_delete_Solids();
  SOLARCHVISION_delete_Faces();
  SOLARCHVISION_delete_Vertices();
  SOLARCHVISION_delete_Group3Ds(); 

  SOLARCHVISION_delete_Sections();
  SOLARCHVISION_delete_Cameras();

  WIN3D_Update = 1;
}


void SOLARCHVISION_delete_Cameras () {
  allCameras_PPPSRRRF = new float [1][8]; 
  allCameras_PPPSRRRF[0][0] = WIN3D_X_Coordinate;
  allCameras_PPPSRRRF[0][1] = WIN3D_Y_Coordinate;
  allCameras_PPPSRRRF[0][2] = WIN3D_Z_Coordinate;
  allCameras_PPPSRRRF[0][3] = WIN3D_S_Coordinate;
  allCameras_PPPSRRRF[0][4] = WIN3D_RX_Coordinate;
  allCameras_PPPSRRRF[0][5] = WIN3D_RY_Coordinate;
  allCameras_PPPSRRRF[0][6] = WIN3D_RZ_Coordinate;
  allCameras_PPPSRRRF[0][7] = WIN3D_Zoom;

  allCameras_Type = new int [1];
  allCameras_Type[0] = WIN3D_ViewType;

  allCameras_num = 0;

  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_delete_Sections () {
  allSections_UVERAB = new float [1][6]; 
  allSections_UVERAB[0][0] = 0;
  allSections_UVERAB[0][1] = 0;
  allSections_UVERAB[0][2] = 0;
  allSections_UVERAB[0][3] = 0;
  allSections_UVERAB[0][4] = 0;
  allSections_UVERAB[0][5] = 0;

  allSections_Type = new int [1];
  allSections_Type[0] = 0;

  allSections_RES1 = new int [1];
  allSections_RES1[0] = 0;

  allSections_RES2 = new int [1];
  allSections_RES2[0] = 0;

  allSections_SolidImpact = new PImage [1];
  allSections_SolidImpact[0] = createImage(2, 2, RGB);

  allSections_SolarImpact = new PImage[1][(1 + STUDY_j_End - STUDY_j_Start)];
  {
    int i = 0;
    for (int j = STUDY_j_Start; j <= STUDY_j_End; j += 1) { 
      allSections_SolarImpact[i][j] = createImage(2, 2, RGB);
    }
  }      

  allSections_num = 0;

  SOLARCHVISION_deselect_All();
}


void SOLARCHVISION_delete_Solids () {
  allSolids_DEF = new float [1][13]; 
  allSolids_DEF[0][0] = 0;
  allSolids_DEF[0][1] = 0;
  allSolids_DEF[0][2] = 0;
  allSolids_DEF[0][3] = 2;
  allSolids_DEF[0][4] = 2;
  allSolids_DEF[0][5] = 2;
  allSolids_DEF[0][6] = 1;
  allSolids_DEF[0][7] = 1;
  allSolids_DEF[0][8] = 1;
  allSolids_DEF[0][9] = 0;
  allSolids_DEF[0][10] = 0;
  allSolids_DEF[0][11] = 0;
  allSolids_DEF[0][12] = 1;

  for (int q = 0; q < allGroup3Ds_num + 1; q++) {
    allGroup3Ds_Solids[q][0] = 0;
    allGroup3Ds_Solids[q][1] = -1;
  }

  SOLARCHVISION_deselect_All();
}


void SOLARCHVISION_resize_allSections_Solar_Impact_Array () { // called when STUDY_j_End changes

  allSections_SolarImpact = new PImage[1 + allSections_num][(1 + STUDY_j_End - STUDY_j_Start)];
  {
    for (int i = 0; i <= allSections_num; i++) {
      for (int j = STUDY_j_Start; j <= STUDY_j_End; j += 1) { 
        allSections_SolarImpact[i][j] = createImage(2, 2, RGB);
      }
    }
  }
}


void SOLARCHVISION_delete_Fractals () {

  allFractals_XYZSR = new float [1][5]; 
  allFractals_XYZSR[0][0] = 0;
  allFractals_XYZSR[0][1] = 0;
  allFractals_XYZSR[0][2] = 0;
  allFractals_XYZSR[0][3] = 0;
  allFractals_XYZSR[0][4] = 0;

  allFractals_Type = new int [1];
  allFractals_Type[0] = 0;

  allFractals_DegreeMin = new int [1];
  allFractals_DegreeMin[0] = 0;

  allFractals_DegreeMax = new int [1];
  allFractals_DegreeMax[0] = 0;

  allFractals_Seed = new int [1];
  allFractals_Seed[0] = 0;

  allFractals_TrunkSize = new float [1];
  allFractals_TrunkSize[0] = 0;

  allFractals_LeafSize = new float [1];
  allFractals_LeafSize[0] = 0;

  allFractals_num = 0;

  for (int q = 0; q < allGroup3Ds_num + 1; q++) {
    allGroup3Ds_Fractals[q][0] = 0;
    allGroup3Ds_Fractals[q][1] = -1;
  }    

  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_delete_Object2Ds () {

  allObject2Ds_XYZS = new float [1][4]; 
  allObject2Ds_XYZS[0][0] = 0;
  allObject2Ds_XYZS[0][1] = 0;
  allObject2Ds_XYZS[0][2] = 0;
  allObject2Ds_XYZS[0][3] = 0;

  allObject2Ds_MAP = new int [1];
  allObject2Ds_MAP[0] = 0;

  allObject2Ds_num = 0;

  for (int q = 0; q < allGroup3Ds_num + 1; q++) {
    allGroup3Ds_Object2Ds[q][0] = 0;
    allGroup3Ds_Object2Ds[q][1] = -1;
  }  

  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_delete_Faces () {

  allFaces_PNT = new int [1][3];
  allFaces_PNT[0][0] = 0;
  allFaces_PNT[0][1] = 0;
  allFaces_PNT[0][2] = 0;

  allFaces_MTLV = new int [1][4];
  allFaces_MTLV[0][0] = 0;
  allFaces_MTLV[0][1] = 0;
  allFaces_MTLV[0][2] = 0;
  allFaces_MTLV[0][3] = 0;

  for (int q = 0; q < allGroup3Ds_num + 1; q++) {
    allGroup3Ds_Faces[q][0] = 0;
    allGroup3Ds_Faces[q][1] = -1;
  }  

  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_delete_Vertices () {

  allVertices = new float [1][3];
  allVertices[0][0] = 0;
  allVertices[0][1] = 0;
  allVertices[0][2] = 0;

  SOLARCHVISION_deselect_All();
}

void SOLARCHVISION_delete_Group3Ds () {

  allGroup3Ds_Fractals = new int [1][2];
  allGroup3Ds_Fractals[0][0] = 0;
  allGroup3Ds_Fractals[0][1] = -1;    

  allGroup3Ds_Object2Ds = new int [1][2];
  allGroup3Ds_Object2Ds[0][0] = 0;
  allGroup3Ds_Object2Ds[0][1] = -1;  

  allGroup3Ds_Faces = new int [1][2];
  allGroup3Ds_Faces[0][0] = 0;
  allGroup3Ds_Faces[0][1] = -1;

  allGroup3Ds_Solids = new int [1][2];
  allGroup3Ds_Solids[0][0] = 0;
  allGroup3Ds_Solids[0][1] = -1;

  allGroup3Ds_PivotXYZ = new float [1][9];
  allGroup3Ds_PivotXYZ[0][0] = 0;
  allGroup3Ds_PivotXYZ[0][1] = 0;
  allGroup3Ds_PivotXYZ[0][2] = 0;
  allGroup3Ds_PivotXYZ[0][3] = 1;
  allGroup3Ds_PivotXYZ[0][4] = 1;
  allGroup3Ds_PivotXYZ[0][5] = 1;
  allGroup3Ds_PivotXYZ[0][6] = 0;
  allGroup3Ds_PivotXYZ[0][7] = 0;
  allGroup3Ds_PivotXYZ[0][8] = 0;

  allGroup3Ds_PivotType = new int [1][1];
  allGroup3Ds_PivotType[0][0] = 0;

  allGroup3Ds_num = 0;

  SOLARCHVISION_deselect_All();

  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);



  urbanVertices_start = 0;
  urbanVertices_end = 0;
  urbanFaces_start = 0;
  urbanFaces_end = 0; 

  WIN3D_VerticesSolarValue_Update = 1;
}

int urbanVertices_start = 0;
int urbanVertices_end = 0;
int urbanFaces_start = 0;
int urbanFaces_end = 0;

void SOLARCHVISION_add_urban () {

  if (urbanVertices_start == 0) { // avoids overloading the urban model when it was loaded before.
    if (LoadButton_UrbanMesh == 1) {
      urbanVertices_start = allVertices.length;
      urbanFaces_start = allFaces_PNT.length;

      //float h = (HeightAboveGround - LocationElevation);
      float h = 0; //-20; // ?????????????????????????????????????????

      SOLARCHVISION_import_objects_OBJ("C:/SOLARCHVISION_2015/Import/Stations/" + Defined_Stations[STATION_Number][0] + ".obj", -1, 0, 0, 1, 1, 0, 0, h, 1, 1, 1);

      urbanVertices_end = allVertices.length;
      urbanFaces_end = allFaces_PNT.length;
    }
  }
}

void SOLARCHVISION_add_3Dbase (int m, int tes, int lyr, int vsb, int xtr) {

  if (LoadButton_LandMesh != 0) {

    for (int i = 0; i < Skip_LAND_MESH_Center; i += 1) {  
      for (int j = 0; j < LAND_n_J - 1; j += 1) {
        // Material -2 for colored elevations
        SOLARCHVISION_add_Mesh4(m, tes, lyr, vsb, xtr, LAND_MESH[i][j][0], LAND_MESH[i][j][1], LAND_MESH[i][j][2], LAND_MESH[i+1][j][0], LAND_MESH[i+1][j][1], LAND_MESH[i+1][j][2], LAND_MESH[i+1][j+1][0], LAND_MESH[i+1][j+1][1], LAND_MESH[i+1][j+1][2], LAND_MESH[i][j+1][0], LAND_MESH[i][j+1][1], LAND_MESH[i][j+1][2]);
      }
    }
  }
}  

int MAX_Default_Models_Number = 7;

void SOLARCHVISION_add_DefaultModel (int n) {

  if (LoadButton_LandMesh == 1) {

    SOLARCHVISION_add_Object2Ds_onLand(1); // 1 = people

    SOLARCHVISION_add_Object2Ds_onLand(2); // 2 = 2D trees
  } else {
    //SOLARCHVISION_add_Object2Ds_polar(1, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // people
    //SOLARCHVISION_add_Object2Ds_polar(2, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // trees
  }  



  //if (n != 0) {
  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
  SOLARCHVISION_add_Mesh2(8, 0, 0, 1, 1, -100, -100, 0, 100, 100, 0);
  //}

  if (n == 1) {
    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
    SOLARCHVISION_add_House_Core(0, 0, 0, 1, 1, 0, 0, 0, 6, 6, 6, 6, 90);
  }

  if (n == 2) {
    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
    SOLARCHVISION_add_House_Core(0, 0, 0, 1, 1, 0, 0, 0, 6, 6, 6, 6, 0);
  }  

  if (n == 3) {
    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
    SOLARCHVISION_add_PolygonHyper(0, 0, 0, 1, 1, 0, 0, 5, 10, 10, 4, 0);

    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
    SOLARCHVISION_add_House_Core(7, 0, 0, 1, 1, 25, 25, 0, 6, 6, 6, 6, 0);
  }   

  if (n == 4) {
    for (int i = 0; i < int (10 + random (10)); i++) {
      SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
      SOLARCHVISION_add_House_Core(7, 0, 0, 1, 1, random(-80, 80), random(-80, 80), 0, random(5, 10), random(5, 10), random(5, 10), random(2.5, 7.5), random(360));
    }
  }    


  if (n == 5) {
    //SOLARCHVISION Complex:

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 0, 0, 1, 3, 3);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 0, 0, 1, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 2, 1, 1, 3, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 0, 2, 1, 3, 3);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 2, 0, 0, 6, 4, 0.5);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 7, 0, 0, 9, 2, 2);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 7, 3, 0, 9, 4, 4);

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 10, 0, 0, 13, 4, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 10, 0, 0, 13, 1, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 10, 1, 0, 10.5, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 12.5, 1, 0, 13, 3, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 10, 3, 0, 13, 4, 1);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 4, 0, 1, 8, 2);

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 2, 5, 0, 4, 8, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 2, 5, 0, 4, 5.5, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 2, 5.5, 0, 2.5, 7.5, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 3.5, 5.5, 0, 4, 7.5, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 2, 7.5, 0, 4, 8, 2);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 5, 5, 0, 8, 8, 1);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 9, 5, 0, 11, 9, 1);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 12, 5, 0, 13, 7, 4);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 12, 8, 0, 13, 9, 8);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 9, 0, 4, 11, 1);

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 5, 9, 0, 8, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 5, 9, 0, 5.5, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 5.5, 9, 0, 7.5, 9.5, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 5.5, 10.5, 0, 7.5, 11, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 7.5, 9, 0, 8, 11, 2);

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 0, 12, 0, 3, 13, 3);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 12, 0, 3, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 12, 1, 1, 13, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 2, 12, 1, 3, 13, 2);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 0, 12, 2, 3, 13, 3);

    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 4, 12, 0, 8, 13, 2);

    //SOLARCHVISION_add_Box_Corners(-1,0,0,1,1, 9, 10, 0, 13, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 9, 10, 0, 10, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 10, 10, 0, 12, 10.5, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 10, 12.5, 0, 12, 13, 1);
    SOLARCHVISION_add_Box_Corners(-1, 0, 0, 1, 1, 12, 10, 0, 13, 13, 1);

    float model_scale = 12; // to make grid scale equal to 12m. <<<<

    for (int i = 1; i < allVertices.length; i++) {
      allVertices[i][0] -= 6.5;
      allVertices[i][1] -= 6.5; 

      allVertices[i][0] *= model_scale;
      allVertices[i][1] *= model_scale; 
      allVertices[i][2] *= model_scale;
    }
  }      

  if (n == 6) {
    {
      SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 10;
      SOLARCHVISION_add_CrystalSphere(1, 0, 0, 1, 1, x, y, z, r, 5, 0, 90);
      SOLARCHVISION_add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
    }

    {
      SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
      float x = 30;
      float y = 0;
      float z = 0;
      float r = 8;
      SOLARCHVISION_add_CrystalSphere(2, 0, 0, 1, 1, x, y, z, r, 4, 0, 90);
      SOLARCHVISION_add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
    }

    {
      SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
      float x = 0;
      float y = 20;
      float z = 0;
      float r = 8;
      SOLARCHVISION_add_CrystalSphere(3, 0, 0, 1, 1, x, y, z, r, 3, 0, 90);
      SOLARCHVISION_add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
    }
  }

  if (n == 7) {
    SOLARCHVISION_add_Model_Main();
  }
}





void SOLARCHVISION_add_ParametricSurface (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float rx, float ry, float rz, int n, float rot) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr; 

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;  

  float teta = rot * PI / 180.0;

  float stp_u = 0.1; //0.05;
  float stp_v = 0.1; //0.05;

  float start_u = -1;
  float start_v = -1;
  float end_u = 1;
  float end_v = 1;

  if (n == 1) {
    start_u = 0;
  }
  if (n == 2) {
    start_u = 0;
  }

  for (float a = start_u; a < end_u; a += stp_u) {
    for (float b = start_v; b < end_v; b += stp_v) {

      int[] newFace = {
      };

      for (int i = 0; i < 4; i++) {

        float u = a;
        float v = b;

        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        float x = 0;
        float y = 0;
        float z = 0;

        if (n == 1) { // LOGO:
          float x0 = cos(u * PI); 
          float y0 = sin(v * PI);
          float z0 = -sin(u * PI) * cos(v * PI);

          float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
          x = 0;
          y = 0;
          z = 0;
          if (d != 0) {
            x = x0 / d;  
            y = y0 / d;  
            z = z0 / d;
          }
        } else if (n == 2) { 
          x = cos(u * PI); 
          y = sin(v * PI);
          z = -sin(u * PI) * cos(v * PI);
        } else if (n == 3) {
          x = sin(u * PI); 
          y = sin(v * PI);
          z = cos((u + v) * PI);
        } else if (n == 4) {
          float x0 = sin(u * PI); 
          float y0 = sin(v * PI);
          float z0 = cos((u + v) * PI);

          float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
          x = 0;
          y = 0;
          z = 0;
          if (d != 0) {
            x = x0 / d;  
            y = y0 / d;  
            z = z0 / d;
          }
        } else if (n == 5) {
          x = u; 
          y = v; 
          z = cos(0.5 * u * PI) * cos(0.5 * v * PI);
        } else if (n == 6) {
          x = u; 
          y = v; 
          z = sin(u * PI) * sin(v * PI);
        } else if (n == 7) {
          x = u; 
          y = v; 
          z = 0.5 * cos(u * PI) + cos(v * PI);
        }


        x *= rx;
        y *= ry;
        z *= rz;

        float x_rot = cx + x * cos(teta) - y * sin(teta);
        float y_rot = cy + x * sin(teta) + y * cos(teta);
        float z_rot = cz + z;

        x = x_rot;
        y = y_rot;
        z = z_rot;

        int[] f = {
          SOLARCHVISION_add_Vertex(x, y, z)
        };
        newFace = concat(newFace, f);
      }

      if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));      

      SOLARCHVISION_add_Face(newFace);
    }
  }
}




void SOLARCHVISION_build_SkySphere (int Tessellation) {

  //SOLARCHVISION_add_CrystalSphere(0,0,0,1,1, 0,0,0, 1, Tessellation, 1, 90); // SKY
  SOLARCHVISION_add_CrystalSphere(0, 0, 0, 1, 1, 0, 0, 0, 1, 4, 1, 90); // SKY
}



float OBJECTS_scale = 1.0;  



PGraphics ViewFromTheSky (int SKY2D_X_View, int SKY2D_Y_View, float SKY2D_ZOOM_Coordinate, float SKY2D_X_Coordinate, float SKY2D_Y_Coordinate, float SKY2D_Z_Coordinate, float SKY2D_RX_Coordinate, float SKY2D_RY_Coordinate, float SKY2D_RZ_Coordinate) {

  PGraphics SKY2D_Diagrams = createGraphics(SKY2D_X_View, SKY2D_Y_View, P3D);   

  SKY2D_Diagrams.beginDraw();

  SKY2D_Diagrams.background(233);

  //float ZOOM = 0.456 * SKY2D_ZOOM_Coordinate * PI / 180;
  float ZOOM = 0.125 * SKY2D_ZOOM_Coordinate * PI / 180;

  SKY2D_Diagrams.ortho(ZOOM * SKY2D_X_View * -1, ZOOM * SKY2D_X_View * 1, ZOOM  * SKY2D_Y_View * -1, ZOOM  * SKY2D_Y_View * 1, 0.00001, 100000);

  SKY2D_Diagrams.translate(0, 1.0 * SKY2D_Y_View, 0); // << IMPORTANT! 

  SKY2D_Diagrams.pushMatrix();

  SKY2D_Diagrams.translate(0, 0, 0);

  SKY2D_Diagrams.fill(0);
  SKY2D_Diagrams.textAlign(CENTER, CENTER); 
  SKY2D_Diagrams.textSize(5 * (SKY2D_ZOOM_Coordinate / 30.0));
  SKY2D_Diagrams.text(LocationName + " [" + nfp(LocationLatitude, 0, 1) + ", " + nfp(LocationLongitude, 0, 1) + "]", 0, 60 * (SKY2D_ZOOM_Coordinate / 30.0), 0);

  SKY2D_Diagrams.popMatrix();

  SKY2D_Diagrams.translate(SKY2D_X_Coordinate, SKY2D_Y_Coordinate, SKY2D_Z_Coordinate);
  SKY2D_Diagrams.rotateX(SKY2D_RX_Coordinate * PI / 180); 
  SKY2D_Diagrams.rotateY(SKY2D_RY_Coordinate * PI / 180);
  SKY2D_Diagrams.rotateZ(SKY2D_RZ_Coordinate * PI / 180); 

  SKY2D_Diagrams.hint(ENABLE_DEPTH_TEST);

  for (int f = 1; f < allFaces_PNT.length; f++) {

    int vsb = allFaces_MTLV[f][3];

    if (vsb > 0) {

      color c = color(0, 0, 0);

      int mt = allFaces_MTLV[f][0];
      c = color(Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3], Materials_Color[mt][0]);

      SKY2D_Diagrams.stroke(c);
      SKY2D_Diagrams.fill(c);

      int Tessellation = allFaces_MTLV[f][1];

      int TotalSubNo = 1;  
      if (allFaces_MTLV[f][0] == 0) {
        Tessellation += MODEL3D_Tessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
      for (int j = 0; j < allFaces_PNT[f].length; j++) {
        int vNo = allFaces_PNT[f][j];
        base_Vertices[j][0] = allVertices[vNo][0];
        base_Vertices[j][1] = allVertices[vNo][1];
        base_Vertices[j][2] = allVertices[vNo][2];
      }

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

        SKY2D_Diagrams.beginShape();

        for (int s = 0; s < subFace.length; s++) {

          SKY2D_Diagrams.vertex(subFace[s][0] * WIN3D_Scale3D, -subFace[s][1] * WIN3D_Scale3D, subFace[s][2] * WIN3D_Scale3D);
        }

        SKY2D_Diagrams.endShape(CLOSE);
      }
    }
  }

  SKY2D_Diagrams.endDraw();

  return SKY2D_Diagrams;
}


void SOLARCHVISION_draw_SKY3D () {

  if (Display_SKY3D != 0) {

    for (int f = 1; f < skyFaces.length; f++) {

      if (WIN3D_FacesShade != Shade_Global_Solar) {

        color c = color(191, 191, 255);

        WIN3D_Diagrams.noStroke();

        if (WIN3D_FacesShade == Shade_Surface_Materials) {
          //WIN3D_Diagrams.fill(255, 255, 255);
          WIN3D_Diagrams.noFill();
        } else {
          WIN3D_Diagrams.fill(c);
        }    

        WIN3D_Diagrams.beginShape();

        for (int j = 0; j < skyFaces[f].length; j++) {
          int vNo = skyFaces[f][j];
          WIN3D_Diagrams.vertex(skyVertices[vNo][0] * SKY3D_scale * WIN3D_Scale3D, -(skyVertices[vNo][1] * SKY3D_scale * WIN3D_Scale3D), skyVertices[vNo][2] * SKY3D_scale * WIN3D_Scale3D);
        }    

        WIN3D_Diagrams.endShape(CLOSE);
      } else {

        int PAL_TYPE = 0; 
        int PAL_DIR = 1;
        float PAL_Multiplier = 1; 

        if (Impact_TYPE == Impact_ACTIVE) {
          PAL_TYPE = SKY3D_Pallet_ACTIVE_CLR; 
          PAL_DIR = SKY3D_Pallet_ACTIVE_DIR;  
          PAL_Multiplier = 1.0 * SKY3D_Pallet_ACTIVE_MLT;
        }
        if (Impact_TYPE == Impact_PASSIVE) {
          PAL_TYPE = SKY3D_Pallet_PASSIVE_CLR; 
          PAL_DIR = SKY3D_Pallet_PASSIVE_DIR;  
          PAL_Multiplier = 0.05 * SKY3D_Pallet_PASSIVE_MLT;
        }             



        int Tessellation = 0;

        int TotalSubNo = 1;  
        Tessellation = SKY3D_TESSELLATION;
        if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

        float[][] base_Vertices = new float [skyFaces[f].length][3];
        for (int j = 0; j < skyFaces[f].length; j++) {
          int vNo = skyFaces[f][j];
          base_Vertices[j][0] = skyVertices[vNo][0];
          base_Vertices[j][1] = skyVertices[vNo][1];
          base_Vertices[j][2] = skyVertices[vNo][2];
        }

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

          for (int j = 0; j < subFace.length; j++) {
            subFace[j] = SOLARCHVISION_fn_normalize(subFace[j]);
          }

          WIN3D_Diagrams.beginShape();

          for (int s = 0; s < subFace.length; s++) {

            int s_next = (s + 1) % subFace.length;
            int s_prev = (s + subFace.length - 1) % subFace.length;

            //if ((subFace[s][2] > -0.2) && (subFace[s_prev][2] > -0.2) && (subFace[s_next][2] > -0.2)) // to remove below
            { 
              float[] COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);

              WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

              WIN3D_Diagrams.vertex(subFace[s][0] * SKY3D_scale * WIN3D_Scale3D, -(subFace[s][1] * SKY3D_scale * WIN3D_Scale3D), subFace[s][2] * SKY3D_scale * WIN3D_Scale3D);
            }
          }

          WIN3D_Diagrams.endShape(CLOSE);
        }
      }
    }
  }
}














void SOLARCHVISION_draw_WindFlow () {



  if (Display_WindFlow != 0) {  

    int PAL_TYPE = WindFlow_Pallet_CLR; 
    int PAL_DIR = WindFlow_Pallet_DIR; 
    float PAL_Multiplier = WindFlow_Pallet_MLT;



    for (int q = 1; q < WindFlow_Lines.length; q++) {

      int n1 = WindFlow_Lines[q][0];
      int n2 = WindFlow_Lines[q][1];

      float x1 = WindFlow_Vertices[n1][0];
      float y1 = WindFlow_Vertices[n1][1];
      float z1 = WindFlow_Vertices[n1][2];

      float x2 = WindFlow_Vertices[n2][0];
      float y2 = WindFlow_Vertices[n2][1];
      float z2 = WindFlow_Vertices[n2][2];


      float _val = WindFlow_Pallet_MLT * WindFlow_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<

      float _u = 0.5 + 0.5 * (PAL_Multiplier * _val);
      if (PAL_DIR == -1) _u = 1 - _u;
      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_DIR == 2) _u =  0.5 * _u;

      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);      

      /*    
       WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]);
       WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
       
       WIN3D_Diagrams.strokeWeight(1);
       WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_Scale3D, -y1 * OBJECTS_scale * WIN3D_Scale3D, z1 * OBJECTS_scale * WIN3D_Scale3D, x2 * OBJECTS_scale * WIN3D_Scale3D, -y2 * OBJECTS_scale * WIN3D_Scale3D, z2 * OBJECTS_scale * WIN3D_Scale3D);
       
       WIN3D_Diagrams.strokeWeight(4);      
       WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_Scale3D, -y1 * OBJECTS_scale * WIN3D_Scale3D, z1 * OBJECTS_scale * WIN3D_Scale3D, 0.5 * (x2 + x1) * OBJECTS_scale * WIN3D_Scale3D, -0.5 * (y2 + y1) * OBJECTS_scale * WIN3D_Scale3D, 0.5 * (z2 + z1) * OBJECTS_scale * WIN3D_Scale3D);
       */


      float the_dist = dist(x1, y1, z1, x2, y2, z2);

      float[] W = {
        x2 - x1, y2 - y1, z2 - z1
      };
      W = SOLARCHVISION_fn_normalize(W);

      float Alpha = asin_ang(W[2]);
      float Beta = atan2_ang(W[1], W[0]) + 90;   

      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], 127);
      WIN3D_Diagrams.noStroke();

      for (int i = 0; i < 4; i++) {

        WIN3D_Diagrams.beginShape();

        WIN3D_Diagrams.vertex(x2 * OBJECTS_scale * WIN3D_Scale3D, -y2 * OBJECTS_scale * WIN3D_Scale3D, z2 * OBJECTS_scale * WIN3D_Scale3D);  

        for (int j = 0; j < 2; j++) {

          float px = 0.1 * the_dist * cos((i + j) * HALF_PI);
          float py = 0;
          float pz = 0.1 * the_dist * sin((i + j) * HALF_PI); 

          float pz_rot = pz;
          float px_rot = px * cos_ang(Beta) - py * sin_ang(Beta);
          float py_rot = px * sin_ang(Beta) + py * cos_ang(Beta);  

          px = px_rot;
          py = py_rot;
          pz = pz_rot;

          px_rot = px;
          py_rot = py * cos_ang(Alpha) - pz * sin_ang(Alpha);
          pz_rot = py * sin_ang(Alpha) + pz * cos_ang(Alpha);

          px = px_rot;
          py = py_rot;
          pz = pz_rot;          

          WIN3D_Diagrams.vertex((x1 + px) * OBJECTS_scale * WIN3D_Scale3D, -(y1 + py) * OBJECTS_scale * WIN3D_Scale3D, (z1 + pz) * OBJECTS_scale * WIN3D_Scale3D);
        }

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }


    WIN3D_Diagrams.strokeWeight(0);
  }
}


PImage[] TROPO_IMAGES_Map;

//String TROPO_IMAGES_Path = "C:/SOLARCHVISION_2015/Output/2015-12-04/GDPS_00/World/Winds";
String TROPO_IMAGES_Path = "C:/SOLARCHVISION_2015/Output/2015-12-04/GDPS_00/World/Winds_less";

String[] TROPO_IMAGES_Filenames;

void Load_TROPO_IMAGES () {

  TROPO_IMAGES_Filenames = sort(SOLARCHVISION_getfiles(TROPO_IMAGES_Path));

  TROPO_IMAGES_Map = new PImage [TROPO_IMAGES_Filenames.length];

  for (int i = 0; i < TROPO_IMAGES_Filenames.length; i++) {

    println("Loading:", TROPO_IMAGES_Path + "/" + TROPO_IMAGES_Filenames[i]);

    TROPO_IMAGES_Map[i] = loadImage(TROPO_IMAGES_Path + "/" + TROPO_IMAGES_Filenames[i]);
  }
}


void SOLARCHVISION_draw_TROPO3D () {
  if (Display_TROPO3D_Surface != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    for (int TROPO_level = 0; TROPO_level < TROPO_IMAGES_Map.length; TROPO_level++) {

      float TROPO_IMAGES_OffsetX = 0; //TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + 180;
      float TROPO_IMAGES_OffsetY = 0; //TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - 90;

      float TROPO_IMAGES_ScaleX = 1; //(TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0]) / 360.0;
      float TROPO_IMAGES_ScaleY = 1; //(TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1] - TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0]) / 180.0;

      float CEN_lon = 0; //0.5 * (TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesX[TROPO_IMAGES_Number][1]);
      float CEN_lat = 0; //0.5 * (TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][0] + TROPO_IMAGES_BoundariesY[TROPO_IMAGES_Number][1]);

      float delta_Alpha = -BIOSPHERE_drawResolution;
      float delta_Beta = -BIOSPHERE_drawResolution;

      float r = FLOAT_r_Earth + (TROPO_IMAGES_Map.length - TROPO_level) * 17000;

      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

          float[][] subFace = new float [4][5];

          for (int s = 0; s < 4; s += 1) {

            float a = Alpha;
            float b = Beta;

            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }

            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }

            float x0 = r * cos_ang(b - 90) * cos_ang(a); 
            float y0 = r * sin_ang(b - 90) * cos_ang(a);
            float z0 = r * sin_ang(a);

            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;

            if (Display_TROPO3D_Texture != 0) {
              // calculating u and v
              subFace[s][3] = (_lon / TROPO_IMAGES_ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / TROPO_IMAGES_ScaleY / 180.0 + 0.5);
            }         

            // rotating to location coordinates 
            float tb = -LocationLongitude;
            float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
            float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
            float z1 = z0;

            float ta = 90 - LocationLatitude;
            float x2 = x1;
            float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
            float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

            // move it down!
            z2 -= FLOAT_r_Earth;

            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }

          WIN3D_Diagrams.beginShape();

          WIN3D_Diagrams.noStroke();

          if (Display_TROPO3D_Texture != 0) {

            WIN3D_Diagrams.texture(TROPO_IMAGES_Map[TROPO_level]);
          }

          for (int s = 0; s < subFace.length; s++) {

            WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][3] * TROPO_IMAGES_Map[TROPO_level].width, subFace[s][4] * TROPO_IMAGES_Map[TROPO_level].height);
          }

          WIN3D_Diagrams.endShape(CLOSE);
        }
      }
    }
  }
}




PImage[] EARTH_IMAGES_Map;

float[][] EARTH_IMAGES_BoundariesX;
float[][] EARTH_IMAGES_BoundariesY;

String EARTH_IMAGES_Path = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/EarthSurface";

String[] EARTH_IMAGES_Filenames = sort(SOLARCHVISION_getfiles(EARTH_IMAGES_Path));

void Load_EARTH_IMAGES () {

  int n = EARTH_IMAGES_Filenames.length;

  EARTH_IMAGES_Map = new PImage [n];

  EARTH_IMAGES_BoundariesX = new float [n][2];
  EARTH_IMAGES_BoundariesY = new float [n][2];

  for (int i = 0; i < EARTH_IMAGES_Filenames.length; i++) {

    String MapFilename = EARTH_IMAGES_Path + "/" + EARTH_IMAGES_Filenames[i];

    String[] Parts = split(EARTH_IMAGES_Filenames[i], '_');

    EARTH_IMAGES_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
    EARTH_IMAGES_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
    EARTH_IMAGES_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
    EARTH_IMAGES_BoundariesY[i][1] =  float(Parts[4]) * 0.001;

    println("Loading:", MapFilename);

    EARTH_IMAGES_Map[i] = loadImage(MapFilename);
  }
}


void SOLARCHVISION_draw_EARTH3D () {
  if (Display_EARTH3D_Surface != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    int n = 0;
    if (IMPACTS_DisplayDay < EARTH_IMAGES_Map.length) n = IMPACTS_DisplayDay;

    float EARTH_IMAGES_OffsetX = EARTH_IMAGES_BoundariesX[n][0] + 180;
    float EARTH_IMAGES_OffsetY = EARTH_IMAGES_BoundariesY[n][1] - 90;

    float EARTH_IMAGES_ScaleX = (EARTH_IMAGES_BoundariesX[n][1] - EARTH_IMAGES_BoundariesX[n][0]) / 360.0;
    float EARTH_IMAGES_ScaleY = (EARTH_IMAGES_BoundariesY[n][1] - EARTH_IMAGES_BoundariesY[n][0]) / 180.0;

    float CEN_lon = 0.5 * (EARTH_IMAGES_BoundariesX[n][0] + EARTH_IMAGES_BoundariesX[n][1]);
    float CEN_lat = 0.5 * (EARTH_IMAGES_BoundariesY[n][0] + EARTH_IMAGES_BoundariesY[n][1]);

    float delta_Alpha = -BIOSPHERE_drawResolution;
    float delta_Beta = -BIOSPHERE_drawResolution;

    float r = FLOAT_r_Earth;

    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];

        for (int s = 0; s < 4; s += 1) {

          float a = Alpha;
          float b = Beta;

          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);

          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;

          if (Display_EARTH3D_Texture != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / EARTH_IMAGES_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / EARTH_IMAGES_ScaleY / 180.0 + 0.5);
          }         

          // rotating to location coordinates 
          float tb = -LocationLongitude;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;

          float ta = 90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

          // move it down!
          z2 -= FLOAT_r_Earth;

          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;
        }

        WIN3D_Diagrams.beginShape();

        WIN3D_Diagrams.noStroke();

        if (Display_EARTH3D_Texture != 0) {

          WIN3D_Diagrams.texture(EARTH_IMAGES_Map[n]);
        }

        for (int s = 0; s < subFace.length; s++) {

          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][3] * EARTH_IMAGES_Map[n].width, subFace[s][4] * EARTH_IMAGES_Map[n].height);
        }

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }
  }
}



String MOON_IMAGE_Filename = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Moon/Moon.jpg";

PImage MOON_IMAGE_Map; 

void SOLARCHVISION_draw_MOON3D () {
  if (Display_MOON3D_Surface != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    float MOON_IMAGE_OffsetX = 0; 
    float MOON_IMAGE_OffsetY = 0; 

    float MOON_IMAGE_ScaleX = 1; 
    float MOON_IMAGE_ScaleY = 1; 

    float CEN_lon = 0; 
    float CEN_lat = 0; 

    float delta_Alpha = -5;
    float delta_Beta = -10;

    float r = 1737000.0 * Planetary_Magnification;
    float d = 384400000.0 - FLOAT_r_Earth;

    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];

        for (int s = 0; s < 4; s += 1) {

          float a = Alpha;
          float b = Beta;

          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);

          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;

          if (Display_MOON3D_Texture != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / MOON_IMAGE_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / MOON_IMAGE_ScaleY / 180.0 + 0.5);
          }         

          // rotating to location coordinates


          float tb = 0;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;

          float ta = -90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

          // move it up here!
          y2 += d * sin_ang(-LocationLatitude);      
          z2 += d * cos_ang(-LocationLatitude);

          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;
        }

        WIN3D_Diagrams.beginShape();

        WIN3D_Diagrams.noStroke();

        if (Display_MOON3D_Texture != 0) {

          WIN3D_Diagrams.texture(MOON_IMAGE_Map);
        }

        for (int s = 0; s < subFace.length; s++) {

          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][3] * MOON_IMAGE_Map.width, subFace[s][4] * MOON_IMAGE_Map.height);
        }

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }
  }
}


String STAR_IMAGE_Filename = "C:/SOLARCHVISION_2015/Input/BackgroundImages/Standard/Maps/Sun/Sun.jpg";

PImage STAR_IMAGE_Map;

void SOLARCHVISION_draw_STAR3D () {
  if (Display_STAR3D_Surface != 0) {

    WIN3D_Diagrams.strokeWeight(1);

    float STAR_IMAGE_OffsetX = 0; 
    float STAR_IMAGE_OffsetY = 0; 

    float STAR_IMAGE_ScaleX = 1; 
    float STAR_IMAGE_ScaleY = 1; 

    float CEN_lon = 0; 
    float CEN_lat = 0; 

    float delta_Alpha = -5;
    float delta_Beta = -10;

    float r = 696.0 * Planetary_Magnification; // * 1000000; // multiply this later
    float d = 150000.0; // * 1000000; // multiply this later 

    for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
      for (float Beta = 180; Beta > -180; Beta += delta_Beta) {

        float[][] subFace = new float [4][5];

        for (int s = 0; s < 4; s += 1) {

          float a = Alpha;
          float b = Beta;

          if ((s == 2) || (s == 3)) {
            a += delta_Alpha;
          }

          if ((s == 1) || (s == 2)) {
            b += delta_Beta;
          }

          float x0 = r * cos_ang(b - 90) * cos_ang(a); 
          float y0 = r * sin_ang(b - 90) * cos_ang(a);
          float z0 = r * sin_ang(a);

          float _lon = b - CEN_lon;
          float _lat = a - CEN_lat;

          if (Display_STAR3D_Texture != 0) {
            // calculating u and v
            subFace[s][3] = (_lon / STAR_IMAGE_ScaleX / 360.0 + 0.5); 
            subFace[s][4] = (-_lat / STAR_IMAGE_ScaleY / 180.0 + 0.5);
          }         

          // rotating to location coordinates

          float tb = 0;
          float x1 = x0 * cos_ang(tb) - y0 * sin_ang(tb);
          float y1 = x0 * sin_ang(tb) + y0 * cos_ang(tb);
          float z1 = z0;

          float ta = -90 - LocationLatitude;
          float x2 = x1;
          float y2 = z1 * sin_ang(ta) + y1 * cos_ang(ta);
          float z2 = z1 * cos_ang(ta) - y1 * sin_ang(ta);

          // scale it here!
          x2 *= 1000000.0;
          y2 *= 1000000.0;
          z2 *= 1000000.0;

          // move it to scale here!
          y2 += 1000000.0 * d * sin_ang(-LocationLatitude);      
          z2 += 1000000.0 * d * cos_ang(-LocationLatitude);

          subFace[s][0] = x2;
          subFace[s][1] = y2;
          subFace[s][2] = z2;
        }

        WIN3D_Diagrams.beginShape();

        WIN3D_Diagrams.noStroke();

        if (Display_STAR3D_Texture != 0) {

          WIN3D_Diagrams.texture(STAR_IMAGE_Map);
        }

        for (int s = 0; s < subFace.length; s++) {

          WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][3] * STAR_IMAGE_Map.width, subFace[s][4] * STAR_IMAGE_Map.height);
        }

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }
  }
}



void SOLARCHVISION_draw_land (int target_window) {

  // target_window: 1:STUDY, 2:WORLD, 3:WIN3D 4:OBJ-export 5:RAD-export

  if ((Display_LAND_MESH == 1) && (LoadButton_LandMesh == 1)) {


    int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
    int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
    float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 

    if (target_window == 5) {

      if (objExport_MaterialLibrary != 0) {

        //if (Display_LAND_Texture != 0) {           

          //for (int n_Map = 0; n_Map <= LAND_Texture_num; n_Map++) {
          for (int n_Map = 0; n_Map < 1; n_Map++) {  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

            
// Just to test!

            int mt = n_Map;

            float a = Materials_Color[mt][0] / 255.0; 
            float r = Materials_Color[mt][1] / 255.0; 
            float g = Materials_Color[mt][2] / 255.0; 
            float b = Materials_Color[mt][3] / 255.0; 
    
            radOutput.println("void plastic " + "LandMesh_" + nf(n_Map, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 " + nf(r, 0, objExport_PrecisionVtexture) + " " + nf(g, 0, objExport_PrecisionVtexture) + " " + nf(b, 0, objExport_PrecisionVtexture) + " 0 0");

            if (Display_LAND_Texture != 0) {
              if (n_Map != 0) {
/*
    copy the map!
*/                
              }
            }
          }
        //}
      }
    }

    if (target_window == 4) {

      if (objExport_MaterialLibrary != 0) {

        if (Display_LAND_Texture != 0) {           

          for (int n_Map = 0; n_Map <= LAND_Texture_num; n_Map++) {

            mtlOutput.println("newmtl LandMesh_" + nf(n_Map, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)

            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter


            if (Display_LAND_Texture != 0) {
              if (n_Map != 0) {

                String old_Texture_path = LAND_Texture_ImagePath[n_Map]; 

                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name

                String new_Texture_path = Model3DFolder + "/" + obj_MapsSubfolder + the_filename;

                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));

                //mtlOutput.println("\tmap_Ka " + obj_MapsSubfolder + the_filename); // ambient map
                mtlOutput.println("\tmap_Kd " + obj_MapsSubfolder + the_filename); // diffuse map        
                mtlOutput.println("\tmap_d " + obj_MapsSubfolder + the_filename); // diffuse map
              }
            }
          }
        }
      }
    }


    num_vertices_added = 0;

    int end_turn = 1;
    if (target_window == 4) end_turn = 3;
    for (int _turn = 1; _turn <= end_turn; _turn += 1) {


      if (target_window == 4) {

        if (_turn == 3) {

          obj_lastGroupNumber += 1;
          objOutput.println("g LandMesh");
        }
      }    



      int Tessellation = LAND_TESSELLATION;
      if (WIN3D_FacesShade == Shade_Surface_Base) {
        Tessellation = 0;
      }

      int TotalSubNo = 1;  
      if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.


      for (int i = Skip_LAND_MESH_Center; i < LAND_n_I - 1; i += 1) {
        for (int j = 0; j < LAND_n_J - 1; j += 1) {

          float[][] base_Vertices = new float [4][3];

          base_Vertices[0][0] = LAND_MESH[i][j][0];
          base_Vertices[0][1] = LAND_MESH[i][j][1];
          base_Vertices[0][2] = LAND_MESH[i][j][2];

          base_Vertices[1][0] = LAND_MESH[i+1][j][0];
          base_Vertices[1][1] = LAND_MESH[i+1][j][1];
          base_Vertices[1][2] = LAND_MESH[i+1][j][2];

          base_Vertices[2][0] = LAND_MESH[i+1][j+1][0];
          base_Vertices[2][1] = LAND_MESH[i+1][j+1][1];
          base_Vertices[2][2] = LAND_MESH[i+1][j+1][2];

          base_Vertices[3][0] = LAND_MESH[i][j+1][0];
          base_Vertices[3][1] = LAND_MESH[i][j+1][1];
          base_Vertices[3][2] = LAND_MESH[i][j+1][2];        

          for (int n = 0; n < TotalSubNo; n++) {

            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

            int n_Map = 0; 
            if (Display_LAND_Texture != 0) { 

              for (int q = 1; q <= LAND_Texture_num; q++) { // increase the resolution until all the vertices located inside the appropriate map

                n_Map = q; 

                for (int s = 0; s < subFace.length; s++) {

                  float u = (subFace[s][0] / LAND_Texture_scale_U[q] + 0.5);
                  float v = (-subFace[s][1] / LAND_Texture_scale_V[q] + 0.5);

                  if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {

                    n_Map = 0;

                    break;
                  }
                }

                if (n_Map == q) break;
              }
            }

            if (target_window == 3) {

              WIN3D_Diagrams.beginShape();

              WIN3D_Diagrams.strokeWeight(1);
              WIN3D_Diagrams.stroke(0, 0, 0);
              if (MODEL3D_DisplayEdges == 0) WIN3D_Diagrams.noStroke();
              if (Display_LAND_Texture != 0) WIN3D_Diagrams.noStroke();

              if (Display_LAND_Texture != 0) {
                if (n_Map != 0) {
                  WIN3D_Diagrams.texture(LAND_Texture_Map[n_Map]);
                } else {
                  WIN3D_Diagrams.noFill();   
                  WIN3D_Diagrams.strokeWeight(1);
                  WIN3D_Diagrams.stroke(0, 0, 0);
                }
              }
            }

            if (target_window == 4) {

              if (_turn == 3) {

                if (Display_LAND_Texture != 0) {

                  if (objExport_MaterialLibrary != 0) {      
                    objOutput.println("usemtl LandMesh_" + nf(n_Map, 0));
                  }
                }
              }
            }    
            
            for (int s = 0; s < subFace.length; s++) {

              if (Display_LAND_Texture == 0) {

                if (WIN3D_FacesShade != Shade_Surface_Wire) {

                  float[] COL = {
                    255, 255, 255, 255
                  };

                  if (WIN3D_FacesShade == Shade_Global_Solar) {
                    int s_next = (s + 1) % subFace.length;
                    int s_prev = (s + subFace.length - 1) % subFace.length;

                    COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }



                  if (WIN3D_FacesShade == Shade_Surface_White) {
                    COL = SOLARCHVISION_vertexRender_Shade_Surface_White(255);
                  }                   

                  if (WIN3D_FacesShade == Shade_Surface_Materials) {
                    //COL = SOLARCHVISION_vertexRender_Shade_Surface_Materials(mt);
                    COL = SOLARCHVISION_vertexRender_Shade_Surface_White(223);
                  }    

                  if (WIN3D_FacesShade == Shade_Vertex_Elevation) {

                    COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }              

                  if (WIN3D_FacesShade == Shade_Vertex_Solid) {

                    COL = SOLARCHVISION_vertexRender_Shade_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                  }                  

                  if (target_window == 3) {
                    WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
                  }
                } else {

                  if (target_window == 3) {
                    WIN3D_Diagrams.noFill();
                  }
                }

                if (target_window == 3) {
                  WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D);
                }
                
                
                
                if (target_window == 5) {

                  radOutput.println("LandMesh_0" + " polygon " + "LAND");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");      
                  
                  radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));                
                  radOutput.println(" " + nf(subFace[1][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[1][2], 0, objExport_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));
                  
                  radOutput.println("LandMesh_0" + " polygon " + "LAND");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");      
                  
                  radOutput.println(" " + nf(subFace[2][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[2][2], 0, objExport_PrecisionVertex));                
                  radOutput.println(" " + nf(subFace[3][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[3][2], 0, objExport_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[0][0], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][1], 0, objExport_PrecisionVertex) + " " + nf(subFace[0][2], 0, objExport_PrecisionVertex));

                }
                                

                
              } else {       

                float u = (subFace[s][0] / LAND_Texture_scale_U[n_Map] + 0.5);
                float v = (-subFace[s][1] / LAND_Texture_scale_V[n_Map] + 0.5);

                if (target_window == 3) {
                  WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, u * LAND_Texture_Map[n_Map].width, v * LAND_Texture_Map[n_Map].height);
                }

                if (target_window == 4) {
                  if (_turn == 1) {
                    SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                  }
                  if (_turn == 2) { 

                    v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

                    SOLARCHVISION_OBJprintVtexture(u, v, 0);
                  }
                  if (_turn == 3) {
                    num_vertices_added += 1;
                  }
                }



             
              }
            }


            if (target_window == 3) {
              WIN3D_Diagrams.endShape(CLOSE);
            }

            if (target_window == 4) {

              if (_turn == 3) {

                String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

                String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          

                obj_lastFaceNumber += 1;
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
                if (objExport_BackSides != 0) {
                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                }
              }
            }


            if (Display_LAND_Texture != 0) {

              if (Display_LAND_DEPTH != 0) {


                if (target_window == 3) {
                  WIN3D_Diagrams.fill(223, 223, 223);
                  WIN3D_Diagrams.noStroke();
                }

                for (int s = 0; s < subFace.length; s++) {

                  int s_next = (s + 1) % subFace.length;

                  float u = (subFace[s][0] / LAND_Texture_scale_U[n_Map] + 0.5);
                  float v = (-subFace[s][1] / LAND_Texture_scale_V[n_Map] + 0.5);

                  float u_next = (subFace[s_next][0] / LAND_Texture_scale_U[n_Map] + 0.5);
                  float v_next = (-subFace[s_next][1] / LAND_Texture_scale_V[n_Map] + 0.5);

                  if (target_window == 3) {

                    WIN3D_Diagrams.beginShape();

                    WIN3D_Diagrams.texture(LAND_Texture_Map[n_Map]);                  

                    WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D, u * LAND_Texture_Map[n_Map].width, v * LAND_Texture_Map[n_Map].height);
                    WIN3D_Diagrams.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s_next][1] * OBJECTS_scale * WIN3D_Scale3D, subFace[s_next][2] * OBJECTS_scale * WIN3D_Scale3D, u_next * LAND_Texture_Map[n_Map].width, v_next * LAND_Texture_Map[n_Map].height);
                    WIN3D_Diagrams.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s_next][1] * OBJECTS_scale * WIN3D_Scale3D, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D_Scale3D, u_next * LAND_Texture_Map[n_Map].width, v_next * LAND_Texture_Map[n_Map].height);
                    WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D_Scale3D, u * LAND_Texture_Map[n_Map].width, v * LAND_Texture_Map[n_Map].height);

                    WIN3D_Diagrams.endShape(CLOSE);
                  }
                }
              }
            }
          }
        }
      }
    }

    if (target_window == 4) {
      obj_lastVertexNumber += num_vertices_added;
      obj_lastVtextureNumber += num_vertices_added;
    }    

    if (target_window == 3) {
      if (Display_LAND_POINTS != 0) {

        WIN3D_Diagrams.fill(191, 191, 0); 
        WIN3D_Diagrams.noStroke();

        WIN3D_Diagrams.sphereDetail(6, 4);

        for (int i = 0; i < LAND_n_I; i += 1) {
          for (int j = 0; j < LAND_n_J; j += 1) {

            float x = LAND_MESH[i][j][0];
            float y = LAND_MESH[i][j][1];
            float z = LAND_MESH[i][j][2];

            float R = 2.0 * OBJECTS_scale; // <<<<<<<<<<

            WIN3D_Diagrams.pushMatrix();
            WIN3D_Diagrams.translate(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
            WIN3D_Diagrams.sphere(R);
            WIN3D_Diagrams.popMatrix();
          }
        }
      }
    }
  }
}



float[] SOLARCHVISION_vertexRender_Shade_Surface_White (int c) {  

  float[] COL = {
    c, c, c, c
  };

  return COL;
}

float[] SOLARCHVISION_vertexRender_Shade_Surface_Materials (int mt) {  

  float[] COL = {
    Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]
  };

  return COL;
}


float[] SOLARCHVISION_vertexRender_Shade_Vertex_Solid (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  float _u = SOLARCHVISION_vertexU_Shade_Vertex_Solid(VERTEX_now, PAL_TYPE, PAL_DIR, PAL_Multiplier);

  float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);     

  return COL;
}


float SOLARCHVISION_vertexU_Shade_Vertex_Solid (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  SolidImpactType = 0;
  float val = SOLARCHVISION_get_SolidImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);

  float _u = 0.5 + 0.5 * (PAL_Multiplier * val);

  if (PAL_DIR == -1) _u = 1 - _u;
  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
  if (PAL_DIR == 2) _u =  0.5 * _u;

  return _u;
}


float[] SOLARCHVISION_vertexRender_Shade_Vertex_Elevation (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  float _u = SOLARCHVISION_vertexU_Shade_Vertex_Elevation(VERTEX_now, PAL_TYPE, PAL_DIR, PAL_Multiplier);

  float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);  

  return COL;
}

float SOLARCHVISION_vertexU_Shade_Vertex_Elevation (float[] VERTEX_now, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  float _u = 0.5 + 0.5 * (PAL_Multiplier * VERTEX_now[2]);

  if (PAL_DIR == -1) _u = 1 - _u;
  if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
  if (PAL_DIR == 2) _u =  0.5 * _u;

  return _u;
}


float[] SOLARCHVISION_vertexRender_Shade_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  float _u = SOLARCHVISION_vertexU_Shade_Global_Solar(VERTEX_now, VERTEX_prev, VERTEX_next, PAL_TYPE, PAL_DIR, PAL_Multiplier);

  float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

  return COL;
}

float SOLARCHVISION_vertexU_Shade_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_TYPE, int PAL_DIR, float PAL_Multiplier) {

  PVector U = new PVector(VERTEX_next[0] - VERTEX_now[0], VERTEX_next[1] - VERTEX_now[1], VERTEX_next[2] - VERTEX_now[2]);
  PVector V = new PVector(VERTEX_prev[0] - VERTEX_now[0], VERTEX_prev[1] - VERTEX_now[1], VERTEX_prev[2] - VERTEX_now[2]);
  PVector UV = U.cross(V);
  float[] W = {
    UV.x, UV.y, UV.z
  };
  W = SOLARCHVISION_fn_normalize(W);

  float Alpha = asin_ang(W[2]);
  float Beta = atan2_ang(W[1], W[0]) + 90;       

  int a = int((Alpha + 90) / SOLARCHVISION_GLOBE_stp_slp);
  int b = int(Beta / SOLARCHVISION_GLOBE_stp_dir);

  if (a < 0) a += int(180 / SOLARCHVISION_GLOBE_stp_slp);
  if (b < 0) b += int(360 / SOLARCHVISION_GLOBE_stp_dir);
  if (a > int(180 / SOLARCHVISION_GLOBE_stp_slp)) a -= int(180 / SOLARCHVISION_GLOBE_stp_slp);
  if (b > int(360 / SOLARCHVISION_GLOBE_stp_dir)) b -= int(360 / SOLARCHVISION_GLOBE_stp_dir);

  float _valuesSUM = LocationExposure[IMPACTS_DisplayDay][a][b];

  float _u = 0;

  if (_valuesSUM < 0.9 * FLOAT_undefined) {

    if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

    if (PAL_DIR == -1) _u = 1 - _u;
    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_DIR == 2) _u =  0.5 * _u;
  }

  return _u;
}



int SOLARCHVISION_getShader_PAL_TYPE () {

  int PAL_TYPE = 0; 

  if (WIN3D_FacesShade == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR;
    if (Impact_TYPE == Impact_PASSIVE) PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR;
  }              

  if (WIN3D_FacesShade == Shade_Vertex_Solid) {
    PAL_TYPE = SOLID_Pallet_CLR;
  }                  

  if (WIN3D_FacesShade == Shade_Vertex_Elevation) {
    PAL_TYPE = ELEVATION_Pallet_CLR;
  }  

  return PAL_TYPE;
}


int SOLARCHVISION_getShader_PAL_DIR () {

  int PAL_DIR = 1;

  if (WIN3D_FacesShade == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;
    if (Impact_TYPE == Impact_PASSIVE) PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
  }              

  if (WIN3D_FacesShade == Shade_Vertex_Solid) {
    PAL_DIR = SOLID_Pallet_DIR;
  }                  

  if (WIN3D_FacesShade == Shade_Vertex_Elevation) {
    PAL_DIR = ELEVATION_Pallet_DIR;
  }  

  return PAL_DIR;
}


float SOLARCHVISION_getShader_PAL_Multiplier () {

  float PAL_Multiplier = 1; 

  if (WIN3D_FacesShade == Shade_Global_Solar) {
    if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
    if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
  }              

  if (WIN3D_FacesShade == Shade_Vertex_Solid) {
    PAL_Multiplier = SOLID_Pallet_MLT;
  }                  

  if (WIN3D_FacesShade == Shade_Vertex_Elevation) {
    PAL_Multiplier = ELEVATION_Pallet_MLT;
  }

  return PAL_Multiplier;
}



int Shade_Surface_Wire = -1;
int Shade_Surface_Base = 0;
int Shade_Surface_White = 1;
int Shade_Surface_Materials = 2;
int Shade_Global_Solar = 3;
int Shade_Vertex_Solar = 4;
int Shade_Vertex_Solid = 5;
int Shade_Vertex_Elevation = 6;

int Shade_Options_num = 7;

int WIN3D_FacesShade = Shade_Surface_Materials; //Shade_Surface_White; // <<<<<





void SOLARCHVISION_draw_Group3Ds () {

  if (Display_Model3Ds != 0) {

    if (MODEL3D_DisplayNormals != 0) {

      for (int f = 1; f < allFaces_PNT.length; f++) {

        int vsb = allFaces_MTLV[f][3];

        if (vsb > 0) {

          float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
          for (int j = 0; j < allFaces_PNT[f].length; j++) {
            int vNo = allFaces_PNT[f][j];
            base_Vertices[j][0] = allVertices[vNo][0];
            base_Vertices[j][1] = allVertices[vNo][1];
            base_Vertices[j][2] = allVertices[vNo][2];
          }

          float G_x0 = 0;
          float G_y0 = 0;
          float G_z0 = 0;

          float G_x1 = 0;
          float G_y1 = 0;
          float G_z1 = 0;

          float n = float(base_Vertices.length);

          for (int s = 0; s < base_Vertices.length; s++) {

            int s_next = (s + 1) % base_Vertices.length;
            int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;

            PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
            PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
            PVector UV = U.cross(V);
            float[] W = {
              UV.x, UV.y, UV.z
            };
            W = SOLARCHVISION_fn_normalize(W);

            float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D_Scale3D;
            float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D_Scale3D;
            float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D_Scale3D;

            float x1 = (base_Vertices[s][0] + W[0]) * OBJECTS_scale * WIN3D_Scale3D;
            float y1 = (base_Vertices[s][1] + W[1]) * OBJECTS_scale * WIN3D_Scale3D;
            float z1 = (base_Vertices[s][2] + W[2]) * OBJECTS_scale * WIN3D_Scale3D;

            G_x0 += x0 / n;
            G_y0 += y0 / n;
            G_z0 += z0 / n;

            G_x1 += x1 / n;
            G_y1 += y1 / n;
            G_z1 += z1 / n;
          }

          WIN3D_Diagrams.strokeWeight(3);
          WIN3D_Diagrams.stroke(127, 255, 127);
          WIN3D_Diagrams.line(G_x0, -G_y0, G_z0, G_x1, -G_y1, G_z1);        

          WIN3D_Diagrams.strokeWeight(1);
          WIN3D_Diagrams.stroke(0, 127, 0);

          for (int s = 0; s < base_Vertices.length; s++) {

            float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D_Scale3D;
            float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D_Scale3D;
            float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D_Scale3D;

            WIN3D_Diagrams.line(x0, -y0, z0, G_x1, -G_y1, G_z1);
          }
        }
      }
    }

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0, 0, 0);
    if (MODEL3D_DisplayEdges == 0) WIN3D_Diagrams.noStroke();

    int PAL_TYPE = SOLARCHVISION_getShader_PAL_TYPE(); 
    int PAL_DIR = SOLARCHVISION_getShader_PAL_DIR();
    float PAL_Multiplier = SOLARCHVISION_getShader_PAL_Multiplier(); 

    if ((WIN3D_FacesShade == Shade_Global_Solar) || (WIN3D_FacesShade == Shade_Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
        PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      }             

      if (Impact_TYPE == Impact_ACTIVE) PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT; 
      if (Impact_TYPE == Impact_PASSIVE) PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
    }              

    if (WIN3D_FacesShade == Shade_Surface_Materials) {
    }              

    if (WIN3D_FacesShade == Shade_Surface_White) {
    }     

    if (WIN3D_FacesShade == Shade_Vertex_Solid) {
    }                  

    if (WIN3D_FacesShade == Shade_Vertex_Elevation) {
    }




    if (WIN3D_FacesShade != Shade_Vertex_Solar) {
      for (int f = 1; f < allFaces_PNT.length; f++) {

        int vsb = allFaces_MTLV[f][3];

        if (vsb > 0) {        

          if (((LoadButton_UrbanMesh == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
          } else {

            if (WIN3D_FacesShade == Shade_Surface_Base) {

              WIN3D_Diagrams.fill(255, 255, 255);

              WIN3D_Diagrams.beginShape();

              for (int j = 0; j < allFaces_PNT[f].length; j++) {
                int vNo = allFaces_PNT[f][j];

                WIN3D_Diagrams.vertex(allVertices[vNo][0] * OBJECTS_scale * WIN3D_Scale3D, -(allVertices[vNo][1] * OBJECTS_scale * WIN3D_Scale3D), allVertices[vNo][2] * OBJECTS_scale * WIN3D_Scale3D);
              }    

              WIN3D_Diagrams.endShape(CLOSE);
            } else {

              int mt = allFaces_MTLV[f][0];

              int Tessellation = allFaces_MTLV[f][1];

              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_Tessellation;
              }
              if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

              float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
              for (int j = 0; j < allFaces_PNT[f].length; j++) {
                int vNo = allFaces_PNT[f][j];
                base_Vertices[j][0] = allVertices[vNo][0];
                base_Vertices[j][1] = allVertices[vNo][1];
                base_Vertices[j][2] = allVertices[vNo][2];
              }

              for (int n = 0; n < TotalSubNo; n++) {

                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                WIN3D_Diagrams.beginShape();

                for (int s = 0; s < subFace.length; s++) {

                  if (WIN3D_FacesShade != Shade_Surface_Wire) {

                    float[] COL = {
                      255, 255, 255, 255
                    };

                    if (WIN3D_FacesShade == Shade_Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;

                      COL = SOLARCHVISION_vertexRender_Shade_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }              

                    if (WIN3D_FacesShade == Shade_Surface_Materials) {
                      COL = SOLARCHVISION_vertexRender_Shade_Surface_Materials(mt);
                    }              

                    if (WIN3D_FacesShade == Shade_Surface_White) {
                      COL = SOLARCHVISION_vertexRender_Shade_Surface_White(255);
                    }     

                    if (WIN3D_FacesShade == Shade_Vertex_Solid) {

                      COL = SOLARCHVISION_vertexRender_Shade_Vertex_Solid(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }                  

                    if (WIN3D_FacesShade == Shade_Vertex_Elevation) {

                      COL = SOLARCHVISION_vertexRender_Shade_Vertex_Elevation(subFace[s], PAL_TYPE, PAL_DIR, PAL_Multiplier);
                    }

                    WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);
                  } else {
                    WIN3D_Diagrams.noFill();
                  }


                  WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D);
                }

                WIN3D_Diagrams.endShape(CLOSE);
              }
            }
          }
        }
      }
    } else if (WIN3D_FacesShade == Shade_Vertex_Solar) {
      if (WIN3D_VerticesSolarValue_Update == 0) {
        try {

          int N_baked = 0;

          for (int f = 1; f < allFaces_PNT.length; f++) {

            int vsb = allFaces_MTLV[f][3];

            if (vsb > 0) {

              if (((LoadButton_UrbanMesh == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
              } else {

                int Tessellation = allFaces_MTLV[f][1];

                int TotalSubNo = 1;  
                if (allFaces_MTLV[f][0] == 0) {
                  Tessellation += MODEL3D_Tessellation;
                }
                if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

                float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
                for (int j = 0; j < allFaces_PNT[f].length; j++) {
                  int vNo = allFaces_PNT[f][j];
                  base_Vertices[j][0] = allVertices[vNo][0];
                  base_Vertices[j][1] = allVertices[vNo][1];
                  base_Vertices[j][2] = allVertices[vNo][2];
                }     

                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                  WIN3D_Diagrams.beginShape();

                  for (int s = 0; s < subFace.length; s++) {

                    N_baked += 1;

                    float _valuesSUM = 0;
                    if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = WIN3D_VerticesSolarEnergy[N_baked];
                    if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = WIN3D_VerticesSolarEffect[N_baked];

                    if (_valuesSUM < 0.9 * FLOAT_undefined) {

                      float _u = 0;

                      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

                      if (PAL_DIR == -1) _u = 1 - _u;
                      if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_DIR == 2) _u =  0.5 * _u;

                      float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

                      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);          

                      WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D);
                    }
                  }

                  WIN3D_Diagrams.endShape(CLOSE);
                }
              }
            }
          }
        } 
        catch (Exception e) {
          WIN3D_VerticesSolarValue_Update = 1; 
          WIN3D_Update = 1;
        }
      } else {
        cursor(WAIT);

        WIN3D_VerticesSolarEnergy = new float [1];
        WIN3D_VerticesSolarEffect = new float [1];
        WIN3D_VerticesSolarEnergy[0] = FLOAT_undefined; 
        WIN3D_VerticesSolarEffect[0] = FLOAT_undefined; 

        float keep_STUDY_PerDays = STUDY_PerDays;
        int keep_STUDY_JoinDays = STUDY_JoinDays;
        if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
          STUDY_PerDays = 1;
          STUDY_JoinDays = 1;
        }

        int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
        int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
        int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2]; 

        Impact_TYPE = Impact_ACTIVE; 
        if (STUDY_PlotImpacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;

        float Pa = FLOAT_undefined;
        float Pb = FLOAT_undefined;
        float Pc = FLOAT_undefined;
        float Pd = FLOAT_undefined;

        float _values_R_dir;
        float _values_R_dif;
        float _values_E_dir;
        float _values_E_dif;

        int now_k = 0;
        int now_i = 0;
        int now_j = 0;

        int[][] PROCESSED_DAILY_SCENARIOS = {
          {
          }
        };  

        for (int f = 1; f < allFaces_PNT.length; f++) {

          println("calculating %", nf(100.0 * f / (1.0 * allFaces_PNT.length), 0, 2)); 

          int vsb = allFaces_MTLV[f][3];

          if (vsb > 0) {

            if (((LoadButton_UrbanMesh == 0) || (Display_URBAN_MESH == 0)) && (urbanFaces_start <= f) && (urbanFaces_end >= f)) {
            } else {    

              int Tessellation = allFaces_MTLV[f][1];

              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_Tessellation;
              }
              if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

              float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
              for (int j = 0; j < allFaces_PNT[f].length; j++) {
                int vNo = allFaces_PNT[f][j];
                base_Vertices[j][0] = allVertices[vNo][0];
                base_Vertices[j][1] = allVertices[vNo][1];
                base_Vertices[j][2] = allVertices[vNo][2];
              }     

              for (int n = 0; n < TotalSubNo; n++) {

                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                WIN3D_Diagrams.beginShape();

                for (int s = 0; s < subFace.length; s++) {

                  int s_next = (s + 1) % subFace.length;
                  int s_prev = (s + subFace.length - 1) % subFace.length;

                  PVector U = new PVector(subFace[s_next][0] - subFace[s][0], subFace[s_next][1] - subFace[s][1], subFace[s_next][2] - subFace[s][2]);
                  PVector V = new PVector(subFace[s_prev][0] - subFace[s][0], subFace[s_prev][1] - subFace[s][1], subFace[s_prev][2] - subFace[s][2]);
                  PVector UV = U.cross(V);
                  float[] W = {
                    UV.x, UV.y, UV.z
                  };
                  W = SOLARCHVISION_fn_normalize(W);

                  float Alpha = asin_ang(W[2]);
                  float Beta = atan2_ang(W[1], W[0]) + 90; 

                  float _valuesSUM_RAD = 0;
                  float _valuesSUM_EFF_P = 0;
                  float _valuesSUM_EFF_N = 0;
                  int _valuesNUM = 0; 


                  int l = STUDY_ImpactLayer;

                  int DATE_step = 1;
            
                  int J_START = STUDY_j_Start;
                  int J_END = STUDY_j_End;
            
                  if (IMPACTS_DisplayDay > 0) {
                    J_START = IMPACTS_DisplayDay - 1;
                    J_END = IMPACTS_DisplayDay;
                  }
            
                  for (int j = J_START; j < J_END; j += DATE_step) {

                    now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

                    if (now_j >= 365) {
                      now_j = now_j % 365;
                    }
                    if (now_j < 0) {
                      now_j = (now_j + 365) % 365;
                    }

                    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

                    float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
                    float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

                    int[] Normals_COL_N;


                    if (PROCESSED_DAILY_SCENARIOS.length > STUDY_j_End - STUDY_j_Start) {
                      Normals_COL_N = PROCESSED_DAILY_SCENARIOS[STUDY_j_End - STUDY_j_Start];
                    } else {
                      Normals_COL_N = new int [9];
                      Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

                      int[][] newNormals = {
                        Normals_COL_N
                      };
                      PROCESSED_DAILY_SCENARIOS = (int[][]) concat(PROCESSED_DAILY_SCENARIOS, newNormals);
                      println("length of PROCESSED_DAILY_SCENARIOS =", PROCESSED_DAILY_SCENARIOS.length);
                    }

                    int nk = Normals_COL_N[l];

                    if (nk != -1) {
                      int k = int(nk / STUDY_JoinDays);
                      int j_ADD = nk % STUDY_JoinDays; 


                      for (int i = 0; i < 24; i += 1) {

                        if (STUDY_isInHourlyRange(i) == 1) {

                          float HOUR_ANGLE = i; 
                          float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                          if (SunR[3] > 0) {

                            now_k = k;
                            now_i = i;
                            now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                            if (now_j >= 365) {
                              now_j = now_j % 365;
                            }
                            if (now_j < 0) {
                              now_j = (now_j + 365) % 365;
                            }

                            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                              Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                              Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                              Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
                              Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
                            }
                            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                              Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                              Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                              Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
                              Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
                            }                            
                            if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                              Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                              Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                              Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
                              Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
                            }            
                            if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                              Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                              Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                              Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
                              Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
                            }   
                            if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                              Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                              Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                              Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
                              Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
                            }       

                            if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                              _values_R_dir = FLOAT_undefined;
                              _values_R_dif = FLOAT_undefined;
                              _values_E_dir = FLOAT_undefined;
                              _values_E_dif = FLOAT_undefined;
                            } else {

                              int drw_count = 0;
                              if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                              if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                              if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                              if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                              if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                              if (drw_count == 1) {
                                _values_R_dir = 0.001 * Pa; 
                                _values_R_dif = 0.001 * Pb;  
                                _values_E_dir = 0.001 * Pc;
                                _values_E_dif = 0.001 * Pd;

                                if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                                  _valuesSUM_RAD = 0;
                                  _valuesSUM_EFF_P = 0;
                                  _valuesSUM_EFF_N = 0;
                                  _valuesNUM = 0;
                                } else {

                                  float[] VECT = {
                                    0, 0, 0
                                  }; 

                                  if (abs(Alpha) > 89.99) {
                                    VECT[0] = 0;
                                    VECT[1] = 0;
                                    VECT[2] = 1;
                                  } else if (Alpha < -89.99) {
                                    VECT[0] = 0;
                                    VECT[1] = 0;
                                    VECT[2] = -1;
                                  } else {
                                    VECT[0] = sin_ang(Beta);
                                    VECT[1] = -cos_ang(Beta);
                                    VECT[2] = tan_ang(Alpha);
                                  }  

                                  VECT = SOLARCHVISION_fn_normalize(VECT);

                                  float[] SunV = {
                                    SunR[1], SunR[2], SunR[3]
                                  };

                                  float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
                                  if (SunMask <= 0) SunMask = 0; // removes backing faces 

                                  float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));

                                  float[] ray_start = subFace[s];     
                                  float[] ray_direction = {
                                    SunR[1], SunR[2], SunR[3]
                                  }; 

                                  if (SOLARCHVISION_fn_dot(W, ray_direction) > 0) { // removes backing faces

                                    if (SOLARCHVISION_is3Dintersected(ray_start, ray_direction) == 1) { 
                                      if (_values_E_dir < 0) {
                                        _valuesSUM_EFF_P += -(_values_E_dir * SunMask); 
                                        _valuesSUM_EFF_N += -(_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
                                      } else {
                                        _valuesSUM_EFF_N += (_values_E_dir * SunMask); 
                                        _valuesSUM_EFF_P += (_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
                                      }

                                      _valuesSUM_RAD += (_values_R_dif * SkyMask); // only approximate diffuse radiation!
                                    } else { 
                                      if (_values_E_dir < 0) {
                                        _valuesSUM_EFF_N += -((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
                                      } else {
                                        _valuesSUM_EFF_P += ((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
                                      }

                                      _valuesSUM_RAD += ((_values_R_dir * SunMask) + (_values_R_dif * SkyMask)); // calculates total radiation
                                    }
                                  }
                                  _valuesNUM += 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }    

                  float _valuesMUL = 0;

                  if (_valuesNUM != 0) {
                    _valuesMUL = 12.0 / (1.0 * _valuesNUM); // this might be approximate!

                    _valuesSUM_RAD *= _valuesMUL;
                    _valuesSUM_EFF_P *= _valuesMUL;
                    _valuesSUM_EFF_N *= _valuesMUL;
                  } else {
                    _valuesSUM_RAD = 0; //FLOAT_undefined;
                    _valuesSUM_EFF_P = 0; //FLOAT_undefined;
                    _valuesSUM_EFF_N = 0; //FLOAT_undefined;
                  }                   



                  float AVERAGE, PERCENTAGE, COMPARISON;

                  AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
                  if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
                  else PERCENTAGE = 0.0;
                  COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

                  //println("3D-Model >> _valuesSUM_RAD:", _valuesSUM_RAD, "|COMPARISON:", COMPARISON);

                  {
                    float[] ADD_values_RAD = {
                      _valuesSUM_RAD
                    };
                    WIN3D_VerticesSolarEnergy = concat(WIN3D_VerticesSolarEnergy, ADD_values_RAD);

                    float[] ADD_values_EFF = {
                      COMPARISON
                    };
                    WIN3D_VerticesSolarEffect = concat(WIN3D_VerticesSolarEffect, ADD_values_EFF);
                  }

                  float _valuesSUM = 0;
                  if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON;

                  if (_valuesSUM < 0.9 * FLOAT_undefined) {

                    float _u = 0;

                    if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);

                    if (PAL_DIR == -1) _u = 1 - _u;
                    if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_DIR == 2) _u =  0.5 * _u;

                    float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

                    WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

                    WIN3D_Diagrams.vertex(subFace[s][0] * OBJECTS_scale * WIN3D_Scale3D, -(subFace[s][1] * OBJECTS_scale * WIN3D_Scale3D), subFace[s][2] * OBJECTS_scale * WIN3D_Scale3D);
                  }
                }
                WIN3D_Diagrams.endShape(CLOSE);
              }
            }
          }
        }
        WIN3D_VerticesSolarValue_Update = 0;

        cursor(ARROW);
      }
    }
  }
}


float Orthographic_ZOOM () {

  float ZOOM = 0.5 * WIN3D_Zoom * PI / 180;

  return ZOOM;
}


void SOLARCHVISION_look_3DViewport_towards_Selection () {

  SOLARCHVISION_lookXY_3DViewport_towards_Selection();
  SOLARCHVISION_lookZ_3DViewport_towards_Selection();
}

void SOLARCHVISION_lookXY_3DViewport_towards_Selection () {

  float xO = WIN3D_CAM_x / OBJECTS_scale;
  float yO = WIN3D_CAM_y / OBJECTS_scale;
  float zO = WIN3D_CAM_z / OBJECTS_scale;

  float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
  float xA = ray_end[0] / OBJECTS_scale;
  float yA = ray_end[1] / OBJECTS_scale;
  float zA = ray_end[2] / OBJECTS_scale;

  float[] P = SOLARCHVISION_getPivot();

  float xB = P[0];
  float yB = P[1];
  float zB = P[2];  


  WIN3D_RZ_Coordinate += atan2_ang((yB - yO), (xB - xO)) - atan2_ang((yA - yO), (xA - xO));

  SOLARCHVISION_reverseTransform_3DViewport();
}


void SOLARCHVISION_lookZ_3DViewport_towards_Selection () {

  float xO = WIN3D_CAM_x / OBJECTS_scale;
  float yO = WIN3D_CAM_y / OBJECTS_scale;
  float zO = WIN3D_CAM_z / OBJECTS_scale;

  float[] ray_end = SOLARCHVISION_calculate_Click3D(0, 0);  
  float xA = ray_end[0] / OBJECTS_scale;
  float yA = ray_end[1] / OBJECTS_scale;
  float zA = ray_end[2] / OBJECTS_scale;

  float[] P = SOLARCHVISION_getPivot();

  float xB = P[0];
  float yB = P[1];
  float zB = P[2];  

  WIN3D_RX_Coordinate += atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));

  SOLARCHVISION_reverseTransform_3DViewport();
}

void SOLARCHVISION_move_3DViewport_towards_Mouse (float t) {

  float xA = WIN3D_CAM_x / OBJECTS_scale;
  float yA = WIN3D_CAM_y / OBJECTS_scale;
  float zA = WIN3D_CAM_z / OBJECTS_scale;

  float Image_X = mouseX - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
  float Image_Y = mouseY - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);

  float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);  
  float xO = ray_end[0] / OBJECTS_scale;
  float yO = ray_end[1] / OBJECTS_scale;
  float zO = ray_end[2] / OBJECTS_scale;

  float dx = xA - xO;
  float dy = yA - yO;
  float dz = zA - zO;

  float xB = xO + t * dx; 
  float yB = yO + t * dy;
  float zB = zO + t * dz;

  WIN3D_CAM_x = xB * OBJECTS_scale;           
  WIN3D_CAM_y = yB * OBJECTS_scale;
  WIN3D_CAM_z = zB * OBJECTS_scale;     

  SOLARCHVISION_reverseTransform_3DViewport();


  //WIN3D_S_Coordinate *= t; // just to adjust panning better
}

void SOLARCHVISION_move_3DViewport_towards_Selection (float t) {

  float xA = WIN3D_CAM_x / OBJECTS_scale;
  float yA = WIN3D_CAM_y / OBJECTS_scale;
  float zA = WIN3D_CAM_z / OBJECTS_scale;

  float[] P = SOLARCHVISION_getPivot();

  float xO = P[0];
  float yO = P[1];
  float zO = P[2];         

  float dx = xA - xO;
  float dy = yA - yO;
  float dz = zA - zO;

  float xB = xO + t * dx; 
  float yB = yO + t * dy;
  float zB = zO + t * dz;

  WIN3D_CAM_x = xB * OBJECTS_scale;           
  WIN3D_CAM_y = yB * OBJECTS_scale;
  WIN3D_CAM_z = zB * OBJECTS_scale;     

  SOLARCHVISION_reverseTransform_3DViewport();


  //WIN3D_S_Coordinate *= t; // just to adjust panning better
}

void SOLARCHVISION_rotateZ_3DViewport_around_Selection (float t) {

  WIN3D_RX_Coordinate += t;

  float xA = WIN3D_CAM_x / OBJECTS_scale;
  float yA = WIN3D_CAM_y / OBJECTS_scale;
  float zA = WIN3D_CAM_z / OBJECTS_scale;

  float[] P = SOLARCHVISION_getPivot();

  float xO = P[0];
  float yO = P[1];
  float zO = P[2];         

  float xB = xA - xO;
  float yB = yA - yO;
  float zB = zA - zO;

  // rotate to make it on yz plane

  float xC = xB * cos_ang(-WIN3D_RZ_Coordinate) - yB * sin_ang(-WIN3D_RZ_Coordinate); 
  float yC = xB * sin_ang(-WIN3D_RZ_Coordinate) + yB * cos_ang(-WIN3D_RZ_Coordinate);
  float zC = zB;

  // rotate it on yz plane

  float xD = xC;
  float yD = yC * cos_ang(t) - zC * sin_ang(t);
  float zD = yC * sin_ang(t) + zC * cos_ang(t);

  // rotate to back from yz plane

  float xE = xD * cos_ang(WIN3D_RZ_Coordinate) - yD * sin_ang(WIN3D_RZ_Coordinate); 
  float yE = xD * sin_ang(WIN3D_RZ_Coordinate) + yD * cos_ang(WIN3D_RZ_Coordinate);
  float zE = zD;

  float xF = xE + xO;
  float yF = yE + yO;
  float zF = zE + zO;

  WIN3D_CAM_x = xF * OBJECTS_scale;           
  WIN3D_CAM_y = yF * OBJECTS_scale;
  WIN3D_CAM_z = zF * OBJECTS_scale; 

  SOLARCHVISION_reverseTransform_3DViewport();
}


void SOLARCHVISION_rotateXY_3DViewport_around_Selection (float t) {

  WIN3D_RZ_Coordinate += t;

  float xA = WIN3D_CAM_x / OBJECTS_scale;
  float yA = WIN3D_CAM_y / OBJECTS_scale;
  float zA = WIN3D_CAM_z / OBJECTS_scale;

  float[] P = SOLARCHVISION_getPivot();

  float xO = P[0];
  float yO = P[1];
  float zO = P[2];             

  float dx = xA - xO;
  float dy = yA - yO;

  float xB = xO + dx * cos_ang(t) - dy * sin_ang(t); 
  float yB = yO + dx * sin_ang(t) + dy * cos_ang(t);
  float zB = zA;

  WIN3D_CAM_x = xB * OBJECTS_scale;           
  WIN3D_CAM_y = yB * OBJECTS_scale;
  WIN3D_CAM_z = zB * OBJECTS_scale;   

  SOLARCHVISION_reverseTransform_3DViewport();
}


void SOLARCHVISION_reverseTransform_3DViewport () { // computing WIN3D_X_Coordinate, WIN3D_Y_Coordinate and WIN3D_Z_Coordinate from new set of camera start and end points.

  float px, py, pz;

  px = WIN3D_CAM_x;
  py = WIN3D_CAM_y;
  pz = WIN3D_CAM_z;  

  float CAM_x1, CAM_y1, CAM_z1;

  CAM_z1 = pz;
  CAM_x1 = px * cos_ang(-WIN3D_RZ_Coordinate) - py * sin_ang(-WIN3D_RZ_Coordinate);
  CAM_y1 = px * sin_ang(-WIN3D_RZ_Coordinate) + py * cos_ang(-WIN3D_RZ_Coordinate);  

  px = CAM_x1;
  py = CAM_y1;
  pz = CAM_z1;  

  CAM_x1 = px;
  CAM_y1 = py * cos_ang(-WIN3D_RX_Coordinate) - pz * sin_ang(-WIN3D_RX_Coordinate);
  CAM_z1 = py * sin_ang(-WIN3D_RX_Coordinate) + pz * cos_ang(-WIN3D_RX_Coordinate);    


  float CAM_x2, CAM_y2, CAM_z2;

  WIN3D_CAM_fov = WIN3D_Zoom * PI / 180;

  WIN3D_CAM_dist = (0.5 * WIN3D_refScale) / tan(0.5 * WIN3D_CAM_fov);

  CAM_x2 = 0;
  CAM_y2 = 0;
  CAM_z2 = WIN3D_CAM_dist;

  CAM_x2 *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_y2 *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);
  CAM_z2 *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);  


  WIN3D_X_Coordinate = CAM_x2 - CAM_x1; 
  WIN3D_Y_Coordinate = -(CAM_y2 - CAM_y1); 
  WIN3D_Z_Coordinate = CAM_z2 - CAM_z1;
}


void SOLARCHVISION_record_last3DViewport () {

  allCameras_PPPSRRRF[WIN3D_CurrentCamera][0] = WIN3D_X_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][1] = WIN3D_Y_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][2] = WIN3D_Z_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][3] = WIN3D_S_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][4] = WIN3D_RX_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][5] = WIN3D_RY_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][6] = WIN3D_RZ_Coordinate;
  allCameras_PPPSRRRF[WIN3D_CurrentCamera][7] = WIN3D_Zoom;

  allCameras_Type[WIN3D_CurrentCamera] = WIN3D_ViewType;
}  


void SOLARCHVISION_apply_currentCamera () {

  WIN3D_X_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][0];
  WIN3D_Y_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][1];
  WIN3D_Z_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][2];
  WIN3D_S_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][3];
  WIN3D_RX_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][4];
  WIN3D_RY_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][5];
  WIN3D_RZ_Coordinate = allCameras_PPPSRRRF[WIN3D_CurrentCamera][6];
  WIN3D_Zoom = allCameras_PPPSRRRF[WIN3D_CurrentCamera][7];

  WIN3D_ViewType = allCameras_Type[WIN3D_CurrentCamera];
}  


void SOLARCHVISION_transform_3DViewport () {

  WIN3D_CAM_fov = WIN3D_Zoom * PI / 180;

  WIN3D_CAM_dist = (0.5 * WIN3D_refScale) / tan(0.5 * WIN3D_CAM_fov);

  WIN3D_CAM_x = 0;
  WIN3D_CAM_y = 0;
  WIN3D_CAM_z = WIN3D_CAM_dist;


  WIN3D_CAM_x *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);
  WIN3D_CAM_y *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);
  WIN3D_CAM_z *= tan(0.5 * WIN3D_CAM_fov) / tan(0.5 * PI / 3.0);

  WIN3D_CAM_x -= WIN3D_X_Coordinate;
  WIN3D_CAM_y += WIN3D_Y_Coordinate;
  WIN3D_CAM_z -= WIN3D_Z_Coordinate;

  float px, py, pz;

  px = WIN3D_CAM_x;
  py = WIN3D_CAM_y * cos_ang(WIN3D_RX_Coordinate) - WIN3D_CAM_z * sin_ang(WIN3D_RX_Coordinate);
  pz = WIN3D_CAM_y * sin_ang(WIN3D_RX_Coordinate) + WIN3D_CAM_z * cos_ang(WIN3D_RX_Coordinate);

  WIN3D_CAM_x = px;
  WIN3D_CAM_y = py;
  WIN3D_CAM_z = pz;

  pz = WIN3D_CAM_z;
  px = WIN3D_CAM_x * cos_ang(WIN3D_RZ_Coordinate) - WIN3D_CAM_y * sin_ang(WIN3D_RZ_Coordinate);
  py = WIN3D_CAM_x * sin_ang(WIN3D_RZ_Coordinate) + WIN3D_CAM_y * cos_ang(WIN3D_RZ_Coordinate);

  WIN3D_CAM_x = px;
  WIN3D_CAM_y = py;
  WIN3D_CAM_z = pz;   

  //println("Camera:", nf(WIN3D_CAM_x,0,4), nf(WIN3D_CAM_y,0,4), nf(WIN3D_CAM_z,0,4));
}



void SOLARCHVISION_put_3DViewport () {  

  if (WIN3D_ViewType == 1) {

    float aspect = 1.0 / WIN3D_R_View;

    float zFar = WIN3D_CAM_dist * WIN3D_CAM_clipFar;
    float zNear = WIN3D_CAM_dist * WIN3D_CAM_clipNear;

    WIN3D_Diagrams.perspective(WIN3D_CAM_fov, aspect, zNear, zFar);

    WIN3D_Diagrams.translate(0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View, 0); // << IMPORTANT!
  } else {

    float ZOOM = Orthographic_ZOOM();

    WIN3D_Diagrams.ortho(ZOOM * WIN3D_X_View * -1, ZOOM * WIN3D_X_View * 1, ZOOM  * WIN3D_Y_View * -1, ZOOM  * WIN3D_Y_View * 1, 0.00001, 100000);

    WIN3D_Diagrams.translate(0, 1.0 * WIN3D_Y_View, 0); // << IMPORTANT!
  }

  WIN3D_Diagrams.translate(WIN3D_X_Coordinate * WIN3D_Scale3D, WIN3D_Y_Coordinate * WIN3D_Scale3D, WIN3D_Z_Coordinate * WIN3D_Scale3D);

  WIN3D_Diagrams.rotateX(WIN3D_RX_Coordinate * PI / 180); 
  WIN3D_Diagrams.rotateZ(WIN3D_RZ_Coordinate * PI / 180);
}





float[][] allObject2Ds_Vertices;
int[][] allObject2Ds_Faces;

void SOLARCHVISION_draw_Object2Ds () {

  allObject2Ds_Faces = new int [1 + allObject2Ds_num][4];

  allObject2Ds_Vertices = new float [4 * allObject2Ds_num + 1][3];
  allObject2Ds_Vertices[0][0] = 0;
  allObject2Ds_Vertices[0][1] = 0;
  allObject2Ds_Vertices[0][2] = 0;

  if (Display_Model2Ds != 0) {

    float[] DistZ = new float [1 + allObject2Ds_num];

    for (int f = 1; f <= allObject2Ds_num; f++) {
      float x = allObject2Ds_XYZS[f][0] * OBJECTS_scale;
      float y = allObject2Ds_XYZS[f][1] * OBJECTS_scale;
      float z = allObject2Ds_XYZS[f][2] * OBJECTS_scale;

      DistZ[f] = dist(x, y, z, WIN3D_CAM_x, WIN3D_CAM_y, WIN3D_CAM_z);
    }

    for (int g = 1; g <= allObject2Ds_num; g++) {

      int f = 0;
      float max_dist = -1;

      for (int q = 1; q <= allObject2Ds_num; q++) {
        if (max_dist < DistZ[q]) {
          max_dist = DistZ[q];
          f = q;
        }
      }

      DistZ[f] = -1;



      if (f != 0) {

        int n = abs(allObject2Ds_MAP[f]);

        int w = Object2D_Images[n].width; 
        int h = Object2D_Images[n].height;

        float x = allObject2Ds_XYZS[f][0] * OBJECTS_scale;
        float y = allObject2Ds_XYZS[f][1] * OBJECTS_scale;
        float z = allObject2Ds_XYZS[f][2] * OBJECTS_scale;

        float rh = allObject2Ds_XYZS[f][3] * 0.5 * OBJECTS_scale;
        float rw = rh * Object2D_ImageRatios[n];

        float t = WIN3D_RZ_Coordinate * PI / 180.0;
        if (WIN3D_ViewType == 1) t = atan2(y - WIN3D_CAM_y, x - WIN3D_CAM_x) + 0.5 * PI; 

        if (allObject2Ds_MAP[f] < 0) t += PI;         

        WIN3D_Diagrams.beginShape();

        WIN3D_Diagrams.texture(Object2D_Images[n]);    
        WIN3D_Diagrams.stroke(255, 255, 255, 0);
        WIN3D_Diagrams.fill(255, 255, 255, 0);

        WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_Scale3D, -(y - rw * sin(t)) * WIN3D_Scale3D, z * WIN3D_Scale3D, 0, h);
        WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_Scale3D, -(y + rw * sin(t)) * WIN3D_Scale3D, z * WIN3D_Scale3D, w, h);
        WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_Scale3D, -(y + rw * sin(t)) * WIN3D_Scale3D, (z + 2 * rh) * WIN3D_Scale3D, w, 0);
        WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_Scale3D, -(y - rw * sin(t)) * WIN3D_Scale3D, (z + 2 * rh) * WIN3D_Scale3D, 0, 0);

        WIN3D_Diagrams.endShape(CLOSE);

        {
          allObject2Ds_Vertices[f * 4 - 3][0] = (x - rw * cos(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 3][1] = (y - rw * sin(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 3][2] = (z) / OBJECTS_scale;

          allObject2Ds_Vertices[f * 4 - 2][0] = (x + rw * cos(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 2][1] = (y + rw * sin(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 2][2] = (z) / OBJECTS_scale;

          allObject2Ds_Vertices[f * 4 - 1][0] = (x + rw * cos(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 1][1] = (y + rw * sin(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 1][2] = (z + 2 * rh) / OBJECTS_scale;

          allObject2Ds_Vertices[f * 4 - 0][0] = (x - rw * cos(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 0][1] = (y - rw * sin(t)) / OBJECTS_scale;
          allObject2Ds_Vertices[f * 4 - 0][2] = (z + 2 * rh) / OBJECTS_scale;

          allObject2Ds_Faces[f][0] = f * 4 - 3;
          allObject2Ds_Faces[f][1] = f * 4 - 2;
          allObject2Ds_Faces[f][2] = f * 4 - 1;
          allObject2Ds_Faces[f][3] = f * 4 - 0;
        }        



        if (n > Object2D_PEOPLE_Files_Num) { // case: trees   

          float ratio = 0.5;

          for (int back_front = -1; back_front <= 1; back_front += 2) {

            float rot = back_front * PI / 2 + t;

            WIN3D_Diagrams.beginShape();

            WIN3D_Diagrams.texture(Object2D_Images[n]);    
            WIN3D_Diagrams.stroke(255, 255, 255, 0);
            WIN3D_Diagrams.fill(255, 255, 255, 0);

            WIN3D_Diagrams.vertex((x - rw * cos(t)) * WIN3D_Scale3D, -(y - rw * sin(t)) * WIN3D_Scale3D, (z + 2 * rh * ratio) * WIN3D_Scale3D, 0, h * ratio);
            WIN3D_Diagrams.vertex((x + rw * cos(t)) * WIN3D_Scale3D, -(y + rw * sin(t)) * WIN3D_Scale3D, (z + 2 * rh * ratio) * WIN3D_Scale3D, w, h * ratio);
            WIN3D_Diagrams.vertex((x + rw * cos(t) + rw * cos(rot)) * WIN3D_Scale3D, -(y + rw * sin(t) + rw * sin(rot)) * WIN3D_Scale3D, (z + 2 * rh * ratio) * WIN3D_Scale3D, w, 0);
            WIN3D_Diagrams.vertex((x - rw * cos(t) + rw * cos(rot)) * WIN3D_Scale3D, -(y - rw * sin(t) + rw * sin(rot)) * WIN3D_Scale3D, (z + 2 * rh * ratio) * WIN3D_Scale3D, 0, 0);

            WIN3D_Diagrams.endShape(CLOSE);
          }
        }
      }
    }
  }
}


int SOLARCHVISION_is3Dintersected (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  int hit = 0;

  for (int f = 1; f < allFaces_PNT.length; f++) {

    int vsb = allFaces_MTLV[f][3];

    if (vsb > 0) {

      float[] A = allVertices[allFaces_PNT[f][0]];
      float[] B = allVertices[allFaces_PNT[f][1]];
      float[] C = allVertices[allFaces_PNT[f][allFaces_PNT[f].length - 2]];
      float[] D = allVertices[allFaces_PNT[f][allFaces_PNT[f].length - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
      
      float dist2intersect = FLOAT_undefined;
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
    
          float AnglesAll = 0;      
    
          for (int i = 0; i < allFaces_PNT[f].length; i++) {
            int next_i = (i + 1) % allFaces_PNT[f].length;
    
            float[] vect1 = {allVertices[allFaces_PNT[f][i]][0] - X_intersect, allVertices[allFaces_PNT[f][i]][1] - Y_intersect, allVertices[allFaces_PNT[f][i]][2] - Z_intersect};
            float[] vect2 = {allVertices[allFaces_PNT[f][next_i]][0] - X_intersect, allVertices[allFaces_PNT[f][next_i]][1] - Y_intersect, allVertices[allFaces_PNT[f][next_i]][2] - Z_intersect};
    
            float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
    
            AnglesAll += t;
          }
          
          if (AnglesAll > 359) { // <<<<<<<<<
          
            hit = 1;

          }
        }
      }
        
    }
    
    if (hit != 0) break;
  }

  return hit;
}


float[] SOLARCHVISION_3Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allFaces_PNT.length][7];

  for (int f = 1; f < allFaces_PNT.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
    hitPoint[f][4] = FLOAT_undefined;
    hitPoint[f][5] = FLOAT_undefined;
    hitPoint[f][6] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allFaces_PNT.length; f++) {

    int vsb = allFaces_MTLV[f][3];

    if (vsb > 0) {    

      float[] A = allVertices[allFaces_PNT[f][0]];
      float[] B = allVertices[allFaces_PNT[f][1]];
      float[] C = allVertices[allFaces_PNT[f][allFaces_PNT[f].length - 2]];
      float[] D = allVertices[allFaces_PNT[f][allFaces_PNT[f].length - 1]];
      
      float[] AC = SOLARCHVISION_3xSub(A, C);
      float[] BD = SOLARCHVISION_3xSub(B, D);
      
      float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
      
      float dist2intersect = FLOAT_undefined;
    
      float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
    
          float AnglesAll = 0;      
    
          for (int i = 0; i < allFaces_PNT[f].length; i++) {
            int next_i = (i + 1) % allFaces_PNT[f].length;
    
            float[] vect1 = {allVertices[allFaces_PNT[f][i]][0] - X_intersect, allVertices[allFaces_PNT[f][i]][1] - Y_intersect, allVertices[allFaces_PNT[f][i]][2] - Z_intersect};
            float[] vect2 = {allVertices[allFaces_PNT[f][next_i]][0] - X_intersect, allVertices[allFaces_PNT[f][next_i]][1] - Y_intersect, allVertices[allFaces_PNT[f][next_i]][2] - Z_intersect};
    
            float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
    
            AnglesAll += t;
          }
          
          if (AnglesAll > 359) { // <<<<<<<<<
          
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
            hitPoint[f][4] = face_norm[0];
            hitPoint[f][5] = face_norm[1];
            hitPoint[f][6] = face_norm[2];
          }
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allFaces_PNT.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
      return_point[5] = hitPoint[f][4];
      return_point[6] = hitPoint[f][5];
      return_point[7] = hitPoint[f][6];

    }

  }

  return return_point;
}




float[] SOLARCHVISION_2Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allObject2Ds_Faces.length][4];

  for (int f = 1; f < allObject2Ds_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allObject2Ds_Faces.length; f++) {

    float[] A = allObject2Ds_Vertices[allObject2Ds_Faces[f][0]];
    float[] B = allObject2Ds_Vertices[allObject2Ds_Faces[f][1]];
    float[] C = allObject2Ds_Vertices[allObject2Ds_Faces[f][allObject2Ds_Faces[f].length - 2]];
    float[] D = allObject2Ds_Vertices[allObject2Ds_Faces[f][allObject2Ds_Faces[f].length - 1]];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
    
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < allObject2Ds_Faces[f].length; i++) {
          int next_i = (i + 1) % allObject2Ds_Faces[f].length;
  
          float[] vect1 = {allObject2Ds_Vertices[allObject2Ds_Faces[f][i]][0] - X_intersect, allObject2Ds_Vertices[allObject2Ds_Faces[f][i]][1] - Y_intersect, allObject2Ds_Vertices[allObject2Ds_Faces[f][i]][2] - Z_intersect};
          float[] vect2 = {allObject2Ds_Vertices[allObject2Ds_Faces[f][next_i]][0] - X_intersect, allObject2Ds_Vertices[allObject2Ds_Faces[f][next_i]][1] - Y_intersect, allObject2Ds_Vertices[allObject2Ds_Faces[f][next_i]][2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allObject2Ds_Faces.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}



float[] SOLARCHVISION_1Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allFractals_Faces.length][4];

  for (int f = 1; f < allFractals_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allFractals_Faces.length; f++) {

    float[] A = allFractals_Vertices[allFractals_Faces[f][0]];
    float[] B = allFractals_Vertices[allFractals_Faces[f][1]];
    float[] C = allFractals_Vertices[allFractals_Faces[f][allFractals_Faces[f].length - 2]];
    float[] D = allFractals_Vertices[allFractals_Faces[f][allFractals_Faces[f].length - 1]];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
      
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < allFractals_Faces[f].length; i++) {
          int next_i = (i + 1) % allFractals_Faces[f].length;
  
          float[] vect1 = {allFractals_Vertices[allFractals_Faces[f][i]][0] - X_intersect, allFractals_Vertices[allFractals_Faces[f][i]][1] - Y_intersect, allFractals_Vertices[allFractals_Faces[f][i]][2] - Z_intersect};
          float[] vect2 = {allFractals_Vertices[allFractals_Faces[f][next_i]][0] - X_intersect, allFractals_Vertices[allFractals_Faces[f][next_i]][1] - Y_intersect, allFractals_Vertices[allFractals_Faces[f][next_i]][2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allFractals_Faces.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}



float[] SOLARCHVISION_9Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allCameras_Faces.length][4];

  for (int f = 1; f < allCameras_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allCameras_Faces.length; f++) {

    float[] A = allCameras_Vertices[allCameras_Faces[f][0]];
    float[] B = allCameras_Vertices[allCameras_Faces[f][1]];
    float[] C = allCameras_Vertices[allCameras_Faces[f][allCameras_Faces[f].length - 2]];
    float[] D = allCameras_Vertices[allCameras_Faces[f][allCameras_Faces[f].length - 1]];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
      
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < allCameras_Faces[f].length; i++) {
          int next_i = (i + 1) % allCameras_Faces[f].length;
  
          float[] vect1 = {allCameras_Vertices[allCameras_Faces[f][i]][0] - X_intersect, allCameras_Vertices[allCameras_Faces[f][i]][1] - Y_intersect, allCameras_Vertices[allCameras_Faces[f][i]][2] - Z_intersect};
          float[] vect2 = {allCameras_Vertices[allCameras_Faces[f][next_i]][0] - X_intersect, allCameras_Vertices[allCameras_Faces[f][next_i]][1] - Y_intersect, allCameras_Vertices[allCameras_Faces[f][next_i]][2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allCameras_Faces.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}




float[] SOLARCHVISION_8Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allSections_Faces.length][4];

  for (int f = 1; f < allSections_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allSections_Faces.length; f++) {

    float[] A = allSections_Vertices[allSections_Faces[f][0]];
    float[] B = allSections_Vertices[allSections_Faces[f][1]];
    float[] C = allSections_Vertices[allSections_Faces[f][allSections_Faces[f].length - 2]];
    float[] D = allSections_Vertices[allSections_Faces[f][allSections_Faces[f].length - 1]];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
      
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < allSections_Faces[f].length; i++) {
          int next_i = (i + 1) % allSections_Faces[f].length;
  
          float[] vect1 = {allSections_Vertices[allSections_Faces[f][i]][0] - X_intersect, allSections_Vertices[allSections_Faces[f][i]][1] - Y_intersect, allSections_Vertices[allSections_Faces[f][i]][2] - Z_intersect};
          float[] vect2 = {allSections_Vertices[allSections_Faces[f][next_i]][0] - X_intersect, allSections_Vertices[allSections_Faces[f][next_i]][1] - Y_intersect, allSections_Vertices[allSections_Faces[f][next_i]][2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allSections_Faces.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}



float[] SOLARCHVISION_7Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [allSolids_Faces.length][4];

  for (int f = 1; f < allSolids_Faces.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }
  
  for (int f = 1; f < allSolids_Faces.length; f++) {

    float[] A = allSolids_Vertices[allSolids_Faces[f][0]];
    float[] B = allSolids_Vertices[allSolids_Faces[f][1]];
    float[] C = allSolids_Vertices[allSolids_Faces[f][allSolids_Faces[f].length - 2]];
    float[] D = allSolids_Vertices[allSolids_Faces[f][allSolids_Faces[f].length - 1]];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
      
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < allSolids_Faces[f].length; i++) {
          int next_i = (i + 1) % allSolids_Faces[f].length;
  
          float[] vect1 = {allSolids_Vertices[allSolids_Faces[f][i]][0] - X_intersect, allSolids_Vertices[allSolids_Faces[f][i]][1] - Y_intersect, allSolids_Vertices[allSolids_Faces[f][i]][2] - Z_intersect};
          float[] vect2 = {allSolids_Vertices[allSolids_Faces[f][next_i]][0] - X_intersect, allSolids_Vertices[allSolids_Faces[f][next_i]][1] - Y_intersect, allSolids_Vertices[allSolids_Faces[f][next_i]][2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }
  }  

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < allSolids_Faces.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = 1 + int((f - 1) / Solids_DisplayFaces);
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];

    }

  }

  return return_point;
}





float[] SOLARCHVISION_0Dintersect (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = SOLARCHVISION_fn_normalize(ray_dir);   

  float[][] hitPoint = new float [(LAND_n_I - 1) * (LAND_n_J - 1) + 1][4];

  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }

  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {

    int LAND_i = (f - 1) / (LAND_n_J - 1);
    int LAND_j = (f - 1) % (LAND_n_J - 1);
    
    float[] A = LAND_MESH[LAND_i][LAND_j];
    float[] B = LAND_MESH[LAND_i][LAND_j + 1];
    float[] C = LAND_MESH[LAND_i + 1][LAND_j + 1];
    float[] D = LAND_MESH[LAND_i + 1][LAND_j];
    
    float[] AC = SOLARCHVISION_3xSub(A, C);
    float[] BD = SOLARCHVISION_3xSub(B, D);
    
    float[] face_norm = SOLARCHVISION_3xCross(AC, BD);
    
    float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
    float dist2intersect = FLOAT_undefined;
  
    float R = -SOLARCHVISION_3xDot(ray_dir, face_norm);

    if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
      dist2intersect = FLOAT_huge;
    }
    else {
      dist2intersect = (SOLARCHVISION_3xDot(ray_pnt, face_norm) - face_offset) / R;

      //if (dist2intersect > 0) {
      if (dist2intersect > FLOAT_tiny) {
      
        float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
        float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
        float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
  
        float AnglesAll = 0;      
  
        for (int i = 0; i < 4; i++) {
          
          float[] P = {0,0,0};
          float[] Q = {0,0,0};
          

          if (i == 0) {
            P = A;
            Q = B;
          } else if (i == 1) {
            P = B;
            Q = C;
          } else if (i == 2) {
            P = C;
            Q = D;
          } else if (i == 3) {
            P = D;
            Q = A;
          }         
          
          float[] vect1 = {P[0] - X_intersect, P[1] - Y_intersect, P[2] - Z_intersect};
          float[] vect2 = {Q[0] - X_intersect, Q[1] - Y_intersect, Q[2] - Z_intersect};
  
          float t = acos_ang(SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(vect1), SOLARCHVISION_fn_normalize(vect2)));
  
          AnglesAll += t;
        }
        
        if (AnglesAll > 359) { // <<<<<<<<<
        
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
        }
      }
    }    

  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 1; f < (LAND_n_I - 1) * (LAND_n_J - 1) + 1; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}




float[][] getSubFace (float[][] base_Vertices, int Tessellation, int n) {

  float[][] return_vertices = {
  };

  int TotalSubNo = 1;
  if (Tessellation > 0) TotalSubNo = base_Vertices.length * int(roundTo(pow(4, Tessellation - 1), 1));   

  if ((Tessellation <= 0) || (n < 0) || (n >= TotalSubNo)) {
    return_vertices = new float [base_Vertices.length][3];

    for (int j = 0; j < base_Vertices.length; j++) {
      return_vertices[j] = base_Vertices[j];
    }
  } else {
    return_vertices = new float [4][3];

    int div = base_Vertices.length;

    int the_first = n % div;
    int the_next = (the_first + 1) % div;
    int the_previous = (the_first + div - 1) % div;

    float[] A = {
      0, 0, 0
    };
    float[] B = {
      0, 0, 0
    };
    float[] C = {
      0, 0, 0
    };
    float[] D = {
      0, 0, 0
    };

    for (int i = 0; i < 3; i++) {

      A[i] = base_Vertices[the_first][i];
      B[i] = 0.5 * (A[i] + base_Vertices[the_next][i]);
      D[i] = 0.5 * (A[i] + base_Vertices[the_previous][i]);

      for (int j = 0; j < base_Vertices.length; j++) {
        C[i] += base_Vertices[j][i] / (1.0 * base_Vertices.length);
      }
    }

    if (Tessellation == 1) {
      return_vertices[0] = A; 
      return_vertices[1] = B; 
      return_vertices[2] = C; 
      return_vertices[3] = D;
    } else {

      int section = n / div;
      int res = int(roundTo(pow(2, Tessellation - 1), 1));
      int u = section / res;
      int v = section % res;

      float x1 = (1.0 * u) / (1.0 * res);
      float y1 = (1.0 * v) / (1.0 * res);
      float x2 = (1.0 * (u + 1)) / (1.0 * res);
      float y2 = (1.0 * (v + 1)) / (1.0 * res);

      float[] P0 = {
        0, 0, 0
      };
      float[] P1 = {
        0, 0, 0
      };
      float[] P2 = {
        0, 0, 0
      };
      float[] P3 = {
        0, 0, 0
      };

      for (int i = 0; i < 3; i++) {
        P0[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x1, y1); 
        P1[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x2, y1); 
        P2[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x2, y2); 
        P3[i] = SOLARCHVISION_Bilinear(A[i], B[i], C[i], D[i], x1, y2);
      }      

      //return_vertices[0] = P0; 
      //return_vertices[1] = P1; 
      //return_vertices[2] = P2; 
      //return_vertices[3] = P3;

      //to rotate tri-grid cells:

      int d = ((u % 2) + ((v + 1) % 2)) % 2; 
      if (d == 0) {
        return_vertices[0] = P0; 
        return_vertices[1] = P1; 
        return_vertices[2] = P2; 
        return_vertices[3] = P3;
      } else {
        return_vertices[0] = P1; 
        return_vertices[1] = P2; 
        return_vertices[2] = P3; 
        return_vertices[3] = P0;
      }
    }
  }


  return return_vertices;
}






// ---------------------------------------------------------

int LAND_Texture_num = 0;   
float[] LAND_Texture_scale_U = {
  1000
}; // 1km
float[] LAND_Texture_scale_V = {
  1000
}; // 1km
PImage[] LAND_Texture_Map = {
  createImage(2, 2, RGB)
};
String[] LAND_Texture_ImagePath  = {
  ""
};


void SOLARCHVISION_LoadLAND_Texture (String LandDirectory) {

  LAND_Texture_scale_U = new float [1];
  LAND_Texture_scale_V = new float [1];
  LAND_Texture_Map = new PImage [1]; 
  LAND_Texture_ImagePath  = new String [1];  

  LAND_Texture_num = 0;

  LAND_Texture_scale_U[0] = 1000; // 1km
  LAND_Texture_scale_V[0] = 1000; // 1km  
  LAND_Texture_Map[0] = createImage(2, 2, RGB);
  LAND_Texture_ImagePath[0] = "";

  Display_LAND_Texture = 0;

  try {     

    String[] filenames = sort(SOLARCHVISION_getfiles(LandDirectory)); // important to sort

    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        println(filenames[i]);

        int _L = filenames[i].length();
        String _Extention = filenames[i].substring(_L - 4, _L);
        //println(_Extention);
        if (_Extention.toLowerCase().equals(".jpg")) {

          String[] Parts = split(filenames[i], '_');

          if (Parts[0].toUpperCase().equals("ELEV")) {

            if (Parts.length > 1) {

              String dir = LandDirectory + "/" + filenames[i];

              {
                String[] new_item = {
                  dir
                };

                LAND_Texture_ImagePath = (String[]) concat(LAND_Texture_ImagePath, new_item);
              }

              {
                PImage[] new_item = {
                  loadImage(dir)
                };

                LAND_Texture_Map = (PImage[]) concat(LAND_Texture_Map, new_item);
              }

              float h = float(Parts[1]);

              {
                float[] new_item = {
                  h * 1.16363
                };

                LAND_Texture_scale_U = (float[]) concat(LAND_Texture_scale_U, new_item);
              }  

              {
                float[] new_item = {
                  h * 0.66084
                };

                LAND_Texture_scale_V = (float[]) concat(LAND_Texture_scale_V, new_item);
              }

              LAND_Texture_num += 1;


              Display_LAND_Texture = 1;
            }
          }
        }
      }
    }
  }
  catch (Exception e) {
    println("ERROR loading LAND_Texture_Map!");
  }
}



//Cartesian
//int LAND_n_I_base = 15;
//int LAND_n_J_base = 15;
//int LAND_n_I = LAND_n_I_base * 2 + 1;
//int LAND_n_J = LAND_n_J_base * 2 + 1;    

//Polar
int LAND_n_I_base = 0;
int LAND_n_J_base = 0;
int LAND_n_I = 25 + 1; //13 + 1; //29 + 1; //17 + 1; //13 + 1; //16 + 1; // 24 + 1;
int LAND_n_J = 24 + 1;     




double LAND_mid_lat;
double LAND_mid_lon;

float[][][] LAND_MESH;

void SOLARCHVISION_load_LandMesh (String ProjectSite) {

  String LandDirectory = LandFolder + "/" + ProjectSite + "/"  + ProjectSite;

  LAND_mid_lat = LocationLatitude;
  LAND_mid_lon = LocationLongitude;

  LAND_MESH = new float [LAND_n_I][LAND_n_J][3];

  for (int i = 0; i < LAND_n_I; i += 1) {
    for (int j = 0; j < LAND_n_J; j += 1) {
      LAND_MESH[i][j][0] = FLOAT_undefined;
      LAND_MESH[i][j][1] = FLOAT_undefined;
      LAND_MESH[i][j][2] = FLOAT_undefined;
    }
  }

  try { 

    if (LoadButton_LandMesh == 1) {

      for (int i = 0; i < LAND_n_I; i += 1) {

        XML FileALL = loadXML(LandDirectory + "/" + nf(i - LAND_n_I_base, 0) + ".xml");

        XML[] children0 = FileALL.getChildren("result");

        for (int j = 0; j < LAND_n_J; j += 1) {

          String txt_elevation = children0[j].getChild("elevation").getContent();

          XML[] children1 = children0[j].getChildren("location");

          String txt_latitude = children1[0].getChild("lat").getContent();
          String txt_longitude = children1[0].getChild("lng").getContent();

          //println(txt_longitude, txt_latitude, txt_elevation);

          double _lon = Double.parseDouble(txt_longitude); 
          double _lat = Double.parseDouble(txt_latitude); 

          double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * DOUBLE_r_Earth);
          double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * DOUBLE_r_Earth);

          float x = (float) du * cos_ang((float) _lat);
          float y = (float) dv; 
          float z = float(txt_elevation);

          //println(i, j);
          //println(x,y,z);

          LAND_MESH[i][j][0] = x;      
          LAND_MESH[i][j][1] = y;      
          LAND_MESH[i][j][2] = z;
        }
      }

      float h = LAND_MESH[LAND_n_I_base][LAND_n_J_base][2];

      h += HeightAboveGround;

      for (int i = 0; i < LAND_n_I; i += 1) {
        for (int j = 0; j < LAND_n_J; j += 1) {

          LAND_MESH[i][j][2] -= h;
        }
      }
    }
  }

  catch (Exception e) {
    println("ERROR loading LAND_MESH!");
  }


  SOLARCHVISION_LoadLAND_Texture(LandDirectory);
}


void SOLARCHVISION_download_LandMesh () {

  LAND_mid_lat = LocationLatitude;
  LAND_mid_lon = LocationLongitude;

  LAND_MESH = new float [LAND_n_I][LAND_n_J][3];


  for (int i = 0; i < LAND_n_I; i += 1) {

    String the_link = "";

    double stp_lat = 1.0 / 2224.5968; // equals to 50m <<<<<<<< Note: for many locations this one is applied
    //double stp_lat = 40.0 / 2224.5968; // equals to 2km 


    double stp_lon = stp_lat / cos_ang((float) LAND_mid_lat); 

    for (int j = 0; j < LAND_n_J; j += 1) {

      float t = j * 360.0 / (LAND_n_J - 1);

      //float q = 2;
      float q = pow(2, 0.5); // <<<<<<<< Note: for many locations this one is applied
      //float q = 1.25;
      //float q = 1.125;


      float r = 0;
      if (i > 0) r = pow(q, i - 1);

      double _lon = LAND_mid_lon + stp_lon * r * cos_ang(t);
      double _lat = LAND_mid_lat + stp_lat * r * sin_ang(t);

      double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * DOUBLE_r_Earth);
      double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * DOUBLE_r_Earth);

      float x = (float) du * cos_ang((float) LAND_mid_lat);
      float y = (float) dv; 

      //println(dist_lon_lat(_lon, _lat, LAND_mid_lon, LAND_mid_lat));
      //println(dist(x,y,0,0));
      //println("____________");

      //String txt_latitude = String.valueOf(_lat);
      //String txt_longitude = String.valueOf(_lon);

      String txt_latitude = nf((float) _lat, 0, 5);
      String txt_longitude = nf((float) _lon, 0, 5);      

      if (the_link.equals("")) the_link = "https://maps.googleapis.com/maps/api/elevation/xml?locations=";
      else the_link += "%7C"; //"|";

      the_link += txt_latitude + "," + txt_longitude;
    }

    println(nf(i, 0), ":", the_link);
    //link(the_link);

    String LandFile = LandFolder + "/" + nf(LocationLatitude, 0, 5) + "_" + nf(LocationLongitude, 0, 5) + "/" + nf(i, 0) + ".xml";
    saveBytes(LandFile, loadBytes(the_link));


    XML FileALL = loadXML(LandFile);

    XML[] children0 = FileALL.getChildren("result");

    for (int j = 0; j < LAND_n_J; j += 1) {

      String txt_elevation = children0[j].getChild("elevation").getContent();

      XML[] children1 = children0[j].getChildren("location");

      String txt_latitude = children1[0].getChild("lat").getContent();
      String txt_longitude = children1[0].getChild("lng").getContent();

      //println(txt_longitude, txt_latitude, txt_elevation);

      double _lon = Double.parseDouble(txt_longitude); 
      double _lat = Double.parseDouble(txt_latitude); 

      double du = ((_lon - LAND_mid_lon) / 180.0) * (PI * DOUBLE_r_Earth);
      double dv = ((_lat - LAND_mid_lat) / 180.0) * (PI * DOUBLE_r_Earth);

      float x = (float) du * cos_ang((float) _lat);
      float y = (float) dv; 
      float z = float(txt_elevation);

      //println(i, j);
      //println(x,y,z);

      LAND_MESH[i][j][0] = x;      
      LAND_MESH[i][j][1] = y;      
      LAND_MESH[i][j][2] = z;    

      if ((i == 0) && (j == 0)) LocationElevation = z;
    }
  }

  float h = LAND_MESH[LAND_n_I_base][LAND_n_J_base][2];

  h += HeightAboveGround;

  for (int i = 0; i < LAND_n_I; i += 1) {
    for (int j = 0; j < LAND_n_J; j += 1) {

      LAND_MESH[i][j][2] -= h;
    }
  }

  Download_LAND_MESH = 0;
}



void SOLARCHVISION_add_Model_2DsFromFile () {

  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);


  String[] FileALL = loadStrings("C:/SOLARCHVISION_2015/Import/Hamedan_PEOPLE.txt");

  String lineSTR;  

  for (int f = 1; f < FileALL.length; f += 1) { // skip the first line.

    lineSTR = FileALL[f];
    //println(lineSTR);

    String[] parts = split(lineSTR, ',');

    float x = float(parts[0]);
    float y = float(parts[1]);
    float z = float(parts[2]);

    SOLARCHVISION_add_Object2D_single("PEOPLE", 0, x, y, z, 2.5);
  }
}


void SOLARCHVISION_add_Model_CMC () { //CMC


  {
    float dx = 5 * 4.5;
    float dy = 3 * 4.5;
    float dz = 5 * 3.0;
    float x = 0;
    float y = 0;
    float z = dz;    
    float rot = 34;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    //SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1);
  }  







  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  addToLastGroup3D = 0;
}


void SOLARCHVISION_add_Model_Main () {
  
  
}


void SOLARCHVISION_add_Model_OCPM2016 () {
 

  {
    float dx = 10;
    float dy = 20;
    float dz = 60;
    float x = -20;
    float y = 0;
    float z = 0;    
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1);
  }  


  {
    float dx = 10;
    float dy = 20;
    float dz = 60;
    float x = 20;
    float y = 0;
    float z = 0;   
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1);
  }

  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  addToLastGroup3D = 0;
}


void SOLARCHVISION_add_Model_LabQC () {

  int[][] block = {
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
  };

  for (int k = 0; k < 15; k++) {
    for (int j = 0; j < 11; j++) {
      for (int i = 0; i < 11; i++) {    

        if (block[i][j] != 0) {
  
          SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
          float dx = 6;
          float dy = 6;
          float dz = 2;
          float rot = 55;
          float x = 2 * (dx * (i - 5) * cos_ang(rot) - dy * (j - 5) * sin_ang(rot));
          float y = 2 * (dx * (i - 5) * sin_ang(rot) + dy * (j - 5) * cos_ang(rot));
          float z = 2 * (dz * k);    
  
          SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
        }
      }
    }
  }
}


void SOLARCHVISION_add_Model_Home () { //Home



  {
    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

    int lvl = 12; // levels

    {
      float dx = 10;
      float dy = 10;
      float dz = 17.5;
      float x = 0;
      float y = 0;
      float z = dz;    

      SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, 0);
      for (float i = 0; i < 2 * dz; i += 2 * dz / lvl) {
        SOLARCHVISION_add_Mesh2(2, 0, 0, 1, 1, x-dx, y-dy, i, x+dx, y+dy, i); // floors
        SOLARCHVISION_add_Object2Ds_plane(1, 10, x, y, i, dx, dy); // people
      }
    }  

    {
      float dx = 35;
      float dy = 10;
      float dz = 17.5;
      float x = 0;
      float y = 20;
      float z = dz;    

      SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, 0);
      for (float i = 0; i < 2 * dz; i += 2 * dz / lvl) {
        SOLARCHVISION_add_Mesh2(2, 0, 0, 1, 1, x-dx, y-dy, i, x+dx, y+dy, i); // floors
        SOLARCHVISION_add_Object2Ds_plane(1, 10, x, y, i, dx, dy); // people
      }
    }      


    {
      float dx = 25;
      float dy = 10;
      float dz = 17.5;
      float x = -10;
      float y = -20;
      float z = dz;    

      SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, 0);
      for (float i = 0; i < 2 * dz; i += 2 * dz / lvl) {
        SOLARCHVISION_add_Mesh2(2, 0, 0, 1, 1, x-dx, y-dy, i, x+dx, y+dy, i); // floors
        SOLARCHVISION_add_Object2Ds_plane(1, 10, x, y, i, dx, dy); // people
      }
    }
  }  




  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  addToLastGroup3D = 0;
}




void SOLARCHVISION_add_Model_Basic () {

  /*
  {
   float dx = 10;
   float dy = 10;
   float dz = 45;
   float x = 0;
   float y = 10.1;
   float z = 0;
   float rot = 0;
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
   SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1); 
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   for (float i = 0; i < 45; i += 3) {
   SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
   
   SOLARCHVISION_add_Object2Ds_plane(1, 10, x,y,i, dx, dy); // people  
   }   
   }  
   
   {
   float dx = 10;
   float dy = 10;
   float dz = 45;
   float x = -30;
   float y = 10.1;
   float z = 0;
   float rot = 0;
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
   SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1); 
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   for (float i = 0; i < 45; i += 3) {
   SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
   
   SOLARCHVISION_add_Object2Ds_plane(1, 10, x,y,i, dx, dy); // people  
   }   
   }    
   
   {
   float dx = 10;
   float dy = 10;
   float dz = 45;
   float x = 30;
   float y = 10.1;
   float z = 0;
   float rot = 0;
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(8,0,0,1,1, x,y,z, dx, dy, dz, rot); // facades
   SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1); 
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   SOLARCHVISION_add_Box_Core(5,0,0,1,1, x,y,z, dx/3, dy/3, dz, rot); // building core
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   for (float i = 0; i < 45; i += 3) {
   SOLARCHVISION_add_Mesh2(2,0,0,1,1, x-dx,y-dy,i, x+dx,y+dy,i); // floors
   
   SOLARCHVISION_add_Object2Ds_plane(1, 10, x,y,i, dx, dy); // people  
   }    
   }    
   
   
   {
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   float d = 1.0;
   for (float i = 0; i < 45; i += d) {
   SOLARCHVISION_add_H_shade(1,0,0,1,1, 30,0,i, 20,d, 90-4*i,0); // south
   }
   }
   
   {
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   float d = 1.0;
   for (float i = -10; i <= 10; i += d) {
   SOLARCHVISION_add_V_shade(6,0,0,1,1, i-30,0,22.5, 45,d, 4.5*i,0); // south
   }    
   }
   
   
   {
   float d = 1.0;
   for (float i = 0; i < 45; i += d) {
   
   float x = 0;
   float y = 0;
   float z = i;
   
   // X-axis
   defaultPivotType = 1; SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,0); defaultPivotType = 0;
   
   SOLARCHVISION_add_H_shade(1,0,0,1,1, x,y,z, 20,d, 0,0); // south
   }
   
   for (float i = -10; i <= 10; i += d) {
   
   float x = i;
   float y = 0;
   float z = 22.5;
   
   // Z-axis
   defaultPivotType = 3; SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,0); defaultPivotType = 0;
   
   SOLARCHVISION_add_V_shade(3,0,0,1,1, x,y,z, 45,d, 0,0); // south
   }    
   }    
   */

  /* 
   {
   SOLARCHVISION_beginNewGroup3D(0,0,0,1,1,1,0,0,0);
   
   float d = 1.0;
   
   for (float i = 0; i < 45; i += d) {
   
   SOLARCHVISION_add_H_shade(1,0,0,1,1, 0,0,i, 20,d, 90-4*i,0); // south
   //SOLARCHVISION_add_H_shade(2,0,0,1,1, 10,10,i, 20,d, 90-4*i,90); // east
   //SOLARCHVISION_add_H_shade(3,0,0,1,1, -10,10,i, 20,d, 90-4*i,270); // west
   
   }
   
   for (float i = -10; i <= 10; i += d) {
   
   //SOLARCHVISION_add_V_shade(4,0,0,1,1, i,20,22.5, 45,d, 4.5*i,180); // north
   
   SOLARCHVISION_add_V_shade(6,0,0,1,1, i,0,22.5, 45,d, 4.5*i,0); // south
   }    
   }
   */







  //SOLARCHVISION_add_Object2Ds_plane(1, 100, 0,0,0, 50,50); // people
  //SOLARCHVISION_add_Object2Ds_plane(2, 25, 0,40,0, 50,10); // trees back
  //SOLARCHVISION_add_Object2Ds_plane(2, 25, 0,-30,0, 50,20); // trees front
  /*
  SOLARCHVISION_beginNewGroup3D(0,0,0,1,1,1,0,0,0);
   SOLARCHVISION_add_PolygonHyper(0,0,0,1,1, 30,-30,4.5, 9, 9, 6, 0);  // hyper
   
   
   {  
   float dx = 5;
   float dy = 5;
   float dz = 5;
   float x = -30;
   float y = -30;
   float z = 0;
   float rot = 0;
   
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);    
   SOLARCHVISION_add_House_Core(7,0,0,1,1, x,y,z, dx,dy,dz, dz, rot); // house 
   SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1);
   } 
   
   {
   float r = 5;    
   float x = 0;
   float y = -30;
   float z = r;
   SOLARCHVISION_beginNewGroup3D(x,y,z,1,1,1,0,0,rot);
   //SOLARCHVISION_add_CrystalSphere(1,0,0,1,1, x,y,z, r, 2, 0, 0);
   SOLARCHVISION_add_CrystalSphere(1,0,0,1,1, x,y,z, r, 4, 0, 0);
   SOLARCHVISION_add_Solid(x,y,z, 2,2,2, r,r,r, 0,0,0, 1);
   }    
   */

  {
    float dx = 100;
    float dy = 100;
    float dz = 10;
    float x = 0;
    float y = 0;
    float z = -dz;    
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    //SOLARCHVISION_add_Solid(x,y,z, CubePower,CubePower,CubePower, dx,dy,dz, 0,0,rot, 1);
  }  


  int keep_Create_Mesh_as_Solid = CreateInput_MeshOrSolid;
  CreateInput_MeshOrSolid = 1; // 0;

  SOLARCHVISION_add_Object2Ds_polar(1, 100, 0, 0, 0, 0, 100); // people
  SOLARCHVISION_add_Object2Ds_polar(2, 15, 0, 0, 0, 50, 100); // 2D trees
  //SOLARCHVISION_add_Object2Ds_polar(3, 15, 0,0,0, 50,100); // fractal trees

  CreateInput_MeshOrSolid = keep_Create_Mesh_as_Solid;


  {
    float dx = 24;
    float dy = 24;
    float dz = 18;
    float x = 0;
    float y = 0;
    float z = 0;    
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(8, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot); // facades
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1); 


    for (float i = 6; i <= dz; i += 6) {

      SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);

      if (i != dz) {

        SOLARCHVISION_add_Mesh2(6, 0, 0, 1, 1, x-dx, y-dy, i, x-dx/3.0, y+dy/3.0, i); // floors
        SOLARCHVISION_add_Mesh2(6, 0, 0, 1, 1, x-dx, y+dy/3.0, i, x+dx/3.0, y+dy, i); // floors
        SOLARCHVISION_add_Mesh2(6, 0, 0, 1, 1, x+dx/3.0, y-dy/3.0, i, x+dx, y+dy, i); // floors
        SOLARCHVISION_add_Mesh2(6, 0, 0, 1, 1, x-dx/3.0, y-dy, i, x+dx, y-dy/3.0, i); // floors
      }

      SOLARCHVISION_add_Object2Ds_Mesh2(1, 10, x-dx, y-dy, i, x-dx/3.0, y+dy/3.0, i); // people  
      SOLARCHVISION_add_Object2Ds_Mesh2(1, 10, x-dx, y+dy/3.0, i, x+dx/3.0, y+dy, i); // people
      SOLARCHVISION_add_Object2Ds_Mesh2(1, 10, x+dx/3.0, y-dy/3.0, i, x+dx, y+dy, i); // people
      SOLARCHVISION_add_Object2Ds_Mesh2(1, 10, x-dx/3.0, y-dy, i, x+dx, y-dy/3.0, i); // people
    }   

    {
      float x2 = x - 0.5 * dx;
      float y2 = y + 0.5 * dy;
      float z2 = z + dz + 4.5;

      SOLARCHVISION_beginNewGroup3D(x2, y2, z2, 1, 1, 1, 0, 0, rot);
      SOLARCHVISION_add_PolygonHyper(0, 1, 0, 1, 1, x2, y2, z2, 9, 9, 4, 0);  // hyper
    }

    {
      SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);

      for (float i = 0; i < dy; i += 6) {

        SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, x+0.5*dx, -i, z+dz+2, dx, 2, -45, 0); // south
      }
    }
  }  

  {
    SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, 12, -24, 3, 24, 6, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 9, 24, 1, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 10, 24, 1, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 11, 24, 1, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 12, 24, 1, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 15, 24, 1, 0, 0); // south
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -12, -24, 18, 24, 1, 0, 0); // south

    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, 12, 3, 24, 6, 0, 270); // west    
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 9, 24, 1, 0, 270); // west
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 10, 24, 1, 0, 270); // west
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 11, 24, 1, 0, 270); // west
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 12, 24, 1, 0, 270); // west
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 15, 24, 1, 0, 270); // west
    SOLARCHVISION_add_H_shade(1, 0, 0, 1, 1, -24, -12, 18, 24, 1, 0, 270); // west

    for (float i = 0; i < 24; i += 3) {
      SOLARCHVISION_add_V_shade(1, 0, 0, 1, 1, 24, -i, 12, 12, 1, -45, 90); // east
    }

    for (float i = 0; i < 24; i += 3) {
      SOLARCHVISION_add_V_shade(1, 0, 0, 1, 1, -i, 24, 12, 12, 1, 0, 180); // north
    }
  }

  {  
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = 30;
    float y = 30;
    float z = 9;    
    float rot = 30;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(4, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  }   


  {  
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = 30;
    float y = -30;
    float z = 9;    
    float rot = 30;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(4, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  }     

  {  
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = -30;
    float y = -30;
    float z = 9;    
    float rot = 45;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(4, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  }  


  {  
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = 0;
    float y = 0;
    float z = 0;    
    float rot = 30;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(4, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  }    

  {  
    float dx = 12;
    float dy = 9;
    float dz = 6;
    float x = -30;
    float y = 30;
    float z = 9;    
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_Box_Core(4, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  }  


  {  
    float dx = 5;
    float dy = 5;
    float dz = 5;
    float x = 50;
    float y = -50;
    float z = 0;
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_House_Core(6, 0, 0, 1, 1, x, y, z, dx, dy, dz, dz, rot); // house 
    SOLARCHVISION_add_Solid(x, y, z, CubePower, CubePower, CubePower, dx, dy, dz, 0, 0, rot, 1);
  } 

  {
    float r = 5;    
    float x = 0;
    float y = -50;
    float z = r;
    float rot = 0;
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_CrystalSphere(2, 0, 0, 1, 1, x, y, z, r, 3, 0, 0);
    SOLARCHVISION_add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
  }      

  {
    float r = 5;    
    float x = -50;
    float y = -50;
    float z = r;
    float rot = 0;    
    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
    SOLARCHVISION_add_PolygonHyper(0, 1, 0, 1, 1, x, y, z, 2 * r, 2 * r, 6, 0);  // hyper
  }

  SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  addToLastGroup3D = 0;
}


void SOLARCHVISION_add_Model_SCHOOL () {

  int[][] block = {
    {
      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
    , 
    {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    }
  };


  for (int i = 0; i < 11; i++) {
    for (int j = 0; j < 11; j++) {

      if (block[i][j] != 0) {

        SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

        float dx = 2.5;
        float dy = 2.5;
        float dz = 4;
        float rot = 60;
        float x = 2 * (dx * i * cos_ang(rot) - dy * j * sin_ang(rot));
        float y = 2 * (dx * i * sin_ang(rot) + dy * j * cos_ang(rot));
        float z = dz;    

        SOLARCHVISION_add_Box_Core(7, 0, 0, 1, 1, x, y, z, dx, dy, dz, rot);
      }
    }
  }
}


void SOLARCHVISION_build_SolarImpact_Image_array () {

  SolarImpact_Image = new PImage [(1 + STUDY_j_End - STUDY_j_Start)];

  for (int j = STUDY_j_Start - 1; j < STUDY_j_End; j += 1) { // total image at j = -1 

      SolarImpact_Image[j + 1] = createImage(2, 2, RGB); // empty and small
  }  

  rebuild_SolarImpactImage_array = 0;
}

void SOLARCHVISION_build_WindRose_Image_array () {

  WindRose_Image = new PImage [(1 + STUDY_j_End - STUDY_j_Start)];

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 

    WindRose_Image[j + 1] = createImage(2, 2, RGB); // empty and small
  }  

  rebuild_WindRoseImage_array = 0;
}

int IMPACTS_DisplayDay = 0; // 0:total 1:day-1 2:day-2 etc.

PImage[] WindRose_Image;

int Display_WindRoseImage = 0; // 0:talse 1:true

int Rendered_WindRose_RES = 1;
int WindRose_RES = 400;

PImage[] SolarImpact_Image;

int Display_SolarImpactImage = 0; // 0:talse 1:true
int SolarImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float SolarImpact_Rotation = 0; // North is up by default

float SolarImpact_scale_U = float(Defined_Stations[STATION_Number][7]); // i.e. 500 = 500m 
float SolarImpact_scale_V = float(Defined_Stations[STATION_Number][7]); // i.e. 500 = 500m 

float SolarImpact_offset_U = 0;
float SolarImpact_offset_V = 0; 

int SolarImpact_RES1 = 200;
int SolarImpact_RES2 = 200;

float SolarImpact_Elevation;


void SOLARCHVISION_calculate_SolarImpact_CurrentSection () {


  if (rebuild_SolarProjection_array != 0) {
    SOLARCHVISION_build_SolarImpact_Image_array();
  }

  if (SolarImpact_sectionType != 0) {

    cursor(WAIT);

    int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
    int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
    int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2];     


    int RES1 = SolarImpact_RES1;
    int RES2 = SolarImpact_RES2;

    if (STUDY_PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
    if (STUDY_PlotImpacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float Pc = FLOAT_undefined;
    float Pd = FLOAT_undefined;

    float _values_R_dir;
    float _values_R_dif;

    float _values_E_dir;
    float _values_E_dif;

    int now_k = 0;
    int now_i = 0;
    int now_j = 0;

    int PAL_TYPE = 0; 
    int PAL_DIR = 1;
    float PAL_Multiplier = 1; 

    if (Impact_TYPE == Impact_ACTIVE) {
      PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR;  
      PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
    }
    if (Impact_TYPE == Impact_PASSIVE) {  
      PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
      PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
      PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
    }             

    for (int p = 0; p < 1; p += 1) { 
      int l = STUDY_ImpactLayer;

      PImage total_Image_RGBA = createImage(RES1, RES2, RGB);

      float[][][] total_Matrix_ARGB;
      total_Matrix_ARGB = new float [4][RES1][RES2];

      for (int np = 0; np < (RES1 * RES2); np++) {
        int Image_X = np % RES1;
        int Image_Y = np / RES1;

        total_Matrix_ARGB[0][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[1][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[2][Image_X][Image_Y] = 0;
        total_Matrix_ARGB[3][Image_X][Image_Y] = 0;
      }

      for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

        now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

        int DATE_ANGLE_approximate = int((DATE_ANGLE + 15) / 30) * 30;
        if (DATE_ANGLE_approximate == 360) DATE_ANGLE_approximate = 0;

        float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
        float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

        //println(DATE_ANGLE, DATE_ANGLE_approximate);

        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

        //println("j =", j);
        //println(Normals_COL_N);

        for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
          if (nk != -1) {
            int k = int(nk / STUDY_JoinDays);
            int j_ADD = nk % STUDY_JoinDays; 

            float[][][] Matrix_ARGB;

            Matrix_ARGB = new float [4][RES1][RES2];

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              Matrix_ARGB[0][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[1][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[2][Image_X][Image_Y] = FLOAT_undefined;
              Matrix_ARGB[3][Image_X][Image_Y] = FLOAT_undefined;
            }

            PImage Image_RGBA = createImage(RES1, RES2, RGB);




            int _valuesNUM = 0;  

            for (int i = 4; i <= 20; i += 1) { // to make it faster. Also the images are not available out of this period. 
              if (STUDY_isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k;
                  now_i = i;
                  now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }                  
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }            
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                    Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }   

                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int drw_count = 0;
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;  
                      _values_R_dif = 0.001 * Pb; 
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      for (int RAD_TYPE = 0; RAD_TYPE <= 1; RAD_TYPE += 1) { 
                        float RAD_VALUE = 0;
                        float EFF_VALUE = 0;
                        if (RAD_TYPE == 0) {
                          RAD_VALUE = _values_R_dir; 
                          EFF_VALUE = _values_E_dir;
                        } else { 
                          //float MULT_dif = 2.0;
                          float MULT_dif = FLOAT_e; // 2.718

                          RAD_VALUE = _values_R_dif * MULT_dif;
                          EFF_VALUE = _values_E_dif * MULT_dif;
                        }

                        PImage[] Shadings = new PImage[2];
                        for (int SHD = 0; SHD <= 1; SHD += 1) {
                          String[] STR_SHD = {
                            "F", "T"
                          };
                          String File_Name = "";

                          if (Defined_Stations[STATION_Number][0].equals("Hamedan")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Hamedan" + "/";
                          } else if (Defined_Stations[STATION_Number][0].equals("Financial_District")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Financial_District" + "/";
                          } else if (Defined_Stations[STATION_Number][0].equals("Ryerson_University")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Ryerson_University" + "/";
                          } else if (Defined_Stations[STATION_Number][0].equals("Place_Bonaventure")) { 
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + "Place_Bonaventure" + "/";
                          } else if (Defined_Stations[STATION_Number][0].equals("Montreal_Downtown")) { 
                            if (Camera_Variation == 1) File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/MONTREAL_DOWNTOWN" + "/";
                            if (Camera_Variation == 2) File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/EV_BUILDING" + "/";
                          } else {
                            File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";
                          }                          


                          if (RAD_TYPE == 0) {
                            File_Name += nf(DATE_ANGLE_approximate, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
                          } else {
                            File_Name += "DIF_" + STR_SHD[SHD];
                          }

                          if (Defined_Stations[STATION_Number][0].equals("Hamedan")) { 
                            File_Name += "_" + "Hamedan" + "_Camera" + nf(Camera_Variation, 2) + ".PNG";
                          } else if (Defined_Stations[STATION_Number][0].equals("Financial_District")) { 
                            File_Name += "_" + "Financial_District" + "_Camera" + nf(Camera_Variation, 2) + ".PNG";
                          } else if (Defined_Stations[STATION_Number][0].equals("Ryerson_University")) { 
                            File_Name += "_" + "Ryerson_University" + "_Camera" + nf(Camera_Variation, 2) + ".PNG";
                          } else if (Defined_Stations[STATION_Number][0].equals("Place_Bonaventure")) { 
                            File_Name += "_" + "Place_Bonaventure" + "_Camera" + nf(Camera_Variation, 2) + ".PNG";
                          } else if (Defined_Stations[STATION_Number][0].equals("Montreal_Downtown")) { 
                            if (Camera_Variation == 1) File_Name += "_" + "Montreal_Downtown.PNG";
                            if (Camera_Variation == 2) File_Name += "_" + "Montreal_EV_BUILDING_B.PNG";
                          } else {
                            File_Name += "_" + SceneName + "_" + NearLatitude_Stamp() + "_Camera" + nf(Camera_Variation, 2) + ".PNG";
                          }

                          //println(File_Name);
                          Shadings[SHD]  = loadImage(File_Name);
                        }   

                        for (int np = 0; np < (RES1 * RES2); np++) {
                          int Image_X = np % RES1;
                          int Image_Y = np / RES1;

                          if (Matrix_ARGB[0][Image_X][Image_Y] > 0.9 * FLOAT_undefined) {
                            Matrix_ARGB[0][Image_X][Image_Y] = 0;
                            Matrix_ARGB[1][Image_X][Image_Y] = 0;
                            Matrix_ARGB[2][Image_X][Image_Y] = 0;
                            Matrix_ARGB[3][Image_X][Image_Y] = 0;
                          }                             

                          color COL0 = Shadings[0].get(Image_X, Image_Y);
                          color COL1 = Shadings[1].get(Image_X, Image_Y);
                          //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                          float COL_V0 = (COL0 >> 8 & 0xFF) / 255.0; 
                          float COL_V1 = (COL1 >> 8 & 0xFF) / 255.0;

                          float COL_Alpha = (COL1 >> 24 & 0xFF);

                          Matrix_ARGB[0][Image_X][Image_Y] = COL_Alpha;

                          if (Impact_TYPE == Impact_ACTIVE) {  
                            Matrix_ARGB[2][Image_X][Image_Y] += RAD_VALUE * COL_V1;
                          }
                          if (Impact_TYPE == Impact_PASSIVE) {
                            if (EFF_VALUE < 0) {
                              Matrix_ARGB[1][Image_X][Image_Y] -= EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[3][Image_X][Image_Y] -= EFF_VALUE * (COL_V0 - COL_V1);
                            } else {
                              Matrix_ARGB[3][Image_X][Image_Y] += EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[1][Image_X][Image_Y] += EFF_VALUE * (COL_V0 - COL_V1);
                            }
                          }

                          if (np == 0) _valuesNUM += 1;
                        }
                      }
                    }
                  }
                }
              }
            }

            float _valuesMUL = 0;

            if (_valuesNUM != 0) {
              //_valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
              //_valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
              _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);
            }

            Image_RGBA.loadPixels();

            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;

              float Image_A = Matrix_ARGB[0][Image_X][Image_Y] * _valuesMUL;
              float Image_R = Matrix_ARGB[1][Image_X][Image_Y] * _valuesMUL;
              float Image_G = Matrix_ARGB[2][Image_X][Image_Y] * _valuesMUL;
              float Image_B = Matrix_ARGB[3][Image_X][Image_Y] * _valuesMUL;

              total_Matrix_ARGB[0][Image_X][Image_Y] += Image_A;
              total_Matrix_ARGB[1][Image_X][Image_Y] += Image_R;
              total_Matrix_ARGB[2][Image_X][Image_Y] += Image_G;
              total_Matrix_ARGB[3][Image_X][Image_Y] += Image_B; 


              float[] _c = {
                0, 0, 0, 0
              };

              float _u = 0;

              float _valuesSUM = FLOAT_undefined;

              if (Impact_TYPE == Impact_ACTIVE) {
                _valuesSUM = Image_G;

                //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
                //_u = (0.1 * PAL_Multiplier * _valuesSUM);
                _u = (0.2 * PAL_Multiplier * _valuesSUM);
              }

              if (Impact_TYPE == Impact_PASSIVE) {
                float AVERAGE, PERCENTAGE, COMPARISON;

                AVERAGE = (Image_B - Image_R);
                if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

                _valuesSUM = COMPARISON;

                //_u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
                _u = 0.5 + 0.5 * (0.2 * PAL_Multiplier * _valuesSUM);
              }


              //if ((Image_X == RES1 / 2) && (Image_Y == RES2 / 2)) println("Image Processing: <CENTER> _valuesSUM =", _valuesSUM); 
              //if ((Image_X == RES1 - 1) && (Image_Y == RES2 - 1)) println("Image Processing: <CORNER> _valuesSUM =", _valuesSUM); 

              if (PAL_DIR == -1) _u = 1 - _u;
              if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_DIR == 2) _u =  0.5 * _u;

              _c = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

              if (Image_A != 0) Image_RGBA.pixels[np] = color(_c[1], _c[2], _c[3]);
              else Image_RGBA.pixels[np] = color(223, 223, 223);
            }

            Image_RGBA.updatePixels(); 

            //if (Camera_Variation == 0) {
            SolarImpact_Image[j + 1] = Image_RGBA;           
            if (SolarImpact_record_JPG == 1) {
              String myFile = getFilename_SolarImpact() + "_solar_" + nf(Impact_TYPE, 1) + "_" + nf(j + 1, 0) + ".jpg";
              SolarImpact_Image[j + 1].save(myFile);
              if (j == 0) SOLARCHVISION_explore_output(myFile);
              println("File created:" + myFile);
            }
            //}
          }
        }
      }

      //----------------------
      if (Camera_Variation == 0) STUDY_impact_summary = 1; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      //----------------------

      if (STUDY_impact_summary == 1) { 
        int j = -1; // << to put the summary graph before the daily graphs

        total_Image_RGBA.loadPixels();

        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;

          float Image_A = total_Matrix_ARGB[0][Image_X][Image_Y] / (1.0 * (STUDY_j_End - STUDY_j_Start));
          float Image_R = total_Matrix_ARGB[1][Image_X][Image_Y] / (1.0 * (STUDY_j_End - STUDY_j_Start));
          float Image_G = total_Matrix_ARGB[2][Image_X][Image_Y] / (1.0 * (STUDY_j_End - STUDY_j_Start));
          float Image_B = total_Matrix_ARGB[3][Image_X][Image_Y] / (1.0 * (STUDY_j_End - STUDY_j_Start));

          float[] _c = {
            0, 0, 0, 0
          };

          float _u = 0;

          float _valuesSUM = FLOAT_undefined;

          if (Impact_TYPE == Impact_ACTIVE) {
            _valuesSUM = Image_G;

            //_u = 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
            //_u = (0.1 * PAL_Multiplier * _valuesSUM);
            _u = (0.2 * PAL_Multiplier * _valuesSUM);
          }

          if (Impact_TYPE == Impact_PASSIVE) {
            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (Image_B - Image_R);
            if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

            _valuesSUM = COMPARISON;

            //_u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
            _u = 0.5 + 0.5 * (0.2 * PAL_Multiplier * _valuesSUM);
          }

          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;

          _c = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

          if (Image_A != 0) total_Image_RGBA.pixels[np] = color(_c[1], _c[2], _c[3]);
          else total_Image_RGBA.pixels[np] = color(223, 223, 223);
        }

        total_Image_RGBA.updatePixels(); 

        //if (Camera_Variation == 0) {
        SolarImpact_Image[0] = total_Image_RGBA;           
        if (SolarImpact_record_JPG == 1) {
          String myFile = getFilename_SolarImpact() + "_solar_" + nf(Impact_TYPE, 1) + "_" + nf(0, 0) + ".jpg";
          SolarImpact_Image[0].save(myFile);
          //SOLARCHVISION_explore_output(myFile);
          println("File created:" + myFile);
        }
        //}
      }
    }

    cursor(ARROW);
  }
}



void SOLARCHVISION_render_Shadows_selectedSections () {

  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

    int f = selectedSection_numbers[o];

    if (f != 0) {        

      SolarImpact_sectionType = allSections_Type[f];
      SolarImpact_RES1 = allSections_RES1[f];
      SolarImpact_RES2 = allSections_RES2[f];     

      SolarImpact_offset_U = allSections_UVERAB[f][0];
      SolarImpact_offset_V = allSections_UVERAB[f][1];
      SolarImpact_Elevation = 0.1 + allSections_UVERAB[f][2];
      SolarImpact_Rotation = allSections_UVERAB[f][3];
      SolarImpact_scale_U = allSections_UVERAB[f][4];
      SolarImpact_scale_V = allSections_UVERAB[f][5];

      SceneName = "temp_" + Section_Stamp();

      SOLARCHVISION_render_Shadows_CurrentSection();
    }
  }

  Display_SolarImpactImage = 1;
  Display_SolidImpactImage = 0;
  ROLLOUT_Update = 1;
}




void SOLARCHVISION_calculate_SolarImpact_selectedSections () {

  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

    int f = selectedSection_numbers[o];

    if (f != 0) {        

      SolarImpact_sectionType = allSections_Type[f];
      SolarImpact_RES1 = allSections_RES1[f];
      SolarImpact_RES2 = allSections_RES2[f];     

      SolarImpact_offset_U = allSections_UVERAB[f][0];
      SolarImpact_offset_V = allSections_UVERAB[f][1];
      SolarImpact_Elevation = 0.1 + allSections_UVERAB[f][2];
      SolarImpact_Rotation = allSections_UVERAB[f][3];
      SolarImpact_scale_U = allSections_UVERAB[f][4];
      SolarImpact_scale_V = allSections_UVERAB[f][5];

      SceneName = "temp_" + Section_Stamp();

      SOLARCHVISION_calculate_SolarImpact_CurrentSection();
      for (int j = STUDY_j_Start - 1; j < STUDY_j_End; j += 1) {

        allSections_SolarImpact[f][j + 1] = createImage(SolarImpact_RES1, SolarImpact_RES2, RGB);

        allSections_SolarImpact[f][j + 1].copy(SolarImpact_Image[j + 1], 0, 0, SolarImpact_RES1, SolarImpact_RES2, 0, 0, SolarImpact_RES1, SolarImpact_RES2);
      }
    }
  }
}




void SOLARCHVISION_calculate_SolidImpact_selectedSections () {

  println("SOLARCHVISION_calculate_SolidImpact_selectedSections");

  for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

    int f = selectedSection_numbers[o];

    if (f != 0) {        

      SolidImpact_sectionType = allSections_Type[f];
      SolidImpact_RES1 = allSections_RES1[f];
      SolidImpact_RES2 = allSections_RES2[f];     

      SolidImpact_offset_U[SolidImpact_sectionType] = allSections_UVERAB[f][0];
      SolidImpact_offset_V[SolidImpact_sectionType] = allSections_UVERAB[f][1];
      SolidImpact_Elevation[SolidImpact_sectionType] = allSections_UVERAB[f][2];
      SolidImpact_Rotation[SolidImpact_sectionType] = allSections_UVERAB[f][3];
      SolidImpact_scale_U[SolidImpact_sectionType] = allSections_UVERAB[f][4];
      SolidImpact_scale_V[SolidImpact_sectionType] = allSections_UVERAB[f][5];

      {
        if ((SolidImpact_Image.width != SolidImpact_RES1) || (SolidImpact_Image.height != SolidImpact_RES2)) {
          SolidImpact_Image = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);

          allSections_SolidImpact[f] = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);
        }

        SOLARCHVISION_calculate_SolidImpact_CurrentSection();

        allSections_SolidImpact[f].copy(SolidImpact_Image, 0, 0, SolidImpact_RES1, SolidImpact_RES2, 0, 0, SolidImpact_RES1, SolidImpact_RES2);
      }
    }
  }
}






float[] SolidImpact_scale_U = {
  100, 100, 100, 100
}; // i.e. 100m
float[] SolidImpact_scale_V = {
  100, 100, 100, 100
}; // i.e. 100m

float[] SolidImpact_offset_U = {
  0, 0, 0, 0
}; 
float[] SolidImpact_offset_V = {
  0, 0, 0, 0
}; 

int SolidImpact_RES1 = 200; //400;
int SolidImpact_RES2 = 200; //400;

PImage SolidImpact_Image = createImage(SolidImpact_RES1, SolidImpact_RES2, ARGB);



int Display_SolidImpactImage = 1; // 0:false, 1:true
int SolidImpact_sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)

float[] SolidImpact_Elevation = {
  0, 0.1, 0, 0
}; // <<<
float[] SolidImpact_Rotation = {
  0, 0, 0, 0
};

float SolidImpact_positionStep = 1.25;


int SolidImpactType = 0; // INTERNAL! 0:simple 1:complex

float SOLARCHVISION_get_SolidImpact_atXYZ (float x, float y, float z) {

  float v = 0;

  if (SolidImpactType == 0) {
    v = SOLARCHVISION_calculate_SolidImpact_atXYZ_simple(x, y, z);
  } else {
    v = SOLARCHVISION_calculate_SolidImpact_atXYZ_complex(x, y, z);
  }

  return v;
}



float SOLARCHVISION_calculate_SolidImpact_atXYZ_simple (float x, float y, float z) {

  float val = 1;

  for (int n = 1; n < allSolids_DEF.length; n++) {

    float r = Solid_get_value(n);
    float d = Solid_get_Distance(n, x, y, z);

    //d *= pow(d, SolidImpact_Power);
    d *= pow(d, SolidImpact_Power / float(allSolids_DEF.length - 1));    

    if (val < 0) val *= abs(d - r);
    else {
      val *= d - r;
    }
  }

  if (allSolids_DEF.length - 1 > 0) {
    float val_sign = 1;
    if (val < 0) {
      val_sign = -1;
      val = abs(val);
    } 
    val = pow(val, 1.0 / float(allSolids_DEF.length - 1));
    val *= val_sign;
  } 

  return val;
}



float SOLARCHVISION_calculate_SolidImpact_atXYZ_complex (float x, float y, float z) {

  float deltaX = SolidImpact_WindSpeed * cos_ang(SolidImpact_WindDirection);
  float deltaY = SolidImpact_WindSpeed * sin_ang(SolidImpact_WindDirection);

  float[] val = {
    1, 1
  };

  for (int o = 0; o < 2; o++) {

    for (int n = 1; n < allSolids_DEF.length; n++) {

      float r = Solid_get_value(n);
      float d = Solid_get_Distance(n, x + o * deltaX, y + o * deltaY, z);

      //d *= pow(d, SolidImpact_Power);
      d *= pow(d, SolidImpact_Power / float(allSolids_DEF.length - 1));

      if (val[o] < 0) val[o] *= abs(d - r);
      else {
        val[o] *= d - r;
      }
    }

    if (allSolids_DEF.length - 1 > 0) {
      float val_sign = 1;
      if (val[o] < 0) {
        val_sign = -1;
        val[o] = abs(val[o]);
      } 
      val[o] = pow(val[o], 1.0 / float(allSolids_DEF.length - 1));
      val[o] *= val_sign;
    }
  }

  return val[1] - val[0];
}




float[][] WindFlow_Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping values at the 4th member
int[][] WindFlow_Lines = {
  {
    0, 0
  }
};

void SOLARCHVISION_calculate_WindFlow () {

  cursor(WAIT);  

  WindFlow_Vertices = new float [1][4];
  WindFlow_Vertices[0][0] = 0; 
  WindFlow_Vertices[0][1] = 0; 
  WindFlow_Vertices[0][2] = 0; 
  WindFlow_Vertices[0][3] = 0;   


  WindFlow_Lines = new int [1][2];
  WindFlow_Lines[0][0] = 0;
  WindFlow_Lines[0][1] = 0;  





  float deltaX = -SolidImpact_WindSpeed * cos_ang(SolidImpact_WindDirection);
  float deltaY = -SolidImpact_WindSpeed * sin_ang(SolidImpact_WindDirection);
  float deltaZ = 0;   

  /* 
   
   float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
   float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
   float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
   float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
   float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
   float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];
   
   int Section_Type = SolidImpact_sectionType;
   int Section_RES1 = SolidImpact_RES1;
   int Section_RES2 = SolidImpact_RES2; 
   
   float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2); 
   
   float[] SectionCorner_A = ImageVertex[1];
   float[] SectionCorner_B = ImageVertex[2];
   float[] SectionCorner_C = ImageVertex[3];
   float[] SectionCorner_D = ImageVertex[4]; 
   
   for (int i = 0; i < SolidImpact_RES1; i += 10) {
   for (int j = 0; j < SolidImpact_RES2; j += 10) {
   
   float x = SOLARCHVISION_Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   float y = SOLARCHVISION_Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   float z = SOLARCHVISION_Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
   
   */


  for (float z = 2.5; z <= 30; z += 2.5) {
    for (float y = -80; y <= 80; y += 2.5) {
      for (float x = -80; x <= 80; x += 2.5) {



        float[] test_point = {
          x, y, z
        };


        int num_steps = 1; //1; //4;

        for (int n = 0; n < num_steps; n += 1) {

          SolidImpactType = 0;
          float inside_or_outside = SOLARCHVISION_get_SolidImpact_atXYZ(test_point[0], test_point[1], test_point[2]);

          if (inside_or_outside > 0) {

            SolidImpactType = 1;
            float val = SOLARCHVISION_get_SolidImpact_atXYZ(test_point[0], test_point[1], test_point[2]);


            float MinimumDistance_trace = 1 / float(num_steps);

            //-----------------------------------------------------------------------------------------------------------------------------------------
            float[][] tracedPoints = SOLARCHVISION_3DtraceContour(MinimumDistance_trace, test_point[0], test_point[1], test_point[2], val);
            //-----------------------------------------------------------------------------------------------------------------------------------------

            float[] point_min = tracedPoints[0];
            //float[] point_equ = tracedPoints[1];
            //float[] point_max = tracedPoints[2];

            float[] v1 = {
              deltaX, deltaY, deltaZ
            };

            float[] v2 = {
              point_min[0] - x, point_min[1] - y, point_min[2] - z
            };

            float acceleration = -SolidImpact_WindSpeed * (point_min[3] - val);

            float dx = v1[0] + v2[0] * acceleration;
            float dy = v1[1] + v2[1] * acceleration;
            float dz = v1[2] + v2[2] * acceleration;

            //float scale = 1.0 / float(num_steps);
            float scale = 0.1 / float(num_steps); // <<<<<<<<<<<<<<<<<<<<

            float x1 = test_point[0] - 0.5 * dx * scale;
            float y1 = test_point[1] - 0.5 * dy * scale;
            float z1 = test_point[2] - 0.5 * dz * scale;

            float x2 = test_point[0] + 0.5 * dx * scale;
            float y2 = test_point[1] + 0.5 * dy * scale;
            float z2 = test_point[2] + 0.5 * dz * scale;


            float AB = (dist(x1, y1, z1, x2, y2, z2) / scale - SolidImpact_WindSpeed) / SolidImpact_WindSpeed; 

            int point_prev = 0;
            int point_next = 0;

            {
              float[][] newVertex = {
                {
                  x1, y1, z1, AB
                }
              };
              WindFlow_Vertices = (float[][]) concat(WindFlow_Vertices, newVertex);

              point_prev = WindFlow_Vertices.length - 1;
            }      


            {
              float[][] newVertex = {
                {
                  x2, y2, z2, AB
                }
              };
              WindFlow_Vertices = (float[][]) concat(WindFlow_Vertices, newVertex);

              point_next = WindFlow_Vertices.length - 1;
            }      

            if ((point_prev != 0) && (point_next != 0)) {
              int[][] newU1Line = {
                {
                  point_prev, point_next
                }
              };
              WindFlow_Lines = (int[][]) concat(WindFlow_Lines, newU1Line);

              point_prev = point_next;
            }      


            test_point[0] = x2;       
            test_point[1] = y2;
            test_point[2] = z2;
          }
        }
      }
    }
  }  

  cursor(ARROW);  

  Display_WindFlow = 1;                
  ROLLOUT_Update = 1;
}










float SOLARCHVISION_fn_2Ddot (float x1, float y1, float x2, float y2) {
  return x1 * x2 + y1 * y2;
}

float[] SOLARCHVISION_2DtraceContour (int traceType, float epsilon, float x, float y, float z, float dx, float dy, float dz, float v) {

  float t_max = FLOAT_undefined;
  float t_min = FLOAT_undefined;
  float t_equ = 0; //FLOAT_undefined;  

  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;

  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = x + dx; //FLOAT_undefined;

  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = y + dy; //FLOAT_undefined;

  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = z + dz; //FLOAT_undefined;

  float min_dist = FLOAT_undefined;  

  float r = epsilon;

  float t = atan2_ang(dy, dx);

  //for (int test_t = -180; test_t < 180; test_t += 5) { 
  for (int test_t = -150; test_t <= 150; test_t += 5) { // <<<<

    float a = r * cos_ang(t + test_t);
    float b = r * sin_ang(t + test_t);
    float c = 0;

    if (SolidImpact_sectionType == 1) {
      float Qx = a * cos_ang(-SolidImpact_Rotation[SolidImpact_sectionType]) - b * sin_ang(-SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(-SolidImpact_Rotation[SolidImpact_sectionType]) + b * cos_ang(-SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = c;

      a = Qx; 
      b = Qy; 
      c = Qz;
    } else if (SolidImpact_sectionType == 2) {
      float Qx = a * cos_ang(SolidImpact_Rotation[SolidImpact_sectionType]) - c * sin_ang(SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(SolidImpact_Rotation[SolidImpact_sectionType]) + c * cos_ang(SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = -b; 

      a = Qx; 
      b = Qy; 
      c = Qz;
    } else if (SolidImpact_sectionType == 3) {
      float Qx = a * cos_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]) - c * sin_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]);
      float Qy = -(a * sin_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]) + c * cos_ang(90 - SolidImpact_Rotation[SolidImpact_sectionType]));
      float Qz = -b; 

      a = Qx; 
      b = Qy; 
      c = Qz;
    }

    float test_x = x + a;
    float test_y = y + b;
    float test_z = z + c;

    float test_v = SOLARCHVISION_get_SolidImpact_atXYZ(test_x, test_y, test_z);        

    if ((test_v < v_min) || (v_min > 0.9 * FLOAT_undefined)) {
      v_min = test_v;
      t_min = test_t;
      x_min = test_x;
      y_min = test_y;
      z_min = test_z;
    }
    if ((test_v > v_max) || (v_max > 0.9 * FLOAT_undefined)) {
      v_max = test_v;
      t_max = test_t;
      x_max = test_x;
      y_max = test_y;          
      z_max = test_z;
    }

    //if (((abs(test_v - v) < min_dist) && (SOLARCHVISION_fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0)) || (v_equ > 0.9 * FLOAT_undefined))  {
    if ((abs(test_v - v) < min_dist) || (v_equ > 0.9 * FLOAT_undefined)) {
      //if (SOLARCHVISION_fn_dot2D(test_x - x, test_y - y, dx, dy) >= 0) {

      min_dist = abs(test_v - v);

      v_equ = test_v;
      t_equ = test_t;
      x_equ = test_x;
      y_equ = test_y;          
      z_equ = test_z;
      //}
    }
  }     


  float the_X = 0, the_Y = 0, the_Z = 0, the_T = 0;

  if (traceType == 0) {
    the_X = x_equ;
    the_Y = y_equ;
    the_Z = z_equ;
    the_T = t_equ;
  }
  if (traceType == -1) {
    the_X = x_min;
    the_Y = y_min;
    the_Z = z_min;
    the_T = t_min;
  }
  if (traceType == 1) {
    the_X = x_max;
    the_Y = y_max;
    the_Z = z_max;
    the_T = t_max;
  }

  float[] return_array = {
    the_X, the_Y, the_Z, cos_ang(t + the_T), sin_ang(t + the_T), 0
  };

  return return_array;
}


float[][] SOLARCHVISION_3DtraceContour (float epsilon, float x, float y, float z, float v) {

  float tz_max = FLOAT_undefined;
  float tz_min = FLOAT_undefined;
  float tz_equ = FLOAT_undefined;  

  float txy_max = FLOAT_undefined;
  float txy_min = FLOAT_undefined;
  float txy_equ = FLOAT_undefined;  

  float v_max = FLOAT_undefined;
  float v_min = FLOAT_undefined;
  float v_equ = FLOAT_undefined;

  float x_max = FLOAT_undefined;
  float x_min = FLOAT_undefined;
  float x_equ = FLOAT_undefined;

  float y_max = FLOAT_undefined;
  float y_min = FLOAT_undefined;
  float y_equ = FLOAT_undefined;

  float z_max = FLOAT_undefined;
  float z_min = FLOAT_undefined;
  float z_equ = FLOAT_undefined;

  float min_dist = FLOAT_undefined;  

  float r = epsilon;

  for (int test_tz = -90; test_tz <= 90; test_tz += 30) { // in the space 
    //for (int test_tz = 0; test_tz <= 0; test_tz += 30) { // on the surface! 

    float c = r * sin_ang(test_tz);

    for (int test_txy = -180; test_txy < 180; test_txy += 15) { 

      float a = r * cos_ang(test_tz) * cos_ang(test_txy);
      float b = r * cos_ang(test_tz) * sin_ang(test_txy);


      float test_x = x + a;
      float test_y = y + b;
      float test_z = z + c;

      float test_v = SOLARCHVISION_get_SolidImpact_atXYZ(test_x, test_y, test_z);        

      if ((test_v < v_min) || (v_min > 0.9 * FLOAT_undefined)) {
        v_min = test_v;
        tz_min = test_tz;
        txy_min = test_txy;
        x_min = test_x;
        y_min = test_y;
        z_min = test_z;
      }
      if ((test_v > v_max) || (v_max > 0.9 * FLOAT_undefined)) {
        v_max = test_v;
        tz_max = test_tz;
        txy_max = test_txy;
        x_max = test_x;
        y_max = test_y;          
        z_max = test_z;
      }

      if ((abs(test_v - v) < min_dist) || (v_equ > 0.9 * FLOAT_undefined)) {

        min_dist = abs(test_v - v);

        v_equ = test_v;
        tz_equ = test_tz;
        txy_equ = test_txy;
        x_equ = test_x;
        y_equ = test_y;          
        z_equ = test_z;
      }
    }
  }

  float[][] return_array = {
    {
      x_min, y_min, z_min, v_min
    }
    , {
      x_equ, y_equ, z_equ, v_equ
    }
    , {
      x_max, y_max, z_max, v_max
    }
  };

  return return_array;
}





float[][] SolidImpact_Contours_U1Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
float[][] SolidImpact_Contours_V1Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
float[][] SolidImpact_Contours_V2Vertices = {
  {
    0, 0, 0, 0
  }
}; // keeping SolidImpact value at the 4th member
int[][] SolidImpact_Contours_U1Lines = {
  {
    0, 0
  }
};
int[][] SolidImpact_Contours_V1Lines = {
  {
    0, 0
  }
};
int[][] SolidImpact_Contours_V2Lines = {
  {
    0, 0
  }
};

int Process_subDivisions = 1; //1; // 0,1,2,3

float deltaSolidImpactStep = 0.05;
float deltaSolidImpactLines = 0.1 * deltaSolidImpactStep;


void SOLARCHVISION_calculate_SolidImpact_CurrentSection () {

  if (SolidImpact_sectionType != 0) {

    cursor(WAIT);

    SolidImpact_Contours_U1Vertices = new float [1][4];
    SolidImpact_Contours_U1Vertices[0][0] = 0; 
    SolidImpact_Contours_U1Vertices[0][1] = 0; 
    SolidImpact_Contours_U1Vertices[0][2] = 0; 
    SolidImpact_Contours_U1Vertices[0][3] = 0;   

    SolidImpact_Contours_V1Vertices = new float [1][4];
    SolidImpact_Contours_V1Vertices[0][0] = 0; 
    SolidImpact_Contours_V1Vertices[0][1] = 0; 
    SolidImpact_Contours_V1Vertices[0][2] = 0; 
    SolidImpact_Contours_V1Vertices[0][3] = 0;

    SolidImpact_Contours_V2Vertices = new float [1][4];
    SolidImpact_Contours_V2Vertices[0][0] = 0; 
    SolidImpact_Contours_V2Vertices[0][1] = 0; 
    SolidImpact_Contours_V2Vertices[0][2] = 0; 
    SolidImpact_Contours_V2Vertices[0][3] = 0;

    SolidImpact_Contours_U1Lines = new int [1][2];
    SolidImpact_Contours_U1Lines[0][0] = 0;
    SolidImpact_Contours_U1Lines[0][1] = 0;

    SolidImpact_Contours_V1Lines = new int [1][2];
    SolidImpact_Contours_V1Lines[0][0] = 0;
    SolidImpact_Contours_V1Lines[0][1] = 0;

    SolidImpact_Contours_V2Lines = new int [1][2];
    SolidImpact_Contours_V2Lines[0][0] = 0;
    SolidImpact_Contours_V2Lines[0][1] = 0;  


    int PAL_TYPE = SOLID_Pallet_CLR; 
    int PAL_DIR = SOLID_Pallet_DIR;
    float PAL_Multiplier = SOLID_Pallet_MLT;     

    SolidImpact_Image.loadPixels();

    float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
    float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
    float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
    float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
    float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
    float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];

    int Section_Type = SolidImpact_sectionType;
    int Section_RES1 = SolidImpact_RES1;
    int Section_RES2 = SolidImpact_RES2; 

    float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

    float[] SectionCorner_A = ImageVertex[1];
    float[] SectionCorner_B = ImageVertex[2];
    float[] SectionCorner_C = ImageVertex[3];
    float[] SectionCorner_D = ImageVertex[4]; 

    for (int i = 0; i < SolidImpact_RES1; i++) {
      for (int j = 0; j < SolidImpact_RES2; j++) {

        float x = SOLARCHVISION_Bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
        float y = SOLARCHVISION_Bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));
        float z = SOLARCHVISION_Bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(SolidImpact_RES1), 1 - j / float(SolidImpact_RES2));

        SolidImpactType = 0;
        float val = SOLARCHVISION_get_SolidImpact_atXYZ(x, y, z);     

        float g =      roundTo(SolidImpact_Grade * val, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
        float g_line = roundTo(SolidImpact_Grade * val, deltaSolidImpactLines);

        float _u = PAL_Multiplier * val + 0.5;

        if (PAL_DIR == -1) _u = 1 - _u;
        if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_DIR == 2) _u =  0.5 * _u;

        float[] COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);     

        if ((Process_subDivisions == 1) || (Process_subDivisions == 2)) {
          //if ((g == g_line) && (g != 0)) {
          if ((abs(g - g_line) < 0.001) && (g != 0)) {      
            COL[0] = 0;    
            COL[1] = 0;//255;
            COL[2] = 0;//255;
            COL[3] = 0;//255;
          }
        } 

        if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {

          if ((abs(g - g_line) < 0.0001) && (g != 0) && (g_line <= 1)) {
            //if ((g_line > 1 - deltaSolidImpactLines) && (g_line <= 1)) { // not sure!

            float dx = 1;
            float dy = 0;
            float dz = 0;             

            float[] test_point_dir = {
              x, y, z, dx, dy, dz
            };

            SOLARCHVISION_trace_U1Line(test_point_dir, g_line, 100);
          }
        }

        SolidImpact_Image.pixels[i + j * SolidImpact_RES1] = color(COL[1], COL[2], COL[3], COL[0]);
      }
    }

    SolidImpact_Image.updatePixels();

    if (SolidImpact_record_JPG == 1) {
      String myFile = getFilename_SolidImpact() + ".jpg";
      SolidImpact_Image.save(myFile);
      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    }    



    if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {
      /*    
       for (int k = 1; k < SolidImpact_Contours_U1Vertices.length; k++) {  
       
       float x = SolidImpact_Contours_U1Vertices[k][0];
       float y = SolidImpact_Contours_U1Vertices[k][1];
       float z = SolidImpact_Contours_U1Vertices[k][2];
       
       float val = SolidImpact_Contours_U1Vertices[k][3]; //SOLARCHVISION_get_SolidImpact_atXYZ(x, y, z);
       
       float g =      roundTo(SolidImpact_Grade * val, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
       float g_line = roundTo(SolidImpact_Grade * val, deltaSolidImpactLines);
       
       float dx = 1;
       float dy = 0;
       float dz = 0;   
       
       float[] test_point_dir = {x, y, z, dx, dy, dz}; 
       
       // making the first VVertex on the UVertice
       {
       float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade}};
       SolidImpact_Contours_V1Vertices = (float[][]) concat(SolidImpact_Contours_V1Vertices, newVertex);
       }      
       
       // making the first WVertex on the UVertice
       {
       float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade}};
       SolidImpact_Contours_V2Vertices = (float[][]) concat(SolidImpact_Contours_V2Vertices, newVertex);
       }      
       
       
       SOLARCHVISION_trace_V1Line(test_point_dir, g_line, 100);
       }
       */
    }

    if (SolidImpact_record_PDF == 1) {

      String myFile = getFilename_SolidImpact() + ".pdf";

      PGraphics SolidImpact_PDF = createGraphics(SolidImpact_RES1, SolidImpact_RES2, PDF, myFile);

      SolidImpact_PDF.beginDraw();

      SolidImpact_PDF.image(SolidImpact_Image, 0, 0, SolidImpact_RES1, SolidImpact_RES2);

      if ((Process_subDivisions == 2) || (Process_subDivisions == 3)) {
        if (Display_SolidImpact_Lines != 0) {

          for (int U_or_V_or_W = 0; U_or_V_or_W < 3; U_or_V_or_W++) {

            if (U_or_V_or_W == 0) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(255, 0, 0);
              SolidImpact_PDF.fill(255, 0, 0);
            } 
            if (U_or_V_or_W == 1) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(0, 255, 0);
              SolidImpact_PDF.fill(0, 255, 0);
            }
            if (U_or_V_or_W == 2) {
              SolidImpact_PDF.strokeWeight(0.25);
              SolidImpact_PDF.stroke(0, 0, 255);
              SolidImpact_PDF.fill(0, 0, 255);
            }

            int q_num = 0;
            if (U_or_V_or_W == 0) {
              q_num = SolidImpact_Contours_U1Lines.length;
            } 
            if (U_or_V_or_W == 1) {
              q_num = SolidImpact_Contours_V1Lines.length;
            }
            if (U_or_V_or_W == 2) {
              q_num = SolidImpact_Contours_V2Lines.length;
            }

            for (int q = 1; q < q_num; q++) {

              float[] i = {
                0, 0
              };
              float[] j = {
                0, 0
              };

              for (int p = 0; p < 2; p++) {

                int n = 0;
                float x0 = 0, y0 = 0, z0 = 0;

                if (U_or_V_or_W == 0) {
                  n = SolidImpact_Contours_U1Lines[q][p];
                  x0 = SolidImpact_Contours_U1Vertices[n][0];
                  y0 = SolidImpact_Contours_U1Vertices[n][1];
                  z0 = SolidImpact_Contours_U1Vertices[n][2];
                }
                if (U_or_V_or_W == 1) {
                  n = SolidImpact_Contours_V1Lines[q][p];        
                  x0 = SolidImpact_Contours_V1Vertices[n][0];
                  y0 = SolidImpact_Contours_V1Vertices[n][1];
                  z0 = SolidImpact_Contours_V1Vertices[n][2];
                }
                if (U_or_V_or_W == 2) {
                  n = SolidImpact_Contours_V2Lines[q][p];        
                  x0 = SolidImpact_Contours_V2Vertices[n][0];
                  y0 = SolidImpact_Contours_V2Vertices[n][1];
                  z0 = SolidImpact_Contours_V2Vertices[n][2];
                }

                float r = 0;

                if (SolidImpact_sectionType == 1) {
                  r = -SolidImpact_Rotation[SolidImpact_sectionType];
                } else if (SolidImpact_sectionType == 2) {
                  r = SolidImpact_Rotation[SolidImpact_sectionType];
                } else if (SolidImpact_sectionType == 3) {
                  r = -SolidImpact_Rotation[SolidImpact_sectionType];
                }     

                float x = x0 * cos_ang(r) - y0 * sin_ang(r);
                float y = x0 * sin_ang(r) + y0 * cos_ang(r);
                float z = z0;

                float a = 0;
                float b = 0;

                if (SolidImpact_sectionType == 1) {
                  a = x;
                  b = -y;
                } else if (SolidImpact_sectionType == 2) {
                  a = x;
                  b = -z;
                } else if (SolidImpact_sectionType == 3) {
                  a = -y;
                  b = -z;
                }

                i[p] = SolidImpact_RES1 * ((a - SolidImpact_offset_U[SolidImpact_sectionType]) / SolidImpact_scale_U[SolidImpact_sectionType] + 0.5);
                j[p] = SolidImpact_RES2 * ((b + SolidImpact_offset_V[SolidImpact_sectionType]) / SolidImpact_scale_V[SolidImpact_sectionType] + 0.5);
              }   

              SolidImpact_PDF.line(i[0], j[0], i[1], j[1]);
            }
          }
        }

        if (Display_SolidImpact_Points != 0) {
          SolidImpact_PDF.strokeWeight(0.5);
          SolidImpact_PDF.stroke(255, 127, 0);
          SolidImpact_PDF.noFill();  
          SolidImpact_PDF.ellipseMode(CENTER);

          for (int n = 1; n < SolidImpact_Contours_U1Vertices.length; n++) {

            float x0 = SolidImpact_Contours_U1Vertices[n][0];
            float y0 = SolidImpact_Contours_U1Vertices[n][1];
            float z0 = SolidImpact_Contours_U1Vertices[n][2];

            float r = 0;

            if (SolidImpact_sectionType == 1) {
              r = -SolidImpact_Rotation[SolidImpact_sectionType];
            } else if (SolidImpact_sectionType == 2) {
              r = SolidImpact_Rotation[SolidImpact_sectionType];
            } else if (SolidImpact_sectionType == 3) {
              r = -SolidImpact_Rotation[SolidImpact_sectionType];
            }     

            float x = x0 * cos_ang(r) - y0 * sin_ang(r);
            float y = x0 * sin_ang(r) + y0 * cos_ang(r);
            float z = z0;

            float a = 0;
            float b = 0;

            if (SolidImpact_sectionType == 1) {
              a = x;
              b = -y;
            } else if (SolidImpact_sectionType == 2) {
              a = x;
              b = -z;
            } else if (SolidImpact_sectionType == 3) {
              a = -y;
              b = -z;
            }

            float i = SolidImpact_RES1 * ((a - SolidImpact_offset_U[SolidImpact_sectionType]) / SolidImpact_scale_U[SolidImpact_sectionType] + 0.5);
            float j = SolidImpact_RES2 * ((b + SolidImpact_offset_V[SolidImpact_sectionType]) / SolidImpact_scale_V[SolidImpact_sectionType] + 0.5);

            SolidImpact_PDF.ellipse(i, j, 1, 1);
          }

          SolidImpact_PDF.strokeWeight(0);
        }
      }


      SolidImpact_PDF.dispose();

      SolidImpact_PDF.endDraw();

      SOLARCHVISION_explore_output(myFile);
      println("File created:" + myFile);
    }

    cursor(ARROW);
  }
}



void SOLARCHVISION_draw_SolidImpact_lines () {

  if (Display_SolidImpact_Lines != 0) {

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(255, 0, 0);
    WIN3D_Diagrams.fill(255, 0, 0);  

    for (int q = 1; q < SolidImpact_Contours_U1Lines.length; q++) {

      int n1 = SolidImpact_Contours_U1Lines[q][0];
      int n2 = SolidImpact_Contours_U1Lines[q][1];

      float x1 = SolidImpact_Contours_U1Vertices[n1][0];
      float y1 = SolidImpact_Contours_U1Vertices[n1][1];
      float z1 = SolidImpact_Contours_U1Vertices[n1][2];

      float x2 = SolidImpact_Contours_U1Vertices[n2][0];
      float y2 = SolidImpact_Contours_U1Vertices[n2][1];
      float z2 = SolidImpact_Contours_U1Vertices[n2][2];

      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_Scale3D, -y1 * OBJECTS_scale * WIN3D_Scale3D, z1 * OBJECTS_scale * WIN3D_Scale3D, x2 * OBJECTS_scale * WIN3D_Scale3D, -y2 * OBJECTS_scale * WIN3D_Scale3D, z2 * OBJECTS_scale * WIN3D_Scale3D);
    }

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(0, 255, 0);
    WIN3D_Diagrams.fill(0, 255, 0);  

    for (int q = 1; q < SolidImpact_Contours_V1Lines.length; q++) {

      int n1 = SolidImpact_Contours_V1Lines[q][0];
      int n2 = SolidImpact_Contours_V1Lines[q][1];

      float x1 = SolidImpact_Contours_V1Vertices[n1][0];
      float y1 = SolidImpact_Contours_V1Vertices[n1][1];
      float z1 = SolidImpact_Contours_V1Vertices[n1][2];

      float x2 = SolidImpact_Contours_V1Vertices[n2][0];
      float y2 = SolidImpact_Contours_V1Vertices[n2][1];
      float z2 = SolidImpact_Contours_V1Vertices[n2][2];

      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_Scale3D, -y1 * OBJECTS_scale * WIN3D_Scale3D, z1 * OBJECTS_scale * WIN3D_Scale3D, x2 * OBJECTS_scale * WIN3D_Scale3D, -y2 * OBJECTS_scale * WIN3D_Scale3D, z2 * OBJECTS_scale * WIN3D_Scale3D);
    }

    WIN3D_Diagrams.strokeWeight(1);
    WIN3D_Diagrams.stroke(255, 0, 0);
    WIN3D_Diagrams.fill(255, 0, 0);  

    for (int q = 1; q < SolidImpact_Contours_V2Lines.length; q++) {

      int n1 = SolidImpact_Contours_V2Lines[q][0];
      int n2 = SolidImpact_Contours_V2Lines[q][1];

      float x1 = SolidImpact_Contours_V2Vertices[n1][0];
      float y1 = SolidImpact_Contours_V2Vertices[n1][1];
      float z1 = SolidImpact_Contours_V2Vertices[n1][2];

      float x2 = SolidImpact_Contours_V2Vertices[n2][0];
      float y2 = SolidImpact_Contours_V2Vertices[n2][1];
      float z2 = SolidImpact_Contours_V2Vertices[n2][2];

      WIN3D_Diagrams.line(x1 * OBJECTS_scale * WIN3D_Scale3D, -y1 * OBJECTS_scale * WIN3D_Scale3D, z1 * OBJECTS_scale * WIN3D_Scale3D, x2 * OBJECTS_scale * WIN3D_Scale3D, -y2 * OBJECTS_scale * WIN3D_Scale3D, z2 * OBJECTS_scale * WIN3D_Scale3D);
    }

    WIN3D_Diagrams.strokeWeight(0);
  }
}

void SOLARCHVISION_draw_SolidImpact_points () {
  if (Display_SolidImpact_Points != 0) {

    WIN3D_Diagrams.strokeWeight(0);
    WIN3D_Diagrams.stroke(255, 127, 0);
    WIN3D_Diagrams.fill(255, 127, 0);  

    float R = 1; //0.2;

    for (int n = 1; n < SolidImpact_Contours_U1Vertices.length; n++) {

      float x = SolidImpact_Contours_U1Vertices[n][0];
      float y = SolidImpact_Contours_U1Vertices[n][1];
      float z = SolidImpact_Contours_U1Vertices[n][2];

      WIN3D_Diagrams.pushMatrix();
      WIN3D_Diagrams.translate(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
      WIN3D_Diagrams.sphere(R);
      WIN3D_Diagrams.popMatrix();
    }
  }
}

float MinimumDistance_traceU = 1.0;
float MinimumDistance_traceV = 0.25;

void SOLARCHVISION_trace_U1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = 0; 
  int point_next = 0;

  for (int n = 0; n < n_Tries; n++) {

    float[][] preVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };

    if (point_prev == 0) {
      float nearestPointDist = FLOAT_undefined;
      int nearestPointNum = 0;

      for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {
        //if (preVertex[0][3] == SolidImpact_Contours_U1Vertices[q][3]) {
        if (preVertex[0][3] - SolidImpact_Contours_U1Vertices[q][3] < 0.0001) {

          float d = dist(preVertex[0][0], preVertex[0][1], preVertex[0][2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

          if (nearestPointDist > d) {
            nearestPointDist = d;
            nearestPointNum = q;
          }
        }
      }

      if (nearestPointDist < 0.5) {  //i.e. 0.5m 
        point_prev = nearestPointNum;

        test_point_dir[0] = SolidImpact_Contours_U1Vertices[point_prev][0];
        test_point_dir[1] = SolidImpact_Contours_U1Vertices[point_prev][1];
        test_point_dir[2] = SolidImpact_Contours_U1Vertices[point_prev][2];
      }
    } 

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(0, MinimumDistance_traceU, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SolidImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    float[][] newVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };
    point_next = 0; 

    float nearestPointDist = FLOAT_undefined;
    int nearestPointNum = 0;

    int next_point_existed = 0;

    for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {
      //if (newVertex[0][3] == SolidImpact_Contours_U1Vertices[q][3]) {
      if (abs(newVertex[0][3] - SolidImpact_Contours_U1Vertices[q][3]) < 0.0001) {

        float d = dist(newVertex[0][0], newVertex[0][1], newVertex[0][2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

        if ((nearestPointDist > d) && (point_prev != q)) { 
          nearestPointDist = d;
          nearestPointNum = q;
        }
      }
    }

    if (nearestPointDist < MinimumDistance_traceU) {
      point_next = nearestPointNum;

      test_point_dir[0] = SolidImpact_Contours_U1Vertices[point_next][0];
      test_point_dir[1] = SolidImpact_Contours_U1Vertices[point_next][1];
      test_point_dir[2] = SolidImpact_Contours_U1Vertices[point_next][2];

      next_point_existed = 1;
    }


    if (point_next == 0) {

      SolidImpact_Contours_U1Vertices = (float[][]) concat(SolidImpact_Contours_U1Vertices, newVertex);              
      point_next = SolidImpact_Contours_U1Vertices.length - 1;
    } 

    if ((point_prev != 0) && (point_next != 0)) {
      int[][] newU1Line = {
        {
          point_prev, point_next
        }
      };
      SolidImpact_Contours_U1Lines = (int[][]) concat(SolidImpact_Contours_U1Lines, newU1Line);

      point_prev = point_next;
    }

    if (next_point_existed == 1) {
      break; // when reaching an existing line
    }
  }
}

void SOLARCHVISION_trace_V1Line (float[] test_point_dir, float g_line, int n_Tries) {

  int point_prev = SolidImpact_Contours_V1Vertices.length - 1; // the last added point
  int point_next = 0;

  for (int n = 0; n < n_Tries; n++) {

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    test_point_dir = SOLARCHVISION_2DtraceContour(-1, MinimumDistance_traceV, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / SolidImpact_Grade);
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    float[][] newVertex = {
      {
        test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / SolidImpact_Grade
      }
    };

    point_next = 0;

    {
      SolidImpact_Contours_V1Vertices = (float[][]) concat(SolidImpact_Contours_V1Vertices, newVertex);              
      point_next = SolidImpact_Contours_V1Vertices.length - 1;
    }

    if ((point_prev != 0) && (point_next != 0)) {
      int[][] newV1Line = {
        {
          point_prev, point_next
        }
      };
      SolidImpact_Contours_V1Lines = (int[][]) concat(SolidImpact_Contours_V1Lines, newV1Line);

      float val_new = SOLARCHVISION_get_SolidImpact_atXYZ(test_point_dir[0], test_point_dir[1], test_point_dir[2]);
      float g_new =      roundTo(SolidImpact_Grade * val_new, deltaSolidImpactStep) - 0.5 * deltaSolidImpactStep;
      float g_line_new = roundTo(SolidImpact_Grade * val_new, deltaSolidImpactLines);

      if (g_line - g_line_new >= deltaSolidImpactStep) {


        float nearestPointDist = FLOAT_undefined;
        int nearestPointNum = 0;

        for (int q = 1; q < SolidImpact_Contours_U1Vertices.length; q++) {

          //if (abs(g_line_new / SolidImpact_Grade - SolidImpact_Contours_U1Vertices[q][3]) < 0.0001) {
          if (g_line - g_line_new < 2 * deltaSolidImpactStep) {

            float d = dist(test_point_dir[0], test_point_dir[1], test_point_dir[2], SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2]);

            if (nearestPointDist > d) { 
              nearestPointDist = d;
              nearestPointNum = q;
            }
          }
        }

        if (nearestPointDist < MinimumDistance_traceU) {

          int q = nearestPointNum;

          float[][] endVertex = {
            {
              SolidImpact_Contours_U1Vertices[q][0], SolidImpact_Contours_U1Vertices[q][1], SolidImpact_Contours_U1Vertices[q][2], SolidImpact_Contours_U1Vertices[q][3]
            }
          };
          SolidImpact_Contours_V2Vertices = (float[][]) concat(SolidImpact_Contours_V2Vertices, endVertex);

          int[][] newV2Line = {
            {
              SolidImpact_Contours_V2Vertices.length - 2, SolidImpact_Contours_V2Vertices.length - 1
            }
          }; // last two WVertices
          SolidImpact_Contours_V2Lines = (int[][]) concat(SolidImpact_Contours_V2Lines, newV2Line);
        }


        break; // when reaching the area outside contour level
      }

      point_prev = point_next;
    }
  }
}





void SOLARCHVISION_add_CrystalSphere (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float r, int Tessellation, int isSky, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  int[] vT = new int [6];
  int[] vB = new int [6];

  vT[0] = SOLARCHVISION_addToTempObjectVertices(0, 0, 1);
  vB[0] = SOLARCHVISION_addToTempObjectVertices(0, 0, -1);

  for (int i = 1; i <= 5; i++) {
    float q = i * 72 + t;

    float R_in = pow(5.0, 0.5) * 2.0 / 5.0;  
    float H_in = pow(5.0, 0.5) * 1.0 / 5.0;

    vT[i] = SOLARCHVISION_addToTempObjectVertices(R_in * cos_ang(q), R_in * sin_ang(q), H_in);
    vB[i] = SOLARCHVISION_addToTempObjectVertices(R_in * cos_ang(q + 36), R_in * sin_ang(q + 36), -H_in);
  } 


  int BuildFaces = 0;

  for (int Loop_Tessellation = 1; Loop_Tessellation <= Tessellation; Loop_Tessellation++) { // added so that the tree generated from the bottom to the top!

    if (Loop_Tessellation == Tessellation) BuildFaces = 1;
    else BuildFaces = 0;

    for (int i = 1; i <= 5; i++) {

      int next_i = (i % 5) + 1;
      int prev_i = ((i + 5 - 2) % 5) + 1;

      {
        SOLARCHVISION_createLozenge(
        TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
        TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
        TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
        TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
        Loop_Tessellation, BuildFaces);
      }

      {
        SOLARCHVISION_createLozenge(
        TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
        TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
        TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
        TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
        Loop_Tessellation, BuildFaces);
      }      

      {
        SOLARCHVISION_createLozenge(
        TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
        TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
        TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
        TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
        Loop_Tessellation, BuildFaces);
      }     

      {
        SOLARCHVISION_createLozenge(

        TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
        TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
        TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
        TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 

        Loop_Tessellation, BuildFaces);
      }

      {
        SOLARCHVISION_createLozenge(
        TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
        TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
        TempObjectVertices[vB[next_i]][0], TempObjectVertices[vB[next_i]][1], TempObjectVertices[vB[next_i]][2], 
        TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 

        Loop_Tessellation, BuildFaces);
      }
    }
  }


  //println("Vertices:", POINTER_TempObjectVertices);
  //println("Faces:", POINTER_TempObjectFaces);

  if (isSky == 0) {
    SOLARCHVISION_addTempObjectToScene(m, tes, lyr, vsb, xtr, cx, cy, cz, r, r, r, t);
  } else if (isSky == 1) {


    skyVertices = new float [1][3]; 
    skyFaces = new int [1][1];

    skyFaces[0][0] = 0;
    skyVertices[0][0] = 0;
    skyVertices[0][1] = 0;
    skyVertices[0][2] = 0;

    for (int i = 1; i < POINTER_TempObjectVertices; i++) {

      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];

      float[][] newVertex = {
        {
          x, y, z
        }
      }; 

      skyVertices = (float[][]) concat(skyVertices, newVertex);
    }

    for (int i = 1; i < POINTER_TempObjectFaces; i++) {

      int[][] newFace = {
        {
          TempObjectFaces[i][0], TempObjectFaces[i][1], TempObjectFaces[i][2], TempObjectFaces[i][3]
        }
      }; 

      skyFaces = (int[][]) concat(skyFaces, newFace);
    }

    POINTER_skyVertices = POINTER_TempObjectVertices;
    POINTER_skyFaces = POINTER_TempObjectFaces;    

    POINTER_TempObjectVertices = 1;
    POINTER_TempObjectFaces = 1;
  } else {
    // Nothing. In this case we should add temp object outside this function. See SuperSphere
  }
}  



void SOLARCHVISION_add_SuperSphere (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float px, float py, float pz, float sx, float sy, float sz, int Tessellation, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr; 

  SOLARCHVISION_add_CrystalSphere(m, tes, lyr, vsb, xtr, cx, cy, cz, 1, Tessellation, -1, 90); // passing with isSky:-1

  float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
  value = 1;
  posX = 0;
  posY = 0; 
  posZ = 0;    
  powX = px;
  powY = py;
  powZ = pz;    
  scaleX = 1;
  scaleY = 1; 
  scaleZ = 1;    

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float x = TempObjectVertices[i][0];
    float y = TempObjectVertices[i][1];
    float z = TempObjectVertices[i][2];

    float the_dist = (pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    if (the_dist != 0) {
      x /= the_dist;
      y /= the_dist;
      z /= the_dist;
    }

    TempObjectVertices[i][0] = x;
    TempObjectVertices[i][1] = y;
    TempObjectVertices[i][2] = z;
  }

  SOLARCHVISION_addTempObjectToScene(m, tes, lyr, vsb, xtr, cx, cy, cz, sx, sy, sz, t);
}  


void SOLARCHVISION_add_SuperCylinder (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float sx, float sy, float sz, int n, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr; 

  int[] vT = new int [n];
  int[] vB = new int [n];

  vT[0] = SOLARCHVISION_addToTempObjectVertices(1, 0, 1);
  vB[0] = SOLARCHVISION_addToTempObjectVertices(1, 0, -1);

  int[] newFaceT = {
    vT[0]
  };
  int[] newFaceB = {
    vB[0]
  };
  for (int i = 1; i < n; i++) {
    float rot = i * 360.0 / float(n);

    vT[i] = SOLARCHVISION_addToTempObjectVertices(cos_ang(rot), sin_ang(rot), 1);
    vB[i] = SOLARCHVISION_addToTempObjectVertices(cos_ang(rot), sin_ang(rot), -1);
    int[] fT = {
      vT[i]
    };
    int[] fB = {
      vB[i]
    };

    newFaceT = concat(newFaceT, fT);
    newFaceB = concat(newFaceB, fB);
  } 

  SOLARCHVISION_addToTempObjectFaces(newFaceT, 0); // 0:check_duplicates
  SOLARCHVISION_addToTempObjectFaces(newFaceB, 0); // 0:check_duplicates  

  for (int i = 0; i < n; i++) {
    int next_i = (i + 1) % n;

    int[] newFace = {
      vT[i], vB[i], vB[next_i], vT[next_i]
    };

    SOLARCHVISION_addToTempObjectFaces(newFace, 0); // 0:check_duplicates
  }  

  float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
  value = 1;
  posX = 0;
  posY = 0; 
  posZ = 0;    
  scaleX = 1;
  scaleY = 1; 
  scaleZ = 1;    

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float x = TempObjectVertices[i][0];
    float y = TempObjectVertices[i][1];
    float z = TempObjectVertices[i][2];

    float the_dist = (pow((pow(abs(x - posX) / scaleX, 2) + pow(abs(y - posY) / scaleY, 2)), 0.5) / value);
    if (the_dist != 0) {
      x /= the_dist;
      y /= the_dist;
    }

    TempObjectVertices[i][0] = x;
    TempObjectVertices[i][1] = y;
    TempObjectVertices[i][2] = z;
  }

  SOLARCHVISION_addTempObjectToScene(m, tes, lyr, vsb, xtr, cx, cy, cz, sx, sy, sz, t);
}


int SOLARCHVISION_addToTempObjectVertices (float x, float y, float z) {

  float[][] newVertex = {
    {
      x, y, z
    }
  }; 

  int vertex_existed = 0;

  float min_dist = FLOAT_undefined;

  for (int i = 1; i < POINTER_TempObjectVertices; i++) {

    float the_dist = SOLARCHVISION_fn_dist(newVertex[0], TempObjectVertices[i]);

    if (the_dist < 0.1) { // avoid creating duplicate vertices - WELD is necessary for Fractal spheres!

      if (min_dist > the_dist) {
        min_dist = the_dist;
        vertex_existed = i;
      }
    }
  }

  if (vertex_existed == 0) { 

    if (POINTER_TempObjectVertices >= TempObjectVertices.length) {
      TempObjectVertices = (float[][]) concat(TempObjectVertices, newVertex);
    } else {
      //TempObjectVertices[POINTER_TempObjectVertices] = new int [3];

      TempObjectVertices[POINTER_TempObjectVertices][0] = x;
      TempObjectVertices[POINTER_TempObjectVertices][1] = y;
      TempObjectVertices[POINTER_TempObjectVertices][2] = z;
    }

    vertex_existed = POINTER_TempObjectVertices;

    POINTER_TempObjectVertices += 1;
  }

  return(vertex_existed);
}

int SOLARCHVISION_addToTempObjectFaces (int[] f, int check_duplicates) {

  int face_existed = 0;

  if (check_duplicates == 1) {

    for (int i = 1; i < POINTER_TempObjectFaces; i++) {
      if (f.length == TempObjectFaces[i].length) {

        for (int k = 0; k < f.length; k++) { // "k" introduces different variations that two faces could match

          for (int dir = -1; dir <= 1; dir += 2) { // "dir" introduces different diretions that two faces could match

            //println("\ndir=", dir);

            float total_distances = 0; 

            for (int j = 0; j < f.length; j++) {

              int q = (j * dir + k + f.length) % f.length;

              //print("q=", q, "; k=" );

              total_distances += SOLARCHVISION_fn_dist(TempObjectVertices[f[q]], TempObjectVertices[TempObjectFaces[i][j]]);
            }

            if (total_distances < 0.0001) { // avoid creating duplicate faces
              //println("A duplicate face detected :", i);

              face_existed = i;
              break;
            }
          }
        }
      }
      if (face_existed != 0) break;
    }
  }

  if (face_existed == 0) { 

    if (POINTER_TempObjectFaces >= TempObjectFaces.length) {
      int[][] newFace = {
        f
      }; 
      TempObjectFaces = (int[][]) concat(TempObjectFaces, newFace);
    } else {
      TempObjectFaces[POINTER_TempObjectFaces] = new int [f.length];

      for (int i = 0; i < f.length; i++) {
        TempObjectFaces[POINTER_TempObjectFaces][i] = f[i];
      }
    }

    face_existed = POINTER_TempObjectFaces;

    POINTER_TempObjectFaces += 1;
  }

  return(face_existed);
}

void SOLARCHVISION_addTempObjectToScene (int m, int tes, int lyr, int vsb, int xtr, float cx, float cy, float cz, float sx, float sy, float sz, float t) {

  defaultMaterial = m;
  defaultTessellation = tes;
  defaultLayer = lyr;
  defaultVisibility = vsb;
  defaultExtraType = xtr;

  if (m == -1) defaultMaterial = 0;
  else defaultMaterial = m;

  for (int i = 1; i < POINTER_TempObjectFaces; i++) {

    int[] new_vert_numbers = new int [TempObjectFaces[i].length];

    for (int j = 0; j < TempObjectFaces[i].length; j++) {

      float x0 = TempObjectVertices[TempObjectFaces[i][j]][0] * sx;
      float y0 = TempObjectVertices[TempObjectFaces[i][j]][1] * sy;
      float z0 = TempObjectVertices[TempObjectFaces[i][j]][2] * sz;

      float x = x0 * cos_ang(t) - y0 * sin_ang(t);
      float y = x0 * sin_ang(t) + y0 * cos_ang(t);
      float z = z0;

      new_vert_numbers[j] = SOLARCHVISION_add_Vertex(x + cx, y + cy, z + cz);
    }

    if (m == -1) defaultMaterial = 1 + (defaultMaterial % (Materials_Number - 1));  
    SOLARCHVISION_add_Face(new_vert_numbers);
  }

  TempObjectVertices = new float [1][3];
  TempObjectVertices[0][0] = 0;
  TempObjectVertices[0][1] = 0;
  TempObjectVertices[0][2] = 0;

  TempObjectFaces = new int [1][1];
  TempObjectFaces[0][0] = 0;

  POINTER_TempObjectVertices = 1;
  POINTER_TempObjectFaces = 1;
}

void SOLARCHVISION_createLozenge (float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, int Tessellation, int BuildFaces) {


  if (Tessellation > 0) {

    if (Tessellation == 1) {

      int[] newPoly = new int [4];

      newPoly[0] = SOLARCHVISION_addToTempObjectVertices(x1, y1, z1);    
      newPoly[1] = SOLARCHVISION_addToTempObjectVertices(x2, y2, z2);
      newPoly[2] = SOLARCHVISION_addToTempObjectVertices(x3, y3, z3);
      newPoly[3] = SOLARCHVISION_addToTempObjectVertices(x4, y4, z4);

      if (BuildFaces != 0) {
        SOLARCHVISION_addToTempObjectFaces(newPoly, 1); // 1:check_duplicates
      }

      {
        // because the vertices might be welded to a nearest point:  

        x1 = TempObjectVertices[newPoly[0]][0];
        y1 = TempObjectVertices[newPoly[0]][1];
        z1 = TempObjectVertices[newPoly[0]][2];

        x2 = TempObjectVertices[newPoly[1]][0];
        y2 = TempObjectVertices[newPoly[1]][1];
        z2 = TempObjectVertices[newPoly[1]][2];

        x3 = TempObjectVertices[newPoly[2]][0];
        y3 = TempObjectVertices[newPoly[2]][1];
        z3 = TempObjectVertices[newPoly[2]][2];

        x4 = TempObjectVertices[newPoly[3]][0];
        y4 = TempObjectVertices[newPoly[3]][1];
        z4 = TempObjectVertices[newPoly[3]][2];
      }
    }



    Tessellation -= 1;

    float[] M = {
      (x1 + x2 + x4) / 3.0, (y1 + y2 + y4) / 3.0, (z1 + z2 + z4) / 3.0
    };
    float[] N = {
      (x3 + x2 + x4) / 3.0, (y3 + y2 + y4) / 3.0, (z3 + z2 + z4) / 3.0
    };

    M = SOLARCHVISION_fn_normalize(M);
    N = SOLARCHVISION_fn_normalize(N);

    SOLARCHVISION_createLozenge(x2, y2, z2, N[0], N[1], N[2], x4, y4, z4, M[0], M[1], M[2], Tessellation, BuildFaces);     


    if (BuildFaces != 0) 
    {

      float[] P = M;

      PVector A_vec = new PVector(x1, y1, z1);
      PVector B_vec = new PVector(x2, y2, z2);

      PVector AxB_vec = A_vec.cross(B_vec);
      AxB_vec.normalize();

      float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;

      float[] Q = {
        P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
      };

      Q = SOLARCHVISION_fn_normalize(Q);

      SOLARCHVISION_createLozenge(x2, y2, z2, P[0], P[1], P[2], x1, y1, z1, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
    }


    if (BuildFaces != 0) 
    {

      float[] P = N;

      PVector A_vec = new PVector(x3, y3, z3);
      PVector B_vec = new PVector(x4, y4, z4);

      PVector AxB_vec = A_vec.cross(B_vec);
      AxB_vec.normalize();

      float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;

      float[] Q = {
        P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
      };

      Q = SOLARCHVISION_fn_normalize(Q);

      SOLARCHVISION_createLozenge(x4, y4, z4, P[0], P[1], P[2], x3, y3, z3, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
    }
  }
}

int POINTER_skyVertices = 1;
int POINTER_skyFaces = 1;

float[][] skyVertices = {
  {
    0, 0, 0
  }
};
int[][] skyFaces = {
  {
    0
  }
};


int POINTER_TempObjectVertices = 1;
int POINTER_TempObjectFaces = 1;


float[][] TempObjectVertices = {
  {
    0, 0, 0
  }
};
int[][] TempObjectFaces = {
  {
    0
  }
};






float SOLARCHVISION_SolarAtSurface (float SunR1, float SunR2, float SunR3, float SunR4, float SunR5, float Alpha, float Beta, float THE_ALBEDO) {

  float return_value = FLOAT_undefined;

  if ((SunR1 < 0.9 * FLOAT_undefined) && (SunR2 < 0.9 * FLOAT_undefined) && (SunR3 < 0.9 * FLOAT_undefined) && (SunR4 < 0.9 * FLOAT_undefined) && (SunR5 < 0.9 * FLOAT_undefined)) { 

    float[] VECT = {
      0, 0, 0
    }; 

    if (abs(Alpha) > 89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = 1;
    } else if (Alpha < -89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = -1;
    } else {
      VECT[0] = sin_ang(Beta);
      VECT[1] = -cos_ang(Beta);
      VECT[2] = tan_ang(Alpha);
    }   

    VECT = SOLARCHVISION_fn_normalize(VECT);


    float[] SunV = {
      SunR1, SunR2, SunR3
    };

    float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
    if (SunMask <= 0) SunMask = 0; // removes backing faces 

    float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));

    return_value = (SunR4 * SunMask) + (SunR5 * SkyMask);    


    /*
    float[] REF_SunV = {SunR1, SunR2, -SunR3};
     
     float REF_SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(REF_SunV), SOLARCHVISION_fn_normalize(VECT));
     if (REF_SunMask <= 0) REF_SunMask = 0; // removes backing faces 
     
     float REF_SkyMask = 1 - (0.5 * (1.0 + (Alpha / 90.0)));      
     
     return_value +=  (0.01 * THE_ALBEDO) * ((SunR4 * REF_SunMask) + (SunR5 * REF_SkyMask));
     */
  }

  return (return_value);
}




float SOLARCHVISION_GLOBE_stp_slp;
float SOLARCHVISION_GLOBE_stp_dir;
int SOLARCHVISION_GLOBE_n_slp;  
int SOLARCHVISION_GLOBE_n_dir;

float[][][]LocationExposure;


int rebuild_SolarProjection_array = 1;
int rebuild_SolarImpactImage_array = 1;
int rebuild_WindRoseImage_array = 1; 


void SOLARCHVISION_build_SolarProjection_array () {

  SOLARCHVISION_GLOBE_stp_slp = GLOBE_calculatedResolution;
  SOLARCHVISION_GLOBE_stp_dir = GLOBE_calculatedResolution;
  SOLARCHVISION_GLOBE_n_slp = int(roundTo(180.0 / (1.0 * SOLARCHVISION_GLOBE_stp_slp), 1)) + 1;  
  SOLARCHVISION_GLOBE_n_dir = int(roundTo(360.0 / (1.0 * SOLARCHVISION_GLOBE_stp_dir), 1));

  LocationExposure = new float [(1 + STUDY_j_End - STUDY_j_Start)][SOLARCHVISION_GLOBE_n_slp][SOLARCHVISION_GLOBE_n_dir];

  for (int j = 0; j < LocationExposure.length; j += 1) {

    for (int a = 0; a < SOLARCHVISION_GLOBE_n_slp; a += 1) {
      for (int b = 0; b < SOLARCHVISION_GLOBE_n_dir; b += 1) {  
        LocationExposure[j][a][b] = FLOAT_undefined;
      }
    }
  }

  rebuild_SolarProjection_array = 0;
}


void SOLARCHVISION_SolarProjection () {

  cursor(WAIT);

  if (rebuild_SolarProjection_array != 0) {
    SOLARCHVISION_build_SolarProjection_array();
  }

  float keep_STUDY_PerDays = STUDY_PerDays;
  int keep_STUDY_JoinDays = STUDY_JoinDays;
  if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
    STUDY_PerDays = 1;
    STUDY_JoinDays = 1;
  }

  int start_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[0];
  int end_z = STUDY_get_startZ_endZ(IMPACTS_DataSource)[1]; 
  int layers_count = STUDY_get_startZ_endZ(IMPACTS_DataSource)[2];   



  if (STUDY_PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
  else Impact_TYPE = Impact_PASSIVE;



  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float _values_R_dir;
  float _values_R_dif;
  float _values_E_dir;
  float _values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int l = STUDY_ImpactLayer;

  float[][] TOTAL_valuesSUM_RAD = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_P = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  float[][] TOTAL_valuesSUM_EFF_N = new float [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];
  int[][] TOTAL_valuesNUM = new int [1 + int(180 / SOLARCHVISION_GLOBE_stp_slp)][1 + int(360 / SOLARCHVISION_GLOBE_stp_dir)];

  for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
    for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
      TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
      TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      TOTAL_valuesNUM[a][b] = 0;
    }
  }

  for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) {

    now_j = (j * int(STUDY_PerDays) + TIME_BeginDay + 365) % 365;

    if (now_j >= 365) {
      now_j = now_j % 365;
    }
    if (now_j < 0) {
      now_j = (now_j + 365) % 365;
    }

    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

    float _sunrise = SOLARCHVISION_Sunrise(LocationLatitude, DATE_ANGLE); 
    float _sunset = SOLARCHVISION_Sunset(LocationLatitude, DATE_ANGLE);

    int[] Normals_COL_N;
    Normals_COL_N = new int [9];
    Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(layers_count, start_z, end_z, j, DATE_ANGLE);

    for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk += 1) {
      if (nk != -1) {
        int k = int(nk / STUDY_JoinDays);
        int j_ADD = nk % STUDY_JoinDays; 

        for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
          float Alpha = a * SOLARCHVISION_GLOBE_stp_slp - 90;
          for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
            float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

            float _valuesSUM_RAD = 0;
            float _valuesSUM_EFF_P = 0;
            float _valuesSUM_EFF_N = 0;
            int _valuesNUM = 0; 

            for (int i = 0; i < 24; i += 1) {
              if (STUDY_isInHourlyRange(i) == 1) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k;
                  now_i = i;
                  now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    Pa = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CWEEDS_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    Pa = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_CLMREC_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }                  
                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Pa = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = FORECAST_ENSEMBLE_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }            
                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    Pa = RECENT_OBSERVED_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = RECENT_OBSERVED_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = RECENT_OBSERVED_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }   
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
                    Pa = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_dirnorrad][now_k]; 
                    Pb = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difhorrad][now_k]; 
                    Pc = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_direffect][now_k]; 
                    Pd = CLIMATE_TMYEPW_Data[now_i][now_j][LAYER_difeffect][now_k];
                  }       

                  if ((Pa > 0.9 * FLOAT_undefined) || (Pb > 0.9 * FLOAT_undefined) || (Pc > 0.9 * FLOAT_undefined) || (Pd > 0.9 * FLOAT_undefined)) {
                    _values_R_dir = FLOAT_undefined;
                    _values_R_dif = FLOAT_undefined;
                    _values_E_dir = FLOAT_undefined;
                    _values_E_dif = FLOAT_undefined;
                  } else {

                    int drw_count = 0;
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) drw_count = SOLARCHVISION_filter("CLIMATE_TMYEPW_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) drw_count = SOLARCHVISION_filter("CLIMATE_CWEEDS_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) drw_count = SOLARCHVISION_filter("CLIMATE_CLMREC_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) drw_count = SOLARCHVISION_filter("FORECAST_ENSEMBLE_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);
                    if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) drw_count = SOLARCHVISION_filter("RECENT_OBSERVED_Data", LAYER_cloudcover, FILTER_Active, STUDY_skyScenario_Active, now_i, now_j, now_k);

                    if (drw_count == 1) {
                      _values_R_dir = 0.001 * Pa;
                      _values_R_dif = 0.001 * Pb;
                      _values_E_dir = 0.001 * Pc;
                      _values_E_dif = 0.001 * Pd;

                      if (_valuesSUM_RAD > 0.9 * FLOAT_undefined) {
                        _valuesSUM_RAD = 0;
                        _valuesSUM_EFF_P = 0;
                        _valuesSUM_EFF_N = 0;
                        _valuesNUM = 0;
                      } else {

                        if (_values_E_dir < 0) {
                          _valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                        } else {
                          _valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_E_dir, _values_E_dif, Alpha, Beta, GlobalAlbedo);
                        }

                        _valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], _values_R_dir, _values_R_dif, Alpha, Beta, GlobalAlbedo); 

                        _valuesNUM += 1;
                      }
                    }
                  }
                }
              }
            }


            if (_valuesNUM != 0) {
              //float _valuesMUL = SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE) / (1.0 * _valuesNUM);  
              //float _valuesMUL = int(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE)) / (1.0 * _valuesNUM);
              float _valuesMUL = roundTo(SOLARCHVISION_DayTime(LocationLatitude, DATE_ANGLE), 1) / (1.0 * _valuesNUM);

              _valuesSUM_RAD *= _valuesMUL;
              _valuesSUM_EFF_P *= _valuesMUL;
              _valuesSUM_EFF_N *= _valuesMUL;

              if (TOTAL_valuesNUM[a][b] == 0) {
                TOTAL_valuesSUM_RAD[a][b] = 0;
                TOTAL_valuesSUM_EFF_P[a][b] = 0;
                TOTAL_valuesSUM_EFF_N[a][b] = 0;
              }

              TOTAL_valuesSUM_RAD[a][b] += _valuesSUM_RAD;
              TOTAL_valuesSUM_EFF_P[a][b] += _valuesSUM_EFF_P;
              TOTAL_valuesSUM_EFF_N[a][b] += _valuesSUM_EFF_N;
              TOTAL_valuesNUM[a][b] += 1;
            } else {
              _valuesSUM_RAD = FLOAT_undefined;
              _valuesSUM_EFF_P = FLOAT_undefined;
              _valuesSUM_EFF_N = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N);
            if ((_valuesSUM_EFF_P + _valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (_valuesSUM_EFF_P - _valuesSUM_EFF_N) / (1.0 * (_valuesSUM_EFF_P + _valuesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

            float _valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = _valuesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

            if (_valuesSUM < 0.9 * FLOAT_undefined) {
              LocationExposure[j + 1][a][b] = _valuesSUM;
            }
          }
        }
      }
    }
  }



  for (int a = 0; a <= int (180 / SOLARCHVISION_GLOBE_stp_slp); a += 1) { 
    float Alpha = a * SOLARCHVISION_GLOBE_stp_slp - 90;
    for (int b = 0; b < int (360 / SOLARCHVISION_GLOBE_stp_dir); b += 1) {
      float Beta = b * SOLARCHVISION_GLOBE_stp_dir;

      if (TOTAL_valuesNUM[a][b] != 0) {
        TOTAL_valuesSUM_RAD[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_P[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
        TOTAL_valuesSUM_EFF_N[a][b] /= 1.0 * TOTAL_valuesNUM[a][b];
      } else {
        TOTAL_valuesSUM_RAD[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_P[a][b] = FLOAT_undefined;
        TOTAL_valuesSUM_EFF_N[a][b] = FLOAT_undefined;
      }

      float AVERAGE, PERCENTAGE, COMPARISON;

      AVERAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]);
      if ((TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTAL_valuesSUM_EFF_P[a][b] - TOTAL_valuesSUM_EFF_N[a][b]) / (1.0 * (TOTAL_valuesSUM_EFF_P[a][b] + TOTAL_valuesSUM_EFF_N[a][b])); 
      else PERCENTAGE = 0.0;
      COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);


      float _valuesSUM = FLOAT_undefined;
      if (Impact_TYPE == Impact_ACTIVE) _valuesSUM = TOTAL_valuesSUM_RAD[a][b];
      if (Impact_TYPE == Impact_PASSIVE) _valuesSUM = COMPARISON; 

      if (_valuesSUM < 0.9 * FLOAT_undefined) {
        LocationExposure[0][a][b] = _valuesSUM;
      }
    }
  }


  keep_STUDY_PerDays = STUDY_PerDays;
  STUDY_JoinDays = keep_STUDY_JoinDays;

  cursor(ARROW);
}


void SOLARCHVISION_draw_logo (float cx, float cy, float cz, float cr, int the_view) {

  float stp_u = 1.0 / 12.0;
  float stp_v = 1.0 / 12.0;

  int n_a = 1;

  for (float a = -1; a < 1; a += stp_u) {

    n_a *= -1;

    int n_b = n_a;

    for (float b = -1; b < 1; b += stp_v) {

      n_b *= -1;

      float[][] newQuad = {
        {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
      };

      for (int i = 0; i < 4; i++) {

        float u = a;
        float v = b;

        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        //---------------------------------------
        float x0 = cos(u * PI); 
        float y0 = sin(u * PI) * cos(v * PI);
        float z0 = sin(v * PI);

        float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
        x0 /= d;  
        y0 /= d;  
        z0 /= d;  

        float x = x0;
        float y = y0;
        float z = z0;

        if (the_view == 0) { // corner view: logo
          float t = 0.25 * PI;
          newQuad[i][0] = x0 * cos(t) - z0 * sin(t);
          newQuad[i][1] = y0;   
          newQuad[i][2] = x0 * sin(t) + z0 * cos(t);
        } else if (the_view == 1) { // front view
          newQuad[i][0] = x0;
          newQuad[i][1] = y0;   
          newQuad[i][2] = z0;
        } else if (the_view == -1) { // top view
          newQuad[i][0] = x0;
          newQuad[i][1] = z0;   
          newQuad[i][2] = y0;
        }
      }

      float x1 = cr * newQuad[0][0] + cx;
      float y1 = cr * newQuad[0][1] + cy;
      float z1 = cr * newQuad[0][2] + cz;

      float x2 = cr * newQuad[1][0] + cx;
      float y2 = cr * newQuad[1][1] + cy;
      float z2 = cr * newQuad[1][2] + cz;

      float x3 = cr * newQuad[2][0] + cx;
      float y3 = cr * newQuad[2][1] + cy;
      float z3 = cr * newQuad[2][2] + cz;

      float x4 = cr * newQuad[3][0] + cx;
      float y4 = cr * newQuad[3][1] + cy;
      float z4 = cr * newQuad[3][2] + cz;

      if (n_a * n_b == 1) {
        triangle(x1, y1, x2, y2, x3, y3);
        triangle(x3, y3, x4, y4, x1, y1);
      } else {
        triangle(x4, y4, x1, y1, x2, y2);
        triangle(x2, y2, x3, y3, x4, y4);
      }
    }
  }
}


int SOLARCHVISION_nextUnselected (int go_direction, int start_index) { 

  //go_direction: 1=next -1=previous

  if (go_direction > 0) go_direction = 1;
  else go_direction = -1;


  int length_of_indexes = 0;
  int start_index_OBJ_NUM = 0;

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
    length_of_indexes = LAND_n_I * LAND_n_J + 1;
    start_index_OBJ_NUM = selectedLandPoint_numbers[start_index];
  }  

  if (Current_ObjectCategory == ObjectCategory_Fractals) {
    length_of_indexes = allFractals_num + 1;
    start_index_OBJ_NUM = selectedFractal_numbers[start_index];
  }    

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
    length_of_indexes = allObject2Ds_num + 1;
    start_index_OBJ_NUM = selectedObject2D_numbers[start_index];
  }    

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
    length_of_indexes = allGroup3Ds_num + 1;
    start_index_OBJ_NUM = selectedGroup3D_numbers[start_index];
  }

  if (Current_ObjectCategory == ObjectCategory_Faces) {
    length_of_indexes = allFaces_PNT.length; 
    start_index_OBJ_NUM = selectedFace_numbers[start_index];
  }                

  if (Current_ObjectCategory == ObjectCategory_Vertices) {
    length_of_indexes = allVertices.length; 
    start_index_OBJ_NUM = selectedVertex_numbers[start_index];
  }     

  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
  }  

  if (Current_ObjectCategory == ObjectCategory_Solids) {
    length_of_indexes = allSolids_DEF.length;
    start_index_OBJ_NUM = selectedSolid_numbers[start_index];
  }   

  if (Current_ObjectCategory == ObjectCategory_Sections) {
    length_of_indexes = allSections_num + 1;
    start_index_OBJ_NUM = selectedSection_numbers[start_index];
  }  


  if (Current_ObjectCategory == ObjectCategory_Cameras) {
    length_of_indexes = allCameras_num + 1;
    start_index_OBJ_NUM = selectedCamera_numbers[start_index];
  }



  int return_OBJ_NUM = 0;

  for (int i = 0; i < length_of_indexes; i++) {

    int OBJ_NUM = start_index_OBJ_NUM + i * go_direction;

    if (OBJ_NUM < 0) OBJ_NUM += length_of_indexes;
    if (OBJ_NUM >= length_of_indexes) OBJ_NUM -= length_of_indexes;

    if ((OBJ_NUM != 0) && (OBJ_NUM != start_index_OBJ_NUM)) {

      int found_at = -1;

      if (Current_ObjectCategory == ObjectCategory_LandPoint) {
        for (int o = selectedLandPoint_numbers.length - 1; o >= 0; o--) {
          if (selectedLandPoint_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Fractals) {
        for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
          if (selectedFractal_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
        for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
          if (selectedObject2D_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
        for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

          if (selectedGroup3D_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Faces) {
        for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
          if (selectedFace_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Vertices) {
        for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
          if (selectedVertex_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
      }

      if (Current_ObjectCategory == ObjectCategory_Solids) {
        for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {
          if (selectedSolid_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }    

      if (Current_ObjectCategory == ObjectCategory_Sections) {
        for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
          if (selectedSection_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }

      if (Current_ObjectCategory == ObjectCategory_Cameras) {
        for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {
          if (selectedCamera_numbers[o] == OBJ_NUM) {
            found_at = o;
            break;
          }
        }
      }


      if (found_at == -1) {
        return_OBJ_NUM = OBJ_NUM;
        break;
      }
    }
  }

  //println("start_index", start_index);
  //println("start_index_OBJ_NUM", start_index_OBJ_NUM);
  //println("return_OBJ_NUM", return_OBJ_NUM);

  return return_OBJ_NUM;
}



void SOLARCHVISION_PickSelect (float[] RxP) {

  if (addNewSelectionToPreviousSelection == 0) SOLARCHVISION_deselect_All();


  if (Current_ObjectCategory == ObjectCategory_LandPoint) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedLandPoint_numbers.length - 1; o >= 0; o--) {
        if (selectedLandPoint_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedLandPoint_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedLandPoint_numbers, found_at + 1);

      selectedLandPoint_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedLandPoint_numbers = (int[]) concat(selectedLandPoint_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedLandPoint_numbers_lastItem != selectedLandPoint_numbers[selectedLandPoint_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 6");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }


  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
        if (selectedFractal_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedFractal_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedFractal_numbers, found_at + 1);

      selectedFractal_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedFractal_numbers = (int[]) concat(selectedFractal_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedFractal_numbers_lastItem != selectedFractal_numbers[selectedFractal_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 6");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }


  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
        if (selectedObject2D_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedObject2D_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedObject2D_numbers, found_at + 1);

      selectedObject2D_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedObject2D_numbers = (int[]) concat(selectedObject2D_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedObject2D_numbers_lastItem != selectedObject2D_numbers[selectedObject2D_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 5");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }


  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    int f = int(RxP[0]);

    int OBJ_NUM = 0;

    for (int i = 0; i < allGroup3Ds_num + 1; i++) {
      if ((allGroup3Ds_Faces[i][0] <= f) && (f <= allGroup3Ds_Faces[i][1])) {

        OBJ_NUM = i;

        WIN3D_Update = 1;
        break;
      }
    }

    if (OBJ_NUM != 0) {

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {
          if (selectedGroup3D_numbers[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(selectedGroup3D_numbers, 0, found_at);
        int[] endList = (int[]) subset(selectedGroup3D_numbers, found_at + 1);

        selectedGroup3D_numbers = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] new_OBJ_number = {
          OBJ_NUM
        };

        selectedGroup3D_numbers = (int[]) concat(selectedGroup3D_numbers, new_OBJ_number);
      }
    }


    //if (pre_selectedGroup3D_numbers_lastItem != selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 4");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }

  if (Current_ObjectCategory == ObjectCategory_Faces) {

    int OBJ_NUM = int(RxP[0]);

    if (OBJ_NUM != 0) {

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
          if (selectedFace_numbers[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(selectedFace_numbers, 0, found_at);
        int[] endList = (int[]) subset(selectedFace_numbers, found_at + 1);

        selectedFace_numbers = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] new_OBJ_number = {
          OBJ_NUM
        };

        selectedFace_numbers = (int[]) concat(selectedFace_numbers, new_OBJ_number);
      }
    }


    //if (pre_selectedFace_numbers_lastItem != selectedFace_numbers[selectedFace_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 3");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }



  if (Current_ObjectCategory == ObjectCategory_Vertices) {

    int f = int(RxP[0]);

    int OBJ_NUM = 0;
    float min_dist = FLOAT_undefined;  

    for (int j = 0; j < allFaces_PNT[f].length; j++) {
      int vNo = allFaces_PNT[f][j];

      float x = allVertices[vNo][0];
      float y = allVertices[vNo][1];          
      float z = allVertices[vNo][2];

      float now_dist = dist(x, y, z, RxP[1], RxP[2], RxP[3]);

      if (min_dist > now_dist) {
        min_dist = now_dist;
        OBJ_NUM = vNo;
      }
    }

    if (OBJ_NUM != 0) {

      int found_at = -1;

      int use_it = 0; // 0:nothing 1:add -1:subtract

      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;

      if (addNewSelectionToPreviousSelection != 0) {

        for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
          if (selectedVertex_numbers[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }

      if (use_it == -1) {
        int[] startList = (int[]) subset(selectedVertex_numbers, 0, found_at);
        int[] endList = (int[]) subset(selectedVertex_numbers, found_at + 1);

        selectedVertex_numbers = (int[]) concat(startList, endList);
      }

      if (use_it == 1) {
        int[] new_OBJ_number = {
          OBJ_NUM
        };

        selectedVertex_numbers = (int[]) concat(selectedVertex_numbers, new_OBJ_number);
      }
    }


    //if (pre_selectedVertex_numbers_lastItem != selectedVertex_numbers[selectedVertex_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 2");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }



  if (Current_ObjectCategory == ObjectCategory_Solids) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {
        if (selectedSolid_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedSolid_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedSolid_numbers, found_at + 1);

      selectedSolid_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedSolid_numbers = (int[]) concat(selectedSolid_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedSolid_numbers_lastItem != selectedSolid_numbers[selectedSolid_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 6e");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }



  if (Current_ObjectCategory == ObjectCategory_Sections) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
        if (selectedSection_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedSection_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedSection_numbers, found_at + 1);

      selectedSection_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedSection_numbers = (int[]) concat(selectedSection_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedSection_numbers_lastItem != selectedSection_numbers[selectedSection_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 6b");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }

  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    int OBJ_NUM = int(RxP[0]);

    int found_at = -1;

    int use_it = 0; // 0:nothing 1:add -1:subtract

    if (addNewSelectionToPreviousSelection == 0) use_it = 1;
    if (addNewSelectionToPreviousSelection == 1) use_it = 1;
    if (addNewSelectionToPreviousSelection == -1) use_it = 0;

    if (addNewSelectionToPreviousSelection != 0) {

      for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {
        if (selectedCamera_numbers[o] == OBJ_NUM) {
          found_at = o;
          if (addNewSelectionToPreviousSelection == 1) {
            use_it = 0;
          }
          if (addNewSelectionToPreviousSelection == -1) {
            use_it = -1;
          }
          break;
        }
      }
    }

    if (use_it == -1) {
      int[] startList = (int[]) subset(selectedCamera_numbers, 0, found_at);
      int[] endList = (int[]) subset(selectedCamera_numbers, found_at + 1);

      selectedCamera_numbers = (int[]) concat(startList, endList);
    }

    if (use_it == 1) {
      int[] new_OBJ_number = {
        OBJ_NUM
      };

      selectedCamera_numbers = (int[]) concat(selectedCamera_numbers, new_OBJ_number);
    }

    WIN3D_Update = 1;

    //if (pre_selectedCamera_numbers_lastItem != selectedCamera_numbers[selectedCamera_numbers.length - 1]) {
    println("SOLARCHVISION_calculate_selection_BoundingBox 6c");
    SOLARCHVISION_calculate_selection_BoundingBox();
    //}
  }
}


void SOLARCHVISION_RectSelect (float corner1x, float corner1y, float corner2x, float corner2y) {

  if (addNewSelectionToPreviousSelection == 0) SOLARCHVISION_deselect_All();


  if (Current_ObjectCategory == ObjectCategory_LandPoint) {

    for (int OBJ_NUM = 1; OBJ_NUM < 1 + LAND_n_I * LAND_n_J; OBJ_NUM++) {

      int i = (OBJ_NUM - 1) / LAND_n_J;
      int j = (OBJ_NUM - 1) % LAND_n_J;      

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      for (int k = 0; k < 1; k++) { // just a loop to make those break commands relevant!  

        float x = LAND_MESH[i][j][0] * OBJECTS_scale;
        float y = LAND_MESH[i][j][1] * OBJECTS_scale;
        float z = -LAND_MESH[i][j][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }
      }        



      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedLandPoint_numbers.length - 1; o >= 0; o--) {
            if (selectedLandPoint_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedLandPoint_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedLandPoint_numbers, found_at + 1);

          selectedLandPoint_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedLandPoint_numbers = (int[]) concat(selectedLandPoint_numbers, new_OBJ_number);
        }
      }
    }
  }   



  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    for (int OBJ_NUM = 1; OBJ_NUM < allFractals_Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allFractals_Faces[f].length; j++) {

        int vNo = allFractals_Faces[f][j];

        float x = allFractals_Vertices[vNo][0] * OBJECTS_scale;
        float y = allFractals_Vertices[vNo][1] * OBJECTS_scale;
        float z = -allFractals_Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {
            if (selectedFractal_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedFractal_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedFractal_numbers, found_at + 1);

          selectedFractal_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedFractal_numbers = (int[]) concat(selectedFractal_numbers, new_OBJ_number);
        }
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    for (int OBJ_NUM = 1; OBJ_NUM < allObject2Ds_Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allObject2Ds_Faces[f].length; j++) {

        int vNo = allObject2Ds_Faces[f][j];

        float x = allObject2Ds_Vertices[vNo][0] * OBJECTS_scale;
        float y = allObject2Ds_Vertices[vNo][1] * OBJECTS_scale;
        float z = -allObject2Ds_Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }

        if (break_loops == 1) break;
      }

      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {
            if (selectedObject2D_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedObject2D_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedObject2D_numbers, found_at + 1);

          selectedObject2D_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedObject2D_numbers = (int[]) concat(selectedObject2D_numbers, new_OBJ_number);
        }
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    for (int OBJ_NUM = 1; OBJ_NUM < allGroup3Ds_num + 1; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (allGroup3Ds_Faces[OBJ_NUM][0] <= allGroup3Ds_Faces[OBJ_NUM][1]) {

        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

        for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {
          if ((0 < f) && (f < allFaces_PNT.length)) { 

            for (int j = 0; j < allFaces_PNT[f].length; j++) {
              int vNo = allFaces_PNT[f][j];

              float x = allVertices[vNo][0] * OBJECTS_scale;
              float y = allVertices[vNo][1] * OBJECTS_scale;            
              float z = -allVertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                  if (mouseButton == RIGHT) {
                    include_OBJ_in_newSelection = 1;
                    break_loops = 1;
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }
              } else {
                if (mouseButton == LEFT) {
                  include_OBJ_in_newSelection = 0;
                  break_loops = 1;
                }
              }                        

              if (break_loops == 1) break;
            }

            if (break_loops == 1) break;
          }
        }
      }

      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {
            if (selectedGroup3D_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedGroup3D_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedGroup3D_numbers, found_at + 1);

          selectedGroup3D_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedGroup3D_numbers = (int[]) concat(selectedGroup3D_numbers, new_OBJ_number);
        }
      }
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Faces) {

    for (int OBJ_NUM = 1; OBJ_NUM < allFaces_PNT.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      for (int j = 0; j < allFaces_PNT[OBJ_NUM].length; j++) {
        int vNo = allFaces_PNT[OBJ_NUM][j];

        float x = allVertices[vNo][0] * OBJECTS_scale;
        float y = allVertices[vNo][1] * OBJECTS_scale;            
        float z = -allVertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                        

        if (break_loops == 1) break;
      }



      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {
            if (selectedFace_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedFace_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedFace_numbers, found_at + 1);

          selectedFace_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedFace_numbers = (int[]) concat(selectedFace_numbers, new_OBJ_number);
        }
      }
    }
  }                

  if (Current_ObjectCategory == ObjectCategory_Vertices) {

    for (int OBJ_NUM = 1; OBJ_NUM < allVertices.length; OBJ_NUM++) {

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      float x = allVertices[OBJ_NUM][0] * OBJECTS_scale;
      float y = allVertices[OBJ_NUM][1] * OBJECTS_scale;            
      float z = -allVertices[OBJ_NUM][2] * OBJECTS_scale;

      float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

      if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
          if (mouseButton == RIGHT) {
            include_OBJ_in_newSelection = 1;
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
          }
        }
      } else {
        if (mouseButton == LEFT) {
          include_OBJ_in_newSelection = 0;
        }
      }                        


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {
            if (selectedVertex_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedVertex_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedVertex_numbers, found_at + 1);

          selectedVertex_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedVertex_numbers = (int[]) concat(selectedVertex_numbers, new_OBJ_number);
        }
      }
    }
  }             



  if (Current_ObjectCategory == ObjectCategory_Solids) {

    for (int f = 1; f < allSolids_Faces.length; f++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int OBJ_NUM = 1 + ((f - 1) / Solids_DisplayFaces);

      println(f, OBJ_NUM);

      for (int j = 0; j < allSolids_Faces[f].length; j++) {

        int vNo = allSolids_Faces[f][j];

        float x = allSolids_Vertices[vNo][0] * OBJECTS_scale;
        float y = allSolids_Vertices[vNo][1] * OBJECTS_scale;
        float z = -allSolids_Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {
            if (selectedSolid_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }


        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedSolid_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedSolid_numbers, found_at + 1);

          selectedSolid_numbers = (int[]) concat(startList, endList);
        }



        if (use_it == 1) {
          if (selectedSolid_numbers[selectedSolid_numbers.length - 1] != OBJ_NUM) { // check if added during the previous loop

            int[] new_OBJ_number = {
              OBJ_NUM
            };

            selectedSolid_numbers = (int[]) concat(selectedSolid_numbers, new_OBJ_number);
          }
        }
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    for (int OBJ_NUM = 1; OBJ_NUM < allSections_Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allSections_Faces[f].length; j++) {

        int vNo = allSections_Faces[f][j];

        float x = allSections_Vertices[vNo][0] * OBJECTS_scale;
        float y = allSections_Vertices[vNo][1] * OBJECTS_scale;
        float z = -allSections_Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {
            if (selectedSection_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedSection_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedSection_numbers, found_at + 1);

          selectedSection_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedSection_numbers = (int[]) concat(selectedSection_numbers, new_OBJ_number);
        }
      }
    }
  }  


  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    for (int OBJ_NUM = 1; OBJ_NUM < allCameras_Faces.length; OBJ_NUM++) {

      int break_loops = 0;

      int include_OBJ_in_newSelection = -1;    

      if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
      if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;

      int f = OBJ_NUM;

      for (int j = 0; j < allCameras_Faces[f].length; j++) {

        int vNo = allCameras_Faces[f][j];

        float x = allCameras_Vertices[vNo][0] * OBJECTS_scale;
        float y = allCameras_Vertices[vNo][1] * OBJECTS_scale;
        float z = -allCameras_Vertices[vNo][2] * OBJECTS_scale;

        float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
              break_loops = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }

          if (break_loops == 1) break;
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
            break_loops = 1;
          }
        }                  

        if (break_loops == 1) break;
      }


      if (include_OBJ_in_newSelection == 1) {

        int found_at = -1;

        int use_it = 0; // 0:nothing 1:add -1:subtract

        if (addNewSelectionToPreviousSelection == 0) use_it = 1;
        if (addNewSelectionToPreviousSelection == 1) use_it = 1;
        if (addNewSelectionToPreviousSelection == -1) use_it = 0;

        if (addNewSelectionToPreviousSelection != 0) {

          for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {
            if (selectedCamera_numbers[o] == OBJ_NUM) {
              found_at = o;
              if (addNewSelectionToPreviousSelection == 1) {
                use_it = 0;
              }
              if (addNewSelectionToPreviousSelection == -1) {
                use_it = -1;
              }
              break;
            }
          }
        }

        if (use_it == -1) {
          int[] startList = (int[]) subset(selectedCamera_numbers, 0, found_at);
          int[] endList = (int[]) subset(selectedCamera_numbers, found_at + 1);

          selectedCamera_numbers = (int[]) concat(startList, endList);
        }

        if (use_it == 1) {
          int[] new_OBJ_number = {
            OBJ_NUM
          };

          selectedCamera_numbers = (int[]) concat(selectedCamera_numbers, new_OBJ_number);
        }
      }
    }
  }
}




int mouseWheelConsume = 0;

void mouseWheel (MouseEvent event) {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_UI_BAR_a_selected_parent == -1) {

      mouseWheelConsume += 1;
      if (mouseWheelConsume % 2 == 0) {
        mouseWheelConsume = 0;

        float Wheel_Value = event.getCount(); 

        if (SOLARCHVISION_automated == 0) {
          SOLARCHVISION_X_clicked = mouseX;
          SOLARCHVISION_Y_clicked = mouseY;

          {
            float displayBarHeight = MessageSize;
            float displayBarWidth = 2 * SOLARCHVISION_W_Pixel; 

            STUDY_X_control = 0.5 * displayBarWidth;
            STUDY_Y_control = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + 0.5 * SOLARCHVISION_UI_BAR_d_tab;

            for (int i = 0; i < SOLARCHVISION_UI_BAR_d_Items.length; i++) {

              float x1 = STUDY_X_control - 0.366 * displayBarWidth;
              float x2 = STUDY_X_control + 0.5 * displayBarWidth;
              float y1 = STUDY_Y_control - 0.45 * displayBarHeight;
              float y2 = STUDY_Y_control + 0.45 * displayBarHeight;

              if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Day")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_i_Start = STUDY_i_Start;
                  int keep_STUDY_i_End = STUDY_i_End;

                  if (Wheel_Value > 0) {
                    STUDY_i_Start += 1; 
                    STUDY_i_End += 1;
                  } 
                  if (Wheel_Value < 0) {
                    STUDY_i_Start -= 1; 
                    STUDY_i_End -= 1;
                  } 

                  if (STUDY_i_Start < 0) STUDY_i_Start = 23;
                  if (STUDY_i_Start > 23) STUDY_i_Start = 0;
                  if (STUDY_i_End < 0) STUDY_i_End = 23;
                  if (STUDY_i_End > 23) STUDY_i_End = 0;

                  if ((keep_STUDY_i_Start != STUDY_i_Start) || (keep_STUDY_i_End != STUDY_i_End)) {
                    //Update_DevelopData = 1;

                    ROLLOUT_Update = 1;
                    STUDY_Update = 1;
                    SOLARCHVISION_UI_BAR_d_Update = 1;

                    SOLARCHVISION_check_for_WIN3D_update();
                  }
                }
              }

              if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Year")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_JoinDays = STUDY_JoinDays;

                  if (Wheel_Value > 0) STUDY_JoinDays += 2;
                  if (Wheel_Value < 0) STUDY_JoinDays -= 2;

                  if (STUDY_JoinDays > 365 / STUDY_j_End) STUDY_JoinDays = 365 / STUDY_j_End;
                  if (STUDY_JoinDays < 1) STUDY_JoinDays = 1;

                  if (keep_STUDY_JoinDays != STUDY_JoinDays) {
                    //Update_DevelopData = 1;

                    ROLLOUT_Update = 1;
                    STUDY_Update = 1;
                    SOLARCHVISION_UI_BAR_d_Update = 1;

                    SOLARCHVISION_check_for_WIN3D_update();
                  }
                }
              }

              if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Scenario")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CWEEDS_start) SampleYear_Start = CLIMATE_CWEEDS_start;
                    if (SampleYear_Start > CLIMATE_CWEEDS_end) SampleYear_Start = CLIMATE_CWEEDS_end;
                    if (SampleYear_End < CLIMATE_CWEEDS_start) SampleYear_End = CLIMATE_CWEEDS_start;
                    if (SampleYear_End > CLIMATE_CWEEDS_end) SampleYear_End = CLIMATE_CWEEDS_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      H_Layer_Option = -1; 

                      //Update_DevelopData = 1;

                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      SOLARCHVISION_UI_BAR_d_Update = 1;

                      SOLARCHVISION_check_for_WIN3D_update();
                    }
                  }
                  
                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CLMREC_start) SampleYear_Start = CLIMATE_CLMREC_start;
                    if (SampleYear_Start > CLIMATE_CLMREC_end) SampleYear_Start = CLIMATE_CLMREC_end;
                    if (SampleYear_End < CLIMATE_CLMREC_start) SampleYear_End = CLIMATE_CLMREC_start;
                    if (SampleYear_End > CLIMATE_CLMREC_end) SampleYear_End = CLIMATE_CLMREC_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      H_Layer_Option = -1; 

                      //Update_DevelopData = 1;

                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      SOLARCHVISION_UI_BAR_d_Update = 1;

                      SOLARCHVISION_check_for_WIN3D_update();
                    }
                  }                  

                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    int keep_SampleMember_Start = SampleMember_Start;
                    int keep_SampleMember_End = SampleMember_End;

                    if (Wheel_Value > 0) {
                      SampleMember_Start += 1; 
                      SampleMember_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleMember_Start -= 1; 
                      SampleMember_End -= 1;
                    }

                    if (SampleMember_End < SampleMember_Start) SampleMember_End = SampleMember_Start;
                    if (SampleMember_Start > SampleMember_End) SampleMember_Start = SampleMember_End; 

                    if (SampleMember_Start < FORECAST_ENSEMBLE_start) SampleMember_Start = FORECAST_ENSEMBLE_start;
                    if (SampleMember_Start > FORECAST_ENSEMBLE_end) SampleMember_Start = FORECAST_ENSEMBLE_end;
                    if (SampleMember_End < FORECAST_ENSEMBLE_start) SampleMember_End = FORECAST_ENSEMBLE_start;
                    if (SampleMember_End > FORECAST_ENSEMBLE_end) SampleMember_End = FORECAST_ENSEMBLE_end;

                    if ((keep_SampleMember_Start != SampleMember_Start) || (keep_SampleMember_End != SampleMember_End)) {

                      F_Layer_Option = -1; 

                      //Update_DevelopData = 1;

                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      SOLARCHVISION_UI_BAR_d_Update = 1;

                      SOLARCHVISION_check_for_WIN3D_update();
                    }
                  }   

                  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
                    int keep_SampleStation_Start = SampleStation_Start;
                    int keep_SampleStation_End = SampleStation_End;

                    if (Wheel_Value > 0) {
                      SampleStation_Start += 1; 
                      SampleStation_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleStation_Start -= 1; 
                      SampleStation_End -= 1;
                    }

                    if (SampleStation_End < SampleStation_Start) SampleStation_End = SampleStation_Start;
                    if (SampleStation_Start > SampleStation_End) SampleStation_Start = SampleStation_End; 

                    if (SampleStation_Start < RECENT_OBSERVED_start) SampleStation_Start = RECENT_OBSERVED_start;
                    if (SampleStation_Start > RECENT_OBSERVED_end) SampleStation_Start = RECENT_OBSERVED_end;
                    if (SampleStation_End < RECENT_OBSERVED_start) SampleStation_End = RECENT_OBSERVED_start;
                    if (SampleStation_End > RECENT_OBSERVED_end) SampleStation_End = RECENT_OBSERVED_end;

                    if ((keep_SampleStation_Start != SampleStation_Start) || (keep_SampleStation_End != SampleStation_End)) {

                      O_Layer_Option = -1; 

                      //Update_DevelopData = 1;

                      ROLLOUT_Update = 1;
                      STUDY_Update = 1;
                      SOLARCHVISION_UI_BAR_d_Update = 1;

                      SOLARCHVISION_check_for_WIN3D_update();
                    }
                  }
                }
              }            


              STUDY_Y_control += SOLARCHVISION_UI_BAR_d_tab;
            }
          }


          if (WORLD_Include == 1) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD_CX_View, WORLD_CY_View, WORLD_CX_View + WORLD_X_View, WORLD_CY_View + WORLD_Y_View) == 1) {

              int keep_WORLD_Viewport_ZOOM = WORLD_Viewport_ZOOM;

              if (Wheel_Value < 0) WORLD_Viewport_ZOOM += 1;
              if (Wheel_Value > 0) WORLD_Viewport_ZOOM -= 1;

              if (WORLD_Viewport_ZOOM < 1) WORLD_Viewport_ZOOM = 1;
              if (WORLD_Viewport_ZOOM > 6) WORLD_Viewport_ZOOM = 6;

              if (keep_WORLD_Viewport_ZOOM != WORLD_Viewport_ZOOM) {
                WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);

                WORLD_Update = 1;
              }
            }
          }    

          if (WIN3D_Include == 1) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {

              float[] P = SOLARCHVISION_getPivot();

              float x0 = P[0];
              float y0 = P[1];
              float z0 = P[2];


              if (WIN3D_UI_CurrentTask == 3) { // rotate

                float r = (15 * Wheel_Value) * PI / 180.0;

                int the_Vector = selected_rotVector;

                SOLARCHVISION_rotate_Selection(x0, y0, z0, r, the_Vector);

                WIN3D_Update = 1;
              }   

              if (WIN3D_UI_CurrentTask == 2) { // scale

                float s = pow(pow(2.0, 0.25), Wheel_Value);

                float sx = s;
                float sy = s;
                float sz = s;

                int the_Vector = selected_scaleVector;

                if (the_Vector == 0) {
                  sy = 1; 
                  sz = 1;
                }  
                if (the_Vector == 1) {
                  sz = 1; 
                  sx = 1;
                }  
                if (the_Vector == 2) {
                  sx = 1; 
                  sy = 1;
                }                    

                SOLARCHVISION_scale_Selection(x0, y0, z0, sx, sy, sz);

                WIN3D_Update = 1;
              }       


              if (WIN3D_UI_CurrentTask == 1) { // move

                float d = Wheel_Value;

                float dx = d;
                float dy = d;
                float dz = d;

                int the_Vector = selected_posVector;

                if (the_Vector == 0) {
                  dy = 0; 
                  dz = 0;
                }  
                if (the_Vector == 1) {
                  dz = 0; 
                  dx = 0;
                }  
                if (the_Vector == 2) {
                  dx = 0; 
                  dy = 0;
                }  

                SOLARCHVISION_move_Selection(dx, dy, dz);

                WIN3D_Update = 1;
              }   



              if (WIN3D_UI_TaskModifyParameter == 0) {
                if (WIN3D_UI_CurrentTask >= 4) { // other properties

                  int p = int(Wheel_Value);

                  SOLARCHVISION_changeProperties_Selection(p);

                  WIN3D_Update = 1;
                }
              }


              if (WIN3D_UI_CurrentTask == -1) { // PickSelect 

                int go_direction = int(Wheel_Value);

                if (Current_ObjectCategory == ObjectCategory_LandPoint) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedLandPoint_numbers.length - 1);
                  if (nextIndex != -1) selectedLandPoint_numbers[selectedLandPoint_numbers.length - 1] = nextIndex;
                }

                if (Current_ObjectCategory == ObjectCategory_Fractals) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedFractal_numbers.length - 1);
                  if (nextIndex != -1) selectedFractal_numbers[selectedFractal_numbers.length - 1] = nextIndex;
                }

                if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedObject2D_numbers.length - 1);
                  if (nextIndex != -1) selectedObject2D_numbers[selectedObject2D_numbers.length - 1] = nextIndex;
                }        

                if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedGroup3D_numbers.length - 1);
                  if (nextIndex != -1) selectedGroup3D_numbers[selectedGroup3D_numbers.length - 1] = nextIndex;
                }

                if (Current_ObjectCategory == ObjectCategory_Faces) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedFace_numbers.length - 1);
                  if (nextIndex != -1) selectedFace_numbers[selectedFace_numbers.length - 1] = nextIndex;
                }

                if (Current_ObjectCategory == ObjectCategory_Vertices) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedVertex_numbers.length - 1);
                  if (nextIndex != -1) selectedVertex_numbers[selectedVertex_numbers.length - 1] = nextIndex;
                }

                if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
                }

                if (Current_ObjectCategory == ObjectCategory_Solids) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedSolid_numbers.length - 1);
                  if (nextIndex != -1) selectedSolid_numbers[selectedSolid_numbers.length - 1] = nextIndex;
                }     

                if (Current_ObjectCategory == ObjectCategory_Sections) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedSection_numbers.length - 1);
                  if (nextIndex != -1) selectedSection_numbers[selectedSection_numbers.length - 1] = nextIndex;
                }     

                if (Current_ObjectCategory == ObjectCategory_Cameras) {
                  int nextIndex = SOLARCHVISION_nextUnselected(go_direction, selectedCamera_numbers.length - 1);
                  if (nextIndex != -1) selectedCamera_numbers[selectedCamera_numbers.length - 1] = nextIndex;
                }         

                println("SOLARCHVISION_calculate_selection_BoundingBox 534");
                SOLARCHVISION_calculate_selection_BoundingBox();

                WIN3D_Update = 1;
              }


              if ((WIN3D_UI_CurrentTask == -3) || (WIN3D_UI_CurrentTask == -10) || (WIN3D_UI_CurrentTask == -12) || (WIN3D_UI_CurrentTask == -14)) { // viewport:zoom

                if (WIN3D_ViewType == 1) {
                  WIN3D_Z_Coordinate += Wheel_Value * WIN3D_S_Coordinate * OBJECTS_scale;
                } else {
                  WIN3D_Zoom /= pow(2.0, Wheel_Value);
                }

                WIN3D_Update = 1;
              }

              if (WIN3D_UI_CurrentTask == -4) { // viewport:elevation

                if (Wheel_Value > 0) WIN3D_Zoom = 2 * atan_ang((1.0 / 1.1) * tan_ang(0.5 * WIN3D_Zoom)); 
                if (Wheel_Value < 0) WIN3D_Zoom = 2 * atan_ang((1.1 / 1.0) * tan_ang(0.5 * WIN3D_Zoom));

                WIN3D_Update = 1;
              }  

              if (WIN3D_UI_CurrentTask == -5) { // viewport:3DModelSize

                if (Wheel_Value > 0) OBJECTS_scale *= pow(2.0, 0.25);
                if (Wheel_Value < 0) OBJECTS_scale /= pow(2.0, 0.25);

                WIN3D_Update = 1;
              }          

              if (WIN3D_UI_CurrentTask == -6) { // viewport:different functions with wheel

                if (WIN3D_UI_TaskModifyParameter == 0) { // Truck

                  if (WIN3D_UI_OptionXorY == 0) {

                    WIN3D_X_Coordinate += Wheel_Value * WIN3D_S_Coordinate * OBJECTS_scale;

                    WIN3D_Update = 1;
                  }

                  if (WIN3D_UI_OptionXorY == 1) {

                    WIN3D_Y_Coordinate += Wheel_Value * WIN3D_S_Coordinate * OBJECTS_scale;

                    WIN3D_Update = 1;
                  }
                }


                if (WIN3D_UI_TaskModifyParameter == 1) {  // Orbit

                  if (WIN3D_UI_OptionXorY == 0) {

                    WIN3D_RX_Coordinate += Wheel_Value * WIN3D_RS_Coordinate;

                    WIN3D_Update = 1;
                  }

                  if (WIN3D_UI_OptionXorY == 1) {

                    WIN3D_RZ_Coordinate += Wheel_Value * WIN3D_RS_Coordinate;

                    WIN3D_Update = 1;
                  }
                }


                WIN3D_Update = 1;
              }  


              if (WIN3D_UI_CurrentTask == -7) { // viewport:different functions with wheel

                if (WIN3D_UI_TaskModifyParameter == 0) { // SkydomeSize

                  if (Wheel_Value > 0) SKY3D_scale *= pow(2.0, 0.25);              
                  if (Wheel_Value < 0) SKY3D_scale /= pow(2.0, 0.25);

                  WIN3D_Update = 1;
                }
              }

              if (WIN3D_UI_CurrentTask == -8) { // viewport:different functions with wheel

                if (WIN3D_UI_TaskModifyParameter == 0) { // AllModelSize

                  if (Wheel_Value > 0) {
                    OBJECTS_scale *= pow(2.0, 0.25);
                    SKY3D_scale *= pow(2.0, 0.25);
                  }              

                  if (Wheel_Value < 0) {
                    OBJECTS_scale /= pow(2.0, 0.25);
                    SKY3D_scale /= pow(2.0, 0.25);
                  }      

                  WIN3D_Update = 1;
                }
              }    

              if (WIN3D_UI_CurrentTask == -9) { // viewport:TargetRollXY/TargetRoolZ

                if (WIN3D_UI_OptionXorY == 0) {   
                  WIN3D_RX_Coordinate += Wheel_Value * WIN3D_RS_Coordinate;

                  SOLARCHVISION_reverseTransform_3DViewport();
                }

                if (WIN3D_UI_OptionXorY == 1) {   
                  WIN3D_RZ_Coordinate += Wheel_Value * WIN3D_RS_Coordinate;

                  SOLARCHVISION_reverseTransform_3DViewport();
                }              

                WIN3D_Update = 1;
              }

              if (WIN3D_UI_CurrentTask == -11) { // viewport:CameraRollXY/CameraRoolZ

                if (WIN3D_UI_OptionXorY == 0) {   

                  SOLARCHVISION_rotateZ_3DViewport_around_Selection(Wheel_Value * WIN3D_RS_Coordinate);
                }

                if (WIN3D_UI_OptionXorY == 1) {   

                  SOLARCHVISION_rotateXY_3DViewport_around_Selection(Wheel_Value * WIN3D_RS_Coordinate);
                }    

                WIN3D_Update = 1;
              }            

              if (WIN3D_UI_CurrentTask == -13) { // viewport:CameraDistance

                SOLARCHVISION_move_3DViewport_towards_Selection(pow(2, -0.5 * Wheel_Value));

                WIN3D_Update = 1;
              }              

              if (WIN3D_UI_CurrentTask == -15) { // viewport:PanX

                WIN3D_X_Coordinate += Wheel_Value * WIN3D_S_Coordinate * OBJECTS_scale;

                WIN3D_Update = 1;
              }         

              if (WIN3D_UI_CurrentTask == -16) { // viewport:PanY

                WIN3D_Y_Coordinate += Wheel_Value * WIN3D_S_Coordinate * OBJECTS_scale;

                WIN3D_Update = 1;
              }      

              if (WIN3D_UI_CurrentTask == -17) { // viewport:DistMouseXY

                SOLARCHVISION_move_3DViewport_towards_Mouse(pow(2, -0.5 * Wheel_Value));

                WIN3D_Update = 1;
              }
            }
          }
        }
      }
    }
  }
}


int dragging_started = 0;

void mouseReleased () {

  if (frameCount > Last_initializationStep) {  

    if (SOLARCHVISION_automated == 0) {

      if (dragging_started != 0) {

        SOLARCHVISION_X_click2 = mouseX;
        SOLARCHVISION_Y_click2 = mouseY;

        int swap_tmp = 0;

        if (SOLARCHVISION_X_click2 < SOLARCHVISION_X_click1) {
          swap_tmp = SOLARCHVISION_X_click2;
          SOLARCHVISION_X_click2 = SOLARCHVISION_X_click1;
          SOLARCHVISION_X_click1 = swap_tmp;
        }

        if (SOLARCHVISION_Y_click2 < SOLARCHVISION_Y_click1) {
          swap_tmp = SOLARCHVISION_Y_click2;
          SOLARCHVISION_Y_click2 = SOLARCHVISION_Y_click1;
          SOLARCHVISION_Y_click1 = swap_tmp;
        }        

        if (FRAME_drag_JPG == 1) {

          SOLARCHVISION_RecordFrame();

          strokeWeight(2);
          if (mouseButton == RIGHT) {
            noStroke();
            fill(127, 127);
          } else {
            stroke(255, 0, 0);
            noFill();
          }          

          rect(SOLARCHVISION_X_click1, SOLARCHVISION_Y_click1, SOLARCHVISION_X_click2 - SOLARCHVISION_X_click1, SOLARCHVISION_Y_click2 - SOLARCHVISION_Y_click1);
          strokeWeight(0);

          SOLARCHVISION_RecordFrame();

          WORLD_Update = 1;
          WIN3D_Update = 1;  
          STUDY_Update = 1;
          ROLLOUT_Update = 1;
          SOLARCHVISION_UI_BAR_a_Update = 1;
          SOLARCHVISION_UI_BAR_b_Update = 1;
          SOLARCHVISION_UI_BAR_d_Update = 1;          

          FRAME_drag_JPG = 0;

          dragging_started = 0;
        } else {        

          if (WIN3D_Include == 1) {
            if (isInside(mouseX, mouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {

              if ((WIN3D_UI_CurrentTask == -2) || (WIN3D_UI_CurrentTask > 1)) { // RectSelect also if scale, rotate, modify, etc. where selected          

                float corner1x = SOLARCHVISION_X_click1 - 0.5 * WIN3D_X_View - WIN3D_CX_View;
                float corner1y = SOLARCHVISION_Y_click1 - 0.5 * WIN3D_Y_View - WIN3D_CY_View;

                float corner2x = SOLARCHVISION_X_click2 - 0.5 * WIN3D_X_View - WIN3D_CX_View;
                float corner2y = SOLARCHVISION_Y_click2 - 0.5 * WIN3D_Y_View - WIN3D_CY_View;

                pushMatrix();

                translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

                noFill();

                stroke(127); 
                strokeWeight(2);

                rect(corner1x, corner1y, corner2x - corner1x, corner2y - corner1y);

                popMatrix();            

                SOLARCHVISION_RectSelect(corner1x, corner1y, corner2x, corner2y);

                println("SOLARCHVISION_calculate_selection_BoundingBox 1");
                SOLARCHVISION_calculate_selection_BoundingBox();

                SOLARCHVISION_reset_selectedRefValues();  

                WIN3D_Update = 1;
              }


              if (WIN3D_UI_CurrentTask == 18) {      

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                for (int q = 0; q < 2; q++) {

                  float Image_X = 0;
                  float Image_Y = 0;

                  if (q == 0) {
                    Image_X = SOLARCHVISION_X_click1 - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
                    Image_Y = SOLARCHVISION_Y_click1 - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);
                  }
                  if (q == 1) {
                    Image_X = SOLARCHVISION_X_click2 - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
                    Image_Y = SOLARCHVISION_Y_click2 - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);
                  }

                  float[] ray_direction = new float [3];

                  float[] ray_start = {
                    WIN3D_CAM_x, WIN3D_CAM_y, WIN3D_CAM_z
                  };

                  float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

                  ray_start[0] /= OBJECTS_scale;
                  ray_start[1] /= OBJECTS_scale;
                  ray_start[2] /= OBJECTS_scale;          

                  ray_end[0] /= OBJECTS_scale;
                  ray_end[1] /= OBJECTS_scale;
                  ray_end[2] /= OBJECTS_scale;

                  if (WIN3D_ViewType == 0) {
                    float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

                    ray_center[0] /= OBJECTS_scale;
                    ray_center[1] /= OBJECTS_scale;
                    ray_center[2] /= OBJECTS_scale;

                    ray_start[0] += ray_end[0] - ray_center[0];
                    ray_start[1] += ray_end[1] - ray_center[1];
                    ray_start[2] += ray_end[2] - ray_center[2];
                  }

                  ray_direction[0] = ray_end[0] - ray_start[0];
                  ray_direction[1] = ray_end[1] - ray_start[1];
                  ray_direction[2] = ray_end[2] - ray_start[2];

                  float[] RxP = new float [8]; 

                  if (mouseButton == RIGHT) {
                    RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
                  } else if (mouseButton == LEFT) {
                    RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
                  }

                  if (RxP[0] > 0) {
                    if (q == 0) {
                      x1 = RxP[1];
                      y1 = RxP[2];
                      z1 = RxP[3];
                    }
                    if (q == 1) {
                      x2 = RxP[1];
                      y2 = RxP[2];
                      z2 = RxP[3];
                    }
                  }
                }

                float dx = x2 - x1;
                float dy = y2 - y1;
                float dz = z2 - z1;

                float dx_rot = dx * cos_ang(-WIN3D_RZ_Coordinate) - dy * sin_ang(-WIN3D_RZ_Coordinate);
                float dy_rot = dx * sin_ang(-WIN3D_RZ_Coordinate) + dy * cos_ang(-WIN3D_RZ_Coordinate);
                float dz_rot = dz;

                if (WIN3D_UI_TaskModifyParameter == 0) {
                  CreateInput_Length = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D_UI_TaskModifyParameter == 1) {
                  CreateInput_Width = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D_UI_TaskModifyParameter == 2) {
                  CreateInput_Height = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D_UI_TaskModifyParameter == 3) {
                  CreateInput_Length = abs(dx_rot);
                  CreateInput_Width = abs(dy_rot);
                  CreateInput_Height = abs(dz_rot);
                }
                if (WIN3D_UI_TaskModifyParameter == 4) {
                  CreateInput_Length = abs(dx_rot);
                  CreateInput_Width = abs(dy_rot);
                }
                if (WIN3D_UI_TaskModifyParameter == 5) {
                  CreateInput_Orientation = atan2_ang(y2 - y1, x2 - x1) + 90;
                }

                ROLLOUT_Update = 1;
              }
            }
          }

          dragging_started = 0;
        }
      }
    }
  }
}

void mouseDragged () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_drag_JPG == 1) {
        if (dragging_started == 0) {
          SOLARCHVISION_X_click1 = pmouseX;
          SOLARCHVISION_Y_click1 = pmouseY;

          dragging_started = 1;
        }
      } else if (WIN3D_Include == 1) {
        if (isInside(pmouseX, pmouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {
          if (isInside(mouseX, mouseY, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {

            if (dragging_started == 0) {

              SOLARCHVISION_X_click1 = pmouseX;
              SOLARCHVISION_Y_click1 = pmouseY;

              dragging_started = 1;
            }

            float dx = (mouseX - pmouseX) / float(WIN3D_X_View);
            float dy = (mouseY - pmouseY) / float(WIN3D_Y_View);

            if ((WIN3D_UI_CurrentTask == -15) || (WIN3D_UI_CurrentTask == -16)) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                SOLARCHVISION_rotateXY_3DViewport_around_Selection(10 * dx * WIN3D_RS_Coordinate);

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                SOLARCHVISION_rotateZ_3DViewport_around_Selection(10 * dy * WIN3D_RS_Coordinate);

                WIN3D_Update = 1;
              }
            } 

            if ((WIN3D_UI_CurrentTask == -14) || (WIN3D_UI_CurrentTask == -17)) { // viewport

              if (mouseButton == LEFT) { // pan

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 

                WIN3D_Update = 1;
              }      

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D_RZ_Coordinate += 10 * dx * WIN3D_RS_Coordinate; 
                WIN3D_RX_Coordinate += 10 * dy * WIN3D_RS_Coordinate;

                SOLARCHVISION_reverseTransform_3DViewport(); 

                WIN3D_Update = 1;
              }
            }            

            if ((WIN3D_UI_CurrentTask == -12) || (WIN3D_UI_CurrentTask == -13)) { // viewport

              if (mouseButton == LEFT) { // CameraRoll

                SOLARCHVISION_rotateXY_3DViewport_around_Selection(10 * dx * WIN3D_RS_Coordinate);

                SOLARCHVISION_rotateZ_3DViewport_around_Selection(10 * dy * WIN3D_RS_Coordinate);

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // pan

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 

                WIN3D_Update = 1;
              }
            }  

            if (WIN3D_UI_CurrentTask == -11) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                SOLARCHVISION_rotateXY_3DViewport_around_Selection(10 * dx * WIN3D_RS_Coordinate);

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                SOLARCHVISION_rotateZ_3DViewport_around_Selection(10 * dy * WIN3D_RS_Coordinate);

                WIN3D_Update = 1;
              }
            }            

            if (WIN3D_UI_CurrentTask == -10) { // viewport

              if (mouseButton == LEFT) { // TargetRoll

                WIN3D_RZ_Coordinate += 10 * dx * WIN3D_RS_Coordinate; 
                WIN3D_RX_Coordinate += 10 * dy * WIN3D_RS_Coordinate;

                SOLARCHVISION_reverseTransform_3DViewport(); 

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // pan

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 

                WIN3D_Update = 1;
              }
            }  

            if (WIN3D_UI_CurrentTask == -9) { // viewport

              if (mouseButton == LEFT) { // TargetRollXY

                WIN3D_RZ_Coordinate += 10 * dx * WIN3D_RS_Coordinate; 

                SOLARCHVISION_reverseTransform_3DViewport(); 

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // TargetRollZ

                WIN3D_RX_Coordinate += 10 * dy * WIN3D_RS_Coordinate;

                SOLARCHVISION_reverseTransform_3DViewport(); 

                WIN3D_Update = 1;
              }
            }            

            if ((WIN3D_UI_CurrentTask == -3) || (WIN3D_UI_CurrentTask == -7) || (WIN3D_UI_CurrentTask == -8)) { // viewport

              if (mouseButton == LEFT) { // orbit

                WIN3D_RZ_Coordinate -= 10 * dx * WIN3D_RS_Coordinate; 
                WIN3D_RX_Coordinate -= 10 * dy * WIN3D_RS_Coordinate;

                WIN3D_Update = 1;
              }

              if (mouseButton == RIGHT) { // pan

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 

                WIN3D_Update = 1;
              }
            }  

            if (WIN3D_UI_CurrentTask == -4) { 

              if (mouseButton == LEFT) { // move Y

                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale;  

                WIN3D_Update = 1;
              }              

              if (mouseButton == RIGHT) { // move X

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  

                WIN3D_Update = 1;
              }
            }

            if (WIN3D_UI_CurrentTask == -5) { // viewport

              if (mouseButton == LEFT) { // pan

                WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 

                WIN3D_Update = 1;
              }   

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D_RZ_Coordinate += 10 * dx * WIN3D_RS_Coordinate; 
                WIN3D_RX_Coordinate += 10 * dy * WIN3D_RS_Coordinate;

                SOLARCHVISION_reverseTransform_3DViewport(); 

                WIN3D_Update = 1;
              }
            }

            if (WIN3D_UI_CurrentTask == -6) { // viewport:different functions

              if (WIN3D_UI_TaskModifyParameter == 0) { // Truck

                if (WIN3D_UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                  if (mouseButton == RIGHT) WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 
                  WIN3D_Update = 1;
                }

                if (WIN3D_UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D_X_Coordinate += 100 * dx * WIN3D_S_Coordinate * OBJECTS_scale;  
                  if (mouseButton == LEFT) WIN3D_Y_Coordinate += 100 * dy * WIN3D_S_Coordinate * OBJECTS_scale; 
                  WIN3D_Update = 1;
                }
              }


              if (WIN3D_UI_TaskModifyParameter == 1) {  // Orbit

                if (WIN3D_UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D_RX_Coordinate -= 10 * dy * WIN3D_RS_Coordinate;
                  if (mouseButton == RIGHT) WIN3D_RZ_Coordinate -= 10 * dx * WIN3D_RS_Coordinate;
                  WIN3D_Update = 1;
                }

                if (WIN3D_UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D_RX_Coordinate -= 10 * dy * WIN3D_RS_Coordinate;
                  if (mouseButton == LEFT) WIN3D_RZ_Coordinate -= 10 * dx * WIN3D_RS_Coordinate;
                  WIN3D_Update = 1;
                }
              }


              WIN3D_Update = 1;
            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_update_Project_info (File selectedFile) {

  ProjectName = selectedFile.getName().replace(".xml", "").replace(".XML", "").replace(".Xml", ""); // should work most of the times!
  ProjectsFolder =  selectedFile.getAbsolutePath().replace(char(92), '/').replace("/" + selectedFile.getName(), "");

  println("New ProjectName:", ProjectName);
  println("New ProjectsFolder:", ProjectsFolder);
}

void SOLARCHVISION_fileSelected_New (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("New project:", Filename);

    SOLARCHVISION_update_Project_info(selectedFile);
  }
}

void SOLARCHVISION_fileSelected_Open (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Loading:", Filename);

    SOLARCHVISION_load_project(Filename);

    SOLARCHVISION_update_Project_info(selectedFile);
  }
} 


void SOLARCHVISION_fileSelected_SaveAs (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Saving to:", Filename);

    SOLARCHVISION_save_project(Filename, Display_Output_in_Explorer);

    SOLARCHVISION_update_Project_info(selectedFile);
  }
}     



void SOLARCHVISION_SelectFile_Import_3DModel (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Importing:", Filename);

    int NUM_allGroup3Ds_Faces_Before = allGroup3Ds_num + 1;

    //SOLARCHVISION_import_objects_OBJ(Filename, -1,0,0,1,1, 0,0,0, 1,1,1); // different objects: different materials
    SOLARCHVISION_import_objects_OBJ(Filename, DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, 0, 0, 0, 1, 1, 1); // apply default material

    int NUM_allGroup3Ds_Faces_After = allGroup3Ds_num + 1;

    selectedGroup3D_numbers = new int [1 + NUM_allGroup3Ds_Faces_After - NUM_allGroup3Ds_Faces_Before];
    for (int i = 0; i < selectedGroup3D_numbers.length - 1; i++) { 
      selectedGroup3D_numbers[i] = i + NUM_allGroup3Ds_Faces_Before;
      //println(selectedGroup3D_numbers[i]);
    }

    Current_ObjectCategory = ObjectCategory_Group3Ds;

    SOLARCHVISION_calculate_selection_BoundingBox();

    WIN3D_Update = 1;
  }
}     



void mouseClicked () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_click_JPG == 1) {

        SOLARCHVISION_RecordFrame();

        SOLARCHVISION_UI_dessin_Mouse(1, mouseX, mouseY, 2 * MessageSize);        

        SOLARCHVISION_RecordFrame();
        /*        
         WORLD_Update = 1;
         WIN3D_Update = 1;  
         STUDY_Update = 1;
         ROLLOUT_Update = 1;
         SOLARCHVISION_UI_BAR_a_Update = 1;
         SOLARCHVISION_UI_BAR_b_Update = 1;
         SOLARCHVISION_UI_BAR_d_Update = 1;          
         
         FRAME_click_JPG = 0;
         */
      }    


      if ((SOLARCHVISION_UI_BAR_a_selected_parent != -1) && (isInside(mouseX, mouseY, 0, 0, width, SOLARCHVISION_A_Pixel) == 0)) {

        if (mouseButton == LEFT) {
          if (SOLARCHVISION_UI_BAR_a_selected_child != 0) {

            // should call the functions here!

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Mojtaba Samimi")) { 
              link("http://solarchvision.com/?page_id=102");
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("www.solarchvision.com")) { 
              link("http://solarchvision.com/");
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("New")) { 
              selectInput("Specify project name:", "SOLARCHVISION_fileSelected_New");

              SOLARCHVISION_delete_All();


              //SOLARCHVISION_update_station(0);
            }  

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Save")) { 
              SOLARCHVISION_save_project(ProjectsFolder + "/" + ProjectName + ".xml", 0);
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hold")) {
              HoldStamp = nf(millis(), 0);
              int pre_Display_Output_in_Explorer = Display_Output_in_Explorer;

              SOLARCHVISION_save_project(ProjectsFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml", 0);
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Fetch")) {
              try {
                SOLARCHVISION_load_project(ProjectsFolder + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml");
              }
              catch (Exception e) {
                println("Cannot find hold file!");
              }
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Undo")) {
            }             

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Open...")) { 
              selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
            }          

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Save As...")) { 
              selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Import 3D-Model...")) { 
              selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Export 3D-Model > OBJ")) {
              SOLARCHVISION_export_objects_OBJ();
            }    
            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Export 3D-Model > RAD")) {
              SOLARCHVISION_export_objects_RAD();
            }
        
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Export 3D-Model > SCR")) {
              SOLARCHVISION_export_objects_SCR();
            }                

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Quit")) { 
              exit();
            }      



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Wind pattern (active)")) {
              STUDY_PlotImpacts = -2;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 1;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Wind pattern (passive)")) {
              STUDY_PlotImpacts = -1;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 1;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Urban solar potential (active)")) {
              STUDY_PlotImpacts = 0;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Urban solar potential (passive)")) {
              STUDY_PlotImpacts = 1;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Orientation potential (active)")) {
              STUDY_PlotImpacts = 2;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Orientation potential (passive)")) {
              STUDY_PlotImpacts = 3;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hourly sun position (active)")) {
              STUDY_PlotImpacts = 4;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hourly sun position (passive)")) {
              STUDY_PlotImpacts = 5;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("View from sun & sky (active)")) {
              STUDY_PlotImpacts = 6;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("View from sun & sky (passive)")) {
              STUDY_PlotImpacts = 7;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Annual cycle sun path (active)")) {
              STUDY_PlotImpacts = 8;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Annual cycle sun path (passive)")) {
              STUDY_PlotImpacts = 9;
              STUDY_Setup = 14; // <<<<<<<<
              STUDY_Update = 1;
              Display_WindRoseImage = 0;
              ROLLOUT_Update = 1;
            }  

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pre-bake Selected Sections")) {
              SOLARCHVISION_render_Shadows_selectedSections();              
              WIN3D_Update = 1;
            }         

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Process Active Impact")) {
              STUDY_PlotImpacts = 0;         
              SOLARCHVISION_calculate_SolarImpact_selectedSections();              
              WIN3D_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Process Passive Impact")) {
              STUDY_PlotImpacts = 1;         
              SOLARCHVISION_calculate_SolarImpact_selectedSections();              
              WIN3D_Update = 1;
            }               

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Process Solid Impact")) {
              SOLARCHVISION_calculate_SolidImpact_selectedSections();              
              WIN3D_Update = 1;
            }  

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Run wind 3D-model")) {
              SOLARCHVISION_calculate_WindFlow();              
              WIN3D_Update = 1;
            }  

            for (int n = -2; n <= 14; n++) { 
              if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Layout " + nf(n, 0))) {

                STUDY_Setup = n;
                STUDY_Update = 1;

                if (STUDY_Setup == 14) {
                } else {  

                  if (FrameVariation != 2) {
                    FrameVariation = 2;
                    SOLARCHVISION_update_frame_layout();
                  }
                }
              }
            }




            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Stop REC.")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   

              ROLLOUT_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("REC. Time Graph")) { 
              STUDY_record_AUTO = 1;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   

              ROLLOUT_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("REC. Location Graph")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 1;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   

              ROLLOUT_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("REC. Solid Graph")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 1;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 0;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   

              ROLLOUT_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("REC. Screenshot")) { 
              STUDY_record_AUTO = 0;
              STUDY_record_JPG = 0;
              STUDY_record_PDF = 0;
              WORLD_record_AUTO = 0;
              WORLD_record_JPG = 0;
              WORLD_record_PDF = 0;
              WIN3D_record_AUTO = 0;
              WIN3D_record_JPG = 0;
              FRAME_record_AUTO = 1;
              FRAME_record_JPG = 0;
              FRAME_click_JPG = 0;
              FRAME_drag_JPG = 0;   

              ROLLOUT_Update = 1;
            }             

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PDF Time Graph")) { 
              STUDY_record_PDF = 1;
              STUDY_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("JPG Time Graph")) { 
              STUDY_record_JPG = 1;
              STUDY_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("JPG Location Graph")) { 
              WORLD_record_JPG = 1;
              WORLD_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PDF Location Graph")) { 
              WORLD_record_PDF = 1;
              WORLD_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("JPG 3D Graph")) { 
              WIN3D_record_JPG = 1;
              WIN3D_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Screenshot")) { 
              FRAME_record_JPG = 1;
            }             

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Screenshot+Click")) { 
              FRAME_click_JPG = 1;
            }           

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Screenshot+Drag")) { 
              FRAME_drag_JPG = 1;
            }                

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][0].equals("Site")) {
              if (SOLARCHVISION_UI_BAR_a_selected_child > 0) {
                if (STATION_Number != SOLARCHVISION_UI_BAR_a_selected_child - 1) {

                  STATION_Number = SOLARCHVISION_UI_BAR_a_selected_child - 1;

                  SOLARCHVISION_update_station(0);
                }
              }
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][0].equals("Layer")) {
              if (SOLARCHVISION_UI_BAR_a_selected_child > 0) {
                if (STUDY_CurrentLayer != SOLARCHVISION_UI_BAR_a_selected_child - 1) {

                  if (SOLARCHVISION_UI_BAR_a_selected_child < num_Layers) {

                    STUDY_CurrentLayer = SOLARCHVISION_UI_BAR_a_selected_child - 1;

                    STUDY_DevelopLayer = STUDY_CurrentLayer;

                    STUDY_Update = 1;
                  } else {

                    if ((Develop_Option == DEV_OP_06) || (Develop_Option == DEV_OP_07) || (Develop_Option == DEV_OP_08)) {

                      if (STUDY_CurrentLayer == STUDY_DevelopLayer) {

                        STUDY_CurrentLayer = LAYER_developed;
                      }

                      Develop_Option = SOLARCHVISION_UI_BAR_a_selected_child - num_Layers;

                      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);   

                      STUDY_Update = 1;
                    } else {

                      STUDY_DevelopLayer = STUDY_CurrentLayer;

                      STUDY_CurrentLayer = LAYER_developed; 

                      Develop_Option = SOLARCHVISION_UI_BAR_a_selected_child - num_Layers;

                      SOLARCHVISION_DevelopDATA(IMPACTS_DataSource);   

                      STUDY_Update = 1;
                    }
                  }
                }
              }
            }            


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Typical Year (TMY)")) {
              IMPACTS_DataSource = databaseNumber_CLIMATE_TMYEPW;

              if (LoadButton_CLIMATE_TMYEPW == 0) {
                LoadButton_CLIMATE_TMYEPW = 1;
                SOLARCHVISION_try_update_CLIMATE_TMYEPW();
              }

              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              SOLARCHVISION_UI_BAR_d_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Long-term (CWEEDS)")) {
              IMPACTS_DataSource = databaseNumber_CLIMATE_CWEEDS;

              if (LoadButton_CLIMATE_CWEEDS == 0) {
                LoadButton_CLIMATE_CWEEDS = 1;
                SOLARCHVISION_try_update_CLIMATE_CWEEDS();
              }

              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              SOLARCHVISION_UI_BAR_d_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Long-term (CLMREC)")) {
              IMPACTS_DataSource = databaseNumber_CLIMATE_CLMREC;

              if (LoadButton_CLIMATE_CLMREC == 0) {
                LoadButton_CLIMATE_CLMREC = 1;
                SOLARCHVISION_try_update_CLIMATE_CLMREC();
              }

              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              SOLARCHVISION_UI_BAR_d_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Weather Forecast (NAEFS)")) {
              IMPACTS_DataSource = databaseNumber_FORECAST_ENSEMBLE;

              if (LoadButton_FORECAST_ENSEMBLE == 0) {
                LoadButton_FORECAST_ENSEMBLE = 1;
                SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
              }

              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              SOLARCHVISION_UI_BAR_d_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Real-time Observed (SWOB)")) {
              IMPACTS_DataSource = databaseNumber_RECENT_OBSERVED;

              if (LoadButton_RECENT_OBSERVED == 0) {
                LoadButton_RECENT_OBSERVED = 1;
                SOLARCHVISION_try_update_RECENT_OBSERVED();
              }

              WORLD_Update = 1;
              WIN3D_Update = 1;  
              STUDY_Update = 1;
              ROLLOUT_Update = 1;
              SOLARCHVISION_UI_BAR_d_Update = 1;
            }           

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Surface Wire")) {
              WIN3D_FacesShade = Shade_Surface_Wire;
              MODEL3D_DisplayEdges = 1; //<<<<<<<<<<<<<<<

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }       
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Surface Base")) {
              WIN3D_FacesShade = Shade_Surface_Base;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Surface White")) {
              WIN3D_FacesShade = Shade_Surface_White;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Surface Materials")) {
              WIN3D_FacesShade = Shade_Surface_Materials;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Global Solar")) {
              WIN3D_FacesShade = Shade_Global_Solar;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Vertex Solar")) {
              WIN3D_FacesShade = Shade_Vertex_Solar;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Vertex Solid")) {
              WIN3D_FacesShade = Shade_Vertex_Solid;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shade Vertex Elevation")) {
              WIN3D_FacesShade = Shade_Vertex_Elevation;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Render Viewport")) {
              
              SOLARCHVISION_RenderViewport();            
            }              
            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Land Mesh")) {
              Display_LAND_MESH = (Display_LAND_MESH + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Land Texture")) {
              Display_LAND_Texture = (Display_LAND_Texture + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }       
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Land Points")) {
              Display_LAND_POINTS = (Display_LAND_POINTS + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }                 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Land Depth")) {
              Display_LAND_DEPTH = (Display_LAND_DEPTH + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Edges")) {
              MODEL3D_DisplayEdges = (MODEL3D_DisplayEdges  + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Normals")) {
              MODEL3D_DisplayNormals = (MODEL3D_DisplayNormals  + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Leaves")) {
              Display_Leaves = (Display_Leaves + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }                
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Living Objects")) {
              Display_Model2Ds = (Display_Model2Ds + 1) % 2;
              Display_Fractals = Display_Model2Ds; // <<<<<<<
              Display_Leaves = Display_Fractals; // <<<<<<

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Building Objects")) {
              Display_Model3Ds = (Display_Model3Ds + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Urban")) {
              Display_URBAN_MESH = (Display_URBAN_MESH + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Solids")) {
              Display_Solids = (Display_Solids + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Sections")) {
              Display_Sections = (Display_Sections + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Cameras")) {
              Display_Cameras = (Display_Cameras + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Sky")) {
              Display_SKY3D = (Display_SKY3D + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Sun Path")) {
              Display_SUN3D_Path = (Display_SUN3D_Path + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Sun Pattern")) {
              Display_SUN3D_Pattern = (Display_SUN3D_Pattern + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Star")) {
              Display_STAR3D_Surface = (Display_STAR3D_Surface + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Moon")) {
              Display_MOON3D_Surface = (Display_MOON3D_Surface + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Earth")) {
              Display_EARTH3D_Surface = (Display_EARTH3D_Surface + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Troposphere")) {
              Display_TROPO3D_Surface = (Display_TROPO3D_Surface + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Solar Section")) {
              Display_SolarImpactImage = (Display_SolarImpactImage + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Solid Section")) {
              Display_SolidImpactImage = (Display_SolidImpactImage + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Solids")) {
              selectedSolid_displayEdges = (selectedSolid_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Sections")) {
              selectedSection_displayEdges = (selectedSection_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Cameras")) {
              selectedCamera_displayEdges = (selectedCamera_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }     
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected LandPoints")) {
              selectedLandPoint_displayPoints = (selectedLandPoint_displayPoints + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }                  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Wind Flow")) {
              Display_WindFlow = (Display_WindFlow + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Faces")) {
              selectedFace_displayEdges = (selectedFace_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Faces Vertex Count")) {
              selectedFace_displayVertexCount = (selectedFace_displayVertexCount + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }               
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Vertices")) {
              selectedVertex_displayVertices = (selectedVertex_displayVertices + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected REF Pivot")) {
              selected_displayReferencePivot = (selected_displayReferencePivot + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }        
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Group3D Pivot")) {
              selectedGroup3D_displayPivot = (selectedGroup3D_displayPivot + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Group3D Edges")) {
              selectedGroup3D_displayEdges = (selectedGroup3D_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected Group3D Box")) {
              selectedGroup3D_displayBox = (selectedGroup3D_displayBox + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected 2½D Edges")) {
              selectedObject2D_displayEdges = (selectedObject2D_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide Selected ∞-D Edges")) {
              selectedFractal_displayEdges = (selectedFractal_displayEdges + 1) % 2;

              WIN3D_Update = 1;  
              ROLLOUT_Update = 1;
            }              

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide SWOB points")) {
              Display_SWOB_Points = (Display_SWOB_Points  + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide SWOB nearest")) {
              Display_SWOB_Nearest = (Display_SWOB_Nearest + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide NAEFS points")) {
              Display_NAEFS_Points = (Display_NAEFS_Points + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide NAEFS nearest")) {
              Display_NAEFS_Nearest = (Display_NAEFS_Nearest  + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide CWEEDS points")) {
              Display_CWEEDS_Points = (Display_CWEEDS_Points + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide CWEEDS nearest")) {
              Display_CWEEDS_Nearest = (Display_CWEEDS_Nearest + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide CLMREC points")) {
              Display_CLMREC_Points = (Display_CLMREC_Points + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide CLMREC nearest")) {
              Display_CLMREC_Nearest = (Display_CLMREC_Nearest + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide TMYEPW points")) {
              Display_TMYEPW_Points = (Display_TMYEPW_Points + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Display/Hide TMYEPW nearest")) {
              Display_TMYEPW_Nearest = (Display_TMYEPW_Nearest + 1) % 2;

              WORLD_Update = 1;  
              ROLLOUT_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Fractal")) {
              SOLARCHVISION_UI_set_to_Create_Fractal();
              SOLARCHVISION_highlight_in_BAR_b("Fractal");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Tree")) {
              SOLARCHVISION_UI_set_to_Create_Tree();
              SOLARCHVISION_highlight_in_BAR_b("Tree");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Person")) {
              SOLARCHVISION_UI_set_to_Create_Person();
              SOLARCHVISION_highlight_in_BAR_b("Person");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 1")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(1);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 2")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(2);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 3")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(3);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 4")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(4);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 5")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(5);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 6")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(6);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Parametric 7")) {
              SOLARCHVISION_UI_set_to_Create_Parametric(7);
              SOLARCHVISION_highlight_in_BAR_b("Parametric");      
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Tri")) {
              SOLARCHVISION_UI_set_to_Create_Tri();
              SOLARCHVISION_highlight_in_BAR_b("Tri");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Poly")) {
              SOLARCHVISION_UI_set_to_Create_Poly();
              SOLARCHVISION_highlight_in_BAR_b("Poly");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Extrude")) {
              SOLARCHVISION_UI_set_to_Create_Extrude();
              SOLARCHVISION_highlight_in_BAR_b("Extrude");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hyper")) {
              SOLARCHVISION_UI_set_to_Create_Hyper();
              SOLARCHVISION_highlight_in_BAR_b("Hyper");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("House")) {
              SOLARCHVISION_UI_set_to_Create_House();
              SOLARCHVISION_highlight_in_BAR_b("House");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Box")) {
              SOLARCHVISION_UI_set_to_Create_Box();
              SOLARCHVISION_highlight_in_BAR_b("Box");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Octahedron")) {
              SOLARCHVISION_UI_set_to_Create_Octahedron();
              SOLARCHVISION_highlight_in_BAR_b("Octahedron");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Sphere")) {
              SOLARCHVISION_UI_set_to_Create_Sphere();
              SOLARCHVISION_highlight_in_BAR_b("Sphere");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Cylinder")) {
              SOLARCHVISION_UI_set_to_Create_Cylinder();
              SOLARCHVISION_highlight_in_BAR_b("Cylinder");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Cushion")) {
              SOLARCHVISION_UI_set_to_Create_Cushion();
              SOLARCHVISION_highlight_in_BAR_b("Cushion");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Drop on LandSurface")) {
              SOLARCHVISION_UI_set_to_Modify_Drop(0);
              SOLARCHVISION_highlight_in_BAR_b("DrL±");
              SOLARCHVISION_UI_BAR_b_Update = 1;  

              SOLARCHVISION_drop_Selection();
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Drop on ModelSurface (Down)")) {
              SOLARCHVISION_UI_set_to_Modify_Drop(1);
              SOLARCHVISION_highlight_in_BAR_b("DrM-");
              SOLARCHVISION_UI_BAR_b_Update = 1;  

              SOLARCHVISION_drop_Selection(); 
              WIN3D_Update = 1;
            }                      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Drop on ModelSurface (Up)")) {
              SOLARCHVISION_UI_set_to_Modify_Drop(2);
              SOLARCHVISION_highlight_in_BAR_b("DrM+");
              SOLARCHVISION_UI_BAR_b_Update = 1;  

              SOLARCHVISION_drop_Selection();
              WIN3D_Update = 1;
            }



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get dX")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(0);
              SOLARCHVISION_highlight_in_BAR_b("GLx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get dY")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(1);
              SOLARCHVISION_highlight_in_BAR_b("GLy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get dZ")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(2);
              SOLARCHVISION_highlight_in_BAR_b("GLz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get dXYZ")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(3);
              SOLARCHVISION_highlight_in_BAR_b("GL³");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get dXY")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(4);
              SOLARCHVISION_highlight_in_BAR_b("GL²");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get Angle")) {
              SOLARCHVISION_UI_set_to_Modify_GetLength(5);
              SOLARCHVISION_highlight_in_BAR_b("GLa");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }               


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("MoveX")) {
              SOLARCHVISION_UI_set_to_Modify_Move(0);
              SOLARCHVISION_highlight_in_BAR_b("MVx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("MoveY")) {
              SOLARCHVISION_UI_set_to_Modify_Move(1);
              SOLARCHVISION_highlight_in_BAR_b("MVy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("MoveZ")) {
              SOLARCHVISION_UI_set_to_Modify_Move(2);
              SOLARCHVISION_highlight_in_BAR_b("MVz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Move")) {
              SOLARCHVISION_UI_set_to_Modify_Move(3);
              SOLARCHVISION_highlight_in_BAR_b("MV³");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("ScaleX")) {
              SOLARCHVISION_UI_set_to_Modify_Scale(0);
              SOLARCHVISION_highlight_in_BAR_b("SCx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("ScaleY")) {
              SOLARCHVISION_UI_set_to_Modify_Scale(1);
              SOLARCHVISION_highlight_in_BAR_b("SCy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("ScaleZ")) {
              SOLARCHVISION_UI_set_to_Modify_Scale(2);
              SOLARCHVISION_highlight_in_BAR_b("SCz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Scale")) {
              SOLARCHVISION_UI_set_to_Modify_Scale(3);
              SOLARCHVISION_highlight_in_BAR_b("SC³");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PowerX")) {
              SOLARCHVISION_UI_set_to_Modify_Power(0);
              SOLARCHVISION_highlight_in_BAR_b("PWx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PowerY")) {
              SOLARCHVISION_UI_set_to_Modify_Power(1);
              SOLARCHVISION_highlight_in_BAR_b("PWy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PowerZ")) {
              SOLARCHVISION_UI_set_to_Modify_Power(2);
              SOLARCHVISION_highlight_in_BAR_b("PWz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Power")) {
              SOLARCHVISION_UI_set_to_Modify_Power(3);
              SOLARCHVISION_highlight_in_BAR_b("PW³");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("RotateX")) {
              SOLARCHVISION_UI_set_to_Modify_Rotate(0);
              SOLARCHVISION_highlight_in_BAR_b("RTx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("RotateY")) {
              SOLARCHVISION_UI_set_to_Modify_Rotate(1);
              SOLARCHVISION_highlight_in_BAR_b("RTy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("RotateZ")) {
              SOLARCHVISION_UI_set_to_Modify_Rotate(2);
              SOLARCHVISION_highlight_in_BAR_b("RTz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Rotate")) {
              SOLARCHVISION_UI_set_to_Modify_Rotate(2);
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pivot")) {
              SOLARCHVISION_UI_set_to_Modify_Pivot(0);
              SOLARCHVISION_highlight_in_BAR_b("SPvt0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick Pivot")) {
              SOLARCHVISION_UI_set_to_Modify_Pivot(1);
              SOLARCHVISION_highlight_in_BAR_b("SPvt1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign Pivot")) {
              SOLARCHVISION_UI_set_to_Modify_Pivot(2);
              SOLARCHVISION_highlight_in_BAR_b("SPvt2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Save Current ReferenceBox")) {
              SOLARCHVISION_save_current_BoundingBox();
              SOLARCHVISION_highlight_in_BAR_b("<pvt>");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Reset Saved ReferenceBox")) {
              SOLARCHVISION_apply_saved_ReferenceBox();
              SOLARCHVISION_highlight_in_BAR_b(">pvt<");
              SOLARCHVISION_UI_BAR_b_Update = 1;  
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Use Selection ReferenceBox")) {
              SOLARCHVISION_calculate_selection_BoundingBox();
              SOLARCHVISION_highlight_in_BAR_b("|pvt|");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Use Origin ReferenceBox")) {
              SOLARCHVISION_apply_origin_ReferenceBox();
              SOLARCHVISION_highlight_in_BAR_b(".pvt.");
              SOLARCHVISION_UI_BAR_b_Update = 1;  
              WIN3D_Update = 1;
            }



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Begin New Group3D at Origin")) {
              SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

              selectedGroup3D_numbers = new int [2];
              selectedGroup3D_numbers[0] = 0;
              selectedGroup3D_numbers[1] = allGroup3Ds_num;

              WIN3D_Update = 1;
            }    

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Begin New Group3D at Pivot")) {

              SOLARCHVISION_beginNewGroup3D(SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][1], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][2], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][4], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][5], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][7], SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][8]);

              selectedGroup3D_numbers = new int [2];
              selectedGroup3D_numbers[0] = 0;
              selectedGroup3D_numbers[1] = allGroup3Ds_num;       

              WIN3D_Update = 1;
            }              

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Solid")) {
              SOLARCHVISION_UI_set_to_Create_Solid();
              SOLARCHVISION_highlight_in_BAR_b("SLD");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Section")) {
              SOLARCHVISION_UI_set_to_Create_Section();
              SOLARCHVISION_highlight_in_BAR_b("SEC");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Camera")) {
              SOLARCHVISION_UI_set_to_Create_Camera();
              SOLARCHVISION_highlight_in_BAR_b("CAM");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Viewport >> Camera")) {

              float Camera_X = WIN3D_X_Coordinate;
              float Camera_Y = WIN3D_Y_Coordinate;
              float Camera_Z = WIN3D_Z_Coordinate;
              float Camera_S = WIN3D_S_Coordinate;
              float Camera_RX = WIN3D_RX_Coordinate;
              float Camera_RY = WIN3D_RY_Coordinate;
              float Camera_RZ = WIN3D_RZ_Coordinate;
              float Camera_ZOOM = WIN3D_Zoom;

              int Camera_Type = WIN3D_ViewType;

              SOLARCHVISION_add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

              WIN3D_CurrentCamera = allCameras_num;
              SOLARCHVISION_apply_currentCamera();
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D_Update = 1;   
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Camera >> Viewport")) {

              allCameras_PPPSRRRF[0][0] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][0];
              allCameras_PPPSRRRF[0][1] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][1];
              allCameras_PPPSRRRF[0][2] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][2];
              allCameras_PPPSRRRF[0][3] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][3];
              allCameras_PPPSRRRF[0][4] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][4];
              allCameras_PPPSRRRF[0][5] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][5];
              allCameras_PPPSRRRF[0][6] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][6];
              allCameras_PPPSRRRF[0][7] = allCameras_PPPSRRRF[WIN3D_CurrentCamera][7];

              allCameras_Type[0] = allCameras_Type[WIN3D_CurrentCamera];

              WIN3D_CurrentCamera = 0;
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D_Update = 1;   
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }  

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("GoTo Selected Camera")) {

              WIN3D_CurrentCamera = selectedCamera_numbers[selectedCamera_numbers.length - 1];
              SOLARCHVISION_apply_currentCamera();
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D_Update = 1;   
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change Seed/Material")) {
              SOLARCHVISION_UI_set_to_Modify_Seed(0);
              SOLARCHVISION_highlight_in_BAR_b("Mat0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick Seed/Material")) {
              SOLARCHVISION_UI_set_to_Modify_Seed(1);
              SOLARCHVISION_highlight_in_BAR_b("Mat1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign Seed/Material")) {
              SOLARCHVISION_UI_set_to_Modify_Seed(2);
              SOLARCHVISION_highlight_in_BAR_b("Mat2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change Tessellation")) {
              SOLARCHVISION_UI_set_to_Modify_Tessellation(0);
              SOLARCHVISION_highlight_in_BAR_b("Tes0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick Tessellation")) {
              SOLARCHVISION_UI_set_to_Modify_Tessellation(1);
              SOLARCHVISION_highlight_in_BAR_b("Tes1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign Tessellation")) {
              SOLARCHVISION_UI_set_to_Modify_Tessellation(2);
              SOLARCHVISION_highlight_in_BAR_b("Tes2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change Layer")) {
              SOLARCHVISION_UI_set_to_Modify_Layer(0);
              SOLARCHVISION_highlight_in_BAR_b("Lyr0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick Layer")) {
              SOLARCHVISION_UI_set_to_Modify_Layer(1);
              SOLARCHVISION_highlight_in_BAR_b("Lyr1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign Layer")) {
              SOLARCHVISION_UI_set_to_Modify_Layer(2);
              SOLARCHVISION_highlight_in_BAR_b("Lyr2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change Visibility")) {
              SOLARCHVISION_UI_set_to_Modify_Visibility(0);
              SOLARCHVISION_highlight_in_BAR_b("Vsb0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick Visibility")) {
              SOLARCHVISION_UI_set_to_Modify_Visibility(1);
              SOLARCHVISION_highlight_in_BAR_b("Vsb1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign Visibility")) {
              SOLARCHVISION_UI_set_to_Modify_Visibility(2);
              SOLARCHVISION_highlight_in_BAR_b("Vsb2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Flip FaceNormal")) {
              SOLARCHVISION_UI_set_to_Modify_FaceNormal(1);
              SOLARCHVISION_highlight_in_BAR_b("FNorm1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Set-Out FaceNormal")) {
              SOLARCHVISION_UI_set_to_Modify_FaceNormal(2);
              SOLARCHVISION_highlight_in_BAR_b("FNorm2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Set-In FaceNormal")) {
              SOLARCHVISION_UI_set_to_Modify_FaceNormal(3);
              SOLARCHVISION_highlight_in_BAR_b("FNorm3");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Get FaceFirstVertex")) {
              SOLARCHVISION_UI_set_to_Modify_FaceFirstVertex(1);
              SOLARCHVISION_highlight_in_BAR_b("F1stV");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeMax")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMax(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMax0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick DegreeMax")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMax(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMax1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign DegreeMax")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMax(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMax2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeDif")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeDif(0);
              SOLARCHVISION_highlight_in_BAR_b("dgDif0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick DegreeDif")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeDif(1);
              SOLARCHVISION_highlight_in_BAR_b("dgDif1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign DegreeDif")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeDif(2);
              SOLARCHVISION_highlight_in_BAR_b("dgDif2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeMin")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMin(0);
              SOLARCHVISION_highlight_in_BAR_b("dgMin0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick DegreeMin")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMin(1);
              SOLARCHVISION_highlight_in_BAR_b("dgMin1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign DegreeMin")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMin(2);
              SOLARCHVISION_highlight_in_BAR_b("dgMin2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change TrunkSize")) {
              SOLARCHVISION_UI_set_to_Modify_TrunkSize(0);
              SOLARCHVISION_highlight_in_BAR_b("trSz0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick TrunkSize")) {
              SOLARCHVISION_UI_set_to_Modify_TrunkSize(1);
              SOLARCHVISION_highlight_in_BAR_b("trSz1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign TrunkSize")) {
              SOLARCHVISION_UI_set_to_Modify_TrunkSize(2);
              SOLARCHVISION_highlight_in_BAR_b("trSz2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change LeafSize")) {
              SOLARCHVISION_UI_set_to_Modify_LeafSize(0);
              SOLARCHVISION_highlight_in_BAR_b("lfSz0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick LeafSize")) {
              SOLARCHVISION_UI_set_to_Modify_LeafSize(1);
              SOLARCHVISION_highlight_in_BAR_b("lfSz1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign LeafSize")) {
              SOLARCHVISION_UI_set_to_Modify_LeafSize(2);
              SOLARCHVISION_highlight_in_BAR_b("lfSz2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("AllFractalProps")) {
              SOLARCHVISION_UI_set_to_Modify_AllFractalProps(0);
              SOLARCHVISION_highlight_in_BAR_b("allFP0");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pick AllFractalProps")) {
              SOLARCHVISION_UI_set_to_Modify_AllFractalProps(1);
              SOLARCHVISION_highlight_in_BAR_b("allFP1");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Assign AllFractalProps")) {
              SOLARCHVISION_UI_set_to_Modify_AllFractalProps(2);
              SOLARCHVISION_highlight_in_BAR_b("allFP2");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeMax")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMax(0);
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeDif")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeDif(0);
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change DegreeMin")) {
              SOLARCHVISION_UI_set_to_Modify_DegreeMin(0);
            }     
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change TrunkSize")) {
              SOLARCHVISION_UI_set_to_Modify_TrunkSize(0);
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Change LeafSize")) {
              SOLARCHVISION_UI_set_to_Modify_LeafSize(0);
            }           


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Orthographic")) {
              SOLARCHVISION_UI_set_to_View_ProjectionType(0);
              SOLARCHVISION_highlight_in_BAR_b("P<>");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Perspective")) {
              SOLARCHVISION_UI_set_to_View_ProjectionType(1);
              SOLARCHVISION_highlight_in_BAR_b("P><");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Reverse Selection")) {
              SOLARCHVISION_reverse_Selection();
              WIN3D_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Deselect All")) {
              SOLARCHVISION_deselect_All();
              WIN3D_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select All")) {
              SOLARCHVISION_select_All();
              WIN3D_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Solid")) {
              Current_ObjectCategory = ObjectCategory_Solids;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Section")) {
              Current_ObjectCategory = ObjectCategory_Sections;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }       
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Camera")) {
              Current_ObjectCategory = ObjectCategory_Cameras;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select LandPoint")) {
              Current_ObjectCategory = ObjectCategory_LandPoint;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Fractal")) {
              Current_ObjectCategory = ObjectCategory_Fractals;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Object2D")) {
              Current_ObjectCategory = ObjectCategory_Object2Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Group3D")) {
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Face")) {
              Current_ObjectCategory = ObjectCategory_Faces;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Vertex")) {
              Current_ObjectCategory = ObjectCategory_Vertices;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Soft Selection")) {
              SOLARCHVISION_convert_Vertex_to_softSelection();

              Current_ObjectCategory = ObjectCategory_SoftVerts;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Vertex >> Group3D")) {
              SOLARCHVISION_convert_Vertex_to_Group3D();
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Face >> Group3D")) {
              SOLARCHVISION_convert_Face_to_Group3D();
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group3D >> Face")) {
              SOLARCHVISION_convert_Group3D_to_Face();
              Current_ObjectCategory = ObjectCategory_Faces;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group3D >> Vertex")) {
              SOLARCHVISION_convert_Group3D_to_Vertex();
              Current_ObjectCategory = ObjectCategory_Vertices;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Face >> Vertex")) {
              SOLARCHVISION_convert_Face_to_Vertex();
              Current_ObjectCategory = ObjectCategory_Vertices;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Vertex >> Face")) {
              SOLARCHVISION_convert_Vertex_to_Face();
              Current_ObjectCategory = ObjectCategory_Faces;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Solid >> Group3D")) {
              SOLARCHVISION_convert_Solid_to_Group3D();
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group3D >> Solid")) {
              SOLARCHVISION_convert_Group3D_to_Solid();
              Current_ObjectCategory = ObjectCategory_Solids;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Object2D >> Group3D")) {
              SOLARCHVISION_convert_Object2D_to_Group3D();
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group3D >> Object2D")) {
              SOLARCHVISION_convert_Group3D_to_Object2D();
              Current_ObjectCategory = ObjectCategory_Object2Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Fractal >> Group3D")) {
              SOLARCHVISION_convert_Fractal_to_Group3D();
              Current_ObjectCategory = ObjectCategory_Group3Ds;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group3D >> Fractal")) {
              SOLARCHVISION_convert_Group3D_to_Fractal();
              Current_ObjectCategory = ObjectCategory_Fractals;
              WIN3D_Update = 1;
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Click Select")) {
              SOLARCHVISION_UI_set_to_View_ClickSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±CS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Click Select+")) {
              SOLARCHVISION_UI_set_to_View_ClickSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+CS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Click Select-")) {
              SOLARCHVISION_UI_set_to_View_ClickSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-CS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }            

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Window Select")) {
              SOLARCHVISION_UI_set_to_View_WindowSelect(0);
              SOLARCHVISION_highlight_in_BAR_b("±WS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Window Select+")) {
              SOLARCHVISION_UI_set_to_View_WindowSelect(1);
              SOLARCHVISION_highlight_in_BAR_b("+WS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Window Select-")) {
              SOLARCHVISION_UI_set_to_View_WindowSelect(2);
              SOLARCHVISION_highlight_in_BAR_b("-WS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select Near Vertices Selection")) {
              SOLARCHVISION_selectNearVertices_Selection();
              WIN3D_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Weld Objects Vertices Selection")) {
              SOLARCHVISION_weldObjectsVertices_Selection();
              WIN3D_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Weld Scene Vertices Selection")) {
              SOLARCHVISION_weldSceneVertices_Selection();
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Reposition Vertices Selection")) {
              SOLARCHVISION_repositionVertices_Selection();
              WIN3D_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Separate Vertices Selection")) {
              SOLARCHVISION_separateVertices_Selection();
              WIN3D_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Select All Isolated Vertices")) {
              SOLARCHVISION_selectIsolatedVertices_Scene();
              WIN3D_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Delete All Isolated Vertices")) {
              SOLARCHVISION_deleteIsolatedVertices_Scene();
              WIN3D_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Delete Isolated Vertices Selection")) {
              SOLARCHVISION_deleteIsolatedVertices_Selection();
              WIN3D_Update = 1;
            }              
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Delete All Empty Groups")) {
              SOLARCHVISION_deleteEmptyGroups_Scene();
              WIN3D_Update = 1;
            }               
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Delete Selection")) {
              SOLARCHVISION_delete_Selection();
              WIN3D_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Dettach from Groups")) {
              SOLARCHVISION_dettachFromGroups_Selection();
              WIN3D_Update = 1;
            }                
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Ungroup Selection")) {
              SOLARCHVISION_ungroup_Selection();
              WIN3D_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Group Selection")) {
              SOLARCHVISION_group_Selection(1);
              WIN3D_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Attach to Last Group")) {
              SOLARCHVISION_group_Selection(0);
              WIN3D_Update = 1;
            }                 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Duplicate Selection (Identical)")) {
              SOLARCHVISION_duplicate_Selection(0);
              WIN3D_Update = 1;
            }      
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Duplicate Selection (Variation)")) {
              SOLARCHVISION_duplicate_Selection(1);
              WIN3D_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Insert Corner Opennings")) {
              SOLARCHVISION_inserCornerOpennings_Selection();
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Insert Parallel Opennings")) {
              SOLARCHVISION_insertParallelOpennings_Selection();              
              WIN3D_Update = 1;
            }     
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Insert Rotated Opennings")) {
              SOLARCHVISION_insertRotatedOpennings_Selection();
              WIN3D_Update = 1;
            }       
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Insert Edge Opennings")) {
              SOLARCHVISION_insertEdgeOpennings_Selection();
              WIN3D_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Tessellate Rows & Columns")) {
              SOLARCHVISION_tessellateRowsColumnsFaceSelection();
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Tessellate Rectangular")) {
              SOLARCHVISION_tessellateRectangularFaceSelection();
              WIN3D_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Tessellation Triangular")) {
              SOLARCHVISION_tessellateTriangularFaceSelection();
              WIN3D_Update = 1;
            }            
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Extrude Face Edges")) {
              SOLARCHVISION_extrudeFaceEdges_Selection();
              WIN3D_Update = 1;
            }    
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Offset(above) Vertices")) {
              SOLARCHVISION_offsetVertices_Selection(0, abs(ModifyInput_OffsetAmount));
              WIN3D_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Offset(below) Vertices")) {
              SOLARCHVISION_offsetVertices_Selection(0, -abs(ModifyInput_OffsetAmount));
              WIN3D_Update = 1;
            }             
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Offset(expand) Vertices")) {
              SOLARCHVISION_offsetVertices_Selection(1, -abs(ModifyInput_OffsetAmount));
              WIN3D_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Offset(shrink) Vertices")) {
              SOLARCHVISION_offsetVertices_Selection(1, abs(ModifyInput_OffsetAmount));
              WIN3D_Update = 1;
            }               

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Reverse Visibility of All Faces")) {
              SOLARCHVISION_reverseVisibilityFaces_Scene();
              WIN3D_Update = 1;
            } 
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hide All Faces")) {
              SOLARCHVISION_changeVisibilityFaces_Scene(0);
              WIN3D_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Unhide All Faces")) {
              SOLARCHVISION_changeVisibilityFaces_Scene(1);
              WIN3D_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Hide Selected Faces")) {
              SOLARCHVISION_changeVisibilityFaces_Selection(0);
              WIN3D_Update = 1;
            }  
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Unhide Selected Faces")) {
              SOLARCHVISION_changeVisibilityFaces_Selection(1);
              WIN3D_Update = 1;
            }     
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Isolate Selected Faces")) {
              SOLARCHVISION_isolate_Selection();
              WIN3D_Update = 1;
            }         

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Flatten Selected LandPoints")) {

              SOLARCHVISION_flatten_selectedLandPoints();
              WIN3D_Update = 1;
            }



            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TargetRoll")) {
              SOLARCHVISION_UI_set_to_View_TargetRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("TRL");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TargetRollZ")) {
              SOLARCHVISION_UI_set_to_View_TargetRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("TRLz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TargetRollXY")) {
              SOLARCHVISION_UI_set_to_View_TargetRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("TRLxy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("CameraRoll")) {
              SOLARCHVISION_UI_set_to_View_CameraRoll(0);
              SOLARCHVISION_highlight_in_BAR_b("CRL");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("CameraRollZ")) {
              SOLARCHVISION_UI_set_to_View_CameraRoll(1);
              SOLARCHVISION_highlight_in_BAR_b("CRLz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }                
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("CameraRollXY")) {
              SOLARCHVISION_UI_set_to_View_CameraRoll(2);
              SOLARCHVISION_highlight_in_BAR_b("CRLxy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Orbit")) {
              SOLARCHVISION_UI_set_to_View_Orbit(0);
              SOLARCHVISION_highlight_in_BAR_b("OR");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("OrbitZ")) {
              SOLARCHVISION_UI_set_to_View_Orbit(1);
              SOLARCHVISION_highlight_in_BAR_b("ORz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }           
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("OrbitXY")) {
              SOLARCHVISION_UI_set_to_View_Orbit(2);
              SOLARCHVISION_highlight_in_BAR_b("ORxy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }   

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Pan")) {
              SOLARCHVISION_UI_set_to_View_Pan(0);
              SOLARCHVISION_highlight_in_BAR_b("Pan");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PanX")) {
              SOLARCHVISION_UI_set_to_View_Pan(1);
              SOLARCHVISION_highlight_in_BAR_b("PanX");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PanY")) {
              SOLARCHVISION_UI_set_to_View_Pan(2);
              SOLARCHVISION_highlight_in_BAR_b("PanY");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Zoom")) {
              SOLARCHVISION_UI_set_to_View_ZOOM(0);
              SOLARCHVISION_highlight_in_BAR_b("±ZM");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Zoom as default")) {
              SOLARCHVISION_UI_set_to_View_ZOOM(1);
              SOLARCHVISION_highlight_in_BAR_b("0ZM");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }


            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TruckX")) {
              SOLARCHVISION_UI_set_to_View_Truck(1);
              SOLARCHVISION_highlight_in_BAR_b("DIx");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TruckY")) {
              SOLARCHVISION_UI_set_to_View_Truck(2);
              SOLARCHVISION_highlight_in_BAR_b("DIy");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("TruckZ")) {
              SOLARCHVISION_UI_set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("DIz");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("DistZ")) {
              SOLARCHVISION_UI_set_to_View_Truck(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDZ");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("CameraDistance")) {
              SOLARCHVISION_UI_set_to_View_CameraDistance(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }   
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("DistMouseXY")) {
              SOLARCHVISION_UI_set_to_View_DistMouseXY(0);
              SOLARCHVISION_highlight_in_BAR_b("±CDM");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }  

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Look at origin")) {
              SOLARCHVISION_UI_set_to_View_LookAtOrigin(0);
              SOLARCHVISION_highlight_in_BAR_b("LAO");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Look at selection")) {
              SOLARCHVISION_UI_set_to_View_LookAtSelection(0);
              SOLARCHVISION_highlight_in_BAR_b("LAS");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("3DModelSize")) {
              SOLARCHVISION_UI_set_to_View_3DModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SZ");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }          

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("SkydomeSize")) {
              SOLARCHVISION_UI_set_to_View_SkydomeSize();
              SOLARCHVISION_highlight_in_BAR_b("±SK");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }       

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("AllModelSize")) {
              SOLARCHVISION_UI_set_to_View_AllModelSize();
              SOLARCHVISION_highlight_in_BAR_b("±SA");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }     

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Shrink 3DViewSpace")) {
              SOLARCHVISION_UI_set_to_View_3DViewSpace(0);
              SOLARCHVISION_highlight_in_BAR_b("AllViewsports");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Enlarge 3DViewSpace")) {
              SOLARCHVISION_UI_set_to_View_3DViewSpace(1);
              SOLARCHVISION_highlight_in_BAR_b("Expand3DView");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            } 

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Top")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(0);
              SOLARCHVISION_highlight_in_BAR_b("Top");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Front")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(1);
              SOLARCHVISION_highlight_in_BAR_b("Front");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Left")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(2);
              SOLARCHVISION_highlight_in_BAR_b("Left");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Back")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(3);
              SOLARCHVISION_highlight_in_BAR_b("Back");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Right")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(4);
              SOLARCHVISION_highlight_in_BAR_b("Right");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("Bottom")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(5);
              SOLARCHVISION_highlight_in_BAR_b("Bottom");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("S.W.")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(6);
              SOLARCHVISION_highlight_in_BAR_b("S.W.");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("S.E.")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(7);
              SOLARCHVISION_highlight_in_BAR_b("S.E.");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("N.E.")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(8);
              SOLARCHVISION_highlight_in_BAR_b("N.E.");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("N.W.")) {
              SOLARCHVISION_UI_set_to_View_3DViewPoint(9);
              SOLARCHVISION_highlight_in_BAR_b("N.W.");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotX:Minimum")) {
              SOLARCHVISION_UI_set_to_View_PivotX(-1);
              SOLARCHVISION_highlight_in_BAR_b("X<");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotX:Center")) {
              SOLARCHVISION_UI_set_to_View_PivotX(0);
              SOLARCHVISION_highlight_in_BAR_b("X|");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotX:Maximum")) {
              SOLARCHVISION_UI_set_to_View_PivotX(1);
              SOLARCHVISION_highlight_in_BAR_b("X>");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotY:Minimum")) {
              SOLARCHVISION_UI_set_to_View_PivotY(-1);
              SOLARCHVISION_highlight_in_BAR_b("Y<");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotY:Center")) {
              SOLARCHVISION_UI_set_to_View_PivotY(0);
              SOLARCHVISION_highlight_in_BAR_b("Y|");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotY:Maximum")) {
              SOLARCHVISION_UI_set_to_View_PivotY(1);
              SOLARCHVISION_highlight_in_BAR_b("Y>");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }

            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotZ:Minimum")) {
              SOLARCHVISION_UI_set_to_View_PivotZ(-1);
              SOLARCHVISION_highlight_in_BAR_b("Z<");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotZ:Center")) {
              SOLARCHVISION_UI_set_to_View_PivotZ(0);
              SOLARCHVISION_highlight_in_BAR_b("Z|");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
            if (SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent][SOLARCHVISION_UI_BAR_a_selected_child].equals("PivotZ:Maximum")) {
              SOLARCHVISION_UI_set_to_View_PivotZ(1);
              SOLARCHVISION_highlight_in_BAR_b("Z>");
              SOLARCHVISION_UI_BAR_b_Update = 1;
            }
          }
        }

        SOLARCHVISION_UI_BAR_a_selected_parent = -1;
        SOLARCHVISION_UI_BAR_a_selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);

        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      } else {    

        SOLARCHVISION_X_clicked = mouseX;
        SOLARCHVISION_Y_clicked = mouseY;

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, 0, width, SOLARCHVISION_A_Pixel) == 1) {
          SOLARCHVISION_UI_BAR_a_Update = 1;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_A_Pixel, width, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel) == 1) {
          SOLARCHVISION_UI_BAR_b_Update = 1;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel, width, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + SOLARCHVISION_D_Pixel) == 1) {
          SOLARCHVISION_UI_BAR_d_Update = 1;
        }  

        if (WORLD_Include == 1) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD_CX_View, WORLD_CY_View, WORLD_CX_View + WORLD_X_View, WORLD_CY_View + WORLD_Y_View) == 1) {

            float WORLD_VIEW_OffsetX = WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0] + 180;
            float WORLD_VIEW_OffsetY = WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - 90;

            float WORLD_VIEW_ScaleX = (WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesX[WORLD_VIEW_Number][0]) / 360.0;
            float WORLD_VIEW_ScaleY = (WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][1] - WORLD_VIEW_BoundariesY[WORLD_VIEW_Number][0]) / 180.0;    

            float mouse_lon = 360.0 * ((mouseX - WORLD_CX_View) * WORLD_VIEW_ScaleX / WORLD_X_View - 0.5) + WORLD_VIEW_OffsetX;
            float mouse_lat = -180.0 * ((mouseY - WORLD_CY_View) * WORLD_VIEW_ScaleY / WORLD_Y_View - 0.5) + WORLD_VIEW_OffsetY;
            //float mouse_lon = LocationLongitude;
            //float mouse_lat = LocationLatitude;


            pre_LocationLatitude = LocationLatitude;
            pre_LocationLongitude = LocationLongitude;

            LocationLatitude = mouse_lat;
            LocationLongitude = mouse_lon;

            if (mouseButton == LEFT) {
              WORLD_Viewport_ZOOM = 6;
            }

            if ((pre_LocationLatitude != LocationLatitude) || (pre_LocationLongitude != LocationLongitude)) {
              WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);
            } 



            {
              int nearest_STATION_NAEFS = -1;
              float nearest_STATION_NAEFS_dist = FLOAT_undefined;

              for (int f = 0; f < STATION_NAEFS_INFO.length; f += 1) {

                float _lat = float(STATION_NAEFS_INFO[f][3]);
                float _lon = float(STATION_NAEFS_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

                if (nearest_STATION_NAEFS_dist > d) {
                  nearest_STATION_NAEFS_dist = d;
                  nearest_STATION_NAEFS = f;
                }
              }

              {
                int f = nearest_STATION_NAEFS;

                if (Defined_Stations[STATION_Number][8].equals(STATION_NAEFS_INFO[f][6])) {
                } else {

                  STATION_Number = 0; // <<<<<<<<<< overwrite station 0

                  Defined_Stations[STATION_Number][3] = nf(mouse_lat, 0, 0);                
                  Defined_Stations[STATION_Number][4] = nf(mouse_lon, 0, 0); 

                  Defined_Stations[STATION_Number][8] = STATION_NAEFS_INFO[f][6]; // naefs filename

                  println("nearest naefs filename:", STATION_NAEFS_INFO[f][6]);    

                  STATION_Selected = STATION_Number;

                  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
                    Defined_Stations[STATION_Number][0] = STATION_NAEFS_INFO[f][0];
                    Defined_Stations[STATION_Number][1] = STATION_NAEFS_INFO[f][1];
                    Defined_Stations[STATION_Number][2] = STATION_NAEFS_INFO[f][2];

                    //Defined_Stations[STATION_Number][3] = STATION_NAEFS_INFO[f][3];
                    //Defined_Stations[STATION_Number][4] = STATION_NAEFS_INFO[f][4];
                    Defined_Stations[STATION_Number][5] = nf(roundTo(float(STATION_NAEFS_INFO[f][2]), 15), 0, 0);                      

                    SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][1] = Defined_Stations[STATION_Number][0]; // <<<<<<<<

                    SOLARCHVISION_ROLLOUT_parent = 0;
                    SOLARCHVISION_ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;


                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);
                  }
                }
              }
            }        


            {
              int nearest_STATION_CWEEDS = -1;
              float nearest_STATION_CWEEDS_dist = FLOAT_undefined;

              for (int f = 0; f < STATION_CWEEDS_INFO.length; f += 1) {

                float _lat = float(STATION_CWEEDS_INFO[f][3]);
                float _lon = float(STATION_CWEEDS_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

                if (nearest_STATION_CWEEDS_dist > d) {
                  nearest_STATION_CWEEDS_dist = d;
                  nearest_STATION_CWEEDS = f;
                }
              }

              {
                int f = nearest_STATION_CWEEDS;

                if (Defined_Stations[STATION_Number][9].equals(STATION_CWEEDS_INFO[f][6])) {
                } else {

                  STATION_Number = 0; // <<<<<<<<<< overwrite station 0

                  Defined_Stations[STATION_Number][3] = nf(mouse_lat, 0, 0);                
                  Defined_Stations[STATION_Number][4] = nf(mouse_lon, 0, 0); 

                  Defined_Stations[STATION_Number][9] = STATION_CWEEDS_INFO[f][6]; // CWEEDS filename

                  println("nearest CWEEDS filename:", STATION_CWEEDS_INFO[f][6]);       

                  STATION_Selected = STATION_Number;

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) { 

                    Defined_Stations[STATION_Number][0] = STATION_CWEEDS_INFO[f][0];
                    Defined_Stations[STATION_Number][1] = STATION_CWEEDS_INFO[f][1];
                    Defined_Stations[STATION_Number][2] = STATION_CWEEDS_INFO[f][2]; 

                    //Defined_Stations[STATION_Number][3] = STATION_CWEEDS_INFO[f][3];
                    //Defined_Stations[STATION_Number][4] = STATION_CWEEDS_INFO[f][4];
                    Defined_Stations[STATION_Number][5] = STATION_CWEEDS_INFO[f][6]; 
                    Defined_Stations[STATION_Number][6] = STATION_CWEEDS_INFO[f][5];   

                    SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][1] = Defined_Stations[STATION_Number][0]; // <<<<<<<<

                    SOLARCHVISION_ROLLOUT_parent = 0;
                    SOLARCHVISION_ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;

                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_CLIMATE_CWEEDS();
                  }
                }
              }
            }          

            {
              int nearest_STATION_CLMREC = -1;
              float nearest_STATION_CLMREC_dist = FLOAT_undefined;

              for (int f = 0; f < STATION_CLMREC_INFO.length; f += 1) {
                
                if (int(STATION_CLMREC_INFO[f][10]) == 2016) { // only use stations with this condition

                  float _lat = float(STATION_CLMREC_INFO[f][3]);
                  float _lon = float(STATION_CLMREC_INFO[f][4]); 
                  if (_lon > 180) _lon -= 360; // << important!
  
                  float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);
  
                  if (nearest_STATION_CLMREC_dist > d) {
                    nearest_STATION_CLMREC_dist = d;
                    nearest_STATION_CLMREC = f;
                  }
                }
              }

              {
                int f = nearest_STATION_CLMREC;

                if (Defined_Stations[STATION_Number][9].equals(STATION_CLMREC_INFO[f][6])) {
                } else {

                  STATION_Number = 0; // <<<<<<<<<< overwrite station 0

                  Defined_Stations[STATION_Number][3] = nf(mouse_lat, 0, 0);                
                  Defined_Stations[STATION_Number][4] = nf(mouse_lon, 0, 0); 

                  Defined_Stations[STATION_Number][9] = STATION_CLMREC_INFO[f][6]; // CLMREC filename

                  println("nearest CLMREC filename:", STATION_CLMREC_INFO[f][6]);       

                  STATION_Selected = STATION_Number;

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) { 

                    Defined_Stations[STATION_Number][0] = STATION_CLMREC_INFO[f][0];
                    Defined_Stations[STATION_Number][1] = STATION_CLMREC_INFO[f][1];
                    Defined_Stations[STATION_Number][2] = STATION_CLMREC_INFO[f][2]; 

                    //Defined_Stations[STATION_Number][3] = STATION_CLMREC_INFO[f][3];
                    //Defined_Stations[STATION_Number][4] = STATION_CLMREC_INFO[f][4];
                    Defined_Stations[STATION_Number][5] = STATION_CLMREC_INFO[f][6]; 
                    Defined_Stations[STATION_Number][6] = STATION_CLMREC_INFO[f][5];   

                    SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][1] = Defined_Stations[STATION_Number][0]; // <<<<<<<<

                    SOLARCHVISION_ROLLOUT_parent = 0;
                    SOLARCHVISION_ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;

                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_CLIMATE_CLMREC();
                  }
                }
              }
            }          


            {
              int nearest_STATION_TMYEPW = -1;
              float nearest_STATION_TMYEPW_dist = FLOAT_undefined;

              for (int f = 0; f < STATION_TMYEPW_INFO.length; f += 1) {

                float _lat = float(STATION_TMYEPW_INFO[f][3]);
                float _lon = float(STATION_TMYEPW_INFO[f][4]); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = dist_lon_lat(_lon, _lat, LocationLongitude, LocationLatitude);

                if (nearest_STATION_TMYEPW_dist > d) {
                  nearest_STATION_TMYEPW_dist = d;
                  nearest_STATION_TMYEPW = f;
                }
              }

              {
                int f = nearest_STATION_TMYEPW;

                if (Defined_Stations[STATION_Number][10].equals(STATION_TMYEPW_INFO[f][8])) {
                } else {

                  STATION_Number = 0; // <<<<<<<<<< overwrite station 0

                  Defined_Stations[STATION_Number][3] = nf(mouse_lat, 0, 0);                
                  Defined_Stations[STATION_Number][4] = nf(mouse_lon, 0, 0); 

                  Defined_Stations[STATION_Number][10] = STATION_TMYEPW_INFO[f][8]; // epw filename

                  println("nearest epw filename:", STATION_TMYEPW_INFO[f][8]);       

                  STATION_Selected = STATION_Number;

                  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {     
                    Defined_Stations[STATION_Number][0] = STATION_TMYEPW_INFO[f][0];
                    Defined_Stations[STATION_Number][1] = STATION_TMYEPW_INFO[f][1];
                    Defined_Stations[STATION_Number][2] = STATION_TMYEPW_INFO[f][2]; 

                    //Defined_Stations[STATION_Number][3] = STATION_TMYEPW_INFO[f][3];
                    //Defined_Stations[STATION_Number][4] = STATION_TMYEPW_INFO[f][4];
                    Defined_Stations[STATION_Number][5] = STATION_TMYEPW_INFO[f][6]; 
                    Defined_Stations[STATION_Number][6] = STATION_TMYEPW_INFO[f][5];    

                    SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][1] = Defined_Stations[STATION_Number][0]; // <<<<<<<<

                    SOLARCHVISION_ROLLOUT_parent = 0;
                    SOLARCHVISION_ROLLOUT_child = 1;
                    ROLLOUT_Update = 1;

                    SOLARCHVISION_update_station(1);
                    SOLARCHVISION_try_update_CLIMATE_TMYEPW();
                  }
                }
              }
            }          




            WORLD_Update = 1;
          }
        }

        if (WIN3D_Include == 1) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D_CX_View, WIN3D_CY_View, WIN3D_CX_View + WIN3D_X_View, WIN3D_CY_View + WIN3D_Y_View) == 1) {

            float Image_X = 0;
            float Image_Y = 0;

            Image_X = SOLARCHVISION_X_clicked - (WIN3D_CX_View + 0.5 * WIN3D_X_View);
            Image_Y = SOLARCHVISION_Y_clicked - (WIN3D_CY_View + 0.5 * WIN3D_Y_View);

            float[] ray_direction = new float [3];

            float[] ray_start = {
              WIN3D_CAM_x, WIN3D_CAM_y, WIN3D_CAM_z
            };

            float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

            ray_start[0] /= OBJECTS_scale;
            ray_start[1] /= OBJECTS_scale;
            ray_start[2] /= OBJECTS_scale;          

            ray_end[0] /= OBJECTS_scale;
            ray_end[1] /= OBJECTS_scale;
            ray_end[2] /= OBJECTS_scale;

            if (WIN3D_ViewType == 0) {
              float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

              ray_center[0] /= OBJECTS_scale;
              ray_center[1] /= OBJECTS_scale;
              ray_center[2] /= OBJECTS_scale;

              ray_start[0] += ray_end[0] - ray_center[0];
              ray_start[1] += ray_end[1] - ray_center[1];
              ray_start[2] += ray_end[2] - ray_center[2];
            }

            ray_direction[0] = ray_end[0] - ray_start[0];
            ray_direction[1] = ray_end[1] - ray_start[1];
            ray_direction[2] = ray_end[2] - ray_start[2];

            float[] RxP = new float [8];

            if (mouseButton == RIGHT) {
              RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
            } else if (mouseButton == LEFT) {

              if ((WIN3D_UI_CurrentTask == 0) || (WIN3D_UI_CurrentTask == 1)) {
                RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
              } else {

                if (Current_ObjectCategory == ObjectCategory_Cameras) {
                  RxP = SOLARCHVISION_9Dintersect(ray_start, ray_direction);
                } else if (Current_ObjectCategory == ObjectCategory_Sections) {
                  RxP = SOLARCHVISION_8Dintersect(ray_start, ray_direction);
                } else if (Current_ObjectCategory == ObjectCategory_Solids) {
                  RxP = SOLARCHVISION_7Dintersect(ray_start, ray_direction);
                } else if (Current_ObjectCategory == ObjectCategory_Fractals) {
                  RxP = SOLARCHVISION_1Dintersect(ray_start, ray_direction);
                } else if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
                  RxP = SOLARCHVISION_2Dintersect(ray_start, ray_direction);
                } else {
                  RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
                }
              }
            }


            //println(ray_start[0], ray_start[1], ray_start[2], ">>", ray_end[0], ray_end[1], ray_end[2], ">>", RxP[1], RxP[2], RxP[3], RxP[4], RxP[0]);

            if (RxP[0] > 0) {

              if (WIN3D_UI_CurrentTask == 1) { // move

                float x1 = FLOAT_undefined;
                float y1 = FLOAT_undefined;
                float z1 = FLOAT_undefined;

                if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

                  float[] P = SOLARCHVISION_getPivot();

                  x1 = P[0];
                  y1 = P[1];
                  z1 = P[2];
                }

                if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

                  x1 = allObject2Ds_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][0]; 
                  y1 = allObject2Ds_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][1]; 
                  z1 = allObject2Ds_XYZS[selectedObject2D_numbers[selectedObject2D_numbers.length - 1]][2];
                }

                if (Current_ObjectCategory == ObjectCategory_Fractals) {

                  x1 = allFractals_XYZSR[selectedFractal_numbers[selectedFractal_numbers.length - 1]][0]; 
                  y1 = allFractals_XYZSR[selectedFractal_numbers[selectedFractal_numbers.length - 1]][1]; 
                  z1 = allFractals_XYZSR[selectedFractal_numbers[selectedFractal_numbers.length - 1]][2];
                }            

                if (Current_ObjectCategory == ObjectCategory_Solids) {

                  x1 = allSolids_DEF[selectedSolid_numbers[selectedSolid_numbers.length - 1]][0]; 
                  y1 = allSolids_DEF[selectedSolid_numbers[selectedSolid_numbers.length - 1]][1]; 
                  z1 = allSolids_DEF[selectedSolid_numbers[selectedSolid_numbers.length - 1]][2];
                }                 

                if (Current_ObjectCategory == ObjectCategory_Vertices) {

                  x1 = allVertices[selectedVertex_numbers[selectedVertex_numbers.length - 1]][0]; 
                  y1 = allVertices[selectedVertex_numbers[selectedVertex_numbers.length - 1]][1]; 
                  z1 = allVertices[selectedVertex_numbers[selectedVertex_numbers.length - 1]][2];
                }             

                if ((x1 != FLOAT_undefined) && (y1 != FLOAT_undefined) && (z1 != FLOAT_undefined)) {       

                  float x2 = RxP[1];
                  float y2 = RxP[2];
                  float z2 = RxP[3];

                  float[] p = SOLARCHVISION_translateOutside_ReferencePivot(x2, y2, z2);

                  float dx = p[0] - x1; 
                  float dy = p[1] - y1;
                  float dz = p[2] - z1;

                  int the_Vector = selected_posVector;

                  if (the_Vector == 0) {
                    dy = 0; 
                    dz = 0;
                  }  
                  if (the_Vector == 1) {
                    dz = 0; 
                    dx = 0;
                  }  
                  if (the_Vector == 2) {
                    dx = 0; 
                    dy = 0;
                  } 

                  SOLARCHVISION_move_Selection(dx, dy, dz);

                  println("SOLARCHVISION_calculate_selection_BoundingBox 10");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                  WIN3D_Update = 1;
                }
              }   




              if (mouseButton == LEFT) { // modify should work only with left click because the right click returns the land info, not objects info

                if ((WIN3D_UI_TaskModifyParameter != 0) && (WIN3D_UI_CurrentTask >= 4)) { // Pick/Assign properties 

                  if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces)) {

                    int f = int(RxP[0]);

                    if ((WIN3D_UI_CurrentTask == 4) || (WIN3D_UI_CurrentTask == 5) || (WIN3D_UI_CurrentTask == 6) || (WIN3D_UI_CurrentTask == 7)) {

                      if (WIN3D_UI_TaskModifyParameter == 1) { // Pick 
                        if (WIN3D_UI_CurrentTask == 4) DEFAULT_CreateMaterial = allFaces_MTLV[f][0];
                        if (WIN3D_UI_CurrentTask == 5) DEFAULT_CreateTessellation = allFaces_MTLV[f][1];
                        if (WIN3D_UI_CurrentTask == 6) DEFAULT_CreateLayer = allFaces_MTLV[f][2];
                        if (WIN3D_UI_CurrentTask == 7) DEFAULT_CreateVisibility = allFaces_MTLV[f][3];
                      } 
                      if (WIN3D_UI_TaskModifyParameter == 2) { // Assign(sub) 
                        if (WIN3D_UI_CurrentTask == 4) allFaces_MTLV[f][0] = DEFAULT_CreateMaterial;
                        if (WIN3D_UI_CurrentTask == 5) allFaces_MTLV[f][1] = DEFAULT_CreateTessellation;
                        if (WIN3D_UI_CurrentTask == 6) allFaces_MTLV[f][2] = DEFAULT_CreateLayer;
                        if (WIN3D_UI_CurrentTask == 7) allFaces_MTLV[f][3] = DEFAULT_CreateVisibility;
                      }
                      if (WIN3D_UI_TaskModifyParameter == 3) { // Assign(all) 
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allGroup3Ds_num + 1; i++) {
                          if ((allGroup3Ds_Faces[i][0] <= f) && (f <= allGroup3Ds_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {
                          for (int q = allGroup3Ds_Faces[OBJ_NUM][0]; q <= allGroup3Ds_Faces[OBJ_NUM][1]; q++) {                    
                            if (WIN3D_UI_CurrentTask == 4) allFaces_MTLV[q][0] = DEFAULT_CreateMaterial;
                            if (WIN3D_UI_CurrentTask == 5) allFaces_MTLV[q][1] = DEFAULT_CreateTessellation;
                            if (WIN3D_UI_CurrentTask == 6) allFaces_MTLV[q][2] = DEFAULT_CreateLayer;
                            if (WIN3D_UI_CurrentTask == 7) allFaces_MTLV[q][3] = DEFAULT_CreateVisibility;
                          }
                        }
                      }
                    }

                    if (WIN3D_UI_CurrentTask == 14) {
                      if (WIN3D_UI_TaskModifyParameter == 1) { // Pick 
                        //?????????????????????????????????????????????????
                      }     
                      if (WIN3D_UI_TaskModifyParameter == 2) { // Assign
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allGroup3Ds_num + 1; i++) {
                          if ((allGroup3Ds_Faces[i][0] <= f) && (f <= allGroup3Ds_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {

                          float[] P = SOLARCHVISION_getPivot();

                          allGroup3Ds_PivotXYZ[OBJ_NUM][0] = P[0];
                          allGroup3Ds_PivotXYZ[OBJ_NUM][1] = P[1];
                          allGroup3Ds_PivotXYZ[OBJ_NUM][2] = P[2];

                          //zzzzzzzzzzzzzzzzzzz should add other components?
                        }
                      }
                    }

                    if (WIN3D_UI_CurrentTask == 15) { //FaceNormal

                      if (Current_ObjectCategory == ObjectCategory_Faces) {

                        selectedFace_numbers = new int [2];
                        selectedFace_numbers[0] = 0;
                        selectedFace_numbers[1] = f;       

                        selectedFace_displayVertexCount = 1;                 

                        int n = allFaces_PNT[f].length;

                        if (n > 2) {
                          int[] tmpFace = new int[n];
                          float[] G = {
                            0, 0, 0
                          }; 
                          for (int j = 0; j < n; j++) {
                            tmpFace[j] = allFaces_PNT[f][j];
                            G[0] += allVertices[tmpFace[j]][0] / float(n); 
                            G[1] += allVertices[tmpFace[j]][1] / float(n);
                            G[2] += allVertices[tmpFace[j]][2] / float(n);
                          }  

                          int flip_face = 0;
                          if (WIN3D_UI_TaskModifyParameter == 1) flip_face = 1;
                          else {
                            PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                            PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);

                            PVector GAxGB = AG.cross(BG);

                            float[] P = SOLARCHVISION_getPivot();

                            float x0 = P[0];
                            float y0 = P[1];
                            float z0 = P[2];                            

                            PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                            float V = PG.dot(GAxGB); 

                            if (WIN3D_UI_TaskModifyParameter == 2) {
                              if (V > 0) flip_face = 1;
                            }
                            if (WIN3D_UI_TaskModifyParameter == 3) {
                              if (V < 0) flip_face = 1;
                            }
                          }

                          if (flip_face == 1) {
                            for (int j = 0; j < n; j++) {
                              allFaces_PNT[f][j] = tmpFace[n - j - 1];
                            }
                          }
                        }
                      }

                      if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
                        int OBJ_NUM = 0;
                        for (int i = 0; i < allGroup3Ds_num + 1; i++) {
                          if ((allGroup3Ds_Faces[i][0] <= f) && (f <= allGroup3Ds_Faces[i][1])) {
                            OBJ_NUM = i;
                            break;
                          }
                        }
                        if (OBJ_NUM != 0) {         
                          for (int q = allGroup3Ds_Faces[OBJ_NUM][0]; q <= allGroup3Ds_Faces[OBJ_NUM][1]; q++) {                    
                            int n = allFaces_PNT[q].length;

                            if (n > 2) {
                              int[] tmpFace = new int[n];
                              float[] G = {
                                0, 0, 0
                              }; 
                              for (int j = 0; j < n; j++) {
                                tmpFace[j] = allFaces_PNT[q][j];
                                G[0] += allVertices[tmpFace[j]][0] / float(n); 
                                G[1] += allVertices[tmpFace[j]][1] / float(n);
                                G[2] += allVertices[tmpFace[j]][2] / float(n);
                              }  

                              int flip_face = 0;
                              if (WIN3D_UI_TaskModifyParameter == 1) flip_face = 1;
                              else {
                                PVector AG = new PVector(allVertices[tmpFace[0]][0] - G[0], allVertices[tmpFace[0]][1] - G[1], allVertices[tmpFace[0]][2] - G[2]);                       
                                PVector BG = new PVector(allVertices[tmpFace[1]][0] - G[0], allVertices[tmpFace[1]][1] - G[1], allVertices[tmpFace[1]][2] - G[2]);

                                PVector GAxGB = AG.cross(BG);

                                float[] P = SOLARCHVISION_getPivot();

                                float x0 = P[0];
                                float y0 = P[1];
                                float z0 = P[2];                                

                                PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                                float V = PG.dot(GAxGB); 

                                if (WIN3D_UI_TaskModifyParameter == 2) {
                                  if (V > 0) flip_face = 1;
                                }
                                if (WIN3D_UI_TaskModifyParameter == 3) {
                                  if (V < 0) flip_face = 1;
                                }
                              }

                              if (flip_face == 1) {
                                for (int j = 0; j < n; j++) {
                                  allFaces_PNT[q][j] = tmpFace[n - j - 1];
                                }
                              }
                            }
                          }
                        }
                      }
                    }   


                    if (WIN3D_UI_CurrentTask == 16) { //FaceFirstVertex

                      if (Current_ObjectCategory == ObjectCategory_Faces) {

                        selectedFace_numbers = new int [2];
                        selectedFace_numbers[0] = 0;
                        selectedFace_numbers[1] = f;

                        selectedFace_displayVertexCount = 1;

                        int n = allFaces_PNT[f].length;

                        if (n > 2) {

                          int min_num = 0;
                          float min_dist = FLOAT_undefined;

                          for (int j = 0; j < n; j++) {
                            int vNo = allFaces_PNT[f][j];

                            float d = dist(RxP[1], RxP[2], RxP[3], allVertices[vNo][0], allVertices[vNo][1], allVertices[vNo][2]);

                            if (min_dist > d) {
                              min_dist = d;
                              min_num = j;
                            }
                          }

                          int[] tmpFace = new int[n];
                          for (int j = 0; j < n; j++) {
                            tmpFace[j] = allFaces_PNT[f][j];
                          }  

                          for (int j = 0; j < n; j++) {
                            allFaces_PNT[f][j] = tmpFace[(j + min_num + n) % n];
                          }
                        }
                      }
                    }
                  } 










                  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

                    int OBJ_NUM = int(RxP[0]);

                    int n = allObject2Ds_MAP[OBJ_NUM];
                    int sign_n = 1;
                    if (n < 0) sign_n = -1;
                    n = abs(n);
                    int n1 = Object2D_PEOPLE_Files_Num;
                    int n2 = Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num;

                    if (WIN3D_UI_CurrentTask == 4) {

                      if (WIN3D_UI_TaskModifyParameter == 1) { // Pick 
                        if (n <= n1) { // case: people 
                          CreatePerson_Type = n;
                        } else { // case: trees
                          CreatePlant_Type = n - n1;
                        }
                      } 
                      if ((WIN3D_UI_TaskModifyParameter == 2) || (WIN3D_UI_TaskModifyParameter == 3)) { // Assign
                        if (n <= n1) { // case: people 
                          allObject2Ds_MAP[OBJ_NUM] = sign_n * CreatePerson_Type;
                        } else { // case: trees
                          allObject2Ds_MAP[OBJ_NUM] = sign_n * (CreatePlant_Type + n1);
                        }
                      }
                    }
                  }      


                  if (Current_ObjectCategory == ObjectCategory_Fractals) {

                    int OBJ_NUM = int(RxP[0]);

                    if (WIN3D_UI_TaskModifyParameter == 1) { // Pick 
                      if (WIN3D_UI_CurrentTask == 8) CreateFractal_DegreeMax = allFractals_DegreeMax[OBJ_NUM];
                      if (WIN3D_UI_CurrentTask == 9) {
                        CreateFractal_DegreeMax = allFractals_DegreeMax[OBJ_NUM]; 
                        CreateFractal_DegreeMin = allFractals_DegreeMin[OBJ_NUM];
                      }
                      if (WIN3D_UI_CurrentTask == 10) CreateFractal_DegreeMin = allFractals_DegreeMin[OBJ_NUM];
                      if (WIN3D_UI_CurrentTask == 11) CreateFractal_TrunkSize = allFractals_TrunkSize[OBJ_NUM];
                      if (WIN3D_UI_CurrentTask == 12) CreateFractal_LeafSize = allFractals_LeafSize[OBJ_NUM];
                      if (WIN3D_UI_CurrentTask == 13) { // all properties
                        CreateFractal_DegreeMax = allFractals_DegreeMax[OBJ_NUM];
                        CreateFractal_DegreeMin = allFractals_DegreeMin[OBJ_NUM];
                        CreateFractal_TrunkSize = allFractals_TrunkSize[OBJ_NUM];
                        CreateFractal_LeafSize = allFractals_LeafSize[OBJ_NUM];
                      }
                    } 
                    if (WIN3D_UI_TaskModifyParameter == 2) { //Assign
                      if (WIN3D_UI_CurrentTask == 8) allFractals_DegreeMax[OBJ_NUM] = CreateFractal_DegreeMax;                    
                      if (WIN3D_UI_CurrentTask == 9) {
                        allFractals_DegreeMax[OBJ_NUM] = CreateFractal_DegreeMax; 
                        allFractals_DegreeMin[OBJ_NUM] = CreateFractal_DegreeMin;
                      }                 
                      if (WIN3D_UI_CurrentTask == 10) allFractals_DegreeMin[OBJ_NUM] = CreateFractal_DegreeMin;                    
                      if (WIN3D_UI_CurrentTask == 11) allFractals_TrunkSize[OBJ_NUM] = CreateFractal_TrunkSize;                    
                      if (WIN3D_UI_CurrentTask == 12) allFractals_LeafSize[OBJ_NUM] = CreateFractal_LeafSize;
                      if (WIN3D_UI_CurrentTask == 13) { // all properties
                        allFractals_DegreeMax[OBJ_NUM] = CreateFractal_DegreeMax;
                        allFractals_DegreeMin[OBJ_NUM] = CreateFractal_DegreeMin;                    
                        allFractals_TrunkSize[OBJ_NUM] = CreateFractal_TrunkSize;                    
                        allFractals_LeafSize[OBJ_NUM] = CreateFractal_LeafSize;
                      }
                    }
                  }                        

                  WIN3D_Update = 1;                 
                  ROLLOUT_Update = 1;
                } else if ((WIN3D_UI_CurrentTask != 0) && (WIN3D_UI_CurrentTask != 1)) { // PickSelect also if scale, rotate, modify, etc. where selected

                  SOLARCHVISION_PickSelect(RxP);
                }
              }

              if (WIN3D_UI_CurrentTask == 0) { // create

                int keep_number_of_Group3Ds = allGroup3Ds_num + 1;
                int keep_number_of_Object2Ds = allObject2Ds_num + 1;
                int keep_number_of_Fractals = allFractals_num + 1;
                int keep_number_of_Solids = allSolids_DEF.length;
                int keep_number_of_Sections = allSections_num + 1;
                int keep_number_of_Cameras = allCameras_num + 1;

                float x = RxP[1]; 
                float y = RxP[2]; 
                float z = RxP[3];             

                float rot = CreateInput_Orientation;
                if (rot == 360) rot = WIN3D_RZ_Coordinate;



                float rx = 0.5 * CreateInput_Length;
                if (rx < 0) rx = random(0.25 * abs(rx), abs(rx));

                float ry = 0.5 * CreateInput_Width;
                if (ry < 0) ry = random(0.25 * abs(ry), abs(ry));

                float rz = 0.5 * CreateInput_Height;
                if (rz < 0) rz = random(0.25 * abs(rz), abs(rz));



                float px = CreateInput_powX; 
                float py = CreateInput_powY;
                float pz = CreateInput_powZ;

                if (CreateInput_powRnd == 1) {
                  px = pow(2, int(random(5)) - 1);
                  py = px;
                  pz = px;
                }

                if (CreateInput_Volume != 0) {

                  if ((rx != 0) && (ry != 0)) {
                    rz = CreateInput_Volume / (8 * rx * ry);
                  }

                  //---------------------------------------------------
                  float A = 1; 
                  // cube volume: 8*r^3, sphere volume: 4*r^3, so maybe:
                  if (pz >= 8) A = 1;
                  else if (pz == 4) A = 0.75;
                  else if (pz == 2) A = 0.5;
                  else if (pz == 1) A = 0.25;
                  else if (pz == 0.5) A = 0.125;
                  else if (pz == 0.25) A = 0.0625;

                  rx /= pow(A, (1.0 / 3.0));
                  ry /= pow(A, (1.0 / 3.0));
                  rz /= pow(A, (1.0 / 3.0));
                  //---------------------------------------------------
                }


                if ((Current_ObjectCategory != ObjectCategory_Fractals) && (Current_ObjectCategory != ObjectCategory_Object2Ds) && (Current_ObjectCategory != ObjectCategory_LandPoint) && (Current_ObjectCategory != ObjectCategory_Cameras) && (Current_ObjectCategory != ObjectCategory_Sections)) {

                  x -= rx * selection_alignX;
                  y -= ry * selection_alignY;
                  z -= rz * selection_alignZ;
                }



                if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Solids) || (Current_ObjectCategory == ObjectCategory_Fractals) || (Current_ObjectCategory == ObjectCategory_Object2Ds)) {

                  if (addToLastGroup3D == 0) {

                    SOLARCHVISION_beginNewGroup3D(x, y, z, 1, 1, 1, 0, 0, rot);
                  }
                }


                if (Current_ObjectCategory == ObjectCategory_Group3Ds) { // working with meshes
  
                  if (CreateButton_3DSuperOBJ == 1) {
  
                    if ((px == CubePower) && (py == CubePower) && (pz == 2)) {
  
                      SOLARCHVISION_add_ParametricSurface(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, 2, rot);
                    } else if ((px == 2) && (py == 2) && (pz == CubePower)) {
  
                      SOLARCHVISION_add_SuperCylinder(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, CreateInput_CylinderDegree, rot);
                    } else if ((px == CubePower) && (py == CubePower) && (pz == CubePower)) {
  
                      SOLARCHVISION_add_Box_Core(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, rot);
                    } else if ((px == 1) && (py == 1) && (pz == 1)) {
  
                      SOLARCHVISION_add_Octahedron(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, rot);
                    } else {
  
                      SOLARCHVISION_add_SuperSphere(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, pz, py, pz, rx, ry, rz, CreateInput_SphereDegree, rot);
                    }
  
  
  
  
                    if (CreateInput_MeshOrSolid == 1) {
  
                      SOLARCHVISION_add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                    }
                  }
  

  
                  if (CreateButton_3DTri == 1) {
  
                    SOLARCHVISION_add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x-rx, y-ry, z-rz, x+rx, y-ry, z-rz, x, y, z+rz);
                    SOLARCHVISION_add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x+rx, y-ry, z-rz, x+rx, y+ry, z-rz, x, y, z+rz);
                    SOLARCHVISION_add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x+rx, y+ry, z-rz, x-rx, y+ry, z-rz, x, y, z+rz);
                    SOLARCHVISION_add_Mesh3(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x-rx, y+ry, z-rz, x-rx, y-ry, z-rz, x, y, z+rz);
                  }
  
                  if (CreateButton_3DQuad == 1) {
  
                    SOLARCHVISION_add_Mesh4(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x-rx, y-ry, z-rz, x+rx, y-ry, z+rz, x+rx, y+ry, z-rz, x-rx, y+ry, z+rz);
                  }
  
                  if (CreateButton_3DPoly == 1) {
  
                    SOLARCHVISION_add_PolygonHyper(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, 2 * rz, CreateInput_PolyDegree, rot);
                  }
  
                  if (CreateButton_3DExtrude == 1) {       
  
                    SOLARCHVISION_add_PolygonExtrude(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, 2 * rz, CreateInput_PolyDegree, rot);
                  }
  
                  if (CreateButton_3DHouse == 1) {   
  
                    SOLARCHVISION_add_House_Core(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, ry, rot);
                  }
  
                  if (CreateButton_3DParametric != 0) {
  
                    SOLARCHVISION_add_ParametricSurface(DEFAULT_CreateMaterial, DEFAULT_CreateTessellation, DEFAULT_CreateLayer, DEFAULT_CreateVisibility, DEFAULT_CreateExtraType, x, y, z, rx, ry, rz, CreateParametric_Type, rot);
                  }
                }

                if (Current_ObjectCategory == ObjectCategory_Object2Ds) { // working with object2Ds
                  if (CreateButton_2DPerson != 0) {
  
                    randomSeed(millis());
                    SOLARCHVISION_add_Object2D_single("PEOPLE", CreatePerson_Type, x, y, z, 2.5);
                  }
  
                  if (CreateButton_2DPlant != 0) {
                    int n = 0;
                    if (CreatePlant_Type > 0) n = CreatePlant_Type + Object2D_PEOPLE_Files_Num;
  
                    randomSeed(millis());
                    SOLARCHVISION_add_Object2D_single("TREES", n, x, y, z, 2 * rz);
                  }
                }    
                
                if (Current_ObjectCategory == ObjectCategory_Fractals) { // working with fractals
                  if (CreateButton_Fractal != 0) {

                    randomSeed(millis());
                    SOLARCHVISION_add_Fractal(CreateFractal_Type, x, y, z, 2 * rz, rot, CreateFractal_DegreeMin, CreateFractal_DegreeMax, CreateFractal_Seed, CreateFractal_TrunkSize, CreateFractal_LeafSize);
                  }        
                }


                if (Current_ObjectCategory == ObjectCategory_Solids) { // working with solids

                    SOLARCHVISION_add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                }        


                if (Current_ObjectCategory == ObjectCategory_Cameras) { // working with cameras              

                    int f = int(RxP[0]);

                  float keep_CAM_x = WIN3D_CAM_x;
                  float keep_CAM_y = WIN3D_CAM_y;
                  float keep_CAM_z = WIN3D_CAM_z;
                  float keep_WIN3D_X_Coordinate = WIN3D_X_Coordinate; 
                  float keep_WIN3D_Y_Coordinate = WIN3D_Y_Coordinate;
                  float keep_WIN3D_Z_Coordinate = WIN3D_Z_Coordinate;
                  float keep_WIN3D_S_Coordinate = WIN3D_S_Coordinate;
                  float keep_WIN3D_RX_Coordinate = WIN3D_RX_Coordinate; 
                  float keep_WIN3D_RY_Coordinate = WIN3D_RY_Coordinate;
                  float keep_WIN3D_RZ_Coordinate = WIN3D_RZ_Coordinate;
                  float keep_WIN3D_Zoom = WIN3D_Zoom;

                  {

                    WIN3D_CAM_x = RxP[1];
                    WIN3D_CAM_y = RxP[2];
                    WIN3D_CAM_z = RxP[3] + EyeLevel;       

                    SOLARCHVISION_reverseTransform_3DViewport();

                    float Camera_X = WIN3D_X_Coordinate;
                    float Camera_Y = WIN3D_Y_Coordinate;
                    float Camera_Z = WIN3D_Z_Coordinate;
                    float Camera_S = WIN3D_S_Coordinate;
                    float Camera_RX = WIN3D_RX_Coordinate;
                    float Camera_RY = WIN3D_RY_Coordinate;
                    float Camera_RZ = WIN3D_RZ_Coordinate;
                    float Camera_ZOOM = WIN3D_Zoom;

                    int Camera_Type = WIN3D_ViewType;

                    SOLARCHVISION_add_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

                    WIN3D_Update = 1;
                  }  

                  WIN3D_CAM_x = keep_CAM_x;
                  WIN3D_CAM_y = keep_CAM_y;
                  WIN3D_CAM_z = keep_CAM_z;
                  WIN3D_X_Coordinate = keep_WIN3D_X_Coordinate; 
                  WIN3D_Y_Coordinate = keep_WIN3D_Y_Coordinate;
                  WIN3D_Z_Coordinate = keep_WIN3D_Z_Coordinate;
                  WIN3D_S_Coordinate = keep_WIN3D_S_Coordinate;
                  WIN3D_RX_Coordinate = keep_WIN3D_RX_Coordinate; 
                  WIN3D_RY_Coordinate = keep_WIN3D_RY_Coordinate;
                  WIN3D_RZ_Coordinate = keep_WIN3D_RZ_Coordinate;
                  WIN3D_Zoom = keep_WIN3D_Zoom;
                }

                if (Current_ObjectCategory == ObjectCategory_Sections) { // working with sections

                  int createNewSection = 0;

                  float Section_offset_U = SolidImpact_offset_U[SolidImpact_sectionType];
                  float Section_offset_V = SolidImpact_offset_V[SolidImpact_sectionType];
                  float Section_Elevation = SolidImpact_Elevation[SolidImpact_sectionType];
                  float Section_Rotation = SolidImpact_Rotation[SolidImpact_sectionType];
                  float Section_scale_U = SolidImpact_scale_U[SolidImpact_sectionType];
                  float Section_scale_V = SolidImpact_scale_V[SolidImpact_sectionType];

                  int Section_Type = SolidImpact_sectionType;
                  int Section_RES1 = SolidImpact_RES1;
                  int Section_RES2 = SolidImpact_RES2;  
  
                  if (mouseButton == LEFT) {   
                    
                    int f = int(RxP[0]);
                    
                    int n = allFaces_PNT[f].length;
  
                    if (n > 2) {
  
                      //float min_Alpha = 90;
                      float min_Beta = 360;
  
                      for (int j = 0; j < n; j++) {
  
                        int j_next = (j + 1) % n;
  
                        float x1 = allVertices[allFaces_PNT[f][j]][0];
                        float y1 = allVertices[allFaces_PNT[f][j]][1];
                        float z1 = allVertices[allFaces_PNT[f][j]][2];                        
  
                        float x2 = allVertices[allFaces_PNT[f][j_next]][0];
                        float y2 = allVertices[allFaces_PNT[f][j_next]][1];
                        float z2 = allVertices[allFaces_PNT[f][j_next]][2];                        
  
  
                        //float Alpha = asin_ang(z2 - z1);
                        float Beta = atan2_ang(y2 - y1, x2 - x1) + 90;
  
                        //if (min_Alpha > Alpha) min_Alpha = Alpha;                      
                        if (min_Beta > Beta) min_Beta = Beta;
                      }
  
                      //println("min_Alpha", min_Alpha);
  
                      float[][] tmpVertices = new float[n][3];
  
  
                      for (int j = 0; j < n; j++) {
  
                        float x1 = allVertices[allFaces_PNT[f][j]][0];
                        float y1 = allVertices[allFaces_PNT[f][j]][1];
                        float z1 = allVertices[allFaces_PNT[f][j]][2];
  
                        float x2 = x1 * cos_ang(-min_Beta) - y1 * sin_ang(-min_Beta);
                        float y2 = x1 * sin_ang(-min_Beta) + y1 * cos_ang(-min_Beta);
                        float z2 = z1;
  
                        tmpVertices[j][0] = x2;
                        tmpVertices[j][1] = y2;
                        tmpVertices[j][2] = z2;
                      }    
  
                      float min_x = FLOAT_undefined;
                      float max_x = -FLOAT_undefined;
                      float min_y = FLOAT_undefined;
                      float max_y = -FLOAT_undefined;
                      float min_z = FLOAT_undefined;
                      float max_z = -FLOAT_undefined;
  
                      float[] G = {
                        0, 0, 0
                      }; 
                      for (int j = 0; j < n; j++) {
                        float the_x = tmpVertices[j][0];
                        float the_y = tmpVertices[j][1];
                        float the_z = tmpVertices[j][2];
  
                        G[0] += the_x / float(n); 
                        G[1] += the_y / float(n);
                        G[2] += the_z / float(n);
  
                        if (min_x > the_x) min_x = the_x; 
                        if (max_x < the_x) max_x = the_x; 
                        if (min_y > the_y) min_y = the_y; 
                        if (max_y < the_y) max_y = the_y; 
                        if (min_z > the_z) min_z = the_z; 
                        if (max_z < the_z) max_z = the_z;
                      }
  


                      if ((max_z - min_z < max_x - min_x) && (max_z - min_z < max_y - min_y)) {
                        Section_Type = 1;
  
                        Section_scale_U = max_x - min_x; 
                        Section_scale_V = max_y - min_y;
  
                        Section_offset_U = G[0];
                        Section_offset_V = G[1];
  
                        Section_Elevation = G[2];
  
                        Section_Rotation = min_Beta;
                      } else {
                        Section_Type = 2;
  
                        Section_scale_U = max_y - min_y;
                        Section_scale_V = max_z - min_z; 
  
                        Section_offset_U = -G[1];
                        Section_offset_V = G[2];        
  
                        Section_Elevation = -G[0];
  
                        Section_Rotation = 90 - min_Beta;
                      }       
  
  
                      // recalculating G...  
                      G[0] = 0;             
                      G[1] = 0;
                      G[2] = 0;
                      for (int j = 0; j < n; j++) {
                        float the_x = allVertices[allFaces_PNT[f][j]][0];
                        float the_y = allVertices[allFaces_PNT[f][j]][1];
                        float the_z = allVertices[allFaces_PNT[f][j]][2];
  
                        G[0] += the_x / float(n); 
                        G[1] += the_y / float(n);
                        G[2] += the_z / float(n);
                      }
  
                      PVector AG = new PVector(allVertices[allFaces_PNT[f][0]][0] - G[0], allVertices[allFaces_PNT[f][0]][1] - G[1], allVertices[allFaces_PNT[f][0]][2] - G[2]);                       
                      PVector BG = new PVector(allVertices[allFaces_PNT[f][1]][0] - G[0], allVertices[allFaces_PNT[f][1]][1] - G[1], allVertices[allFaces_PNT[f][1]][2] - G[2]);
  
                      PVector GAxGB = AG.cross(BG);
  
                      float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);
  
                      float[] SectionCorner_A = ImageVertex[1];
                      float[] SectionCorner_B = ImageVertex[2];
                      float[] SectionCorner_C = ImageVertex[3];
                      float[] SectionCorner_D = ImageVertex[4]; 
  
                      float[] ImageCenter = {
                        0, 0, 0
                      };
                      for (int j = 0; j < 3; j++) {
                        ImageCenter[j] = 0.25 * (SectionCorner_A[j] + SectionCorner_B[j] + SectionCorner_C[j] + SectionCorner_D[j]);
                      }  
  
                      PVector AG_other = new PVector(SectionCorner_A[0] - ImageCenter[0], SectionCorner_A[1] - ImageCenter[1], SectionCorner_A[2] - ImageCenter[2]);                       
                      PVector BG_other = new PVector(SectionCorner_B[0] - ImageCenter[0], SectionCorner_B[1] - ImageCenter[1], SectionCorner_B[2] - ImageCenter[2]);
  
                      PVector GAxGB_other = AG_other.cross(BG_other);
  
                      //println("GAxGB", GAxGB);
                      //println("GAxGB_other", GAxGB_other);
  
                      float V = GAxGB_other.dot(GAxGB);
  
                      //println("V", nf(V, 0, 6));                        
  
                      if (V < 0) {
                        println("flip face!");
  
                        Section_Rotation = 180 + Section_Rotation;
                        Section_Elevation *= -1;
                        Section_offset_U *= -1;
                      } else {
                        println("face OK!");
                      }
                      
                      createNewSection = 1;
  
                    }
                  }
                  
                  if (mouseButton == RIGHT) {   

                    Section_Type = 1;

                    Section_offset_U = RxP[1];
                    Section_offset_V = RxP[2];
                    Section_Elevation = RxP[3];


                    createNewSection = 1;
                  }
                  
                  if (createNewSection != 0) {
  
                    SOLARCHVISION_add_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

                    if (keep_number_of_Sections != allSections_num + 1) { // if any Section created during the process

                      selectedSection_numbers = new int [1];
                      selectedSection_numbers[0] = 0;

                      for (int o = keep_number_of_Sections; o < allSections_num + 1; o++) {

                        int[] newlyAddedSection = {
                          allSections_num
                        };

                        selectedSection_numbers = concat(selectedSection_numbers, newlyAddedSection);
                      }  

                      println("SOLARCHVISION_calculate_selection_BoundingBox 9_Section");
                      SOLARCHVISION_calculate_selection_BoundingBox();
                    }      

                    SolidImpact_offset_U[SolidImpact_sectionType] = Section_offset_U;
                    SolidImpact_offset_V[SolidImpact_sectionType] = Section_offset_V;
                    SolidImpact_Elevation[SolidImpact_sectionType] = Section_Elevation;
                    SolidImpact_Rotation[SolidImpact_sectionType] = Section_Rotation;
                    SolidImpact_scale_U[SolidImpact_sectionType] = Section_scale_U;
                    SolidImpact_scale_V[SolidImpact_sectionType] = Section_scale_V;

                    SolidImpact_sectionType = Section_Type;
                    SolidImpact_RES1 = Section_RES1;
                    SolidImpact_RES2 = Section_RES2;    

                    SOLARCHVISION_calculate_SolidImpact_selectedSections();

                    SolarImpact_sectionType = Section_Type;          

                    WIN3D_Update = 1; 
                    ROLLOUT_Update = 1;

                  }                  
                }




                if (keep_number_of_Solids != allSolids_DEF.length) { // if any Solid created during the process

                  selectedSolid_numbers = new int [1];
                  selectedSolid_numbers[0] = 0;

                  for (int o = keep_number_of_Solids; o < allSolids_DEF.length; o++) {

                    int[] newlyAddedSolid = {
                      allSolids_DEF.length - 1
                    };

                    selectedSolid_numbers = concat(selectedSolid_numbers, newlyAddedSolid);
                  }  

                  println("SOLARCHVISION_calculate_selection_BoundingBox 9_Solid");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                }   



                if (keep_number_of_Cameras != allCameras_num + 1) { // if any Camera created during the process

                  selectedCamera_numbers = new int [1];
                  selectedCamera_numbers[0] = 0;

                  for (int o = keep_number_of_Cameras; o < allCameras_num + 1; o++) {

                    int[] newlyAddedCamera = {
                      allCameras_num
                    };

                    selectedCamera_numbers = concat(selectedCamera_numbers, newlyAddedCamera);
                  }  

                  println("SOLARCHVISION_calculate_selection_BoundingBox 9_Camera");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                }                   


                if (keep_number_of_Group3Ds != allGroup3Ds_num + 1) { // if any Group3D created during the process

                  selectedGroup3D_numbers = new int [1];
                  selectedGroup3D_numbers[0] = 0;

                  for (int o = keep_number_of_Group3Ds; o < allGroup3Ds_num + 1; o++) {

                    int[] newlyAddedGroup3D = {
                      allGroup3Ds_num
                    };

                    selectedGroup3D_numbers = concat(selectedGroup3D_numbers, newlyAddedGroup3D);
                  }  

                  println("SOLARCHVISION_calculate_selection_BoundingBox 9_Group3D");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                }   

                if (keep_number_of_Object2Ds != allObject2Ds_num + 1) { // if any Object2D created during the process

                  selectedObject2D_numbers = new int [1];
                  selectedObject2D_numbers[0] = 0;

                  for (int o = keep_number_of_Object2Ds; o < allObject2Ds_num + 1; o++) {

                    int[] newlyAddedObject2D = {
                      allObject2Ds_num
                    };

                    selectedObject2D_numbers = concat(selectedObject2D_numbers, newlyAddedObject2D);
                  }  

                  println("SOLARCHVISION_calculate_selection_BoundingBox 9_Object2D");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                }   


                if (keep_number_of_Fractals != allFractals_num + 1) { // if any Fractal created during the process

                  selectedFractal_numbers = new int [1];
                  selectedFractal_numbers[0] = 0;

                  for (int o = keep_number_of_Fractals; o < allFractals_num + 1; o++) {

                    int[] newlyAddedFractal = {
                      allFractals_num
                    };

                    selectedFractal_numbers = concat(selectedFractal_numbers, newlyAddedFractal);
                  }  

                  println("SOLARCHVISION_calculate_selection_BoundingBox 9_Fractal");
                  SOLARCHVISION_calculate_selection_BoundingBox();
                }
              }
            }          

            WIN3D_Update = 1;
          }
        }

        ROLLOUT_Update = 1;

        redraw();
      }
    }
  }
}

int isInside (float x, float y, float x1, float y1, float x2, float y2) {
  if ((x1 < x) && (x < x2) && (y1 < y) && (y < y2)) return 1;
  else return 0;
} 




float SOLARCHVISION_Spinner (float x, float y, int update1, int update2, int update3, String caption, float v, float min_v, float max_v, float stp_v) {

  float new_value = v;

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v;    

  float cx, cy, cr;
  float w1, w2, h, o, t_o; 

  //w1 = 32.5 * ROLLOUT_S_View;
  //w2 = 142.5 * ROLLOUT_S_View;

  w1 = 100 * ROLLOUT_S_View;
  w2 = 200 * ROLLOUT_S_View;

  h = 16 * ROLLOUT_S_View;
  o = 2 * ROLLOUT_S_View;
  t_o = h * ROLLOUT_S_View / 8.0;

  STUDY_Y_control += 25 * ROLLOUT_S_View; //(h + 2 * o) * 1.25;

  strokeWeight(0); 
  stroke(0); 
  fill(0);
  rect(x + o, y - (h / 2) - o, 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  rect(x + o, y - (h / 2) - o + 0.5 * (h + 2 * o), 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  stroke(255); 
  fill(255);
  cx = x + o + 0.25 * (h + 2 * o);
  cy = y - (h / 2) - o + 0.25 * (h + 2 * o);
  cr = 0.25 * (h + 2 * o);
  triangle(cx + cr * cos_ang(270), cy + 0.75 * cr * sin_ang(270), cx + 0.75 * cr * cos_ang(30), cy + 0.75 * cr * sin_ang(30), cx + 0.75 * cr * cos_ang(150), cy + 0.75 * cr * sin_ang(150));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {
    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value *= abs(stp_v);
      } else { 
        new_value += abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = max_v;
    }
  }

  cy += 2 * cr;
  triangle(cx + cr * cos_ang(90), cy + 0.75 * cr * sin_ang(90), cx + 0.75 * cr * cos_ang(210), cy + 0.75 * cr * sin_ang(210), cx + 0.75 * cr * cos_ang(330), cy + 0.75 * cr * sin_ang(330));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {

    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value /= abs(stp_v);
      } else { 
        new_value -= abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = min_v;
    }
  }

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v; 



  strokeWeight(0); 
  stroke(191); 
  fill(191);
  rect(x - (w1 + w2) - o, y - (h / 2) - o, (w1 + w2) + 2 * o, h + 2 * o);

  stroke(255); 
  fill(255);
  rect(x - w1, y - (h / 2), w1, h);

  float q = 0;

  if (max_v - min_v > 0.001) {
    q = (new_value - min_v) / (max_v - min_v);
  }

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x - w1, y - (h / 2), x, y + (h / 2)) == 1) {

    q = 1;

    if (max_v - min_v > 0.001) {
      q = (SOLARCHVISION_X_clicked - (x - w1)) / w1;
    }

    new_value = min_v + q * (max_v - min_v);

    if (new_value < min_v) new_value = max_v; 
    if (new_value > max_v) new_value = min_v;

    ROLLOUT_Update = 1;
  }

  strokeWeight(0); 
  stroke(191, 255, 191); 
  fill(191, 255, 191);
  rect(x - w1, y - (h / 2), q * w1, h);          


  strokeWeight(2); 
  stroke(0); 
  noFill();
  rect(x - w1, y - (h / 2), w1, h);    

  strokeWeight(0);
  stroke(0); 
  fill(0);
  textSize(1.0 * h);
  textAlign(RIGHT, CENTER);
  if ((new_value == int(new_value)) || (new_value >= 100)) {
    text(String.valueOf(int(new_value)), x - t_o, y - t_o);
  } else {
    text(nf(new_value, 0, 0), x - t_o, y - t_o);
  }


  strokeWeight(0);
  stroke(0); 
  fill(0);
  //textSize(1.0 * h);
  textSize(0.85 * h);
  //textAlign(RIGHT, CENTER); text(caption + ":", x - w1 - t_o, y - t_o);
  textAlign(LEFT, CENTER); 
  text(caption + ":", x - w1 - w2 + t_o, y - t_o);

  if (new_value != v) {
    if (update1 != 0) STUDY_Update = 1;
    if (update2 != 0) WIN3D_Update = 1;
    if (update3 != 0) WORLD_Update = 1;
  }

  return new_value;
}



String[][] SOLARCHVISION_ROLLOUTS = {
  {
    "Location & Data", "Point", "Weather", "Atmosphere"
  }
  , 
  {
    "Geometries & Space", "General", "Create", "Modify", "Solid", "Surface", "Living", "Environment", "Viewport", "Simulation"
  }
  , 
  {
    "Time & Scenarios", "Period", "Ranges", "Filters"
  }
  , 
  {
    "Illustration Options", "2D-Layers", "2D-Colors", "3D-Solar", "3D-Spatial", "Selection"
  }
  , 
  {
    "Post-Processing", "Interpolation", "Developed", "Impacts"
  }
  , 
  {
    "Export Products", "Data", "Media", "Launch"
  }
};

int SOLARCHVISION_ROLLOUT_parent = 0; // 0: Location, 1: Geometry, 2: Time, etc.
int SOLARCHVISION_ROLLOUT_child = 1; // number of the category inside e.g. 1, 2, ...



void SOLARCHVISION_draw_ROLLOUT () {

  stroke(255); 
  fill(255);
  strokeWeight(0);
  rect(ROLLOUT_CX_View, ROLLOUT_CY_View, ROLLOUT_X_View, ROLLOUT_Y_View);


  float h = 20 * ROLLOUT_S_View;

  STUDY_X_control = ROLLOUT_CX_View;
  STUDY_Y_control = ROLLOUT_CY_View;

  STUDY_X_control += 307.5 * ROLLOUT_S_View;
  STUDY_Y_control += 7.5 * ROLLOUT_S_View;

  if (SOLARCHVISION_ROLLOUT_parent >= SOLARCHVISION_ROLLOUTS.length) {
    SOLARCHVISION_ROLLOUT_parent = SOLARCHVISION_ROLLOUTS.length - 1;
  }

  if (SOLARCHVISION_ROLLOUT_child >= SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent].length) {
    SOLARCHVISION_ROLLOUT_child = SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent].length - 1;
  }  

  if (SOLARCHVISION_ROLLOUT_parent < SOLARCHVISION_ROLLOUTS.length) {

    for (int i = 0; i < SOLARCHVISION_ROLLOUTS.length; i++) {

      float cx = ROLLOUT_CX_View + (150 * (i % 2) + 5) * ROLLOUT_S_View;
      float cy = STUDY_Y_control;
      float cr = 6.75 * ROLLOUT_S_View;      

      textAlign(LEFT, CENTER);    

      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 150 * ROLLOUT_S_View, cy + cr) == 1) {
        SOLARCHVISION_ROLLOUT_parent = i;
        SOLARCHVISION_ROLLOUT_child = 1; // <<<<<

        ROLLOUT_Update = 1;
      }

      if (i == SOLARCHVISION_ROLLOUT_parent) {
        strokeWeight(2); 
        stroke(63); 
        fill(191);
        rect(cx - 2.5 * ROLLOUT_S_View, cy - 5 * ROLLOUT_S_View, 150 * ROLLOUT_S_View, 2 * 7.5 * ROLLOUT_S_View);
        strokeWeight(0); 

        stroke(0); 
        fill(0);
        textSize(15 * ROLLOUT_S_View);
      } else {
        stroke(127); 
        fill(127);
        textSize(15 * ROLLOUT_S_View);
      }

      text(nf(i + 1, 0) + ":" + SOLARCHVISION_ROLLOUTS[i][0], cx, cy);

      if (i % 2 == 1) STUDY_Y_control += 15 * ROLLOUT_S_View;
    }

    strokeWeight(2); 
    stroke(63); 
    fill(63);
    rect(ROLLOUT_CX_View, STUDY_Y_control, ROLLOUT_X_View, 17.5 * ceil((SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent].length - 1) / 3.0) * ROLLOUT_S_View);
    strokeWeight(0);    

    STUDY_Y_control += 5 * ROLLOUT_S_View;

    for (int i = 1; i < SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent].length; i++) {

      float cx = ROLLOUT_CX_View + (100 * ((i - 1) % 3) + 10) * ROLLOUT_S_View;
      float cy = STUDY_Y_control;
      float cr = 6.75 * ROLLOUT_S_View;        

      textAlign(LEFT, CENTER);     

      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 100 * ROLLOUT_S_View, cy + cr) == 1) {
        SOLARCHVISION_ROLLOUT_child = i;

        ROLLOUT_Update = 1;
      }      

      if (i == SOLARCHVISION_ROLLOUT_child) {
        stroke(255, 127, 0); 
        fill(255, 127, 0);
        textSize(15 * ROLLOUT_S_View);
      } else {
        stroke(255); 
        fill(255);
        textSize(12.5 * ROLLOUT_S_View);
      }

      text("[" + nf(i, 0) + "]" + SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent][i], cx, cy);

      if (i % 3 == 0) STUDY_Y_control += 15 * ROLLOUT_S_View;
    }

    if (SOLARCHVISION_ROLLOUTS[SOLARCHVISION_ROLLOUT_parent].length % 3 != 1) STUDY_Y_control += 15 * ROLLOUT_S_View;

    STUDY_Y_control += 15 * ROLLOUT_S_View;
  }




  if (SOLARCHVISION_ROLLOUT_parent == 0) { // Location & data


    if (SOLARCHVISION_ROLLOUT_child == 1) { // Point
      //STATION_Selected = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,0,1, "Selected:" + Defined_Stations[STATION_Selected][0], STATION_Selected, 0, Defined_Stations.length - 1, 1), 1));
      //LoadButton_STATION = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1,1,1, "LoadButton_STATION", LoadButton_STATION, 0, 1, 1), 1));
      //STATION_Number = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1,1,1, "Loaded:" + Defined_Stations[STATION_Number][0], STATION_Number, 0, Defined_Stations.length - 1, 1), 1));


      //WORLD_AutoView = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,0,1, "Map Auto Fit", WORLD_AutoView, 0, 1, 1), 1));
      //WORLD_VIEW_Number = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,0,1, "Map Viewport", WORLD_VIEW_Number, 0, WORLD_Viewports_num - 1, 1), 1));

      LocationLatitude = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Latitude", LocationLatitude, -85, 85, LocationLAT_step);
      LocationLongitude = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Longitude", LocationLongitude, -180, 180, LocationLON_step);
      LocationElevation = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Elevation", LocationElevation, -100, 8000, LocationELE_step);

      LocationLAT_step = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Latitude_step", LocationLAT_step, 0.001, 10, -2);
      LocationLON_step = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Longitude_step", LocationLON_step, 0.001, 10, -2);
      LocationELE_step = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Elevation_step", LocationELE_step, 0.125, 1024, -2);

      Display_SWOB_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_SWOB_Points", Display_SWOB_Points, 0, 2, 1), 1));
      Display_SWOB_Nearest = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_SWOB_Nearest", Display_SWOB_Nearest, 0, 1, 1), 1));

      Display_NAEFS_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_NAEFS_Points", Display_NAEFS_Points, 0, 2, 1), 1));
      Display_NAEFS_Nearest = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_NAEFS_Nearest", Display_NAEFS_Nearest, 0, 1, 1), 1));

      Display_CWEEDS_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_CWEEDS_Points", Display_CWEEDS_Points, 0, 2, 1), 1));
      Display_CWEEDS_Nearest = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_CWEEDS_Nearest", Display_CWEEDS_Nearest, 0, 1, 1), 1));

      Display_CLMREC_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_CLMREC_Points", Display_CLMREC_Points, 0, 2, 1), 1));
      Display_CLMREC_Nearest = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_CLMREC_Nearest", Display_CLMREC_Nearest, 0, 1, 1), 1));

      Display_TMYEPW_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_TMYEPW_Points", Display_TMYEPW_Points, 0, 2, 1), 1));
      Display_TMYEPW_Nearest = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Display_TMYEPW_Nearest", Display_TMYEPW_Nearest, 0, 1, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 2) { // Weather

      LoadButton_FORECAST_ENSEMBLE = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "LoadButton_FORECAST_ENSEMBLE", LoadButton_FORECAST_ENSEMBLE, 0, 1, 1), 1));
      LoadButton_CLIMATE_CWEEDS = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "LoadButton_CLIMATE_CWEEDS", LoadButton_CLIMATE_CWEEDS, 0, 1, 1), 1));
      LoadButton_CLIMATE_CLMREC = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "LoadButton_CLIMATE_CLMREC", LoadButton_CLIMATE_CLMREC, 0, 1, 1), 1));
      LoadButton_CLIMATE_TMYEPW = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "LoadButton_CLIMATE_TMYEPW", LoadButton_CLIMATE_TMYEPW, 0, 1, 1), 1));
      LoadButton_RECENT_OBSERVED = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "LoadButton_RECENT_OBSERVED", LoadButton_RECENT_OBSERVED, 0, 1, 1), 1));

      STUDY_max_j_end_observations = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Days of recent observations to load", STUDY_max_j_end_observations, 0, 31, 1), 1));
      Download_RECENT_OBSERVED = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Download_RECENT_OBSERVED", Download_RECENT_OBSERVED, 0, 1, 1), 1));
      Download_CLMREC = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Download_CLMREC", Download_CLMREC, 0, 1, 1), 1));
      Download_FORECAST_ENSEMBLE = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Download_FORECAST_ENSEMBLE", Download_FORECAST_ENSEMBLE, 0, 1, 1), 1));
      

      Download_AERIAL = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Download_AERIAL", Download_AERIAL, 0, 1, 1), 1));

      GRIB2_Hour_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Hour_Start", GRIB2_Hour_Start, 0, 48, 1), 1));
      GRIB2_Hour_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Hour_End", GRIB2_Hour_End, 0, 48, 1), 1));
      GRIB2_Hour_Step = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Hour_Step", GRIB2_Hour_Step, 1, 24, 1), 1));

      GRIB2_Layer_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Layer_Start", GRIB2_Layer_Start, 0, num_Layers, 1), 1));
      GRIB2_Layer_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Layer_End", GRIB2_Layer_End, 0, num_Layers, 1), 1));
      GRIB2_Layer_Step = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "GRIB2_Layer_Step", GRIB2_Layer_Step, 1, num_Layers, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 3) { // Atmosphere

      Display_TROPO3D_Surface = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_TROPO3D_Surface", Display_TROPO3D_Surface, 0, 1, 1), 1));
      Display_TROPO3D_Texture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_TROPO3D_Texture", Display_TROPO3D_Texture, 0, 1, 1), 1));      

      Display_EARTH3D_Surface = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_EARTH3D_Surface", Display_EARTH3D_Surface, 0, 1, 1), 1));
      Display_EARTH3D_Texture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_EARTH3D_Texture", Display_EARTH3D_Texture, 0, 1, 1), 1));

      Display_MOON3D_Surface = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_MOON3D_Surface", Display_MOON3D_Surface, 0, 1, 1), 1));
      Display_MOON3D_Texture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_MOON3D_Texture", Display_MOON3D_Texture, 0, 1, 1), 1));

      Display_STAR3D_Surface = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_STAR3D_Surface", Display_STAR3D_Surface, 0, 1, 1), 1));
      Display_STAR3D_Texture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_STAR3D_Texture", Display_STAR3D_Texture, 0, 1, 1), 1));      

      Planetary_Magnification = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Planetary_Magnification", Planetary_Magnification, 1, 100, 1.0);
    }
  } else if (SOLARCHVISION_ROLLOUT_parent == 1) { // Geometries & Space

    if (SOLARCHVISION_ROLLOUT_child == 1) { // General

      CreateInput_MeshOrSolid = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_MeshOrSolid", CreateInput_MeshOrSolid, 0, 1, 1), 1));

      MODEL3D_Tessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "MODEL3D_Tessellation", MODEL3D_Tessellation, 0, 4, 1), 1));

      LAND_TESSELLATION = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "LAND_TESSELLATION", LAND_TESSELLATION, 0, 4, 1), 1));

      SKY3D_TESSELLATION = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_TESSELLATION", SKY3D_TESSELLATION, 0, 4, 1), 1));   
      SKY3D_scale = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_scale", SKY3D_scale, 0.0000001, 1000000, -2);

      BIOSPHERE_drawResolution = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "BIOSPHERE_drawResolution", BIOSPHERE_drawResolution, 1, 10, 1), 1);

      OBJECTS_scale = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_scale", OBJECTS_scale, 0.0000001, 1000000, -2);      

      LoadButton_UrbanMesh = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "LoadButton_UrbanMesh", LoadButton_UrbanMesh, 0, 1, 1), 1));

      ERASE_Fractals = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Fractals", ERASE_Fractals, 0, 1, 1), 1));

      ERASE_Object2Ds = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Object2Ds", ERASE_Object2Ds, 0, 1, 1), 1));

      ERASE_Group3Ds = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Group3Ds", ERASE_Group3Ds, 0, 1, 1), 1));

      ERASE_Solids = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Solids", ERASE_Solids, 0, 1, 1), 1));

      ERASE_Faces = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Faces", ERASE_Faces, 0, 1, 1), 1));

      ERASE_Sections = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Sections", ERASE_Sections, 0, 1, 1), 1));

      ERASE_Cameras = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_Cameras", ERASE_Cameras, 0, 1, 1), 1));

      ERASE_All = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ERASE_All", ERASE_All, 0, 1, 1), 1));      

      LoadButton_DefaultModels = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "LoadButton_DefaultModels", LoadButton_DefaultModels, 0, MAX_Default_Models_Number, 1), 1));
    }



    if (SOLARCHVISION_ROLLOUT_child == 2) { // Create


      addToLastGroup3D = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "addToLastGroup3D", addToLastGroup3D, 0, 1, 1), 1));



      DEFAULT_CreateMaterial = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "DEFAULT_CreateMaterial", DEFAULT_CreateMaterial, -1, 8, 1), 1));
      DEFAULT_CreateTessellation = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "DEFAULT_CreateTessellation", DEFAULT_CreateTessellation, 0, 6, 1), 1));
      DEFAULT_CreateLayer = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "DEFAULT_CreateLayer", DEFAULT_CreateLayer, 0, 16, 1), 1));
      DEFAULT_CreateVisibility = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "DEFAULT_CreateVisibility", DEFAULT_CreateVisibility, -1, 1, 1), 1));
      //DEFAULT_CreateExtraType = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,0,0, "DEFAULT_CreateExtraType" , DEFAULT_CreateExtraType, 0, 10, 1), 1));

      DEFAULT_CreatePivotType = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "DEFAULT_CreatePivotType", DEFAULT_CreatePivotType, 0, 4, 1), 1));

      CreateInput_Orientation = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_Orientation", CreateInput_Orientation, 0, 360, 15);

      CreateInput_Length = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_Length", CreateInput_Length, -50, 150, -2), 0.5); 
      CreateInput_Width = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_Width", CreateInput_Width, -50, 150, -2), 0.5); 
      CreateInput_Height = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_Height", CreateInput_Height, -50, 150, -2), 0.5);     

      CreateInput_Volume = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_Volume", CreateInput_Volume, 0, 25000, 1000);
    }    

    if (SOLARCHVISION_ROLLOUT_child == 3) { // Modify

      ModifyInput_OpenningDepth = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_OpenningDepth", ModifyInput_OpenningDepth, -10, 10, 0.1);
      ModifyInput_OpenningArea = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_OpenningArea", ModifyInput_OpenningArea, 0, 1, 0.05);
      ModifyInput_OpenningDeviation = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_OpenningDeviation", ModifyInput_OpenningDeviation, 0, 1, 0.05);

      ModifyInput_TessellateRows = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_TessellateRows", ModifyInput_TessellateRows, 1, 100, 1), 1));
      ModifyInput_TessellateColumns = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_TessellateColumns", ModifyInput_TessellateColumns, 1, 100, 1), 1));

      ModifyInput_OffsetAmount = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_OffsetAmount", ModifyInput_OffsetAmount, 0, 25, 0.001);

      ModifyInput_WeldTreshold = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "ModifyInput_WeldTreshold", ModifyInput_WeldTreshold, 0, 10, 0.001);      

      softSelection_Power = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "softSelection_Power", softSelection_Power, 0.125, 8, -2);
      softSelection_Radius = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "softSelection_Radius", softSelection_Radius, 0.01, 100, -2);

      selected_posVector = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_posVector", selected_posVector, 0, 3, 1), 1));
      selected_rotVector =  int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_rotVector", selected_rotVector, 0, 2, 1), 1));
      selected_scaleVector =  int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_scaleVector", selected_scaleVector, 0, 3, 1), 1));

      selected_posValue = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_posValue", selected_posValue, -50, 50, 1), 1));
      selected_rotValue = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_rotValue", selected_rotValue, -180, 180, 5), 5)); 
      selected_scaleValue = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_scaleValue", selected_scaleValue, -8, 8, 0.5), 0.5)); 

      selection_alignX = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selection_alignX", selection_alignX, -1, 1, 1), 1));
      selection_alignY = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selection_alignY", selection_alignY, -1, 1, 1), 1));
      selection_alignZ = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selection_alignZ", selection_alignZ, -1, 1, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 4) { // Solid

      CreateButton_3DSuperOBJ = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateButton_3DSuperOBJ", CreateButton_3DSuperOBJ, 0, 1, 1), 1));

      //CreateInput_powRnd = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,0,0, "CreateInput_powRnd" , CreateInput_powRnd, 0, 1, 1), 1));    
      CreateInput_powAll = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_powAll", CreateInput_powAll, 0.5, CubePower, -2);
      CreateInput_powX = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_powX", CreateInput_powX, 0.5, CubePower, -2); 
      CreateInput_powY = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_powY", CreateInput_powY, 0.5, CubePower, -2); 
      CreateInput_powZ = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_powZ", CreateInput_powZ, 0.5, CubePower, -2);
    }  

    if (SOLARCHVISION_ROLLOUT_child == 5) { // Surface

      CreateInput_SphereDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_SphereDegree", CreateInput_SphereDegree, 0, 5, 1), 1));      

      CreateInput_CylinderDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_CylinderDegree", CreateInput_CylinderDegree, 3, 36, 1), 1));    

      CreateInput_PolyDegree = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateInput_PolyDegree", CreateInput_PolyDegree, 3, 36, 1), 1));

      CreateParametric_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateParametric_Type", CreateParametric_Type, 0, 7, 1), 1));
      CreatePerson_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreatePerson_Type", CreatePerson_Type, 0, Object2D_PEOPLE_Files_Num, 1), 1));
      CreatePlant_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreatePlant_Type", CreatePlant_Type, 0, Object2D_TREES_Files_Num, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 6) { // Living

      CreateButton_Fractal = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateButton_Fractal", CreateButton_Fractal, 0, 1, 1), 1));
      CreateFractal_Type = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_Type", CreateFractal_Type, 0, 0, 1), 1));
      CreateFractal_DegreeMin = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_DegreeMin", CreateFractal_DegreeMin, 1, 9, 1), 1));
      CreateFractal_DegreeMax = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_DegreeMax", CreateFractal_DegreeMax, 1, 9, 1), 1));
      CreateFractal_Seed = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_Seed", CreateFractal_Seed, -1, 32767, 1), 1));
      CreateFractal_TrunkSize = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_TrunkSize", CreateFractal_TrunkSize, 0, 10, 0.1), 0.1);
      CreateFractal_LeafSize = roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "CreateFractal_LeafSize", CreateFractal_LeafSize, 0, 10, 0.1), 0.1);
    }    

    if (SOLARCHVISION_ROLLOUT_child == 7) { // Environment

      Download_LAND_MESH = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Download_LAND_MESH", Download_LAND_MESH, 0, 1, 1), 1));
      LoadButton_LandMesh = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "LoadButton_LandMesh", LoadButton_LandMesh, 0, 1, 1), 1));
      Skip_LAND_MESH_Center = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Skip_LAND_MESH_Center", Skip_LAND_MESH_Center, 0, LAND_n_I - 1, 1), 1));
      Display_LAND_MESH = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_LAND_MESH", Display_LAND_MESH, 0, 1, 1), 1));
      Display_LAND_Texture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_LAND_Texture", Display_LAND_Texture, 0, 1, 1), 1));
      Display_LAND_POINTS = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_LAND_POINTS", Display_LAND_POINTS, 0, 1, 1), 1));     
      Display_LAND_DEPTH = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_LAND_DEPTH", Display_LAND_DEPTH, 0, 1, 1), 1));

      Display_Model2Ds = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Model2Ds", Display_Model2Ds, 0, 1, 1), 1));
      Display_Fractals = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Fractals", Display_Fractals, 0, 1, 1), 1));
      Display_Leaves = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Leaves", Display_Leaves, 0, 1, 1), 1));
      Display_Model3Ds = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Model3Ds", Display_Model3Ds, 0, 1, 1), 1));

      Display_URBAN_MESH = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_URBAN_MESH", Display_URBAN_MESH, 0, 1, 1), 1));

      Display_Solids = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Solids", Display_Solids, 0, 1, 1), 1));

      Display_Sections = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Sections", Display_Sections, 0, 1, 1), 1));




      Display_WindRoseImage = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_WindRoseImage", Display_WindRoseImage, 0, 1, 1), 1));

      WindRose3D_scale = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WindRose3D_scale", WindRose3D_scale, 50, 3200, -2);
      WindRose_RES = int(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WindRose3D_resolution", WindRose_RES, 200, 600, 100));



      Display_SKY3D = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_SKY3D", Display_SKY3D, 0, 1, 1), 1));

      Display_SUN3D_Path = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_SUN3D_Path", Display_SUN3D_Path, 0, 1, 1), 1));
      Display_SUN3D_Pattern = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_SUN3D_Pattern", Display_SUN3D_Pattern, 0, 1, 1), 1));
    }


    if (SOLARCHVISION_ROLLOUT_child == 8) { // Viewport

      WIN3D_CurrentCamera = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WIN3D_CurrentCamera", WIN3D_CurrentCamera, 0, allCameras_num, 1), 1));

      WIN3D_CAM_clipNear = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WIN3D_CAM_clipNear", WIN3D_CAM_clipNear, 0.01, 100, -2);
      WIN3D_CAM_clipFar = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WIN3D_CAM_clipFar", WIN3D_CAM_clipFar, 1000, 2000000000, -2);

      //WIN3D_FacesShade = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0,1,0, "WIN3D_FacesShade", WIN3D_FacesShade, 0, Shade_Options_num - 1, 1), 1));

      MODEL3D_DisplayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "MODEL3D_DisplayEdges", MODEL3D_DisplayEdges, 0, 1, 1), 1));
      MODEL3D_DisplayNormals = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "MODEL3D_DisplayNormals", MODEL3D_DisplayNormals, 0, 1, 1), 1));

      Display_Cameras = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_Cameras", Display_Cameras, 0, 1, 1), 1));
    }    


    if (SOLARCHVISION_ROLLOUT_child == 9) { // Simulation

      IMPACTS_DisplayDay = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "IMPACTS_DisplayDay", IMPACTS_DisplayDay, 0, STUDY_j_End - STUDY_j_Start, 1), 1));

      Display_SolarImpactImage = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_SolarImpactImage", Display_SolarImpactImage, 0, 1, 1), 1));
      Display_SolidImpactImage = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Display_SolidImpactImage", Display_SolidImpactImage, 0, 1, 1), 1));

      SolarImpact_sectionType = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolarImpact_sectionType", SolarImpact_sectionType, 0, 3, 1), 1));      
      SolidImpact_sectionType = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_sectionType", SolidImpact_sectionType, 0, 3, 1), 1));


      SolidImpact_Grade = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_Grade", SolidImpact_Grade, 0.0001, 64.0, -2);
      SolidImpact_Power = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_Power", SolidImpact_Power, 0.0001, 64.0, -2);      
      SolidImpact_Rotation[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_Rotation[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_Rotation[SolidImpact_sectionType], -360, 360, -2);
      SolidImpact_Elevation[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_Elevation[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_Elevation[SolidImpact_sectionType], -1000, 1000, -2);
      SolidImpact_positionStep = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_positionStep", SolidImpact_positionStep, 5, 80, -2);

      SolidImpact_scale_U[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_scale_U[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_scale_U[SolidImpact_sectionType], 0.125, 3200, -2);
      SolidImpact_scale_V[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_scale_V[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_scale_V[SolidImpact_sectionType], 0.125, 3200, -2);
      SolidImpact_offset_U[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_offset_U[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_offset_U[SolidImpact_sectionType], -10000, 10000, -2);
      SolidImpact_offset_V[SolidImpact_sectionType] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_offset_V[" + nf(SolidImpact_sectionType, 0) + "]", SolidImpact_offset_V[SolidImpact_sectionType], -10000, 10000, -2);


      SolidImpact_WindSpeed = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_WindSpeed (m/s)", SolidImpact_WindSpeed, 1, 16, -2); 
      SolidImpact_WindDirection = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SolidImpact_WindDirection", SolidImpact_WindDirection, 0, 360, 15);


      Process_subDivisions = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Process_subDivisions", Process_subDivisions, 0, 3, 1), 1));

      Display_SolidImpact_Points = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Display_SolidImpact_Points", Display_SolidImpact_Points, 0, 1, 1), 1));
      Display_SolidImpact_Lines = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Display_SolidImpact_Lines", Display_SolidImpact_Lines, 0, 1, 1), 1));

      Display_WindFlow = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Display_WindFlow", Display_WindFlow, 0, 1, 1), 1));
    }
  } else if (SOLARCHVISION_ROLLOUT_parent == 2) { // Time & Scenarios

    if (SOLARCHVISION_ROLLOUT_child == 1) { // Period

      STUDY_j_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Number of days to plot", STUDY_j_End, 1, 61, 1), 1));

      TIME_BeginDay = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Plot start date", TIME_BeginDay, 0, 364, 1), 1));

      //TIME_Date = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1,0,0, "Solar date", TIME_Date, 0, 364.5, 0.5);
      TIME_Date = int(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Solar date", TIME_Date, 0, 364, 1));

      TIME_Day = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Forecast day", TIME_Day, 1, 31, 1), 1));
      TIME_Month = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Forecast month", TIME_Month, 1, 12, 1), 1));
      TIME_Year = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Forecast year", TIME_Year, 1953, 2100, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 2) { // Ranges
      STUDY_i_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Start hour", STUDY_i_Start, 0, 23, 1), 1));
      STUDY_i_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "End hour", STUDY_i_End, 0, 23, 1), 1));

      STUDY_JoinDays = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_JoinDays", STUDY_JoinDays, 1, 64, -2), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 3) { // Filters
      STUDY_skyScenario_Active = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Sky status", STUDY_skyScenario_Active, 1, 4, 1), 1));
      FILTER_Active = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Hourly/daily filter", FILTER_Active, 0, 1, 1), 1));

      H_Layer_Option = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Climate filter option", H_Layer_Option, -1, 6, 1), 1));
      //SampleYear_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Start year", SampleYear_Start, CLIMATE_CWEEDS_start, CLIMATE_CWEEDS_end, 1), 1));
      //SampleYear_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "End year", SampleYear_End, CLIMATE_CWEEDS_start, CLIMATE_CWEEDS_end, 1), 1));
      SampleYear_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Start year", SampleYear_Start, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
      SampleYear_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "End year", SampleYear_End, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
//??????
      F_Layer_Option = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Forecast filter option", F_Layer_Option, -1, 4, 1), 1));
      SampleMember_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Start member", SampleMember_Start, FORECAST_ENSEMBLE_start, FORECAST_ENSEMBLE_end, 1), 1));  
      SampleMember_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "End member", SampleMember_End, FORECAST_ENSEMBLE_start, FORECAST_ENSEMBLE_end, 1), 1));

      O_Layer_Option = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Observation filter option", O_Layer_Option, -1, 1, 1), 1));
      SampleStation_Start = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Start station", SampleStation_Start, RECENT_OBSERVED_start, RECENT_OBSERVED_end, 1), 1));  
      SampleStation_End = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "End station", SampleStation_End, RECENT_OBSERVED_start, RECENT_OBSERVED_end, 1), 1));
    }
  } else if (SOLARCHVISION_ROLLOUT_parent == 3) { // Display Options

    if (SOLARCHVISION_ROLLOUT_child == 1) { // 2D-Layers

      FrameVariation = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 1, 1, "Frame layout variation", FrameVariation, 0, 3, 1), 1));

      STUDY_Setup = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Diagram setup", STUDY_Setup, -2, 14, 1), 1));

      STUDY_Update = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Redraw scene", STUDY_Update, 0, 1, 1), 1));  

      STUDY_CurrentLayer = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Layer", STUDY_CurrentLayer, 0, (num_Layers - 1), 1), 1));
      STUDY_V_scale[STUDY_CurrentLayer] = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "V_scale[" + nf(STUDY_CurrentLayer, 2) + "]", STUDY_V_scale[STUDY_CurrentLayer], 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));      

      STUDY_DisplayRaws = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Draw data", STUDY_DisplayRaws, 0, 1, 1), 1));
      STUDY_DisplaySorted = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Draw sorted", STUDY_DisplaySorted, 0, 1, 1), 1));
      STUDY_DisplayNormals = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Draw statistics", STUDY_DisplayNormals, 0, 1, 1), 1));
      STUDY_DisplayProbs = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Draw probabilities", STUDY_DisplayProbs, 0, 1, 1), 1));
      STUDY_SumInterval = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Probabilities interval", STUDY_SumInterval, 1, 24, 1), 1));
      STUDY_LevelPix = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Probabilities range", STUDY_LevelPix, 2, 32, -2), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 2) { // 2D-Colors

      //COLOR_STYLE_Active = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1,0,0, "Hourly color scheme", COLOR_STYLE_Active, -1, (COLOR_STYLE_Number - 1), 1), 1));

      STUDY_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_ACTIVE_CLR", STUDY_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      STUDY_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_ACTIVE_DIR", STUDY_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      STUDY_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_ACTIVE_MLT", STUDY_Pallet_ACTIVE_MLT, 0.125, 8, -2);

      STUDY_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PASSIVE_CLR", STUDY_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      STUDY_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PASSIVE_DIR", STUDY_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
      STUDY_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PASSIVE_MLT", STUDY_Pallet_PASSIVE_MLT, 0.125, 8, -2);       

      STUDY_Pallet_SORT_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_SORT_CLR", STUDY_Pallet_SORT_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      STUDY_Pallet_SORT_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_SORT_DIR", STUDY_Pallet_SORT_DIR, -2, 2, 2), 1));
      STUDY_Pallet_SORT_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_SORT_MLT", STUDY_Pallet_SORT_MLT, 0.125, 8, -2);

      STUDY_Pallet_PROB_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PROB_CLR", STUDY_Pallet_PROB_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      STUDY_Pallet_PROB_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PROB_DIR", STUDY_Pallet_PROB_DIR, -2, 2, 2), 1));
      STUDY_Pallet_PROB_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "STUDY_Pallet_PROB_MLT", STUDY_Pallet_PROB_MLT, 0.125, 8, -2);

      STUDY_O_scale = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Windose opacity scale", STUDY_O_scale, 1, 100, -pow(2.0, (1.0 / 4.0)));
    }

    if (SOLARCHVISION_ROLLOUT_child == 3) { // 3D-Solar 

      OBJECTS_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      OBJECTS_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      OBJECTS_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT, 0.125, 8, -2);

      OBJECTS_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      OBJECTS_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
      OBJECTS_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT, 0.125, 8, -2);

      SKY3D_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_ACTIVE_CLR", SKY3D_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      SKY3D_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_ACTIVE_DIR", SKY3D_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      SKY3D_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_ACTIVE_MLT", SKY3D_Pallet_ACTIVE_MLT, 0.125, 8, -2);

      SKY3D_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_PASSIVE_CLR", SKY3D_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      SKY3D_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_PASSIVE_DIR", SKY3D_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
      SKY3D_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SKY3D_Pallet_PASSIVE_MLT", SKY3D_Pallet_PASSIVE_MLT, 0.125, 8, -2);

      SunPath3D_Pallet_ACTIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_ACTIVE_CLR", SunPath3D_Pallet_ACTIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      SunPath3D_Pallet_ACTIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_ACTIVE_DIR", SunPath3D_Pallet_ACTIVE_DIR, -2, 2, 1), 1));
      SunPath3D_Pallet_ACTIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_ACTIVE_MLT", SunPath3D_Pallet_ACTIVE_MLT, 0.125, 8, -2);

      SunPath3D_Pallet_PASSIVE_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_PASSIVE_CLR", SunPath3D_Pallet_PASSIVE_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      SunPath3D_Pallet_PASSIVE_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_PASSIVE_DIR", SunPath3D_Pallet_PASSIVE_DIR, -2, 2, 2), 1));
      SunPath3D_Pallet_PASSIVE_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SunPath3D_Pallet_PASSIVE_MLT", SunPath3D_Pallet_PASSIVE_MLT, 0.125, 8, -2);
    }




    if (SOLARCHVISION_ROLLOUT_child == 4) { // 3D-Solid   

      SOLID_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SOLID_Pallet_CLR", SOLID_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      SOLID_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SOLID_Pallet_DIR", SOLID_Pallet_DIR, -2, 2, 2), 1));
      SOLID_Pallet_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "SOLID_Pallet_MLT", SOLID_Pallet_MLT, 0.0001, 64, -2);      

      ELEVATION_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      ELEVATION_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR, -2, 2, 2), 1));
      ELEVATION_Pallet_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT, 0.001, 0.5, -2);   

      WindFlow_Pallet_CLR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WindFlow_Pallet_CLR", WindFlow_Pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
      WindFlow_Pallet_DIR = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WindFlow_Pallet_DIR", WindFlow_Pallet_DIR, -2, 2, 2), 1));
      WindFlow_Pallet_MLT = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "WindFlow_Pallet_MLT", WindFlow_Pallet_MLT, 0.01, 1.0, -2);
    }      


    if (SOLARCHVISION_ROLLOUT_child == 5) { // Selection

      selectedGroup3D_displayPivot = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedGroup3D_displayPivot", selectedGroup3D_displayPivot, 0, 1, 1), 1));
      selected_displayReferencePivot = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selected_displayReferencePivot", selected_displayReferencePivot, 0, 1, 1), 1));
      selectedGroup3D_displayBox = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedGroup3D_displayBox", selectedGroup3D_displayBox, 0, 1, 1), 1));
      selectedGroup3D_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedGroup3D_displayEdges", selectedGroup3D_displayEdges, 0, 1, 1), 1));

      selectedFace_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedFace_displayEdges", selectedFace_displayEdges, 0, 1, 1), 1));
      selectedFace_displayVertexCount = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedFace_displayVertexCount", selectedFace_displayVertexCount, 0, 1, 1), 1));
      selectedVertex_displayVertices = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedVertex_displayVertices", selectedVertex_displayVertices, 0, 1, 1), 1));

      selectedObject2D_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedObject2D_displayEdges", selectedObject2D_displayEdges, 0, 1, 1), 1));
      selectedFractal_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedFractal_displayEdges", selectedFractal_displayEdges, 0, 1, 1), 1));

      selectedSolid_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedSolid_displayEdges", selectedSolid_displayEdges, 0, 1, 1), 1));

      selectedSection_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedSection_displayEdges", selectedSection_displayEdges, 0, 1, 1), 1));

      selectedCamera_displayEdges = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedCamera_displayEdges", selectedCamera_displayEdges, 0, 1, 1), 1));

      selectedLandPoint_displayPoints = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "selectedLandPoint_displayPoints", selectedLandPoint_displayPoints, 0, 1, 1), 1));
    }
  } else if (SOLARCHVISION_ROLLOUT_parent == 4) { // Post-Processing

    if (SOLARCHVISION_ROLLOUT_child == 1) { // Interpolation

      Interpolation_Weight = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Interpolation_Weight", Interpolation_Weight, 0, 5, 0.5);
      CLIMATIC_SolarForecast = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Climate-based solar forecast", CLIMATIC_SolarForecast, 0, 1, 1), 1));
      CLIMATIC_WeatherForecast = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Climate-based temperature forecast", CLIMATIC_WeatherForecast, 0, 2, 1), 1));
    } 
    if (SOLARCHVISION_ROLLOUT_child == 2) { // Developed
      Develop_Option = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Develop_Option", Develop_Option, 0, 11, 1), 1));
      Develop_DayHour = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Develop_DayHour", Develop_DayHour, 0, 3, 1), 1));

      STUDY_TrendJoinHours = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Trend period hours", STUDY_TrendJoinHours, 1, 24 * 16, 1), 1));
      STUDY_TrendJoinType = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Weighted/equal trend", STUDY_TrendJoinType, -1, 1, 2), 1));

      Develop_AngleInclination = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Inclination angle", Develop_AngleInclination, 0, 90, 5), 1));
      Develop_AngleOrientation = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Orientation angle", Develop_AngleOrientation, 0, 360, 15), 1));
    }
    if (SOLARCHVISION_ROLLOUT_child == 3) { // Impacts
      IMPACTS_DataSource = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Impacts Source", IMPACTS_DataSource, 0, 3, 1), 1));
      STUDY_ImpactLayer = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Impact Min/50%/Max", STUDY_ImpactLayer, 0, 8, 1), 1));
      STUDY_Impacts_Update = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Update impacts", STUDY_Impacts_Update, 0, 1, 1), 1));
    }
  } else if (SOLARCHVISION_ROLLOUT_parent == 5) { // Export Products

    if (SOLARCHVISION_ROLLOUT_child == 1) { // Data

      Export_STUDY_info_node = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Export ASCII data", Export_STUDY_info_node, 0, 1, 1), 1));
      Export_STUDY_info_norm = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Export ASCII statistics", Export_STUDY_info_norm, 0, 1, 1), 1));
      Export_STUDY_info_prob = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Export ASCII probabilities", Export_STUDY_info_prob, 0, 1, 1), 1));


      objExport_Scale = SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_Scale", objExport_Scale, .001, 1000, -0.1);
      objExport_FlipZYaxis = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_FlipZYaxis", objExport_FlipZYaxis, 0, 1, 1), 1));

      objExport_PrecisionVertex = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_PrecisionVertex", objExport_PrecisionVertex, 0, 6, 1), 1));
      objExport_PrecisionVtexture = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_PrecisionVtexture", objExport_PrecisionVtexture, 0, 6, 1), 1));
      objExport_PolyToPoly = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_PolyToPoly", objExport_PolyToPoly, 0, 1, 1), 1));

      objExport_MaterialLibrary = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_MaterialLibrary", objExport_MaterialLibrary, 0, 1, 1), 1));
      objExport_BackSides = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_BackSides", objExport_BackSides, 0, 1, 1), 1));
      objExport_CombinedMaterial = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_CombinedMaterial", objExport_CombinedMaterial, 0, 1, 1), 1));      
      objExport_BakingResolution = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_BakingResolution", objExport_BakingResolution, 4, 256, -2), 1));
      objExport_PalletResolution = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_PalletResolution", objExport_PalletResolution, 32, 2048, -2), 1));
      objExport_UsePalletOrBakeFaces = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "objExport_UsePalletOrBakeFaces", objExport_UsePalletOrBakeFaces, 0, 1, 1), 1));


      Display_Output_in_Explorer = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Display_Output_in_Explorer", Display_Output_in_Explorer, 0, 1, 1), 1));
    }  

    if (SOLARCHVISION_ROLLOUT_child == 2) { // Media

      STUDY_record_PDF = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Record Time Graph in PDF", STUDY_record_PDF, 0, 1, 1), 1));
      STUDY_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "Record Time Graph in JPG", STUDY_record_JPG, 0, 1, 1), 1));

      WORLD_record_PDF = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Record Location Graph in PDF", WORLD_record_PDF, 0, 1, 1), 1));
      WORLD_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 1, "Record Location Graph in JPG", WORLD_record_JPG, 0, 1, 1), 1));

      WIN3D_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 1, 0, "Record 3D-Model Graph in JPG", WIN3D_record_JPG, 0, 1, 1), 1));

      FRAME_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Screenshot in JPG", FRAME_record_JPG, 0, 1, 1), 1));
      FRAME_click_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Screenshot with click mark", FRAME_click_JPG, 0, 1, 1), 1));
      FRAME_drag_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Screenshot with drag mark", FRAME_drag_JPG, 0, 1, 1), 1));

      SolidImpact_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Record SolidImpact in JPG", SolidImpact_record_JPG, 0, 1, 1), 1));
      SolidImpact_record_PDF = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Record SolidImpact in PDF", SolidImpact_record_PDF, 0, 1, 1), 1));

      SolarImpact_record_JPG = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 0, 0, 0, "Record Solar Analysis in JPG", SolarImpact_record_JPG, 0, 1, 1), 1));
    }

    if (SOLARCHVISION_ROLLOUT_child == 3) { // Launch

      RUN_AudioProduct = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "RUN_AudioProduct", RUN_AudioProduct, 0, 1, 1), 1));
      RUN_ExternalSimulation = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "RUN_ExternalSimulation", RUN_ExternalSimulation, 0, 1, 1), 1));
      RUN_ExternalHardware = int(roundTo(SOLARCHVISION_Spinner(STUDY_X_control, STUDY_Y_control, 1, 0, 0, "RUN_ExternalHardware", RUN_ExternalHardware, 0, 1, 1), 1));
    }
  }    

  if (ROLLOUT_Include == 1) {
    if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, ROLLOUT_CX_View, ROLLOUT_CY_View, ROLLOUT_CX_View + ROLLOUT_X_View, ROLLOUT_CY_View + ROLLOUT_Y_View) == 1) {  
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }
}




//---------------------------------------------------------------------






void SOLARCHVISION_try_update_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {

  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = 0; //begin_HOUR; // <<<<<<<<<<<<<<<




  AERIAL_Data = new float [49][num_Layers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Flags = new int [49][num_Layers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Locations = new float [AERIAL_num][3]; // lon, lat, tgl
  AERIAL_Center_Longitude = LocationLongitude;
  AERIAL_Center_Latitude = LocationLatitude;

  for (int h = 0; h < GRIB2_TGL_number; h += 1) {
    GRIB2_TGL_Selected[h] = 0; // deselect all layers first.
  }

  for (int n = 0; n < AERIAL_num; n += 1) {
    for (int k = 0; k <= 48; k += 1) {
      for (int l = 0; l < num_Layers; l++) {
        for (int o = 0; o < GRIB2_maxScenarios; o += 1) {   
          AERIAL_Data[k][l][n][o] = FLOAT_undefined;
          AERIAL_Flags[k][l][n][o] = -1;
        }
      }
    }  


    float stp_lat = 20.0 / 2224.5968; // equals to 1km <<<<<<<<
    float stp_lon = stp_lat / cos_ang(AERIAL_Center_Latitude); 


    float r1 = float(GRIB2_Domains[GRIB2_DomainSelection][5]);
    float r = 0; 
    float t = 0; 

    int p = n / (1 + 6 + 12);
    int q = n % (1 + 6 + 12);

    if ((q > 0) && (q <= 6)) {
      r = 1 * r1;
      t = 360 * q / 6.0;
    }  

    if ((q > 6) && (q <= 18)) {
      r = 2 * r1;
      t = 360 * (q - 6) / 12.0;
    }  

    if ((q > 18) && (q <= 36)) {
      r = 3 * r1;
      t = 360 * (q - 18) / 18.0;
    }  

    float _tgl = 40 * p;

    if (_tgl == 0) _tgl = 10; // <<<<<<  

    AERIAL_Locations[n][0] = AERIAL_Center_Longitude + stp_lon * r * cos_ang(t);
    AERIAL_Locations[n][1] = AERIAL_Center_Latitude + stp_lat * r * sin_ang(t);
    AERIAL_Locations[n][2] = _tgl;

    GRIB2_TGL_Selected[p] = 1;
  }  


  String the_directory = getGrib2Folder(GRIB2_DomainSelection);
  {  
    String[] tmpMessage = {
      nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
    };
    // Creates two temp files to make the destination folders if they were not available.
    saveStrings(Wgrib2TempFolder + "/TempEmpty.txt", tmpMessage);
    saveStrings(the_directory + "/TempEmpty.txt", tmpMessage);
  }

  String[] SavedFiles = sort(SOLARCHVISION_getfiles(the_directory));

  for (int h = 0; h < GRIB2_TGL_number; h += 1) {

    if (GRIB2_TGL_Selected[h] != 0) {

      for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
        GRIB2_Layer = l;

        for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
          GRIB2_Hour = k;

          String the_filename = getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);

          int File_Found = 0;

          for (int i = SavedFiles.length - 1; i >= 0; i--) {
            String thisFile = the_directory + "/" + SavedFiles[i];

            if (thisFile.equals(the_directory + "/" + the_filename)) {
              File_Found = 1;
              break;
            }
          }

          String the_link = "";

          if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("WAVE")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + the_filename;
          }
          if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("HRDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }
          if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }          
          if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GDPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }
          if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GEPS")) {
            the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
          }

          if (File_Found == 0) {

            String the_target = the_directory + "/" + the_filename;

            try {
              println("Downloading...", the_link);
              saveBytes(the_target, loadBytes(the_link));
              println("100%");
              File_Found = 1;
            } 
            catch (Exception e) {
            }
          }

          if (File_Found == 1) {
            /*

             for (int n = 0; n < AERIAL_num; n += 1) {
             
             LocationLongitude = AERIAL_Locations[n][0];
             LocationLatitude = AERIAL_Locations[n][1];
             
             int o = 0; // now only for deterministic!
             AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] = getGrib2Value(GRIB2_Hour, GRIB2_Layer, h, AERIAL_Locations[n][0], AERIAL_Locations[n][1]); 
             
             }
             
             */

            float[][] Points = {
              {
                0, 0, 0
              }
            };
            int Points_num = 1;

            for (int n = 0; n < AERIAL_num; n += 1) {
              int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 

              if (p == h) {

                float[][] newPoint = {
                  {
                    AERIAL_Locations[n][0], AERIAL_Locations[n][1], AERIAL_Locations[n][2]
                  }
                };
                Points = (float[][]) concat(Points, newPoint);

                Points_num += 1;
              }
            }

            if (Points_num > 1) {

              float[][] GRIB2_values = getGrib2Value_MultiplePoints(GRIB2_Hour, GRIB2_Layer, h, Points, the_link);

              int nPoint = 0;

              for (int n = 0; n < AERIAL_num; n += 1) {
                int p = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 

                if (p == h) {

                  nPoint += 1;

                  for (int o = 0; o < GRIB2_maxScenarios; o += 1) {
                    AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] = GRIB2_values[nPoint][o];
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  for (int n = 0; n < AERIAL_num; n += 1) {

    int h = int(roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 

    if ((LAYERS_GRIB2_VAL[LAYER_winddir][h].substring(0, 4)).equals("UGRD") && (LAYERS_GRIB2_VAL[LAYER_windspd][h].substring(0, 4)).equals("VGRD")) {

      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;    

        for (int o = 0; o < GRIB2_maxScenarios; o += 1) {

          float u = AERIAL_Data[GRIB2_Hour][LAYER_winddir][n][o]; // because U component stored in LAYER_winddir 
          float v = AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o]; // because U component stored in LAYER_windspd

          if ((abs(u) < 0.9 * FLOAT_undefined) && (abs(v) < 0.9 * FLOAT_undefined)) { 
            AERIAL_Data[GRIB2_Hour][LAYER_windspd][n][o] = 3.6 * pow((pow(u, 2) + pow(v, 2)), 0.5); // now converting from m/s >> Km/h 
            AERIAL_Data[GRIB2_Hour][LAYER_winddir][n][o] = 180 + atan2_ang(u, v); // ???????????? range checking?
          }
        }
      }
    }
  }




  for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
    GRIB2_Layer = l;

    for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
      GRIB2_Hour = k;

      for (int n = 0; n < AERIAL_num; n += 1) {
        for (int o = 0; o < GRIB2_maxScenarios; o += 1) {
          if (AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] < 0.9 * FLOAT_undefined) {
            AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = 1;
          } else AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = -1;
        }
      }
    }
  }

  for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
    GRIB2_Layer = l;

    for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
      GRIB2_Hour = k;

      for (int n = 0; n < 1; n += 1) { // <<<<<<<<<<<<<<<< For now: only the first point (i.e. the center)
        for (int o = 0; o < GRIB2_maxScenarios; o += 1) {  

          int THE_YEAR = GRIB2_Year;
          int THE_MONTH = GRIB2_Month;
          int THE_DAY = GRIB2_Day;
          int THE_HOUR = GRIB2_ModelRun;

          int now_i = int(THE_HOUR);
          int now_j = SOLARCHVISION_Convert2Date(THE_MONTH, THE_DAY);

          now_i -= int(-LocationTimeZone / 15);
          if (now_i < 0) {
            now_i += 24;
            now_j -= 1;
            if (now_j < 0) {
              now_j += 365;
            }
          }          

          int next_i = now_i + k;
          int next_j = now_j;
          if (next_i >= 24) {

            next_j += int(next_i / 24);
            if (next_j >= 365) {
              next_j = next_j % 365;
            }

            next_i = next_i % 24;
          }


          FORECAST_ENSEMBLE_Data[next_i][next_j][l][43 + o] = AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]; // <<<<<<<<<<< writing after member 43

          println(GRIB2_Domains[GRIB2_DomainSelection][0] + "[" + nf(o, 0) + "]:", next_i, next_j, l, FORECAST_ENSEMBLE_Data[next_i][next_j][l][43 + o]);          
          println("GDPS:", next_i, next_j, l, FORECAST_ENSEMBLE_Data[next_i][next_j][l][21]);
        }
      }
    }
  }

  SOLARCHVISION_postProcess_FORECAST_ENSEMBLE();

  F_Layer_Option = 5;
  STUDY_Update = 1;
}




String getGrib2Folder (int s) {
  return(Grib2ArchiveFolder + "/FORECAST_" + GRIB2_Domains[s][1]);
}

String getGrib2Filename (int k, int l, int h) {
  String return_txt = "";

  String F_L = LAYERS_GRIB2_VAL[l][h];

  if (l == LAYER_winddir) {
    if (GRIB2_Domains[GRIB2_DomainSelection][h].equals("GEPS")) {
      F_L = F_L.replace("WDIR", "UGRD");
      LAYERS_GRIB2_VAL[l][h] = F_L;
    } else {
      F_L = F_L.replace("UGRD", "WDIR");
      LAYERS_GRIB2_VAL[l][h] = F_L;
    }
  }

  if (l == LAYER_windspd) {
    if (GRIB2_Domains[GRIB2_DomainSelection][h].equals("GEPS")) {

      F_L = F_L.replace("WIND", "VGRD");
      LAYERS_GRIB2_VAL[l][h] = F_L;
      LAYERS_GRIB2_MUL[l] = 1; // that is for no unit conversion!
    } else {
      F_L = F_L.replace("VGRD", "WIND");
      LAYERS_GRIB2_VAL[l][h] = F_L;  
      LAYERS_GRIB2_MUL[l] = 3.6; // m/s > Km/h
    }
  }

  if (GRIB2_Domains[GRIB2_DomainSelection][h].equals("GEPS")) {    
    if (F_L.equals("TMP_TGL_2")) F_L += "m";
    if (F_L.equals("RH_TGL_2")) F_L += "m";
    if (F_L.equals("UGRD_TGL_10")) F_L += "m";
    if (F_L.equals("VGRD_TGL_10")) F_L += "m";
  }

  return_txt = GRIB2_Domains[GRIB2_DomainSelection][2] + "_" + F_L + "_" + GRIB2_Domains[GRIB2_DomainSelection][3] + "_" + nf(GRIB2_Year, 4) + nf(GRIB2_Month, 2) + nf(GRIB2_Day, 2) + nf(GRIB2_ModelRun, 2) + "_P" + nf(k, 3) + GRIB2_Domains[GRIB2_DomainSelection][4];

  return return_txt;
}


String getWgrib2Filename_MultiplePoints (int k, int l, int h, int part) {
  return(GRIB2_Domains[GRIB2_DomainSelection][2] + "_" + nf(GRIB2_Year, 4) + nf(GRIB2_Month, 2) + nf(GRIB2_Day, 2) + "R" + nf(GRIB2_ModelRun, 2) + "P" + nf(k, 3) + "_" + LAYERS_GRIB2_VAL[l][h] + "_" + nf(LocationLongitude, 0, 4) + "X" + nf(LocationLatitude, 0, 4) + "_part" + nf(part, 3) + ".txt");
}

String getWgrib2Filename (int k, int l, int h, float _lon, float _lat) {
  return(GRIB2_Domains[GRIB2_DomainSelection][2] + "_" + nf(GRIB2_Year, 4) + nf(GRIB2_Month, 2) + nf(GRIB2_Day, 2) + "R" + nf(GRIB2_ModelRun, 2) + "P" + nf(k, 3) + "_" + LAYERS_GRIB2_VAL[l][h] + "_" + nf(_lon, 0, 4) + "X" + nf(_lat, 0, 4) + ".txt");
}



int MAX_GRIB2_PASS = 200;


float[][] getGrib2Value_MultiplePoints (int k, int l, int h, float[][] Points, String the_link) {

  // note: the first point is null

  float[][] theValues = new float [Points.length][GRIB2_maxScenarios];

  for (int n = 0; n < Points.length; n += 1) {
    for (int o = 0; o < GRIB2_maxScenarios; o += 1) {
      theValues[n][o] = FLOAT_undefined;
    }
  }


  XML my_xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  XML newChild1 = null;
  XML newChild2 = null;
  XML newChild3 = null;

  int build_xml = 1;

  int next_YEAR = GRIB2_Year;
  int next_MONTH = GRIB2_Month;
  int next_DAY = GRIB2_Day;
  int next_HOUR = GRIB2_ModelRun;

  next_HOUR += k;
  if (next_HOUR >= 24) {
    next_HOUR = next_HOUR % 24;
    next_DAY += int((GRIB2_ModelRun + k) / 24);

    if (next_DAY > CalendarLength[(GRIB2_Month - 1)]) {
      next_DAY -= CalendarLength[(GRIB2_Month - 1)];
      next_MONTH += 1;

      if (next_MONTH > 12) {
        next_MONTH = 1;
        next_YEAR += 1;
      }
    }
  }

  if (build_xml == 1) {

    my_xml.setName(GRIB2_Domains[GRIB2_DomainSelection][0] + "_forecast");

    newChild1 = my_xml.addChild("header");

    newChild2 = newChild1.addChild("Domain");
    newChild2.setContent(GRIB2_Domains[GRIB2_DomainSelection][0]);

    newChild2 = newChild1.addChild("valid-begin-time");
    newChild2.setContent(nf(GRIB2_Year, 4) + "-" + nf(GRIB2_Month, 2) + "-" + nf(GRIB2_Day, 2) + "T" + nf(GRIB2_ModelRun, 2) + "00:00Z");

    newChild2 = newChild1.addChild("model_description");
    newChild3 = newChild2.addChild("model");
    //newChild3.setInt("id", 44);  // ???????????????????????????????????????????????
    newChild3.setString("model", GRIB2_Domains[GRIB2_DomainSelection][0]); 
    newChild3.setString("member", nf(GRIB2_maxScenarios, 0)); 
    newChild3.setString("center", "CMC"); 
    newChild3.setString("domain", GRIB2_Domains[GRIB2_DomainSelection][2]);
    newChild3.setString("data_type", "RAW"); 
    newChild3.setString("source", the_link);

    if (GRIB2_maxScenarios == 1) {
      newChild3.setString("member_type", "deterministic");
    } else {
      newChild3.setString("member_type", "ensemble");
    }

    newChild1 = my_xml.addChild("forecast_element");
    newChild1.setString("code", LAYERS_GRIB2_VAL[l][h]); 
    newChild1.setString("unit", LAYERS_Unit[l]); 
    newChild1.setString("title_english", LAYERS_Title[l][Language_EN]);
    newChild1.setString("titre_francais", LAYERS_Title[l][Language_FR]);

    newChild1 = my_xml.addChild("point_description");

    for (int n = 1; n < Points.length; n += 1) {
      newChild2 = newChild1.addChild("point");
      newChild2.setInt("id", n);

      newChild2.setString("latitude", nf(Points[n][0], 0, 4).replace(",", "."));
      newChild2.setString("longitude", nf(Points[n][1], 0, 4).replace(",", "."));
      newChild2.setString("TGL", String.valueOf(Points[n][2]));
    }
  }


  String[] filenames = SOLARCHVISION_getfiles(Wgrib2TempFolder);

  String[] file_lines = {
  };

  int NUM_ValueFiles = 1 + int((Points.length - 1) / MAX_GRIB2_PASS);
  String[] ValueFiles = new String [NUM_ValueFiles];

  for (int p = 0; p < NUM_ValueFiles; p += 1) { 

    String ValueFilename = getWgrib2Filename_MultiplePoints(k, l, h, p); 

    ValueFiles[p] = Wgrib2TempFolder + "/" + ValueFilename;    

    int runWgrib2 = 1;

    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        if (filenames[i].equals(ValueFilename)) {

          file_lines = loadStrings(ValueFiles[p]);

          if (file_lines.length > 0) {
            //println("The previous extraction file is found:", ValueFilename);
            runWgrib2 = 0;
          }
        }
      }
    }

    if (runWgrib2 == 1) {

      String Grib2File = getGrib2Folder(GRIB2_DomainSelection) + "/" + getGrib2Filename(k, l, h);

      String CommandArguments[] = {
        "wgrib2", Grib2File.replace('/', char(92)), "-s"
      };

      int q_max = MAX_GRIB2_PASS;
      if (p == NUM_ValueFiles - 1) {
        q_max = ((Points.length - 1) % MAX_GRIB2_PASS);
      }

      for (int q = 0; q < q_max; q += 1) {
        int f = p * MAX_GRIB2_PASS + q + 1;

        float _lon = Points[f][0];
        float _lat = Points[f][1];

        //StationI = LOCATIONS_IJ[s][f][0];
        //StationJ = LOCATIONS_IJ[s][f][1];

        //if ((GRIB2_Domains[GRIB2_DomainSelection][0].equals("GDPS")) || (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GEPS"))) { 
        String[] _add = {
          "-print", ("station=" + ""), "-lon", nf(360 + _lon, 0, 4).replace(",", "."), nf(_lat, 0, 4).replace(",", ".")
        };
        CommandArguments = concat(CommandArguments, _add);
        //}
        //else {
        //String[] _add = {"-print", ("station=" + ""), "-ijlat", String.valueOf(StationI), String.valueOf(StationJ)};
        //CommandArguments = concat(CommandArguments , _add);
        //}
      }
      String[] _end = {
        ">", ValueFiles[p]
      };
      CommandArguments = concat(CommandArguments, _end);

      println(CommandArguments);
      launch(CommandArguments);
    }





    int _stay = 1;

    while ((_stay != 0) && (_stay < 100000)) {

      //println(_stay);

      _stay += 1;

      filenames = SOLARCHVISION_getfiles(Wgrib2TempFolder);

      if (filenames != null) {
        for (int i = 0; i < filenames.length; i++) {
          //println(filenames[i]);

          if (filenames[i].equals(ValueFilename)) {
            //println("The wgrib2 extraction is ready:", ValueFilename);

            file_lines = loadStrings(ValueFiles[p]);

            if (file_lines.length > 0) _stay = 0;
          }
        }
      }
    }


    if (_stay != 0) {
      println("The wgrib2 extraction is not ready:", ValueFilename);
    } else {
      println(file_lines);

      if (file_lines.length > 0) {

        for (int o = 0; o < GRIB2_maxScenarios; o += 1) {       

          String file_one_line_entered = file_lines[o].replace(":station=", "\n");
          String[] my_lines = split(file_one_line_entered, "\n");  


          //println(file_one_line_entered);
          //println("lines:", my_lines.length);
          //println("-----------------------------------------------");

          if (build_xml == 1) {              
            newChild1 = my_xml.addChild("scenario");
            newChild1.setInt("scenario_id", o + 1); // <<<<<<<<           

            newChild2 = newChild1.addChild("forecast");
            newChild2.setInt("forecast_hour", k);
            newChild2.setString("valid_time", nf(next_YEAR, 4) + nf(next_MONTH, 2) + nf(next_DAY, 2) + nf(next_HOUR, 2));
          } 


          for (int q = 1; q < my_lines.length; q += 1) {
            //println(q, my_lines[q]);

            int _posX = my_lines[q].indexOf("lon=");
            int _posY = my_lines[q].indexOf("lat=");
            int _posZ = my_lines[q].indexOf("val=");

            float uX = Float.valueOf(my_lines[q].substring(_posX + 4, _posY - 1));
            float uY = Float.valueOf(my_lines[q].substring(_posY + 4, _posZ - 1));

            float v = FLOAT_undefined;

            int f = p * MAX_GRIB2_PASS + q;

            float _lon = Points[f][0];
            float _lat = Points[f][1];

            if (_lon < 0) _lon += 360; // << important!

            float d = dist_lon_lat(uX, uY, _lon, _lat);
            if (d > 200000) { // 200km

              println("out of 100km: d =", d);

              println(uX, uY, _lon, _lat);
              println("----------------------------------------");
            } else {
              if (_posZ > 0) {
                v = Float.valueOf(my_lines[q].substring(_posZ + 4));

                //println(v);



                v *= LAYERS_GRIB2_MUL[l];
                v += LAYERS_GRIB2_ADD[l]; // e.g. Kelvin >> C                        

                if (build_xml == 1) {
                  newChild3 = newChild2.addChild("point");
                  newChild3.setInt("id", f); 
                  newChild3.setContent(nf(v, 0, 0));
                }
              }
            }
            theValues[f][o] = v;
          }
        }
      }
    }
  } 

  if (build_xml == 1) { 

    String THE_XML_filename = ExportFolder;
    THE_XML_filename += "/XML_layers/" + GRIB2_Domains[GRIB2_DomainSelection][0];
    THE_XML_filename += "/" + nf(GRIB2_Year, 4) + "_" + nf(GRIB2_Month, 2) + "_" + nf(GRIB2_Day, 2) + "_run" + nf(GRIB2_ModelRun, 2);
    THE_XML_filename += "/" + nfp(AERIAL_Center_Latitude, 2, 3).replace(",", "_").replace(".", "_").replace("+", "N") + nfp(AERIAL_Center_Longitude, 3, 3).replace(",", "_").replace(".", "_").replace("-", "W");
    THE_XML_filename += "/fhr" + nf(k, 3);
    THE_XML_filename += "_" + LAYERS_GRIB2_VAL[l][h];
    THE_XML_filename += ".xml";
    saveXML(my_xml, THE_XML_filename);
  }

  return theValues;
}



float getGrib2Value (int k, int l, int h, float _lon, float _lat) {

  float theValue = FLOAT_undefined;

  String ValueFilename = getWgrib2Filename(k, l, h, _lon, _lat); 

  String ValueFile = Wgrib2TempFolder + "/" + ValueFilename;

  String[] filenames = SOLARCHVISION_getfiles(Wgrib2TempFolder);

  String[] file_lines = {
  };

  int runWgrib2 = 1;

  if (filenames != null) {
    for (int i = 0; i < filenames.length; i++) {
      if (filenames[i].equals(ValueFilename)) {

        file_lines = loadStrings(ValueFile);

        if (file_lines.length > 0) {
          //println("The previous extraction file is found:", ValueFilename);
          runWgrib2 = 0;
        }
      }
    }
  }

  if (runWgrib2 == 1) {
    String Grib2File = getGrib2Folder(GRIB2_DomainSelection) + "/" + getGrib2Filename(k, l, h);

    String CommandArguments[] = {
      "wgrib2", Grib2File.replace('/', char(92)), "-s", "-lon", String.valueOf(_lon), String.valueOf(_lat), ">", ValueFile
    };

    String[] the_command = {
      CommandArguments[0] + " " + CommandArguments[1] + " " + CommandArguments[2] + " " + CommandArguments[3] + " " + CommandArguments[4] + " " + CommandArguments[5] + " " + CommandArguments[6]
    };

    println(CommandArguments);
    launch(CommandArguments);
  } 

  int _stay = 1;

  while ((_stay != 0) && (_stay < 100000)) {

    //println(_stay);

    _stay += 1;

    filenames = SOLARCHVISION_getfiles(Wgrib2TempFolder);

    if (filenames != null) {
      for (int i = 0; i < filenames.length; i++) {
        //println(filenames[i]);

        if (filenames[i].equals(ValueFilename)) {
          //println("The wgrib2 extraction is ready:", ValueFilename);

          file_lines = loadStrings(ValueFile);

          if (file_lines.length > 0) _stay = 0;
        }
      }
    }
  }

  if (_stay != 0) {
    println("The wgrib2 extraction is not ready:", ValueFilename);
  } else {
    //println(file_lines);

    if (file_lines.length > 0) {

      int _posX = file_lines[0].indexOf("lon=");
      int _posY = file_lines[0].indexOf("lat=");
      int _posZ = file_lines[0].indexOf("val=");

      float uX = Float.valueOf(file_lines[0].substring(_posX + 4, _posY - 1));
      float uY = Float.valueOf(file_lines[0].substring(_posY + 4, _posZ - 1));

      if (dist_lon_lat((uX + 360) % 360, (uY + 180) % 180, (_lon + 360) % 360, (_lat + 180) % 180) > 5) { // that means the distance should be less than 5km.
        println(uX, uY, _lat, _lat);
        println((uX + 360) % 360, (uY + 180) % 180, (_lon + 360) % 360, (_lat + 180) % 180);
        println("----------------------------------------");
      } else {
        if (_posZ > 0) {
          theValue = Float.valueOf(file_lines[0].substring(_posZ + 4));

          theValue *= LAYERS_GRIB2_MUL[l];
          theValue += LAYERS_GRIB2_ADD[l]; // e.g. Kelvin >> C
        }
      }
    }
  }

  return(theValue);
}





float[] SOLARCHVISION_calculate_Perspective_Internally (float x, float y, float z) {

  float Image_X = FLOAT_undefined;
  float Image_Y = FLOAT_undefined;
  float Image_Z = -FLOAT_undefined; // negative so that it automatically illuminated by Draw function 


  float px, py, pz;

  x -= WIN3D_CAM_x;
  y -= WIN3D_CAM_y;
  z += WIN3D_CAM_z;

  pz = z;
  px = x * cos_ang(-WIN3D_RZ_Coordinate) - y * sin_ang(-WIN3D_RZ_Coordinate);
  py = x * sin_ang(-WIN3D_RZ_Coordinate) + y * cos_ang(-WIN3D_RZ_Coordinate);

  x = px;
  y = py;
  z = pz;    

  px = x;
  py = y * cos_ang(WIN3D_RX_Coordinate) - z * sin_ang(WIN3D_RX_Coordinate);
  pz = y * sin_ang(WIN3D_RX_Coordinate) + z * cos_ang(WIN3D_RX_Coordinate);

  x = px;
  y = py;
  z = pz;


  if (z > 0) {
    if (WIN3D_ViewType == 1) {

      Image_X = (x / z) * (0.5 * WIN3D_Scale3D / tan(0.5 * WIN3D_CAM_fov)) * WIN3D_refScale;
      Image_Y = -(y / z) * (0.5 * WIN3D_Scale3D / tan(0.5 * WIN3D_CAM_fov)) * WIN3D_refScale;
      Image_Z = z;
    } else {

      float ZOOM = Orthographic_ZOOM();

      Image_X = (x / ZOOM) * (0.5 * WIN3D_Scale3D);
      Image_Y = -(y / ZOOM) * (0.5 * WIN3D_Scale3D);
      Image_Z = z;
    }
  }

  float[] theValues = {
    Image_X, Image_Y, Image_Z
  };

  return theValues;
}




void SOLARCHVISION_draw_Perspective_Internally () {

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {    

    if (selectedLandPoint_displayPoints != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = selectedLandPoint_numbers.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedLandPoint_numbers[o];

        if (OBJ_NUM != 0) {     

          int i = (OBJ_NUM - 1) / LAND_n_J;
          int j = (OBJ_NUM - 1) % LAND_n_J;

          float x = LAND_MESH[i][j][0] * OBJECTS_scale;
          float y = LAND_MESH[i][j][1] * OBJECTS_scale;
          float z = -LAND_MESH[i][j][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View + R, -0.5 * WIN3D_Y_View + R, 0.5 * WIN3D_X_View - R, 0.5 * WIN3D_Y_View - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    if (selectedCamera_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedCamera_numbers[o];

          if (OBJ_NUM != 0) {            

            int f = OBJ_NUM; 

            if ((0 < f) && (f < allCameras_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allCameras_Faces[f].length; j++) {

                int vNo = allCameras_Faces[f][j];

                float x = allCameras_Vertices[vNo][0] * OBJECTS_scale;
                float y = allCameras_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allCameras_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    if (selectedSection_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedSection_numbers[o];

          if (OBJ_NUM != 0) {            

            int f = OBJ_NUM; 

            if ((0 < f) && (f < allSections_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allSections_Faces[f].length; j++) {

                int vNo = allSections_Faces[f][j];

                float x = allSections_Vertices[vNo][0] * OBJECTS_scale;
                float y = allSections_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allSections_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Solids) {

    if (selectedSolid_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedSolid_numbers[o];

          if (OBJ_NUM != 0) {  

            for (int plane_type = 0; plane_type < Solids_DisplayFaces; plane_type++) {          

              int f = (OBJ_NUM - 1) * Solids_DisplayFaces + plane_type + 1; 

              if ((0 < f) && (f < allSolids_Faces.length)) { 

                beginShape();

                for (int j = 0; j < allSolids_Faces[f].length; j++) {

                  int vNo = allSolids_Faces[f][j];

                  float x = allSolids_Vertices[vNo][0] * OBJECTS_scale;
                  float y = allSolids_Vertices[vNo][1] * OBJECTS_scale;
                  float z = -allSolids_Vertices[vNo][2] * OBJECTS_scale;

                  float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                }

                endShape(CLOSE);
              }
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    if (selectedFractal_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedFractal_numbers[o];

          if (OBJ_NUM != 0) {            

            int f = OBJ_NUM; 

            if ((0 < f) && (f < allFractals_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allFractals_Faces[f].length; j++) {

                int vNo = allFractals_Faces[f][j];

                float x = allFractals_Vertices[vNo][0] * OBJECTS_scale;
                float y = allFractals_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allFractals_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    if (selectedObject2D_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

          int OBJ_NUM = selectedObject2D_numbers[o];

          if (OBJ_NUM != 0) {            

            int f = OBJ_NUM; 

            if ((0 < f) && (f < allObject2Ds_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allObject2Ds_Faces[f].length; j++) {

                int vNo = allObject2Ds_Faces[f][j];

                float x = allObject2Ds_Vertices[vNo][0] * OBJECTS_scale;
                float y = allObject2Ds_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allObject2Ds_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Faces) {    

    if (selectedFace_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(127, 0, 255); 
      strokeWeight(2);

      for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

        int f = selectedFace_numbers[o];

        if (f != 0) {

          int Tessellation = allFaces_MTLV[f][1];

          int TotalSubNo = 1;  
          if (allFaces_MTLV[f][0] == 0) {
            Tessellation += MODEL3D_Tessellation;
          }
          if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

          float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
          for (int j = 0; j < allFaces_PNT[f].length; j++) {
            int vNo = allFaces_PNT[f][j];
            base_Vertices[j][0] = allVertices[vNo][0];
            base_Vertices[j][1] = allVertices[vNo][1];
            base_Vertices[j][2] = allVertices[vNo][2];
          }

          for (int n = 0; n < TotalSubNo; n++) {

            float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

            beginShape();

            for (int s = 0; s < subFace.length; s++) {

              float x = subFace[s][0] * OBJECTS_scale;
              float y = subFace[s][1] * OBJECTS_scale;            
              float z = -subFace[s][2] * OBJECTS_scale;

              float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }


    if (selectedFace_displayVertexCount != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      fill(0);

      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

        int f = selectedFace_numbers[o];

        if (f != 0) {

          for (int j = 0; j < allFaces_PNT[f].length; j++) {
            int vNo = allFaces_PNT[f][j];

            float x = allVertices[vNo][0] * OBJECTS_scale;
            float y = allVertices[vNo][1] * OBJECTS_scale;            
            float z = -allVertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
              }
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }


  if (Current_ObjectCategory == ObjectCategory_Vertices) {    

    if (selectedVertex_displayVertices != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = selectedVertex_numbers.length - 1; o >= 0; o--) {

        int vNo = selectedVertex_numbers[o];

        if (vNo != 0) {        

          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;
          float z = -allVertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View + R, -0.5 * WIN3D_Y_View + R, 0.5 * WIN3D_X_View - R, 0.5 * WIN3D_Y_View - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  



  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {    

    if (selectedVertex_displayVertices != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      strokeWeight(0);

      ellipseMode(CENTER);

      float R = 5;

      for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {

        int vNo = selectedVertex_softSelectionVertices[q];

        float _u = selectedVertex_softSelectionValues[q];    

        if (vNo != 0) {        

          float x = allVertices[vNo][0] * OBJECTS_scale;
          float y = allVertices[vNo][1] * OBJECTS_scale;
          float z = -allVertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View + R, -0.5 * WIN3D_Y_View + R, 0.5 * WIN3D_X_View - R, 0.5 * WIN3D_Y_View - R) == 1) {

              float[] COL = SOLARCHVISION_GET_COLOR_STYLE(14, _u); // <<<<<<<<<<<<<<<<<
              fill(COL[1], COL[2], COL[3], COL[0]);
              stroke(COL[1], COL[2], COL[3], COL[0]); 

              ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    



  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {    

    if (selectedGroup3D_displayEdges != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(127); 
      strokeWeight(2);

      for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedGroup3D_numbers[o];

        if (OBJ_NUM != 0) {

          for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {
            if ((0 < f) && (f < allFaces_PNT.length)) { 

              int Tessellation = allFaces_MTLV[f][1];

              int TotalSubNo = 1;  
              if (allFaces_MTLV[f][0] == 0) {
                Tessellation += MODEL3D_Tessellation;
              }
              if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));

              float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
              for (int j = 0; j < allFaces_PNT[f].length; j++) {
                int vNo = allFaces_PNT[f][j];
                base_Vertices[j][0] = allVertices[vNo][0];
                base_Vertices[j][1] = allVertices[vNo][1];
                base_Vertices[j][2] = allVertices[vNo][2];
              }

              for (int n = 0; n < TotalSubNo; n++) {

                float[][] subFace = getSubFace(base_Vertices, Tessellation, n);

                beginShape();

                for (int s = 0; s < subFace.length; s++) {

                  float x = subFace[s][0] * OBJECTS_scale;
                  float y = subFace[s][1] * OBJECTS_scale;            
                  float z = -subFace[s][2] * OBJECTS_scale;

                  float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                }

                endShape(CLOSE);
              }
            }
          }

          for (int f = allGroup3Ds_Fractals[OBJ_NUM][0]; f <= allGroup3Ds_Fractals[OBJ_NUM][1]; f++) {

            if ((0 < f) && (f < allFractals_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allFractals_Faces[f].length; j++) {

                int vNo = allFractals_Faces[f][j];

                float x = allFractals_Vertices[vNo][0] * OBJECTS_scale;
                float y = allFractals_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allFractals_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }


          for (int f = allGroup3Ds_Object2Ds[OBJ_NUM][0]; f <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; f++) {

            if ((0 < f) && (f < allObject2Ds_Faces.length)) { 

              beginShape();

              for (int j = 0; j < allObject2Ds_Faces[f].length; j++) {

                int vNo = allObject2Ds_Faces[f][j];

                float x = allObject2Ds_Vertices[vNo][0] * OBJECTS_scale;
                float y = allObject2Ds_Vertices[vNo][1] * OBJECTS_scale;
                float z = -allObject2Ds_Vertices[vNo][2] * OBJECTS_scale;

                float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }

          for (int q = allGroup3Ds_Solids[OBJ_NUM][0]; q <= allGroup3Ds_Solids[OBJ_NUM][1]; q++) {

            if ((0 < q) && (q < allSolids_Faces.length)) {

              for (int plane_type = 0; plane_type < Solids_DisplayFaces; plane_type++) {          

                int f = (q - 1) * Solids_DisplayFaces + plane_type + 1; 

                if ((0 < f) && (f < allSolids_Faces.length)) {               

                  beginShape();

                  for (int j = 0; j < allSolids_Faces[f].length; j++) {

                    int vNo = allSolids_Faces[f][j];

                    float x = allSolids_Vertices[vNo][0] * OBJECTS_scale;
                    float y = allSolids_Vertices[vNo][1] * OBJECTS_scale;
                    float z = -allSolids_Vertices[vNo][2] * OBJECTS_scale;

                    float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

                    if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                      if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                    }
                  }

                  endShape(CLOSE);
                }
              }
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }


    if (selectedGroup3D_displayBox != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(0, 127, 0, 127);
      strokeWeight(2);

      int keep_selection_alignX = selection_alignX;
      int keep_selection_alignY = selection_alignY;
      int keep_selection_alignZ = selection_alignZ;

      selection_alignX = 0; // apply the centre
      selection_alignY = 0; // apply the centre
      selection_alignZ = 0; // apply the centre

      float[] P = SOLARCHVISION_getPivot();

      float posX = P[0];
      float posY = P[1];
      float posZ = P[2];

      float posX_min = SOLARCHVISION_selection_BoundingBox[0][0];
      float posY_min = SOLARCHVISION_selection_BoundingBox[0][1];
      float posZ_min = SOLARCHVISION_selection_BoundingBox[0][2];

      float posX_max = SOLARCHVISION_selection_BoundingBox[2][0];
      float posY_max = SOLARCHVISION_selection_BoundingBox[2][1];
      float posZ_max = SOLARCHVISION_selection_BoundingBox[2][2];

      float[][] BoundingBox_Vertices = {
        {
          posX_min, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_max, posZ_max
        }
        , 
        {
          posX_min, posY_max, posZ_max
        }
      }; 


      for (int i = 0; i < BoundingBox_Vertices.length; i++) {

        float x = BoundingBox_Vertices[i][0] - posX;
        float y = BoundingBox_Vertices[i][1] - posY;
        float z = BoundingBox_Vertices[i][2] - posZ;

        float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2]; 

        BoundingBox_Vertices[i][0] = x;
        BoundingBox_Vertices[i][1] = y;
        BoundingBox_Vertices[i][2] = z;
      }                                     

      int[][] BoundingBox_Faces = {
        {
          3, 2, 1, 0
        }
        , {
          0, 1, 5, 4
        }
        , {
          1, 2, 6, 5
        }
        , {
          2, 3, 7, 6
        }
        , {
          3, 0, 4, 7
        }
        , {
          4, 5, 6, 7
        }
      };

      for (int f = 0; f < BoundingBox_Faces.length; f++) {

        beginShape();

        for (int g = 0; g < BoundingBox_Faces[f].length; g++) {

          int vNo = BoundingBox_Faces[f][g];

          float x = BoundingBox_Vertices[vNo][0] * OBJECTS_scale;
          float y = BoundingBox_Vertices[vNo][1] * OBJECTS_scale;            
          float z = -BoundingBox_Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = SOLARCHVISION_calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
          }
        }
        endShape(CLOSE);
      }

      strokeWeight(0);   

      popMatrix();


      selection_alignX = keep_selection_alignX;
      selection_alignY = keep_selection_alignY;
      selection_alignZ = keep_selection_alignZ;
    }  




    if (selectedGroup3D_displayPivot != 0) {

      pushMatrix();

      translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

      noFill();

      stroke(255, 127, 0, 127); 

      strokeWeight(5);

      for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

        int OBJ_NUM = selectedGroup3D_numbers[o];

        if (OBJ_NUM != 0) {

          float[][] Pivot_Vertices = {
            {
              0, 0, 0
            }
            , 
            {
              1, 0, 0
            }
            , 
            {
              0, 1, 0
            }
            , 
            {
              0, 0, 1
            }
          }; 


          float x0 = allGroup3Ds_PivotXYZ[OBJ_NUM][0];
          float y0 = allGroup3Ds_PivotXYZ[OBJ_NUM][1];
          float z0 = allGroup3Ds_PivotXYZ[OBJ_NUM][2];

          for (int i = 0; i < Pivot_Vertices.length; i++) {

            float x = Pivot_Vertices[i][0];
            float y = Pivot_Vertices[i][1];
            float z = Pivot_Vertices[i][2];

            float r = 10; // <<<<<<<<< display size

            x *= r;
            y *= r;
            z *= r;

            float[] O = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
            float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

            float dx = A[0] - O[0];
            float dy = A[1] - O[1];
            float dz = A[2] - O[2];

            Pivot_Vertices[i][0] = x0 + dx;
            Pivot_Vertices[i][1] = y0 + dy;
            Pivot_Vertices[i][2] = z0 + dz;
          }


          int[][] Pivot_Lines = {
            {
              0, 1
            }
            , {
              0, 2
            }
            , {
              0, 3
            }
          };

          int f_start = 0;
          int f_end = Pivot_Lines.length - 1;

          if (allGroup3Ds_PivotType[OBJ_NUM][0] == 1) {
            f_start = 0; 
            f_end = f_start;
          }
          if (allGroup3Ds_PivotType[OBJ_NUM][0] == 2) {
            f_start = 1; 
            f_end = f_start;
          }
          if (allGroup3Ds_PivotType[OBJ_NUM][0] == 3) {
            f_start = 2; 
            f_end = f_start;
          }

          for (int f = f_start; f <= f_end; f++) {

            int a = Pivot_Lines[f][0];
            int b = Pivot_Lines[f][1];

            float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
            float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
            float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

            float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
            float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
            float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

            float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1, y1, z1);            
            float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2, y2, z2);

            if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
                  line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
                }
              }
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }



  if (selected_displayReferencePivot != 0) {

    pushMatrix();

    translate(WIN3D_CX_View + 0.5 * WIN3D_X_View, WIN3D_CY_View + 0.5 * WIN3D_Y_View);  

    noFill();

    strokeWeight(2);

    float[][] Pivot_Vertices = {
      {
        0, 0, 0
      }
      , 
      {
        1, 0, 0
      }
      , 
      {
        0, 1, 0
      }
      , 
      {
        0, 0, 1
      }
    }; 

    float[] P = SOLARCHVISION_getPivot();

    float x0 = P[0];
    float y0 = P[1];
    float z0 = P[2];

    for (int i = 0; i < Pivot_Vertices.length; i++) {

      float x = Pivot_Vertices[i][0];
      float y = Pivot_Vertices[i][1];
      float z = Pivot_Vertices[i][2];

      float r = 5; // <<<<<<<<< display size

      x *= r;
      y *= r;
      z *= r;

      float[] O = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
      float[] A = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      float dx = A[0] - O[0];
      float dy = A[1] - O[1];
      float dz = A[2] - O[2];

      Pivot_Vertices[i][0] = x0 + dx;
      Pivot_Vertices[i][1] = y0 + dy;
      Pivot_Vertices[i][2] = z0 + dz;
    }

    int[][] Pivot_Lines = {
      {
        0, 1
      }
      , {
        0, 2
      }
      , {
        0, 3
      }
    };


    for (int f = 0; f < Pivot_Lines.length; f++) {

      if (f == 0) stroke(255, 0, 0);
      if (f == 1) stroke(0, 0, 255);
      if (f == 2) stroke(127, 127, 0);

      int a = Pivot_Lines[f][0];
      int b = Pivot_Lines[f][1];

      float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
      float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
      float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

      float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
      float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
      float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

      float[] Image_XYZa = SOLARCHVISION_calculate_Perspective_Internally(x1, y1, z1);            
      float[] Image_XYZb = SOLARCHVISION_calculate_Perspective_Internally(x2, y2, z2);

      if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
          if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D_X_View, -0.5 * WIN3D_Y_View, 0.5 * WIN3D_X_View, 0.5 * WIN3D_Y_View) == 1) {
            line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
          }
        }
      }
    }

    strokeWeight(0);   

    popMatrix();
  }
}






float[] SOLARCHVISION_calculate_Click3D (float Image_X, float Image_Y) {

  float PNT_x = FLOAT_undefined;
  float PNT_y = FLOAT_undefined;
  float PNT_z = FLOAT_undefined;

  if (WIN3D_ViewType == 1) {

    PNT_z = (0.5 * WIN3D_refScale) / tan(0.5 * PI / 3.0); //100; // for perspective: any value the plane we need the results on!

    PNT_x = PNT_z * Image_X / ((0.5 * WIN3D_Scale3D / tan(0.5 * WIN3D_CAM_fov)) * WIN3D_refScale);
    PNT_y = PNT_z * -Image_Y / ((0.5 * WIN3D_Scale3D / tan(0.5 * WIN3D_CAM_fov)) * WIN3D_refScale);
  } else {
    float ZOOM = Orthographic_ZOOM();

    PNT_z = (0.5 * WIN3D_refScale) / tan(0.5 * PI / 3.0); // for orthographic: should be this.

    PNT_x = ZOOM * Image_X / (0.5 * WIN3D_Scale3D);
    PNT_y = ZOOM * -Image_Y / (0.5 * WIN3D_Scale3D);
  }

  float px, py, pz;

  px = PNT_x;
  py = PNT_y * cos_ang(-WIN3D_RX_Coordinate) - PNT_z * sin_ang(-WIN3D_RX_Coordinate);
  pz = PNT_y * sin_ang(-WIN3D_RX_Coordinate) + PNT_z * cos_ang(-WIN3D_RX_Coordinate);

  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;

  pz = PNT_z;
  px = PNT_x * cos_ang(WIN3D_RZ_Coordinate) - PNT_y * sin_ang(WIN3D_RZ_Coordinate);
  py = PNT_x * sin_ang(WIN3D_RZ_Coordinate) + PNT_y * cos_ang(WIN3D_RZ_Coordinate);

  PNT_x = px;
  PNT_y = py;
  PNT_z = pz;    

  PNT_x += WIN3D_CAM_x;
  PNT_y += WIN3D_CAM_y;
  PNT_z -= WIN3D_CAM_z;  

  float[] return_array = {
    PNT_x, PNT_y, -PNT_z
  };

  return return_array;
}







String NearLatitude_Stamp () {

  int Round_Latitude = int(roundTo(LocationLatitude, 5));
  if (Round_Latitude > 70) Round_Latitude = 70; // <<<<<<<<<<<<<<<
  if (Round_Latitude < -45) Round_Latitude = -45; // <<<<<<<<<<<<<<<

  String a = nf(abs(Round_Latitude), 2);

  if (Round_Latitude < 0) a += "S";
  else a += "N";

  return a;
}



String Section_Stamp () {

  String s = "";

  s += "t" + nf(SolidImpact_sectionType, 0);
  s += "u" + nf(SolarImpact_offset_U, 0, 3);
  s += "v" + nf(SolarImpact_offset_V, 0, 3);
  s += "w" + nf(SolarImpact_Elevation, 0, 3);
  s += "r" + nf(SolarImpact_Rotation, 0, 3);  

  s = s.replace('.', 'p');
  s = s.replace('-', 'n');

  return s;
}


String Viewport_Stamp () {

  String s = "";
  
  /*

  s += "x" + nf(WIN3D_X_Coordinate, 0, 3);
  s += "y" + nf(WIN3D_Y_Coordinate, 0, 3);
  s += "z" + nf(WIN3D_Z_Coordinate, 0, 3);

  s += "rx" + nf(WIN3D_RX_Coordinate, 0, 3);
  s += "ry" + nf(WIN3D_RY_Coordinate, 0, 3);
  s += "rz" + nf(WIN3D_RZ_Coordinate, 0, 3);
  
  s = s.replace('.', 'p');
  s = s.replace('-', 'n');
  
  */

  return s;
}


PGraphics SHADOW_Diagrams; // to be accessible to Fractal plants

String defaultSceneName = "Complex";
String SceneName = defaultSceneName;

void SOLARCHVISION_render_Shadows_CurrentSection () {

  cursor(WAIT);  

  SceneName = "temp_" + Section_Stamp();


  int RES1 = SolarImpact_RES1;
  int RES2 = SolarImpact_RES2;

  float Shades_scaleX = RES1 / SolarImpact_scale_U;
  float Shades_scaleY = RES2 / SolarImpact_scale_V;

  float Shades_offsetX = SolarImpact_offset_U;
  float Shades_offsetY = SolarImpact_offset_V; 


  SHADOW_Diagrams = createGraphics(RES1, RES2, P2D); 

  PGraphics TREES_Diagrams = createGraphics(RES1, RES2, P2D);

  int keep_SolarImpact_sectionType = SolarImpact_sectionType;
  float keep_SolarImpact_Rotation = SolarImpact_Rotation;

  if (SolarImpact_sectionType == 3) {
    SolarImpact_sectionType = 2;
    SolarImpact_Rotation = 90 - SolarImpact_Rotation;
  }

  {  
    int RAD_TYPE = 0;

    for (int DATE_ANGLE = 0; DATE_ANGLE < 360; DATE_ANGLE += 15) {

      //for (int i = 0; i < 24; i += 1) {
      for (int i = 4; i <= 20; i += 1) { // to make it faster. Also the images are not needed out of this period.

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);
        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);

          SunR_Rotated_check = 2;
        } else if (SolarImpact_sectionType == 3) {
        }

        for (int SHD = 0; SHD <= 1; SHD += 1) {

          String[] STR_SHD = {
            "F", "T"
          };
          String File_Name = "";

          File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";

          File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);

          File_Name += "_" +  SceneName + "_" + NearLatitude_Stamp() + "_Camera00";

          TREES_Diagrams.beginDraw();

          TREES_Diagrams.blendMode(REPLACE);

          TREES_Diagrams.fill(255); 
          TREES_Diagrams.stroke(255);
          TREES_Diagrams.strokeWeight(0);
          TREES_Diagrams.rectMode(CORNER);
          TREES_Diagrams.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            TREES_Diagrams.pushMatrix();
            TREES_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

            TREES_Diagrams.stroke(0); 
            TREES_Diagrams.fill(0);     

            TREES_Diagrams.blendMode(BLEND);        

            if (Display_Model2Ds != 0) {

              for (int f = 1; f <= allObject2Ds_num; f++) {

                int n = abs(allObject2Ds_MAP[f]);

                int w = Object2D_Images[n].width; 
                int h = Object2D_Images[n].height;

                float r = allObject2Ds_XYZS[f][3] * 0.5;

                float t = atan2(SunR[2], SunR[1]) + 0.5 * PI; 

                if (allObject2Ds_MAP[f] < 0) t += PI;         

                if (r > 2.5) { // to select only trees!               

                  float x = 0, y = 0, z = 0;

                  { // Vertical mask
                    TREES_Diagrams.beginShape();

                    TREES_Diagrams.texture(Object2D_Images[n]); 

                    x = allObject2Ds_XYZS[f][0];
                    y = allObject2Ds_XYZS[f][1];
                    z = allObject2Ds_XYZS[f][2];

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z; 
                    TX[2] = x + r * cos(t); 
                    TY[2] = y + r * sin(t); 
                    TZ[2] = z + 2 * r; 
                    TX[3] = x - r * cos(t); 
                    TY[3] = y - r * sin(t); 
                    TZ[3] = z + 2 * r;            

                    TU[0] = 0; 
                    TV[0] = h;
                    TU[1] = w; 
                    TV[1] = h;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (SolarImpact_sectionType == 2) {
                      {
                        for (int q = 0; q < 4; q++) {
                          float a = TX[q];
                          float b = -TY[q];
                          float c = TZ[q];

                          TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                          TY[q] = c;
                          TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                        }
                      } 
                      { // now that we rotated 2D we could rotate x,y,z
                        float a = x;
                        float b = -y;
                        float c = z;

                        x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        y = c;
                        z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }
                    } else if (SolarImpact_sectionType == 3) {
                    }

                    if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {

                      float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                      TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                      TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                      if (SolarImpact_sectionType == 1) {

                        TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                        TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                      } else if (SolarImpact_sectionType == 2) {

                        TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                        TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }

                    if (TZ[2] > SolarImpact_Elevation) {

                      for (int q = 0; q < 4; q++) {

                        TZ[q] = TZ[q] - SolarImpact_Elevation;
                        TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                        TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                        if (SolarImpact_sectionType == 1) {
                          float px = TX[q];
                          float py = TY[q];

                          TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                          

                        TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                      }
                    }

                    TREES_Diagrams.endShape(CLOSE);
                  }

                  { // Horizontal mask
                    float ratio = 0.5; // put the mask at half of the height of the tree 

                    for (int back_front = -1; back_front <= 1; back_front += 2) {

                      float rot = back_front * PI / 2 + t;

                      TREES_Diagrams.beginShape();

                      TREES_Diagrams.texture(Object2D_Images[n]); 

                      x = allObject2Ds_XYZS[f][0];
                      y = allObject2Ds_XYZS[f][1];
                      z = allObject2Ds_XYZS[f][2];                      

                      float[] TX = {
                        0, 0, 0, 0
                      };
                      float[] TY = {
                        0, 0, 0, 0
                      };
                      float[] TZ = {
                        0, 0, 0, 0
                      };
                      float[] TU = {
                        0, 0, 0, 0
                      };
                      float[] TV = {
                        0, 0, 0, 0
                      };

                      TX[0] = x - r * cos(t); 
                      TY[0] = y - r * sin(t); 
                      TZ[0] = z + 2 * r * ratio; 
                      TX[1] = x + r * cos(t); 
                      TY[1] = y + r * sin(t); 
                      TZ[1] = z + 2 * r * ratio; 
                      TX[2] = x + r * cos(t) + r * cos(rot); 
                      TY[2] = y + r * sin(t) + r * sin(rot); 
                      TZ[2] = z + 2 * r * ratio; 
                      TX[3] = x - r * cos(t) + r * cos(rot); 
                      TY[3] = y - r * sin(t) + r * sin(rot); 
                      TZ[3] = z + 2 * r * ratio;    

                      TU[0] = 0; 
                      TV[0] = h * ratio;
                      TU[1] = w; 
                      TV[1] = h * ratio;
                      TU[2] = w; 
                      TV[2] = 0;
                      TU[3] = 0; 
                      TV[3] = 0;   

                      if (SolarImpact_sectionType == 1) {

                        if (z + 2 * r * ratio > SolarImpact_Elevation) {

                          for (int q = 0; q < 4; q++) {

                            TZ[q] = TZ[q] - SolarImpact_Elevation;
                            TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                            TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);  

                            if (SolarImpact_sectionType == 1) {
                              float px = TX[q];
                              float py = TY[q];

                              TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            }                            

                            TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                          }
                        }
                      }

                      TREES_Diagrams.endShape(CLOSE);
                    }
                  }
                }
              }
            }

            TREES_Diagrams.popMatrix();
          }


          TREES_Diagrams.endDraw();     

          TREES_Diagrams.save(File_Name + "_2D.JPG");



          SHADOW_Diagrams.beginDraw();

          SHADOW_Diagrams.blendMode(REPLACE);

          float _val = 0;
          if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
          SHADOW_Diagrams.fill(255 * _val); 
          SHADOW_Diagrams.stroke(255 * _val);
          SHADOW_Diagrams.strokeWeight(0);
          SHADOW_Diagrams.rectMode(CORNER);
          SHADOW_Diagrams.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            SHADOW_Diagrams.pushMatrix();
            SHADOW_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

            SHADOW_Diagrams.stroke(0); 
            SHADOW_Diagrams.fill(0);              

            if (Display_Model3Ds != 0) {

              for (int f = 1; f < allFaces_PNT.length; f++) {
  
                int vsb = allFaces_MTLV[f][3];
  
                if (vsb > 0) {
  
                  int  mt = allFaces_MTLV[f][0];
                  if (Materials_Color[mt][0] > 127) {
  
                    int Tessellation = allFaces_MTLV[f][1];
  
                    int TotalSubNo = 1;  
                    if (allFaces_MTLV[f][0] == 0) {
                      Tessellation += MODEL3D_Tessellation;
                    }
                    if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
                    float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
                    for (int g = 0; g < allFaces_PNT[f].length; g++) {
                      int vNo = allFaces_PNT[f][g];
                      base_Vertices[g][0] = allVertices[vNo][0];
                      base_Vertices[g][1] = allVertices[vNo][1];
                      base_Vertices[g][2] = allVertices[vNo][2];
                    }
  
                    for (int n = 0; n < TotalSubNo; n++) {
  
                      float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                      float[][] subFace_Rotated = subFace;
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
                        if (SolarImpact_sectionType == 2) {
                          float a = subFace_Rotated[s][0];
                          float b = -subFace_Rotated[s][1];
                          float c = subFace_Rotated[s][2];
  
                          subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                          subFace_Rotated[s][1] = c;    
                          subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                        } else if (SolarImpact_sectionType == 3) {
                        }
                      }  
  
                      SHADOW_Diagrams.beginShape();
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
  
                        float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                        float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                        float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
  
  
                        if (z >= 0) {
  
                          if (SolarImpact_sectionType == 1) {                    
                            float px = x;
                            float py = y;
  
                            x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 
  
                          SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                        } else {
                          int s_next = (s + 1) % subFace_Rotated.length;
                          int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                          float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                          float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_prev > 0) { 
                            float ratio = z_prev / (z_prev - z);
  
                            float x_trim = x_prev * (1 - ratio) + x * ratio;
                            float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                            if (SolarImpact_sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            } 
  
                            SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
  
                          float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                          float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_next > 0) { 
                            float ratio = z_next / (z_next - z);
  
                            float x_trim = x_next * (1 - ratio) + x * ratio;
                            float y_trim = y_next * (1 - ratio) + y * ratio;
  
                            if (SolarImpact_sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                              y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                            } 
  
                            SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
                        }
                      }
  
                      SHADOW_Diagrams.endShape(CLOSE);
                    }
                  }
                }
              }
            }
            

            if (Display_LAND_MESH != 0) {
              
              int Tessellation = LAND_TESSELLATION;
              if (WIN3D_FacesShade == Shade_Surface_Base) {
                Tessellation = 0;
              }
        
              int TotalSubNo = 1;  
              if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
        
        
              for (int Li = Skip_LAND_MESH_Center; Li < LAND_n_I - 1; Li += 1) {
                for (int Lj = 0; Lj < LAND_n_J - 1; Lj += 1) {
        
                  float[][] base_Vertices = new float [4][3];
        
                  base_Vertices[0][0] = LAND_MESH[Li][Lj][0];
                  base_Vertices[0][1] = LAND_MESH[Li][Lj][1];
                  base_Vertices[0][2] = LAND_MESH[Li][Lj][2];
        
                  base_Vertices[1][0] = LAND_MESH[Li+1][Lj][0];
                  base_Vertices[1][1] = LAND_MESH[Li+1][Lj][1];
                  base_Vertices[1][2] = LAND_MESH[Li+1][Lj][2];
        
                  base_Vertices[2][0] = LAND_MESH[Li+1][Lj+1][0];
                  base_Vertices[2][1] = LAND_MESH[Li+1][Lj+1][1];
                  base_Vertices[2][2] = LAND_MESH[Li+1][Lj+1][2];
        
                  base_Vertices[3][0] = LAND_MESH[Li][Lj+1][0];
                  base_Vertices[3][1] = LAND_MESH[Li][Lj+1][1];
                  base_Vertices[3][2] = LAND_MESH[Li][Lj+1][2];        
        
                  for (int n = 0; n < TotalSubNo; n++) {

                    float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;

                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (SolarImpact_sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];

                        subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                        subFace_Rotated[s][1] = c;    
                        subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }  

                    SHADOW_Diagrams.beginShape();

                    for (int s = 0; s < subFace_Rotated.length; s++) {

                      float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                      if (z >= 0) {

                        if (SolarImpact_sectionType == 1) {                    
                          float px = x;
                          float py = y;

                          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                        float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);

                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;

                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 

                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }

                        float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);

                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;

                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          } 

                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }

                    SHADOW_Diagrams.endShape(CLOSE);
                  }
                }
              }
            }
            
            

            //now calculating Fractal plants
            if (Display_Fractals != 0) {

              for (int f = 1; f <= allFractals_num; f++) {

                float x = allFractals_XYZSR[f][0];
                float y = allFractals_XYZSR[f][1];
                float z = allFractals_XYZSR[f][2];

                float r = allFractals_XYZSR[f][3] * 0.5;
                float rot = allFractals_XYZSR[f][4];      

                int n = allFractals_Type[f];

                int dMin = allFractals_DegreeMin[f];

                int dMax = allFractals_DegreeMax[f];

                int s = allFractals_Seed[f];

                float TrunkSize = allFractals_TrunkSize[f];

                float LeafSize = allFractals_LeafSize[f];

                randomSeed(s);

                if (n == 0) {

                  float Alpha = 0;
                  float Beta = rot; 

                  SOLARCHVISION_Plant_branch_SHADOW(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
                }
              }
            }            

            SHADOW_Diagrams.popMatrix();
          }


          SHADOW_Diagrams.save(File_Name + "3D_.JPG"); //just to test   

          if (Display_Model2Ds != 0) {

            PImage img = loadImage(File_Name + "_2D.JPG");

            img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

            SHADOW_Diagrams.blendMode(DARKEST); 

            SHADOW_Diagrams.tint(255, 255);

            SHADOW_Diagrams.image(img, 0, 0, RES1, RES2);

            SHADOW_Diagrams.noTint();
          }  

          SHADOW_Diagrams.endDraw();        


          SHADOW_Diagrams.save(File_Name + ".PNG");
        }
      }
    }
  }


  {
    int RAD_TYPE = 1;

    for (int SHD = 0; SHD <= 1; SHD += 1) {

      String[] STR_SHD = {
        "F", "T"
      };
      String File_Name = "";

      File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";

      File_Name += "DIF_" + STR_SHD[SHD];

      for (int i = 1; i < skyFaces.length; i++) {

        float[] SunR= {
          0, 0, 0, 0
        };

        for (int j = 0; j < skyFaces[i].length; j++) {
          SunR[1] += skyVertices[skyFaces[i][j]][0] / float(skyFaces[i].length);
          SunR[2] += skyVertices[skyFaces[i][j]][1] / float(skyFaces[i].length);
          SunR[3] += skyVertices[skyFaces[i][j]][2] / float(skyFaces[i].length);
        }

        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (SolarImpact_sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);

          SunR_Rotated_check = 2;
        } else if (SolarImpact_sectionType == 3) {
        }


        //------------------------------------ start of copy & paste from the direct version!
        TREES_Diagrams.beginDraw();

        TREES_Diagrams.blendMode(REPLACE);

        TREES_Diagrams.fill(255); 
        TREES_Diagrams.stroke(255);
        TREES_Diagrams.strokeWeight(0);
        TREES_Diagrams.rectMode(CORNER);
        TREES_Diagrams.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          TREES_Diagrams.pushMatrix();
          TREES_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

          TREES_Diagrams.stroke(0); 
          TREES_Diagrams.fill(0);     

          TREES_Diagrams.blendMode(BLEND);        

          if (Display_Model2Ds != 0) {

            for (int f = 1; f <= allObject2Ds_num; f++) {

              int n = abs(allObject2Ds_MAP[f]);

              int w = Object2D_Images[n].width; 
              int h = Object2D_Images[n].height;

              float r = allObject2Ds_XYZS[f][3] * 0.5;

              float t = atan2(SunR[2], SunR[1]) + 0.5 * PI;

              if (allObject2Ds_MAP[f] < 0) t += PI;         

              if (r > 2.5) { // to select only trees!               

                float x = allObject2Ds_XYZS[f][0];
                float y = allObject2Ds_XYZS[f][1];
                float z = allObject2Ds_XYZS[f][2];

                { // Vertical mask
                  TREES_Diagrams.beginShape();

                  TREES_Diagrams.texture(Object2D_Images[n]); 

                  x = allObject2Ds_XYZS[f][0];
                  y = allObject2Ds_XYZS[f][1];
                  z = allObject2Ds_XYZS[f][2];

                  float[] TX = {
                    0, 0, 0, 0
                  };
                  float[] TY = {
                    0, 0, 0, 0
                  };
                  float[] TZ = {
                    0, 0, 0, 0
                  };
                  float[] TU = {
                    0, 0, 0, 0
                  };
                  float[] TV = {
                    0, 0, 0, 0
                  };

                  TX[0] = x - r * cos(t); 
                  TY[0] = y - r * sin(t); 
                  TZ[0] = z; 
                  TX[1] = x + r * cos(t); 
                  TY[1] = y + r * sin(t); 
                  TZ[1] = z; 
                  TX[2] = x + r * cos(t); 
                  TY[2] = y + r * sin(t); 
                  TZ[2] = z + 2 * r; 
                  TX[3] = x - r * cos(t); 
                  TY[3] = y - r * sin(t); 
                  TZ[3] = z + 2 * r;            

                  TU[0] = 0; 
                  TV[0] = h;
                  TU[1] = w; 
                  TV[1] = h;
                  TU[2] = w; 
                  TV[2] = 0;
                  TU[3] = 0; 
                  TV[3] = 0;   

                  if (SolarImpact_sectionType == 2) {
                    {
                      for (int q = 0; q < 4; q++) {
                        float a = TX[q];
                        float b = -TY[q];
                        float c = TZ[q];

                        TX[q] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                        TY[q] = c;
                        TZ[q] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      }
                    } 
                    { // now that we rotated 2D we could rotate x,y,z
                      float a = x;
                      float b = -y;
                      float c = z;

                      x = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);
                      y = c;
                      z = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                    }
                  } else if (SolarImpact_sectionType == 3) {
                  }

                  if ((TZ[0] < SolarImpact_Elevation) && (SolarImpact_Elevation < TZ[2])) {

                    float ratio = (SolarImpact_Elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                    TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                    TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                    if (SolarImpact_sectionType == 1) {

                      TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                      TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                    } else if (SolarImpact_sectionType == 2) {

                      TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                      TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                    } else if (SolarImpact_sectionType == 3) {
                    }
                  }

                  if (TZ[2] > SolarImpact_Elevation) {

                    for (int q = 0; q < 4; q++) {

                      TZ[q] = TZ[q] - SolarImpact_Elevation;
                      TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                      TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                      if (SolarImpact_sectionType == 1) {
                        float px = TX[q];
                        float py = TY[q];

                        TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      }                          

                      TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                    }
                  }

                  TREES_Diagrams.endShape(CLOSE);
                }

                { // Horizontal mask
                  float ratio = 0.5; // put the mask at half of the height of the tree 

                  for (int back_front = -1; back_front <= 1; back_front += 2) {

                    float rot = back_front * PI / 2 + t;

                    TREES_Diagrams.beginShape();

                    TREES_Diagrams.texture(Object2D_Images[n]); 

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z + 2 * r * ratio; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z + 2 * r * ratio; 
                    TX[2] = x + r * cos(t) + r * cos(rot); 
                    TY[2] = y + r * sin(t) + r * sin(rot); 
                    TZ[2] = z + 2 * r * ratio; 
                    TX[3] = x - r * cos(t) + r * cos(rot); 
                    TY[3] = y - r * sin(t) + r * sin(rot); 
                    TZ[3] = z + 2 * r * ratio;    

                    TU[0] = 0; 
                    TV[0] = h * ratio;
                    TU[1] = w; 
                    TV[1] = h * ratio;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (SolarImpact_sectionType == 1) {
                      if (z + 2 * r * ratio > SolarImpact_Elevation) {

                        for (int q = 0; q < 4; q++) {

                          TZ[q] = TZ[q] - SolarImpact_Elevation;
                          TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                          TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);                  

                          if (SolarImpact_sectionType == 1) {
                            float px = TX[q];
                            float py = TY[q];

                            TX[q] = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            TY[q] = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }      

                          TREES_Diagrams.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                        }
                      }
                    }

                    TREES_Diagrams.endShape(CLOSE);
                  }
                }
              }
            }
          }

          TREES_Diagrams.popMatrix();
        }


        TREES_Diagrams.endDraw();
        //------------------------------------ end of copy & paste from the direct version!

        TREES_Diagrams.save(File_Name + nf(i, 3) + "_2D.JPG");



        SHADOW_Diagrams.beginDraw();

        SHADOW_Diagrams.blendMode(REPLACE);

        float _val = 0;
        if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
        SHADOW_Diagrams.fill(255 * _val); 
        SHADOW_Diagrams.stroke(255 * _val);
        SHADOW_Diagrams.strokeWeight(0);
        SHADOW_Diagrams.rectMode(CORNER);
        SHADOW_Diagrams.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          SHADOW_Diagrams.pushMatrix();
          SHADOW_Diagrams.translate(SolarImpact_RES1 / 2, SolarImpact_RES2 / 2);            

          SHADOW_Diagrams.stroke(0); 
          SHADOW_Diagrams.fill(0);
          
          if (Display_Model3Ds != 0) {

            for (int f = 1; f < allFaces_PNT.length; f++) {
  
              int vsb = allFaces_MTLV[f][3];
  
              if (vsb > 0) {
  
                int  mt = allFaces_MTLV[f][0];            
                if (Materials_Color[mt][0] > 127) {
  
                  int Tessellation = allFaces_MTLV[f][1];
  
                  int TotalSubNo = 1;  
                  if (allFaces_MTLV[f][0] == 0) {
                    Tessellation += MODEL3D_Tessellation;
                  }
                  if (Tessellation > 0) TotalSubNo = allFaces_PNT[f].length * int(roundTo(pow(4, Tessellation - 1), 1));
  
                  float[][] base_Vertices = new float [allFaces_PNT[f].length][3];
                  for (int g = 0; g < allFaces_PNT[f].length; g++) {
                    int vNo = allFaces_PNT[f][g];
                    base_Vertices[g][0] = allVertices[vNo][0];
                    base_Vertices[g][1] = allVertices[vNo][1];
                    base_Vertices[g][2] = allVertices[vNo][2];
                  }
  
                  for (int n = 0; n < TotalSubNo; n++) {
  
                    float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (SolarImpact_sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];
  
                        subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                        subFace_Rotated[s][1] = c;      
                        subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                      } else if (SolarImpact_sectionType == 3) {
                      }
                    }                
  
                    SHADOW_Diagrams.beginShape();
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
  
                      float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
                      if (z >= 0) {
  
                        if (SolarImpact_sectionType == 1) {
                          float px = x;
                          float py = y;
  
                          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        }                   
  
                        SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                        float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];       
  
                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);
  
                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }                     
  
                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
  
                        float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);
  
                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;
  
                          if (SolarImpact_sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                            y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                          }                     
  
                          SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }
  
                    SHADOW_Diagrams.endShape(CLOSE);
                  }
                }
              }
            }
          }
          
          
          if (Display_LAND_MESH != 0) {
            
            int Tessellation = LAND_TESSELLATION;
            if (WIN3D_FacesShade == Shade_Surface_Base) {
              Tessellation = 0;
            }
      
            int TotalSubNo = 1;  
            if (Tessellation > 0) TotalSubNo = 4 * int(roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
      
      
            for (int Li = Skip_LAND_MESH_Center; Li < LAND_n_I - 1; Li += 1) {
              for (int Lj = 0; Lj < LAND_n_J - 1; Lj += 1) {
      
                float[][] base_Vertices = new float [4][3];
      
                base_Vertices[0][0] = LAND_MESH[Li][Lj][0];
                base_Vertices[0][1] = LAND_MESH[Li][Lj][1];
                base_Vertices[0][2] = LAND_MESH[Li][Lj][2];
      
                base_Vertices[1][0] = LAND_MESH[Li+1][Lj][0];
                base_Vertices[1][1] = LAND_MESH[Li+1][Lj][1];
                base_Vertices[1][2] = LAND_MESH[Li+1][Lj][2];
      
                base_Vertices[2][0] = LAND_MESH[Li+1][Lj+1][0];
                base_Vertices[2][1] = LAND_MESH[Li+1][Lj+1][1];
                base_Vertices[2][2] = LAND_MESH[Li+1][Lj+1][2];
      
                base_Vertices[3][0] = LAND_MESH[Li][Lj+1][0];
                base_Vertices[3][1] = LAND_MESH[Li][Lj+1][1];
                base_Vertices[3][2] = LAND_MESH[Li][Lj+1][2];        
      
                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = getSubFace(base_Vertices, Tessellation, n);
                  float[][] subFace_Rotated = subFace;

                  for (int s = 0; s < subFace_Rotated.length; s++) {
                    if (SolarImpact_sectionType == 2) {
                      float a = subFace_Rotated[s][0];
                      float b = -subFace_Rotated[s][1];
                      float c = subFace_Rotated[s][2];

                      subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
                      subFace_Rotated[s][1] = c;    
                      subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
                    } else if (SolarImpact_sectionType == 3) {
                    }
                  }  

                  SHADOW_Diagrams.beginShape();

                  for (int s = 0; s < subFace_Rotated.length; s++) {

                    float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
                    float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                    float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                    if (z >= 0) {

                      if (SolarImpact_sectionType == 1) {                    
                        float px = x;
                        float py = y;

                        x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                        y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                      } 

                      SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                    } else {
                      int s_next = (s + 1) % subFace_Rotated.length;
                      int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                      float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
                      float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_prev > 0) { 
                        float ratio = z_prev / (z_prev - z);

                        float x_trim = x_prev * (1 - ratio) + x * ratio;
                        float y_trim = y_prev * (1 - ratio) + y * ratio;

                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }

                      float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
                      float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_next > 0) { 
                        float ratio = z_next / (z_next - z);

                        float x_trim = x_next * (1 - ratio) + x * ratio;
                        float y_trim = y_next * (1 - ratio) + y * ratio;

                        if (SolarImpact_sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                          y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
                        } 

                        SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }
                    }
                  }

                  SHADOW_Diagrams.endShape(CLOSE);
                }
              }
            }
          }          

          //now calculating Fractal plants
          if (Display_Fractals != 0) {

            for (int f = 1; f <= allFractals_num; f++) {

              float x = allFractals_XYZSR[f][0];
              float y = allFractals_XYZSR[f][1];
              float z = allFractals_XYZSR[f][2];

              float r = allFractals_XYZSR[f][3] * 0.5;
              float rot = allFractals_XYZSR[f][4];      

              int n = allFractals_Type[f];

              int dMin = allFractals_DegreeMin[f];

              int dMax = allFractals_DegreeMax[f];

              int s = allFractals_Seed[f];

              float TrunkSize = allFractals_TrunkSize[f];

              float LeafSize = allFractals_LeafSize[f];

              randomSeed(s);

              if (n == 0) {

                float Alpha = 0;
                float Beta = rot; 

                SOLARCHVISION_Plant_branch_SHADOW(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
              }
            }
          }          

          SHADOW_Diagrams.popMatrix();
        }

        SHADOW_Diagrams.save(File_Name + "3D_.JPG"); //just to test   

        if (Display_Model2Ds != 0) {

          PImage img = loadImage(File_Name + nf(i, 3) + "_2D.JPG");

          img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

          SHADOW_Diagrams.blendMode(DARKEST); 

          SHADOW_Diagrams.tint(255, 255);

          SHADOW_Diagrams.image(img, 0, 0, RES1, RES2);

          SHADOW_Diagrams.noTint();
        }  

        SHADOW_Diagrams.endDraw();    

        SHADOW_Diagrams.save(File_Name + nf(i, 3) + ".JPG");
      }



      PGraphics DIFFUSE_Diagrams = createGraphics(RES1, RES2, P2D);    

      DIFFUSE_Diagrams.beginDraw();

      DIFFUSE_Diagrams.blendMode(REPLACE);

      DIFFUSE_Diagrams.fill(0); 
      DIFFUSE_Diagrams.stroke(0);
      DIFFUSE_Diagrams.strokeWeight(0);
      DIFFUSE_Diagrams.rectMode(CORNER);
      DIFFUSE_Diagrams.rect(0, 0, RES1, RES2);

      for (int i = 1; i < skyFaces.length; i++) {

        PImage img = loadImage(File_Name + nf(i, 3) + ".JPG");

        DIFFUSE_Diagrams.blendMode(ADD); 

        DIFFUSE_Diagrams.tint(255, 255 / (0.5 * float(skyFaces.length)));

        DIFFUSE_Diagrams.image(img, 0, 0, RES1, RES2);

        DIFFUSE_Diagrams.noTint();
      }

      DIFFUSE_Diagrams.endDraw();

      File_Name += "_" +  SceneName + "_" + NearLatitude_Stamp() + "_Camera00.PNG"; 

      DIFFUSE_Diagrams.save(File_Name);
      println(File_Name);
    }
  }

  SolarImpact_sectionType = keep_SolarImpact_sectionType;
  SolarImpact_Rotation = keep_SolarImpact_Rotation;  

  cursor(ARROW);
}












void SOLARCHVISION_draw_WindRoseImage () {

  if (Display_WindRoseImage != 0) {

    if (rebuild_WindRoseImage_array != 0) {
      SOLARCHVISION_build_WindRose_Image_array();
    }    

    WIN3D_Diagrams.stroke(0);
    WIN3D_Diagrams.fill(127, 127, 127);    

    WIN3D_Diagrams.beginShape();

    float WindRose_Elevation = 0.0 + SolidImpact_Elevation[1];
    float WindRose_scale_U = WindRose3D_scale; 
    float WindRose_scale_V = WindRose3D_scale;

    float minU = 0;
    float maxU = Rendered_WindRose_RES;
    float minV = 0;
    float maxV = Rendered_WindRose_RES;

    //float c = HeightAboveGround * OBJECTS_scale; // <<< or zero i.e. height of the plane in 3D  // ?????????
    float c = WindRose_Elevation * OBJECTS_scale; 

    c += 1; // put WindRose_Image it at level 1m. // <<<<<<<<<<<

    WIN3D_Diagrams.beginShape();

    WIN3D_Diagrams.texture(WindRose_Image[IMPACTS_DisplayDay]);  
    WIN3D_Diagrams.stroke(255, 255, 255, 0);
    WIN3D_Diagrams.fill(255, 255, 255, 0);  

    for (int q = 0; q < 4; q++) {

      float qx = 0, qy = 0, u = 0, v = 0;

      if (q == 0) {
        qx = -1; 
        qy = -1; 
        u = minU; 
        v = maxV;
      } else if (q == 1) {
        qx = 1; 
        qy = -1; 
        u = maxU; 
        v = maxV;
      } else if (q == 2) {
        qx = 1; 
        qy = 1; 
        u = maxU; 
        v = minV;
      } else if (q == 3) {
        qx = -1; 
        qy = 1; 
        u = minU; 
        v = minV;
      }    

      float a = qx * 0.5;
      float b = qy * 0.5;    

      float x = 0, y = 0, z = 0;

      x = a;
      y = b;
      z = c;         

      WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D, u * WindRose_scale_U, v * WindRose_scale_V);
    }   

    WIN3D_Diagrams.endShape(CLOSE);
  }
}







void SOLARCHVISION_draw_referencePivot () {


  WIN3D_Diagrams.strokeWeight(3);
  WIN3D_Diagrams.stroke(127, 0, 255, 127);
  WIN3D_Diagrams.fill(127, 0, 255, 127);  

  float[] P = SOLARCHVISION_getPivot();

  float x = P[0];
  float y = P[1];
  float z = P[2];


  WIN3D_Diagrams.pushMatrix(); 
  WIN3D_Diagrams.translate(x * WIN3D_Scale3D, -y * WIN3D_Scale3D, z * WIN3D_Scale3D);

  WIN3D_Diagrams.sphere(1); // <<<<<< size

  WIN3D_Diagrams.popMatrix();

  WIN3D_Diagrams.strokeWeight(0);
}









void SOLARCHVISION_add_Camera (int n, float x, float y, float z, float s, float rx, float ry, float rz, float f) {

  int[] TempCamera_Type = {
    n
  }; 
  allCameras_Type = concat(allCameras_Type, TempCamera_Type);

  float[][] TempCamera_PPPRRRF = {
    {
      x, y, z, s, rx, ry, rz, f
    }
  };
  allCameras_PPPSRRRF = (float[][]) concat(allCameras_PPPSRRRF, TempCamera_PPPRRRF);

  allCameras_num += 1;
}


float[][] allCameras_Vertices;
int[][] allCameras_Faces;


void SOLARCHVISION_draw_Cameras () {

  allCameras_Faces = new int [allCameras_num + 1][4];

  allCameras_Vertices = new float [4 * allCameras_num + 1][3];
  allCameras_Vertices[0][0] = 0;
  allCameras_Vertices[0][1] = 0;
  allCameras_Vertices[0][2] = 0;

  if (Display_Cameras != 0) {

    for (int f = 1; f <= allCameras_num; f++) {

      float Camera_X = allCameras_PPPSRRRF[f][0];
      float Camera_Y = allCameras_PPPSRRRF[f][1];
      float Camera_Z = allCameras_PPPSRRRF[f][2];
      float Camera_S = allCameras_PPPSRRRF[f][3];
      float Camera_RX = allCameras_PPPSRRRF[f][4];
      float Camera_RY = allCameras_PPPSRRRF[f][5];
      float Camera_RZ = allCameras_PPPSRRRF[f][6];
      float Camera_ZOOM = allCameras_PPPSRRRF[f][7];

      int Camera_Type = allCameras_Type[f];

      WIN3D_Diagrams.strokeWeight(1);
      WIN3D_Diagrams.stroke(0);
      WIN3D_Diagrams.noFill();  

      WIN3D_Diagrams.beginShape();

      float[][] ImageVertex = SOLARCHVISION_getCorners_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

      for (int q = 1; q <= 4; q++) {

        float x = ImageVertex[q][0];
        float y = ImageVertex[q][1];
        float z = ImageVertex[q][2];

        WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);

        allCameras_Vertices[f * 4 - q + 1][0] = x;
        allCameras_Vertices[f * 4 - q + 1][1] = y;
        allCameras_Vertices[f * 4 - q + 1][2] = z;
      }        

      allCameras_Faces[f][0] = f * 4 - 3;
      allCameras_Faces[f][1] = f * 4 - 2;
      allCameras_Faces[f][2] = f * 4 - 1;
      allCameras_Faces[f][3] = f * 4 - 0;  

      WIN3D_Diagrams.endShape(CLOSE);

      WIN3D_Diagrams.strokeWeight(1);
      WIN3D_Diagrams.stroke(0);
      //WIN3D_Diagrams.fill(127,255,127,127);
      WIN3D_Diagrams.noFill();

      WIN3D_Diagrams.beginShape();

      for (int q = 1; q <= 4; q++) {

        {
          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];

          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
        }

        {
          int next_q = 1 + (q % 4); 

          float x = ImageVertex[next_q][0];
          float y = ImageVertex[next_q][1];
          float z = ImageVertex[next_q][2];

          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
        }

        {
          int o = 0; 

          float x = ImageVertex[o][0];
          float y = ImageVertex[o][1];
          float z = ImageVertex[o][2];

          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
        }
      }        

      WIN3D_Diagrams.endShape(CLOSE);
    }

    WIN3D_Diagrams.strokeWeight(0);
  }
}


float[][] SOLARCHVISION_getCorners_Camera (int Camera_Type, float Camera_X, float Camera_Y, float Camera_Z, float Camera_S, float Camera_RX, float Camera_RY, float Camera_RZ, float Camera_ZOOM) {

  float[][] ImageVertex = new float [5][3];

  float r = Camera_S * 5; // <<<<<<

  float rx = r * sin_ang(0.5 * Camera_ZOOM) /  WIN3D_R_View;
  float ry = r * sin_ang(0.5 * Camera_ZOOM);  
  float rz = r * cos_ang(0.5 * Camera_ZOOM);  

  for (int q = 0; q < 5; q++) {  

    float qx = 0, qy = 0, qz = 0;

    if (q == 0) {
      qx = 0; 
      qy = 0; 
      qz = 0;
    } else if (q == 1) {
      qx = -1; 
      qy = -1; 
      qz = -1;
    } else if (q == 2) {
      qx = -1; 
      qy = 1; 
      qz = -1;
    } else if (q == 3) {
      qx = 1; 
      qy = 1; 
      qz = -1;
    } else if (q == 4) {
      qx = 1; 
      qy = -1; 
      qz = -1;
    }

    float x = 0, y = 0, z = 0;

    float keep_CAM_x = WIN3D_CAM_x;
    float keep_CAM_y = WIN3D_CAM_y;
    float keep_CAM_z = WIN3D_CAM_z;
    float keep_WIN3D_X_Coordinate = WIN3D_X_Coordinate; 
    float keep_WIN3D_Y_Coordinate = WIN3D_Y_Coordinate;
    float keep_WIN3D_Z_Coordinate = WIN3D_Z_Coordinate;
    float keep_WIN3D_S_Coordinate = WIN3D_S_Coordinate;
    float keep_WIN3D_RX_Coordinate = WIN3D_RX_Coordinate; 
    float keep_WIN3D_RY_Coordinate = WIN3D_RY_Coordinate;
    float keep_WIN3D_RZ_Coordinate = WIN3D_RZ_Coordinate;
    float keep_WIN3D_Zoom = WIN3D_Zoom;

    {

      WIN3D_X_Coordinate = Camera_X;
      WIN3D_Y_Coordinate = Camera_Y;
      WIN3D_Z_Coordinate = Camera_Z;
      WIN3D_S_Coordinate = Camera_S;
      WIN3D_RX_Coordinate = Camera_RX; 
      WIN3D_RY_Coordinate = Camera_RY;
      WIN3D_RZ_Coordinate = Camera_RZ;
      WIN3D_Zoom = Camera_ZOOM;

      SOLARCHVISION_transform_3DViewport();

      float x1 = rx * qx;
      float y1 = ry * qy;
      float z1 = rz * qz;

      float x2 = x1;
      float y2 = y1 * cos_ang(Camera_RX) - z1 * sin_ang(Camera_RX);
      float z2 = y1 * sin_ang(Camera_RX) + z1 * cos_ang(Camera_RX);

      float x3 = x2 * cos_ang(Camera_RZ) - y2 * sin_ang(Camera_RZ);
      float y3 = x2 * sin_ang(Camera_RZ) + y2 * cos_ang(Camera_RZ);
      float z3 = z2;

      x = WIN3D_CAM_x + x3;
      y = WIN3D_CAM_y + y3;
      z = WIN3D_CAM_z + z3;
    }

    WIN3D_CAM_x = keep_CAM_x;
    WIN3D_CAM_y = keep_CAM_y;
    WIN3D_CAM_z = keep_CAM_z;
    WIN3D_X_Coordinate = keep_WIN3D_X_Coordinate; 
    WIN3D_Y_Coordinate = keep_WIN3D_Y_Coordinate;
    WIN3D_Z_Coordinate = keep_WIN3D_Z_Coordinate;
    WIN3D_S_Coordinate = keep_WIN3D_S_Coordinate;
    WIN3D_RX_Coordinate = keep_WIN3D_RX_Coordinate; 
    WIN3D_RY_Coordinate = keep_WIN3D_RY_Coordinate;
    WIN3D_RZ_Coordinate = keep_WIN3D_RZ_Coordinate;
    WIN3D_Zoom = keep_WIN3D_Zoom;

    ImageVertex[q][0] = x;
    ImageVertex[q][1] = y;
    ImageVertex[q][2] = z;
  }

  return ImageVertex;
}





void SOLARCHVISION_add_Section (int n, float u, float v, float elev, float rot, float dU, float dV, int RES1, int RES2) {

  int[] TempSection_Type = {
    n
  }; 
  allSections_Type = concat(allSections_Type, TempSection_Type);

  int[] TempSection_RES1 = {
    RES1
  }; 
  allSections_RES1 = concat(allSections_RES1, TempSection_RES1);

  int[] TempSection_RES2 = {
    RES2
  }; 
  allSections_RES2 = concat(allSections_RES2, TempSection_RES2);

  PImage[] TempSection_SolidImpact = {
    createImage(RES1, RES2, RGB)
  }; 
  allSections_SolidImpact = (PImage[]) concat(allSections_SolidImpact, TempSection_SolidImpact);

  PImage[][] TempSection_SolarImpact = new PImage[1][(1 + STUDY_j_End - STUDY_j_Start)];
  {
    int i = 0;
    for (int j = STUDY_j_Start; j <= STUDY_j_End; j += 1) { 
      TempSection_SolarImpact[i][j] = createImage(2, 2, RGB);
    }
  }
  allSections_SolarImpact = (PImage[][]) concat(allSections_SolarImpact, TempSection_SolarImpact);    

  float[][] TempSection_UVERAB = {
    {
      u, v, elev, rot, dU, dV
    }
  };
  allSections_UVERAB = (float[][]) concat(allSections_UVERAB, TempSection_UVERAB);

  allSections_num += 1;
}


float[][] allSections_Vertices;
int[][] allSections_Faces;


void SOLARCHVISION_draw_Sections () {

  allSections_Faces = new int [allSections_num + 1][4];

  allSections_Vertices = new float [4 * allSections_num + 1][3];
  allSections_Vertices[0][0] = 0;
  allSections_Vertices[0][1] = 0;
  allSections_Vertices[0][2] = 0;

  if (Display_Sections != 0) {

    for (int f = 1; f <= allSections_num; f++) {

      float Section_offset_U = allSections_UVERAB[f][0];
      float Section_offset_V = allSections_UVERAB[f][1];
      float Section_Elevation = allSections_UVERAB[f][2];
      float Section_Rotation = allSections_UVERAB[f][3];
      float Section_scale_U = allSections_UVERAB[f][4];
      float Section_scale_V = allSections_UVERAB[f][5];

      int Section_Type = allSections_Type[f];
      int Section_RES1 = allSections_RES1[f];
      int Section_RES2 = allSections_RES2[f];

      if (Section_Type != 0) {

        WIN3D_Diagrams.stroke(0);
        WIN3D_Diagrams.fill(127, 255, 127);  

        WIN3D_Diagrams.beginShape();

        if (Display_SolarImpactImage != 0) { 
          WIN3D_Diagrams.texture(allSections_SolarImpact[f][IMPACTS_DisplayDay]);

          WIN3D_Diagrams.noStroke();
          WIN3D_Diagrams.noFill();
        } else if (Display_SolidImpactImage != 0) {
          WIN3D_Diagrams.texture(allSections_SolidImpact[f]);

          WIN3D_Diagrams.noStroke();
          WIN3D_Diagrams.noFill();
        }  

        float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

        for (int q = 1; q <= 4; q++) {

          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];
          float u = ImageVertex[q][3];
          float v = ImageVertex[q][4];

          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D, u * Section_RES1, v * Section_RES2);

          allSections_Vertices[f * 4 - q + 1][0] = x;
          allSections_Vertices[f * 4 - q + 1][1] = y;
          allSections_Vertices[f * 4 - q + 1][2] = z;
        }        

        allSections_Faces[f][0] = f * 4 - 3;
        allSections_Faces[f][1] = f * 4 - 2;
        allSections_Faces[f][2] = f * 4 - 1;
        allSections_Faces[f][3] = f * 4 - 0;  

        WIN3D_Diagrams.endShape(CLOSE);

        WIN3D_Diagrams.strokeWeight(1);
        WIN3D_Diagrams.stroke(127);
        WIN3D_Diagrams.noFill();  

        WIN3D_Diagrams.beginShape();

        for (int q = 1; q <= 4; q++) {

          {
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];

            WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
          }

          {
            int next_q = 1 + (q % 4); 

            float x = ImageVertex[next_q][0];
            float y = ImageVertex[next_q][1];
            float z = ImageVertex[next_q][2];

            WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
          }

          {
            int o = 0; 

            float x = ImageVertex[o][0];
            float y = ImageVertex[o][1];
            float z = ImageVertex[o][2];

            WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);
          }
        }        

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }

    WIN3D_Diagrams.noStroke();
  }
}


float[][] SOLARCHVISION_getCorners_Section (int Section_Type, float Section_offset_U, float Section_offset_V, float Section_Elevation, float Section_Rotation, float Section_scale_U, float Section_scale_V, int Section_RES1, int Section_RES2) {

  float[][] ImageVertex = new float [5][5];

  for (int q = 0; q < 5; q++) {

    float qx = 0, qy = 0, u = 0, v = 0;

    if (q == 0) {
      qx = 0; 
      qy = 0; 
      u = 0.5; 
      v = 0.5;
    } // center    
    else if (q == 1) {
      qx = -1; 
      qy = -1; 
      u = 0; 
      v = 1;
    } else if (q == 2) {
      qx = 1; 
      qy = -1; 
      u = 1; 
      v = 1;
    } else if (q == 3) {
      qx = 1; 
      qy = 1; 
      u = 1; 
      v = 0;
    } else if (q == 4) {
      qx = -1; 
      qy = 1; 
      u = 0; 
      v = 0;
    }    

    float a = qx * 0.5 * Section_scale_U + Section_offset_U;
    float b = qy * 0.5 * Section_scale_V + Section_offset_V;
    float c = Section_Elevation;  

    float x = 0, y = 0, z = 0;

    if (Section_Type == 1) {
      x = a * cos_ang(Section_Rotation) - b * sin_ang(Section_Rotation);
      y = a * sin_ang(Section_Rotation) + b * cos_ang(Section_Rotation);
      z = c;
    } else if (Section_Type == 2) {
      x = a * cos_ang(Section_Rotation) - c * sin_ang(Section_Rotation);
      y = -(a * sin_ang(Section_Rotation) + c * cos_ang(Section_Rotation));
      z = b;
    } else if (Section_Type == 3) {
      x = a * cos_ang(90 - Section_Rotation) - c * sin_ang(90 - Section_Rotation); // ????????????
      y = -(a * sin_ang(90 - Section_Rotation) + c * cos_ang(90 - Section_Rotation)); // ????????????
      z = b;
    }      

    ImageVertex[q][0] = x;
    ImageVertex[q][1] = y;
    ImageVertex[q][2] = z;
    ImageVertex[q][3] = u;
    ImageVertex[q][4] = v;
  }

  return ImageVertex;
}



float[][] allSolids_Vertices;
int[][] allSolids_Faces;

int Solids_DisplayFaces = 3; // internal - number of faces: XY, YZ, ZX
int Solids_DisplayDegree = 16; //8; // internal - number of each face corners 


void SOLARCHVISION_draw_Solids () {

  allSolids_Faces = new int [1 + Solids_DisplayFaces * (allSolids_DEF.length - 1)][Solids_DisplayDegree]; 

  allSolids_Vertices = new float [Solids_DisplayFaces * Solids_DisplayDegree * allSolids_DEF.length][3];
  allSolids_Vertices[0][0] = 0;
  allSolids_Vertices[0][1] = 0;
  allSolids_Vertices[0][2] = 0;

  if (Display_Solids != 0) {

    WIN3D_Diagrams.strokeWeight(2);

    for (int f = 1; f < allSolids_DEF.length; f++) {

      float Solid_posX = Solid_get_posX(f);
      float Solid_posY = Solid_get_posY(f);
      float Solid_posZ = Solid_get_posZ(f);
      float Solid_powX = Solid_get_powX(f);
      float Solid_powY = Solid_get_powY(f);
      float Solid_powZ = Solid_get_powZ(f);
      float Solid_scaleX = Solid_get_scaleX(f);
      float Solid_scaleY = Solid_get_scaleY(f);
      float Solid_scaleZ = Solid_get_scaleZ(f);
      float Solid_rotX = Solid_get_rotX(f);
      float Solid_rotY = Solid_get_rotY(f);
      float Solid_rotZ = Solid_get_rotZ(f);
      float Solid_value = Solid_get_value(f);

      for (int plane_type = 0; plane_type < Solids_DisplayFaces; plane_type++) {

        WIN3D_Diagrams.noFill();        
        WIN3D_Diagrams.stroke(0);

        if (plane_type == 0) {
          WIN3D_Diagrams.stroke(0, 255, 0);
        }  
        if (plane_type == 1) {
          WIN3D_Diagrams.stroke(255, 0, 0);
        }          
        if (plane_type == 2) {
          WIN3D_Diagrams.stroke(0, 0, 255);
        }          

        WIN3D_Diagrams.beginShape();

        float[][] ImageVertex = SOLARCHVISION_getCorners_Solid(plane_type, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

        for (int q = 1; q <= Solids_DisplayDegree; q++) {

          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];

          WIN3D_Diagrams.vertex(x * OBJECTS_scale * WIN3D_Scale3D, -y * OBJECTS_scale * WIN3D_Scale3D, z * OBJECTS_scale * WIN3D_Scale3D);

          if (q != 0) {

            int vNo = (Solids_DisplayFaces * (f - 1) + plane_type) * Solids_DisplayDegree + q;

            allSolids_Vertices[vNo][0] = x;
            allSolids_Vertices[vNo][1] = y;
            allSolids_Vertices[vNo][2] = z;

            int fNo = (Solids_DisplayFaces * (f - 1) + plane_type) + 1;

            allSolids_Faces[fNo][q - 1] = vNo;
          }
        }        

        WIN3D_Diagrams.endShape(CLOSE);
      }
    }

    WIN3D_Diagrams.noStroke();
    WIN3D_Diagrams.strokeWeight(0);
  }
}


float[][] SOLARCHVISION_getCorners_Solid (int plane_type, float Solid_posX, float Solid_posY, float Solid_posZ, float Solid_powX, float Solid_powY, float Solid_powZ, float Solid_scaleX, float Solid_scaleY, float Solid_scaleZ, float Solid_rotX, float Solid_rotY, float Solid_rotZ, float Solid_value) {

  float[][] ImageVertex = new float [Solids_DisplayDegree + 1][3];

  for (int q = 0; q <= Solids_DisplayDegree; q++) {

    float qx = 0;
    float qy = 0;
    float qz = 0;

    if (q != 0) {
      if (plane_type == 0) {
        qx = cos_ang(q * 360.0 / float(Solids_DisplayDegree));
        qy = sin_ang(q * 360.0 / float(Solids_DisplayDegree));
      }

      if (plane_type == 1) {
        qy = cos_ang(q * 360.0 / float(Solids_DisplayDegree));
        qz = sin_ang(q * 360.0 / float(Solids_DisplayDegree));
      }

      if (plane_type == 2) {
        qz = cos_ang(q * 360.0 / float(Solids_DisplayDegree));
        qx = sin_ang(q * 360.0 / float(Solids_DisplayDegree));
      }
    }

    if (q != 0) { // normalizing

      float d = pow(pow(abs(qx), Solid_powX) + pow(abs(qy), Solid_powY) + pow(abs(qz), Solid_powZ), 3.0 / (Solid_powX + Solid_powY + Solid_powZ));

      if (d != 0) {
        qx /= d;
        qy /= d;
        qz /= d;
      }
    }


    float a = qx * Solid_scaleX;
    float b = qy * Solid_scaleY;
    float c = qz * Solid_scaleZ;  

    ///////////////////////// NOT SURE START!    

    float y1 = b * cos_ang(Solid_rotX) - c * sin_ang(Solid_rotX); 
    float z1 = b * sin_ang(Solid_rotX) + c * cos_ang(Solid_rotX);
    float x1 = a;

    a = x1;
    b = y1;
    c = z1;  

    float z2 = c * cos_ang(Solid_rotY) - a * sin_ang(Solid_rotY);
    float x2 = c * sin_ang(Solid_rotY) + a * cos_ang(Solid_rotY);
    float y2 = b; 

    a = x2;
    b = y2;
    c = z2;      
    ///////////////////////// NOT SURE END!

    float x = a * cos_ang(Solid_rotZ) - b * sin_ang(Solid_rotZ);
    float y = a * sin_ang(Solid_rotZ) + b * cos_ang(Solid_rotZ);
    float z = c;         


    x += Solid_posX;
    y += Solid_posY;
    z += Solid_posZ;  

    ImageVertex[q][0] = x;
    ImageVertex[q][1] = y;
    ImageVertex[q][2] = z;
  }

  return ImageVertex;
}



void SOLARCHVISION_add_Fractal (int PlantType, float x, float y, float z, float s, float rot, int PlantDegreeMin, int PlantDegreeMax, int PlantSeed, float TrunkSize, float LeafSize) {

  if (allGroup3Ds_num == 0) SOLARCHVISION_beginNewGroup3D(0, 0, 0, 1, 1, 1, 0, 0, 0);

  {
    float[] TempFractal_TrunkSize = {
      TrunkSize
    }; 
    allFractals_TrunkSize = concat(allFractals_TrunkSize, TempFractal_TrunkSize);  

    float[] TempFractal_LeafSize = {
      LeafSize
    }; 
    allFractals_LeafSize = concat(allFractals_LeafSize, TempFractal_LeafSize);

    int[] TempFractal_Type = {
      PlantType
    }; 
    allFractals_Type = concat(allFractals_Type, TempFractal_Type);

    int[] TempFractal_DegreeMin = {
      PlantDegreeMin
    }; 
    allFractals_DegreeMin = concat(allFractals_DegreeMin, TempFractal_DegreeMin);

    int[] TempFractal_DegreeMax = {
      PlantDegreeMax
    }; 
    allFractals_DegreeMax = concat(allFractals_DegreeMax, TempFractal_DegreeMax);

    int q = PlantSeed;
    if (q == -1) q = int(random(32767));

    int[] TempFractal_Seed = {
      q
    }; 
    allFractals_Seed = concat(allFractals_Seed, TempFractal_Seed);

    float[][] TempFractal_XYZSR = {
      {
        x, y, z, s, rot
      }
    };
    allFractals_XYZSR = (float[][]) concat(allFractals_XYZSR, TempFractal_XYZSR);

    allFractals_num += 1;



    if (CreateInput_MeshOrSolid != 0) {

      randomSeed(q);

      SOLARCHVISION_Plant_branch_addSolids(x, y, z, 0, rot, 0.5 * s, PlantDegreeMin, PlantDegreeMin, PlantDegreeMax, TrunkSize, LeafSize);
    }
  }

  allGroup3Ds_Fractals[allGroup3Ds_num][1] = allFractals_num;
}

float[][] allFractals_Vertices;
int[][] allFractals_Faces;


void SOLARCHVISION_draw_Fractals () {

  allFractals_Faces = new int [1 + allFractals_num][4];

  allFractals_Vertices = new float [4 * allFractals_num + 1][3];
  allFractals_Vertices[0][0] = 0;
  allFractals_Vertices[0][1] = 0;
  allFractals_Vertices[0][2] = 0;

  if (Display_Fractals != 0) {

    for (int f = 1; f <= allFractals_num; f++) {

      float x = allFractals_XYZSR[f][0];
      float y = allFractals_XYZSR[f][1];
      float z = allFractals_XYZSR[f][2];

      float r = allFractals_XYZSR[f][3] * 0.5;
      float rot = allFractals_XYZSR[f][4];

      int n = allFractals_Type[f];

      int dMin = allFractals_DegreeMin[f];

      int dMax = allFractals_DegreeMax[f];

      int s = allFractals_Seed[f];

      float TrunkSize = allFractals_TrunkSize[f];

      float LeafSize = allFractals_LeafSize[f];

      randomSeed(s);

      if (n == 0) {

        float Alpha = 0;
        float Beta = rot; 

        SOLARCHVISION_Plant_branch_Main(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);

        // ----------------
        x *= OBJECTS_scale;
        y *= OBJECTS_scale;
        z *= OBJECTS_scale;
        r *= OBJECTS_scale;
        // ----------------        

        float t = WIN3D_RZ_Coordinate * PI / 180.0;
        if (WIN3D_ViewType == 1) t = atan2(y - WIN3D_CAM_y, x - WIN3D_CAM_x) + 0.5 * PI; 

        {
          allFractals_Vertices[f * 4 - 3][0] = (x - r * cos(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 3][1] = (y - r * sin(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 3][2] = (z) / OBJECTS_scale;

          allFractals_Vertices[f * 4 - 2][0] = (x + r * cos(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 2][1] = (y + r * sin(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 2][2] = (z) / OBJECTS_scale;

          allFractals_Vertices[f * 4 - 1][0] = (x + r * cos(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 1][1] = (y + r * sin(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 1][2] = (z + 2 * r) / OBJECTS_scale;

          allFractals_Vertices[f * 4 - 0][0] = (x - r * cos(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 0][1] = (y - r * sin(t)) / OBJECTS_scale;
          allFractals_Vertices[f * 4 - 0][2] = (z + 2 * r) / OBJECTS_scale;

          allFractals_Faces[f][0] = f * 4 - 3;
          allFractals_Faces[f][1] = f * 4 - 2;
          allFractals_Faces[f][2] = f * 4 - 1;
          allFractals_Faces[f][3] = f * 4 - 0;
        }
      }
    }
  }
}




void SOLARCHVISION_Plant_branch_objExport_ (int _turn, float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {

  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  

      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);

      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);

      //float[] COL = {255, 100 - 6 * w, 50 - 3 * w, 0};

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);

      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_Fractals != 0) {
        int nSeg = 6; 
        for (int q = 0; q < nSeg; q++) {

          for (int j = 0; j < 4; j++) {

            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;

            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;

            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks

            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;

            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);

            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 


            float x = Trunk_x_new;
            float y = Trunk_y_new;
            float z = Trunk_z_new;
            float u = the_U;
            float v = the_V;

            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

            if (_turn == 1) {

              SOLARCHVISION_OBJprintVertex(x, y, z);
            }

            if (_turn == 2) {

              SOLARCHVISION_OBJprintVtexture(u, v, 0);
            }
          }

          if (_turn == 3) {

            num_vertices_added += 4;

            String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

            String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);               

            if (objExport_PolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println(("g Fractal_Trunk_n" + nf(q, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
            }

            if (objExport_MaterialLibrary != 0) {
              objOutput.println("usemtl Fractal_Trunk");
            }

            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
          }
        }
      }

      SOLARCHVISION_Plant_branch_objExport_(_turn, x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
    }
  } else {

    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int c = int(random(127));  

    if (Display_Leaves != 0) {

      float LeafVertices[][] = {
        {
          0, 0, 0
        }
        , {
          1, 0, 1
        }
        , {
          0, 1, 1
        }
        , {
          -1, 0, 1
        }
        , {
          0, -1, 1
        }
        , {
          0, 0, 2
        }
      };
      int LeafFaces[][] = {
        {
          0, 1, 2, 5
        }
        , {
          0, 2, 3, 5
        }
        , {
          0, 3, 4, 5
        }
        , {
          0, 4, 1, 5
        }
      };

      for (int i = 0; i < 4; i++) { // 4: LeafFaces.length
        for (int j = 0; j < 4; j++) { // 4: LeafFaces[i].length

          float the_U = 0;
          if ((j == 1) || (j == 2)) the_U = 1;

          float the_V = 0;
          if ((j == 2) || (j == 3)) the_V = 1;


          float Leaf_x_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][0];
          float Leaf_y_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][1];
          float Leaf_z_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][2];

          float Leaf_x_rot = Leaf_z_dif * sin(rotZX) +  Leaf_x_dif * cos(rotZX);
          float Leaf_y_rot = Leaf_y_dif;
          float Leaf_z_rot = Leaf_z_dif * cos(rotZX) - Leaf_x_dif * sin(rotZX);

          float Leaf_x_new = x0 + Leaf_x_rot * cos(rotXY) - Leaf_y_rot * sin(rotXY);
          float Leaf_y_new = y0 + Leaf_x_rot * sin(rotXY) + Leaf_y_rot * cos(rotXY);
          float Leaf_z_new = z0 + Leaf_z_rot; 

          float x = Leaf_x_new;
          float y = Leaf_y_new;
          float z = Leaf_z_new;
          float u = the_U;
          float v = the_V;

          v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<

          if (_turn == 1) {

            SOLARCHVISION_OBJprintVertex(x, y, z);
          }

          if (_turn == 2) {

            SOLARCHVISION_OBJprintVtexture(u, v, 0);
          }
        }


        if (_turn == 3) {  

          num_vertices_added += 4;

          String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
          String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
          String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
          String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);

          String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
          String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
          String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
          String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);        

          if (objExport_PolyToPoly == 0) {
            obj_lastGroupNumber += 1;
            objOutput.println(("g Fractal_Leaf_n" + nf(i, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
          }

          if (objExport_MaterialLibrary != 0) {
            objOutput.println("usemtl Fractal_Leaf");
          }

          obj_lastFaceNumber += 1;
          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
          if (objExport_BackSides != 0) {
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
          }
        }
      }
    }
  }
}




float getRatio_Plant_branch (float d) {
  return (0.75 / pow(d, 0.06125));
}

void SOLARCHVISION_Plant_branch_Main (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {

  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  

      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);

      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);

      float[] COL = {
        255, 100 - 6 * w, 50 - 3 * w, 0
      };

      WIN3D_Diagrams.strokeWeight(1);

      if (MODEL3D_DisplayEdges == 0) {
        WIN3D_Diagrams.noStroke();
      } else {
        WIN3D_Diagrams.stroke(0);
      }

      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3]);

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);

      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_Fractals != 0) {
        int nSeg = 6; 
        for (int q = 0; q < nSeg; q++) {
          WIN3D_Diagrams.beginShape();
          for (int j = 0; j < 4; j++) {

            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;

            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;

            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks

            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;

            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);

            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 

            WIN3D_Diagrams.vertex(Trunk_x_new * OBJECTS_scale * WIN3D_Scale3D, -Trunk_y_new * OBJECTS_scale * WIN3D_Scale3D, Trunk_z_new * OBJECTS_scale * WIN3D_Scale3D);
          }
          WIN3D_Diagrams.endShape(CLOSE);
        }
      }

      SOLARCHVISION_Plant_branch_Main(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
    }
  } else {

    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int c = int(random(127));  

    if (Display_Leaves != 0) {

      WIN3D_Diagrams.strokeWeight(0);

      float[] COL = {
        127, 2 * c, 191 - c, 0
      };  // opaque!

      WIN3D_Diagrams.stroke(COL[1], COL[2], COL[3], COL[0]); 
      WIN3D_Diagrams.fill(COL[1], COL[2], COL[3], COL[0]);

      WIN3D_Diagrams.pushMatrix(); 
      WIN3D_Diagrams.translate(x0 * OBJECTS_scale * WIN3D_Scale3D, -y0 * OBJECTS_scale * WIN3D_Scale3D, z0 * OBJECTS_scale * WIN3D_Scale3D);
      WIN3D_Diagrams.sphere(0.5 * LeafSize * OBJECTS_scale * WIN3D_Scale3D);
      WIN3D_Diagrams.popMatrix();
    }
  }
}


void SOLARCHVISION_Plant_branch_addSolids (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {


  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  

      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);

      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);


      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);

      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 




      float cx = 0.5 * (x0 + x_new); 
      float cy = 0.5 * (y0 + y_new); 
      float cz = 0.5 * (z0 + z_new);

      float the_thickness = 0.025 * w * h;
      float rx = 0.5 * the_thickness;
      float ry = 0.5 * the_thickness;
      //float rz = 0.5 * abs(z_new - z0);
      float rz = 0.5 * abs(z_new - z0) * 1.25; // <<<<<<< to somehow compensate the shrinkage!

      SOLARCHVISION_add_Solid(cx, cy, cz, 2, 2, 2, rx, ry, rz, 0, (rotZX * 180 / PI), (rotXY * 180 / PI), CreateInput_MeshOrSolid);


      SOLARCHVISION_Plant_branch_addSolids(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
    }
  } else {

    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int c = int(random(127));  

    if (Display_Leaves != 0) {

      float r0 = 0.5 * LeafSize;
      SOLARCHVISION_add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, CreateInput_MeshOrSolid);
    }
  }
}

void SOLARCHVISION_Plant_branch_SHADOW (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float[] SunR_Rotated, float Shades_scaleX, float Shades_scaleY, float Shades_offsetX, float Shades_offsetY) {

  SHADOW_Diagrams.strokeWeight(0);

  SHADOW_Diagrams.stroke(0);
  SHADOW_Diagrams.fill(0);

  h *= getRatio_Plant_branch(d);

  int birth = 1;

  if ((birth != 0) && (d < Plant_max_degree)) {

    for (int i = 1; i <= d; i++) {  

      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);

      float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);

      float x_dif = 0;
      float y_dif = 0;
      float z_dif = h;

      float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
      float y_rot = y_dif;
      float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);

      float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
      float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
      float z_new = z0 + z_rot; 

      if (Display_Fractals != 0) {
        int nSeg = 6; 
        float[][] subFace = new float [nSeg * 4][3];
        for (int q = 0; q < nSeg; q++) {
          for (int j = 0; j < 4; j++) {

            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;

            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;

            float the_thickness = 0.025 * w * h;
            if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks

            float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
            float Trunk_z_dif = h * the_V;

            float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
            float Trunk_y_rot = Trunk_y_dif;
            float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);

            float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
            float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
            float Trunk_z_new = z0 + Trunk_z_rot; 

            subFace[q * 4 + j][0] = Trunk_x_new;
            subFace[q * 4 + j][1] = Trunk_y_new; 
            subFace[q * 4 + j][2] = Trunk_z_new;
          }
        }

        float[][] subFace_Rotated = subFace;

        for (int s = 0; s < subFace_Rotated.length; s++) {
          if (SolarImpact_sectionType == 2) {
            float a = subFace_Rotated[s][0];
            float b = -subFace_Rotated[s][1];
            float c = subFace_Rotated[s][2];

            subFace_Rotated[s][0] = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
            subFace_Rotated[s][1] = c;    
            subFace_Rotated[s][2] = a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
          } else if (SolarImpact_sectionType == 3) {
          }
        }  

        SHADOW_Diagrams.beginShape();

        for (int s = 0; s < subFace_Rotated.length; s++) {

          float z = subFace_Rotated[s][2] - SolarImpact_Elevation;
          float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
          float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];

          if (z >= 0) {

            if (SolarImpact_sectionType == 1) {                    
              float px = x;
              float py = y;

              x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
              y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
            } 

            SHADOW_Diagrams.vertex((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY);
          } else {
            int s_next = (s + 1) % subFace_Rotated.length;
            int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

            float z_prev = subFace_Rotated[s_prev][2] - SolarImpact_Elevation;
            float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
            float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

            if (z_prev > 0) { 
              float ratio = z_prev / (z_prev - z);

              float x_trim = x_prev * (1 - ratio) + x * ratio;
              float y_trim = y_prev * (1 - ratio) + y * ratio;

              if (SolarImpact_sectionType == 1) {
                float px = x_trim;
                float py = y_trim;

                x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
              } 

              SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
            }

            float z_next = subFace_Rotated[s_next][2] - SolarImpact_Elevation;
            float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
            float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

            if (z_next > 0) { 
              float ratio = z_next / (z_next - z);

              float x_trim = x_next * (1 - ratio) + x * ratio;
              float y_trim = y_next * (1 - ratio) + y * ratio;

              if (SolarImpact_sectionType == 1) {
                float px = x_trim;
                float py = y_trim;

                x_trim = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
                y_trim = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
              } 

              SHADOW_Diagrams.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
            }
          }
        }

        SHADOW_Diagrams.endShape(CLOSE);
      }

      SOLARCHVISION_Plant_branch_SHADOW(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetY, Shades_offsetY);
    }
  } else {

    // must pass all the random values here.
    float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
    float rotXY = Beta + random(-PI, PI);
    int COL = int(random(127));      

    if (Display_Leaves != 0) {

      float x0_Rotated = x0;
      float y0_Rotated = y0;
      float z0_Rotated = z0;

      if (SolarImpact_sectionType == 2) {
        float a = x0;
        float b = -y0;
        float c = z0;

        x0_Rotated = a * cos_ang(-SolarImpact_Rotation) - b * sin_ang(-SolarImpact_Rotation);     
        y0_Rotated = c;    
        z0_Rotated= a * sin_ang(-SolarImpact_Rotation) + b * cos_ang(-SolarImpact_Rotation);
      } else if (SolarImpact_sectionType == 3) {
      }


      float z = z0_Rotated - SolarImpact_Elevation;
      float x = x0_Rotated - z * SunR_Rotated[1] / SunR_Rotated[3];
      float y = y0_Rotated - z * SunR_Rotated[2] / SunR_Rotated[3];

      if (z >= 0) {

        if (SolarImpact_sectionType == 1) {                    
          float px = x;
          float py = y;

          x = px * cos_ang(-SolarImpact_Rotation) - py * sin_ang(-SolarImpact_Rotation); 
          y = px * sin_ang(-SolarImpact_Rotation) + py * cos_ang(-SolarImpact_Rotation);
        } 



        SHADOW_Diagrams.ellipse((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY, LeafSize * Shades_scaleX, LeafSize * Shades_scaleY);
      }
    }
  }
}




int[] SOLARCHVISION_get_selectedFace_Vertices () {

  int[] FaceVertices = {
    0
  };

  for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedFace_numbers[o];

    if (OBJ_NUM != 0) {

      int f = OBJ_NUM;

      for (int j = 0; j < allFaces_PNT[f].length; j++) {
        int vNo = allFaces_PNT[f][j];

        int vertex_listed = 0;

        for (int q = 1; q < FaceVertices.length; q++) {
          if (vNo == FaceVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }         

        if (vertex_listed == 0) {
          int[] newVertexListed = {
            vNo
          };
          FaceVertices = concat(FaceVertices, newVertexListed);
        }
      }
    }
  }

  return FaceVertices;
} 



int[] SOLARCHVISION_get_selectedGroup3D_Vertices () {

  int[] PolymeshVertices = {
    0
  };

  for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup3D_numbers[o];

    if (OBJ_NUM != 0) {

      for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {

        if ((0 < f) && (f < allFaces_PNT.length)) { 
          for (int j = 0; j < allFaces_PNT[f].length; j++) {

            int vNo = allFaces_PNT[f][j];

            int vertex_listed = 0;

            for (int q = 1; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }         

            if (vertex_listed == 0) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
    }
  }

  return PolymeshVertices;
} 





float[][] SOLARCHVISION_selection_BoundingBox = {
  {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
}; // [min|mid|max]

float[][] SOLARCHVISION_saved_BoundingBox = {
  {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
  , {
    0, 0, 0, 1, 1, 1, 0, 0, 0
  }
};

int SOLARCHVISION_saved_alignX = 0;
int SOLARCHVISION_saved_alignY = 0;
int SOLARCHVISION_saved_alignZ = 0;

void SOLARCHVISION_calculate_selection_BoundingBox () {


  int keep_selection_alignX = selection_alignX;
  int keep_selection_alignY = selection_alignY;
  int keep_selection_alignZ = selection_alignZ;

  selection_alignX = 0; // apply the centre
  selection_alignY = 0; // apply the centre
  selection_alignZ = 0; // apply the centre

  int[] theVertices = {
  };

  if (Current_ObjectCategory == ObjectCategory_Cameras) {
    theVertices = selectedCamera_numbers;
  } 

  if (Current_ObjectCategory == ObjectCategory_Sections) {
    theVertices = selectedSection_numbers;
  } 

  if (Current_ObjectCategory == ObjectCategory_Solids) {
    theVertices = selectedSolid_numbers;
  } 

  if ((Current_ObjectCategory == ObjectCategory_Vertices) || (Current_ObjectCategory == ObjectCategory_SoftVerts)) {
    theVertices = selectedVertex_numbers;
  }
  if (Current_ObjectCategory == ObjectCategory_Faces) {
    theVertices = SOLARCHVISION_get_selectedFace_Vertices();
  }  
  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
    theVertices = SOLARCHVISION_get_selectedGroup3D_Vertices();
  }
  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
    theVertices = selectedObject2D_numbers;
  }
  if (Current_ObjectCategory == ObjectCategory_Fractals) {
    theVertices = selectedFractal_numbers;
  }  
  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
    theVertices = selectedLandPoint_numbers;
  }    

  float posX = 0;
  float posY = 0;
  float posZ = 0;

  float scaleX = 1; 
  float scaleY = 1; 
  float scaleZ = 1; 

  float rotX = 0;
  float rotY = 0;
  float rotZ = 0;

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) { 

    int o = selectedGroup3D_numbers.length - 1; // applying the local coordinates of the last selected object <<<<<<<<<<<<<<<<<<<<<<<

    int OBJ_NUM = selectedGroup3D_numbers[o];

    posX = allGroup3Ds_PivotXYZ[OBJ_NUM][0];
    posY = allGroup3Ds_PivotXYZ[OBJ_NUM][1];
    posZ = allGroup3Ds_PivotXYZ[OBJ_NUM][2];

    scaleX = allGroup3Ds_PivotXYZ[OBJ_NUM][3];
    scaleY = allGroup3Ds_PivotXYZ[OBJ_NUM][4];
    scaleZ = allGroup3Ds_PivotXYZ[OBJ_NUM][5];

    rotX = allGroup3Ds_PivotXYZ[OBJ_NUM][6];
    rotY = allGroup3Ds_PivotXYZ[OBJ_NUM][7];
    rotZ = allGroup3Ds_PivotXYZ[OBJ_NUM][8];
  }


  for (int i = 0; i < 3; i++) {
    float ratio = 0.5 * i;
    SOLARCHVISION_selection_BoundingBox[i][0] = posX;
    SOLARCHVISION_selection_BoundingBox[i][1] = posY;
    SOLARCHVISION_selection_BoundingBox[i][2] = posZ;

    SOLARCHVISION_selection_BoundingBox[i][3] = scaleX;
    SOLARCHVISION_selection_BoundingBox[i][4] = scaleY;
    SOLARCHVISION_selection_BoundingBox[i][5] = scaleZ;

    SOLARCHVISION_selection_BoundingBox[i][6] = rotX;
    SOLARCHVISION_selection_BoundingBox[i][7] = rotY;
    SOLARCHVISION_selection_BoundingBox[i][8] = rotZ;
  }   


  float posX_min = FLOAT_undefined;
  float posY_min = FLOAT_undefined;
  float posZ_min = FLOAT_undefined;

  float posX_max = -FLOAT_undefined;  
  float posY_max = -FLOAT_undefined;  
  float posZ_max = -FLOAT_undefined;



  for (int q = 1; q < theVertices.length; q++) {

    float x = 0;
    float y = 0;
    float z = 0;

    if (Current_ObjectCategory == ObjectCategory_Cameras) {
      int n = theVertices[q];

      if ((n != 0) && (n < allCameras_num +  1)) {

        float Camera_X = allCameras_PPPSRRRF[n][0];
        float Camera_Y = allCameras_PPPSRRRF[n][1];
        float Camera_Z = allCameras_PPPSRRRF[n][2];
        float Camera_S = allCameras_PPPSRRRF[n][3];
        float Camera_RX = allCameras_PPPSRRRF[n][4];
        float Camera_RY = allCameras_PPPSRRRF[n][5];
        float Camera_RZ = allCameras_PPPSRRRF[n][6];
        float Camera_ZOOM = allCameras_PPPSRRRF[n][7];

        int Camera_Type = allCameras_Type[n];

        float[][] ImageVertex = SOLARCHVISION_getCorners_Camera(Camera_Type, Camera_X, Camera_Y, Camera_Z, Camera_S, Camera_RX, Camera_RY, Camera_RZ, Camera_ZOOM);

        // the first vertex is the Camera point
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  

    if (Current_ObjectCategory == ObjectCategory_Sections) {
      int n = theVertices[q];

      if ((n != 0) && (n < allSections_num +  1)) {

        float Section_offset_U = allSections_UVERAB[n][0];
        float Section_offset_V = allSections_UVERAB[n][1];
        float Section_Elevation = allSections_UVERAB[n][2];
        float Section_Rotation = allSections_UVERAB[n][3];
        float Section_scale_U = allSections_UVERAB[n][4];
        float Section_scale_V = allSections_UVERAB[n][5];

        int Section_Type = allSections_Type[n];
        int Section_RES1 = allSections_RES1[n];
        int Section_RES2 = allSections_RES2[n];

        float[][] ImageVertex = SOLARCHVISION_getCorners_Section(Section_Type, Section_offset_U, Section_offset_V, Section_Elevation, Section_Rotation, Section_scale_U, Section_scale_V, Section_RES1, Section_RES2);

        // the first vertex is the center of Section plane
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  

    if (Current_ObjectCategory == ObjectCategory_Solids) {
      int n = theVertices[q];

      if ((n != 0) && (n < allSolids_DEF.length)) {

        float Solid_posX = Solid_get_posX(n);
        float Solid_posY = Solid_get_posY(n);
        float Solid_posZ = Solid_get_posZ(n);
        float Solid_powX = Solid_get_powX(n);
        float Solid_powY = Solid_get_powY(n);
        float Solid_powZ = Solid_get_powZ(n);
        float Solid_scaleX = Solid_get_scaleX(n);
        float Solid_scaleY = Solid_get_scaleY(n);
        float Solid_scaleZ = Solid_get_scaleZ(n);
        float Solid_rotX = Solid_get_rotX(n);
        float Solid_rotY = Solid_get_rotY(n);
        float Solid_rotZ = Solid_get_rotZ(n);
        float Solid_value = Solid_get_value(n);

        float[][] ImageVertex = SOLARCHVISION_getCorners_Solid(0, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);

        // the first vertex is the center of Solid plane
        x = ImageVertex[0][0]; 
        y = ImageVertex[0][1]; 
        z = ImageVertex[0][2];
      }
    }  


    if ((Current_ObjectCategory == ObjectCategory_Group3Ds) || (Current_ObjectCategory == ObjectCategory_Faces) || (Current_ObjectCategory == ObjectCategory_Vertices) || (Current_ObjectCategory == ObjectCategory_SoftVerts)) {
      int n = theVertices[q];

      x = allVertices[n][0];
      y = allVertices[n][1];
      z = allVertices[n][2];
    }
    if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
      int n = theVertices[q];

      x = allObject2Ds_XYZS[n][0];
      y = allObject2Ds_XYZS[n][1];
      z = allObject2Ds_XYZS[n][2];
    }     
    if (Current_ObjectCategory == ObjectCategory_Fractals) {
      int n = theVertices[q];

      x = allFractals_XYZSR[n][0];
      y = allFractals_XYZSR[n][1];
      z = allFractals_XYZSR[n][2];
    }  
    if (Current_ObjectCategory == ObjectCategory_LandPoint) {
      int n = theVertices[q];

      int OBJ_NUM = n;

      if (OBJ_NUM != 0) {     

        int the_i = (OBJ_NUM - 1) / LAND_n_J;
        int the_j = (OBJ_NUM - 1) % LAND_n_J;

        x = LAND_MESH[the_i][the_j][0];
        y = LAND_MESH[the_i][the_j][1];
        z = LAND_MESH[the_i][the_j][2];
      } else {
        x = 0;
        y = 0;
        z = 0;
      }
    }             




    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = A[0];
    y = A[1];
    z = A[2];


    if (posX_min > x) posX_min = x;   
    if (posY_min > y) posY_min = y;   
    if (posZ_min > z) posZ_min = z;

    if (posX_max < x) posX_max = x;   
    if (posY_max < y) posY_max = y;   
    if (posZ_max < z) posZ_max = z;
  }   

  if ((posX_min != FLOAT_undefined) && (posX_max != -FLOAT_undefined) && (posY_min != FLOAT_undefined) && (posY_max != -FLOAT_undefined) && (posZ_min != FLOAT_undefined) && (posZ_max != -FLOAT_undefined)) {

    float dx = posX;
    float dy = posY;
    float dz = posZ;

    posX_min += dx;
    posY_min += dy;
    posZ_min += dz;    

    posX_max += dx;
    posY_max += dy;
    posZ_max += dz;   

    for (int i = 0; i < 3; i++) {
      float ratio = 0.5 * i;
      SOLARCHVISION_selection_BoundingBox[i][0] = (1 - ratio) * posX_min + ratio * posX_max;
      SOLARCHVISION_selection_BoundingBox[i][1] = (1 - ratio) * posY_min + ratio * posY_max;
      SOLARCHVISION_selection_BoundingBox[i][2] = (1 - ratio) * posZ_min + ratio * posZ_max;

      SOLARCHVISION_selection_BoundingBox[i][3] = scaleX;
      SOLARCHVISION_selection_BoundingBox[i][4] = scaleY;
      SOLARCHVISION_selection_BoundingBox[i][5] = scaleZ;

      SOLARCHVISION_selection_BoundingBox[i][6] = rotX;
      SOLARCHVISION_selection_BoundingBox[i][7] = rotY;
      SOLARCHVISION_selection_BoundingBox[i][8] = rotZ;
    }
  }



  selection_alignX = keep_selection_alignX;
  selection_alignY = keep_selection_alignY;
  selection_alignZ = keep_selection_alignZ;
}



void SOLARCHVISION_save_current_BoundingBox () {

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 9; j++) {
      SOLARCHVISION_saved_BoundingBox[i][j] = SOLARCHVISION_selection_BoundingBox[i][j];
    }
  } 

  SOLARCHVISION_saved_alignX = selection_alignX;
  SOLARCHVISION_saved_alignY = selection_alignY;
  SOLARCHVISION_saved_alignZ = selection_alignZ;
}


void SOLARCHVISION_apply_saved_ReferenceBox () {

  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 9; j++) {
      SOLARCHVISION_selection_BoundingBox[i][j] = SOLARCHVISION_saved_BoundingBox[i][j];
    }
  } 

  selection_alignX = SOLARCHVISION_saved_alignX;
  selection_alignY = SOLARCHVISION_saved_alignY;
  selection_alignZ = SOLARCHVISION_saved_alignZ;
}


void SOLARCHVISION_apply_origin_ReferenceBox () {

  for (int i = 0; i < 3; i++) {
    SOLARCHVISION_selection_BoundingBox[i][0] = 0;
    SOLARCHVISION_selection_BoundingBox[i][1] = 0;
    SOLARCHVISION_selection_BoundingBox[i][2] = 0;
    SOLARCHVISION_selection_BoundingBox[i][3] = 1;
    SOLARCHVISION_selection_BoundingBox[i][4] = 1;
    SOLARCHVISION_selection_BoundingBox[i][5] = 1;
    SOLARCHVISION_selection_BoundingBox[i][6] = 0;
    SOLARCHVISION_selection_BoundingBox[i][7] = 0;
    SOLARCHVISION_selection_BoundingBox[i][8] = 0;
  }

  //selection_alignX = 0;
  //selection_alignY = 0;
  //selection_alignZ = 0;
}




void SOLARCHVISION_reset_selectedRefValues () {

  selected_posValue = 0;  
  selected_rotValue = 0;  
  selected_scaleValue = 0;
}





void SOLARCHVISION_move_selectedGroup3Ds (float dx, float dy, float dz) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedGroup3D_Vertices();

  for (int q = 1; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    allVertices[n][0] += dx; 
    allVertices[n][1] += dy;
    allVertices[n][2] += dz;
  }

  int Solids_updated = 0;

  for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup3D_numbers[o];

    if (OBJ_NUM != 0) {  

      {
        allGroup3Ds_PivotXYZ[OBJ_NUM][0] += dx;
        allGroup3Ds_PivotXYZ[OBJ_NUM][1] += dy;
        allGroup3Ds_PivotXYZ[OBJ_NUM][2] += dz;
      }

      for (int f = allGroup3Ds_Fractals[OBJ_NUM][0]; f <= allGroup3Ds_Fractals[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allFractals_num)) {

          allFractals_XYZSR[f][0] += dx;
          allFractals_XYZSR[f][1] += dy;
          allFractals_XYZSR[f][2] += dz;
        }
      }

      for (int f = allGroup3Ds_Object2Ds[OBJ_NUM][0]; f <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allObject2Ds_num)) {

          allObject2Ds_XYZS[f][0] += dx;
          allObject2Ds_XYZS[f][1] += dy;
          allObject2Ds_XYZS[f][2] += dz;
        }
      }

      for (int f = allGroup3Ds_Solids[OBJ_NUM][0]; f <= allGroup3Ds_Solids[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allSolids_DEF.length - 1)) {

          float Solid_posX = Solid_get_posX(f);
          float Solid_posY = Solid_get_posY(f);
          float Solid_posZ = Solid_get_posZ(f);

          Solid_updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

          Solids_updated = 1;
        }
      }
    }
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}

void SOLARCHVISION_rotate_selectedGroup3Ds (float r, int the_Vector) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedGroup3D_Vertices();

  for (int q = 1; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    float x = allVertices[n][0]; 
    float y = allVertices[n][1]; 
    float z = allVertices[n][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = A[0];
    y = A[1];
    z = A[2];

    {
      float a = x;
      float b = y;
      float c = z;

      if (the_Vector == 2) {
        a = x * cos(r) - y * sin(r); 
        b = x * sin(r) + y * cos(r);
        c = z;
      } else if (the_Vector == 1) {
        a = z * sin(r) + x * cos(r); 
        b = y;
        c = z * cos(r) - x * sin(r);
      } else if (the_Vector == 0) {
        a = x;
        b = y * cos(r) - z * sin(r);
        c = y * sin(r) + z * cos(r);
      }   

      x = a;
      y = b;
      z = c;
    }

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[n][0] = x; 
    allVertices[n][1] = y;
    allVertices[n][2] = z;
  }






  int Solids_updated = 0;

  for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup3D_numbers[o];

    if (OBJ_NUM != 0) {  

      { 
        float x = allGroup3Ds_PivotXYZ[OBJ_NUM][0]; 
        float y = allGroup3Ds_PivotXYZ[OBJ_NUM][1]; 
        float z = allGroup3Ds_PivotXYZ[OBJ_NUM][2];

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2];

        {
          float a = x;
          float b = y;
          float c = z;

          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r); 
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r); 
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }   

          x = a;
          y = b;
          z = c;
        }

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allGroup3Ds_PivotXYZ[OBJ_NUM][0] = x;
        allGroup3Ds_PivotXYZ[OBJ_NUM][1] = y;
        allGroup3Ds_PivotXYZ[OBJ_NUM][2] = z;

        if (the_Vector == 2) {
          allGroup3Ds_PivotXYZ[OBJ_NUM][8] += r * 180.0 / PI;
        } else if (the_Vector == 1) {
          allGroup3Ds_PivotXYZ[OBJ_NUM][7] += r * 180.0 / PI;
        } else if (the_Vector == 0) {
          allGroup3Ds_PivotXYZ[OBJ_NUM][6] += r * 180.0 / PI;
        }
      }    


      for (int f = allGroup3Ds_Fractals[OBJ_NUM][0]; f <= allGroup3Ds_Fractals[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allFractals_num)) {

          float x = allFractals_XYZSR[f][0]; 
          float y = allFractals_XYZSR[f][1]; 
          float z = allFractals_XYZSR[f][2];

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   

            x = a;
            y = b;
            z = c;
          }

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allFractals_XYZSR[f][0] = x;
          allFractals_XYZSR[f][1] = y;
          allFractals_XYZSR[f][2] = z;


          if (the_Vector == 2) {
            allFractals_XYZSR[f][4] += r; // <<<<<<<<<
          } else if (the_Vector == 1) {
          } else if (the_Vector == 0) {
          }
        }
      }         

      for (int f = allGroup3Ds_Object2Ds[OBJ_NUM][0]; f <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allObject2Ds_num)) {

          float x = allObject2Ds_XYZS[f][0]; 
          float y = allObject2Ds_XYZS[f][1]; 
          float z = allObject2Ds_XYZS[f][2];

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   

            x = a;
            y = b;
            z = c;
          }

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allObject2Ds_XYZS[f][0] = x;
          allObject2Ds_XYZS[f][1] = y;
          allObject2Ds_XYZS[f][2] = z;
        }
      }         

      for (int f = allGroup3Ds_Solids[OBJ_NUM][0]; f <= allGroup3Ds_Solids[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allSolids_DEF.length - 1)) {

          float x = Solid_get_posX(f);
          float y = Solid_get_posY(f);
          float z = Solid_get_posZ(f);

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = A[0];
          y = A[1];
          z = A[2];

          {
            float a = x;
            float b = y;
            float c = z;

            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   

            x = a;
            y = b;
            z = c;
          }

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];


          Solid_updatePosition(f, x, y, z);

          // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Note: these rotations could be translated to locals to avoid problems!
          if (the_Vector == 2) {
            Solid_RotateZ(f, r * 180 / PI);
          } else if (the_Vector == 1) {
            Solid_RotateY(f, r * 180 / PI);
          } else if (the_Vector == 0) {
            Solid_RotateX(f, r * 180 / PI);
          }

          Solids_updated = 1;
        }
      }
    }
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}



void SOLARCHVISION_scale_selectedGroup3Ds (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] PolymeshVertices = SOLARCHVISION_get_selectedGroup3D_Vertices();

  for (int q = 1; q < PolymeshVertices.length; q++) {

    int n = PolymeshVertices[q];

    float x = allVertices[n][0]; 
    float y = allVertices[n][1]; 
    float z = allVertices[n][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[n][0] = x; 
    allVertices[n][1] = y;
    allVertices[n][2] = z;
  }

  int n1 = Object2D_PEOPLE_Files_Num;

  int Solids_updated = 0;

  for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

    int OBJ_NUM = selectedGroup3D_numbers[o];

    if (OBJ_NUM != 0) {

      {
        float x = allGroup3Ds_PivotXYZ[OBJ_NUM][0]; 
        float y = allGroup3Ds_PivotXYZ[OBJ_NUM][1]; 
        float z = allGroup3Ds_PivotXYZ[OBJ_NUM][2];

        float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;

        float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

        x = B[0];
        y = B[1];
        z = B[2];

        allGroup3Ds_PivotXYZ[OBJ_NUM][0] = x; 
        allGroup3Ds_PivotXYZ[OBJ_NUM][1] = y;
        allGroup3Ds_PivotXYZ[OBJ_NUM][2] = z;        

        // ???????
        //allGroup3Ds_PivotXYZ[OBJ_NUM][3] *= sx; 
        //allGroup3Ds_PivotXYZ[OBJ_NUM][4] *= sy;
        //allGroup3Ds_PivotXYZ[OBJ_NUM][5] *= sz;
        // ???????
      }


      for (int f = allGroup3Ds_Fractals[OBJ_NUM][0]; f <= allGroup3Ds_Fractals[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allFractals_num)) {

          float x = allFractals_XYZSR[f][0];
          float y = allFractals_XYZSR[f][1]; 
          float z = allFractals_XYZSR[f][2];

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];

          allFractals_XYZSR[f][0] = x;
          allFractals_XYZSR[f][1] = y;
          allFractals_XYZSR[f][2] = z;

          allFractals_XYZSR[f][3] *= sz;
        }
      }  


      for (int f = allGroup3Ds_Object2Ds[OBJ_NUM][0]; f <= allGroup3Ds_Object2Ds[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allObject2Ds_num)) {

          float x = allObject2Ds_XYZS[f][0];
          float y = allObject2Ds_XYZS[f][1]; 
          float z = allObject2Ds_XYZS[f][2];

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0];
          y = B[1];
          z = B[2];         

          allObject2Ds_XYZS[f][0] = x; 
          allObject2Ds_XYZS[f][1] = y;
          allObject2Ds_XYZS[f][2] = z;

          int n = allObject2Ds_MAP[f];

          if (abs(n) > n1) { // does not scale poeple!    
            allObject2Ds_XYZS[f][3] *= sz;
          }
        }
      }     

      for (int f = allGroup3Ds_Solids[OBJ_NUM][0]; f <= allGroup3Ds_Solids[OBJ_NUM][1]; f++) {
        if ((0 < f) && (f <= allSolids_DEF.length - 1)) {

          float x = Solid_get_posX(f);
          float y = Solid_get_posY(f);
          float z = Solid_get_posZ(f);

          float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;

          float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

          x = B[0]; 
          y = B[1];
          z = B[2];

          Solid_updatePosition(f, x, y, z);

          Solid_Scale(f, sx, sy, sz);

          Solids_updated = 1;
        }
      }
    }
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}



void SOLARCHVISION_move_selectedFaces (float dx, float dy, float dz) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();

  for (int q = 1; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    allVertices[f][0] += dx; 
    allVertices[f][1] += dy;
    allVertices[f][2] += dz;
  }
}

void SOLARCHVISION_rotate_selectedFaces (float x0, float y0, float z0, float r, int the_Vector) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();

  for (int q = 1; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[f][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}

void SOLARCHVISION_scale_selectedFaces (float x0, float y0, float z0, float sx, float sy, float sz) {

  int[] FaceVertices = SOLARCHVISION_get_selectedFace_Vertices();

  for (int q = 1; q < FaceVertices.length; q++) {

    int f = FaceVertices[q];

    float x = allVertices[f][0];
    float y = allVertices[f][1];
    float z = allVertices[f][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];    

    allVertices[f][0] = x; 
    allVertices[f][1] = y;
    allVertices[f][2] = z;
  }
}


void SOLARCHVISION_move_selectedVertices (float dx, float dy, float dz) {

  for (int q = 1; q < selectedVertex_numbers.length; q++) {

    int f = selectedVertex_numbers[q];

    allVertices[f][0] += dx; 
    allVertices[f][1] += dy;
    allVertices[f][2] += dz;
  }
}


void SOLARCHVISION_rotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedVertex_numbers.length; q++) {

    int f = selectedVertex_numbers[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allVertices[f][1] = y0 + (x * sin(r) + y * cos(r));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r) - z * sin(r));
      allVertices[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}


void SOLARCHVISION_scale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 1; q < selectedVertex_numbers.length; q++) {

    int f = selectedVertex_numbers[q];

    float x = allVertices[f][0]; 
    float y = allVertices[f][1]; 
    float z = allVertices[f][2];

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0];
    y = B[1];
    z = B[2];

    allVertices[f][0] = x; 
    allVertices[f][1] = y;
    allVertices[f][2] = z;
  }
}




float SOLARCHVISION_softVertexSelectionFunction (float d_min) {

  float v = 0;

  if (d_min < softSelection_Radius) {
    v = pow(cos_ang(90 * d_min / softSelection_Radius), softSelection_Power);
  }

  return v;
}

void SOLARCHVISION_softMove_selectedVertices (float dx, float dy, float dz) {

  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];

    allVertices[f][0] += dx * v; 
    allVertices[f][1] += dy * v;
    allVertices[f][2] += dz * v;
  }
}


void SOLARCHVISION_softRotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    if (the_Vector == 2) {
      allVertices[f][0] = x0 + (x * cos(r * v) - y * sin(r * v)); 
      allVertices[f][1] = y0 + (x * sin(r * v) + y * cos(r * v));
      allVertices[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allVertices[f][0] = x0 + (z * sin(r * v) + x * cos(r * v)); 
      allVertices[f][1] = y0 + (y);
      allVertices[f][2] = z0 + (z * cos(r * v) - x * sin(r * v));
    } else if (the_Vector == 0) {
      allVertices[f][0] = x0 + (x); 
      allVertices[f][1] = y0 + (y * cos(r * v) - z * sin(r * v));
      allVertices[f][2] = z0 + (y * sin(r * v) + z * cos(r * v));
    }
  }
}



void SOLARCHVISION_softScale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 1; q < selectedVertex_softSelectionVertices.length; q++) {

    int f = selectedVertex_softSelectionVertices[q];

    float v = selectedVertex_softSelectionValues[q];    

    float x = allVertices[f][0] - x0; 
    float y = allVertices[f][1] - y0; 
    float z = allVertices[f][2] - z0;

    allVertices[f][0] = (x0 + sx * x) * v + (x0 + x) * (1 - v); 
    allVertices[f][1] = (y0 + sy * y) * v + (y0 + y) * (1 - v); 
    allVertices[f][2] = (z0 + sz * z) * v + (z0 + z) * (1 - v);
  }
}



void SOLARCHVISION_scale_selectedObject2Ds (float x0, float y0, float z0, float sx, float sy, float sz) { 

  int n1 = Object2D_PEOPLE_Files_Num;    

  for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

    int f = selectedObject2D_numbers[o];

    if (f != 0) {      

      float x = allObject2Ds_XYZS[f][0];
      float y = allObject2Ds_XYZS[f][1]; 
      float z = allObject2Ds_XYZS[f][2];

      float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];         

      allObject2Ds_XYZS[f][0] = x; 
      allObject2Ds_XYZS[f][1] = y;
      allObject2Ds_XYZS[f][2] = z;    


      int n = allObject2Ds_MAP[f];

      if (abs(n) > n1) { // does not scale poeple!    
        allObject2Ds_XYZS[f][3] *= sz;
      }
    }
  }
}


void SOLARCHVISION_rotate_selectedObject2Ds (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedObject2D_numbers.length; q++) {

    int f = selectedObject2D_numbers[q];

    float x = allObject2Ds_XYZS[f][0] - x0; 
    float y = allObject2Ds_XYZS[f][1] - y0; 
    float z = allObject2Ds_XYZS[f][2] - z0;

    if (the_Vector == 2) {
      allObject2Ds_XYZS[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allObject2Ds_XYZS[f][1] = y0 + (x * sin(r) + y * cos(r));
      allObject2Ds_XYZS[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allObject2Ds_XYZS[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allObject2Ds_XYZS[f][1] = y0 + (y);
      allObject2Ds_XYZS[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allObject2Ds_XYZS[f][0] = x0 + (x); 
      allObject2Ds_XYZS[f][1] = y0 + (y * cos(r) - z * sin(r));
      allObject2Ds_XYZS[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}



void SOLARCHVISION_move_selectedObject2Ds (float dx, float dy, float dz) {

  for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

    int f = selectedObject2D_numbers[o];

    if (f != 0) {      

      allObject2Ds_XYZS[f][0] += dx; 
      allObject2Ds_XYZS[f][1] += dy; 
      allObject2Ds_XYZS[f][2] += dz;
    }
  }
} 


void SOLARCHVISION_scale_selectedFractals (float x0, float y0, float z0, float sx, float sy, float sz) { 

  for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

    int f = selectedFractal_numbers[o];

    if (f != 0) {      

      float x = allFractals_XYZSR[f][0];
      float y = allFractals_XYZSR[f][1]; 
      float z = allFractals_XYZSR[f][2];

      float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      allFractals_XYZSR[f][0] = x;
      allFractals_XYZSR[f][1] = y;
      allFractals_XYZSR[f][2] = z;

      allFractals_XYZSR[f][3] *= sz;
    }
  }
}


void SOLARCHVISION_rotate_selectedFractals (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedFractal_numbers.length; q++) {

    int f = selectedFractal_numbers[q];

    float x = allFractals_XYZSR[f][0] - x0; 
    float y = allFractals_XYZSR[f][1] - y0; 
    float z = allFractals_XYZSR[f][2] - z0;

    if (the_Vector == 2) {
      allFractals_XYZSR[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allFractals_XYZSR[f][1] = y0 + (x * sin(r) + y * cos(r));
      allFractals_XYZSR[f][2] = z0 + (z);

      allFractals_XYZSR[f][4] += r; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    } else if (the_Vector == 1) {
      allFractals_XYZSR[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allFractals_XYZSR[f][1] = y0 + (y);
      allFractals_XYZSR[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allFractals_XYZSR[f][0] = x0 + (x); 
      allFractals_XYZSR[f][1] = y0 + (y * cos(r) - z * sin(r));
      allFractals_XYZSR[f][2] = z0 + (y * sin(r) + z * cos(r));
    }
  }
}


void SOLARCHVISION_move_selectedFractals (float dx, float dy, float dz) {

  for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

    int f = selectedFractal_numbers[o];

    if (f != 0) {      

      allFractals_XYZSR[f][0] += dx; 
      allFractals_XYZSR[f][1] += dy; 
      allFractals_XYZSR[f][2] += dz;
    }
  }
} 


void SOLARCHVISION_move_selectedSolids (float dx, float dy, float dz) {

  int Solids_updated = 0; 

  for (int q = 1; q < selectedSolid_numbers.length; q++) {

    int f = selectedSolid_numbers[q];

    float Solid_posX = Solid_get_posX(f);
    float Solid_posY = Solid_get_posY(f);
    float Solid_posZ = Solid_get_posZ(f);

    Solid_updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);

    Solids_updated = 1;
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}


void SOLARCHVISION_rotate_selectedSolids (float x0, float y0, float z0, float r, int the_Vector) {

  int Solids_updated = 0; 

  for (int q = 1; q < selectedSolid_numbers.length; q++) {

    int f = selectedSolid_numbers[q];

    float Solid_posX = Solid_get_posX(f);
    float Solid_posY = Solid_get_posY(f);
    float Solid_posZ = Solid_get_posZ(f);


    float x = Solid_posX - x0; 
    float y = Solid_posY - y0; 
    float z = Solid_posZ - z0;

    if (the_Vector == 2) {
      Solid_updatePosition(f, x0 + (x * cos(r) - y * sin(r)), y0 + (x * sin(r) + y * cos(r)), z0 + (z));

      Solid_RotateZ(f, r * 180 / PI);
    } else if (the_Vector == 1) {
      Solid_updatePosition(f, x0 + (z * sin(r) + x * cos(r)), y0 + (y), z0 + (z * cos(r) - x * sin(r)));

      Solid_RotateY(f, r * 180 / PI);
    } else if (the_Vector == 0) {
      Solid_updatePosition(f, x0 + (x), y0 + (y * cos(r) - z * sin(r)), z0 + (y * sin(r) + z * cos(r)));

      Solid_RotateX(f, r * 180 / PI);
    }

    Solids_updated = 1;
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}


void SOLARCHVISION_scale_selectedSolids (float x0, float y0, float z0, float sx, float sy, float sz) {

  int Solids_updated = 0; 

  for (int q = 1; q < selectedSolid_numbers.length; q++) {

    int f = selectedSolid_numbers[q];

    float x = Solid_get_posX(f);
    float y = Solid_get_posY(f);
    float z = Solid_get_posZ(f);

    float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

    x = sx * (A[0] - x0) + x0;
    y = sy * (A[1] - y0) + y0;
    z = sz * (A[2] - z0) + z0;

    float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

    x = B[0]; 
    y = B[1];
    z = B[2];

    Solid_updatePosition(f, x, y, z);

    Solid_Scale(f, sx, sy, sz);    

    Solids_updated = 1;
  }

  if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
}


void SOLARCHVISION_move_selectedSections (float dx, float dy, float dz) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {

    int f = selectedSection_numbers[q];

    allSections_UVERAB[f][0] += dx;
    allSections_UVERAB[f][1] += dy;
    allSections_UVERAB[f][2] += dz;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedSections();

  WIN3D_Update = 1;
  ROLLOUT_Update = 1;
}


void SOLARCHVISION_rotate_selectedSections (float r) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {

    int f = selectedSection_numbers[q];

    allSections_UVERAB[f][3] += r * 180.0 / PI;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedSections(); 

  WIN3D_Update = 1;
  ROLLOUT_Update = 1;
}

void SOLARCHVISION_scale_selectedSections (float sx, float sy) {

  for (int q = 1; q < selectedSection_numbers.length; q++) {

    int f = selectedSection_numbers[q];

    allSections_UVERAB[f][4] *= sx;
    allSections_UVERAB[f][5] *= sy;
  }

  SOLARCHVISION_calculate_SolidImpact_selectedSections(); 

  WIN3D_Update = 1;
  ROLLOUT_Update = 1;
}


void SOLARCHVISION_move_selectedCameras (float dx, float dy, float dz) {

  // swapping y and z vectors to match camera's local coordinate
  float tmp = dz;
  dz = dy;
  dy = tmp;

  for (int q = 1; q < selectedCamera_numbers.length; q++) {

    int f = selectedCamera_numbers[q];

    allCameras_PPPSRRRF[f][0] += dx; 
    allCameras_PPPSRRRF[f][1] += dy;
    allCameras_PPPSRRRF[f][2] += dz;

    if (f == WIN3D_CurrentCamera) SOLARCHVISION_apply_currentCamera();
  }
}


void SOLARCHVISION_rotate_selectedCameras (float x0, float y0, float z0, float r, int the_Vector) {

  // swapping y and z vectors to match camera's local coordinate
  if (the_Vector == 2) the_Vector = 1;
  else if (the_Vector == 1) the_Vector = 2;

  for (int q = 1; q < selectedCamera_numbers.length; q++) {

    int f = selectedCamera_numbers[q];

    float x = allCameras_PPPSRRRF[f][0] - x0; 
    float y = allCameras_PPPSRRRF[f][1] - y0; 
    float z = allCameras_PPPSRRRF[f][2] - z0;

    if (the_Vector == 2) {
      allCameras_PPPSRRRF[f][0] = x0 + (x * cos(r) - y * sin(r)); 
      allCameras_PPPSRRRF[f][1] = y0 + (x * sin(r) + y * cos(r));
      allCameras_PPPSRRRF[f][2] = z0 + (z);
    } else if (the_Vector == 1) {
      allCameras_PPPSRRRF[f][0] = x0 + (z * sin(r) + x * cos(r)); 
      allCameras_PPPSRRRF[f][1] = y0 + (y);
      allCameras_PPPSRRRF[f][2] = z0 + (z * cos(r) - x * sin(r));
    } else if (the_Vector == 0) {
      allCameras_PPPSRRRF[f][0] = x0 + (x); 
      allCameras_PPPSRRRF[f][1] = y0 + (y * cos(r) - z * sin(r));
      allCameras_PPPSRRRF[f][2] = z0 + (y * sin(r) + z * cos(r));
    }    

    if (f == WIN3D_CurrentCamera) SOLARCHVISION_apply_currentCamera();
  }
}


void SOLARCHVISION_scale_selectedCameras (float x0, float y0, float z0, float sx, float sy, float sz) {

  // swapping y and z vectors to match camera's local coordinate
  float tmp = sz;
  sz = sy;
  sy = tmp;

  for (int q = 1; q < selectedCamera_numbers.length; q++) {

    int f = selectedCamera_numbers[q];

    float x = allCameras_PPPSRRRF[f][0] - x0; 
    float y = allCameras_PPPSRRRF[f][1] - y0; 
    float z = allCameras_PPPSRRRF[f][2] - z0;

    allCameras_PPPSRRRF[f][0] = x0 + sx * x; 
    allCameras_PPPSRRRF[f][1] = y0 + sy * y;
    allCameras_PPPSRRRF[f][2] = z0 + sz * z;

    if (f == WIN3D_CurrentCamera) SOLARCHVISION_apply_currentCamera();
  }
}


void SOLARCHVISION_flatten_selectedLandPoints () {

  for (int q = 1; q < selectedLandPoint_numbers.length; q++) {

    int f = selectedLandPoint_numbers[q];

    if (f != 0) {      

      int i = (f - 1) / LAND_n_J;
      int j = (f - 1) % LAND_n_J;

      LAND_MESH[i][j][2] = 0;
    }
  }
}



void SOLARCHVISION_move_selectedLandPoints (float dx, float dy, float dz) {

  for (int q = 1; q < selectedLandPoint_numbers.length; q++) {

    int f = selectedLandPoint_numbers[q];

    if (f != 0) {      

      int i = (f - 1) / LAND_n_J;
      int j = (f - 1) % LAND_n_J;

      LAND_MESH[i][j][0] += dx; 
      LAND_MESH[i][j][1] += dy;
      LAND_MESH[i][j][2] += dz;
    }
  }
}


void SOLARCHVISION_rotate_selectedLandPoints (float x0, float y0, float z0, float r, int the_Vector) {

  for (int q = 1; q < selectedLandPoint_numbers.length; q++) {

    int f = selectedLandPoint_numbers[q];

    if (f != 0) {      

      int i = (f - 1) / LAND_n_J;
      int j = (f - 1) % LAND_n_J;

      float x = LAND_MESH[i][j][0] - x0; 
      float y = LAND_MESH[i][j][1] - y0; 
      float z = LAND_MESH[i][j][2] - z0;

      if (the_Vector == 2) {
        LAND_MESH[i][j][0] = x0 + (x * cos(r) - y * sin(r)); 
        LAND_MESH[i][j][1] = y0 + (x * sin(r) + y * cos(r));
        LAND_MESH[i][j][2] = z0 + (z);
      } else if (the_Vector == 1) {
        LAND_MESH[i][j][0] = x0 + (z * sin(r) + x * cos(r)); 
        LAND_MESH[i][j][1] = y0 + (y);
        LAND_MESH[i][j][2] = z0 + (z * cos(r) - x * sin(r));
      } else if (the_Vector == 0) {
        LAND_MESH[i][j][0] = x0 + (x); 
        LAND_MESH[i][j][1] = y0 + (y * cos(r) - z * sin(r));
        LAND_MESH[i][j][2] = z0 + (y * sin(r) + z * cos(r));
      }
    }
  }
}


void SOLARCHVISION_scale_selectedLandPoints (float x0, float y0, float z0, float sx, float sy, float sz) {

  for (int q = 1; q < selectedLandPoint_numbers.length; q++) {

    int f = selectedLandPoint_numbers[q];

    if (f != 0) {      

      int i = (f - 1) / LAND_n_J;
      int j = (f - 1) % LAND_n_J;

      float x = LAND_MESH[i][j][0];
      float y = LAND_MESH[i][j][1]; 
      float z = LAND_MESH[i][j][2];

      float[] A = SOLARCHVISION_translateOutside_ReferencePivot(x, y, z);

      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;

      float[] B = SOLARCHVISION_translateInside_ReferencePivot(x, y, z);

      x = B[0];
      y = B[1];
      z = B[2];

      LAND_MESH[i][j][0] = x; 
      LAND_MESH[i][j][1] = y;
      LAND_MESH[i][j][2] = z;
    }
  }
}



void SOLARCHVISION_scale_Selection (float x0, float y0, float z0, float sx, float sy, float sz) {

  float[] O = SOLARCHVISION_translateOutside_ReferencePivot(x0, y0, z0);

  x0 = O[0];
  y0 = O[1];
  z0 = O[2];    


  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    SOLARCHVISION_scale_selectedCameras(x0, y0, z0, sx, sy, sz);
  }   

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    SOLARCHVISION_scale_selectedSections(sx, sy);
  }   

  if (Current_ObjectCategory == ObjectCategory_Solids) {
    SOLARCHVISION_scale_selectedSolids(x0, y0, z0, sx, sy, sz);
  }       

  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {

    SOLARCHVISION_softScale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }    

  if (Current_ObjectCategory == ObjectCategory_Vertices) {

    SOLARCHVISION_scale_selectedVertices(x0, y0, z0, sx, sy, sz);
  }  

  if (Current_ObjectCategory == ObjectCategory_Faces) {

    SOLARCHVISION_scale_selectedFaces(x0, y0, z0, sx, sy, sz);
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    SOLARCHVISION_scale_selectedGroup3Ds(x0, y0, z0, sx, sy, sz);
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    SOLARCHVISION_scale_selectedObject2Ds(x0, y0, z0, sx, sy, sz);
  }

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    SOLARCHVISION_scale_selectedFractals(x0, y0, z0, sx, sy, sz);
  }  

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {

    SOLARCHVISION_scale_selectedLandPoints(x0, y0, z0, sx, sy, sz);
  }
}



void SOLARCHVISION_rotate_Selection (float x0, float y0, float z0, float r, int the_Vector) {

  float[] A = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
  float[] B = SOLARCHVISION_translateInside_ReferencePivot(x0, y0, z0);

  x0 = B[0] - A[0];
  y0 = B[1] - A[1];
  z0 = B[2] - A[2];  


  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    SOLARCHVISION_rotate_selectedCameras(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    SOLARCHVISION_rotate_selectedSections(r);
  }   

  if (Current_ObjectCategory == ObjectCategory_Solids) {

    SOLARCHVISION_rotate_selectedSolids(x0, y0, z0, r, the_Vector);
  }       

  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {

    SOLARCHVISION_softRotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory_Vertices) {

    SOLARCHVISION_rotate_selectedVertices(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory_Faces) {

    SOLARCHVISION_rotate_selectedFaces(x0, y0, z0, r, the_Vector);
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    SOLARCHVISION_rotate_selectedGroup3Ds(r, the_Vector);
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    SOLARCHVISION_rotate_selectedObject2Ds(x0, y0, z0, r, the_Vector);
  }

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    SOLARCHVISION_rotate_selectedFractals(x0, y0, z0, r, the_Vector);
  }   

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {

    SOLARCHVISION_rotate_selectedLandPoints(x0, y0, z0, r, the_Vector);
  }
} 






void SOLARCHVISION_move_Selection (float dx, float dy, float dz) {

  float[] A = SOLARCHVISION_translateInside_ReferencePivot(0, 0, 0);
  float[] B = SOLARCHVISION_translateInside_ReferencePivot(dx, dy, dz);

  dx = B[0] - A[0];
  dy = B[1] - A[1];
  dz = B[2] - A[2];




  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    SOLARCHVISION_move_selectedCameras(dx, dy, dz);
  }     

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    SOLARCHVISION_move_selectedSections(dx, dy, dz);
  }   

  if (Current_ObjectCategory == ObjectCategory_Solids) {

    SOLARCHVISION_move_selectedSolids(dx, dy, dz);
  }      

  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {

    SOLARCHVISION_softMove_selectedVertices(dx, dy, dz);
  }    

  if (Current_ObjectCategory == ObjectCategory_Vertices) {

    SOLARCHVISION_move_selectedVertices(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory_Faces) {

    SOLARCHVISION_move_selectedFaces(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    SOLARCHVISION_move_selectedGroup3Ds(dx, dy, dz);
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    SOLARCHVISION_move_selectedObject2Ds(dx, dy, dz);
  }  

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    SOLARCHVISION_move_selectedFractals(dx, dy, dz);
  }    

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {

    SOLARCHVISION_move_selectedLandPoints(dx, dy, dz);
  }
}


void SOLARCHVISION_drop_Selection () {


  if (Current_ObjectCategory == ObjectCategory_Cameras) {
  }     

  if (Current_ObjectCategory == ObjectCategory_Sections) {
  }   

  if (Current_ObjectCategory == ObjectCategory_Solids) {
  }      

  if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
  }    

  if (Current_ObjectCategory == ObjectCategory_Vertices) {
  }  

  if (Current_ObjectCategory == ObjectCategory_Faces) {
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {

    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedObject2D_numbers[o];

      if (OBJ_NUM != 0) {      

        float x = allObject2Ds_XYZS[OBJ_NUM][0];
        float y = allObject2Ds_XYZS[OBJ_NUM][1];
        float z = allObject2Ds_XYZS[OBJ_NUM][2];

        float[] ray_start = {
          x, y, z
        };

        float[] ray_direction = {
          0, 0, -1
        };

        float[] RxP = new float [8];

        if (WIN3D_UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
        } else if (WIN3D_UI_TaskModifyParameter == 1) {
          RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] > 0) {
          allObject2Ds_XYZS[OBJ_NUM][0] = RxP[1]; 
          allObject2Ds_XYZS[OBJ_NUM][1] = RxP[2]; 
          allObject2Ds_XYZS[OBJ_NUM][2] = RxP[3];
        } else {
          ray_direction[2] = 1; // <<<< going upwards

          if (WIN3D_UI_TaskModifyParameter == 0) { 
            RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
          } else if (WIN3D_UI_TaskModifyParameter == 2) {
            RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
          } else {
            RxP[0] = -1; // undefined
          }

          if (RxP[0] > 0) {
            allObject2Ds_XYZS[OBJ_NUM][0] = RxP[1]; 
            allObject2Ds_XYZS[OBJ_NUM][1] = RxP[2]; 
            allObject2Ds_XYZS[OBJ_NUM][2] = RxP[3];
          }
        }
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFractal_numbers[o];

      if (OBJ_NUM != 0) {      

        float x = allFractals_XYZSR[OBJ_NUM][0];
        float y = allFractals_XYZSR[OBJ_NUM][1];
        float z = allFractals_XYZSR[OBJ_NUM][2];

        float[] ray_start = {
          x, y, z
        };

        float[] ray_direction = {
          0, 0, -1
        };

        float[] RxP = new float [8];

        if (WIN3D_UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
        } else if (WIN3D_UI_TaskModifyParameter == 1) {
          RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }

        if (RxP[0] > 0) {
          allFractals_XYZSR[OBJ_NUM][0] = RxP[1]; 
          allFractals_XYZSR[OBJ_NUM][1] = RxP[2]; 
          allFractals_XYZSR[OBJ_NUM][2] = RxP[3];
        } else {
          ray_direction[2] = 1; // <<<< going upwards

          if (WIN3D_UI_TaskModifyParameter == 0) { 
            RxP = SOLARCHVISION_0Dintersect(ray_start, ray_direction);
          } else if (WIN3D_UI_TaskModifyParameter == 2) {
            RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);
          } else {
            RxP[0] = -1; // undefined
          }

          if (RxP[0] > 0) {
            allFractals_XYZSR[OBJ_NUM][0] = RxP[1]; 
            allFractals_XYZSR[OBJ_NUM][1] = RxP[2]; 
            allFractals_XYZSR[OBJ_NUM][2] = RxP[3];
          }
        }
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_LandPoint) {
  }
}



void SOLARCHVISION_changeProperties_Selection (int p) {

  if (Current_ObjectCategory == ObjectCategory_Cameras) {

    for (int o = selectedCamera_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedCamera_numbers[o];

      if (OBJ_NUM != 0) {      

        int f = OBJ_NUM;

        if (WIN3D_UI_CurrentTask == 4) {
          int n = allCameras_Type[f];
          n += p;
          if (n > 1) n = 0;
          if (n < 0) n = 1;
          allCameras_Type[f] = n;         

          if (f == WIN3D_CurrentCamera) WIN3D_ViewType = allCameras_Type[f];
        }
      }
    }
  }    

  if (Current_ObjectCategory == ObjectCategory_Sections) {

    int Solids_updated = 0;  

    for (int o = selectedSection_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSection_numbers[o];

      if (OBJ_NUM != 0) {      

        int f = OBJ_NUM;

        if (WIN3D_UI_CurrentTask == 4) {
          int n = allSections_Type[f];
          n += p;
          if (n > 3) n = 0;
          if (n < 0) n = 3;
          allSections_Type[f] = n;         

          Solids_updated = 1;
        }        

        if (WIN3D_UI_CurrentTask == 5) {
          int n = allSections_RES1[f];
          if (p > 0) n *= 2;
          if (p < 0) n /= 2;

          if (n > 1600) n = 100;
          if (n < 100) n = 1600;
          allSections_RES1[f] = n;

          allSections_RES2[f] = n; // also modifying the other one

          println("RES:", n);

          Solids_updated = 1;
        }
      }
    } 

    if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
  }  


  if (Current_ObjectCategory == ObjectCategory_Solids) {

    int Solids_updated = 0;  

    for (int o = selectedSolid_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedSolid_numbers[o];

      if (OBJ_NUM != 0) {      

        int f = OBJ_NUM;

        if ((WIN3D_UI_CurrentTask == 19) ||  (WIN3D_UI_CurrentTask == 20) ||  (WIN3D_UI_CurrentTask == 21) ||  (WIN3D_UI_CurrentTask == 22)) {


          float Solid_powX = Solid_get_powX(f);
          float Solid_powY = Solid_get_powY(f);
          float Solid_powZ = Solid_get_powZ(f);


          float n = 2;

          if (WIN3D_UI_CurrentTask == 19) n = Solid_powX; 
          if (WIN3D_UI_CurrentTask == 20) n = Solid_powY; 
          if (WIN3D_UI_CurrentTask == 21) n = Solid_powZ; 
          if (WIN3D_UI_CurrentTask == 22) {
            n = Solid_powX;
          }          

          if (p > 0) n *= 2;
          if (p < 0) n /= 2;

          if (n > CubePower) n = StarPower;
          if (n < StarPower) n = CubePower;

          if (WIN3D_UI_CurrentTask == 19) Solid_powX = n; 
          if (WIN3D_UI_CurrentTask == 20) Solid_powY = n; 
          if (WIN3D_UI_CurrentTask == 21) Solid_powZ = n; 
          if (WIN3D_UI_CurrentTask == 22) {
            Solid_powX = n;
            Solid_powY = n;
            Solid_powZ = n;
          } 

          Solid_updatePowers(f, Solid_powX, Solid_powY, Solid_powZ);          

          Solids_updated = 1;
        }
      }
    } 

    if (Solids_updated != 0) SOLARCHVISION_calculate_SolidImpact_selectedSections();
  }    


  if (Current_ObjectCategory == ObjectCategory_Faces) {

    for (int o = selectedFace_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFace_numbers[o];

      if (OBJ_NUM != 0) {      

        int f = OBJ_NUM;

        if (WIN3D_UI_CurrentTask == 4) {
          int n = allFaces_MTLV[f][0];
          n += p;
          if (n > 8) n = 0;
          if (n < 0) n = 8;
          allFaces_MTLV[f][0] = n;
        }

        if (WIN3D_UI_CurrentTask == 5) {
          int n = allFaces_MTLV[f][1];
          n += p;
          if (n > 4) n = 0;
          if (n < 0) n = 4;
          allFaces_MTLV[f][1] = n;
        }   

        if (WIN3D_UI_CurrentTask == 6) {
          int n = allFaces_MTLV[f][2];
          n += p;
          if (n > 16) n = 0;
          if (n < 0) n = 16;
          allFaces_MTLV[f][2] = n;
        }  

        if (WIN3D_UI_CurrentTask == 7) {
          int n = allFaces_MTLV[f][3];
          n += p;
          if (n > 2) n = 0;
          if (n < 0) n = 2;
          allFaces_MTLV[f][3] = n;
        }
      }
    }
  }  

  if (Current_ObjectCategory == ObjectCategory_Group3Ds) {

    for (int o = selectedGroup3D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedGroup3D_numbers[o];

      if (OBJ_NUM != 0) {      

        for (int f = allGroup3Ds_Faces[OBJ_NUM][0]; f <= allGroup3Ds_Faces[OBJ_NUM][1]; f++) {
          if ((0 < f) && (f < allFaces_PNT.length)) {

            if (WIN3D_UI_CurrentTask == 4) {
              int n = allFaces_MTLV[f][0];
              n += p;
              if (n > 8) n = 0;
              if (n < 0) n = 8;
              allFaces_MTLV[f][0] = n;
            }

            if (WIN3D_UI_CurrentTask == 5) {
              int n = allFaces_MTLV[f][1];
              n += p;
              if (n > 4) n = 0;
              if (n < 0) n = 4;
              allFaces_MTLV[f][1] = n;
            }      

            if (WIN3D_UI_CurrentTask == 6) {
              int n = allFaces_MTLV[f][2];
              n += p;
              if (n > 16) n = 0;
              if (n < 0) n = 16;
              allFaces_MTLV[f][2] = n;
            }  

            if (WIN3D_UI_CurrentTask == 7) {
              int n = allFaces_MTLV[f][3];
              n += p;
              if (n > 2) n = 0;
              if (n < 0) n = 2;
              allFaces_MTLV[f][3] = n;
            }
          }
        }
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Object2Ds) {
    for (int o = selectedObject2D_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedObject2D_numbers[o];

      if (OBJ_NUM != 0) {      

        if (WIN3D_UI_CurrentTask == 4) {

          int n = allObject2Ds_MAP[OBJ_NUM];
          int sign_n = 1;
          if (n < 0) sign_n = -1;

          n = abs(n);

          int n1 = Object2D_PEOPLE_Files_Num;
          int n2 = Object2D_PEOPLE_Files_Num + Object2D_TREES_Files_Num;


          if (n <= n1) { // case: people 

            n += p;

            if (n > n1) {
              n = 1; 
              sign_n *= -1;
            }
            if (n < 1) {
              n = n1; 
              sign_n *= -1;
            }
          } else { // case: trees

            n += p;

            if (n > n2) {
              n = n1 + 1; 
              sign_n *= -1;
            }
            if (n < n1 + 1) {
              n = n2; 
              sign_n *= -1;
            }
          }

          n *= sign_n;

          allObject2Ds_MAP[OBJ_NUM] = n;
        }
      }
    }
  }

  if (Current_ObjectCategory == ObjectCategory_Fractals) {

    for (int o = selectedFractal_numbers.length - 1; o >= 0; o--) {

      int OBJ_NUM = selectedFractal_numbers[o];

      if (OBJ_NUM != 0) {      

        if (WIN3D_UI_CurrentTask == 4) {

          allFractals_Seed[OBJ_NUM] += p;
        } 
        if (WIN3D_UI_CurrentTask == 8) {
          int q = allFractals_DegreeMax[OBJ_NUM];

          q += p;

          if (q < 0) q = 0;

          allFractals_DegreeMax[OBJ_NUM] = q;

          CreateFractal_DegreeMax = q;
          ROLLOUT_Update = 1;
        }
        if (WIN3D_UI_CurrentTask == 9) {
          int q1 = allFractals_DegreeMin[OBJ_NUM];
          int q2 = allFractals_DegreeMax[OBJ_NUM];
          q1 += p;
          q2 += p;

          int change_them = 1; 

          if (q1 < 0) {
            q1 = 0; 
            change_them = 0;
          } 
          if (q2 < 0) {
            q2 = 0; 
            change_them = 0;
          }

          if (change_them == 1) {

            allFractals_DegreeMin[OBJ_NUM] = q1;
            allFractals_DegreeMax[OBJ_NUM] = q2;

            CreateFractal_DegreeMin = q1;
            CreateFractal_DegreeMax = q2;

            ROLLOUT_Update = 1;
          }
        }
        if (WIN3D_UI_CurrentTask == 10) {
          int q = allFractals_DegreeMin[OBJ_NUM];

          q += p;

          if (q < 0) q = 0;

          allFractals_DegreeMin[OBJ_NUM] = q;

          CreateFractal_DegreeMin = q;
          ROLLOUT_Update = 1;
        }        
        if (WIN3D_UI_CurrentTask == 11) {
          float q = allFractals_TrunkSize[OBJ_NUM];

          q += 0.25 * p;

          if (q < 0) q = 0;

          allFractals_TrunkSize[OBJ_NUM] = q;

          CreateFractal_TrunkSize = q;
          ROLLOUT_Update = 1;
        }
        if (WIN3D_UI_CurrentTask == 12) {
          float q = allFractals_LeafSize[OBJ_NUM];

          q += 0.25 * p;

          if (q < 0) q = 0;

          allFractals_LeafSize[OBJ_NUM] = q;

          CreateFractal_LeafSize = q;
          ROLLOUT_Update = 1;
        }
      }
    }
  }
} 




void SOLARCHVISION_UI_dessin_Mouse (int _type, float x, float y, float r) {

  float d = 0.4 * r;

  for (int i = 0; i < 3; i++) { 

    float dx = 0;
    float dy = 0;

    if (i == 0) {
      dx = 0.5 * d;
      dy = 0.5 * d;
      strokeWeight(1);
      stroke(63); 
      fill(63);
    } else if (i == 1) {
      strokeWeight(3);
      stroke(0); 
      fill(0);
    } else {
      strokeWeight(1);
      stroke(1);
      stroke(255); 
      fill(255);
    }          

    pushMatrix();
    translate(x + d + dx, y + d + dy);

    triangle(-d, -d, -d, d, d, -d); 

    if (i == 1) {
      strokeWeight(2 + d);
    } else { 
      strokeWeight(d);
    }

    line(0, 0, d, d);

    popMatrix();
  }

  strokeWeight(0);
}

void SOLARCHVISION_UI_dessin_ClickSelect (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(255);  

  float d = 0.3 * r;
  triangle(-d, -d, -d, d, d, -d); 

  strokeWeight(5);
  line(0, 0, d, d);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_WindowSelect (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(63);  
  rect(-0.5 * r, -0.5 * r, 1.25 * r, 1.25 * r);

  strokeWeight(1);
  stroke(255); 
  fill(255);  

  float d = 0.3 * r;
  triangle(-d, -d, -d, d, d, -d); 

  strokeWeight(5);
  line(0, 0, d, d);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Drop (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  fill(0);

  float d = 0.8 * r;

  if (_type == 1) {
    ellipse(0, 0, 2 * d, d);
  } 
  if ((_type == 2) || (_type == 3)) {
    beginShape();
    vertex(0, 0.5 * d);
    vertex(cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-cos_ang(30) * d, 0);
    endShape(CLOSE);
  } 




  strokeWeight(2);
  stroke(255); 
  fill(0);

  if (_type == 1) {
    line(0, 0, 0, -d);  
    line(0, 0, 0 - 0.25 * d, 0.25 * -d);
    line(0, 0, 0 + 0.25 * d, 0.25 * -d);

    line(0, 0, 0, d);  
    line(0, 0, 0 - 0.25 * d, 0.25 * d);
    line(0, 0, 0 + 0.25 * d, 0.25 * d);
  }

  if (_type == 2) {
    line(0, 0.25 * d, 0, -d);  
    line(0, 0.25 * d, 0 - 0.25 * d, 0);
    line(0, 0.25 * d, 0 + 0.25 * d, 0);
  }

  if (_type == 3) {
    line(0, 0.25 * -d, 0, d);  
    line(0, 0.25 * -d, 0 - 0.25 * d, 0);
    line(0, 0.25 * -d, 0 + 0.25 * d, 0);
  }  

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_GetLength (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();


  float d = 0.8 * r;

  beginShape();
  vertex(0, 0);
  vertex(cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, -d);
  vertex(-cos_ang(30) * d, -sin_ang(30) * d);
  endShape(CLOSE);

  beginShape();
  vertex(cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, 0);
  vertex(0, d);
  vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
  endShape(CLOSE);

  beginShape();
  vertex(-cos_ang(30) * d, -sin_ang(30) * d);
  vertex(0, 0);
  vertex(0, d);
  vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
  endShape(CLOSE);


  strokeWeight(2);
  stroke(0, 127, 255); 
  fill(0);

  if (_type == 1) {
    line(0, 0, cos_ang(30) * d, -sin_ang(30) * d);
  }
  if (_type == 2) {
    line(0, 0, cos_ang(30) * d, -sin_ang(30) * d);
  }    
  if (_type == 3) {
    line(0, 0, -cos_ang(30) * d, -sin_ang(30) * d);
  }      
  if (_type == 4) {
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);  

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }     
  if (_type == 5) {
    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);
  }    
  if (_type == 6) {
    line(0, 0, 0, -d);
  }      


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Move (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(3);
  stroke(255); 
  noFill();  

  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);  
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
  if (_type == 4) line(-0.4 * r, -0.4 * r, 0.4 * r, 0.4 * r);

  noStroke();
  fill(255, 0, 0);
  float d = 5;
  if (_type == 1) {
    ellipse(-0.8 * r, 0, d, d); 
    ellipse(0.8 * r, 0, d, d);
  }
  if (_type == 2) {
    ellipse(0.4 * r, -0.4 * r, d, d); 
    ellipse(-0.4 * r, 0.4 * r, d, d);
  }    
  if (_type == 3) {
    ellipse(0, 0.8 * r, d, d); 
    ellipse(0, -0.8 * r, d, d);
  }
  if (_type == 4) {
    ellipse(-0.4 * r, -0.4 * r, d, d); 
    ellipse(0.4 * r, 0.4 * r, d, d);
  }  

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}

void SOLARCHVISION_UI_dessin_Scale (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(5);
  stroke(0, 255, 0); 
  noFill();  

  if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
  if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
  if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
  if (_type == 4) {
    line(-0.4 * r, 0, 0.4 * r, 0);
    line(0, 0.4 * r, 0, -0.4 * r);
    line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
  }  

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Power (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(3);
  stroke(0, 127, 255); 
  noFill();  

  if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
  if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
  if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
  if (_type == 4) {
    line(-0.4 * r, 0, 0.4 * r, 0);
    line(0, 0.4 * r, 0, -0.4 * r);
    line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
  }  

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Rotate (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(3);
  stroke(255); 
  noFill();  

  if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
  if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);

  strokeWeight(2);
  stroke(0, 127, 255);
  noFill();
  float d = 0.85 * r;
  if (_type == 1) {
    arc(0, 0, d, d, 0.25 * PI, 1.75 * PI);
  }
  if (_type == 2) {
    arc(0, 0, d, d, (0.25 + 0.75) * PI, (1.75 + 0.75) * PI);
  }
  if (_type == 3) {
    arc(0, 0, d, d, (0.25 - 0.5) * PI, (1.75 - 0.5) * PI);
  }


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}





void SOLARCHVISION_UI_dessin_Seed (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(0, 0, 0.8 * r, 0); 
  line(0, 0, 0, -0.8 * r); 
  line(0, 0, -0.4 * r, 0.4 * r); 

  strokeWeight(1);
  stroke(255); 
  noFill();  

  line(-0.8 * r, 0, 0.8 * r, 0);
  line(0, 0.8 * r, 0, -0.8 * r);
  line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);

  strokeWeight(1);
  stroke(255, 255, 0); 
  noFill();  

  for (int i = 0; i < 360; i += 30) {
    float d = random(0.25, 0.75);

    line(0, 0, 0.8 * r * d * cos(i), 0.8 * r * d * sin(i));
  }  

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_Tessellation (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 1.25 * r;

  strokeWeight(2);
  stroke(255); 
  fill(63);  
  rect(-0.5 * d, -0.5 * d, d, d);

  strokeWeight(1);
  stroke(191); 
  fill(191);  

  for (int i = 1; i < 4; i++) {
    float w = (0.25 * i - 0.5) * d;
    line(-0.5 * d, w, 0.5 * d, w);  
    line(w, -0.5 * d, w, 0.5 * d);
  }

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Layer (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(2);
  stroke(255); 
  fill(0, 127, 255);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Visibility (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE); 

  strokeWeight(0);
  stroke(255); 
  fill(127, 127);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  stroke(0, 127, 255);
  strokeWeight(3);
  if (_type == 2) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
  }
  if (_type == 3) {
    line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
    line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
  } 
  if (_type == 4) {
    line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
    line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_FaceNormal (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, 0.5 * d);
  vertex(cos_ang(30) * d, 0);
  vertex(0, -0.5 * d);
  vertex(-cos_ang(30) * d, 0);
  endShape(CLOSE);

  if (_type == 1) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);

    line(0, 0.5 * d, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }

  if (_type == 2) {
    line(0, 0, 0, -d);  
    line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
    line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
  }


  if (_type == 3) {
    line(0, 0, 0, d);  
    line(0 - 0.25 * d, d - 0.25 * d, 0, d);
    line(0 + 0.25 * d, d - 0.25 * d, 0, d);
  }  


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_FaceFirstVertex (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.8 * r;

  strokeWeight(2);
  stroke(255); 
  fill(0);

  beginShape();
  vertex(0, d);
  vertex(cos_ang(30) * d, 0.5 * d);
  vertex(0, 0);
  vertex(-cos_ang(30) * d, 0.5 * d);
  endShape(CLOSE);

  stroke(255, 0, 0);
  ellipse(0, 0, 0.25 * d, 0.25 * d);

  fill(255);
  textSize(d);
  textAlign(CENTER, BOTTOM);
  text("1st", 0, 0);

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_3DViewSpace (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  noFill();

  strokeWeight(1);
  stroke(255); 
  if (_type == 1) fill(63);  
  if (_type == 2) fill(191);
  rect(-0.75 * r, -0.75 * r, 1.5 * r, 1.5 * r);

  if (_type == 1) fill(191);  
  if (_type == 2) fill(63);
  rect(-0.75 * r, -0.75 * r, 0.75 * r, 0.75 * r);

  strokeWeight(2);
  line(0, 0, 0.75 * r, 0.75 * r);

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}

void SOLARCHVISION_UI_dessin_ProjectionType (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255); 
  fill(0);


  float d = 0.8 * r;

  if (_type == 1) {

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  

  if (_type == 2) {

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0.75 * sin_ang(0) * d, 0.75 * -cos_ang(0) * d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(0.75 * sin_ang(120) * d, 0.75 * -cos_ang(120) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(0.75 * sin_ang(240) * d, 0.75 * -cos_ang(240) * d);
    endShape(CLOSE);
  }



  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Truck (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);


  stroke(255); 
  fill(0);

  float d = 0.625 * r;

  float a = 0;
  float b = 0;
  if (_type == 1) {
    a = cos_ang(30) * d; 
    b = -sin_ang(30) * d;
  }
  if (_type == 2) {
    a = -cos_ang(30) * d; 
    b = -sin_ang(30) * d;
  }
  if (_type == 3) {
    a = 0; 
    b = d;
  }

  strokeWeight(1);
  {
    pushMatrix();
    translate(0.5 * a, 0.5 * b);

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    popMatrix();
  }




  strokeWeight(2);
  {
    pushMatrix();
    translate(-0.5 * a, -0.5 * b);

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}




void SOLARCHVISION_UI_dessin_ZOOM (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    pushMatrix();
    translate(0.25 * r, 0.25 * r);

    stroke(255); 

    fill(0);
    strokeWeight(1);
    ellipse(-0.4 * r, -0.4 * r, 0.8 * r, 0.8 * r); 

    noFill();  
    strokeWeight(4);
    line(-0.1 * r, -0.1 * r, 0.3 * r, 0.3 * r);

    strokeWeight(2);
    stroke(255, 255, 0);
    if (_type == 1) {
      line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r); 
      line(-0.4 * r, -0.6 * r, -0.4 * r, -0.2 * r);
    } 
    if (_type == 2) {
      line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);
    }

    popMatrix();
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_3DModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  stroke(255); 
  fill(0);
  strokeWeight(2);
  ellipse(0, 0, r, r);
  noFill();
  strokeWeight(1);
  ellipse(0, 0, 1.5 * r, 1.5 * r); 

  strokeWeight(1);
  line(-0.75 * r, 0, -0.5 * r, 0);
  line(0, -0.75 * r, 0, -0.5 * r);
  line(0.75 * r, 0, 0.5 * r, 0);
  line(0, 0.75 * r, 0, 0.5 * r);


  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}





void SOLARCHVISION_UI_dessin_AllModelSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 0.75 * r;

  stroke(255); 
  fill(0); 
  strokeWeight(1);
  ellipse(0, 0, d, d);
  noFill();
  strokeWeight(1);
  ellipse(0, 0, 2 * d, 2 * d); 

  strokeWeight(1);
  line(-1 * d, 0, -0.5 * d, 0);
  line(0, -1 * d, 0, -0.5 * d);
  line(1 * d, 0, 0.5 * d, 0);
  line(0, 1 * d, 0, 0.5 * d);


  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_SkydomeSize (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    pushMatrix();
    translate(0, 0.125 * r);

    float d = 1.0 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);
    arc(0, 0, d, d, PI, 2 * PI); 
    arc(0, 0, d, 0.333 * d, 0, PI);

    d = 1.5 * r;

    strokeWeight(2);
    stroke(255); 
    noFill();  
    arc(0, 0, d, d, PI, 2 * PI);
    arc(0, 0, d, 0.333 * d, 0, PI);

    popMatrix();
  }

  strokeWeight(2);
  stroke(255, 255, 0);
  line(-0.2 * r, 0, 0.2 * r, 0);
  line(0, -0.2 * r, 0, 0.2 * r); 

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Orbit (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  float d = 1.5 * r;

  strokeWeight(1);
  stroke(255); 
  fill(0); 
  ellipse(0, 0, d, d); 

  strokeWeight(2);
  stroke(255); 
  noFill();  

  if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
  if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
  if (_type == 1) {
    arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    arc(0, 0, d, 0.333 * d, 0, PI);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_LookAtOrigin (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255);
  fill(127, 63, 0); 

  {
    float d = 0.8 * r;

    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_LookAtSelection (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(2);
  stroke(255);
  fill(127, 63, 0); 

  {
    float d = 0.8 * r;

    line(0, 0, cos_ang(90) * d, -sin_ang(90) * d);
    line(0, 0, cos_ang(210) * d, -sin_ang(210) * d);
    line(0, 0, cos_ang(330) * d, -sin_ang(330) * d);
  }

  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }    

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_CameraRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    float d = 1.5 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);
    ellipse(0, 0, d, d);
  }


  strokeWeight(1);
  stroke(255);
  fill(127, 63, 0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  



  {
    float d = 1.5 * r;

    strokeWeight(2);
    stroke(255); 
    noFill();  

    if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      arc(0, 0, d, 0.333 * d, 0, PI);
    }
  }  

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_TargetRoll (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {  

    float d = 1.5 * r;

    strokeWeight(1);
    stroke(255); 
    fill(0);  
    rect(-d/2, -d/2, d, d);   

    strokeWeight(2);
    stroke(255); 
    noFill();  

    if (_type == 3) arc(0, 0, d, 0.333 * d, PI, 2 * PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
      arc(0, 0, d, 0.333 * d, PI, 2 * PI);
    }
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}


void SOLARCHVISION_UI_dessin_Pan (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  {
    float d = 1.0 * r;

    strokeWeight(1);
    stroke(255); 
    noFill();  
    arc(0, 0, d, d, 0, PI); 

    stroke(255); 
    noFill();  

    for (float i = -1.5; i <= 1.5; i++) { 
      line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);

      if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
    }
  }

  strokeWeight(2);
  stroke(255); 
  noFill();  
  {
    float d = 0.75 * r;

    if (_type == 2) {
      line(-1 * d, 0, -0.5 * d, 0);
      line(1 * d, 0, 0.5 * d, 0);
    }
    if (_type == 3) {
      line(0, -1 * d, 0, -0.5 * d);
      line(0, 1 * d, 0, 0.5 * d);
    }
  }

  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_DistMouseXY (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, -0.5 * r, r, -0.5 * r);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, r, 0);
  line(-0.5 * r, -0.5 * r, -r, 0);
  strokeWeight(2);
  line(-0.5 * r, -0.5 * r, 0, r);


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_CameraDistance (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);

  strokeWeight(1);
  stroke(255);
  fill(127, 63, 0); 
  {
    //float d = 0.625 * r;
    float d = 0.5 * r;

    beginShape();
    vertex(0, 0);
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, -d);
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    endShape(CLOSE);

    beginShape();
    vertex(cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);

    beginShape();
    vertex(-cos_ang(30) * d, -sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-cos_ang(30) * d, (1 - sin_ang(30)) * d);
    endShape(CLOSE);
  }  


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}



void SOLARCHVISION_UI_dessin_DistZ (int _type, float x, float y, float r) {

  pushMatrix();
  translate(x, y);

  strokeWeight(1);
  stroke(255); 
  line(-r, 0, r, 0);
  strokeWeight(2);
  line(0, 0, r, 0.5 * r);
  line(0, 0, -r, 0.5 * r);
  strokeWeight(2);
  line(0, 0, 0, r);


  strokeWeight(0);

  popMatrix();

  SOLARCHVISION_UI_BAR_b_Display_Text = 0;
}






int SOLARCHVISION_UI_X_moved = -1;
int SOLARCHVISION_UI_Y_moved = -1;


void mouseMoved () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (SOLARCHVISION_UI_BAR_a_selected_parent != -1) {

        if ((SOLARCHVISION_UI_X_moved != mouseX) || (SOLARCHVISION_UI_Y_moved != mouseY)) {

          SOLARCHVISION_UI_X_moved = mouseX;
          SOLARCHVISION_UI_Y_moved = mouseY;      

          SOLARCHVISION_UI_BAR_a_Update = 1;     

          redraw();
        }
      }
    }
  }
}



PImage pre_screen;

int SOLARCHVISION_UI_BAR_a_Update = 1;

float SOLARCHVISION_UI_BAR_a_width_parent = 4 * SOLARCHVISION_A_Pixel;
float SOLARCHVISION_UI_BAR_a_width_child = 3.5 * SOLARCHVISION_UI_BAR_a_width_parent;

int SOLARCHVISION_UI_BAR_a_selected_parent = -1;
int SOLARCHVISION_UI_BAR_a_selected_child = 0;

String[][] SOLARCHVISION_UI_BAR_a_Items = {
  {
    "SOLARCHVISION-2016", "Designed & developed by", "Mojtaba Samimi", "www.solarchvision.com"
  }
  , 
  {
    "Project", "New", "Save", "Hold", "Fetch", "Open...", "Save As...", "Export 3D-Model > SCR", "Export 3D-Model > RAD", "Export 3D-Model > OBJ", "Import 3D-Model...", "Preferences", "Quit"
  }
  , 
  {
    "Site"
  }
  , // Locations
  {
    "Data", "Typical Year (TMY)", "Long-term (CWEEDS)", "Long-term (CLMREC)", "Real-time Observed (SWOB)", "Weather Forecast (NAEFS)"
  }
  , 
  {
    "View", "Camera >> Viewport", "GoTo Selected Camera", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Shrink 3DViewSpace", "Enlarge 3DViewSpace", "Perspective", "Orthographic", "Zoom", "Zoom as default", "Look at origin", "Look at selection", "Pan", "PanX", "PanY", "Orbit", "OrbitXY", "OrbitZ", "CameraRoll", "CameraRollXY", "CameraRollZ", "TargetRoll", "TargetRollXY", "TargetRollZ", "TruckX", "TruckY", "TruckZ", "DistZ", "DistMouseXY", "CameraDistance", "3DModelSize", "SkydomeSize"
  }
  , 
  {
    "Display", "Display/Hide Land Mesh", "Display/Hide Land Texture", "Display/Hide Land Points", "Display/Hide Land Depth", "Display/Hide Edges", "Display/Hide Normals", "Display/Hide Leaves", "Display/Hide Living Objects", "Display/Hide Building Objects", "Display/Hide Urban", "Display/Hide Solids", "Display/Hide Sections", "Display/Hide Cameras", "Display/Hide Sky", "Display/Hide Sun Path", "Display/Hide Sun Pattern", "Display/Hide Star", "Display/Hide Moon", "Display/Hide Troposphere", "Display/Hide Earth", "Display/Hide Solar Section", "Display/Hide Solid Section", "Display/Hide Wind Flow", "Display/Hide Selected Solids", "Display/Hide Selected Sections", "Display/Hide Selected Cameras", "Display/Hide Selected LandPoints", "Display/Hide Selected Faces", "Display/Hide Selected Faces Vertex Count", "Display/Hide Selected Vertices", "Display/Hide Selected REF Pivot", "Display/Hide Selected Group3D Pivot", "Display/Hide Selected Group3D Edges", "Display/Hide Selected Group3D Box", "Display/Hide Selected 2½D Edges", "Display/Hide Selected ∞-D Edges", "Display/Hide SWOB points", "Display/Hide SWOB nearest", "Display/Hide NAEFS points", "Display/Hide NAEFS nearest", "Display/Hide CWEEDS points", "Display/Hide CWEEDS nearest", "Display/Hide CLMREC points", "Display/Hide CLMREC nearest", "Display/Hide TMYEPW points", "Display/Hide TMYEPW nearest"
  }
  , 
  {
    "Shade", "Shade Surface Wire", "Shade Surface Base", "Shade Surface White", "Shade Surface Materials", "Shade Global Solar", "Shade Vertex Solar", "Shade Vertex Solid", "Shade Vertex Elevation", "Render Viewport"
  }
  , 
  {
    "Study", "Wind pattern (active)", "Wind pattern (passive)", "Urban solar potential (active)", "Urban solar potential (passive)", "Orientation potential (active)", "Orientation potential (passive)", "Hourly sun position (active)", "Hourly sun position (passive)", "View from sun & sky (active)", "View from sun & sky (passive)", "Annual cycle sun path (active)", "Annual cycle sun path (passive)", "Pre-bake Selected Sections", "Process Active Impact", "Process Passive Impact", "Process Solid Impact", "Run wind 3D-model"
  }
  , 
  {
    "Layer"
  }
  , // Parameters 
  {
    "Layout", "Layout -2", "Layout -1", "Layout 0", "Layout 1", "Layout 2", "Layout 3", "Layout 4", "Layout 5", "Layout 6", "Layout 7", "Layout 8", "Layout 9", "Layout 10", "Layout 11", "Layout 12", "Layout 13", "Layout 14"
  }
  , 
  {
    "Create", "Begin New Group3D at Origin", "Begin New Group3D at Pivot", "Viewport >> Camera", "Camera", "Section", "Solid", "Fractal", "Tree", "Person", "House", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Tri", "Hyper", "Poly", "Extrude", "Parametric 1", "Parametric 2", "Parametric 3", "Parametric 4", "Parametric 5", "Parametric 6", "Parametric 7", "Get dX", "Get dY", "Get dZ", "Get dXYZ", "Get dXY", "Get Angle"
  }
  , 
  {
    "Select", "Reverse Selection", "Deselect All", "Select All", "Select Solid", "Select Section", "Select Camera", "Select LandPoint", "Select Fractal", "Select Object2D", "Select Group3D", "Select Face", "Select Vertex", "Soft Selection", "Group3D >> Vertex", "Group3D >> Face", "Group3D >> Solid", "Group3D >> Object2D", "Group3D >> Fractal", "Fractal >> Group3D", "Object2D >> Group3D", "Solid >> Group3D", "Face >> Group3D", "Vertex >> Group3D", "Vertex >> Face", "Face >> Vertex", "Click Select", "Click Select+", "Click Select-", "Window Select", "Window Select+", "Window Select-", "Select Near Vertices Selection", "Select All Isolated Vertices"
  }
  , 
  {
    "Edit", "Duplicate Selection (Identical)", "Duplicate Selection (Variation)", "Attach to Last Group", "Dettach from Groups", "Group Selection", "Ungroup Selection", "Delete All Empty Groups", "Delete Selection", "Delete All Isolated Vertices", "Delete Isolated Vertices Selection", "Separate Vertices Selection", "Reposition Vertices Selection", "Weld Objects Vertices Selection", "Weld Scene Vertices Selection", "Offset(above) Vertices", "Offset(below) Vertices", "Offset(expand) Vertices", "Offset(shrink) Vertices", "Extrude Face Edges", "Tessellation Triangular", "Tessellate Rectangular", "Tessellate Rows & Columns", "Insert Corner Opennings", "Insert Parallel Opennings", "Insert Rotated Opennings", "Insert Edge Opennings", "Reverse Visibility of All Faces", "Hide All Faces", "Hide Selected Faces", "Unhide Selected Faces", "Unhide All Faces", "Isolate Selected Faces", "Flatten Selected LandPoints"
  }
  , 
  {
    "Modify", "Move", "MoveX", "MoveY", "MoveZ", "Rotate", "RotateX", "RotateY", "RotateZ", "Scale", "ScaleX", "ScaleY", "ScaleZ", "Power", "PowerX", "PowerY", "PowerZ", "Flip FaceNormal", "Set-Out FaceNormal", "Set-In FaceNormal", "Get FaceFirstVertex", "Change Seed/Material", "Change Tessellation", "Change Layer", "Change Visibility", "Change DegreeMax", "Change DegreeDif", "Change DegreeMin", "Change TrunkSize", "Change LeafSize"
  }
  , 
  {
    "Match", "Save Current ReferenceBox", "Reset Saved ReferenceBox", "Use Selection ReferenceBox", "Use Origin ReferenceBox", "PivotX:Minimum", "PivotX:Center", "PivotX:Maximum", "PivotY:Minimum", "PivotY:Center", "PivotY:Maximum", "PivotZ:Minimum", "PivotZ:Center", "PivotZ:Maximum", "Pick Seed/Material", "Pick Tessellation", "Pick Layer", "Pick Visibility", "Pick DegreeMax", "Pick DegreeDif", "Pick DegreeMin", "Pick TrunkSize", "Pick LeafSize", "Pick AllFractalProps", "Assign Seed/Material", "Assign Tessellation", "Assign Layer", "Assign Visibility", "Assign DegreeMax", "Assign DegreeDif", "Assign DegreeMin", "Assign TrunkSize", "Assign LeafSize", "Assign AllFractalProps", "Assign Pivot", "Drop on LandSurface", "Drop on ModelSurface (Up)", "Drop on ModelSurface (Down)"
  }
  , 
  {
    "Action", "Undo", "Redo", "JPG Time Graph", "PDF Time Graph", "JPG Location Graph", "PDF Location Graph", "JPG 3D Graph", "Screenshot", "Screenshot+Click", "Screenshot+Drag", "REC. Time Graph", "REC. Location Graph", "REC. Solid Graph", "REC. Screenshot", "Stop REC."
  }
};






int N_Site_in_Bar_a = 2; 
{

  SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a] = new String [1 + Defined_Stations.length];

  SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][0] = "Site";

  for (int i = 0; i < Defined_Stations.length; i++) {

    SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][i + 1] = Defined_Stations[i][0];
  }
} 

int N_Layer_in_Bar_a = 8; 
{

  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a] = new String [num_Layers + 12];

  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][0] = "Layer";

  for (int i = 1; i < num_Layers; i++) {

    SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][i] = LAYERS_Title[i - 1][Language_EN];
  }

  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 0] = "12h accumulated Precipitation";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 1] = "Hourly precipitation";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 2] = "Wind power";  
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 3] = "Accumulated degree day <18°C<";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 4] = "Accumulated radiation on tracker";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 5] = "Accumulated radiation on surface";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 6] = "Radiation on surface inclination";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 7] = "Radiation on solar tracker";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 8] = "Radiation on surface material";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 9] = "Normal trend of parameter";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 10] = "Passive trend of parameter";
  SOLARCHVISION_UI_BAR_a_Items[N_Layer_in_Bar_a][num_Layers + 11] = "Active trend of parameter";
}


void SOLARCHVISION_draw_window_BAR_a () {

  if (SOLARCHVISION_UI_BAR_a_Update == 1) {

    //println("Update BAR!");

    SOLARCHVISION_UI_BAR_a_Update = 0;

    fill(127);
    noStroke();

    rect(0, 0, width, SOLARCHVISION_A_Pixel);

    STUDY_X_control = 0; //0.25 * MessageSize;
    STUDY_Y_control = 0.5 * SOLARCHVISION_A_Pixel;

    for (int i = 0; i < SOLARCHVISION_UI_BAR_a_Items.length; i++) {

      float cx = STUDY_X_control + i * SOLARCHVISION_UI_BAR_a_width_parent;
      float cy = STUDY_Y_control;
      float cr = 0.5 * SOLARCHVISION_A_Pixel; 

      if (i > 0) cx += 1.5 * SOLARCHVISION_UI_BAR_a_width_parent; // to include SOLARCHVISION title     

      if (isInside(mouseX, mouseY, cx, cy - cr, cx + SOLARCHVISION_UI_BAR_a_width_parent, cy + cr) == 1) {

        if (SOLARCHVISION_UI_BAR_a_selected_parent == -1) {

          pre_screen = get(0, SOLARCHVISION_A_Pixel, width, height - SOLARCHVISION_A_Pixel);

          //println("Screen GET!");
        }     

        SOLARCHVISION_UI_BAR_a_selected_parent = i;

        SOLARCHVISION_UI_BAR_a_selected_child = 0;
      }     


      textAlign(LEFT, CENTER);   

      if (SOLARCHVISION_UI_BAR_a_selected_parent == i) {

        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);
      } else {
        stroke(255); 
        fill(255);
        textSize(1.25 * MessageSize);
      }

      text(SOLARCHVISION_UI_BAR_a_Items[i][0], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize);



      if (SOLARCHVISION_UI_BAR_a_selected_parent == i) {

        image(pre_screen, 0, SOLARCHVISION_A_Pixel);

        SOLARCHVISION_UI_BAR_a_selected_child = 0; 

        for (int j = 1; j < SOLARCHVISION_UI_BAR_a_Items[SOLARCHVISION_UI_BAR_a_selected_parent].length; j++) {

          if (isInside(SOLARCHVISION_UI_X_moved, SOLARCHVISION_UI_Y_moved, cx, cy - cr + j * SOLARCHVISION_A_Pixel, cx + SOLARCHVISION_UI_BAR_a_width_child, cy + cr + j * SOLARCHVISION_A_Pixel) == 1) {

            SOLARCHVISION_UI_BAR_a_selected_child = j;

            fill(255, 127, 0);
            noStroke();
            rect(cx, cy - cr + j * SOLARCHVISION_A_Pixel, SOLARCHVISION_UI_BAR_a_width_child, SOLARCHVISION_A_Pixel);
          } else {

            fill(0, 223);
            noStroke();
            rect(cx, cy - cr + j * SOLARCHVISION_A_Pixel, SOLARCHVISION_UI_BAR_a_width_child, SOLARCHVISION_A_Pixel);
          }

          textAlign(LEFT, CENTER);

          if (SOLARCHVISION_UI_BAR_a_selected_child == j) {

            stroke(0); 
            fill(0);
            textSize(1.25 * MessageSize);
          } else {
            stroke(255); 
            fill(255);

            if (SOLARCHVISION_UI_BAR_a_Items[i][0].equals("Display")) {
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Land Mesh")) {
                if (Display_LAND_MESH == 0) {
                  stroke(127); 
                  fill(127);
                }
              }       
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Land Texture")) {
                if (Display_LAND_Texture == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Land Points")) {
                if (Display_LAND_POINTS == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Land Depth")) {
                if (Display_LAND_DEPTH == 0) {
                  stroke(127); 
                  fill(127);
                }
              }          
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Edges")) {
                if (MODEL3D_DisplayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              } 
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Normals")) {
                if (MODEL3D_DisplayNormals == 0) {
                  stroke(127); 
                  fill(127);
                }
              }               
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Leaves")) {
                if (Display_Leaves == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Living Objects")) {
                if (Display_Model2Ds == 0) {
                  stroke(127); 
                  fill(127);
                }
                //if (Display_Fractals == 0) {stroke(127); fill(127);}
                //if (Display_Leaves == 0) {stroke(127); fill(127);}
              } 
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Building Objects")) {
                if (Display_Model3Ds == 0) {
                  stroke(127); 
                  fill(127);
                }
              }           
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Urban")) {
                if (Display_URBAN_MESH == 0) {
                  stroke(127); 
                  fill(127);
                }
              } 
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Solids")) {
                if (Display_Solids == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                  
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Sections")) {
                if (Display_Sections == 0) {
                  stroke(127); 
                  fill(127);
                }
              }          
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Cameras")) {
                if (Display_Cameras == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Sky")) {
                if (Display_SKY3D == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Sun Path")) {
                if (Display_SUN3D_Path == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Sun Pattern")) {
                if (Display_SUN3D_Pattern == 0) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Star")) {
                if (Display_STAR3D_Surface == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Moon")) {
                if (Display_MOON3D_Surface == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Earth")) {
                if (Display_EARTH3D_Surface == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Troposphere")) {
                if (Display_TROPO3D_Surface == 0) {
                  stroke(127); 
                  fill(127);
                }
              }  
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Solar Section")) {
                if (Display_SolarImpactImage == 0) {
                  stroke(127); 
                  fill(127);
                }
              }  
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Solid Section")) {
                if (Display_SolidImpactImage == 0) {
                  stroke(127); 
                  fill(127);
                }
              } 
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Wind Flow")) {
                if (Display_WindFlow == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Solids")) {
                if (selectedSolid_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                        
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Sections")) {
                if (selectedSection_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }          
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Cameras")) {
                if (selectedCamera_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }        
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected LandPoints")) {
                if (selectedLandPoint_displayPoints == 0) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Faces")) {
                if (selectedFace_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }      
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Faces Vertex Count")) {
                if (selectedFace_displayVertexCount == 0) {
                  stroke(127); 
                  fill(127);
                }
              }   
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Vertices")) {
                if (selectedVertex_displayVertices == 0) {
                  stroke(127); 
                  fill(127);
                }
              }               
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected REF Pivot")) {
                if (selected_displayReferencePivot == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                 
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group3D Pivot")) {
                if (selected_displayReferencePivot == 0) {
                  stroke(127); 
                  fill(127);
                }
              }                    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group3D Edges")) {
                if (selectedGroup3D_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected Group3D Box")) {
                if (selectedGroup3D_displayBox == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected 2½D Edges")) {
                if (selectedObject2D_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }    
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide Selected ∞-D Edges")) {
                if (selectedFractal_displayEdges == 0) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide SWOB points")) {
                if (Display_SWOB_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide SWOB nearest")) {
                if (Display_SWOB_Nearest == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide NAEFS points")) {
                if (Display_NAEFS_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide NAEFS nearest")) {
                if (Display_NAEFS_Nearest == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide CWEEDS points")) {
                if (Display_CWEEDS_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide CWEEDS nearest")) {
                if (Display_CWEEDS_Nearest == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide CLMREC points")) {
                if (Display_CLMREC_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide CLMREC nearest")) {
                if (Display_CLMREC_Nearest == 0) {
                  stroke(127); 
                  fill(127);
                }
              }              
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide TMYEPW points")) {
                if (Display_TMYEPW_Points == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
              if (SOLARCHVISION_UI_BAR_a_Items[i][j].equals("Display/Hide TMYEPW nearest")) {
                if (Display_TMYEPW_Nearest == 0) {
                  stroke(127); 
                  fill(127);
                }
              }
            }

            textSize(1.25 * MessageSize);
          }

          text(SOLARCHVISION_UI_BAR_a_Items[i][j], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize + j * SOLARCHVISION_A_Pixel);
        }
      }
    }

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
}


void SOLARCHVISION_modify_Viewport_Title () {

  String s = "Cam" + nf(WIN3D_CurrentCamera, 2);

  SOLARCHVISION_UI_BAR_b_Items[0][11] = s; // <<<<< Note: 3DViewPoint is the first index on BAR_b 
  SOLARCHVISION_highlight_in_BAR_b(s);

  SOLARCHVISION_UI_BAR_b_Update = 1;
}  



int SOLARCHVISION_UI_BAR_b_Update = 1;

float SOLARCHVISION_UI_BAR_b_tab = SOLARCHVISION_B_Pixel;

String[][] SOLARCHVISION_UI_BAR_b_Items = {
  {
    "11", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Cam00", "3DViewPoint", "2.0"
  }
  , 
  {
    "2", "AllViewsports", "Expand3DView", "3DViewSpace", "1"
  }
  , 

  {
    "2", "P<>", "P><", "ProjectionType", "1.0"
  }
  , 
  {
    "1", "LAO", "LookAtOrigin", "1.0"
  }
  , 
  {
    "1", "LAS", "LookAtSelection", "1.0"
  }
  , 
  {
    "3", "CRL", "CRLz", "CRLxy", "CameraRoll", "1.0"
  }
  , 
  {
    "1", "±CDS", "CameraDistance", "1.0"
  }
  , 
  {
    "1", "±CDM", "DistMouseXY", "1.0"
  }
  , 
  {
    "1", "±CDZ", "DistZ", "1.0"
  }
  , 
  {
    "3", "DIz", "DIx", "DIy", "Truck", "1.0"
  }
  , 
  {
    "1", "OR", "ORxy", "ORz", "Orbit", "1.0"
  }
  , 
  {
    "1", "TRL", "TRLz", "TRLxy", "TargetRoll", "1.0"
  }
  , 
  {
    "1", "Pan", "PanX", "PanY", "Pan", "1.0"
  }
  , 
  {
    "1", "±ZM", "0ZM", "Zoom", "1.0"
  }
  , 
  {
    "1", "±SA", "AllModelSize", "1.0"
  }
  , 
  {
    "1", "±SZ", "3DModelSize", "1.0"
  }
  , 
  {
    "1", "±SK", "SkydomeSize", "1.0"
  }
  , 

  {
    "2", "Fractal", "Tree", "Person", "LivingType", "1.5"
  }
  , 
  {
    "1", "House", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Tri", "Hyper", "Poly", "Extrude", "Parametric", "BuildingType", "2.5"
  }
  , 
  {
    "1", "as_Mesh", "as_Solid", "Mesh|Solid", "2.0"
  }
  , 

  {
    "4", "LandP", "Fractal", "2½D", "Group", "Face", "Vertex", "Soft", "Solid", "Section", "Camera", "LayerType", "2.0"
  }
  , 
  {
    "1", "±CS", "+CS", "-CS", "ClickSelect", "1.0"
  }
  , 
  {
    "1", "±WS", "+WS", "-WS", "WindowSelect", "1.0"
  }
  , 
  {
    "2", "X<", "X|", "X>", "PivotX", "1.0"
  }
  , 
  {
    "2", "Y<", "Y|", "Y>", "PivotY", "1.0"
  }
  , 
  {
    "2", "Z<", "Z|", "Z>", "PivotZ", "1.0"
  }
  , 
  //{"1", "DrL±", "DrM+", "DrM-", "Drop", "1.0"},
  {
    "4", "GLx", "GLy", "GLz", "GL³", "GL²", "GLa", "GetLength", "1.0"
  }
  , 
  {
    "3", "MVx", "MVy", "MVz", "MV³", "Move", "1.0"
  }
  , 
  {
    "3", "SCx", "SCy", "SCz", "SC³", "Scale", "1.0"
  }
  , 
  {
    "3", "RTx", "RTy", "RTz", "Rotate", "1.0"
  }
  , 
  //{"3", "PWx", "PWy", "PWz", "PW³", "Power", "1.0"},
  {
    "1", "Mat0", "Mat1", "Mat2", "Mat3", "Change Seed/Material", "1.0"
  }
  , 
  {
    "1", "Tes0", "Tes1", "Tes2", "Tes3", "Change Tessellation", "1.0"
  }
  , 
  {
    "1", "Lyr0", "Lyr1", "Lyr2", "Lyr3", "Change Layer", "1.0"
  }
  , 
  {
    "1", "Vsb0", "Vsb1", "Vsb2", "Vsb3", "Change Visibility", "1.0"
  }
  , 
  {
    "1", "FNorm1", "FNorm2", "FNorm3", "FaceNormal", "1.0"
  }
  , 
  {
    "1", "F1stV", "FaceFirstVertex", "1.0"
  }
  , 

  //{"1", "<pvt>", ">pvt<", "|pvt|", ".pvt.", "Get/Set Pivot", "1.0"},

  //{"1", "SPvt0", "SPvt1", "SPvt2", "Pivot", "1.0"},

  //{"1", "dgMax0", "dgMax1", "dgMax2", "Change DegreeMax", "1.0"},
  //{"1", "dgDif0", "dgDif1", "dgDif2", "Change DegreeDif", "1.0"},
  //{"1", "dgMin0", "dgMin1", "dgMin2", "Change DegreeMin", "1.0"},
  //{"1", "tsSz0", "trSz1", "trSz2", "Change TrunkSize", "1.0"},
  //{"1", "lfSz0", "lfSz1", "lfSz2", "Change LeafSize", "1.0"},
  //{"1", "allFP0", "allFP1", "allFP2", "AllFractalProps", "1.0"},

  //{"1", "SEC", "Section", "1.0"},
  //{"1", "SLD", "Solid", "1.0"},
  //{"1", "CAM", "Pick Study Camera", "1.0"},
};         



int SOLARCHVISION_UI_Bar_b_Selection = -1;                        


int SOLARCHVISION_UI_BAR_b_Display_Text; 


void SOLARCHVISION_highlight_in_BAR_b (String s) {

  int break_loops = 0;

  for (int i = 0; i < SOLARCHVISION_UI_BAR_b_Items.length; i++) {
    for (int j = 1; j < SOLARCHVISION_UI_BAR_b_Items[i].length - 2; j++) {
      if (SOLARCHVISION_UI_BAR_b_Items[i][j].equals(s)) {

        SOLARCHVISION_UI_BAR_b_Items[i][0] = nf(j, 0);

        break_loops = 1;
      }

      if (break_loops == 1) break;
    }
    if (break_loops == 1) break;
  }
}


void SOLARCHVISION_draw_window_BAR_b () {

  if (SOLARCHVISION_UI_BAR_b_Update == 1) {

    SOLARCHVISION_UI_BAR_b_Update = 0;

    fill(0);
    noStroke();
    rect(0, SOLARCHVISION_A_Pixel, width, SOLARCHVISION_B_Pixel);

    STUDY_X_control = 0; //0.25 * MessageSize;
    STUDY_Y_control = SOLARCHVISION_A_Pixel + 0.5 * SOLARCHVISION_B_Pixel;

    float cx = STUDY_X_control;
    float cy = STUDY_Y_control;
    float cr = 0.5 * SOLARCHVISION_B_Pixel;   

    for (int i = 0; i < SOLARCHVISION_UI_BAR_b_Items.length; i++) {

      {
        String Bar_Switch = SOLARCHVISION_UI_BAR_b_Items[i][SOLARCHVISION_UI_BAR_b_Items[i].length - 2];

        if (Bar_Switch.equals("LayerType")) {
          SOLARCHVISION_UI_BAR_b_Items[i][0] = nf(Current_ObjectCategory + 1, 0);
        }
      }



      int j = int(SOLARCHVISION_UI_BAR_b_Items[i][0]);

      float Item_width = SOLARCHVISION_UI_BAR_b_tab * float(SOLARCHVISION_UI_BAR_b_Items[i][SOLARCHVISION_UI_BAR_b_Items[i].length - 1]);

      noFill();
      stroke(255);
      strokeWeight(1);
      rect(cx, cy - cr, Item_width, SOLARCHVISION_B_Pixel);
      strokeWeight(0);




      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + Item_width, cy + cr) == 1) {

        if (mouseButton == RIGHT) {       

          if (SOLARCHVISION_UI_Bar_b_Selection != i) {
            SOLARCHVISION_UI_Bar_b_Selection = i;
          } else {

            int n = int(SOLARCHVISION_UI_BAR_b_Items[i][0]);

            n -= 1;

            if (n <= 0) n = SOLARCHVISION_UI_BAR_b_Items[i].length - 3;

            SOLARCHVISION_UI_BAR_b_Items[i][0] = nf(n, 0);

            j = n;
          }
        }

        if (mouseButton == LEFT) {

          if (SOLARCHVISION_UI_Bar_b_Selection != i) {
            SOLARCHVISION_UI_Bar_b_Selection = i;
          } else {

            int n = int(SOLARCHVISION_UI_BAR_b_Items[i][0]);

            n += 1;

            if (n >= SOLARCHVISION_UI_BAR_b_Items[i].length - 2) n = 1;

            SOLARCHVISION_UI_BAR_b_Items[i][0] = nf(n, 0);

            j = n;
          }
        }               


        fill(255, 127, 0);
        noStroke();
        rect(cx, cy - cr, Item_width, SOLARCHVISION_B_Pixel);     

        String Bar_Switch = SOLARCHVISION_UI_BAR_b_Items[i][SOLARCHVISION_UI_BAR_b_Items[i].length - 2];


        if (Bar_Switch.equals("LayerType")) {
          Current_ObjectCategory = j - 1;

          if (Current_ObjectCategory == ObjectCategory_SoftVerts) {
            SOLARCHVISION_convert_Vertex_to_softSelection();
          }

          ROLLOUT_Update = 1;   
          WIN3D_Update = 1;
        }

        if (Bar_Switch.equals("Mesh|Solid")) {
          CreateInput_MeshOrSolid = j - 1;

          ROLLOUT_Update = 1;
        }        

        if ((Bar_Switch.equals("LivingType")) || (Bar_Switch.equals("BuildingType"))) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Fractal")) SOLARCHVISION_UI_set_to_Create_Fractal();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tree")) SOLARCHVISION_UI_set_to_Create_Tree();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Person")) SOLARCHVISION_UI_set_to_Create_Person();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tri")) SOLARCHVISION_UI_set_to_Create_Tri();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Poly")) SOLARCHVISION_UI_set_to_Create_Poly();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Extrude")) SOLARCHVISION_UI_set_to_Create_Extrude();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Hyper")) SOLARCHVISION_UI_set_to_Create_Hyper();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("House")) SOLARCHVISION_UI_set_to_Create_House();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Box")) SOLARCHVISION_UI_set_to_Create_Box();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Octahedron")) SOLARCHVISION_UI_set_to_Create_Octahedron();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Sphere")) SOLARCHVISION_UI_set_to_Create_Sphere();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Cylinder")) SOLARCHVISION_UI_set_to_Create_Cylinder();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Cushion")) SOLARCHVISION_UI_set_to_Create_Cushion();
          else if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Parametric")) SOLARCHVISION_UI_set_to_Create_Parametric(CreateParametric_Type);
        }

        if (Bar_Switch.equals("Change Seed/Material")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Mat0")) SOLARCHVISION_UI_set_to_Modify_Seed(0);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Mat1")) SOLARCHVISION_UI_set_to_Modify_Seed(1);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Mat2")) SOLARCHVISION_UI_set_to_Modify_Seed(2);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Mat3")) SOLARCHVISION_UI_set_to_Modify_Seed(3);
        }

        if (Bar_Switch.equals("Change Tessellation")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tes0")) SOLARCHVISION_UI_set_to_Modify_Tessellation(0);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tes1")) SOLARCHVISION_UI_set_to_Modify_Tessellation(1);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tes2")) SOLARCHVISION_UI_set_to_Modify_Tessellation(2);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Tes3")) SOLARCHVISION_UI_set_to_Modify_Tessellation(3);
        }

        if (Bar_Switch.equals("Change Layer")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Lyr0")) SOLARCHVISION_UI_set_to_Modify_Layer(0);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Lyr1")) SOLARCHVISION_UI_set_to_Modify_Layer(1);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Lyr2")) SOLARCHVISION_UI_set_to_Modify_Layer(2);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Lyr3")) SOLARCHVISION_UI_set_to_Modify_Layer(3);
        }

        if (Bar_Switch.equals("Change Visibility")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Vsb0")) SOLARCHVISION_UI_set_to_Modify_Visibility(0);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Vsb1")) SOLARCHVISION_UI_set_to_Modify_Visibility(1);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Vsb2")) SOLARCHVISION_UI_set_to_Modify_Visibility(2);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("Vsb3")) SOLARCHVISION_UI_set_to_Modify_Visibility(3);
        }        

        if (Bar_Switch.equals("FaceNormal")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("FNorm1")) SOLARCHVISION_UI_set_to_Modify_FaceNormal(1);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("FNorm2")) SOLARCHVISION_UI_set_to_Modify_FaceNormal(2);
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("FNorm3")) SOLARCHVISION_UI_set_to_Modify_FaceNormal(3);
        }

        if (Bar_Switch.equals("FaceFirstVertex")) {
          if ((SOLARCHVISION_UI_BAR_b_Items[i][j]).equals("F1stV")) SOLARCHVISION_UI_set_to_Modify_FaceFirstVertex(1);
        }        

        if (Bar_Switch.equals("Rotate")) SOLARCHVISION_UI_set_to_Modify_Rotate(j - 1);
        if (Bar_Switch.equals("Power")) SOLARCHVISION_UI_set_to_Modify_Power(j - 1);        
        if (Bar_Switch.equals("Scale")) SOLARCHVISION_UI_set_to_Modify_Scale(j - 1);
        if (Bar_Switch.equals("Move")) SOLARCHVISION_UI_set_to_Modify_Move(j - 1);
        if (Bar_Switch.equals("GetLength")) SOLARCHVISION_UI_set_to_Modify_GetLength(j - 1);
        if (Bar_Switch.equals("Drop")) SOLARCHVISION_UI_set_to_Modify_Drop(j - 1);

        if (Bar_Switch.equals("ProjectionType")) SOLARCHVISION_UI_set_to_View_ProjectionType(j - 1);

        if (Bar_Switch.equals("ClickSelect")) SOLARCHVISION_UI_set_to_View_ClickSelect(j - 1);
        if (Bar_Switch.equals("WindowSelect")) SOLARCHVISION_UI_set_to_View_WindowSelect(j - 1);

        if (Bar_Switch.equals("PivotX")) SOLARCHVISION_UI_set_to_View_PivotX(j - 2);
        if (Bar_Switch.equals("PivotY")) SOLARCHVISION_UI_set_to_View_PivotY(j - 2);
        if (Bar_Switch.equals("PivotZ")) SOLARCHVISION_UI_set_to_View_PivotZ(j - 2);

        if (Bar_Switch.equals("Orbit")) SOLARCHVISION_UI_set_to_View_Orbit(j - 1);
        if (Bar_Switch.equals("CameraRoll")) SOLARCHVISION_UI_set_to_View_CameraRoll(j - 1);
        if (Bar_Switch.equals("TargetRoll")) SOLARCHVISION_UI_set_to_View_TargetRoll(j - 1);

        if (Bar_Switch.equals("LookAtOrigin")) SOLARCHVISION_UI_set_to_View_LookAtOrigin(j - 1);
        if (Bar_Switch.equals("LookAtSelection")) SOLARCHVISION_UI_set_to_View_LookAtSelection(j - 1);

        if (Bar_Switch.equals("Pan")) {

          SOLARCHVISION_UI_set_to_View_Pan(j - 1);
        }  

        if (Bar_Switch.equals("Zoom")) {
          SOLARCHVISION_UI_set_to_View_ZOOM(j - 1);

          SOLARCHVISION_UI_BAR_b_Items[i][0] = "1"; // << set it to default choice next time
        }     

        if (Bar_Switch.equals("CameraDistance")) SOLARCHVISION_UI_set_to_View_CameraDistance(0);

        if (Bar_Switch.equals("DistMouseXY")) SOLARCHVISION_UI_set_to_View_DistMouseXY(0);

        if (Bar_Switch.equals("DistZ")) SOLARCHVISION_UI_set_to_View_Truck(0);
        if (Bar_Switch.equals("Truck")) SOLARCHVISION_UI_set_to_View_Truck(j - 1);

        if (Bar_Switch.equals("3DModelSize")) SOLARCHVISION_UI_set_to_View_3DModelSize();

        if (Bar_Switch.equals("SkydomeSize")) SOLARCHVISION_UI_set_to_View_SkydomeSize();

        if (Bar_Switch.equals("AllModelSize")) SOLARCHVISION_UI_set_to_View_AllModelSize();

        if (Bar_Switch.equals("3DViewSpace")) SOLARCHVISION_UI_set_to_View_3DViewSpace(j - 1);

        if (Bar_Switch.equals("3DViewPoint")) SOLARCHVISION_UI_set_to_View_3DViewPoint(j - 1);
      }


      SOLARCHVISION_UI_BAR_b_Display_Text = 1;  

      { // drawing the icons where available

        String Bar_Switch = SOLARCHVISION_UI_BAR_b_Items[i][SOLARCHVISION_UI_BAR_b_Items[i].length - 2];

        if (Bar_Switch.equals("Drop")) {
          SOLARCHVISION_UI_dessin_Drop(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("GetLength")) {
          SOLARCHVISION_UI_dessin_GetLength(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("Move")) {
          SOLARCHVISION_UI_dessin_Move(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Scale")) {
          SOLARCHVISION_UI_dessin_Scale(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }    
        if (Bar_Switch.equals("Power")) {
          SOLARCHVISION_UI_dessin_Power(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }            
        if (Bar_Switch.equals("Rotate")) {
          SOLARCHVISION_UI_dessin_Rotate(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }    
        if (Bar_Switch.equals("Change Seed/Material")) {
          SOLARCHVISION_UI_dessin_Seed(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Tessellation")) {
          SOLARCHVISION_UI_dessin_Tessellation(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Layer")) {
          SOLARCHVISION_UI_dessin_Layer(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("Change Visibility")) {
          SOLARCHVISION_UI_dessin_Visibility(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("FaceNormal")) {
          SOLARCHVISION_UI_dessin_FaceNormal(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }           
        if (Bar_Switch.equals("FaceFirstVertex")) {
          SOLARCHVISION_UI_dessin_FaceFirstVertex(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }            

        if (Bar_Switch.equals("ClickSelect")) {
          SOLARCHVISION_UI_dessin_ClickSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }       
        if (Bar_Switch.equals("WindowSelect")) {
          SOLARCHVISION_UI_dessin_WindowSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }   
        if (Bar_Switch.equals("ProjectionType")) {
          SOLARCHVISION_UI_dessin_ProjectionType(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }          
        if (Bar_Switch.equals("Zoom")) {
          SOLARCHVISION_UI_dessin_ZOOM(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }   
        if (Bar_Switch.equals("Orbit")) {
          SOLARCHVISION_UI_dessin_Orbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }     
        if (Bar_Switch.equals("CameraRoll")) {
          SOLARCHVISION_UI_dessin_CameraRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }             
        if (Bar_Switch.equals("TargetRoll")) {
          SOLARCHVISION_UI_dessin_TargetRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }      
        if (Bar_Switch.equals("CameraDistance")) {
          SOLARCHVISION_UI_dessin_CameraDistance(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }           
        if (Bar_Switch.equals("LookAtOrigin")) {
          SOLARCHVISION_UI_dessin_LookAtOrigin(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("LookAtSelection")) {
          SOLARCHVISION_UI_dessin_LookAtSelection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }                
        if (Bar_Switch.equals("Pan")) {
          SOLARCHVISION_UI_dessin_Pan(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("DistMouseXY")) {
          SOLARCHVISION_UI_dessin_DistMouseXY(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }          
        if (Bar_Switch.equals("DistZ")) {
          SOLARCHVISION_UI_dessin_DistZ(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }        
        if (Bar_Switch.equals("Truck")) {
          SOLARCHVISION_UI_dessin_Truck(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("3DModelSize")) {
          SOLARCHVISION_UI_dessin_3DModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }      
        if (Bar_Switch.equals("SkydomeSize")) {
          SOLARCHVISION_UI_dessin_SkydomeSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
        if (Bar_Switch.equals("AllModelSize")) {
          SOLARCHVISION_UI_dessin_AllModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }  

        if (Bar_Switch.equals("3DViewSpace")) {
          SOLARCHVISION_UI_dessin_3DViewSpace(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_B_Pixel);
        }
      }

      if (SOLARCHVISION_UI_BAR_b_Display_Text == 1) { // writing titles where the icon is not available

        textAlign(CENTER, CENTER);   
        stroke(255); 
        fill(255);
        textSize(0.45 * SOLARCHVISION_B_Pixel);

        text(SOLARCHVISION_UI_BAR_b_Items[i][j], cx + 0.5 * Item_width, cy - 0.2 * MessageSize);
      }


      cx += Item_width;
    }


    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
}   





void SOLARCHVISION_UI_set_to_Create_Nothing () {

  CreateButton_3DPoly = 0;
  CreateButton_3DExtrude = 0;
  CreateButton_3DTri = 0;
  CreateButton_3DQuad = 0;
  CreateButton_3DHouse = 0; 
  CreateButton_3DParametric = 0;
  CreateButton_3DSuperOBJ = 0;
  CreateButton_2DPerson = 0;
  CreateButton_2DPlant = 0;
  CreateButton_Fractal = 0;

  WIN3D_UI_CurrentTask = 0;

  ROLLOUT_Update = 1;
}


void SOLARCHVISION_UI_set_to_Create_Fractal () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_Fractal = 1;
  Current_ObjectCategory = ObjectCategory_Fractals;
}  


void SOLARCHVISION_UI_set_to_Create_Tree () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_2DPlant = 1;
  Current_ObjectCategory = ObjectCategory_Object2Ds;
}

void SOLARCHVISION_UI_set_to_Create_Person () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_2DPerson = 1;
  Current_ObjectCategory = ObjectCategory_Object2Ds;
}

void SOLARCHVISION_UI_set_to_Create_Parametric (int n) {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DParametric = 1;
  CreateParametric_Type = n;

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Tri () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DTri = 1;
  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Poly () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DPoly = 1;
  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Extrude () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DExtrude = 1;
  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Hyper () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DQuad = 1;
  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_House () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DHouse = 1;
  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Box () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DSuperOBJ = 1;

  CreateInput_powX = CubePower;   
  CreateInput_powY = CubePower; 
  CreateInput_powZ = CubePower;             

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Octahedron () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DSuperOBJ = 1;

  CreateInput_powX = 1;  
  CreateInput_powY = 1; 
  CreateInput_powZ = 1;            

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Sphere () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DSuperOBJ = 1;

  CreateInput_powX = 2;  
  CreateInput_powY = 2; 
  CreateInput_powZ = 2;            

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Cylinder () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DSuperOBJ = 1;

  CreateInput_powX = 2;  
  CreateInput_powY = 2; 
  CreateInput_powZ = CubePower;             

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}

void SOLARCHVISION_UI_set_to_Create_Cushion () {
  SOLARCHVISION_UI_set_to_Create_Nothing();

  CreateButton_3DSuperOBJ = 1;

  CreateInput_powX = CubePower;   
  CreateInput_powY = CubePower;  
  CreateInput_powZ = 2;            

  Current_ObjectCategory = ObjectCategory_Group3Ds;
}




void SOLARCHVISION_UI_set_to_Modify_Move (int n) {
  WIN3D_UI_CurrentTask = 1;

  selected_posVector = n;

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Scale (int n) {
  WIN3D_UI_CurrentTask = 2;

  selected_scaleVector = n;

  ROLLOUT_Update = 1;
}


void SOLARCHVISION_UI_set_to_Modify_Rotate (int n) {
  WIN3D_UI_CurrentTask = 3;

  selected_rotVector = n;

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Seed (int n) {
  WIN3D_UI_CurrentTask = 4;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Tessellation (int n) {
  WIN3D_UI_CurrentTask = 5;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Layer (int n) {
  WIN3D_UI_CurrentTask = 6;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Visibility (int n) {
  WIN3D_UI_CurrentTask = 7;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

// the same messages of WIN3D_UI_CurrentTask=6/7 for both Layer/Visibility of group3Ds and DegreeMax/DegreeDif is not good!

void SOLARCHVISION_UI_set_to_Modify_DegreeMax (int n) {
  WIN3D_UI_CurrentTask = 8;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_DegreeDif (int n) {
  WIN3D_UI_CurrentTask = 9;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_DegreeMin (int n) {
  WIN3D_UI_CurrentTask = 10;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_TrunkSize (int n) {
  WIN3D_UI_CurrentTask = 11;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_LeafSize (int n) {
  WIN3D_UI_CurrentTask = 12;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_AllFractalProps (int n) {
  WIN3D_UI_CurrentTask = 13;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Pivot (int n) {
  WIN3D_UI_CurrentTask = 14;
  WIN3D_UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_FaceNormal (int n) {
  WIN3D_UI_CurrentTask = 15;
  WIN3D_UI_TaskModifyParameter = n; // 1:flip normal, 2:set out from pivot, 3:set in from pivot    

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_FaceFirstVertex (int n) {
  WIN3D_UI_CurrentTask = 16;
  WIN3D_UI_TaskModifyParameter = n; // 1:default

  Current_ObjectCategory = ObjectCategory_Faces; // << because it only works with face sub-object
  //SOLARCHVISION_UI_BAR_b_Update = 1;

  ROLLOUT_Update = 1;
}


void SOLARCHVISION_UI_set_to_Modify_Drop (int n) {
  WIN3D_UI_CurrentTask = 17;

  WIN3D_UI_TaskModifyParameter = n; // 0:LandSurface± 1:ModelSurface- 2:ModelSurface+

  ROLLOUT_Update = 1;
}


void SOLARCHVISION_UI_set_to_Modify_GetLength (int n) {
  WIN3D_UI_CurrentTask = 18;

  WIN3D_UI_TaskModifyParameter = n; // 0:x 1:y 2:z 3:xyz 4:xy 5:angle(on XY plane) 

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Modify_Power (int n) {

  if (n == 0) WIN3D_UI_CurrentTask = 19; // x 
  if (n == 1) WIN3D_UI_CurrentTask = 20; // y 
  if (n == 2) WIN3D_UI_CurrentTask = 21; // z 
  if (n == 3) WIN3D_UI_CurrentTask = 22; // xyz

  WIN3D_UI_TaskModifyParameter = 0; // 0:change

  ROLLOUT_Update = 1;
}


void SOLARCHVISION_UI_set_to_Create_Solid () {

  WIN3D_UI_CurrentTask = 0; 

  Current_ObjectCategory = ObjectCategory_Solids; // << because it only works with Solids
  //SOLARCHVISION_UI_BAR_b_Update = 1;

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Create_Section () {

  WIN3D_UI_CurrentTask = 0; 

  Current_ObjectCategory = ObjectCategory_Sections; // << because it only works with sections
  //SOLARCHVISION_UI_BAR_b_Update = 1;

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_Create_Camera () {

  WIN3D_UI_CurrentTask = 0;

  Current_ObjectCategory = ObjectCategory_Cameras; // << because it only works with cameras
  //SOLARCHVISION_UI_BAR_b_Update = 1;

  ROLLOUT_Update = 1;
}



void SOLARCHVISION_UI_set_to_View_ProjectionType (int n) {
  WIN3D_ViewType = n;

  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_View_ClickSelect (int n) {

  WIN3D_UI_CurrentTask = -1;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_View_WindowSelect (int n) {
  WIN3D_UI_CurrentTask = -2;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT_Update = 1;
}    

void SOLARCHVISION_UI_set_to_View_PivotX (int n) {

  selection_alignX = n;

  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_View_PivotY (int n) {

  selection_alignY = n;

  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_View_PivotZ (int n) {

  selection_alignZ = n;

  WIN3D_Update = 1; 
  ROLLOUT_Update = 1;
}      


void SOLARCHVISION_UI_set_to_View_Truck (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -3;
  }

  if (n == 1) {
    WIN3D_UI_CurrentTask = -6;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D_UI_CurrentTask = -6;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 1;
  }           

  ROLLOUT_Update = 1;
}  


void SOLARCHVISION_UI_set_to_View_DistMouseXY (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -17;
  }

  ROLLOUT_Update = 1;
}  



void SOLARCHVISION_UI_set_to_View_CameraDistance (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -13;
  }

  ROLLOUT_Update = 1;
}  



void SOLARCHVISION_UI_set_to_View_CameraRoll (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -12;
  }

  if (n == 1) {
    WIN3D_UI_CurrentTask = -11;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D_UI_CurrentTask = -11;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 1;
  }           

  ROLLOUT_Update = 1;
}  



void SOLARCHVISION_UI_set_to_View_TargetRoll (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -10;
  }

  if (n == 1) {
    WIN3D_UI_CurrentTask = -9;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D_UI_CurrentTask = -9;
    WIN3D_UI_TaskModifyParameter = 0;            
    WIN3D_UI_OptionXorY = 1;
  }           

  ROLLOUT_Update = 1;
}  


void SOLARCHVISION_UI_set_to_View_Orbit (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -3;
  }

  if (n == 1) {
    WIN3D_UI_CurrentTask = -6;
    WIN3D_UI_TaskModifyParameter = 1;            
    WIN3D_UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D_UI_CurrentTask = -6;
    WIN3D_UI_TaskModifyParameter = 1;            
    WIN3D_UI_OptionXorY = 1;
  }           

  ROLLOUT_Update = 1;
}  




void SOLARCHVISION_UI_set_to_View_LookAtSelection (int n) {

  SOLARCHVISION_look_3DViewport_towards_Selection();

  { // automatically set another choice of ineterest
    SOLARCHVISION_UI_set_to_View_CameraDistance(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDS");
    SOLARCHVISION_UI_BAR_b_Update = 1;
  }

  WIN3D_Update = 1;

  ROLLOUT_Update = 1;
}  


void SOLARCHVISION_UI_set_to_View_LookAtOrigin (int n) {

  WIN3D_X_Coordinate = 0;
  WIN3D_Y_Coordinate = 0;
  WIN3D_Z_Coordinate = 0; 

  {
    // automatically set another choice of ineterest

    SOLARCHVISION_UI_set_to_View_Truck(0);
    SOLARCHVISION_highlight_in_BAR_b("±CDZ");
    SOLARCHVISION_UI_BAR_b_Update = 1;
  }

  WIN3D_Update = 1;

  ROLLOUT_Update = 1;
}  

void SOLARCHVISION_UI_set_to_View_Pan (int n) {

  if (n == 0) {
    WIN3D_UI_CurrentTask = -14;
  }

  if (n == 1) {
    WIN3D_UI_CurrentTask = -15;
  }

  if (n == 2) {
    WIN3D_UI_CurrentTask = -16;
  }


  ROLLOUT_Update = 1;
}  

void SOLARCHVISION_UI_set_to_View_ZOOM (int n) {
  WIN3D_UI_CurrentTask = -4;

  if (n == 1) {
    WIN3D_Zoom = 60;
    WIN3D_Update = 1;
  }

  ROLLOUT_Update = 1;
}      

void SOLARCHVISION_UI_set_to_View_3DModelSize () {

  WIN3D_UI_CurrentTask = -5;

  WIN3D_Update = 1;  

  ROLLOUT_Update = 1;
}      

void SOLARCHVISION_UI_set_to_View_SkydomeSize () {

  WIN3D_UI_CurrentTask = -7;

  WIN3D_Update = 1;  

  ROLLOUT_Update = 1;
}   

void SOLARCHVISION_UI_set_to_View_AllModelSize () {

  WIN3D_UI_CurrentTask = -8;

  WIN3D_Update = 1;  

  ROLLOUT_Update = 1;
}   


void SOLARCHVISION_UI_set_to_View_3DViewSpace (int n) {

  FrameVariation = n;
  SOLARCHVISION_update_frame_layout();

  ROLLOUT_Update = 1;
}

void SOLARCHVISION_UI_set_to_View_3DViewPoint (int n) {

  WIN3D_CurrentCamera = 0;

  SOLARCHVISION_apply_currentCamera();

  if (n == 0) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(0 - WIN3D_RX_Coordinate);
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(0 - WIN3D_RZ_Coordinate);
  }

  if (n == 1) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(0 - WIN3D_RZ_Coordinate);
  }          

  if (n == 2) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(-90 - WIN3D_RZ_Coordinate);
  }    

  if (n == 3) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(180 - WIN3D_RZ_Coordinate);
  }   

  if (n == 4) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(90 - WIN3D_RZ_Coordinate);
  }  

  if (n == 5) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(180 - WIN3D_RX_Coordinate);
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(0 - WIN3D_RZ_Coordinate);
  }             

  if (n == 6) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(-45 - WIN3D_RZ_Coordinate);
  }             

  if (n == 7) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(45 - WIN3D_RZ_Coordinate);
  }     

  if (n == 8) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(135 - WIN3D_RZ_Coordinate);
  }

  if (n == 9) {
    SOLARCHVISION_rotateZ_3DViewport_around_Selection(90 - WIN3D_RX_Coordinate); 
    SOLARCHVISION_rotateXY_3DViewport_around_Selection(-135 - WIN3D_RZ_Coordinate);
  }


  SOLARCHVISION_UI_BAR_b_Update = 1;

  WIN3D_Update = 1;   

  ROLLOUT_Update = 1;
} 




int SOLARCHVISION_UI_BAR_d_Update = 1;

float SOLARCHVISION_UI_BAR_d_tab;

String[][] SOLARCHVISION_UI_BAR_d_Items = {

  {
    "Day"
  }
  , 
  {
    "Year"
  }
  , 
  {
    "Scenario"
  }
};         



void SOLARCHVISION_draw_window_BAR_d () {

  if (SOLARCHVISION_UI_BAR_d_Update == 1) {

    SOLARCHVISION_UI_BAR_d_Update = 0;

    SOLARCHVISION_UI_BAR_d_tab = SOLARCHVISION_D_Pixel / float(SOLARCHVISION_UI_BAR_d_Items.length);

    fill(191);
    noStroke();
    rect(0, SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel, width, SOLARCHVISION_D_Pixel);



    float displayBarHeight = MessageSize;
    float displayBarWidth = 2 * SOLARCHVISION_W_Pixel; 

    STUDY_X_control = 0.5 * displayBarWidth;
    STUDY_Y_control = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + 0.5 * SOLARCHVISION_UI_BAR_d_tab;

    for (int i = 0; i < SOLARCHVISION_UI_BAR_d_Items.length; i++) {

      float x1 = STUDY_X_control - 0.3666 * displayBarWidth;
      float x2 = STUDY_X_control + 0.4875 * displayBarWidth;
      float y1 = STUDY_Y_control - 0.45 * displayBarHeight;
      float y2 = STUDY_Y_control + 0.45 * displayBarHeight;

      fill(127);
      noStroke();      
      rect(x1, y1, x2 - x1, y2 - y1);      

      textAlign(RIGHT, CENTER);   
      stroke(0); 
      fill(0);
      textSize(1.25 * MessageSize);

      text(SOLARCHVISION_UI_BAR_d_Items[i][0] + ": ", x1, STUDY_Y_control - 0.2 * MessageSize);

      if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Day")) {

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {
            STUDY_i_Start = int(roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            ROLLOUT_Update = 1;
            STUDY_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }

          if (mouseButton == RIGHT) {
            STUDY_i_End = int(roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            ROLLOUT_Update = 1;
            STUDY_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }
        }        

        float x_start = x1 + (x2 - x1) * (STUDY_i_Start) / 24.0;  
        float x_end = x1 + (x2 - x1) * (STUDY_i_End + 1) / 24.0;

        fill(0, 191, 0, 191);
        noStroke();

        if (STUDY_i_Start <= STUDY_i_End) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        } else {
          rect(x1, y1, x_end - x1, y2 - y1);
          rect(x_start, y1, x2 - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);

        for (int j = 0; j < 24; j += 1) {
          text(nf(j, 0), x1 + (x2 - x1) * (j + 0.5) / 24.0, STUDY_Y_control - 0.2 * MessageSize);
        }
      }

      if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Year")) {

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {
            float keep_TIME_Date = TIME_Date;
            TIME_Date = (int(roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
            SOLARCHVISION_update_date(); 
            TIME_BeginDay = int(TIME_BeginDay + (TIME_Date - keep_TIME_Date) + 365) % 365;
            SOLARCHVISION_try_update_FORECAST_ENSEMBLE(TIME_Year, TIME_Month, TIME_Day, TIME_Hour);

            Update_DevelopData = 1;

            ROLLOUT_Update = 1;
            STUDY_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }

          if (mouseButton == RIGHT) {

            float _DATE2 = (int(roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;

            if (TIME_Date > _DATE2) _DATE2 += 365;

            STUDY_PerDays = int(roundTo((_DATE2 - TIME_Date) / float(STUDY_j_End - STUDY_j_Start - 1), 1));

            if (STUDY_PerDays < 0) STUDY_PerDays = 1;

            Update_DevelopData = 1;

            STUDY_Update = 1; 
            ROLLOUT_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }
        }        

        float keep_STUDY_PerDays = STUDY_PerDays;
        int keep_STUDY_JoinDays = STUDY_JoinDays;
        if ((IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) || (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED)) {
          STUDY_PerDays = 1;
          STUDY_JoinDays = 1;
        }

        for (int j = STUDY_j_Start; j < STUDY_j_End; j += 1) { 

          for (int j_ADD = 0; j_ADD < STUDY_JoinDays; j_ADD += 1) {    

            int now_j = int(j * STUDY_PerDays + (j_ADD - int(roundTo(0.5 * STUDY_JoinDays, 1))) + TIME_BeginDay + 365) % 365;

            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }

            float x_start = x1 + (x2 - x1) * ((now_j) % 365) / 365.0;  
            float x_end = x1 + (x2 - x1) * ((now_j + 1) % 365) / 365.0;

            fill(191, 0, 0, 191);
            noStroke();

            if (x_start <= x_end) { 
              rect(x_start, y1, x_end - x_start, y2 - y1);
            } else {
              rect(x1, y1, x_end - x1, y2 - y1);
              rect(x_start, y1, x2 - x_start, y2 - y1);
            }
          }
        }

        {
          textAlign(CENTER, CENTER);   
          stroke(0); 
          fill(0);
          textSize(1.25 * MessageSize);

          for (int j = 0; j < 12; j += 1) {
            text(CalendarMonth[j][Language_Active], x1 + (x2 - x1) * (j + 0.5) / 12.0, STUDY_Y_control - 0.2 * MessageSize);
          }
        }        

        STUDY_PerDays = keep_STUDY_PerDays;
        STUDY_JoinDays = keep_STUDY_JoinDays;
      }


      if (SOLARCHVISION_UI_BAR_d_Items[i][0].equals("Scenario")) {

        int n1 = 0;
        int n2 = 1;

        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
          n1 = 1950;
          n2 = 2050;
        }
        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
          n1 = 1950;
          n2 = 2050;
        }        
        if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) {
          n1 = 1950;
          n2 = 2050;
        }        
        if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
          n1 = FORECAST_ENSEMBLE_start;
          n2 = FORECAST_ENSEMBLE_end;
        }        
        if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
          n1 = RECENT_OBSERVED_start;
          n2 = RECENT_OBSERVED_end;
        }  

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

          if (mouseButton == LEFT) {

            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
              SampleYear_Start = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

              H_Layer_Option = -1;
            }
            
            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
              SampleYear_Start = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

              H_Layer_Option = -1;
            }            

            if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
              SampleMember_Start = V_selection;

              if (SampleMember_Start > SampleMember_End) {
                int swap_tmp = SampleMember_Start;
                SampleMember_Start = SampleMember_End;
                SampleMember_End = swap_tmp;
              }

              F_Layer_Option = -1;
            }            

            if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
              SampleStation_Start = V_selection;

              if (SampleStation_Start > SampleStation_End) {
                int swap_tmp = SampleStation_Start;
                SampleStation_Start = SampleStation_End;
                SampleStation_End = swap_tmp;
              }

              O_Layer_Option = -1;
            }       

            //Update_DevelopData = 1;

            ROLLOUT_Update = 1;
            STUDY_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }

          if (mouseButton == RIGHT) {

            int V_selection = n1 + int(roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));

            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
              SampleYear_End = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

              H_Layer_Option = -1;
            }

            if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
              SampleYear_End = V_selection;

              if (SampleYear_Start > SampleYear_End) {
                int swap_tmp = SampleYear_Start;
                SampleYear_Start = SampleYear_End;
                SampleYear_End = swap_tmp;
              }

              H_Layer_Option = -1;
            }

            if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
              SampleMember_End = V_selection;

              if (SampleMember_Start > SampleMember_End) {
                int swap_tmp = SampleMember_Start;
                SampleMember_Start = SampleMember_End;
                SampleMember_End = swap_tmp;
              }

              F_Layer_Option = -1;
            }

            if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
              SampleStation_End = V_selection;

              if (SampleStation_Start > SampleStation_End) {
                int swap_tmp = SampleStation_Start;
                SampleStation_Start = SampleStation_End;
                SampleStation_End = swap_tmp;
              }

              O_Layer_Option = -1;
            }                

            //Update_DevelopData = 1;

            ROLLOUT_Update = 1;
            STUDY_Update = 1;

            SOLARCHVISION_check_for_WIN3D_update();
          }
        }        

        float V_start = 0;  
        float V_end = 0;        

        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
          V_start = SampleYear_Start;
          V_end = SampleYear_End;
        }
        if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
          V_start = SampleYear_Start;
          V_end = SampleYear_End;
        }        
        if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
          V_start = SampleMember_Start;
          V_end = SampleMember_End;
        }
        if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
          V_start = SampleStation_Start;
          V_end = SampleStation_End;
        }        

        float x_start = x1 + (x2 - x1) * (V_start - n1) / float(n2 - n1 + 1);  
        float x_end = x1 + (x2 - x1) * (V_end - n1 + 1) / float(n2 - n1 + 1);

        fill(0, 0, 191, 191);
        noStroke();

        if (x_start <= x_end) { 
          rect(x_start, y1, x_end - x_start, y2 - y1);
        }

        textAlign(CENTER, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);

        for (int j = 0; j < n2 - n1 + 1; j += 1) {

          String txt = ".";

          if (j % 5 == 0) {
            txt = "|";
          }          

          if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) {
            if ((j % 10 == 5)) {
              txt = nf(j - 5 + n1, 0) + "s";
            }
          }
          if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) {
            if ((j % 10 == 5)) {
              txt = nf(j - 5 + n1, 0) + "s";
            }
          }          
          if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
            //if ((j % 1 == 0)) {
            txt = nf(j + n1, 0);
            //}
          }
          if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
            //if ((j % 1 == 0)) {
            txt = STATION_SWOB_INFO[nearest_Station_RECENT_OBSERVED_id[j]][6];
            //}
          }                 

          text(txt, x1 + (x2 - x1) * (j + 0.5) / float(n2 - n1 + 1), STUDY_Y_control - 0.2 * MessageSize);
        }
      }        




      STUDY_Y_control += SOLARCHVISION_UI_BAR_d_tab;
    }


    displayBarWidth = ROLLOUT_X_View; // <<<<<<<<<
    displayBarHeight = 4.5 * MessageSize;

    float temp_offsetX = ROLLOUT_CX_View + 0.5 * displayBarWidth;
    float temp_offsetY = SOLARCHVISION_A_Pixel + SOLARCHVISION_B_Pixel + 2 * SOLARCHVISION_H_Pixel + 0.5 * displayBarHeight;

    for (int n = 0; n < 9; n++) {

      int i = 2 - n / 3;
      int j = 2 - n % 3;

      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;

      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

        STUDY_ImpactLayer = n;

        ROLLOUT_Update = 1;
        STUDY_Update = 1;

        SOLARCHVISION_check_for_WIN3D_update();
      }
    }

    for (int n = 0; n < 9; n++) {

      int i = 2 - n / 3;
      int j = 2 - n % 3;

      float rx = (i + 0.5) / 3.0 - 0.5;
      float ry = (j + 0.5) / 3.0 - 0.5;

      float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
      float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
      float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
      float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;

      if (n == STUDY_ImpactLayer) { 
        fill(255, 127, 0);
        noStroke();
      } else if (n / 3 == STUDY_ImpactLayer / 3) {
        fill(127, 63, 0);
        noStroke();
      } else {
        fill(127);
        noStroke();
      }  
      rect(x1, y1, x2 - x1, y2 - y1);      

      textAlign(CENTER, CENTER);   
      if (n == STUDY_ImpactLayer) { 
        stroke(0); 
        fill(0);
      } else if (n / 3 == STUDY_ImpactLayer / 3) {
        stroke(191); 
        fill(191);
      } else {
        stroke(255); 
        fill(255);
      }        

      if (n == STUDY_ImpactLayer) { 
        textSize(1.25 * MessageSize);
      } else {
        textSize(1.125 * MessageSize);
      }

      text(STAT_N_Title[n], 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.2 * MessageSize);
    }    

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
  }
}   





void SOALRCHVISION_refreshDateTabs () {
  if ((IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) || (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) || (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW)) { 
    if (STUDY_PerDays == 1) { 
      STUDY_PerDays = int(365 / float(STUDY_j_End - STUDY_j_Start));
    } else {
      STUDY_PerDays = 1;
    }
  } 
  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) {
    STUDY_PerDays = 1;
  }           
  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) {
    if (STUDY_PerDays == 1) { 
      STUDY_PerDays = int(STUDY_max_j_end_observations / float(STUDY_j_End - STUDY_j_Start));
    } else {
      STUDY_PerDays = 1;
    }
  }
}  



int STUDY_isInHourlyRange (float i) {
  int q = -1;
  if (STUDY_i_Start <= STUDY_i_End) {
    q = 0;
    if ((STUDY_i_Start <= i) && (i <= (STUDY_i_End + 24) % 24)) q = 1;
  } else {
    q = 1;
    if ((STUDY_i_Start > i) && (i > (STUDY_i_End + 24) % 24)) q = 0;
  }
  return q;
}


int[] STUDY_get_startZ_endZ (int data_source) {
  int[] a = new int [3];

  int start_z = -1;
  int end_z = -1; 
  int layers_count = -1;

  if (data_source == databaseNumber_CLIMATE_CWEEDS) {

    // case -1 :
    start_z = SampleYear_Start;
    end_z = SampleYear_End; 

    switch(H_Layer_Option) {
    case 0 : 
      start_z = CLIMATE_CWEEDS_start; 
      end_z = CLIMATE_CWEEDS_end; 
      break;
    case 1 : 
      start_z = 1953; 
      end_z = 1959; 
      break;
    case 2 : 
      start_z = 1960; 
      end_z = 1969; 
      break;
    case 3 : 
      start_z = 1970; 
      end_z = 1979; 
      break;
    case 4 : 
      start_z = 1980; 
      end_z = 1989; 
      break;
    case 5 : 
      start_z = 1990; 
      end_z = 1999; 
      break;
    case 6 : 
      start_z = 2000; 
      end_z = 2005; 
      break;
    }

    if (start_z < CLIMATE_CWEEDS_start) start_z = CLIMATE_CWEEDS_start;
    if (end_z > CLIMATE_CWEEDS_end) end_z = CLIMATE_CWEEDS_end;

    start_z -= CLIMATE_CWEEDS_start - 1;
    end_z -= CLIMATE_CWEEDS_start - 1;
  }
  if (data_source == databaseNumber_CLIMATE_CLMREC) {

    // case -1 :
    start_z = SampleYear_Start;
    end_z = SampleYear_End; 

    switch(H_Layer_Option) {
    case 0 : 
      start_z = CLIMATE_CLMREC_start; 
      end_z = CLIMATE_CLMREC_end; 
      break;
      
      
      // could add more options here! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    }

    if (start_z < CLIMATE_CLMREC_start) start_z = CLIMATE_CLMREC_start;
    if (end_z > CLIMATE_CLMREC_end) end_z = CLIMATE_CLMREC_end;

    start_z -= CLIMATE_CLMREC_start - 1;
    end_z -= CLIMATE_CLMREC_start - 1;
  }  
  if (data_source == databaseNumber_FORECAST_ENSEMBLE) {

    // case -1 :
    start_z = SampleMember_Start;
    end_z = SampleMember_End;

    switch(F_Layer_Option) {
    case 0 : 
      start_z = FORECAST_ENSEMBLE_start; 
      end_z = FORECAST_ENSEMBLE_end; 
      break; //ALL: xml + grib2
    case 1 : 
      start_z = 23; 
      end_z = 43; 
      break; //xml: US
    case 2 : 
      start_z = 1; 
      end_z = 22; 
      break; //xml: GEPS + GDPS
    case 3: 
      start_z = 44; 
      end_z = FORECAST_ENSEMBLE_end; 
      break; // additional GRIB2 domains
    case 4: 
      start_z = 1; 
      end_z = 43; 
      break; //xml: NAEFS
    }
  }    
  if (data_source == databaseNumber_RECENT_OBSERVED) {

    // case -1 :
    start_z =  SampleStation_Start;
    end_z =  SampleStation_End;

    switch(O_Layer_Option) {
    case 0 : 
      start_z = RECENT_OBSERVED_start; 
      end_z = RECENT_OBSERVED_end; 
      break;
    case 1 : 
      start_z = 1; 
      end_z = 1; 
      break;
    }
  }   
  if (data_source == databaseNumber_CLIMATE_TMYEPW) {

    start_z = 1;
    end_z = 1;
  }   



  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CWEEDS) layers_count = (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start);
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_CLMREC) layers_count = (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start);
  if (IMPACTS_DataSource == databaseNumber_FORECAST_ENSEMBLE) layers_count = (1 + FORECAST_ENSEMBLE_end - FORECAST_ENSEMBLE_start); 
  if (IMPACTS_DataSource == databaseNumber_RECENT_OBSERVED) layers_count = (1 + RECENT_OBSERVED_end - RECENT_OBSERVED_start);
  if (IMPACTS_DataSource == databaseNumber_CLIMATE_TMYEPW) layers_count = 1;

  a[0] = start_z;
  a[1] = end_z;
  a[2] = layers_count;

  return  a;
}



void SOLARCHVISION_explore_output (String outputFile) {

  if ((Display_Output_in_Explorer == 1)  && (STUDY_record_AUTO == 0) && (WORLD_record_AUTO == 0) && (WIN3D_record_AUTO == 0) && (FRAME_record_AUTO == 0)) {
    //launch("explorer /select," + outputFile.replace('/', char(92)));
  }
}

void SOLARCHVISION_check_for_WIN3D_update () {

  if (WIN3D_FacesShade == Shade_Global_Solar) {
    rebuild_SolarProjection_array = 1;
    WIN3D_Update = 1;
  }
  if (Display_SolarImpactImage != 0) {
    rebuild_SolarImpactImage_array = 1;
    WIN3D_Update = 1;
  }     
  if (Display_WindRoseImage != 0) {
    rebuild_WindRoseImage_array = 1;
    WIN3D_Update = 1;
  }      


  if (Display_SUN3D_Path != 0) {
    WIN3D_Update = 1;
  }    
  if (Display_SUN3D_Pattern != 0) {
    WIN3D_Update = 1;
  }
}  




void SOLARCHVISION_save_project (String myFile, int explore_output) {

  myFile = myFile.replace(char(92), '/');

  XML my_xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");
  XML newChild1 = null;
  XML newChild2 = null;
  XML newChild3 = null;


  my_xml.setName("SOLARCHVISION_2015_project");

  newChild1 = my_xml.addChild("SOLARCHVISION_variables");

  newChild1.setString("LocationName", LocationName);
  newChild1.setString("LocationProvince", LocationProvince);
  newChild1.setFloat("LocationLatitude", LocationLatitude);
  newChild1.setFloat("LocationLongitude", LocationLongitude);
  newChild1.setFloat("LocationElevation", LocationElevation);
  newChild1.setFloat("LocationTimeZone", LocationTimeZone);
  newChild1.setFloat("LocationDeltaNoon", LocationDeltaNoon);

  newChild1.setInt("Display_Output_in_Explorer", Display_Output_in_Explorer);
  newChild1.setInt("Display_Model3Ds", Display_Model3Ds);
  newChild1.setInt("Display_Model2Ds", Display_Model2Ds);
  newChild1.setInt("Display_Fractals", Display_Fractals);
  newChild1.setInt("Display_Leaves", Display_Leaves);

  newChild1.setInt("Display_Solids", Display_Solids);
  newChild1.setInt("Display_Sections", Display_Sections);
  newChild1.setInt("Display_Cameras", Display_Cameras);

  newChild1.setInt("DEFAULT_CreateMaterial", DEFAULT_CreateMaterial);  
  newChild1.setInt("DEFAULT_CreateTessellation", DEFAULT_CreateTessellation);
  newChild1.setInt("DEFAULT_CreateLayer", DEFAULT_CreateLayer);
  newChild1.setInt("DEFAULT_CreateVisibility", DEFAULT_CreateVisibility);
  newChild1.setInt("DEFAULT_CreateExtraType", DEFAULT_CreateExtraType);
  newChild1.setInt("DEFAULT_CreatePivotType", DEFAULT_CreatePivotType);

  newChild1.setFloat("ModifyInput_WeldTreshold", ModifyInput_WeldTreshold);

  newChild1.setFloat("ModifyInput_OffsetAmount", ModifyInput_OffsetAmount);

  newChild1.setInt("ModifyInput_TessellateRows", ModifyInput_TessellateRows);
  newChild1.setInt("ModifyInput_TessellateColumns", ModifyInput_TessellateColumns);

  newChild1.setFloat("ModifyInput_OpenningDepth", ModifyInput_OpenningDepth);
  newChild1.setFloat("ModifyInput_OpenningArea", ModifyInput_OpenningArea);
  newChild1.setFloat("ModifyInput_OpenningDeviation", ModifyInput_OpenningDeviation);
  newChild1.setFloat("CreateInput_Length", CreateInput_Length);
  newChild1.setFloat("CreateInput_Width", CreateInput_Width);
  newChild1.setFloat("CreateInput_Height", CreateInput_Height);
  newChild1.setFloat("CreateInput_Volume", CreateInput_Volume);
  newChild1.setFloat("CreateInput_Orientation", CreateInput_Orientation);
  newChild1.setFloat("CreateInput_powX", CreateInput_powX);
  newChild1.setFloat("CreateInput_powY", CreateInput_powY);
  newChild1.setFloat("CreateInput_powZ", CreateInput_powZ);
  newChild1.setFloat("CreateInput_powAll", CreateInput_powAll);
  newChild1.setInt("CreateInput_powRnd", CreateInput_powRnd);
  newChild1.setInt("CreateInput_SphereDegree", CreateInput_SphereDegree);
  newChild1.setInt("CreateInput_CylinderDegree", CreateInput_CylinderDegree);
  newChild1.setInt("CreateInput_PolyDegree", CreateInput_PolyDegree);
  newChild1.setInt("CreateParametric_Type", CreateParametric_Type);
  newChild1.setInt("CreatePerson_Type", CreatePerson_Type);
  newChild1.setInt("CreatePlant_Type", CreatePlant_Type);
  newChild1.setInt("CreateFractal_Type", CreateFractal_Type);
  newChild1.setInt("CreateFractal_DegreeMin", CreateFractal_DegreeMin);
  newChild1.setInt("CreateFractal_DegreeMax", CreateFractal_DegreeMax);
  newChild1.setInt("CreateFractal_Seed", CreateFractal_Seed);
  newChild1.setFloat("CreateFractal_TrunkSize", CreateFractal_TrunkSize);
  newChild1.setFloat("CreateFractal_LeafSize", CreateFractal_LeafSize);
  newChild1.setInt("Current_ObjectCategory", Current_ObjectCategory);
  newChild1.setInt("CreateInput_MeshOrSolid", CreateInput_MeshOrSolid);
  newChild1.setInt("WIN3D_UI_CurrentTask", WIN3D_UI_CurrentTask);
  newChild1.setInt("WIN3D_UI_OptionXorY", WIN3D_UI_OptionXorY);
  newChild1.setInt("WIN3D_UI_TaskModifyParameter", WIN3D_UI_TaskModifyParameter);  

  newChild1.setInt("Display_SWOB_Points", Display_SWOB_Points);
  newChild1.setInt("Display_SWOB_Nearest", Display_SWOB_Nearest);
  newChild1.setInt("Display_NAEFS_Points", Display_NAEFS_Points);
  newChild1.setInt("Display_NAEFS_Nearest", Display_NAEFS_Nearest);
  newChild1.setInt("Display_CWEEDS_Points", Display_CWEEDS_Points);
  newChild1.setInt("Display_CWEEDS_Nearest", Display_CWEEDS_Nearest);
  newChild1.setInt("Display_CLMREC_Points", Display_CLMREC_Points);
  newChild1.setInt("Display_CLMREC_Nearest", Display_CLMREC_Nearest);
  newChild1.setInt("Display_TMYEPW_Points", Display_TMYEPW_Points);
  newChild1.setInt("Display_TMYEPW_Nearest", Display_TMYEPW_Nearest);
  newChild1.setInt("FRAME_record_AUTO", FRAME_record_AUTO);
  newChild1.setInt("FRAME_record_JPG", FRAME_record_JPG);
  newChild1.setInt("FRAME_click_JPG", FRAME_click_JPG);
  newChild1.setInt("FRAME_drag_JPG", FRAME_drag_JPG);
  newChild1.setInt("SolidImpact_record_PDF", SolidImpact_record_PDF);
  newChild1.setInt("SolidImpact_record_JPG", SolidImpact_record_JPG);
  newChild1.setInt("SolarImpact_record_JPG", SolarImpact_record_JPG);

  newChild1.setInt("RUN_AudioProduct", RUN_AudioProduct);
  newChild1.setInt("RUN_ExternalSimulation", RUN_ExternalSimulation);
  newChild1.setInt("RUN_ExternalHardware", RUN_ExternalHardware);

  newChild1.setFloat("SolidImpact_WindSpeed", SolidImpact_WindSpeed); 
  newChild1.setFloat("SolidImpact_WindDirection", SolidImpact_WindDirection);
  newChild1.setFloat("SolidImpact_Power", SolidImpact_Power);
  newChild1.setFloat("GlobalAlbedo", GlobalAlbedo);
  newChild1.setFloat("Interpolation_Weight", Interpolation_Weight);
  newChild1.setFloat("GLOBE_calculatedResolution", GLOBE_calculatedResolution);
  newChild1.setInt("CLIMATIC_SolarForecast", CLIMATIC_SolarForecast);
  newChild1.setInt("CLIMATIC_WeatherForecast", CLIMATIC_WeatherForecast);
  newChild1.setInt("SOLARCHVISION_automated", SOLARCHVISION_automated);

  newChild1.setInt("TIME_ModelRun", TIME_ModelRun);
  newChild1.setInt("TIME_Year", TIME_Year);
  newChild1.setInt("TIME_Month", TIME_Month);
  newChild1.setInt("TIME_Day", TIME_Day); 
  newChild1.setInt("TIME_Hour", TIME_Hour); 
  newChild1.setInt("TIME_BeginDay", TIME_BeginDay);
  newChild1.setFloat("TIME_Date", TIME_Date);

  newChild1.setFloat("LocationLAT_step", LocationLAT_step);
  newChild1.setFloat("LocationLON_step", LocationLON_step);
  newChild1.setFloat("LocationELE_step", LocationELE_step);


  newChild1.setInt("STUDY_record_JPG", STUDY_record_JPG);
  newChild1.setInt("STUDY_record_PDF", STUDY_record_PDF);
  newChild1.setInt("STUDY_record_AUTO", STUDY_record_AUTO);
  newChild1.setInt("WORLD_record_JPG", WORLD_record_JPG);
  newChild1.setInt("WORLD_record_PDF", WORLD_record_PDF);
  newChild1.setInt("WORLD_record_AUTO", WORLD_record_AUTO);
  newChild1.setInt("WIN3D_record_JPG", WIN3D_record_JPG);
  newChild1.setInt("WIN3D_record_AUTO", WIN3D_record_AUTO);
  newChild1.setInt("STUDY_i_Start", STUDY_i_Start);
  newChild1.setInt("STUDY_i_End", STUDY_i_End);
  //newChild1.setInt("STUDY_j_Start", STUDY_j_Start);
  newChild1.setInt("STUDY_j_End", STUDY_j_End);
  newChild1.setInt("STUDY_max_j_end_parameters", STUDY_max_j_end_parameters);
  newChild1.setInt("STUDY_max_j_end_observations", STUDY_max_j_end_observations);
  newChild1.setFloat("STUDY_PerDays", STUDY_PerDays);
  newChild1.setInt("STUDY_JoinDays", STUDY_JoinDays);
  newChild1.setInt("CLIMATE_TMYEPW_start", CLIMATE_TMYEPW_start);
  newChild1.setInt("CLIMATE_TMYEPW_end", CLIMATE_TMYEPW_end);
  newChild1.setInt("CLIMATE_CWEEDS_start", CLIMATE_CWEEDS_start);
  newChild1.setInt("CLIMATE_CWEEDS_end", CLIMATE_CWEEDS_end);
  newChild1.setInt("CLIMATE_CLMREC_start", CLIMATE_CLMREC_start);
  newChild1.setInt("CLIMATE_CLMREC_end", CLIMATE_CLMREC_end);
  newChild1.setInt("FORECAST_ENSEMBLE_start", FORECAST_ENSEMBLE_start);
  newChild1.setInt("FORECAST_ENSEMBLE_end", FORECAST_ENSEMBLE_end);
  newChild1.setInt("numberOfNearestStations_FORECAST_ENSEMBLE", numberOfNearestStations_FORECAST_ENSEMBLE);
  newChild1.setInt("numberOfNearestStations_RECENT_OBSERVED", numberOfNearestStations_RECENT_OBSERVED);
  newChild1.setInt("RECENT_OBSERVED_start", RECENT_OBSERVED_start);
  newChild1.setInt("RECENT_OBSERVED_end", RECENT_OBSERVED_end);
  newChild1.setInt("SampleYear_Start", SampleYear_Start);
  newChild1.setInt("SampleYear_End", SampleYear_End);
  newChild1.setInt("SampleMember_Start", SampleMember_Start);
  newChild1.setInt("SampleMember_End", SampleMember_End);
  newChild1.setInt("SampleStation_Start", SampleStation_Start);
  newChild1.setInt("SampleStation_End", SampleStation_End);
  newChild1.setInt("LoadButton_CLIMATE_TMYEPW", LoadButton_CLIMATE_TMYEPW);
  newChild1.setInt("LoadButton_CLIMATE_CWEEDS", LoadButton_CLIMATE_CWEEDS);
  newChild1.setInt("LoadButton_CLIMATE_CLMREC", LoadButton_CLIMATE_CLMREC);  
  newChild1.setInt("LoadButton_FORECAST_ENSEMBLE", LoadButton_FORECAST_ENSEMBLE);
  newChild1.setInt("LoadButton_RECENT_OBSERVED", LoadButton_RECENT_OBSERVED);
  newChild1.setInt("Download_RECENT_OBSERVED", Download_RECENT_OBSERVED);
  newChild1.setInt("Download_CLMREC", Download_CLMREC);  
  newChild1.setInt("Download_FORECAST_ENSEMBLE", Download_FORECAST_ENSEMBLE);
  newChild1.setInt("Download_AERIAL", Download_AERIAL);
  newChild1.setInt("GRIB2_Month", GRIB2_Month);
  newChild1.setInt("GRIB2_Day", GRIB2_Day);
  newChild1.setInt("GRIB2_ModelRun", GRIB2_ModelRun);
  newChild1.setInt("AERIAL_num", AERIAL_num);
  newChild1.setFloat("AERIAL_Center_Longitude", AERIAL_Center_Longitude);
  newChild1.setFloat("AERIAL_Center_Latitude", AERIAL_Center_Latitude);
  newChild1.setInt("GRIB2_Hour_Start", GRIB2_Hour_Start);
  newChild1.setInt("GRIB2_Hour_End", GRIB2_Hour_End);
  newChild1.setInt("GRIB2_Hour_Step", GRIB2_Hour_Step);
  newChild1.setInt("GRIB2_Layer_Start", GRIB2_Layer_Start);
  newChild1.setInt("GRIB2_Layer_End", GRIB2_Layer_End);
  newChild1.setInt("GRIB2_Layer_Step", GRIB2_Layer_Step);
  newChild1.setInt("GRIB2_Hour", GRIB2_Hour);
  newChild1.setInt("GRIB2_Layer", GRIB2_Layer);
  newChild1.setInt("GRIB2_DomainSelection", GRIB2_DomainSelection);
  newChild1.setInt("GRIB2_TGL_number", GRIB2_TGL_number);
  newChild1.setInt("AERIAL_graphOption", AERIAL_graphOption);
  newChild1.setInt("H_Layer_Option", H_Layer_Option);
  newChild1.setInt("F_Layer_Option", F_Layer_Option);
  newChild1.setInt("O_Layer_Option", O_Layer_Option);
  newChild1.setInt("Develop_Option", Develop_Option);
  newChild1.setInt("Develop_DayHour", Develop_DayHour);
  newChild1.setInt("Update_DevelopData", Update_DevelopData);
  newChild1.setInt("num_Layers", num_Layers);
  newChild1.setInt("LAYER_windspd200hPa", LAYER_windspd200hPa);
  newChild1.setInt("LAYER_thicknesses_1000_500", LAYER_thicknesses_1000_500);
  newChild1.setInt("LAYER_heightp500hPa", LAYER_heightp500hPa);
  newChild1.setInt("LAYER_ceilingsky", LAYER_ceilingsky);
  newChild1.setInt("LAYER_cloudcover", LAYER_cloudcover);
  newChild1.setInt("LAYER_winddir", LAYER_winddir);
  newChild1.setInt("LAYER_windspd", LAYER_windspd);
  newChild1.setInt("LAYER_pressure", LAYER_pressure);
  newChild1.setInt("LAYER_drybulb", LAYER_drybulb);
  newChild1.setInt("LAYER_relhum", LAYER_relhum);
  newChild1.setInt("LAYER_dirnorrad", LAYER_dirnorrad);
  newChild1.setInt("LAYER_difhorrad", LAYER_difhorrad);
  newChild1.setInt("LAYER_glohorrad", LAYER_glohorrad);
  newChild1.setInt("LAYER_direffect", LAYER_direffect);
  newChild1.setInt("LAYER_difeffect", LAYER_difeffect);
  newChild1.setInt("LAYER_precipitation_A", LAYER_precipitation_A);
  newChild1.setInt("LAYER_developed", LAYER_developed);
  newChild1.setFloat("Develop_AngleInclination", Develop_AngleInclination);
  newChild1.setFloat("Develop_AngleOrientation", Develop_AngleOrientation);
  newChild1.setInt("STUDY_CurrentLayer", STUDY_CurrentLayer);
  newChild1.setInt("STUDY_DevelopLayer", STUDY_DevelopLayer);
  newChild1.setInt("STUDY_PrintTtitle", STUDY_PrintTtitle);
  newChild1.setFloat("STUDY_T_scale", STUDY_T_scale);
  newChild1.setFloat("STUDY_U_scale", STUDY_U_scale);
  newChild1.setInt("STUDY_skyScenario_Active", STUDY_skyScenario_Active);
  newChild1.setInt("FILTER_Hourly", FILTER_Hourly);
  newChild1.setInt("FILTER_Daily", FILTER_Daily);
  newChild1.setInt("FILTER_Active", FILTER_Active);
  newChild1.setInt("STUDY_TrendJoinHours", STUDY_TrendJoinHours);
  newChild1.setInt("STUDY_TrendJoinType", STUDY_TrendJoinType);
  newChild1.setInt("TIME_Interval", TIME_Interval);
  newChild1.setInt("Export_STUDY_info_node", Export_STUDY_info_node);
  newChild1.setInt("Export_STUDY_info_norm", Export_STUDY_info_norm);
  newChild1.setInt("Export_STUDY_info_prob", Export_STUDY_info_prob);
  newChild1.setInt("STUDY_Pallet_SORT_CLR", STUDY_Pallet_SORT_CLR);
  newChild1.setInt("STUDY_Pallet_SORT_DIR", STUDY_Pallet_SORT_DIR);
  newChild1.setFloat("STUDY_Pallet_SORT_MLT", STUDY_Pallet_SORT_MLT);
  newChild1.setInt("STUDY_Pallet_PROB_CLR", STUDY_Pallet_PROB_CLR);
  newChild1.setInt("STUDY_Pallet_PROB_DIR", STUDY_Pallet_PROB_DIR);
  newChild1.setFloat("STUDY_Pallet_PROB_MLT", STUDY_Pallet_PROB_MLT);
  newChild1.setInt("STUDY_Pallet_ACTIVE_CLR", STUDY_Pallet_ACTIVE_CLR);
  newChild1.setInt("STUDY_Pallet_ACTIVE_DIR", STUDY_Pallet_ACTIVE_DIR);
  newChild1.setFloat("STUDY_Pallet_ACTIVE_MLT", STUDY_Pallet_ACTIVE_MLT);
  newChild1.setInt("STUDY_Pallet_PASSIVE_CLR", STUDY_Pallet_PASSIVE_CLR);
  newChild1.setInt("STUDY_Pallet_PASSIVE_DIR", STUDY_Pallet_PASSIVE_DIR);
  newChild1.setFloat("STUDY_Pallet_PASSIVE_MLT", STUDY_Pallet_PASSIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_CLR", OBJECTS_Pallet_ACTIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_ACTIVE_DIR", OBJECTS_Pallet_ACTIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_ACTIVE_MLT", OBJECTS_Pallet_ACTIVE_MLT);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_CLR", OBJECTS_Pallet_PASSIVE_CLR);
  newChild1.setInt("OBJECTS_Pallet_PASSIVE_DIR", OBJECTS_Pallet_PASSIVE_DIR);
  newChild1.setFloat("OBJECTS_Pallet_PASSIVE_MLT", OBJECTS_Pallet_PASSIVE_MLT);
  newChild1.setInt("SunPath3D_Pallet_ACTIVE_CLR", SunPath3D_Pallet_ACTIVE_CLR);
  newChild1.setInt("SunPath3D_Pallet_ACTIVE_DIR", SunPath3D_Pallet_ACTIVE_DIR);
  newChild1.setFloat("SunPath3D_Pallet_ACTIVE_MLT", SunPath3D_Pallet_ACTIVE_MLT);
  newChild1.setInt("SunPath3D_Pallet_PASSIVE_CLR", SunPath3D_Pallet_PASSIVE_CLR);
  newChild1.setInt("SunPath3D_Pallet_PASSIVE_DIR", SunPath3D_Pallet_PASSIVE_DIR);
  newChild1.setFloat("SunPath3D_Pallet_PASSIVE_MLT", SunPath3D_Pallet_PASSIVE_MLT);
  newChild1.setInt("SKY3D_Pallet_ACTIVE_CLR", SKY3D_Pallet_ACTIVE_CLR);
  newChild1.setInt("SKY3D_Pallet_ACTIVE_DIR", SKY3D_Pallet_ACTIVE_DIR);
  newChild1.setFloat("SKY3D_Pallet_ACTIVE_MLT", SKY3D_Pallet_ACTIVE_MLT);
  newChild1.setInt("SKY3D_Pallet_PASSIVE_CLR", SKY3D_Pallet_PASSIVE_CLR);
  newChild1.setInt("SKY3D_Pallet_PASSIVE_DIR", SKY3D_Pallet_PASSIVE_DIR);
  newChild1.setFloat("SKY3D_Pallet_PASSIVE_MLT", SKY3D_Pallet_PASSIVE_MLT);
  newChild1.setInt("ELEVATION_Pallet_CLR", ELEVATION_Pallet_CLR);
  newChild1.setInt("ELEVATION_Pallet_DIR", ELEVATION_Pallet_DIR);
  newChild1.setFloat("ELEVATION_Pallet_MLT", ELEVATION_Pallet_MLT);
  newChild1.setInt("SOLID_Pallet_CLR", SOLID_Pallet_CLR);
  newChild1.setInt("SOLID_Pallet_DIR", SOLID_Pallet_DIR);
  newChild1.setFloat("SOLID_Pallet_MLT", SOLID_Pallet_MLT);
  newChild1.setInt("WindFlow_Pallet_CLR", WindFlow_Pallet_CLR);
  newChild1.setInt("WindFlow_Pallet_DIR", WindFlow_Pallet_DIR);
  newChild1.setFloat("WindFlow_Pallet_MLT", WindFlow_Pallet_MLT);
  newChild1.setInt("Impact_ACTIVE", Impact_ACTIVE);
  newChild1.setInt("Impact_PASSIVE", Impact_PASSIVE);
  newChild1.setInt("Impact_WIND_Overlay", Impact_WIND_Overlay);
  newChild1.setInt("Impact_WIND_Temperature", Impact_WIND_Temperature);
  newChild1.setInt("Impact_TYPE", Impact_TYPE);
  newChild1.setFloat("STUDY_O_scale", STUDY_O_scale);
  newChild1.setFloat("STUDY_W_scale", STUDY_W_scale);
  newChild1.setInt("COLOR_STYLE_Active", COLOR_STYLE_Active);
  newChild1.setInt("COLOR_STYLE_Number", COLOR_STYLE_Number);
  newChild1.setFloat("STUDY_rect_scale", STUDY_rect_scale);
  newChild1.setFloat("STUDY_rect_offset_x", STUDY_rect_offset_x);
  newChild1.setInt("databaseNumber_RECENT_OBSERVED", databaseNumber_RECENT_OBSERVED);
  newChild1.setInt("databaseNumber_FORECAST_ENSEMBLE", databaseNumber_FORECAST_ENSEMBLE);
  newChild1.setInt("databaseNumber_CLIMATE_CWEEDS", databaseNumber_CLIMATE_CWEEDS);
  newChild1.setInt("databaseNumber_CLIMATE_CLMREC", databaseNumber_CLIMATE_CLMREC);
  newChild1.setInt("databaseNumber_CLIMATE_TMYEPW", databaseNumber_CLIMATE_TMYEPW);
  newChild1.setInt("IMPACTS_DataSource", IMPACTS_DataSource);
  newChild1.setInt("STUDY_impact_summary", STUDY_impact_summary);
  newChild1.setInt("STUDY_ImpactLayer", STUDY_ImpactLayer);
  newChild1.setInt("STUDY_PlotImpacts", STUDY_PlotImpacts);
  newChild1.setInt("STUDY_Impacts_Update", STUDY_Impacts_Update);
  newChild1.setInt("DrawnFrame", DrawnFrame);

  newChild1.setInt("LAND_TESSELLATION", LAND_TESSELLATION);
  newChild1.setInt("MODEL3D_Tessellation", MODEL3D_Tessellation);
  newChild1.setInt("SKY3D_TESSELLATION", SKY3D_TESSELLATION);
  newChild1.setFloat("SKY3D_scale", SKY3D_scale);
  newChild1.setFloat("WindRose3D_scale", WindRose3D_scale);

  newChild1.setFloat("Planetary_Magnification", Planetary_Magnification);
  newChild1.setInt("Display_SolarRotation", Display_SolarRotation);
  newChild1.setInt("Display_SUN3D_Path", Display_SUN3D_Path);
  newChild1.setInt("Display_SUN3D_Pattern", Display_SUN3D_Pattern);
  newChild1.setInt("Display_SKY3D", Display_SKY3D);
  newChild1.setInt("Display_STAR3D_Surface", Display_STAR3D_Surface);
  newChild1.setInt("Display_STAR3D_Texture", Display_STAR3D_Texture);
  newChild1.setInt("Display_MOON3D_Surface", Display_MOON3D_Surface);
  newChild1.setInt("Display_MOON3D_Texture", Display_MOON3D_Texture);
  newChild1.setInt("Display_TROPO3D_Surface", Display_TROPO3D_Surface);
  newChild1.setInt("Display_TROPO3D_Texture", Display_TROPO3D_Texture);
  newChild1.setInt("Display_EARTH3D_Surface", Display_EARTH3D_Surface);
  newChild1.setInt("Display_EARTH3D_Texture", Display_EARTH3D_Texture);
  newChild1.setInt("Download_LAND_MESH", Download_LAND_MESH);
  newChild1.setInt("LoadButton_LandMesh", LoadButton_LandMesh);
  newChild1.setInt("Display_LAND_MESH", Display_LAND_MESH);
  newChild1.setInt("Display_LAND_POINTS", Display_LAND_POINTS);
  newChild1.setInt("Display_LAND_Texture", Display_LAND_Texture);
  newChild1.setInt("Display_LAND_DEPTH", Display_LAND_DEPTH);
  newChild1.setInt("Skip_LAND_MESH_Center", Skip_LAND_MESH_Center);
  newChild1.setInt("LoadButton_UrbanMesh", LoadButton_UrbanMesh);
  newChild1.setInt("Display_URBAN_MESH", Display_URBAN_MESH);
  newChild1.setInt("Display_SolidImpact_Points", Display_SolidImpact_Points);
  newChild1.setInt("Display_SolidImpact_Lines", Display_SolidImpact_Lines);
  newChild1.setInt("MODEL3D_DisplayEdges", MODEL3D_DisplayEdges);
  newChild1.setInt("MODEL3D_DisplayNormals", MODEL3D_DisplayNormals);
  newChild1.setInt("Display_WindFlow", Display_WindFlow);
  newChild1.setInt("Camera_Variation", Camera_Variation);
  newChild1.setInt("STUDY_DisplayRaws", STUDY_DisplayRaws);
  newChild1.setInt("STUDY_DisplaySorted", STUDY_DisplaySorted);
  newChild1.setInt("STUDY_DisplayNormals", STUDY_DisplayNormals);
  newChild1.setInt("STUDY_DisplayProbs", STUDY_DisplayProbs);
  newChild1.setInt("STUDY_SumInterval", STUDY_SumInterval);
  newChild1.setFloat("STUDY_LevelPix", STUDY_LevelPix);
  newChild1.setFloat("STUDY_Pix", STUDY_Pix);
  newChild1.setInt("STUDY_Setup", STUDY_Setup);
  newChild1.setInt("Materials_Selection", Materials_Selection);
  newChild1.setInt("Shade_Surface_Wire", Shade_Surface_Wire);
  newChild1.setInt("Shade_Surface_Base", Shade_Surface_Base);
  newChild1.setInt("Shade_Surface_White", Shade_Surface_White);
  newChild1.setInt("Shade_Surface_Materials", Shade_Surface_Materials);
  newChild1.setInt("Shade_Global_Solar", Shade_Global_Solar);
  newChild1.setInt("Shade_Vertex_Solar", Shade_Vertex_Solar);
  newChild1.setInt("Shade_Vertex_Solid", Shade_Vertex_Solid);
  newChild1.setInt("Shade_Vertex_Elevation", Shade_Vertex_Elevation);
  newChild1.setFloat("WIN3D_CAM_x", WIN3D_CAM_x);
  newChild1.setFloat("WIN3D_CAM_y", WIN3D_CAM_y);
  newChild1.setFloat("WIN3D_CAM_z", WIN3D_CAM_z);
  newChild1.setFloat("WIN3D_CAM_fov", WIN3D_CAM_fov);
  newChild1.setFloat("WIN3D_CAM_dist", WIN3D_CAM_dist);
  newChild1.setFloat("WIN3D_CAM_clipNear", WIN3D_CAM_clipNear);
  newChild1.setFloat("WIN3D_CAM_clipFar", WIN3D_CAM_clipFar);
  newChild1.setInt("WIN3D_CurrentCamera", WIN3D_CurrentCamera);
  newChild1.setFloat("OBJECTS_scale", OBJECTS_scale);
  newChild1.setFloat("WIN3D_refScale", WIN3D_refScale);
  newChild1.setFloat("WIN3D_X_Coordinate", WIN3D_X_Coordinate);
  newChild1.setFloat("WIN3D_Y_Coordinate", WIN3D_Y_Coordinate);
  newChild1.setFloat("WIN3D_Z_Coordinate", WIN3D_Z_Coordinate);
  newChild1.setFloat("WIN3D_S_Coordinate", WIN3D_S_Coordinate);
  newChild1.setFloat("WIN3D_RX_Coordinate", WIN3D_RX_Coordinate);
  newChild1.setFloat("WIN3D_RY_Coordinate", WIN3D_RY_Coordinate);
  newChild1.setFloat("WIN3D_RZ_Coordinate", WIN3D_RZ_Coordinate);
  newChild1.setFloat("WIN3D_RS_Coordinate", WIN3D_RS_Coordinate);
  newChild1.setFloat("WIN3D_Zoom", WIN3D_Zoom);
  newChild1.setInt("WIN3D_ViewType", WIN3D_ViewType);
  newChild1.setInt("WIN3D_FacesShade", WIN3D_FacesShade);
  newChild1.setInt("selected_posVector", selected_posVector);
  newChild1.setInt("selected_rotVector", selected_rotVector);
  newChild1.setInt("selected_scaleVector", selected_scaleVector);
  newChild1.setFloat("selected_posValue", selected_posValue);
  newChild1.setFloat("selected_rotValue", selected_rotValue);
  newChild1.setFloat("selected_scaleValue", selected_scaleValue);
  newChild1.setInt("selection_alignX", selection_alignX);
  newChild1.setInt("selection_alignY", selection_alignY);
  newChild1.setInt("selection_alignZ", selection_alignZ);

  newChild1.setInt("selectedFace_displayEdges", selectedFace_displayEdges);
  newChild1.setInt("selectedFace_displayVertexCount", selectedFace_displayVertexCount);
  newChild1.setInt("selectedVertex_displayVertices", selectedVertex_displayVertices);
  newChild1.setInt("selectedGroup3D_displayPivot", selectedGroup3D_displayPivot);  
  newChild1.setInt("selected_displayReferencePivot", selected_displayReferencePivot);
  newChild1.setInt("selectedGroup3D_displayEdges", selectedGroup3D_displayEdges);
  newChild1.setInt("selectedGroup3D_displayBox", selectedGroup3D_displayBox);
  newChild1.setInt("selectedObject2D_displayEdges", selectedObject2D_displayEdges);
  newChild1.setInt("selectedFractal_displayEdges", selectedFractal_displayEdges);
  newChild1.setInt("selectedSolid_displayEdges", selectedSolid_displayEdges);
  newChild1.setInt("selectedSection_displayEdges", selectedSection_displayEdges);
  newChild1.setInt("selectedCamera_displayEdges", selectedCamera_displayEdges);
  newChild1.setInt("selectedLandPoint_displayPoints", selectedLandPoint_displayPoints);

  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius);

  newChild1.setInt("WORLD_Viewport_ZOOM", WORLD_Viewport_ZOOM);
  newChild1.setInt("FrameVariation", FrameVariation);
  newChild1.setInt("Language_Active", Language_Active);

  newChild1.setInt("IMPACTS_DisplayDay", IMPACTS_DisplayDay);
  newChild1.setInt("Display_WindRoseImage", Display_WindRoseImage);
  newChild1.setInt("WindRose_RES", WindRose_RES);
  newChild1.setInt("Rendered_WindRose_RES", Rendered_WindRose_RES);
  newChild1.setInt("Display_SolarImpactImage", Display_SolarImpactImage);
  newChild1.setInt("SolarImpact_sectionType", SolarImpact_sectionType);
  newChild1.setFloat("SolarImpact_Rotation", SolarImpact_Rotation);
  newChild1.setFloat("SolarImpact_scale_U", SolarImpact_scale_U);
  newChild1.setFloat("SolarImpact_scale_V", SolarImpact_scale_V);
  newChild1.setFloat("SolarImpact_offset_U", SolarImpact_offset_U);
  newChild1.setFloat("SolarImpact_offset_V", SolarImpact_offset_V);  
  newChild1.setInt("SolarImpact_RES1", SolarImpact_RES1);
  newChild1.setInt("SolarImpact_RES2", SolarImpact_RES2);
  newChild1.setFloat("SolarImpact_Elevation", SolarImpact_Elevation);
  newChild1.setInt("SolidImpact_RES1", SolidImpact_RES1);
  newChild1.setInt("SolidImpact_RES2", SolidImpact_RES2);
  newChild1.setFloat("SolidImpact_Grade", SolidImpact_Grade);
  newChild1.setInt("Display_SolidImpactImage", Display_SolidImpactImage);
  newChild1.setInt("SolidImpact_sectionType", SolidImpact_sectionType);
  newChild1.setFloat("SolidImpact_positionStep", SolidImpact_positionStep);
  newChild1.setInt("Process_subDivisions", Process_subDivisions);
  newChild1.setFloat("deltaSolidImpactStep", deltaSolidImpactStep);
  newChild1.setFloat("deltaSolidImpactLines", deltaSolidImpactLines);
  newChild1.setFloat("MinimumDistance_traceU", MinimumDistance_traceU);
  newChild1.setFloat("MinimumDistance_traceV", MinimumDistance_traceV);
  newChild1.setFloat("SOLARCHVISION_GLOBE_stp_slp", SOLARCHVISION_GLOBE_stp_slp);
  newChild1.setFloat("SOLARCHVISION_GLOBE_stp_dir", SOLARCHVISION_GLOBE_stp_dir);
  newChild1.setInt("SOLARCHVISION_GLOBE_n_slp", SOLARCHVISION_GLOBE_n_slp);
  newChild1.setInt("SOLARCHVISION_GLOBE_n_dir", SOLARCHVISION_GLOBE_n_dir);
  newChild1.setInt("LAND_n_I_base", LAND_n_I_base);
  newChild1.setInt("LAND_n_J_base", LAND_n_J_base);
  newChild1.setInt("LAND_n_I", LAND_n_I);
  newChild1.setInt("LAND_n_J", LAND_n_J);
  newChild1.setString("LAND_mid_lat", Double.toString(LAND_mid_lat));
  newChild1.setString("LAND_mid_lon", Double.toString(LAND_mid_lon));

  newChild1.setInt("Object2D_PEOPLE_Files_Num", Object2D_PEOPLE_Files_Num);
  newChild1.setInt("Object2D_TREES_Files_Num", Object2D_TREES_Files_Num); 

  newChild1.setFloat("softSelection_Power", softSelection_Power);
  newChild1.setFloat("softSelection_Radius", softSelection_Radius); 

  newChild1.setInt("addToLastGroup3D", addToLastGroup3D);

  newChild1.setFloat("BIOSPHERE_drawResolution", BIOSPHERE_drawResolution);
  newChild1.setFloat("objExport_Scale", objExport_Scale);
  newChild1.setInt("objExport_FlipZYaxis", objExport_FlipZYaxis);
  newChild1.setInt("objExport_PrecisionVertex", objExport_PrecisionVertex);
  newChild1.setInt("objExport_PrecisionVtexture", objExport_PrecisionVtexture);
  newChild1.setInt("objExport_PolyToPoly", objExport_PolyToPoly);
  newChild1.setInt("objExport_MaterialLibrary", objExport_MaterialLibrary);
  newChild1.setInt("objExport_BackSides", objExport_BackSides);
  newChild1.setInt("objExport_CombinedMaterial", objExport_CombinedMaterial);
  newChild1.setInt("objExport_BakingResolution", objExport_BakingResolution);
  newChild1.setInt("objExport_PalletResolution", objExport_PalletResolution);
  newChild1.setInt("objExport_UsePalletOrBakeFaces", objExport_UsePalletOrBakeFaces);

  newChild1.setString("Default_Font", Default_Font);

  newChild1.setInt("LAND_n_I_base", LAND_n_I_base);
  newChild1.setInt("LAND_n_J_base", LAND_n_J_base);
  newChild1.setInt("LAND_n_I", LAND_n_I);
  newChild1.setInt("LAND_n_J", LAND_n_J);

  newChild1.setInt("LAND_Texture_num", LAND_Texture_num);

  {
    newChild1 = my_xml.addChild("LAND_Texture_scale_U");
    int ni = LAND_Texture_scale_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAND_Texture_scale_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAND_Texture_scale_V");
    int ni = LAND_Texture_scale_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAND_Texture_scale_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    int TEXTURE_copied = 0;

    String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder

    for (int q = 1; q <= LAND_Texture_num; q++) {

      int n_Map = q; 

      String the_filename = LAND_Texture_ImagePath[n_Map].substring(LAND_Texture_ImagePath[n_Map].lastIndexOf("/") + 1); // image name

      String new_Texture_path = the_dir + "/Textures/" +  the_filename;

      //println("pre_LAND_Texture_ImagePath", LAND_Texture_ImagePath[n_Map]);
      //println("new_Texture_path", new_Texture_path);

      if (LAND_Texture_ImagePath[n_Map].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        TEXTURE_copied = -1;
      } else {

        println("Copying texture:", LAND_Texture_ImagePath[n_Map], ">", new_Texture_path);
        saveBytes(new_Texture_path, loadBytes(LAND_Texture_ImagePath[n_Map]));
        LAND_Texture_ImagePath[n_Map] = new_Texture_path;

        TEXTURE_copied = 1;
      }

      //if (TEXTURE_copied == 0) {
      //  println("Saving texture from the scene.");
      //  LAND_Texture_Map[n_Map].save(new_Texture_path);
      //}
    }
  }

  {
    newChild1 = my_xml.addChild("LAND_Texture_ImagePath");
    int ni = LAND_Texture_ImagePath.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += LAND_Texture_ImagePath[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }



  {
    newChild1 = my_xml.addChild("Object2D_ImagePath");
    int ni = Object2D_ImagePath.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {

      int TEXTURE_copied = 0;

      String the_dir = myFile.substring(0, myFile.lastIndexOf("/")); // project folder

      String the_filename = "";
      if (Object2D_ImagePath[i].equals("")) {
      } else {
        the_filename = Object2D_ImagePath[i].substring(Object2D_ImagePath[i].lastIndexOf("/") + 1); // image name


        String new_Texture_path = the_dir + "/Textures/" + the_filename;

        //println("pre_Object2D_ImagePath", Object2D_ImagePath[i]);
        //println("new_Object2D_ImagePath", new_Object2D_ImagePath[i]);

        if (Object2D_ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
          TEXTURE_copied = -1;
        } else {
          if (Object2D_ImagePath[i].equals("")) {
          } else {
            println("Copying texture:", Object2D_ImagePath[i], ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(Object2D_ImagePath[i]));
            Object2D_ImagePath[i] = new_Texture_path;

            TEXTURE_copied = 1;
          }
        }

        //if (TEXTURE_copied == 0) {
        //  println("Saving texture from the scene.");
        //  Object2D_Images[i].save(new_Texture_path);
        //}
      }

      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(Object2D_ImagePath[i]);
    }
  }


  {
    newChild1 = my_xml.addChild("allSections_SolidImpact");
    int ni = allSections_SolidImpact.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {

      String the_filename = "SolidImpact_" + nf(i, 0) + ".bmp";

      String TEXTURE_path = ProjectsFolder + "/Textures/" + the_filename;

      println("Saving texture:", TEXTURE_path);
      allSections_SolidImpact[i].save(TEXTURE_path);

      newChild2 = newChild1.addChild("Path");
      newChild2.setInt("id", i); 
      newChild2.setContent(TEXTURE_path);
    }
  }

  {
    newChild1 = my_xml.addChild("allSections_SolarImpact");
    int ni = allSections_SolarImpact.length;
    int nj = allSections_SolarImpact[0].length;
    newChild1.setInt("ni", ni);
    newChild1.setInt("nj", nj);

    println("ni", ni);
    println("nj", nj);

    for (int i = 0; i < ni; i++) {
      for (int j = 0; j < nj; j++) {

        String the_filename = "SolarImpact_" + nf(i * nj + j, 0) + ".bmp";

        String TEXTURE_path = ProjectsFolder + "/Textures/" + the_filename;

        println("Saving texture:", TEXTURE_path);
        allSections_SolarImpact[i][j].save(TEXTURE_path);

        newChild2 = newChild1.addChild("Path");
        newChild2.setInt("id", i * nj + j); 
        newChild2.setContent(TEXTURE_path);
      }
    }
  }

  println("Saving:STATION");
  {
    newChild1 = my_xml.addChild("DEFINED_STATION");
    newChild1.setInt("ni", Defined_Stations[STATION_Number].length);
    for (int i = 0; i < Defined_Stations[STATION_Number].length; i++) {
      newChild2 = newChild1.addChild("Property");
      newChild2.setInt("id", i);
      newChild2.setContent(Defined_Stations[STATION_Number][i]);
    }
  }

  println("Saving:LAND_MESH");
  {
    newChild1 = my_xml.addChild("LAND_MESH");
    int vNo = 0;
    for (int i = 0; i < LAND_MESH.length; i++) {
      for (int j = 0; j < LAND_MESH[i].length; j++) {
        newChild2 = newChild1.addChild("Vertice");
        newChild2.setInt("id", vNo);
        String lineSTR = "";
        //for (int k = 0; k < LAND_MESH[i][j].length; k++) {
        for (int k = 0; k < 3; k++) { // x, y, z 
          lineSTR += nf(LAND_MESH[i][j][k], 0, 4).replace(",", "."); // <<<<
          if (k < LAND_MESH[i][j].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
        vNo += 1;
      }
    }
  }  

  println("Saving:Cameras");
  {
    newChild1 = my_xml.addChild("allCameras");
    int ni = 1 + allCameras_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Camera");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allCameras_PPPSRRRF[i].length; j++) {
      for (int j = 0; j < 8; j++) { // x, y, z, s, rx, ry, rz, zoom
        lineSTR += nf(allCameras_PPPSRRRF[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(allCameras_Type[i], 0);
      lineSTR += ",";

      newChild2.setContent(lineSTR);
    }
  }  

  println("Saving:Sections");
  {
    newChild1 = my_xml.addChild("allSections");
    int ni = 1 + allSections_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Section");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allSections_UVERAB[i].length; j++) {
      for (int j = 0; j < 6; j++) { // u, v, e, r, a, b
        lineSTR += nf(allSections_UVERAB[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(allSections_Type[i], 0);
      lineSTR += ",";
      lineSTR += nf(allSections_RES1[i], 0);
      lineSTR += ",";
      lineSTR += nf(allSections_RES2[i], 0);

      newChild2.setContent(lineSTR);
    }
  }

  println("Saving:Solids");
  {
    newChild1 = my_xml.addChild("allSolids_DEF");
    int ni = allSolids_DEF.length;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Solid");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allSolids_DEF[i].length; j++) {
      for (int j = 0; j < 13; j++) { // x, y, y, px, py, pz, sx, sy, sz, rx, ry, rz, v
        lineSTR += nf(allSolids_DEF[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 != allSolids_DEF[i].length) lineSTR += ",";
      }

      newChild2.setContent(lineSTR);
    }
  }  

  println("Saving:Fractals");
  {
    newChild1 = my_xml.addChild("allFractals");
    int ni = 1 + allFractals_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Fractal");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allFractals_XYZSR[i].length; j++) {
      for (int j = 0; j < 5; j++) { // x, y, z, s, rot
        lineSTR += nf(allFractals_XYZSR[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(allFractals_Type[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractals_DegreeMin[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractals_DegreeMax[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractals_Seed[i], 0);
      lineSTR += ",";
      lineSTR += nf(allFractals_TrunkSize[i], 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(allFractals_LeafSize[i], 0, 4).replace(",", "."); // <<<<

      newChild2.setContent(lineSTR);
    }
  }

  println("Saving:Object2Ds");
  {
    newChild1 = my_xml.addChild("allObject2Ds");
    int ni = 1 + allObject2Ds_num;
    newChild1.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      newChild2 = newChild1.addChild("Object2D");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allObject2Ds_XYZS[i].length; j++) {
      for (int j = 0; j < 4; j++) { // x, y, z, s 
        lineSTR += nf(allObject2Ds_XYZS[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += allObject2Ds_MAP[i];

      newChild2.setContent(lineSTR);
    }
  }

  println("Saving:Vertices");
  {
    newChild1 = my_xml.addChild("allVertices");
    newChild1.setInt("ni", allVertices.length);
    for (int i = 0; i < allVertices.length; i++) {
      newChild2 = newChild1.addChild("Vertice");
      newChild2.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < allVertices[i].length; j++) {
      for (int j = 0; j < 3; j++) { // x, y, z 
        lineSTR += nf(allVertices[i][j], 0, 4).replace(",", "."); // <<<<
        if (j < allVertices[i].length - 1) lineSTR += ",";
      }
      newChild2.setContent(lineSTR);
    }
  }

  println("Saving:Faces");
  {
    {
      newChild1 = my_xml.addChild("allFaces_PNT");
      newChild1.setInt("ni", allFaces_PNT.length);
      for (int i = 0; i < allFaces_PNT.length; i++) {
        newChild2 = newChild1.addChild("Face");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allFaces_PNT[i].length; j++) {
          lineSTR += nf(allFaces_PNT[i][j], 0);
          if (j < allFaces_PNT[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allFaces_MTLV");
      newChild1.setInt("ni", allFaces_MTLV.length);
      for (int i = 0; i < allFaces_MTLV.length; i++) {
        newChild2 = newChild1.addChild("Face_MTLV");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allFaces_MTLV[i].length; j++) {
          lineSTR += nf(allFaces_MTLV[i][j], 0);
          if (j < allFaces_MTLV[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }
  }




  println("Saving:Group3Ds");
  {
    {
      newChild1 = my_xml.addChild("allGroup3Ds_Object2Ds");
      newChild1.setInt("ni", allGroup3Ds_num + 1);
      for (int i = 0; i < allGroup3Ds_num + 1; i++) {
        newChild2 = newChild1.addChild("Object2Ds");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroup3Ds_Object2Ds[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroup3Ds_Object2Ds[i][j], 0);
          if (j < allGroup3Ds_Object2Ds[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroup3Ds_Fractals");
      newChild1.setInt("ni", allGroup3Ds_num + 1);
      for (int i = 0; i < allGroup3Ds_num + 1; i++) {
        newChild2 = newChild1.addChild("Fractals");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroup3Ds_Fractals[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroup3Ds_Fractals[i][j], 0);
          if (j < allGroup3Ds_Fractals[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroup3Ds_Faces");
      newChild1.setInt("ni", allGroup3Ds_num + 1);
      for (int i = 0; i < allGroup3Ds_num + 1; i++) {
        newChild2 = newChild1.addChild("Faces");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroup3Ds_Faces[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroup3Ds_Faces[i][j], 0);
          if (j < allGroup3Ds_Faces[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {    
      newChild1 = my_xml.addChild("allGroup3Ds_Solids");
      newChild1.setInt("ni", allGroup3Ds_num + 1);
      for (int i = 0; i < allGroup3Ds_num + 1; i++) {
        newChild2 = newChild1.addChild("Solids");
        newChild2.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < allGroup3Ds_Solids[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(allGroup3Ds_Solids[i][j], 0);
          if (j < allGroup3Ds_Solids[i].length - 1) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }

    {
      newChild1 = my_xml.addChild("allGroup3Ds_PivotXYZ");
      int ni = allGroup3Ds_num + 1;
      newChild1.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        newChild2 = newChild1.addChild("PivotXYZ");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allGroup3Ds_PivotXYZ[i].length; j++) {
          lineSTR += nf(allGroup3Ds_PivotXYZ[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < allGroup3Ds_PivotXYZ[i].length) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }  

    {
      newChild1 = my_xml.addChild("allGroup3Ds_PivotType");
      int ni = allGroup3Ds_num + 1;
      newChild1.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        newChild2 = newChild1.addChild("PivotType");
        newChild2.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < allGroup3Ds_PivotType[i].length; j++) {
          lineSTR += nf(allGroup3Ds_PivotType[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < allGroup3Ds_PivotType[i].length) lineSTR += ",";
        }
        newChild2.setContent(lineSTR);
      }
    }
  }

  {
    newChild1 = my_xml.addChild("selectedLandPoint_numbers");
    int ni = selectedLandPoint_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedLandPoint_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("selectedFractal_numbers");
    int ni = selectedFractal_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedFractal_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedObject2D_numbers");
    int ni = selectedObject2D_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedObject2D_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedGroup3D_numbers");
    int ni = selectedGroup3D_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedGroup3D_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("selectedFace_numbers");
    int ni = selectedFace_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedFace_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_numbers");
    int ni = selectedVertex_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionVertices");
    int ni = selectedVertex_softSelectionVertices.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedVertex_softSelectionVertices[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedVertex_softSelectionValues");
    int ni = selectedVertex_softSelectionValues.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(selectedVertex_softSelectionValues[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("selectedSolid_numbers");
    int ni = selectedSolid_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedSolid_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedSection_numbers");
    int ni = selectedSection_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedSection_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("selectedCamera_numbers");
    int ni = selectedCamera_numbers.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += selectedCamera_numbers[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    



  {
    newChild1 = my_xml.addChild("SolidImpact_Elevation");
    int ni = SolidImpact_Elevation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_Elevation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }

  {
    newChild1 = my_xml.addChild("SolidImpact_Rotation");
    int ni = SolidImpact_Rotation.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_Rotation[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("SolidImpact_scale_U");
    int ni = SolidImpact_scale_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_scale_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_scale_V");
    int ni = SolidImpact_scale_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_scale_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_offset_U");
    int ni = SolidImpact_offset_U.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_offset_U[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    

  {
    newChild1 = my_xml.addChild("SolidImpact_offset_V");
    int ni = SolidImpact_offset_V.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(SolidImpact_offset_V[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }    


  {
    newChild1 = my_xml.addChild("STUDY_V_scale");
    int ni = STUDY_V_scale.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_scale[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("STUDY_V_offset");
    int ni = STUDY_V_offset.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_offset[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  

  {
    newChild1 = my_xml.addChild("STUDY_V_belowLine");
    int ni = STUDY_V_belowLine.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(STUDY_V_belowLine[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }  


  {
    newChild1 = my_xml.addChild("LAYERS_Unit");
    int ni = LAYERS_Unit.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += LAYERS_Unit[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_Text");
    int ni = LAYERS_Text.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += LAYERS_Text[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_GRIB2_MUL");
    int ni = LAYERS_GRIB2_MUL.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAYERS_GRIB2_MUL[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("LAYERS_GRIB2_ADD");
    int ni = LAYERS_GRIB2_ADD.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += nf(LAYERS_GRIB2_ADD[i], 0, 4).replace(",", "."); // <<<<
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  {
    newChild1 = my_xml.addChild("GRIB2_TGL_Selected");
    int ni = GRIB2_TGL_Selected.length;
    newChild1.setInt("ni", ni);
    String lineSTR = "";
    for (int i = 0; i < ni; i++) {
      lineSTR += GRIB2_TGL_Selected[i];
      if (i < ni - 1) lineSTR += ",";
    }
    newChild1.setContent(lineSTR);
  }


  saveXML(my_xml, myFile);    

  println("End of saving project.");

  if (explore_output != 0) SOLARCHVISION_explore_output(myFile);
}


void SOLARCHVISION_load_project (String myFile) {

  myFile = myFile.replace(char(92), '/');


  int continue_process = 1;

  XML FileAll = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileAll = loadXML(myFile);
  }
  catch (Exception e) {
    println("Can't read:", myFile);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    XML[] children0 = FileAll.getChildren("SOLARCHVISION_variables");

    for (int L = 0; L < children0.length; L++) {

      LocationName = children0[L].getString("LocationName");
      LocationProvince = children0[L].getString("LocationProvince");     
      LocationLatitude = children0[L].getFloat("LocationLatitude");
      LocationLongitude = children0[L].getFloat("LocationLongitude");
      LocationElevation = children0[L].getFloat("LocationElevation");
      LocationTimeZone = children0[L].getFloat("LocationTimeZone");
      LocationDeltaNoon = children0[L].getFloat("LocationDeltaNoon");

      Display_Output_in_Explorer = children0[L].getInt("Display_Output_in_Explorer");
      Display_Model3Ds = children0[L].getInt("Display_Model3Ds");
      Display_Model2Ds = children0[L].getInt("Display_Model2Ds");
      Display_Fractals = children0[L].getInt("Display_Fractals");
      Display_Leaves = children0[L].getInt("Display_Leaves");

      Display_Solids = children0[L].getInt("Display_Solids");
      Display_Sections = children0[L].getInt("Display_Sections");
      Display_Cameras = children0[L].getInt("Display_Cameras");

      DEFAULT_CreateMaterial = children0[L].getInt("DEFAULT_CreateMaterial");
      DEFAULT_CreateTessellation = children0[L].getInt("DEFAULT_CreateTessellation");
      DEFAULT_CreateLayer = children0[L].getInt("DEFAULT_CreateLayer");
      DEFAULT_CreateVisibility = children0[L].getInt("DEFAULT_CreateVisibility");
      DEFAULT_CreateExtraType = children0[L].getInt("DEFAULT_CreateExtraType");
      DEFAULT_CreatePivotType = children0[L].getInt("DEFAULT_CreatePivotType");

      ModifyInput_WeldTreshold = children0[L].getFloat("ModifyInput_WeldTreshold");

      ModifyInput_OffsetAmount = children0[L].getFloat("ModifyInput_OffsetAmount");

      ModifyInput_TessellateRows = children0[L].getInt("ModifyInput_TessellateRows");
      ModifyInput_TessellateColumns = children0[L].getInt("ModifyInput_TessellateColumns");

      ModifyInput_OpenningDepth = children0[L].getFloat("ModifyInput_OpenningDepth");
      ModifyInput_OpenningArea = children0[L].getFloat("ModifyInput_OpenningArea");
      ModifyInput_OpenningDeviation = children0[L].getFloat("ModifyInput_OpenningDeviation");
      CreateInput_Length = children0[L].getFloat("CreateInput_Length");
      CreateInput_Width = children0[L].getFloat("CreateInput_Width");
      CreateInput_Height = children0[L].getFloat("CreateInput_Height");
      CreateInput_Volume = children0[L].getFloat("CreateInput_Volume");
      CreateInput_Orientation = children0[L].getFloat("CreateInput_Orientation");
      CreateInput_powX = children0[L].getFloat("CreateInput_powX");
      CreateInput_powY = children0[L].getFloat("CreateInput_powY");
      CreateInput_powZ = children0[L].getFloat("CreateInput_powZ");
      CreateInput_powAll = children0[L].getFloat("CreateInput_powAll");
      CreateInput_powRnd = children0[L].getInt("CreateInput_powRnd");
      CreateInput_SphereDegree = children0[L].getInt("CreateInput_SphereDegree");
      CreateInput_CylinderDegree = children0[L].getInt("CreateInput_CylinderDegree");
      CreateInput_PolyDegree = children0[L].getInt("CreateInput_PolyDegree");
      CreateParametric_Type = children0[L].getInt("CreateParametric_Type");
      CreatePerson_Type = children0[L].getInt("CreatePerson_Type");
      CreatePlant_Type = children0[L].getInt("CreatePlant_Type");
      CreateFractal_Type = children0[L].getInt("CreateFractal_Type");
      CreateFractal_DegreeMin = children0[L].getInt("CreateFractal_DegreeMin");
      CreateFractal_DegreeMax = children0[L].getInt("CreateFractal_DegreeMax");
      CreateFractal_Seed = children0[L].getInt("CreateFractal_Seed");
      CreateFractal_TrunkSize = children0[L].getFloat("CreateFractal_TrunkSize");
      CreateFractal_LeafSize = children0[L].getFloat("CreateFractal_LeafSize");
      Current_ObjectCategory = children0[L].getInt("Current_ObjectCategory");
      CreateInput_MeshOrSolid = children0[L].getInt("CreateInput_MeshOrSolid");
      WIN3D_UI_CurrentTask = children0[L].getInt("WIN3D_UI_CurrentTask");
      WIN3D_UI_OptionXorY = children0[L].getInt("WIN3D_UI_OptionXorY");
      WIN3D_UI_TaskModifyParameter = children0[L].getInt("WIN3D_UI_TaskModifyParameter");      

      Display_SWOB_Points = children0[L].getInt("Display_SWOB_Points");
      Display_SWOB_Nearest = children0[L].getInt("Display_SWOB_Nearest");
      Display_NAEFS_Points = children0[L].getInt("Display_NAEFS_Points");
      Display_NAEFS_Nearest = children0[L].getInt("Display_NAEFS_Nearest");
      Display_CWEEDS_Points = children0[L].getInt("Display_CWEEDS_Points");
      Display_CWEEDS_Nearest = children0[L].getInt("Display_CWEEDS_Nearest");
      Display_CLMREC_Points = children0[L].getInt("Display_CLMREC_Points");
      Display_CLMREC_Nearest = children0[L].getInt("Display_CLMREC_Nearest");      
      Display_TMYEPW_Points = children0[L].getInt("Display_TMYEPW_Points");
      Display_TMYEPW_Nearest = children0[L].getInt("Display_TMYEPW_Nearest");
      FRAME_record_AUTO = children0[L].getInt("FRAME_record_AUTO");
      FRAME_record_JPG = children0[L].getInt("FRAME_record_JPG");
      FRAME_click_JPG = children0[L].getInt("FRAME_click_JPG");
      FRAME_drag_JPG = children0[L].getInt("FRAME_drag_JPG");
      SolidImpact_record_PDF = children0[L].getInt("SolidImpact_record_PDF");
      SolidImpact_record_JPG = children0[L].getInt("SolidImpact_record_JPG");
      SolarImpact_record_JPG = children0[L].getInt("SolarImpact_record_JPG");

      RUN_AudioProduct = children0[L].getInt("RUN_AudioProduct");
      RUN_ExternalSimulation = children0[L].getInt("RUN_ExternalSimulation");
      RUN_ExternalHardware = children0[L].getInt("RUN_ExternalHardware");

      SolidImpact_WindSpeed = children0[L].getFloat("SolidImpact_WindSpeed"); 
      SolidImpact_WindDirection = children0[L].getFloat("SolidImpact_WindDirection");
      SolidImpact_Power = children0[L].getFloat("SolidImpact_Power");
      GlobalAlbedo = children0[L].getFloat("GlobalAlbedo");
      Interpolation_Weight = children0[L].getFloat("Interpolation_Weight");
      GLOBE_calculatedResolution = children0[L].getFloat("GLOBE_calculatedResolution");
      CLIMATIC_SolarForecast = children0[L].getInt("CLIMATIC_SolarForecast");
      CLIMATIC_WeatherForecast = children0[L].getInt("CLIMATIC_WeatherForecast");
      SOLARCHVISION_automated = children0[L].getInt("SOLARCHVISION_automated");

      TIME_ModelRun = children0[L].getInt("TIME_ModelRun"); 
      TIME_Year = children0[L].getInt("TIME_Year");
      TIME_Month = children0[L].getInt("TIME_Month");
      TIME_Day = children0[L].getInt("TIME_Day"); 
      TIME_Hour = children0[L].getInt("TIME_Hour"); 
      TIME_BeginDay = children0[L].getInt("TIME_BeginDay");
      TIME_Date = children0[L].getFloat("TIME_Date");

      LocationLAT_step = children0[L].getFloat("LocationLAT_step");
      LocationLON_step = children0[L].getFloat("LocationLON_step");
      LocationELE_step = children0[L].getFloat("LocationELE_step");


      STUDY_record_JPG = children0[L].getInt("STUDY_record_JPG");
      STUDY_record_PDF = children0[L].getInt("STUDY_record_PDF");
      STUDY_record_AUTO = children0[L].getInt("STUDY_record_AUTO");
      WORLD_record_JPG = children0[L].getInt("WORLD_record_JPG");
      WORLD_record_PDF = children0[L].getInt("WORLD_record_PDF");
      WORLD_record_AUTO = children0[L].getInt("WORLD_record_AUTO");
      WIN3D_record_JPG = children0[L].getInt("WIN3D_record_JPG");
      WIN3D_record_AUTO = children0[L].getInt("WIN3D_record_AUTO");
      STUDY_i_Start = children0[L].getInt("STUDY_i_Start");
      STUDY_i_End = children0[L].getInt("STUDY_i_End");
      //STUDY_j_Start = children0[L].getInt("STUDY_j_Start");
      STUDY_j_End = children0[L].getInt("STUDY_j_End");
      STUDY_max_j_end_parameters = children0[L].getInt("STUDY_max_j_end_parameters");
      STUDY_max_j_end_observations = children0[L].getInt("STUDY_max_j_end_observations");
      STUDY_PerDays = children0[L].getFloat("STUDY_PerDays");
      STUDY_JoinDays = children0[L].getInt("STUDY_JoinDays");
      CLIMATE_TMYEPW_start = children0[L].getInt("CLIMATE_TMYEPW_start");
      CLIMATE_TMYEPW_end = children0[L].getInt("CLIMATE_TMYEPW_end");
      CLIMATE_CWEEDS_start = children0[L].getInt("CLIMATE_CWEEDS_start");
      CLIMATE_CWEEDS_end = children0[L].getInt("CLIMATE_CWEEDS_end");
      CLIMATE_CLMREC_start = children0[L].getInt("CLIMATE_CLMREC_start");
      CLIMATE_CLMREC_end = children0[L].getInt("CLIMATE_CLMREC_end");
      FORECAST_ENSEMBLE_start = children0[L].getInt("FORECAST_ENSEMBLE_start");
      FORECAST_ENSEMBLE_end = children0[L].getInt("FORECAST_ENSEMBLE_end");
      numberOfNearestStations_FORECAST_ENSEMBLE = children0[L].getInt("numberOfNearestStations_FORECAST_ENSEMBLE");
      numberOfNearestStations_RECENT_OBSERVED = children0[L].getInt("numberOfNearestStations_RECENT_OBSERVED");
      RECENT_OBSERVED_start = children0[L].getInt("RECENT_OBSERVED_start");
      RECENT_OBSERVED_end = children0[L].getInt("RECENT_OBSERVED_end");
      SampleYear_Start = children0[L].getInt("SampleYear_Start");
      SampleYear_End = children0[L].getInt("SampleYear_End");
      SampleMember_Start = children0[L].getInt("SampleMember_Start");
      SampleMember_End = children0[L].getInt("SampleMember_End");
      SampleStation_Start = children0[L].getInt("SampleStation_Start");
      SampleStation_End = children0[L].getInt("SampleStation_End");
      LoadButton_CLIMATE_TMYEPW = children0[L].getInt("LoadButton_CLIMATE_TMYEPW");
      LoadButton_CLIMATE_CWEEDS = children0[L].getInt("LoadButton_CLIMATE_CWEEDS");
      LoadButton_CLIMATE_CLMREC = children0[L].getInt("LoadButton_CLIMATE_CLMREC");
      LoadButton_FORECAST_ENSEMBLE = children0[L].getInt("LoadButton_FORECAST_ENSEMBLE");
      LoadButton_RECENT_OBSERVED = children0[L].getInt("LoadButton_RECENT_OBSERVED");
      Download_RECENT_OBSERVED = children0[L].getInt("Download_RECENT_OBSERVED");
      Download_CLMREC = children0[L].getInt("Download_CLMREC");
      Download_FORECAST_ENSEMBLE = children0[L].getInt("Download_FORECAST_ENSEMBLE");
      Download_AERIAL = children0[L].getInt("Download_AERIAL");
      GRIB2_Month = children0[L].getInt("GRIB2_Month");
      GRIB2_Day = children0[L].getInt("GRIB2_Day");
      GRIB2_ModelRun = children0[L].getInt("GRIB2_ModelRun");
      AERIAL_num = children0[L].getInt("AERIAL_num");
      AERIAL_Center_Longitude = children0[L].getFloat("AERIAL_Center_Longitude");
      AERIAL_Center_Latitude = children0[L].getFloat("AERIAL_Center_Latitude");
      GRIB2_Hour_Start = children0[L].getInt("GRIB2_Hour_Start");
      GRIB2_Hour_End = children0[L].getInt("GRIB2_Hour_End");
      GRIB2_Hour_Step = children0[L].getInt("GRIB2_Hour_Step");
      GRIB2_Layer_Start = children0[L].getInt("GRIB2_Layer_Start");
      GRIB2_Layer_End = children0[L].getInt("GRIB2_Layer_End");
      GRIB2_Layer_Step = children0[L].getInt("GRIB2_Layer_Step");
      GRIB2_Hour = children0[L].getInt("GRIB2_Hour");
      GRIB2_Layer = children0[L].getInt("GRIB2_Layer");
      GRIB2_DomainSelection = children0[L].getInt("GRIB2_DomainSelection");
      GRIB2_TGL_number = children0[L].getInt("GRIB2_TGL_number");
      AERIAL_graphOption = children0[L].getInt("AERIAL_graphOption");
      H_Layer_Option = children0[L].getInt("H_Layer_Option");
      F_Layer_Option = children0[L].getInt("F_Layer_Option");
      O_Layer_Option = children0[L].getInt("O_Layer_Option");
      Develop_Option = children0[L].getInt("Develop_Option");
      Develop_DayHour = children0[L].getInt("Develop_DayHour");
      Update_DevelopData = children0[L].getInt("Update_DevelopData");
      num_Layers = children0[L].getInt("num_Layers");
      LAYER_windspd200hPa = children0[L].getInt("LAYER_windspd200hPa");
      LAYER_thicknesses_1000_500 = children0[L].getInt("LAYER_thicknesses_1000_500");
      LAYER_heightp500hPa = children0[L].getInt("LAYER_heightp500hPa");
      LAYER_ceilingsky = children0[L].getInt("LAYER_ceilingsky");
      LAYER_cloudcover = children0[L].getInt("LAYER_cloudcover");
      LAYER_winddir = children0[L].getInt("LAYER_winddir");
      LAYER_windspd = children0[L].getInt("LAYER_windspd");
      LAYER_pressure = children0[L].getInt("LAYER_pressure");
      LAYER_drybulb = children0[L].getInt("LAYER_drybulb");
      LAYER_relhum = children0[L].getInt("LAYER_relhum");
      LAYER_dirnorrad = children0[L].getInt("LAYER_dirnorrad");
      LAYER_difhorrad = children0[L].getInt("LAYER_difhorrad");
      LAYER_glohorrad = children0[L].getInt("LAYER_glohorrad");
      LAYER_direffect = children0[L].getInt("LAYER_direffect");
      LAYER_difeffect = children0[L].getInt("LAYER_difeffect");
      LAYER_precipitation_A = children0[L].getInt("LAYER_precipitation_A");
      LAYER_developed = children0[L].getInt("LAYER_developed");
      Develop_AngleInclination = children0[L].getFloat("Develop_AngleInclination");
      Develop_AngleOrientation = children0[L].getFloat("Develop_AngleOrientation");
      STUDY_CurrentLayer = children0[L].getInt("STUDY_CurrentLayer");
      STUDY_DevelopLayer = children0[L].getInt("STUDY_DevelopLayer");
      STUDY_PrintTtitle = children0[L].getInt("STUDY_PrintTtitle");
      STUDY_T_scale = children0[L].getFloat("STUDY_T_scale");
      STUDY_U_scale = children0[L].getFloat("STUDY_U_scale");
      STUDY_skyScenario_Active = children0[L].getInt("STUDY_skyScenario_Active");
      FILTER_Hourly = children0[L].getInt("FILTER_Hourly");
      FILTER_Daily = children0[L].getInt("FILTER_Daily");
      FILTER_Active = children0[L].getInt("FILTER_Active");
      STUDY_TrendJoinHours = children0[L].getInt("STUDY_TrendJoinHours");
      STUDY_TrendJoinType = children0[L].getInt("STUDY_TrendJoinType");
      TIME_Interval = children0[L].getInt("TIME_Interval");
      Export_STUDY_info_node = children0[L].getInt("Export_STUDY_info_node");
      Export_STUDY_info_norm = children0[L].getInt("Export_STUDY_info_norm");
      Export_STUDY_info_prob = children0[L].getInt("Export_STUDY_info_prob");
      STUDY_Pallet_SORT_CLR = children0[L].getInt("STUDY_Pallet_SORT_CLR");
      STUDY_Pallet_SORT_DIR = children0[L].getInt("STUDY_Pallet_SORT_DIR");
      STUDY_Pallet_SORT_MLT = children0[L].getFloat("STUDY_Pallet_SORT_MLT");
      STUDY_Pallet_PROB_CLR = children0[L].getInt("STUDY_Pallet_PROB_CLR");
      STUDY_Pallet_PROB_DIR = children0[L].getInt("STUDY_Pallet_PROB_DIR");
      STUDY_Pallet_PROB_MLT = children0[L].getFloat("STUDY_Pallet_PROB_MLT");
      STUDY_Pallet_ACTIVE_CLR = children0[L].getInt("STUDY_Pallet_ACTIVE_CLR");
      STUDY_Pallet_ACTIVE_DIR = children0[L].getInt("STUDY_Pallet_ACTIVE_DIR");
      STUDY_Pallet_ACTIVE_MLT = children0[L].getFloat("STUDY_Pallet_ACTIVE_MLT");
      STUDY_Pallet_PASSIVE_CLR = children0[L].getInt("STUDY_Pallet_PASSIVE_CLR");
      STUDY_Pallet_PASSIVE_DIR = children0[L].getInt("STUDY_Pallet_PASSIVE_DIR");
      STUDY_Pallet_PASSIVE_MLT = children0[L].getFloat("STUDY_Pallet_PASSIVE_MLT");
      OBJECTS_Pallet_ACTIVE_CLR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_CLR");
      OBJECTS_Pallet_ACTIVE_DIR = children0[L].getInt("OBJECTS_Pallet_ACTIVE_DIR");
      OBJECTS_Pallet_ACTIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_ACTIVE_MLT");
      OBJECTS_Pallet_PASSIVE_CLR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_CLR");
      OBJECTS_Pallet_PASSIVE_DIR = children0[L].getInt("OBJECTS_Pallet_PASSIVE_DIR");
      OBJECTS_Pallet_PASSIVE_MLT = children0[L].getFloat("OBJECTS_Pallet_PASSIVE_MLT");
      SunPath3D_Pallet_ACTIVE_CLR = children0[L].getInt("SunPath3D_Pallet_ACTIVE_CLR");
      SunPath3D_Pallet_ACTIVE_DIR = children0[L].getInt("SunPath3D_Pallet_ACTIVE_DIR");
      SunPath3D_Pallet_ACTIVE_MLT = children0[L].getFloat("SunPath3D_Pallet_ACTIVE_MLT");
      SunPath3D_Pallet_PASSIVE_CLR = children0[L].getInt("SunPath3D_Pallet_PASSIVE_CLR");
      SunPath3D_Pallet_PASSIVE_DIR = children0[L].getInt("SunPath3D_Pallet_PASSIVE_DIR");
      SunPath3D_Pallet_PASSIVE_MLT = children0[L].getFloat("SunPath3D_Pallet_PASSIVE_MLT");
      SKY3D_Pallet_ACTIVE_CLR = children0[L].getInt("SKY3D_Pallet_ACTIVE_CLR");
      SKY3D_Pallet_ACTIVE_DIR = children0[L].getInt("SKY3D_Pallet_ACTIVE_DIR");
      SKY3D_Pallet_ACTIVE_MLT = children0[L].getFloat("SKY3D_Pallet_ACTIVE_MLT");
      SKY3D_Pallet_PASSIVE_CLR = children0[L].getInt("SKY3D_Pallet_PASSIVE_CLR");
      SKY3D_Pallet_PASSIVE_DIR = children0[L].getInt("SKY3D_Pallet_PASSIVE_DIR");
      SKY3D_Pallet_PASSIVE_MLT = children0[L].getFloat("SKY3D_Pallet_PASSIVE_MLT");
      ELEVATION_Pallet_CLR = children0[L].getInt("ELEVATION_Pallet_CLR");
      ELEVATION_Pallet_DIR = children0[L].getInt("ELEVATION_Pallet_DIR");
      ELEVATION_Pallet_MLT = children0[L].getFloat("ELEVATION_Pallet_MLT");
      SOLID_Pallet_CLR = children0[L].getInt("SOLID_Pallet_CLR");
      SOLID_Pallet_DIR = children0[L].getInt("SOLID_Pallet_DIR");
      SOLID_Pallet_MLT = children0[L].getFloat("SOLID_Pallet_MLT");
      WindFlow_Pallet_CLR = children0[L].getInt("WindFlow_Pallet_CLR");
      WindFlow_Pallet_DIR = children0[L].getInt("WindFlow_Pallet_DIR");
      WindFlow_Pallet_MLT = children0[L].getFloat("WindFlow_Pallet_MLT");
      Impact_ACTIVE = children0[L].getInt("Impact_ACTIVE");
      Impact_PASSIVE = children0[L].getInt("Impact_PASSIVE");
      Impact_WIND_Overlay = children0[L].getInt("Impact_WIND_Overlay");
      Impact_WIND_Temperature = children0[L].getInt("Impact_WIND_Temperature");
      Impact_TYPE = children0[L].getInt("Impact_TYPE");
      STUDY_O_scale = children0[L].getFloat("STUDY_O_scale");
      STUDY_W_scale = children0[L].getFloat("STUDY_W_scale");
      COLOR_STYLE_Active = children0[L].getInt("COLOR_STYLE_Active");
      COLOR_STYLE_Number = children0[L].getInt("COLOR_STYLE_Number");
      STUDY_rect_scale = children0[L].getFloat("STUDY_rect_scale");
      STUDY_rect_offset_x = children0[L].getFloat("STUDY_rect_offset_x");
      databaseNumber_RECENT_OBSERVED = children0[L].getInt("databaseNumber_RECENT_OBSERVED");
      databaseNumber_FORECAST_ENSEMBLE = children0[L].getInt("databaseNumber_FORECAST_ENSEMBLE");
      databaseNumber_CLIMATE_CWEEDS = children0[L].getInt("databaseNumber_CLIMATE_CWEEDS");
      databaseNumber_CLIMATE_CLMREC = children0[L].getInt("databaseNumber_CLIMATE_CLMREC");
      databaseNumber_CLIMATE_TMYEPW = children0[L].getInt("databaseNumber_CLIMATE_TMYEPW");
      IMPACTS_DataSource = children0[L].getInt("IMPACTS_DataSource");
      STUDY_impact_summary = children0[L].getInt("STUDY_impact_summary");
      STUDY_ImpactLayer = children0[L].getInt("STUDY_ImpactLayer");
      STUDY_PlotImpacts = children0[L].getInt("STUDY_PlotImpacts");
      STUDY_Impacts_Update = children0[L].getInt("STUDY_Impacts_Update");
      DrawnFrame = children0[L].getInt("DrawnFrame");

      LAND_TESSELLATION = children0[L].getInt("LAND_TESSELLATION");
      MODEL3D_Tessellation = children0[L].getInt("MODEL3D_Tessellation");
      SKY3D_TESSELLATION = children0[L].getInt("SKY3D_TESSELLATION");
      SKY3D_scale = children0[L].getFloat("SKY3D_scale");
      WindRose3D_scale = children0[L].getFloat("WindRose3D_scale");

      Planetary_Magnification = children0[L].getFloat("Planetary_Magnification");
      Display_SolarRotation = children0[L].getInt("Display_SolarRotation");      
      Display_SUN3D_Path = children0[L].getInt("Display_SUN3D_Path");
      Display_SUN3D_Pattern = children0[L].getInt("Display_SUN3D_Pattern");
      Display_SKY3D = children0[L].getInt("Display_SKY3D");
      Display_STAR3D_Surface = children0[L].getInt("Display_STAR3D_Surface");
      Display_STAR3D_Texture = children0[L].getInt("Display_STAR3D_Texture");            
      Display_MOON3D_Surface = children0[L].getInt("Display_MOON3D_Surface");
      Display_MOON3D_Texture = children0[L].getInt("Display_MOON3D_Texture");
      Display_TROPO3D_Surface = children0[L].getInt("Display_TROPO3D_Surface");
      Display_TROPO3D_Texture = children0[L].getInt("Display_TROPO3D_Texture");
      Display_EARTH3D_Surface = children0[L].getInt("Display_EARTH3D_Surface");
      Display_EARTH3D_Texture = children0[L].getInt("Display_EARTH3D_Texture");
      Download_LAND_MESH = children0[L].getInt("Download_LAND_MESH");
      LoadButton_LandMesh = children0[L].getInt("LoadButton_LandMesh");
      Display_LAND_MESH = children0[L].getInt("Display_LAND_MESH");
      Display_LAND_POINTS = children0[L].getInt("Display_LAND_POINTS");
      Display_LAND_Texture = children0[L].getInt("Display_LAND_Texture");
      Display_LAND_DEPTH = children0[L].getInt("Display_LAND_DEPTH");
      Skip_LAND_MESH_Center = children0[L].getInt("Skip_LAND_MESH_Center");
      LoadButton_UrbanMesh = children0[L].getInt("LoadButton_UrbanMesh");
      Display_URBAN_MESH = children0[L].getInt("Display_URBAN_MESH");
      Display_SolidImpact_Points = children0[L].getInt("Display_SolidImpact_Points");
      Display_SolidImpact_Lines = children0[L].getInt("Display_SolidImpact_Lines");
      MODEL3D_DisplayEdges = children0[L].getInt("MODEL3D_DisplayEdges");
      MODEL3D_DisplayNormals = children0[L].getInt("MODEL3D_DisplayNormals");
      Display_WindFlow = children0[L].getInt("Display_WindFlow");
      Camera_Variation = children0[L].getInt("Camera_Variation");
      STUDY_DisplayRaws = children0[L].getInt("STUDY_DisplayRaws");
      STUDY_DisplaySorted = children0[L].getInt("STUDY_DisplaySorted");
      STUDY_DisplayNormals = children0[L].getInt("STUDY_DisplayNormals");
      STUDY_DisplayProbs = children0[L].getInt("STUDY_DisplayProbs");
      STUDY_SumInterval = children0[L].getInt("STUDY_SumInterval");
      STUDY_LevelPix = children0[L].getFloat("STUDY_LevelPix");
      STUDY_Pix = children0[L].getFloat("STUDY_Pix");
      STUDY_Setup = children0[L].getInt("STUDY_Setup");
      Materials_Selection = children0[L].getInt("Materials_Selection");
      Shade_Surface_Wire = children0[L].getInt("Shade_Surface_Wire");
      Shade_Surface_Base = children0[L].getInt("Shade_Surface_Base");
      Shade_Surface_White = children0[L].getInt("Shade_Surface_White");
      Shade_Surface_Materials = children0[L].getInt("Shade_Surface_Materials");
      Shade_Global_Solar = children0[L].getInt("Shade_Global_Solar");
      Shade_Vertex_Solar = children0[L].getInt("Shade_Vertex_Solar");
      Shade_Vertex_Solid = children0[L].getInt("Shade_Vertex_Solid");
      Shade_Vertex_Elevation = children0[L].getInt("Shade_Vertex_Elevation");
      WIN3D_CAM_x = children0[L].getFloat("WIN3D_CAM_x");
      WIN3D_CAM_y = children0[L].getFloat("WIN3D_CAM_y");
      WIN3D_CAM_z = children0[L].getFloat("WIN3D_CAM_z");
      WIN3D_CAM_fov = children0[L].getFloat("WIN3D_CAM_fov");
      WIN3D_CAM_dist = children0[L].getFloat("WIN3D_CAM_dist");
      WIN3D_CAM_clipNear = children0[L].getFloat("WIN3D_CAM_clipNear");
      WIN3D_CAM_clipFar = children0[L].getFloat("WIN3D_CAM_clipFar");
      WIN3D_CurrentCamera = children0[L].getInt("WIN3D_CurrentCamera");
      OBJECTS_scale = children0[L].getFloat("OBJECTS_scale");
      WIN3D_refScale = children0[L].getFloat("WIN3D_refScale");
      WIN3D_X_Coordinate = children0[L].getFloat("WIN3D_X_Coordinate");
      WIN3D_Y_Coordinate = children0[L].getFloat("WIN3D_Y_Coordinate");
      WIN3D_Z_Coordinate = children0[L].getFloat("WIN3D_Z_Coordinate");
      WIN3D_S_Coordinate = children0[L].getFloat("WIN3D_S_Coordinate");
      WIN3D_RX_Coordinate = children0[L].getFloat("WIN3D_RX_Coordinate");
      WIN3D_RY_Coordinate = children0[L].getFloat("WIN3D_RY_Coordinate");
      WIN3D_RZ_Coordinate = children0[L].getFloat("WIN3D_RZ_Coordinate");
      WIN3D_RS_Coordinate = children0[L].getFloat("WIN3D_RS_Coordinate");
      WIN3D_Zoom = children0[L].getFloat("WIN3D_Zoom");
      WIN3D_ViewType = children0[L].getInt("WIN3D_ViewType");
      WIN3D_FacesShade = children0[L].getInt("WIN3D_FacesShade");

      selected_posVector = children0[L].getInt("selected_posVector");
      selected_rotVector = children0[L].getInt("selected_rotVector");
      selected_scaleVector = children0[L].getInt("selected_scaleVector");
      selected_posValue = children0[L].getFloat("selected_posValue");
      selected_rotValue = children0[L].getFloat("selected_rotValue");
      selected_scaleValue = children0[L].getFloat("selected_scaleValue");
      selection_alignX = children0[L].getInt("selection_alignX");
      selection_alignY = children0[L].getInt("selection_alignY");
      selection_alignZ = children0[L].getInt("selection_alignZ");

      selected_displayReferencePivot = children0[L].getInt("selected_displayReferencePivot");
      selectedGroup3D_displayPivot = children0[L].getInt("selectedGroup3D_displayPivot");
      selectedGroup3D_displayEdges = children0[L].getInt("selectedGroup3D_displayEdges");
      selectedGroup3D_displayBox = children0[L].getInt("selectedGroup3D_displayBox");
      selectedFace_displayEdges = children0[L].getInt("selectedFace_displayEdges");
      selectedFace_displayVertexCount = children0[L].getInt("selectedFace_displayVertexCount");
      selectedVertex_displayVertices = children0[L].getInt("selectedVertex_displayVertices");      
      selectedObject2D_displayEdges = children0[L].getInt("selectedObject2D_displayEdges");
      selectedFractal_displayEdges = children0[L].getInt("selectedFractal_displayEdges");
      selectedSolid_displayEdges = children0[L].getInt("selectedSolid_displayEdges");
      selectedSection_displayEdges = children0[L].getInt("selectedSection_displayEdges");
      selectedCamera_displayEdges = children0[L].getInt("selectedCamera_displayEdges");
      selectedLandPoint_displayPoints = children0[L].getInt("selectedLandPoint_displayPoints");

      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");

      WORLD_Viewport_ZOOM = children0[L].getInt("WORLD_Viewport_ZOOM");
      FrameVariation = children0[L].getInt("FrameVariation");
      Language_Active = children0[L].getInt("Language_Active");

      IMPACTS_DisplayDay = children0[L].getInt("IMPACTS_DisplayDay");
      Display_WindRoseImage = children0[L].getInt("Display_WindRoseImage");
      WindRose_RES = children0[L].getInt("WindRose_RES");
      Rendered_WindRose_RES = children0[L].getInt("Rendered_WindRose_RES");
      Display_SolarImpactImage = children0[L].getInt("Display_SolarImpactImage");
      SolarImpact_sectionType = children0[L].getInt("SolarImpact_sectionType");
      SolarImpact_Rotation = children0[L].getFloat("SolarImpact_Rotation");
      SolarImpact_scale_U = children0[L].getFloat("SolarImpact_scale_U");
      SolarImpact_scale_V = children0[L].getFloat("SolarImpact_scale_V");
      SolarImpact_offset_U = children0[L].getFloat("SolarImpact_offset_U");
      SolarImpact_offset_V = children0[L].getFloat("SolarImpact_offset_V");      
      SolarImpact_RES1 = children0[L].getInt("SolarImpact_RES1");
      SolarImpact_RES2 = children0[L].getInt("SolarImpact_RES2");
      SolarImpact_Elevation = children0[L].getFloat("SolarImpact_Elevation");
      SolidImpact_RES1 = children0[L].getInt("SolidImpact_RES1");
      SolidImpact_RES2 = children0[L].getInt("SolidImpact_RES2");
      SolidImpact_Grade = children0[L].getFloat("SolidImpact_Grade");
      Display_SolidImpactImage = children0[L].getInt("Display_SolidImpactImage");
      SolidImpact_sectionType = children0[L].getInt("SolidImpact_sectionType");
      SolidImpact_positionStep = children0[L].getFloat("SolidImpact_positionStep");
      Process_subDivisions = children0[L].getInt("Process_subDivisions");
      deltaSolidImpactStep = children0[L].getFloat("deltaSolidImpactStep");
      deltaSolidImpactLines = children0[L].getFloat("deltaSolidImpactLines");
      MinimumDistance_traceU = children0[L].getFloat("MinimumDistance_traceU");
      MinimumDistance_traceV = children0[L].getFloat("MinimumDistance_traceV");
      SOLARCHVISION_GLOBE_stp_slp = children0[L].getFloat("SOLARCHVISION_GLOBE_stp_slp");
      SOLARCHVISION_GLOBE_stp_dir = children0[L].getFloat("SOLARCHVISION_GLOBE_stp_dir");
      SOLARCHVISION_GLOBE_n_slp = children0[L].getInt("SOLARCHVISION_GLOBE_n_slp");
      SOLARCHVISION_GLOBE_n_dir = children0[L].getInt("SOLARCHVISION_GLOBE_n_dir");
      LAND_n_I_base = children0[L].getInt("LAND_n_I_base");
      LAND_n_J_base = children0[L].getInt("LAND_n_J_base");
      LAND_n_I = children0[L].getInt("LAND_n_I");
      LAND_n_J = children0[L].getInt("LAND_n_J");
      LAND_mid_lat = Double.parseDouble(children0[L].getString("LAND_mid_lat"));
      LAND_mid_lon = Double.parseDouble(children0[L].getString("LAND_mid_lon"));
      Object2D_PEOPLE_Files_Num = children0[L].getInt("Object2D_PEOPLE_Files_Num");
      Object2D_TREES_Files_Num = children0[L].getInt("Object2D_TREES_Files_Num");
      softSelection_Power = children0[L].getFloat("softSelection_Power");
      softSelection_Radius = children0[L].getFloat("softSelection_Radius");

      addToLastGroup3D = children0[L].getInt("addToLastGroup3D");      

      BIOSPHERE_drawResolution = children0[L].getFloat("BIOSPHERE_drawResolution");

      objExport_Scale = children0[L].getFloat("objExport_Scale");
      objExport_FlipZYaxis = children0[L].getInt("objExport_FlipZYaxis");
      objExport_PrecisionVertex = children0[L].getInt("objExport_PrecisionVertex");
      objExport_PrecisionVtexture = children0[L].getInt("objExport_PrecisionVtexture");
      objExport_PolyToPoly = children0[L].getInt("objExport_PolyToPoly");
      objExport_MaterialLibrary  = children0[L].getInt("objExport_MaterialLibrary");
      objExport_BackSides = children0[L].getInt("objExport_BackSides");
      objExport_CombinedMaterial = children0[L].getInt("objExport_CombinedMaterial");      
      objExport_BakingResolution = children0[L].getInt("objExport_BakingResolution");
      objExport_PalletResolution = children0[L].getInt("objExport_PalletResolution");
      objExport_UsePalletOrBakeFaces = children0[L].getInt("objExport_UsePalletOrBakeFaces");


      {
        String new_Default_Font = children0[L].getString("Default_Font");
        if (Default_Font.equals(new_Default_Font)) {
        } else {
          Default_Font = new_Default_Font;        
          SOLARCHVISION_LoadDefaultFontStyle();
        }
      } 

      LAND_n_I_base = children0[L].getInt("LAND_n_I_base");
      LAND_n_J_base = children0[L].getInt("LAND_n_J_base");
      LAND_n_I = children0[L].getInt("LAND_n_I");
      LAND_n_J = children0[L].getInt("LAND_n_J");


      int pre_LAND_Texture_num = LAND_Texture_num;
      LAND_Texture_num = children0[L].getInt("LAND_Texture_num");

      if (pre_LAND_Texture_num != LAND_Texture_num) {

        int ni = 1 + LAND_Texture_num;

        LAND_Texture_ImagePath = new String [ni];
        LAND_Texture_Map = new PImage [ni];

        for (int i = 0; i < ni; i++) {

          LAND_Texture_ImagePath[i] = "";
          LAND_Texture_Map[i] = createImage(2, 2, RGB);
        }
      }
    }

    children0 = FileAll.getChildren("LAND_Texture_ImagePath");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {

        String new_Texture_path = parts[i];

        if (LAND_Texture_ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        } else {

          LAND_Texture_ImagePath[i] = new_Texture_path;

          if (LAND_Texture_ImagePath[i].equals("")) {
          } else {
            println("Loading texture:", LAND_Texture_ImagePath[i]);
            LAND_Texture_Map[i] = loadImage(LAND_Texture_ImagePath[i]);
          }
        }
      }
    }

    children0 = FileAll.getChildren("LAND_Texture_scale_U");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAND_Texture_scale_U = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAND_Texture_scale_U[i] = float(parts[i]);
      }
    }

    children0 = FileAll.getChildren("LAND_Texture_scale_V");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAND_Texture_scale_V = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAND_Texture_scale_V[i] = float(parts[i]);
      }
    }


    {
      children0 = FileAll.getChildren("Object2D_ImagePath");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");

        int reload_All_textures = 0;

        if (Object2D_ImagePath.length != ni) {
          Object2D_Images = new PImage [ni];
          Object2D_ImageRatios = new float [ni];

          reload_All_textures = 1;
        }

        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      

          String new_Texture_path = children1[i].getContent();
          if ((reload_All_textures == 0) && (Object2D_ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase()))) {
          } else {
            Object2D_ImagePath[i] = new_Texture_path;
            Object2D_Images[i] = createImage(2, 2, RGB);
            if (Object2D_ImagePath[i].equals("")) {
            } else {
              println("Loading texture(" + i + "):", Object2D_ImagePath[i]);
              Object2D_Images[i] = loadImage(Object2D_ImagePath[i]);
              println("loaded!");

              if (Object2D_Images[i].height != 0) {
                Object2D_ImageRatios[i] = float(Object2D_Images[i].width) / float(Object2D_Images[i].height);
              } else {
                Object2D_ImageRatios[i] = 1;
              }
            }
          }
        }
      }
    }


    {
      children0 = FileAll.getChildren("allSections_SolidImpact");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");

        allSections_SolidImpact = new PImage [ni];

        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      

          String TEXTURE_path = children1[i].getContent();

          allSections_SolidImpact[i] = createImage(2, 2, RGB);

          println("Loading texture(" + i + "):", TEXTURE_path);
          allSections_SolidImpact[i] = loadImage(TEXTURE_path);
          println("loaded!");
        }
      }
    }

    {
      children0 = FileAll.getChildren("allSections_SolarImpact");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        int nj = children0[L].getInt("nj");

        allSections_SolarImpact = new PImage [ni][nj]; 

        XML[] children1 = children0[L].getChildren("Path");         
        for (int i = 0; i < ni; i++) {      
          for (int j = 0; j < nj; j++) {

            String TEXTURE_path = children1[i * nj + j].getContent();

            allSections_SolarImpact[i][j] = createImage(2, 2, RGB);

            println("Loading texture(" + i + "," + j + "):", TEXTURE_path);
            allSections_SolarImpact[i][j] = loadImage(TEXTURE_path);
            println("loaded!");
          }
        }
      }
    }

    println("Loading:STATION");
    children0 = FileAll.getChildren("DEFINED_STATION");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      XML[] children1 = children0[L].getChildren("Property");         

      STATION_Number = 0; // <<<<<<<<<< overwrite station 0

        for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();

        Defined_Stations[STATION_Number][i] = lineSTR;
      }

      SOLARCHVISION_UI_BAR_a_Items[N_Site_in_Bar_a][1] = Defined_Stations[STATION_Number][0]; // <<<<<<<<
    }

    println("Loading:LAND_MESH");
    LAND_MESH = new float [LAND_n_I][LAND_n_J][3];
    children0 = FileAll.getChildren("LAND_MESH");
    for (int L = 0; L < children0.length; L++) {
      XML[] children1 = children0[L].getChildren("Vertice");         
      for (int i = 0; i < LAND_n_I * LAND_n_J; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          LAND_MESH[(i / LAND_n_J)][(i % LAND_n_J)][j] = float(parts[j]);
        }
      }
    }

    println("Loading:Cameras");
    children0 = FileAll.getChildren("allCameras");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      allCameras_PPPSRRRF = new float [ni][8];
      allCameras_Type = new int [ni];

      allCameras_num = ni - 1;

      XML[] children1 = children0[L].getChildren("Camera");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 8; j++) {
          allCameras_PPPSRRRF[i][j] = float(parts[j]);
        }

        allCameras_Type[i] = int(parts[8]);
      }
    } 

    println("Loading:Sections");
    children0 = FileAll.getChildren("allSections");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      allSections_UVERAB = new float [ni][6];
      allSections_Type = new int [ni];
      allSections_RES1 = new int [ni];
      allSections_RES2 = new int [ni];
      allSections_num = ni - 1;

      XML[] children1 = children0[L].getChildren("Section");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 6; j++) {
          allSections_UVERAB[i][j] = float(parts[j]);
        }

        allSections_Type[i] = int(parts[6]);
        allSections_RES1[i] = int(parts[7]);
        allSections_RES2[i] = int(parts[8]);
      }
    } 

    println("Loading:Solids");
    children0 = FileAll.getChildren("allSolids_DEF");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      allSolids_DEF = new float [ni][13];

      XML[] children1 = children0[L].getChildren("Solid");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 13; j++) {
          allSolids_DEF[i][j] = float(parts[j]);
        }
      }
    } 

    println("Loading:Fractals");
    children0 = FileAll.getChildren("allFractals");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      allFractals_XYZSR = new float [ni][5];
      allFractals_Type = new int [ni];
      allFractals_DegreeMin = new int [ni];
      allFractals_DegreeMax = new int [ni];
      allFractals_Seed = new int [ni];
      allFractals_TrunkSize = new float [ni];
      allFractals_LeafSize = new float [ni];
      allFractals_num = ni - 1;

      XML[] children1 = children0[L].getChildren("Fractal");         
      for (int i = 0; i < ni; i++) {

        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 5; j++) {
          allFractals_XYZSR[i][j] = float(parts[j]);
        }

        allFractals_Type[i] = int(parts[5]);
        allFractals_DegreeMin[i] = int(parts[6]);
        allFractals_DegreeMax[i] = int(parts[7]);
        allFractals_Seed[i] = int(parts[8]);
        allFractals_TrunkSize[i] = float(parts[9]);
        allFractals_LeafSize[i] = float(parts[10]);
      }
    }       

    println("Loading:Object2Ds");
    children0 = FileAll.getChildren("allObject2Ds");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");

      allObject2Ds_XYZS = new float [ni][4];
      allObject2Ds_MAP = new int [ni];
      allObject2Ds_num = ni - 1;

      XML[] children1 = children0[L].getChildren("Object2D");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 4; j++) {
          allObject2Ds_XYZS[i][j] = float(parts[j]);
        }
        allObject2Ds_MAP[i] = int(parts[4]);
      }
    }      

    println("Loading:Vertices");
    children0 = FileAll.getChildren("allVertices");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      allVertices = new float [ni][3];
      XML[] children1 = children0[L].getChildren("Vertice");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children1[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          allVertices[i][j] = float(parts[j]);
        }
      }
    }  

    println("Loading:Faces");
    {
      children0 = FileAll.getChildren("allFaces_PNT");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allFaces_PNT = new int [0][0];
        XML[] children1 = children0[L].getChildren("Face");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          int nj = parts.length;
          int[][] newFace = new int [1][nj];
          for (int j = 0; j < nj; j++) {
            newFace[0][j] = int(parts[j]);
          }
          allFaces_PNT = (int[][]) concat(allFaces_PNT, newFace);
        }
      }   

      children0 = FileAll.getChildren("allFaces_MTLV");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allFaces_MTLV = new int [ni][4];
        XML[] children1 = children0[L].getChildren("Face_MTLV"); 
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allFaces_MTLV[i][j] = int(parts[j]);
          }
        }
      }
    }



    println("Loading:Group3Ds");
    {
      children0 = FileAll.getChildren("allGroup3Ds_PivotXYZ");
      for (int L = 0; L < children0.length; L++) {

        int ni = children0[L].getInt("ni");

        allGroup3Ds_num = ni - 1;

        allGroup3Ds_PivotXYZ = new float [ni][9];

        XML[] children1 = children0[L].getChildren("PivotXYZ");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < 9; j++) {
            allGroup3Ds_PivotXYZ[i][j] = float(parts[j]);
          }
        }
      }  


      children0 = FileAll.getChildren("allGroup3Ds_PivotType");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");

        allGroup3Ds_PivotType = new int [ni][1];

        XML[] children1 = children0[L].getChildren("PivotType");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < 1; j++) {
            allGroup3Ds_PivotType[i][j] = int(parts[j]);
          }
        }
      }          

      children0 = FileAll.getChildren("allGroup3Ds_Faces");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allGroup3Ds_Faces = new int [ni][2];
        XML[] children1 = children0[L].getChildren("Faces");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroup3Ds_Faces[i][j] = int(parts[j]);
          }
        }
      }     

      children0 = FileAll.getChildren("allGroup3Ds_Solids");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allGroup3Ds_Solids = new int [ni][2];
        XML[] children1 = children0[L].getChildren("Solids");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroup3Ds_Solids[i][j] = int(parts[j]);
          }
        }
      } 

      children0 = FileAll.getChildren("allGroup3Ds_Object2Ds");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allGroup3Ds_Object2Ds = new int [ni][2];
        XML[] children1 = children0[L].getChildren("Object2Ds");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroup3Ds_Object2Ds[i][j] = int(parts[j]);
          }
        }
      } 

      children0 = FileAll.getChildren("allGroup3Ds_Fractals");
      for (int L = 0; L < children0.length; L++) {
        int ni = children0[L].getInt("ni");
        allGroup3Ds_Fractals = new int [ni][2];
        XML[] children1 = children0[L].getChildren("Fractals");         
        for (int i = 0; i < ni; i++) {
          String lineSTR = children1[i].getContent();
          String[] parts = split(lineSTR, ',');
          for (int j = 0; j < parts.length; j++) {
            allGroup3Ds_Fractals[i][j] = int(parts[j]);
          }
        }
      }
    }


    children0 = FileAll.getChildren("selectedLandPoint_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedLandPoint_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedLandPoint_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedFractal_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedFractal_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedFractal_numbers[i] = int(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("selectedObject2D_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedObject2D_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedObject2D_numbers[i] = int(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("selectedGroup3D_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedGroup3D_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedGroup3D_numbers[i] = int(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("selectedFace_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedFace_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedFace_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedVertex_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedVertex_softSelectionVertices");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_softSelectionVertices = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionVertices[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedVertex_softSelectionValues");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedVertex_softSelectionValues = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedVertex_softSelectionValues[i] = float(parts[i]);
      }
    }


    children0 = FileAll.getChildren("selectedSolid_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedSolid_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedSolid_numbers[i] = int(parts[i]);
      }
    }


    children0 = FileAll.getChildren("selectedSection_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedSection_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedSection_numbers[i] = int(parts[i]);
      }
    }

    children0 = FileAll.getChildren("selectedCamera_numbers");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      selectedCamera_numbers = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        selectedCamera_numbers[i] = int(parts[i]);
      }
    }



    children0 = FileAll.getChildren("SolidImpact_Elevation");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_Elevation = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_Elevation[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SolidImpact_Rotation");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_Rotation = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_Rotation[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SolidImpact_scale_U");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_scale_U = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_scale_U[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SolidImpact_scale_V");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_scale_V = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_scale_V[i] = float(parts[i]);
      }
    }     

    children0 = FileAll.getChildren("SolidImpact_offset_U");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_offset_U = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_offset_U[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("SolidImpact_offset_V");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      SolidImpact_offset_V = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        SolidImpact_offset_V[i] = float(parts[i]);
      }
    }         

    children0 = FileAll.getChildren("STUDY_V_scale");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_scale = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_scale[i] = float(parts[i]);
      }
    } 

    children0 = FileAll.getChildren("STUDY_V_offset");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_offset = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_offset[i] = float(parts[i]);
      }
    }     

    children0 = FileAll.getChildren("STUDY_V_belowLine");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      STUDY_V_belowLine = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        STUDY_V_belowLine[i] = float(parts[i]);
      }
    } 


    children0 = FileAll.getChildren("LAYERS_Unit");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_Unit = new String [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_Unit[i] = parts[i];
      }
    }

    children0 = FileAll.getChildren("LAYERS_Text");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_Text = new String [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_Text[i] = parts[i];
      }
    }

    children0 = FileAll.getChildren("LAYERS_GRIB2_MUL");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_GRIB2_MUL = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_GRIB2_MUL[i] = float(parts[i]);
      }
    }

    children0 = FileAll.getChildren("LAYERS_GRIB2_ADD");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      LAYERS_GRIB2_ADD = new float [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        LAYERS_GRIB2_ADD[i] = float(parts[i]);
      }
    }

    children0 = FileAll.getChildren("GRIB2_TGL_Selected");
    for (int L = 0; L < children0.length; L++) {
      int ni = children0[L].getInt("ni");
      GRIB2_TGL_Selected = new int [ni];
      String lineSTR = children0[L].getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        GRIB2_TGL_Selected[i] = int(parts[i]);
      }
    }
  }
  println("End of loading project.");


  // loading only weather data // 
  SOLARCHVISION_update_station(2); 
  SOLARCHVISION_update_station(3);
  SOLARCHVISION_update_station(4);
  SOLARCHVISION_update_station(5);
  ///////////////////////////////

  addNewSelectionToPreviousSelection = 0;

  SOLARCHVISION_UI_set_to_Create_Nothing();

  WORLD_AutoView = 1;

  WORLD_VIEW_Number = WORLD_FindGoodViewport(LocationLongitude, LocationLatitude);

  SOLARCHVISION_update_frame_layout();

  ROLLOUT_Update = 1;
  WORLD_Update = 1;
  WIN3D_Update = 1; 
  STUDY_Update = 1;     
  SOLARCHVISION_UI_BAR_a_Update = 1; 
  SOLARCHVISION_UI_BAR_b_Update = 1;
  SOLARCHVISION_UI_BAR_d_Update = 1;

  rebuild_SolarProjection_array = 1;
  rebuild_SolarImpactImage_array = 1;
  rebuild_WindRoseImage_array = 1; 

  SOLARCHVISION_calculate_SolidImpact_selectedSections();

  SOLARCHVISION_modify_Viewport_Title();
}







void Solid_updatePosition (int n, float a, float b, float c) {

  allSolids_DEF[n][0] = a;
  allSolids_DEF[n][1] = b;
  allSolids_DEF[n][2] = c;
} 

void Solid_updatePowers (int n, float a, float b, float c) {

  allSolids_DEF[n][3] = a;
  allSolids_DEF[n][4] = b;
  allSolids_DEF[n][5] = c;
} 

void Solid_Scale (int n, float a, float b, float c) {

  allSolids_DEF[n][6] *= a;
  allSolids_DEF[n][7] *= b;
  allSolids_DEF[n][8] *= c;
} 

void Solid_RotateX (int n, float t) {

  allSolids_DEF[n][9] += t;
} 

void Solid_RotateY (int n, float t) {

  allSolids_DEF[n][10] += t;
} 

void Solid_RotateZ (int n, float t) {

  allSolids_DEF[n][11] += t;
} 

float Solid_get_posX (int n) { 

  return allSolids_DEF[n][0];
} 

float Solid_get_posY (int n) { 

  return allSolids_DEF[n][1];
} 

float Solid_get_posZ (int n) { 

  return allSolids_DEF[n][2];
} 

float Solid_get_powX (int n) { 

  return allSolids_DEF[n][3];
} 

float Solid_get_powY (int n) { 

  return allSolids_DEF[n][4];
} 

float Solid_get_powZ (int n) { 

  return allSolids_DEF[n][5];
} 

float Solid_get_scaleX (int n) { 

  return allSolids_DEF[n][6];
} 

float Solid_get_scaleY (int n) { 

  return allSolids_DEF[n][7];
} 

float Solid_get_scaleZ (int n) { 

  return allSolids_DEF[n][8];
} 

float Solid_get_rotX (int n) { 

  return allSolids_DEF[n][9];
} 


float Solid_get_rotY (int n) { 

  return allSolids_DEF[n][10];
} 

float Solid_get_rotZ (int n) { 

  return allSolids_DEF[n][11];
} 

float Solid_get_value (int n) { 

  return allSolids_DEF[n][12];
} 

float Solid_get_Distance (int n, float a, float b, float c) {

  float posX = allSolids_DEF[n][0];
  float posY = allSolids_DEF[n][1];
  float posZ = allSolids_DEF[n][2];
  float powX = allSolids_DEF[n][3];
  float powY = allSolids_DEF[n][4];
  float powZ = allSolids_DEF[n][5];
  float scaleX = allSolids_DEF[n][6];
  float scaleY = allSolids_DEF[n][7];
  float scaleZ = allSolids_DEF[n][8];
  float rotX = allSolids_DEF[n][9];
  float rotY = allSolids_DEF[n][10];
  float rotZ = allSolids_DEF[n][11];
  float value = allSolids_DEF[n][12];

  a -= posX;
  b -= posY;    
  c -= posZ;

  ///////////////////////// NOT SURE START!    

  float y1 = b * cos_ang(-rotX) - c * sin_ang(-rotX); 
  float z1 = b * sin_ang(-rotX) + c * cos_ang(-rotX);
  float x1 = a;

  a = x1;
  b = y1;
  c = z1;  

  float z2 = c * cos_ang(-rotY) - a * sin_ang(-rotY);
  float x2 = c * sin_ang(-rotY) + a * cos_ang(-rotY);
  float y2 = b; 

  a = x2;
  b = y2;
  c = z2;      
  ///////////////////////// NOT SURE END!

  float x = a * cos_ang(-rotZ) - b * sin_ang(-rotZ);
  float y = a * sin_ang(-rotZ) + b * cos_ang(-rotZ); 
  float z = c;    

  x += posX;
  y += posY;  
  z += posZ;

  //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value); 
  return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))));
}




float[] SOLARCHVISION_translateInside_ReferencePivot (float a, float b, float c) {


  float rotX = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6];
  float rotY = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][7];
  float rotZ = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][8];

  float y1 = b * cos_ang(rotX) - c * sin_ang(rotX); 
  float z1 = b * sin_ang(rotX) + c * cos_ang(rotX);
  float x1 = a;

  a = x1;
  b = y1;
  c = z1;  

  float z2 = c * cos_ang(rotY) - a * sin_ang(rotY);
  float x2 = c * sin_ang(rotY) + a * cos_ang(rotY);
  float y2 = b; 

  a = x2;
  b = y2;
  c = z2;      

  float x = a * cos_ang(rotZ) - b * sin_ang(rotZ);
  float y = a * sin_ang(rotZ) + b * cos_ang(rotZ); 
  float z = c;      

  x *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3];
  y *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][4];
  z *= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][5]; 

  x += SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  y += SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  z += SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];  

  float[] return_array = {
    x, y, z
  };

  return return_array;
}



float[] SOLARCHVISION_translateOutside_ReferencePivot (float a, float b, float c) {

  a -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  b -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  c -= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];   

  a /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][3];
  b /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][4];
  c /= SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][5];    



  float rotX = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][6];
  float rotY = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][7];
  float rotZ = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][8];

  float x1 = a * cos_ang(-rotZ) - b * sin_ang(-rotZ);
  float y1 = a * sin_ang(-rotZ) + b * cos_ang(-rotZ); 
  float z1 = c;      

  a = x1;
  b = y1;
  c = z1;  

  float z2 = c * cos_ang(-rotY) - a * sin_ang(-rotY);
  float x2 = c * sin_ang(-rotY) + a * cos_ang(-rotY);
  float y2 = b; 

  a = x2;
  b = y2;
  c = z2;      

  float y = b * cos_ang(-rotX) - c * sin_ang(-rotX); 
  float z = b * sin_ang(-rotX) + c * cos_ang(-rotX);
  float x = a;  


  float[] return_array = {
    x, y, z
  };

  return return_array;
}




float[] SOLARCHVISION_getPivot () {

  float posX = SOLARCHVISION_selection_BoundingBox[1][0];
  float posY = SOLARCHVISION_selection_BoundingBox[1][1];
  float posZ = SOLARCHVISION_selection_BoundingBox[1][2];

  float x = SOLARCHVISION_selection_BoundingBox[1 + selection_alignX][0];
  float y = SOLARCHVISION_selection_BoundingBox[1 + selection_alignY][1];
  float z = SOLARCHVISION_selection_BoundingBox[1 + selection_alignZ][2];

  {
    int keep_selection_alignX = selection_alignX;
    int keep_selection_alignY = selection_alignY;
    int keep_selection_alignZ = selection_alignZ;

    selection_alignX = 0; // apply the centre
    selection_alignY = 0; // apply the centre
    selection_alignZ = 0; // apply the centre

    float[] A = SOLARCHVISION_translateInside_ReferencePivot(x - posX, y - posY, z - posZ);  

    x = A[0];
    y = A[1];
    z = A[2];

    selection_alignX = keep_selection_alignX;
    selection_alignY = keep_selection_alignY;
    selection_alignZ = keep_selection_alignZ;
  }

  float[] return_array = {
    x, y, z
  };

  return return_array;
}



/////////////////////// internal values <<<<<<<<<<<<<<<<<<<<<<<<<<<<
int MAT_renderer = 1;
int GLB_renderer = 2;
int SHD_renderer = 3;

int rendererType = 3; //GLB_renderer; // <<<<<<<<<<<<< 


void SOLARCHVISION_RenderViewport () {

  println("Render started!");
  
  int PAL_TYPE = 0; 
  int PAL_DIR = 1;
  float PAL_Multiplier = 1;   

  if (Impact_TYPE == Impact_ACTIVE) {
    PAL_TYPE = OBJECTS_Pallet_ACTIVE_CLR; 
    PAL_DIR = OBJECTS_Pallet_ACTIVE_DIR; 
    PAL_Multiplier = 1.0 * OBJECTS_Pallet_ACTIVE_MLT;
  }
  if (Impact_TYPE == Impact_PASSIVE) {  
    PAL_TYPE = OBJECTS_Pallet_PASSIVE_CLR; 
    PAL_DIR = OBJECTS_Pallet_PASSIVE_DIR;
    PAL_Multiplier = 0.05 * OBJECTS_Pallet_PASSIVE_MLT;
  }     

  
  int RES1 = WIN3D_X_View;
  int RES2 = WIN3D_Y_View;
  
  PImage Image_RGBA = createImage(RES1, RES2, ARGB);

  Image_RGBA.loadPixels();

  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    Image_X -= 0.5 * WIN3D_X_View;
    Image_Y -= 0.5 * WIN3D_Y_View;
  

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D_CAM_x, WIN3D_CAM_y, WIN3D_CAM_z
    };

    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D_ViewType == 0) {
      float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];



         
  
    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);

    if (RxP[0] > 0) {        
        
      int f = int(RxP[0]);

      if (rendererType == SHD_renderer) {

        float[] COL = {
          0, 0, 0, 0
        };
        
        float[] face_norm = {RxP[5], RxP[6], RxP[7]};
        face_norm = SOLARCHVISION_fn_normalize(face_norm);
        
        float Alpha = 90 - acos_ang(face_norm[2]);
        float Beta = 180 - atan2_ang(face_norm[0], face_norm[1]);

float _valuesSUM_RAD = 0;
float _valuesSUM_EFF_P = 0;
float _valuesSUM_EFF_N = 0;
int _valuesNUM = 0; 

                float _values_R_dir = 1;
                float _values_R_dif = 1;
                float _values_E_dir = 0.1;
                float _values_E_dif = 0.1;


//float[] SunR = SOLARCHVISION_SunPositionRadiation(LocationLatitude, DATE_ANGLE, HOUR_ANGLE, FORECAST_ENSEMBLE_Data[i][j][LAYER_cloudcover][k]);
float[] SunR = SOLARCHVISION_SunPositionRadiation(LocationLatitude, 0, 12, 0);
float[] VECT = {
  0, 0, 0
}; 

if (abs(Alpha) > 89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = 1;
} else if (Alpha < -89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = -1;
} else {
  VECT[0] = sin_ang(Beta);
  VECT[1] = -cos_ang(Beta);
  VECT[2] = tan_ang(Alpha);
}   

VECT = SOLARCHVISION_fn_normalize(VECT);


float[] SunV = {
  SunR[1], SunR[2], SunR[3]
};

float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
if (SunMask <= 0) SunMask = 0; // removes backing faces 

float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));


// new trace
ray_start[0] = RxP[1];
ray_start[1] = RxP[2];
ray_start[2] = RxP[3];

ray_direction[0] = SunR[1];
ray_direction[1] = SunR[2];
ray_direction[2] = SunR[3];

if (SOLARCHVISION_fn_dot(face_norm, ray_direction) > 0) { // removes backing faces

  if (SOLARCHVISION_is3Dintersected(ray_start, ray_direction) == 1) { 
    if (_values_E_dir < 0) {
      _valuesSUM_EFF_P += -(_values_E_dir * SunMask); 
      _valuesSUM_EFF_N += -(_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    } else {
      _valuesSUM_EFF_N += (_values_E_dir * SunMask); 
      _valuesSUM_EFF_P += (_values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    }

    _valuesSUM_RAD += (_values_R_dif * SkyMask); // only approximate diffuse radiation!
  } else { 
    if (_values_E_dir < 0) {
      _valuesSUM_EFF_N += -((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
    } else {
      _valuesSUM_EFF_P += ((_values_E_dir * SunMask) + (_values_E_dif * SkyMask));
    }

    _valuesSUM_RAD += ((_values_R_dir * SunMask) + (_values_R_dif * SkyMask)); // calculates total radiation
  }
}
_valuesNUM += 1;

//-----------------------------
float _valuesSUM = _valuesSUM_RAD; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//-----------------------------
      
        float _u = 0;
      
        if (_valuesSUM < 0.9 * FLOAT_undefined) {
      
          if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
      
          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;
        }
      
        COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

        
        Image_RGBA.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        
      }
      else if (rendererType == GLB_renderer) {

        float[] COL = {
          0, 0, 0, 0
        };
        
        float[] face_norm = {RxP[5], RxP[6], RxP[7]};
        face_norm = SOLARCHVISION_fn_normalize(face_norm);
        
        float Alpha = 90 - acos_ang(face_norm[2]);
        float Beta = 180 - atan2_ang(face_norm[0], face_norm[1]);

       
        int a = int((Alpha + 90) / SOLARCHVISION_GLOBE_stp_slp);
        int b = int(Beta / SOLARCHVISION_GLOBE_stp_dir);
      
        if (a < 0) a += int(180 / SOLARCHVISION_GLOBE_stp_slp);
        if (b < 0) b += int(360 / SOLARCHVISION_GLOBE_stp_dir);
        if (a > int(180 / SOLARCHVISION_GLOBE_stp_slp)) a -= int(180 / SOLARCHVISION_GLOBE_stp_slp);
        if (b > int(360 / SOLARCHVISION_GLOBE_stp_dir)) b -= int(360 / SOLARCHVISION_GLOBE_stp_dir);
      
        float _valuesSUM = LocationExposure[IMPACTS_DisplayDay][a][b];
      
        float _u = 0;
      
        if (_valuesSUM < 0.9 * FLOAT_undefined) {
      
          if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_Multiplier * _valuesSUM);
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_Multiplier * _valuesSUM);
      
          if (PAL_DIR == -1) _u = 1 - _u;
          if (PAL_DIR == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_DIR == 2) _u =  0.5 * _u;
        }
      
        COL = SOLARCHVISION_GET_COLOR_STYLE(PAL_TYPE, _u);

        
        Image_RGBA.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        
      }
      else if (rendererType == MAT_renderer) {
        int mt = allFaces_MTLV[f][0];
    
        float a = Materials_Color[mt][0];
        float r = Materials_Color[mt][1]; 
        float g = Materials_Color[mt][2]; 
        float b = Materials_Color[mt][3];   
    
        Image_RGBA.pixels[np] = color(r, g, b, a);
      }
    }
    else Image_RGBA.pixels[np] = color(0,0,0,0);
  }

  Image_RGBA.updatePixels();
 
 
  Image_RGBA.save("Render.png");
  
  println("Render saved!");

  
}




void SOLARCHVISION_PreBakeViewport () {

  SceneName = "test_ " + Viewport_Stamp();
  
  println("PreBake started!");

  int RES1 = WIN3D_X_View;
  int RES2 = WIN3D_Y_View;

  int n_Map = 0; 
  for (int DATE_ANGLE = 90; DATE_ANGLE <= 270; DATE_ANGLE += 45) {
    //for (int i = 0; i < 24; i += 1) {
    for (int i = 9; i <= 15; i += 3) { // to make it faster. Also the images are not needed out of this period.
      n_Map += 1;
    }
  } 
  
  PImage[][] Image_RGBA = new PImage [n_Map][2];

  n_Map = -1; 
  for (int DATE_ANGLE = 90; DATE_ANGLE <= 270; DATE_ANGLE += 45) {
    //for (int i = 0; i < 24; i += 1) {
    for (int i = 9; i <= 15; i += 3) { // to make it faster. Also the images are not needed out of this period.
      n_Map += 1; 
      
      for (int SHD = 0; SHD <= 1; SHD += 1) {

        Image_RGBA[n_Map][SHD] = createImage(RES1, RES2, ARGB);
        
        Image_RGBA[n_Map][SHD].loadPixels();
      }
    }
  }

  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    Image_X -= 0.5 * WIN3D_X_View;
    Image_Y -= 0.5 * WIN3D_Y_View;
  

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D_CAM_x, WIN3D_CAM_y, WIN3D_CAM_z
    };

    float[] ray_end = SOLARCHVISION_calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D_ViewType == 0) {
      float[] ray_center = SOLARCHVISION_calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];



         
  
    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_3Dintersect(ray_start, ray_direction);

    if (RxP[0] > 0) {        
        
      int f = int(RxP[0]);

      float[] COL = {
        0, 0, 0, 0
      };
      
      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = SOLARCHVISION_fn_normalize(face_norm);
      
      float Alpha = 90 - acos_ang(face_norm[2]);
      float Beta = 180 - atan2_ang(face_norm[0], face_norm[1]);

      float[] VECT = {
        0, 0, 0
      }; 

      if (abs(Alpha) > 89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = 1;
      } else if (Alpha < -89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = -1;
      } else {
        VECT[0] = sin_ang(Beta);
        VECT[1] = -cos_ang(Beta);
        VECT[2] = tan_ang(Alpha);
      }   
      
      VECT = SOLARCHVISION_fn_normalize(VECT);
      


      n_Map = -1; 
      for (int DATE_ANGLE = 90; DATE_ANGLE <= 270; DATE_ANGLE += 45) {
        //for (int i = 0; i < 24; i += 1) {
        for (int i = 9; i <= 15; i += 3) { // to make it faster. Also the images are not needed out of this period.
          n_Map += 1; 
          
          float HOUR_ANGLE = i;
    
          float[] SunR = SOLARCHVISION_SunPosition(LocationLatitude, DATE_ANGLE, HOUR_ANGLE);

          
    
          
          float[] SunV = {
            SunR[1], SunR[2], SunR[3]
          };
    
    
    
    
          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];
          
          ray_direction[0] = SunR[1];
          ray_direction[1] = SunR[2];
          ray_direction[2] = SunR[3];
          

          float SunMask = SOLARCHVISION_fn_dot(SOLARCHVISION_fn_normalize(SunV), SOLARCHVISION_fn_normalize(VECT));
          if (SunMask <= 0) SunMask = 0; // removes backing faces 
          
          
          // when SHD = 0;
          Image_RGBA[n_Map][0].pixels[np] = color(255 * SunMask, 255);
            
          // when SHD = 1;            
          if (SOLARCHVISION_is3Dintersected(ray_start, ray_direction) != 1) { 
            Image_RGBA[n_Map][1].pixels[np] = color(255 * SunMask, 255);
          }
          else Image_RGBA[n_Map][1].pixels[np] = color(0, 255);

          
        }
      }
    }
    else {
      
      n_Map = -1; 
      for (int DATE_ANGLE = 90; DATE_ANGLE <= 270; DATE_ANGLE += 45) {
        //for (int i = 0; i < 24; i += 1) {
        for (int i = 9; i <= 15; i += 3) { // to make it faster. Also the images are not needed out of this period.
          n_Map += 1; 
          
          for (int SHD = 0; SHD <= 1; SHD += 1) {
    
            Image_RGBA[n_Map][SHD].pixels[np] = color(0,0,0,0);
          
          }
        }
      }      
    }
    
  }
  
  
  n_Map = -1; 
  for (int DATE_ANGLE = 90; DATE_ANGLE <= 270; DATE_ANGLE += 45) {
    //for (int i = 0; i < 24; i += 1) {
    for (int i = 9; i <= 15; i += 3) { // to make it faster. Also the images are not needed out of this period.
      n_Map += 1; 

      float HOUR_ANGLE = i;


      for (int SHD = 0; SHD <= 1; SHD += 1) {

        String[] STR_SHD = {
          "F", "T"
        };
        String File_Name = "";
  
        File_Name = "C:/SOLARCHVISION_2015/Input/ShadingAnalysis/" + SceneName + "_" + NearLatitude_Stamp() + "/";
  
        File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(roundTo(HOUR_ANGLE * 100, 1.0)), 4);
  
        File_Name += "_" +  SceneName + "_" + NearLatitude_Stamp() + "_Camera00";
  
        Image_RGBA[n_Map][SHD].updatePixels();
        
        Image_RGBA[n_Map][SHD].save(File_Name + ".PNG");
        
        println(File_Name + ".PNG");
      }
    }
  }  
      
 
 
  
  
  println("PreBake saved!");
  
}

