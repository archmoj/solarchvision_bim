// after calling .reduceDegreePolygon is not complete


// bug drawProbs

// remember: should optimize vertics after optimizing faces!

//for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not available out of this period. 


//    allModel2Ds.add_onLand(1); // 1 = people

//    allModel2Ds.add_onLand(2); // 2 = 2D trees



int SOLARCHVISION_pixel_H = 275; //300; 
int SOLARCHVISION_pixel_W = int(SOLARCHVISION_pixel_H * 1.75); 

float MessageSize = (2 * SOLARCHVISION_pixel_W + SOLARCHVISION_pixel_H) / 120.0; // screen width 

int SOLARCHVISION_pixel_A = int(1.5 * MessageSize); // menu bar
int SOLARCHVISION_pixel_B = int(2.75 * MessageSize); // 3D tool bar
int SOLARCHVISION_pixel_C = int(3.0 * MessageSize); // command bar
int SOLARCHVISION_pixel_D = int(4.5 * MessageSize); // time bar


boolean displayOutput_inExplorer = false;


class solarchvision_OperatingSystem {
  
  private final static String CLASS_STAMP = "OperatingSystem";

  String[] getFiles (String _Folder) {
    //println(_Folder);
    String[] filenames = new String[0];
    File dir = new File(_Folder);
    if (dir.exists() && dir.isDirectory()) {
      filenames = concat(filenames, dir.list());
      if (filenames != null) {
        for (int i = 0; i < filenames.length; i++) {
          //println(filenames[i]);
        }
      }
    }
    return filenames;
  }
  
  String getFilenameFromPath (String path) {
    File file = new File(path); 
    return split(file.getName(),'.')[0]; // using the first text before dot
  }  
}
solarchvision_OperatingSystem OPESYS = new solarchvision_OperatingSystem(); 






class solarchvision_Functions {
  
  private final static String CLASS_STAMP = "Functions";
  
  final float EPSILON_DIRECTION = 0.001; // to detect parallels.
  final float EPSILON_POSITION = 0.0001; // to detect intersections i.e. in the world coordinate.


  
  
  float asin_ang (float a) {
    return ((asin(a)) * 180/PI);
  }
  
  float acos_ang (float a) {
    return ((acos(a)) * 180/PI);
  }
  
  float atan_ang (float a) {
    return ((atan(a)) * 180/PI);
  }
  
  float atan2_ang (float a, float b) {
    return ((atan2(a, b)) * 180/PI);
  }
  
  
  float sin_ang (float a) {
    return sin(a * PI / 180);
  }
  
  float cos_ang (float a) {
    return cos(a * PI / 180);
  }
  
  float tan_ang (float a) {
    return tan(a * PI / 180);
  }
  
  
  
  
  float roundTo (float a, float b) {
    float a_floor = (floor (a / (1.0 * b))) * b;
    float a_ceil =  (ceil (a / (1.0 * b))) * b;
    float c;
    if ((a - a_floor) > (a_ceil - a)) {
      c = a_ceil;
    } else {
      c = a_floor;
    }
    return c;
  }
  
  
  float[] convert_lonlat2XY (double lon0, double lat0, double lon, double lat) {
  
    double du = ((lon - lon0) / 180.0) * (PI * DOUBLE_r_Earth);
    double dv = ((lat - lat0) / 180.0) * (PI * DOUBLE_r_Earth);
  
    float x = (float) du * funcs.cos_ang((float) lat);
    float y = (float) dv;   
    
    float[] XY = {x, y};
    
    return XY;
  }  
  
  
  float lon_lat_dist (double lon1, double lat1, double lon2, double lat2) {
  
    float dLon = (float) (lon2 - lon1); 
    float dLat = (float) (lat2 - lat1);
  
    float a = this.sin_ang(dLon / 2.0);
    float b = this.sin_ang(dLat / 2.0) * this.sin_ang(dLat / 2.0) + this.cos_ang((float) lat1) * this.cos_ang((float) lat2) * a * a;
    float d = 2 * atan2(sqrt(b), sqrt(1 - b)) * (float) DOUBLE_r_Earth; 
  
    return(d);
  }
  
  float[] vec_scale (float[] a, float b) {
  
    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b * a[i];
    }
  
    return d;
  }  
  
  float[] vec3_scale (float[] a, float b) {
  
    float[] d = {b * a[0], b * a[1], b * a[2]};
    
    return d; 
  }    
  
  float[] vec_sum (float[] a, float[] b) {
  
    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b[i] + a[i];
    }
  
    return d;
  }
  
  float[] vec3_sum (float[] a, float[] b) {
  
    float[] d = {b[0] + a[0], b[1] + a[1], b[2] + a[2]};
    
    return d; 
  }  
  
  float[] vec_diff (float[] a, float[] b) {
  
    float[] d = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      d[i] = b[i] - a[i];
    }
  
    return d;
  }
  
  float[] vec3_diff (float[] a, float[] b) {
  
    float[] d = {b[0] - a[0], b[1] - a[1], b[2] - a[2]};
    
    return d; 
  }
  
  float vec_dist (float[] a, float[] b) {
  
    return this.vec_mag(this.vec_diff(a, b));
  }  
  
  float vec3_dist (float[] a, float[] b) {
  
    return this.vec3_mag(this.vec3_diff(a, b));
  }    

  
  float vec_mag (float[] a) {
  
    float d = 0;
    for (int i = a.length - 1; i > -1 ; --i) {
      d += pow(a[i], 2);
    }
    d = pow(d, 0.5);
  
    return d;
  }  
  
  float vec3_mag (float[] a) {
  
    return pow(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], 0.5);   
  }    
  
  float[] vec_unit (float[] a) {
    
    float d = this.vec_mag(a);

    float[] b = new float[a.length];
    for (int i = a.length - 1; i > -1; --i) {
      if (d != 0) b[i] = a[i] / d;
      else b[i] = 0;
    } 
    return b;
  }
  
  float[] vec3_unit (float[] a) {

    float d = this.vec3_mag(a);
  
    float[] b = new float[3];
    for (int i = 0; i < 3; i++) {
      if (d != 0) b[i] = a[i] / d;
      else b[i] = 0;
    } 
    return b;
  }  
  
  float vec_dot (float[] a, float b[]) {
    float d = 0;
    for (int i = a.length - 1; i > -1; --i) {
      d += a[i] * b[i];
    }
    return d;
  }
  
  float vec2_dot (float x1, float y1, float x2, float y2) {
    return x1 * x2 + y1 * y2;
  }  
  
  float vec3_dot (float[] a, float b[]) {
    
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  
  float[] vec3_cross (float[] a, float b[]) {
    
    float[] c = new float [3];
    
    c[0] = a[1] * b[2] - a[2] * b[1];
    c[1] = a[2] * b[0] - a[0] * b[2];
    c[2] = a[0] * b[1] - a[1] * b[0];
    
    return c;
  }
  
  float[] centroid (float[][] a) {
  
    float[] b = a[0]; // initializing to the first node
  
    // adding other nodes
    for (int i = a.length - 1; i > 0; --i) { // not the first one!
      for (int j = b.length - 1; j > -1; --j) {
        b[j] += a[i][j];
      }
    }
  
    // dividing to the number of nodes
    for (int j = b.length - 1; j > -1; --j) {
      b[j] /= float(a.length);
    }
  
    return b;
  }  

  
  float bilinear (float f_00, float f_10, float f_11, float f_01, float x, float y) {
  
    float f_xy = f_00 * (1 - x) * (1 - y) + f_10 * x * (1 - y) + f_01 * (1 - x) * y + f_11 * x * y;
  
    return f_xy;
  }
  
  
  boolean isInside_Triangle (float[] P, float[] A, float[] B, float[] C) {
  
    float pX = P[0] - C[0];
    float pY = P[1] - C[1];
    float pZ = P[2] - C[2];
      
    float aX = A[0] - C[0];
    float aY = A[1] - C[1];
    float aZ = A[2] - C[2];
  
    float bX = B[0] - C[0];
    float bY = B[1] - C[1];
    float bZ = B[2] - C[2];
  
    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);
    
    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;
    
    return ((u >= 0) && (v >= 0) && (u + v <= 1));
  }
  
  
  boolean isInside_Quadrangle (float[] P, float[] A, float[] B, float[] C, float[] D) {  
  
    float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]), 0.25 * (A[1] + B[1] + C[1] + D[1]), 0.25 * (A[2] + B[2] + C[2] + D[2])};
  
    float pX = P[0] - G[0];
    float pY = P[1] - G[1];
    float pZ = P[2] - G[2];
  
    float aX = A[0] - G[0];
    float aY = A[1] - G[1];
    float aZ = A[2] - G[2];
  
    float bX = B[0] - G[0];
    float bY = B[1] - G[1];
    float bZ = B[2] - G[2];
    
    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);
  
    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;
   
    boolean result = ((u >= 0) && (v >= 0) && (u + v <= 1));
    
    if (result == false) {
  
      float cX = C[0] - G[0];
      float cY = C[1] - G[1];
      float cZ = C[2] - G[2];
  
      float CC = cX * cX + cY * cY + cZ * cZ; // this.vec3_dot(c, c);
      float CP = cX * pX + cY * pY + cZ * pZ; // this.vec3_dot(c, p);
      float BC = bX * cX + bY * cY + bZ * cZ; // this.vec3_dot(b, c);
    
      r = (BB * CC - BC * BC); if (r == 0.0) return false;
      u = (CC * BP - BC * CP) / r;
      v = (BB * CP - BC * BP) / r;  
      
      result = ((u >= 0) && (v >= 0) && (u + v <= 1));
      
      if (result == false) {
  
        float dX = D[0] - G[0];
        float dY = D[1] - G[1];
        float dZ = D[2] - G[2];
        
        float CD = cX * dX + cY * dY + cZ * dZ; // this.vec3_dot(c, d);
        float DD = dX * dX + dY * dY + dZ * dZ; // this.vec3_dot(d, d);
        float DP = dX * pX + dY * pY + dZ * pZ; // this.vec3_dot(d, p);
      
        r = (CC * DD - CD * CD); if (r == 0.0) return false;
        u = (DD * CP - CD * DP) / r;
        v = (CC * DP - CD * CP) / r;
        
        result = ((u >= 0) && (v >= 0) && (u + v <= 1));
        
        if (result == false) {
          
          float DA = dX * aX + dY * aY + dZ * aZ; // this.vec3_dot(d, a);  
          
          r = (DD * AA - DA * DA); if (r == 0.0) return false;
          u = (AA * DP - DA * AP) / r;
          v = (DD * AP - DA * DP) / r;
          
          result = ((u >= 0) && (v >= 0) && (u + v <= 1));
        }  
      }
    }
    
    return result;
  }
  
  boolean isInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // good for rectangular surfaces namely for selecting allModel2Ds, etc.  
  
    float pX = P[0] - O[0];
    float pY = P[1] - O[1];
    float pZ = P[2] - O[2];
      
    float aX = A[0] - O[0];
    float aY = A[1] - O[1];
    float aZ = A[2] - O[2];
  
    float bX = B[0] - O[0];
    float bY = B[1] - O[1];
    float bZ = B[2] - O[2];
  
    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);
    
    float r = (AA * BB - AB * AB); if (r == 0.0) return false;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;
    
    return ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1));
  }
  
  float[] uvInside_Rectangle (float[] P, float[] A, float[] O, float[] B) { // copy of the function above but it returns u and v
  
    float pX = P[0] - O[0];
    float pY = P[1] - O[1];
    float pZ = P[2] - O[2];
      
    float aX = A[0] - O[0];
    float aY = A[1] - O[1];
    float aZ = A[2] - O[2];
  
    float bX = B[0] - O[0];
    float bY = B[1] - O[1];
    float bZ = B[2] - O[2];
  
    float AA = aX * aX + aY * aY + aZ * aZ; // this.vec3_dot(a, a);
    float AB = aX * bX + aY * bY + aZ * bZ; // this.vec3_dot(a, b);
    float AP = aX * pX + aY * pY + aZ * pZ; // this.vec3_dot(a, p);
    float BB = bX * bX + bY * bY + bZ * bZ; // this.vec3_dot(b, b);
    float BP = bX * pX + bY * pY + bZ * pZ; // this.vec3_dot(b, p);
    
    float[] result = {0, 0};
    
    float r = (AA * BB - AB * AB); if (r == 0.0) return result;
    float u = (BB * AP - AB * BP) / r;
    float v = (AA * BP - AB * AP) / r;
    
    result[0] = u;
    result[1] = v;
    
    return result;
  }
  
  
  float[][] getSubFace (float[][] base_Vertices, int Tessellation, int n) {
  
    float[][] return_vertices = {
    };
  
    int TotalSubNo = 1;
    if (Tessellation > 0) TotalSubNo = base_Vertices.length * int(this.roundTo(pow(4, Tessellation - 1), 1));   
  
    if ((Tessellation <= 0) || (n < 0) || (n >= TotalSubNo)) {
      return_vertices = new float [base_Vertices.length][3];
  
      for (int j = 0; j < base_Vertices.length; j++) {
        return_vertices[j] = base_Vertices[j];
      }
    } else {
      return_vertices = new float [4][3];
  
      int div = base_Vertices.length;
  
      int the_first = n % div;
      int the_next = (the_first + 1) % div;
      int the_previous = (the_first + div - 1) % div;
  
      float[] A = {
        0, 0, 0
      };
      float[] B = {
        0, 0, 0
      };
      float[] C = {
        0, 0, 0
      };
      float[] D = {
        0, 0, 0
      };
  
      for (int i = 0; i < 3; i++) {
  
        A[i] = base_Vertices[the_first][i];
        B[i] = 0.5 * (A[i] + base_Vertices[the_next][i]);
        D[i] = 0.5 * (A[i] + base_Vertices[the_previous][i]);
  
        for (int j = 0; j < base_Vertices.length; j++) {
          C[i] += base_Vertices[j][i] / (1.0 * base_Vertices.length);
        }
      }
  
      if (Tessellation == 1) {
        return_vertices[0] = A; 
        return_vertices[1] = B; 
        return_vertices[2] = C; 
        return_vertices[3] = D;
      } else {
  
        int section = n / div;
        int res = int(this.roundTo(pow(2, Tessellation - 1), 1));
        int u = section / res;
        int v = section % res;
  
        float x1 = (1.0 * u) / (1.0 * res);
        float y1 = (1.0 * v) / (1.0 * res);
        float x2 = (1.0 * (u + 1)) / (1.0 * res);
        float y2 = (1.0 * (v + 1)) / (1.0 * res);
  
        float[] P0 = {
          0, 0, 0
        };
        float[] P1 = {
          0, 0, 0
        };
        float[] P2 = {
          0, 0, 0
        };
        float[] P3 = {
          0, 0, 0
        };
  
        for (int i = 0; i < 3; i++) {
          P0[i] = this.bilinear(A[i], B[i], C[i], D[i], x1, y1); 
          P1[i] = this.bilinear(A[i], B[i], C[i], D[i], x2, y1); 
          P2[i] = this.bilinear(A[i], B[i], C[i], D[i], x2, y2); 
          P3[i] = this.bilinear(A[i], B[i], C[i], D[i], x1, y2);
        }      
  
        //return_vertices[0] = P0; 
        //return_vertices[1] = P1; 
        //return_vertices[2] = P2; 
        //return_vertices[3] = P3;
  
        //to rotate tri-grid cells:
  
        int d = ((u % 2) + ((v + 1) % 2)) % 2; 
        if (d == 0) {
          return_vertices[0] = P0; 
          return_vertices[1] = P1; 
          return_vertices[2] = P2; 
          return_vertices[3] = P3;
        } else {
          return_vertices[0] = P1; 
          return_vertices[1] = P2; 
          return_vertices[2] = P3; 
          return_vertices[3] = P0;
        }
      }
    }
  
  
    return return_vertices;
  }


  boolean is_zero (float val) { 
    return (abs(val) < this.EPSILON_POSITION); 
  }

  boolean is_zero (float val, float tolerance) { 
    return (abs(val) < tolerance); 
  }
  
  boolean arePointsClose(float[] point1, float[] point2) {
    return this.is_zero(this.vec3_mag(this.vec3_diff(point1, point2)), this.EPSILON_POSITION);
  }  
  
  boolean are3PointsIn1Line(float[] point1, float[] point2, float[] point3) {
    
    return this.is_zero(1.0 - abs(this.vec3_dot(
                                  this.vec3_unit(this.vec3_diff(point1, point2)), 
                                  this.vec3_unit(this.vec3_diff(point2, point3)))), this.EPSILON_DIRECTION);
  }
    
  float[] calculateTriangleNormal(float[] point1, float[] point2, float[] point3) {
    return this.vec3_unit(this.vec3_cross(
                          this.vec3_diff(point1, point2), 
                          this.vec3_diff(point2, point3))); 
  }  
  
  
  float[] calculatePolygonNormal(float[][] polygonVertices) {
    
    float[] polygonNormal = {0, 0, 0};
    
    int n = polygonVertices.length;
    
    for (int i = 0; i < n; i++) {
      int i1 = (i + 1) % n;
      int i2 = (i + 2) % n;
      
      if (false == are3PointsIn1Line(polygonVertices[i], 
                                     polygonVertices[i1],
                                     polygonVertices[i2])) {
        
        polygonNormal = calculateTriangleNormal(polygonVertices[i], 
                                                polygonVertices[i1],
                                                polygonVertices[i2]);
  
        break;
      }
    }
                                                  
    return polygonNormal;
  }  
  
  
  boolean isPointInPolygon(float[] point, float[][] polygon_vertices) { 

    float[] polygon_normal = calculatePolygonNormal(polygon_vertices);
    
 
    int i, next_i;
    
    // fisrt check at each vertex, if equal to any we return ture
    for (i = 0; i < polygon_vertices.length; i++) {
      
      if (true == this.is_zero(this.vec3_mag(this.vec3_diff(point, polygon_vertices[i])))) {
        return true;
      }
    }

    float sumAngles = 0.0;
    for (i = 0; i < polygon_vertices.length; i++) {
      next_i = (i + 1) % polygon_vertices.length;
      
      float[] AM = this.vec3_diff(point, polygon_vertices[i]);
      float[] BM = this.vec3_diff(point, polygon_vertices[next_i]);
      
      float divisor = this.vec3_mag(AM) * this.vec3_mag(BM);
      if (divisor > 0.0) {
        
        float acosine = this.vec3_dot(AM, BM) / divisor;
        if (acosine < -1.0) acosine = -1.0;
        else if (acosine > 1.0) acosine = 1.0;
        
        float angle = acos(acosine); // returns between 0 and PI
        if (false == Float.isNaN(angle)){
          if (this.vec3_dot(this.vec3_cross(AM, BM), polygon_normal) < 0) {
            angle = -angle;
          }
          sumAngles += angle;
        }
      }
    }
    
    float remainder = (abs(sumAngles) / (2.0 * PI)) % 2.0;
    if (remainder < 0.9999 || remainder > 1.0001) {
      return false;
    }
    return true;
  }  
  
  
  
  float[][] cleanShape_removeDuplicateVertices (float[][] vertices_IN) {

    float[][] vertices_OUT =  new float[0][3];
    int n = vertices_IN.length;
    for (int i = 0; i < n; i++) {
      int prev_i = (i - 1 + n) % n;

      if (false == this.is_zero(this.vec3_mag(this.vec3_diff(vertices_IN[i], vertices_IN[prev_i])), 0.001)) { // i.e. 1mm tolerance, here
        
        float[][] newVertex = {{vertices_IN[i][0], vertices_IN[i][1], vertices_IN[i][2]}};
        vertices_OUT = (float[][]) concat(vertices_OUT, newVertex);
      }
    }
    
    return vertices_OUT;
  }
  
  
  
  float[][] cleanShape_joinParallelSegments (float[][] vertices_IN) {

    float[][] vertices_OUT =  new float[0][3];
    int n = vertices_IN.length;
    for (int i = 0; i < n; i++) {
      int prev_i = (i - 1 + n) % n;
      int next_i = (i + 1) % n;
      
      if (false == are3PointsIn1Line(vertices_IN[prev_i], 
                                     vertices_IN[i],
                                     vertices_IN[next_i])) {  
                                      
        float[][] newVertex = {{vertices_IN[i][0], vertices_IN[i][1], vertices_IN[i][2]}};
        vertices_OUT = (float[][]) concat(vertices_OUT, newVertex);
      }
    }
    
    return vertices_OUT;
  }
  
  
  
  float[][] optimizeVertices (float[][] vertices_IN) {
    float[][] vertices_TMP = this.cleanShape_removeDuplicateVertices(vertices_IN);
    float[][] vertices_OUT = this.cleanShape_joinParallelSegments(vertices_TMP);
      
    return vertices_OUT;
  }; 
      
  
  
  
  float calculatePolygonArea(float[][] polygonVertices) {

   float[] sumVect = {0, 0, 0};
      
    for (int i = 0; i < polygonVertices.length; i++) {
      int next_i = (i + 1) % polygonVertices.length;
      
      float[] A = this.vec3_cross(polygonVertices[i], polygonVertices[next_i]);
      float[] B = sumVect;
      
      sumVect = this.vec3_sum(A, B);
    }
    
    return 0.5 * this.vec3_mag(sumVect); // unit m2
  }  
  
  
  boolean isPointOnSegment(float[] point, float[] pStart, float[] pEnd) {
    
    float L1 = this.vec3_mag(this.vec3_diff(pStart, point));
    float L2 = this.vec3_mag(this.vec3_diff(point, pEnd));
    float L3 = this.vec3_mag(this.vec3_diff(pStart, pEnd));

    return this.is_zero(L3 -(L2 + L1), this.EPSILON_POSITION);
  }   

 
  float[] getBetween(float[] point1, float[] point2, float ratio) {
    
    return this.vec3_sum(this.vec3_scale(point1, ratio), this.vec3_scale(point2, 1.0 - ratio));
  }   
  
  float[] intersect_segmentXsegment (float[] A1, float[] A2, float[] B1, float[] B2) {
    
    float[] nullPoint = {FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
    
    if (arePointsClose(A1, B1)) return getBetween(A1, B1, 0.5);
    if (arePointsClose(A1, B2)) return getBetween(A1, B2, 0.5);
    if (arePointsClose(A2, B1)) return getBetween(A2, B1, 0.5);
    if (arePointsClose(A2, B2)) return getBetween(A2, B2, 0.5);
    
    if (isPointOnSegment(A1, B1, B2)) return A1;
    if (isPointOnSegment(A2, B1, B2)) return A2;
    if (isPointOnSegment(B1, A1, A2)) return B1;
    if (isPointOnSegment(B2, A1, A2)) return B2;
      
    float[] Axis_A = this.vec3_unit(this.vec3_diff(A1, A2));
    float[] Axis_B = this.vec3_unit(this.vec3_diff(B1, B2));

    if (true == this.is_zero(1 - Math.abs(this.vec3_dot(this.vec3_unit(Axis_A), this.vec3_unit(Axis_B))), this.EPSILON_DIRECTION)) {

      return nullPoint;
    } 
    
    float[] cross_vect = this.vec3_cross(Axis_A, Axis_B);
    float cross_dist = this.vec3_mag(cross_vect);
    
    if (this.is_zero(cross_dist)) {

      return nullPoint;
    }
    
    float rA = this.vec3_dot(this.vec3_cross(this.vec3_diff(B1, A1), Axis_B), cross_vect) / (cross_dist * cross_dist);
    float rB = this.vec3_dot(this.vec3_cross(this.vec3_diff(B1, A1), Axis_A), cross_vect) / (cross_dist * cross_dist);
    
    float[] result_A = this.vec3_sum(A1, this.vec3_scale(Axis_A, rA));
    float[] result_B = this.vec3_sum(B1, this.vec3_scale(Axis_B, rB));

    
    
    if (false == this.is_zero(this.vec3_mag(this.vec3_diff(result_A, result_B)), this.EPSILON_POSITION)) {
      
      return nullPoint;
    }
    
    float[] result_AxB = getBetween(result_A , result_B, 0.5);
    
    if (false == isPointOnSegment(result_AxB, A1, A2)) return nullPoint;
    if (false == isPointOnSegment(result_AxB, B1, B2)) return nullPoint;
    
    return result_AxB;
  }
  




  


  int[][] reduceDegreePolygon (float[][] polygon_vertices) {
    
    int maximumDegree = 3;
    
    int[][] allDiagonals = new int[0][2]; // start, end
    float[] allDiagonals_dist = new float[0];
    float[] intersectionPoint;
    
    int i, j, k, q;
    int i2, j2;
    float[] A, B, A2, B2;
    
    int n = polygon_vertices.length;
    
    for (i = 0; i < n; i++) {
      
      int next_i = (i + 1) % n;
      int prev_i = (i - 1 + n) % n;
      
      for (j = i + 1; j < n; j++) {
        
        if ((j != prev_i) && (j != next_i)) {
        
          A = polygon_vertices[i];
          B = polygon_vertices[j];
          
          boolean diagonalRejected = false;
          
          float[] lEdgeMiddle = this.vec3_scale(this.vec_sum(A, B), 0.5);          
          if (false == isPointInPolygon(lEdgeMiddle, polygon_vertices)) {
            diagonalRejected = true;
          }
          else {
          
            for (k = 0; k < n; k++) {
              
              int next_k = (k + 1) % n;
              
              if ((i != k) && (i != next_k) &&
                  (j != k) && (j != next_k)) {
                    
                A2 = polygon_vertices[k];
                B2 = polygon_vertices[next_k];
            
                intersectionPoint = intersect_segmentXsegment(A, B, A2, B2);
                
                if (false == is_undefined_FLOAT(intersectionPoint[0])) {
                  diagonalRejected = true;
                  break;
                }
              }
            }
          }
          
          if (false == diagonalRejected) {
            
            float dist = this.vec3_mag(this.vec3_diff(A, B));
            
            int[][] newDiagonal = {{i, j}};
            allDiagonals = (int[][]) concat(allDiagonals, newDiagonal);
            
            float[] newDiagonal_dist = {dist};
            allDiagonals_dist = (float[]) concat(allDiagonals_dist, newDiagonal_dist);
            
          }
          
        }
      }
    }


    // ascending sort:
    for (k = 0; k < allDiagonals.length; k++) { 
      for (q = k + 1; q < allDiagonals.length; q++) {
        if (allDiagonals_dist[k] > allDiagonals_dist[q]) {
          float tmp_float = allDiagonals_dist[k];
          allDiagonals_dist[k] = allDiagonals_dist[q];
          allDiagonals_dist[q] = tmp_float;
          
          for (j = 0; k < 2; j++) {
            int tmp_int = allDiagonals[k][j];
            allDiagonals[k][j] = allDiagonals[q][j];
            allDiagonals[q][j] = tmp_int;
          }          
          
        }
      }
    }

    
    for (k = 0; k < allDiagonals.length; k++) { 
    
      i = allDiagonals[k][0]; // start
      j = allDiagonals[k][1]; // end
      A = polygon_vertices[i];
      B = polygon_vertices[j];
    
      for (q = allDiagonals.length - 1 ; q > k; q--) { // reversed loop required.
        
        i2 = allDiagonals[q][0]; // start
        j2 = allDiagonals[q][1]; // end
        A2 = polygon_vertices[i2];
        B2 = polygon_vertices[j2];
        
        if ((i != i2) && (i != j2) &&
            (j != i2) && (j != j2)) {
          
          intersectionPoint = intersect_segmentXsegment(A, B, A2, B2);
          
          if (false == is_undefined_FLOAT(intersectionPoint[0])) {
            int[][] startList = (int[][]) subset(allDiagonals, 0, q);
            int[][] endList = (int[][]) subset(allDiagonals, q + 1);
            allDiagonals = (int[][]) concat(startList, endList); // remove this diagonal
          }
        }
        
      }
    }

    
    int[][] faces = new int[1][n];
    for (k = 0; k < n; k++) {
      faces[0][n] = k;
    }
    
    int vertexID;
    
    for (k = 0; k < allDiagonals.length; k++) { 
      int v1 = allDiagonals[k][0]; // start
      int v2 = allDiagonals[k][1]; // end
      
      int ID_1st = -1;
      int ID_2nd = -1;
      for (i = 0; i < faces.length; i++) {
        
        if (faces[i].length > maximumDegree) { 
        
          for (j = 0; j < faces[i].length; j++) {
            vertexID = faces[i][j];
                 if (v1 == vertexID) ID_1st = j;
            else if (v2 == vertexID) ID_2nd = j;
          }
          
          if ((-1 != ID_1st) && (-1 != ID_2nd)) { 
            // we found the face to devide by the diagonal

            int[][] newFace1 = new int[0][0];
            int[][] newFace2 = new int[0][0]; 
            
            for (j = 0; j < faces[i].length; j++) {
              vertexID = faces[i][j];
              
              int[][] newItem = {{vertexID}};
              
              if ((j <= ID_1st) || (j >= ID_2nd)) {
                newFace1 = (int[][]) concat(newFace1, newItem); // pushing vertexID
              }
              
              if ((j >= ID_1st) && (j <= ID_2nd)) {
                newFace2 = (int[][]) concat(newFace2, newItem); // pushing vertexID
              }

            }
            
            int[][] startList = (int[][]) subset(faces, 0, i);
            int[][] endList = (int[][]) subset(faces, i + 1);
            faces = (int[][]) concat(startList, endList); // remove this face
            
            faces = (int[][]) concat(faces, newFace1); // pushing 1st new face
            faces = (int[][]) concat(faces, newFace2); // pushing 2st new face
            i--; // since we added 2 faces and removed one
            break; 
          }
        }
      }
    }
      
    return faces;
  }

  
}

solarchvision_Functions funcs = new solarchvision_Functions(); 





















class solarchvision_TIME {
  
  private final static String CLASS_STAMP = "TIME";
  
  private int modelRun = 0; //12; 
  
  private int hour = this.modelRun; //hour(); 
  private int year = year(); 
  private int month = 1; //month();
  private int day = 21; //day(); 
  
  private int beginDay;
  private float date;    
  
  final int interval = 1; //dT


  final String[][] WORDS = {
    {
      "", ""
    }
    , 
    {
      "at hour", "à l'heure"
    }
    , 
    {
      "day", "jour"
    }
    , 
    {
      "month", "mois"
    }
    , 
    {
      "year", "année"
    }
    , 
    {
      "date", "date"
    }
  };   

  
  final String[][] namesOfMonths = {
    {
      "January", "janvier"
    }
    , 
    {
      "February", "février"
    }
    , 
    {
      "March", "mars"
    }
    , 
    {
      "April", "avril"
    }
    , 
    {
      "May", "mai"
    }
    , 
    {
      "June", "juin"
    }
    , 
    {
      "July", "juillet"
    }
    , 
    {
      "August", "août"
    }
    , 
    {
      "September", "septembre"
    }
    , 
    {
      "October", "octobre"
    }
    , 
    {
      "November", "novembre"
    }
    , 
    {
      "December", "décembre"
    }
  };
  
  private final int[] lengthOfMonths = {
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  };
  
  private int[] monthFromDate = new int [365];
  private int[] dayFromDate = new int [365];
  private String[] MM = new String [365];
  private String[] MMDD = new String [365];
  private String[][] dayOfYear = new String [365][numberOfLanguages];
  
  int safeDate(float date_IN) {
    return floor(0.001 + (365 + date_IN) % 365); 
  }

  int getMonth_fromDate(float date_IN) {
     return this.monthFromDate[safeDate(date_IN)];
  }
    
  int getDay_fromDate(float date_IN) {
     return this.dayFromDate[safeDate(date_IN)];
  }

  String getDayText(float date_IN) {
    return this.dayOfYear[safeDate(date_IN)][Language_Active];
  }
  
  String getMMDD(float date_IN) {
    return this.MMDD[safeDate(date_IN)];
  }  
  
  String getMM(float date_IN) {
    return this.MM[safeDate(date_IN)];
  }    
  
  solarchvision_TIME () { // constructor
    this.createCalendar();
  }

  void createCalendar () {
    int k = 285;
    
    for (int i = 0; i < 12; i++) {
      for (int j = 0; j < this.lengthOfMonths[i]; j++) {
        k += 1;
        if (k == 365) k = 0; 

        this.monthFromDate[k] = i + 1;
        this.dayFromDate[k] = j + 1;
        
        this.MM[k] = nf(i + 1, 2);
        this.MMDD[k] = nf(i + 1, 2) + nf(j + 1, 2);
        
        for (int l = 0; l < numberOfLanguages; l++) {
          this.dayOfYear[k][l] = this.namesOfMonths[i][l] + " " + nf(j + 1, 0);
        }
      }
    }
  }
  
  int convert2Day (int Date_Angle) {
    int DAY = (Date_Angle + 360) % 360;
    if (DAY >=  31) DAY++;
    if (DAY >=  62) DAY++;
    if (DAY >=  93) DAY++;
    if (DAY >= 124) DAY++;
    if (DAY >= 155) DAY++;
    DAY = DAY % 365;
    return DAY;
  }
  
  int convert2Date (int month, int day) {
    int k = 0;
    for (int i = 0; i < (month - 1); i++) {
      for (int j = 0; j < this.lengthOfMonths[i]; j++) {
        k += 1;
        if (k == 365) k = 0;
      }
    }
    k += day - 1;
  
    k = k % 365;
    return k;
  }
  
  void updateDate () {
    this.month = this.getMonth_fromDate(this.date); 
    this.day = this.getDay_fromDate(this.date);
    this.hour = int(24 * (this.date - int(this.date)));
  }
  

  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
  
    parent.setInt("modelRun", this.modelRun);
    parent.setInt("year", this.year);
    parent.setInt("month", this.month);
    parent.setInt("day", this.day); 
    parent.setInt("hour", this.hour); 
    parent.setInt("beginDay", this.beginDay);
    parent.setFloat("date", this.date);
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.modelRun = parent.getInt("modelRun"); 
    this.year = parent.getInt("year");
    this.month = parent.getInt("month");
    this.day = parent.getInt("day"); 
    this.hour = parent.getInt("hour"); 
    this.beginDay = parent.getInt("beginDay");
    this.date = parent.getFloat("date");
  }      

}

solarchvision_TIME TIME = new solarchvision_TIME(); 









// please define station elevation data for CWEEDS points!



String SceneName = "Complex";




String[] Files_CLIMATE_TMYEPW;
String[] Files_CLIMATE_CWEEDS;
String[] Files_CLIMATE_CLMREC;
String[] Files_ENSEMBLE_OBSERVED;
String[] Files_ENSEMBLE_FORECAST;



String Folder_CLIMATE_TMYEPW;
String Folder_CLIMATE_CWEEDS;
String Folder_CLIMATE_CLMREC;
String Folder_ENSEMBLE_OBSERVED;
String Folder_ENSEMBLE_FORECAST;
String Folder_GRIB2;
String Folder_GEOMET;

String Folder_Wgrib2Temp;

String Folder_Backgrounds;
String Folder_Coordinates;


String Folder_Land;
String Folder_People;
String Folder_Trees;
String Folder_Export;
String Folder_Project;
String Folder_Graphics;
String Folder_Model3Ds;
String Folder_ViewsFromSky;
String Folder_ScreenShots;
String Folder_Shadings;

String SOLARCHVISION_version = "2018"; 
//String BaseFolder = "C:/SOLARCHVISION_" + SOLARCHVISION_version; 
String BaseFolder = "C:/SOLARCHVISION_2017";

String RunStamp = nf(year(), 4) + nf(month(), 2) + nf(day(), 2) + "_" + nf(hour(), 2);
String ProjectName = "Revision_" + RunStamp;
String HoldStamp = ""; 

String Subfolder_exportMaps = "maps/";

void SOLARCHVISION_update_folders () {
  
  Folder_Project = BaseFolder + "/Projects/Esfahan";    
  
  Folder_Wgrib2Temp = Folder_Project + "/Temp";

  Folder_GEOMET = Folder_Project + "/Data/GEOMET" + "/" + RunStamp;
  Folder_GRIB2 = Folder_Project + "/Data/GRIB2";
  
  Folder_ENSEMBLE_FORECAST = Folder_Project + "/Data/FORECAST_NAEFS";
  Folder_ENSEMBLE_OBSERVED = Folder_Project + "/Data/OBSERVATION_SWOB";

  Folder_CLIMATE_CLMREC = BaseFolder + "/Input/Climate/CLIMATE_CLMREC";
  Folder_CLIMATE_TMYEPW = BaseFolder + "/Input/Climate/CLIMATE_EPW_WORLD";
  Folder_CLIMATE_CWEEDS = BaseFolder + "/Input/Climate/CLIMATE_CWEED";
  
  Files_CLIMATE_CLMREC = OPESYS.getFiles(Folder_CLIMATE_CLMREC);
  Files_CLIMATE_TMYEPW = OPESYS.getFiles(Folder_CLIMATE_TMYEPW);
  Files_CLIMATE_CWEEDS = OPESYS.getFiles(Folder_CLIMATE_CWEEDS);
  
  Files_ENSEMBLE_OBSERVED = OPESYS.getFiles(Folder_ENSEMBLE_OBSERVED);
  Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST);  

  Folder_Backgrounds      = BaseFolder + "/Input/BackgroundImages/Standard/Other";
  Folder_Coordinates      = BaseFolder + "/Input/CoordinateFiles/LocationInfo";
  WORLD.ViewFolder      = BaseFolder + "/Input/BackgroundImages/Standard/World";
  
  Folder_People = BaseFolder + "/Input/BackgroundImages/Standard/Maps/People";
  Folder_Trees  = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Trees";
  
  Folder_Shadings = Folder_Project + "/ShadingAnalysis";
  
  Folder_Land         = Folder_Project + "/Land/USE";
  
  Folder_Export       = Folder_Project + "/Export";
  Folder_Graphics     = Folder_Export + "/graphics" + "/" + RunStamp;
  Folder_Model3Ds      = Folder_Export + "/allModel3Ds" + "/" + RunStamp;
  Folder_ViewsFromSky = Folder_Export + "/ViewsFromSky" + "/" + RunStamp;
  Folder_ScreenShots   = Folder_Export + "/ScreenShots" + "/" + RunStamp;

  String[] filenames = OPESYS.getFiles(Folder_ScreenShots);
  if (filenames != null) SavedScreenShots = filenames.length;
  
}




















String[] skyScenario_Title = {
  "", "", "[66% < Total Cloud Cover]", "[33% < Total Cloud Cover < 66%]", "[Total Cloud Cover < 33%]"
};
String[] skyScenario_FileTXT = {
  "", "", "Overcast sky", "Scattered sky", "Clear sky"
};

final int filter_HOURLY = 0;
final int filter_DAILY = 1;

int IMPACTS_displayDay = 0; // 0:total 1:day-1 2:day-2 etc.

final int numberOfLanguages = 2;
final int Language_EN = 0;
final int Language_FR = 1;
int Language_Active = Language_EN;


final float FLOAT_huge = 1000000000;
final float FLOAT_tiny = 0.05; // don't use very tiny values that could result is shading problems at the intersection of faces

final String STRING_undefined = "N/A";
final float FLOAT_undefined = 2000000000; // it must be a positive big number that is not included in any data
final float FLOAT_max_defined = 0.95 * FLOAT_undefined;

boolean is_undefined_FLOAT (float a) {
  boolean b = false;
  if (a > FLOAT_max_defined) {
    b = true; 
  }
  return b;
}


int numberOfLayers = 0;

class solarchvision_LAYER {
  
  private final static String CLASS_STAMP = "LAYER";
  
  public int id;  
  
  public String unit = "";
  public String name = "";
  public String[] descriptions = new String [numberOfLanguages];

  public float V_scale = 1;
  public float V_offset = 0;
  public float V_belowLine = 0;  
  
  solarchvision_LAYER (float V_scale, float V_offset, float V_belowLine, String unit, String description_EN, String description_FR, String name) {
    
    this.V_scale = V_scale;
    this.V_offset = V_offset;
    this.V_belowLine = V_belowLine;
    this.unit = unit;
    this.name = name;
    this.descriptions[Language_EN] = description_EN;
    this.descriptions[Language_FR] = description_FR;
    
    this.id = numberOfLayers;
    numberOfLayers++; 
  }
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP + "_" + nf(this.id, 0));
    
    XML parent = xml.addChild(this.CLASS_STAMP + "_" + nf(this.id, 0));
    
    parent.setInt("id", this.id);
    
    parent.setString("unit", this.unit);
    parent.setString("name", this.name);
    parent.setString("description_EN", this.descriptions[Language_EN]);
    parent.setString("description_FR", this.descriptions[Language_FR]);
    
    parent.setFloat("V_scale", this.V_scale);
    parent.setFloat("V_offset", this.V_offset);
    parent.setFloat("V_belowLine", this.V_belowLine);
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP + "_" + nf(this.id, 0));
  
    XML parent = xml.getChild(this.CLASS_STAMP + "_" + nf(this.id, 0));

    this.id = parent.getInt("id");
    
    this.unit = parent.getString("unit");
    this.name = parent.getString("name");
    this.descriptions[Language_EN] = parent.getString("description_EN");
    this.descriptions[Language_FR] = parent.getString("description_FR");
    
    this.V_scale = parent.getFloat("V_scale");
    this.V_offset = parent.getFloat("V_offset");
    this.V_belowLine = parent.getFloat("V_belowLine");
  }      
  
  
}

solarchvision_LAYER LAYER_windspd200hPa = new solarchvision_LAYER(
  0.5,
  0,
  0,
  "knots",
  "Wind Speed at 200 hPa",
  "Vitesse du vent à 200 hPa",  
  "WIND-200HPA"
);

solarchvision_LAYER LAYER_thicknesses_1000_500 = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotentiel Difference",
  "Différence de géopotentiel",
  "PARAMETERS-1000-500HPA"
);


solarchvision_LAYER LAYER_heightp500hPa = new solarchvision_LAYER(
  1,
  -500,
  1,
  "dam",
  "Geopotential at 500 hPa",
  "Géopotentiel à 500 hPa",
  "HGT-500HPA"
); 

solarchvision_LAYER LAYER_ceilingsky = new solarchvision_LAYER(
  0.01,
  0,
  0,
  "m",
  "Ceiling height",
  "Hauteur sous plafond",  
  ""
);


solarchvision_LAYER LAYER_cloudcover = new solarchvision_LAYER(
  10.0,
  0,
  0,
  "tenth",
  "Total Cloud Cover",
  "Couvert nuageux total",
  "TCDC"
); 

solarchvision_LAYER LAYER_winddir = new solarchvision_LAYER(
  100.0 / 360.0,
  0,
  0,
  "°",
  "Surface Wind Direction",
  "Direction du vent à la surface",
  "WDIR-SFC"
); 

solarchvision_LAYER LAYER_windspd = new solarchvision_LAYER(
  2.5,
  0,
  0,
  "km/h",
  "Surface Wind Speed",
  "Vitesse du vent à la surface",
  "WIND-SFC"
); 

solarchvision_LAYER LAYER_pressure = new solarchvision_LAYER(
  2.0,
  -1000,
  1,
  "hPa",
  "Mean Sea level Pressure",
  "Pression moyenne au niveau de la mer",
  "MSLP"
); 

solarchvision_LAYER LAYER_drybulb = new solarchvision_LAYER(
  2.5,
  0,
  1,
  "°C",
  "Surface Air Temperature",
  "Température de l'air à la surface",
  "TMP-SFC"
); 

solarchvision_LAYER LAYER_relhum = new solarchvision_LAYER(
  1.0,
  0,
  0,
  "%",
  "Surface Relative Humidity",
  "Humidité relative à la surface",
  "RELH-SFC"
); 

solarchvision_LAYER LAYER_dirnorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Direct normal radiation",
  "Rayonnement direct normal",
  ""
);

solarchvision_LAYER LAYER_difhorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Diffuse horizontal radiation",
  "Diffus rayonnement horizontal",
  ""
); 

solarchvision_LAYER LAYER_glohorrad = new solarchvision_LAYER(
  0.1,
  0,
  0,
  "W/m²",
  "Global horizontal radiation",
  "Rayonnement global horizontal",
  ""
); 

solarchvision_LAYER LAYER_direffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Direct normal effect <18°C<",
  "Effet direct normal <18°C<",
  ""
); 

solarchvision_LAYER LAYER_difeffect = new solarchvision_LAYER(
  0.0025,
  0,
  1,
  "W°C/m²",
  "Diffuse normal effect <18°C<",
  "Effet diffus normal <18°C<",
  ""
); 

solarchvision_LAYER LAYER_precipitation = new solarchvision_LAYER(
  4.0,
  0,
  0,
  "mm",
  "Surface Accumulated Precipitation",
  "Précipitations accumulées à la surface",
  "APCP-SFC"
); 

solarchvision_LAYER LAYER_developed = new solarchvision_LAYER(
  1,
  0,
  0,
  "",
  "",
  "",
  ""
); 




solarchvision_LAYER[] allLayers = { 
  LAYER_windspd200hPa,
  LAYER_thicknesses_1000_500,
  LAYER_heightp500hPa,
  LAYER_ceilingsky,
  LAYER_cloudcover,
  LAYER_winddir,
  LAYER_windspd,
  LAYER_pressure,
  LAYER_drybulb,
  LAYER_relhum,
  LAYER_dirnorrad,
  LAYER_difhorrad,
  LAYER_glohorrad,
  LAYER_direffect,
  LAYER_difeffect,
  LAYER_precipitation,
  LAYER_developed
};


int DevelopLayer_id = 0;
int CurrentLayer_id = 0;
String CurrentLayer_unit = allLayers[0].unit;
String CurrentLayer_name = allLayers[0].name;
String[] CurrentLayer_descriptions = {allLayers[0].descriptions[Language_EN], 
                                      allLayers[0].descriptions[Language_FR]};

void changeCurrentLayerTo (int new_id) {
 
  int pre_id = CurrentLayer_id;

  allLayers[pre_id].V_scale = STUDY.V_scale;
  allLayers[pre_id].V_offset = STUDY.V_offset;
  allLayers[pre_id].V_belowLine = STUDY.V_belowLine;
  
  STUDY.V_scale = allLayers[new_id].V_scale;
  STUDY.V_offset = allLayers[new_id].V_offset;
  STUDY.V_belowLine = allLayers[new_id].V_belowLine;

  DevelopLayer_id = new_id;
  CurrentLayer_id = new_id;
  
  CurrentLayer_unit = allLayers[new_id].unit; 
  CurrentLayer_name = allLayers[new_id].name;
  CurrentLayer_descriptions[Language_EN] = allLayers[new_id].descriptions[Language_EN];
  CurrentLayer_descriptions[Language_FR] = allLayers[new_id].descriptions[Language_FR];
  
}


















int ENSEMBLE_FORECAST_maxDays = 16; // Constant
int ENSEMBLE_OBSERVED_maxDays = 3; // Variable


int CLIMATE_TMYEPW_start = 1; 
int CLIMATE_TMYEPW_end = 1;

int CLIMATE_CWEEDS_start = 1953;
int CLIMATE_CWEEDS_end = 2005;

int CLIMATE_CLMREC_start = 2000;
int CLIMATE_CLMREC_end = year();

int ENSEMBLE_FORECAST_start = 1; 
int ENSEMBLE_FORECAST_end = 43; // NAEFS:1-43, Note we will append REPS/HRDPS or other scenarions at the end  of this list

int ENSEMBLE_OBSERVED_numNearest = 3;  // <<<<<<<<

int ENSEMBLE_OBSERVED_start = 1; 
int ENSEMBLE_OBSERVED_end = ENSEMBLE_OBSERVED_numNearest;

int[] nearest_Station_ENSEMBLE_OBSERVED_id = new int [ENSEMBLE_OBSERVED_numNearest];
float[] nearest_Station_ENSEMBLE_OBSERVED_dist = new float [ENSEMBLE_OBSERVED_numNearest];

int nearest_Station_CLMREC_id = -1;
float nearest_Station_CLMREC_dist = FLOAT_undefined;



int SampleYear_Start = 1980; 
int SampleYear_End = year(); 

int SampleMember_Start = 1;
int SampleMember_End = 43;

int SampleStation_Start = 1; 
int SampleStation_End = ENSEMBLE_OBSERVED_numNearest;

float[][][][] CLIMATE_TMYEPW_values;
boolean[][][][] CLIMATE_TMYEPW_flags;

float[][][][] CLIMATE_CWEEDS_values;
boolean[][][][] CLIMATE_CWEEDS_flags;

float[][][][] CLIMATE_CLMREC_values;
boolean[][][][] CLIMATE_CLMREC_flags;

float[][][][] ENSEMBLE_FORECAST_values;
boolean[][][][] ENSEMBLE_FORECAST_flags;

float[][][][] ENSEMBLE_OBSERVED_values;
boolean[][][][] ENSEMBLE_OBSERVED_flags;




boolean CLIMATE_TMYEPW_load = true;
boolean CLIMATE_CWEEDS_load = false;
boolean CLIMATE_CLMREC_load = false;
boolean ENSEMBLE_FORECAST_load = false;
boolean ENSEMBLE_OBSERVED_load = false;


int GRIB2_Year; 
int GRIB2_Month; 
int GRIB2_Day; 
int GRIB2_ModelRun;

int AERIAL_num = 4 * (1 + 6 + 12); // the number of nearest points on the path we want to extract the data 

float AERIAL_Center_Longitude = FLOAT_undefined;
float AERIAL_Center_Latitude = FLOAT_undefined;

float[][] AERIAL_Locations;

float[][][][] AERIAL_Data;
int[][][][] AERIAL_Flags;

int GRIB2_Hour_Start = 0;
int GRIB2_Hour_End = 30; //48;
int GRIB2_Hour_Step = 1; //1;

int GRIB2_Layer_Start = 4; //_cloudcover;
int GRIB2_Layer_End = 8; //_drybulb;
int GRIB2_Layer_Step = 1;

int GRIB2_Hour;
int GRIB2_Layer;




String[][] GRIB2_Domains = {
  {
    "GEPS", "ensemble/naefs/grib2/raw", "CMC_naefs-geps-raw", "latlon1p0x1p0", "_allmbrs.grib2", "100"
  }
  , {
    "REPS", "ensemble/reps/15km/grib2/raw", "CMC-reps-srpe-raw", "ps15km", "_allmbrs.grib2", "15"
  }
  , {
    "GDPS", "model_gem_global/25km/grib2/lat_lon", "CMC_glb", "latlon.24x.24", ".grib2", "20"
  }
  , {
    "RDPS", "model_gem_regional/10km/grib2", "CMC_reg", "ps10km", ".grib2", "10"
  }
  , {
    "HRDPS", "model_hrdps/east/grib2", "CMC_hrdps_east", "ps2.5km", "-00.grib2", "2.5"
  } 
  , {
    "RDWPS", "model_wave/great_lakes/superior/grib2", "CMC_rdwps_lake-superior", "latlon0.05x0.08", ".grib2", "5"
  }
};


//int GRIB2_DomainSelection = 0; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!   
//int GRIB2_DomainSelection = 1; int GRIB2_maxScenarios = 21; // should convert U&V to wind speed and direction!
//int GRIB2_DomainSelection = 2; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 3; int GRIB2_maxScenarios = 1;
int GRIB2_DomainSelection = 4; int GRIB2_maxScenarios = 1;
//int GRIB2_DomainSelection = 5; int GRIB2_maxScenarios = 1; // not working now!

{
  ENSEMBLE_FORECAST_end += GRIB2_maxScenarios;
}


int AERIAL_graphOption = 0; 




final int DEV_OP_00 = 8;
final int DEV_OP_01 = 6;
final int DEV_OP_02 = 5;
final int DEV_OP_03 = 7;
final int DEV_OP_04 = 4;
final int DEV_OP_05 = 3;
final int DEV_OP_06 = 10;
final int DEV_OP_07 = 9;
final int DEV_OP_08 = 11;
final int DEV_OP_09 = 0;
final int DEV_OP_10 = 1;
final int DEV_OP_11 = 2;

int Develop_Option = DEV_OP_06; //between 0 - 11...
int Develop_DayHour = 0; //0:accumulative 1:daily(24h) 2:per12h 3:per6h <should be zero to work well with current menues> 

boolean DevelopData_update = true;












float Develop_AngleInclination = 45; // 90 = horizontal surface, 0 = Vertical surface 
float Develop_AngleOrientation = 0; // 0 = South, 90 = East



























class solarchvision_STATION {

  private final static String CLASS_STAMP = "STATION";
  
  private float elevation = 0;
  private float latitude = 0;
  private float longitude = 0;
  private float timelong = 0;
  private String code = "";  
  private String city = "";
  private String province = "";
  private String country = "";
  private String filename_NAEFS = "";
  private String filename_CWEEDS = "";
  private String filename_TMYEPW = "";


  public float getElevation () { return this.elevation; } 
  public float getLatitude () { return this.latitude; }
  public float getLongitude () { return this.longitude; } 
  public float getTimelong () { return this.timelong; }
  public String getCode () { return this.code; }  
  public String getCity () { return this.city; } 
  public String getProvince () { return this.province; } 
  public String getCountry () { return this.country; }
  public String getFilename_NAEFS () { return this.filename_NAEFS; }
  public String getFilename_CWEEDS () { return this.filename_CWEEDS; }
  public String getFilename_TMYEPW () { return this.filename_TMYEPW; } 

  
  public void setElevation (float elevation) {
    this.elevation = elevation;
  }
  public void setLatitude (float latitude) {
    this.latitude = latitude;
  }
  public void setLongitude (float longitude) {
    this.longitude = longitude;
  }
  public void setTimelong (float timelong) {
    this.timelong = timelong;
  }
  public void setCode (String code) {
    this.code = code;
  }  
  public void setCity (String city) {
    this.city = city;
  }
  public void setProvince (String province) {
    this.province = province;
  }
  public void setCountry (String country) {
    this.country = country;
  }
  public void setFilename_NAEFS (String filename_NAEFS) {
    this.filename_NAEFS = filename_NAEFS;
  }
  public void setFilename_CWEEDS (String filename_CWEEDS) {
    this.filename_CWEEDS = filename_CWEEDS;
  }
  public void setFilename_TMYEPW (String filename_TMYEPW) {
    this.filename_TMYEPW = filename_TMYEPW;
  }  

  public solarchvision_STATION () {
    
  }  
  
  public solarchvision_STATION (String code, String city, String province, String Country, 
                         float latitude, float longitude, float timelong, float elevation, 
                         String filename_NAEFS, String filename_CWEEDS, String filename_TMYEPW) {
  
    this.code = code;
    this.city = city;
    this.province = province;
    this.country = country;
    
    this.filename_NAEFS = filename_NAEFS;
    this.filename_CWEEDS = filename_CWEEDS;
    this.filename_TMYEPW = filename_TMYEPW;
    
    this.elevation = elevation;
    this.latitude = latitude;
    this.longitude = longitude;
    this.timelong = timelong;
  }
  
  
  public void to_XML (XML xml) {
    
    XML child = xml.addChild(this.CLASS_STAMP);
    
    child.setString("code", this.getCode());
    child.setString("city", this.getCity());
    child.setString("province", this.getProvince());
    child.setString("country", this.getCountry());

    child.setFloat("elevation", this.getElevation());
    child.setFloat("latitude", this.getLatitude());
    child.setFloat("longitude", this.getLongitude());
    child.setFloat("timelong", this.getTimelong());
    
    child.setString("filename_NAEFS", this.getFilename_NAEFS());
    child.setString("filename_CWEEDS", this.getFilename_CWEEDS());
    child.setString("filename_TMYEPW", this.getFilename_TMYEPW());
  }
  
  
  public void from_XML (XML xml) {
    
    XML child = xml.getChild(this.CLASS_STAMP);
    
    this.setCode(child.getString("code"));
    this.setCity(child.getString("city"));
    this.setProvince(child.getString("province"));
    this.setCountry(child.getString("country"));

    this.setElevation(child.getFloat("elevation"));
    this.setLatitude(child.getFloat("latitude"));
    this.setLongitude(child.getFloat("longitude"));
    this.setTimelong(child.getFloat("timelong"));
    
    this.setFilename_NAEFS(child.getString("filename_NAEFS"));
    this.setFilename_CWEEDS(child.getString("filename_CWEEDS"));
    this.setFilename_TMYEPW(child.getString("filename_TMYEPW"));    
  }  
}

solarchvision_STATION STATION = new solarchvision_STATION(

  //"", "Roodbar", "XX", "IR", 36.826, 49.426, 52.5, 194, "", "", "IRN_Rasht_YY_IR"

  "", "Esfahan", "ZZ", "IR", 32.617, 51.667, 52.5, 1590, "", "", "IRN_Esfahan_ZZ_IR"
  
);
  









solarchvision_STATION[] TMYEPW_Coordinates;

void inputCoordinates_TMYEPW () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/EPW_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  TMYEPW_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, ',');
    
    TMYEPW_Coordinates[f] = new solarchvision_STATION(); 

    TMYEPW_Coordinates[f].setCity(parts[1]);
    TMYEPW_Coordinates[f].setProvince(parts[2]);
    TMYEPW_Coordinates[f].setCountry(parts[3]);
    TMYEPW_Coordinates[f].setLatitude(float(parts[6]));
    TMYEPW_Coordinates[f].setLongitude(float(parts[7]));
    TMYEPW_Coordinates[f].setTimelong(float(parts[8]) * 15);
    TMYEPW_Coordinates[f].setElevation(float(parts[9]));
    TMYEPW_Coordinates[f].setFilename_TMYEPW(parts[10]);
  }
}


  
  
solarchvision_STATION[] CWEEDS_coordinates;

void inputCoordinates_CWEEDS () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/CWEEDS_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  CWEEDS_coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '_');

    float latitude = float(parts[2]) * 0.01;
    float longitude = float(parts[3]) * -0.01;
    
    CWEEDS_coordinates[f] = new solarchvision_STATION(); 

    CWEEDS_coordinates[f].setCity(parts[1]);
    CWEEDS_coordinates[f].setProvince(parts[0]);
    CWEEDS_coordinates[f].setCountry("CA");
    CWEEDS_coordinates[f].setLatitude(latitude);
    CWEEDS_coordinates[f].setLongitude(longitude);
    CWEEDS_coordinates[f].setTimelong(funcs.roundTo(longitude, 15));
    CWEEDS_coordinates[f].setElevation(0); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ??
    CWEEDS_coordinates[f].setFilename_CWEEDS(lineSTR);
  }
}






solarchvision_STATION[] CLMREC_Coordinates;

void inputCoordinates_CLMREC () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/CLMREC_UTF8_EN.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  CLMREC_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, ',');
    
    CLMREC_Coordinates[f] = new solarchvision_STATION(); 

    float latitude = float(parts[6]);
    float longitude = float(parts[7]);

    CLMREC_Coordinates[f].setCity(parts[0].replace('/', '_'));
    CLMREC_Coordinates[f].setProvince(parts[1]);
    CLMREC_Coordinates[f].setCountry("CA");
    CLMREC_Coordinates[f].setLatitude(latitude);
    CLMREC_Coordinates[f].setLongitude(longitude);
    CLMREC_Coordinates[f].setTimelong(funcs.roundTo(longitude, 15));
    CLMREC_Coordinates[f].setElevation(float(parts[10]));
    //CLMREC_Coordinates[f].setFilename_CLMREC(?);
  }
}




solarchvision_STATION[] SWOB_Coordinates;

void inputCoordinates_SWOB () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/SWOB_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  SWOB_Coordinates = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '\t');
    
    float latitude = float(parts[5]);
    float longitude = float(parts[6]);    
    
    SWOB_Coordinates[f] = new solarchvision_STATION(); 

    String code = parts[8];
    if (parts[4].equals("Manned")) code += "-MAN";
    if (parts[4].equals("Auto")) code += "-AUTO";

    SWOB_Coordinates[f].setCode(code);
    SWOB_Coordinates[f].setCity(parts[2]);
    SWOB_Coordinates[f].setProvince(parts[3]);
    SWOB_Coordinates[f].setCountry("CA");
    SWOB_Coordinates[f].setLatitude(latitude);
    SWOB_Coordinates[f].setLongitude(longitude);
    SWOB_Coordinates[f].setTimelong(funcs.roundTo(longitude, 15));
    SWOB_Coordinates[f].setElevation(float(parts[7]));
    //SWOB_Coordinates[f].setFilename_SWOB(?);
    
  }
}








solarchvision_STATION[] NAEFposition_Ts;

void inputCoordinates_NAEFS () {

  String[] FileALL = loadStrings(Folder_Coordinates + "/NAEFS_UTF8.txt");

  String lineSTR;

  int num_stn = FileALL.length - 1; // to skip the first description line 

  NAEFposition_Ts = new solarchvision_STATION [num_stn]; 

  for (int f = 0; f < num_stn; f++) {
    lineSTR = FileALL[f + 1]; // to skip the first description line  

    String[] parts = split(lineSTR, '\t');

    String filename = parts[0];

    String city = split(filename, '_')[0];
    String province = split(filename, '_')[1];
    String country = split(filename, '_')[2];

    float latitude = 0;
    float longitude = 0;
    float elevation = 0;

    int l = 0;

    l = parts[1].length();
    if (((parts[1].substring(l - 1, l)).equals("N")) || ((parts[1].substring(l - 1, l)).equals("S"))) {
      String[] the_parts = split(parts[1], ':');
      latitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[1].substring(l - 1, l)).equals("S")) latitude *= -1;
    } else {
      latitude = float(parts[1]);
    }

    l = parts[2].length();
    if (((parts[2].substring(l - 1, l)).equals("E")) || ((parts[2].substring(l - 1, l)).equals("W"))) {
      String[] the_parts = split(parts[2], ':');
      longitude = float(the_parts[0]) + (float(the_parts[1]) / 60.0) + (float(the_parts[2]) / 3600.0);
      if ((parts[2].substring(l - 1, l)).equals("W")) longitude *= -1;
    } else {
      longitude = float(parts[2]);
    }

    l = parts[3].length();
    elevation = float(parts[3].substring(0, l - 1));
    
    
    NAEFposition_Ts[f] = new solarchvision_STATION(); 

    NAEFposition_Ts[f].setCity(city);
    NAEFposition_Ts[f].setProvince(province);
    NAEFposition_Ts[f].setCountry(country);
    NAEFposition_Ts[f].setLatitude(latitude);
    NAEFposition_Ts[f].setLongitude(longitude);
    NAEFposition_Ts[f].setTimelong(funcs.roundTo(longitude, 15));
    NAEFposition_Ts[f].setElevation(elevation);
    NAEFposition_Ts[f].setFilename_NAEFS(filename);
  }
}



void download_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  boolean new_files_downloaded = false;
  
  for (int f = 0; f < numberOfLayers; f++) {
    if (allLayers[f].name.equals("")) {
    } else {
      String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";
      
      String the_target = Folder_ENSEMBLE_FORECAST + "/" + FN;
      
      File dir = new File(the_target);
      if (!dir.isFile()) {
        
        String the_directory = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + nf(THE_HOUR, 2) + "/" + allLayers[f].name + "/raw";
        String the_link = "http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/xml/" + the_directory + "/" + FN + ".bz2";
        the_target = the_target + ".bz2";
    
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
    
          new_files_downloaded = true;
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }
  }



  if (new_files_downloaded) {
    
    String folder_inout = Folder_ENSEMBLE_FORECAST.replace('/', char(92));
    
    {
      String Command1 = "cmd /c \"\"C:\\Program Files (x86)\\7-Zip\\7z.exe\"\" e " + folder_inout + "\\*.bz2 -o" + folder_inout + " -y";
      println(Command1);
      String Command2 = "del " + folder_inout + "\\*.bz2 /q";
      println(Command2);
      launch(Command1 + " & " + Command2);
    }
    
    Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST);  
    
    ENSEMBLE_FORECAST_load = true;
    update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);    
  }
}


void update_ENSEMBLE_FORECAST (int THE_YEAR, int THE_MONTH, int THE_DAY, int THE_HOUR) {

  Files_ENSEMBLE_FORECAST = OPESYS.getFiles(Folder_ENSEMBLE_FORECAST); // slow <<<<<<<<<<<< this line didn't work well below... but it is rather slow here! 

  ENSEMBLE_FORECAST_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)];
  ENSEMBLE_FORECAST_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
          ENSEMBLE_FORECAST_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_FORECAST_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_FORECAST_load) {

    for (int f = 0; f < numberOfLayers; f++) {
      if (allLayers[f].name.equals("")) {
      } else {
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + nf(THE_HOUR, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + allLayers[f].name + "_000-384.xml";

        String the_source = Folder_ENSEMBLE_FORECAST + "/" + FN;

        File dir = new File(the_source);
        if (dir.isFile()) load_ENSEMBLE_FORECAST(the_source, f);
        else println("FILE NOT FOUND:", the_source);
      }
    }

    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);
    
    WORLD.displayAll_NAEFS = 1;
    WORLD.displayNear_NAEFS = true;     
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;    
  
  SampleMember_Start = ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;
}







void load_ENSEMBLE_FORECAST (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  int continue_process = 1;

  XML FileALL = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    FileALL = loadXML(FileName);
  }
  catch (Exception e) {
    println("Can't read:", FileName);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    //println(TIME.year, TIME.month, TIME.day, TIME.hour);

    XML[] children0 = FileALL.getChildren("forecast");

    for (int Li = 0; Li < children0.length; Li++) {

      int _a1 = children0[Li].getInt("forecast_hour");
      String _a2 = children0[Li].getString("valid_time");

      //println("Li=", Li, "hour =", _a1, "date:", _a2);

      if (Li >= 0) {

        int THE_YEAR = int(_a2.substring(0, 4));
        int THE_MONTH = int(_a2.substring(4, 6));
        int THE_DAY = int(_a2.substring(6, 8));
        int THE_HOUR = int(_a2.substring(8));

        //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

        int now_i = int(THE_HOUR);
        int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

        //println(now_i, now_j);

        now_i -= int(-STATION.getTimelong() / 15);
        if (now_i < 0) {
          now_i += 24;
          now_j -= 1;
          if (now_j < 0) {
            now_j += 365;
          }
        }

        //println(now_i, now_j);
        //println("-------------");

        XML[] _c = children0[Li].getChildren("model");
        //println("number of members:", _c.length);

        for (int Lk = 0; Lk < _c.length; Lk++) {
          int k = _c[Lk].getInt("id") - 1;

          if (k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start)) {

            ENSEMBLE_FORECAST_values[now_i][now_j][Load_Layer][k] = Float.valueOf(_c[Lk].getContent());
          }
        }
      }
    }
  }
}




void update_CLIMATE_CWEEDS () {

  CLIMATE_CWEEDS_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)];
  CLIMATE_CWEEDS_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start); k++) {
          CLIMATE_CWEEDS_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CWEEDS_flags[i][j][l][k] = false;
        }
      }
    }
  }


  if (CLIMATE_CWEEDS_load) {

    String FN = STATION.getFilename_CWEEDS() + ".wy2";
    
    String the_source = Folder_CLIMATE_CWEEDS + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_CWEEDS(the_source);
    else println("FILE NOT FOUND:", the_source);

  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;   
  
  SampleYear_Start = CLIMATE_CWEEDS_start;
  SampleYear_End = CLIMATE_CWEEDS_end;     
}


void load_CLIMATE_CWEEDS (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    int CLIMATE_YEAR = int(lineSTR.substring(6, 10));
    int CLIMATE_MONTH = int(lineSTR.substring(10, 12));
    int CLIMATE_DAY = int(lineSTR.substring(12, 14));
    int CLIMATE_HOUR = int(lineSTR.substring(14, 16));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CWEEDS_start);

    //println(i);

    CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = float(lineSTR.substring(85, 90)); // 10 times in Pa
    CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = float(lineSTR.substring(91, 95)); // 10 times in °C
    //CLIMATE_CWEEDS_values[i][j][LAYER_relhum.id][k] = 50; // Relative Humidity is not presented in DCLIMATE files!
    CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = float(lineSTR.substring(20, 24)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = float(lineSTR.substring(26, 30)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = float(lineSTR.substring(32, 36)); // Wh/m²
    CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = float(lineSTR.substring(105, 109)); // 10 times in m/s
    CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = float(lineSTR.substring(101, 104)); // °
    CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = float(lineSTR.substring(113, 115)); // 0.1 times in %
    CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = float(lineSTR.substring(61, 65)); // 0.1 times in m

    if (CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] == 99999) CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_pressure.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k] = 0.1 * CLIMATE_CWEEDS_values[i][j][LAYER_drybulb.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_glohorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_dirnorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] = CLIMATE_CWEEDS_values[i][j][LAYER_difhorrad.id][k] / 3.6; // Wh/m²

    if (CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k] = 0.1 * 3.6 * CLIMATE_CWEEDS_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_CWEEDS_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_CWEEDS_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 7777) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 1000; // <<<<<<<<<

    if (CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] == 9999) CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
    else CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k] = 10 * CLIMATE_CWEEDS_values[i][j][LAYER_ceilingsky.id][k];
  }
  
  SOLARCHVISION_setDataFlags(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CWEEDS);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_CWEEDS);
  
  WORLD.displayAll_CWEEDS = 1;
  WORLD.displayNear_CWEEDS = true;  

}







void download_CLIMATE_CLMREC () {
  
  if (nearest_Station_CLMREC_id != -1) {

    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {
      
        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;
    
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";
          
        String the_target = Folder_CLIMATE_CLMREC + "/" + FN;
          
        File dir = new File(the_target);
        if (!dir.isFile()) {          
          
          String the_link = "http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&stationID=" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCode() + "&Year=" + nf(THE_YEAR, 4) + "&Month=" + nf(THE_MONTH, 2) + "&timeframe=1";
          
          println("Try downloading: " + the_link);
    
          try {
            saveBytes(the_target, loadBytes(the_link));
          } 
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }
    
    Files_CLIMATE_CLMREC = OPESYS.getFiles(Folder_CLIMATE_CLMREC);
    
    CLIMATE_CLMREC_load = true;
    update_CLIMATE_CLMREC();
  }
}


void update_CLIMATE_CLMREC () {

  CLIMATE_CLMREC_values = new float [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)];
  CLIMATE_CLMREC_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
          CLIMATE_CLMREC_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_CLMREC_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_CLMREC_load) {

    nearest_Station_CLMREC_id = -1;
    nearest_Station_CLMREC_dist = FLOAT_undefined;
    
    for (int f = 0; f < CLMREC_Coordinates.length; f++) {
      
      //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016) 
      { // only use stations with this condition

        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_Station_CLMREC_dist > d) {
  
          nearest_Station_CLMREC_dist = d;
          nearest_Station_CLMREC_id = f;
        }
      }
    }


    for (int k = 0; k < (1 + CLIMATE_CLMREC_end - CLIMATE_CLMREC_start); k++) {
      for (int m = 0; m < 12; m++) {
      
        int THE_YEAR = k + CLIMATE_CLMREC_start;
        int THE_MONTH = m + 1;
    
        String FN = nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + "_" + CLMREC_Coordinates[nearest_Station_CLMREC_id].getCity() + ".csv";
        
        String the_source = Folder_CLIMATE_CLMREC + "/" + FN;
        
        File dir = new File(the_source);
        if (dir.isFile()) load_CLIMATE_CLMREC(the_source);
        else println("FILE NOT FOUND:", the_source);

      }
    }

    SOLARCHVISION_setDataFlags(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_fillGaps(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_CLIMATE_CLMREC);
    SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_CLMREC);
    
    WORLD.displayAll_CLMREC = 1;
    WORLD.displayNear_CLMREC = true;       
  
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true; 

  SampleYear_Start = CLIMATE_CLMREC_start;
  SampleYear_End = CLIMATE_CLMREC_end;  
}


void load_CLIMATE_CLMREC (String FileName) {

  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;

  println("lines = ", FileALL.length);

  for (int f = 18; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);
    
    lineSTR = lineSTR.replace("\"", ""); 
    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[1]);
    int CLIMATE_MONTH = int(parts[2]);
    int CLIMATE_DAY = int(parts[3]);
    int CLIMATE_HOUR = int(parts[4].substring(0, 2));

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR);
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = (CLIMATE_YEAR - CLIMATE_CLMREC_start);

    //println(i);
    
    if (parts.length > 24) {
      
      String str = "";
      
      str = parts[24];
      
      //println(str);
       
      if (str.equals("NA")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;
      else if (str.equals("Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 0;
      else if (str.equals("Mainly Clear")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 2.5;
      else if (str.equals("Mostly Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 5;
      else if (str.equals("Cloudy")) CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 7.5;
      else CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k] = 10;
      
      //println(CLIMATE_CLMREC_values[i][j][LAYER_cloudcover.id][k]);
    
      str = parts[6];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_drybulb.id][k] = float(str); // °C

      str = parts[10];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_relhum.id][k] = float(str); // %

      str = parts[12];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_winddir.id][k] = float(str) * 10; // °

      str = parts[14];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_windspd.id][k] = float(str); // km/h

      str = parts[18];
      if (!str.equals("")) CLIMATE_CLMREC_values[i][j][LAYER_pressure.id][k] = float(str) * 10; // hPa


    }
  }
  
}









void update_CLIMATE_TMYEPW () {

  CLIMATE_TMYEPW_values = new float [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)];
  CLIMATE_TMYEPW_flags = new boolean [24][365][numberOfLayers][(1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + CLIMATE_TMYEPW_end - CLIMATE_TMYEPW_start); k++) {
          CLIMATE_TMYEPW_values[i][j][l][k] = FLOAT_undefined;
          CLIMATE_TMYEPW_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (CLIMATE_TMYEPW_load) {

    String FN = STATION.getFilename_TMYEPW() + ".epw";

    String the_source = Folder_CLIMATE_TMYEPW + "/" + FN;

    File dir = new File(the_source);
    if (dir.isFile()) load_CLIMATE_TMYEPW(the_source);
    else println("FILE NOT FOUND:", the_source);

    WORLD.displayAll_TMYEPW = 1;
    WORLD.displayNear_TMYEPW = true; 

  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;    

}




void load_CLIMATE_TMYEPW (String FileName) {
  String[] FileALL = loadStrings(FileName);

  String lineSTR;
  String[] input;


  //println("lines = ", FileALL.length);

  for (int f = 8; f < FileALL.length; f++) {

    lineSTR = FileALL[f];

    String[] parts = split(lineSTR, ',');

    int CLIMATE_YEAR = int(parts[0]);
    int CLIMATE_MONTH = int(parts[1]);
    int CLIMATE_DAY = int(parts[2]);
    int CLIMATE_HOUR = int(parts[3]);

    //println(CLIMATE_YEAR, CLIMATE_MONTH, CLIMATE_DAY, CLIMATE_HOUR);

    int i = int(CLIMATE_HOUR) - 1;
    int j = TIME.convert2Date(CLIMATE_MONTH, CLIMATE_DAY);
    int k = 0; // on TMYEPW:TMY files we have only one year 

    //println(i);

    CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = float(parts[9]) * 0.01; // 10 times in Pa
    CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = float(parts[6]); // in °C
    CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = float(parts[8]); // 0 - 110%
    CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = float(parts[13]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = float(parts[14]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = float(parts[15]); // Wh/m²
    CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = float(parts[21]); // in m/s
    CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = float(parts[20]); // ° 
    CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = float(parts[23]); // 0.1 times in % ... there is also total_sky_cover on[22]
    CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = float(parts[25]); // in m


    if (CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] == 999999) CLIMATE_TMYEPW_values[i][j][LAYER_pressure.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] == 99.9) CLIMATE_TMYEPW_values[i][j][LAYER_drybulb.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_relhum.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] == 9999) CLIMATE_TMYEPW_values[i][j][LAYER_glohorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_dirnorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] >= 9999) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] < 0) CLIMATE_TMYEPW_values[i][j][LAYER_difhorrad.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = FLOAT_undefined;
    else CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k] = 3.6 * CLIMATE_TMYEPW_values[i][j][LAYER_windspd.id][k];

    if (CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] == 999) CLIMATE_TMYEPW_values[i][j][LAYER_winddir.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] == 99) CLIMATE_TMYEPW_values[i][j][LAYER_cloudcover.id][k] = FLOAT_undefined;

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 77777) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 88888) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000;
    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] >= 1000) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = 1000; 

    if (CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] == 99999) CLIMATE_TMYEPW_values[i][j][LAYER_ceilingsky.id][k] = FLOAT_undefined;
  }
  
  SOLARCHVISION_setDataFlags(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_solarEffects(dataID_CLIMATE_TMYEPW);
  SOLARCHVISION_postProcess_developDATA(dataID_CLIMATE_TMYEPW);
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;  
  
}



void download_ENSEMBLE_OBSERVED () {
  
  // this line tries to update the most recent files! << 
  int THE_YEAR = year(); 
  int THE_MONTH = month();
  int THE_DAY = day();
  int THE_HOUR = hour(); 


  float THE_DATE = TIME.date;

  int now_i = int(THE_HOUR);
  int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

  now_i += int(-STATION.getTimelong() / 15);
  if (now_i > 23) {
    now_i -= 24;
    now_j += 1;
    if (now_j > 364) {
      now_j -= 365;
      THE_YEAR += 1;
    }
    THE_DATE += 1;
    if (THE_DATE > 364) THE_DATE -= 365;
  }         
  THE_HOUR = now_i;

  for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

    THE_MONTH = TIME.getMonth_fromDate(THE_DATE); 
    THE_DAY = TIME.getDay_fromDate(THE_DATE);

    for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

      int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

      if (f != -1) {

        String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

        String the_target = Folder_ENSEMBLE_OBSERVED + "/" + FN;

        File dir = new File(the_target);
        if (!dir.isFile()) {       

          String the_link = "http://dd.weatheroffice.gc.ca/observations/swob-ml/" + nf(THE_YEAR, 4) + nf(THE_MONTH, 2) + nf(THE_DAY, 2) + "/" + split(SWOB_Coordinates[f].getCode(),'-')[0] + "/" + FN;
  
          println("Try downloading: " + the_link);
  
          try {
            saveBytes(the_target, loadBytes(the_link));
          } 
          catch (Exception e) {
            println("LINK NOT AVAILABLE:", the_link);
          }
        }
      }
    }

    now_i -= 1;
    if (now_i < 0) {
      now_i += 24;
      now_j -= 1;
      if (now_j < 0) {
        now_j += 365;
        THE_YEAR -= 1;
      }
      THE_DATE -= 1;
      if (THE_DATE < 0) THE_DATE += 364;
    }
    THE_HOUR = now_i;
  }
  

  Files_ENSEMBLE_OBSERVED = OPESYS.getFiles(Folder_ENSEMBLE_OBSERVED);
  
  ENSEMBLE_OBSERVED_load = true; 
  SOLARCHVISION_update_ENSEMBLE_OBSERVED();
}

void SOLARCHVISION_update_ENSEMBLE_OBSERVED () {

  ENSEMBLE_OBSERVED_values = new float [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)];
  ENSEMBLE_OBSERVED_flags = new boolean [24][365][numberOfLayers][(1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start)]; // true: direct input , false: no-input, interpolated or post-processed

  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + ENSEMBLE_OBSERVED_end - ENSEMBLE_OBSERVED_start); k++) {
          ENSEMBLE_OBSERVED_values[i][j][l][k] = FLOAT_undefined;
          ENSEMBLE_OBSERVED_flags[i][j][l][k] = false;
        }
      }
    }
  }

  if (ENSEMBLE_OBSERVED_load) {

    // this line tries to update the most recent files! << 
    int THE_YEAR = year(); 
    int THE_MONTH = month();
    int THE_DAY = day();
    int THE_HOUR = hour(); 


    float THE_DATE = TIME.date;

    int now_i = int(THE_HOUR);
    int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

    now_i += int(-STATION.getTimelong() / 15);
    if (now_i > 23) {
      now_i -= 24;
      now_j += 1;
      if (now_j > 364) {
        now_j -= 365;
        THE_YEAR += 1;
      }
      THE_DATE += 1;
      if (THE_DATE > 364) THE_DATE -= 365;
    }         
    THE_HOUR = now_i;

    for (int j_for = 0; j_for < ENSEMBLE_OBSERVED_maxDays * 24; j_for++) {

      THE_MONTH = TIME.getMonth_fromDate(THE_DATE); 
      THE_DAY = TIME.getDay_fromDate(THE_DATE);

      for (int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {

        int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];

        if (f != -1) {

          String FN = nf(THE_YEAR, 4) + "-" + nf(THE_MONTH, 2) + "-" + nf(THE_DAY, 2) + "-" + nf(THE_HOUR, 2) + "00-" + SWOB_Coordinates[f].getCode() + "-swob.xml";

          String the_source = Folder_ENSEMBLE_OBSERVED + "/" + FN;
      
          File dir = new File(the_source);
          if (dir.isFile()) load_ENSEMBLE_OBSERVED(the_source, q);
          else println("FILE NOT FOUND:", the_source);

        }
      }

      now_i -= 1;
      if (now_i < 0) {
        now_i += 24;
        now_j -= 1;
        if (now_j < 0) {
          now_j += 365;
          THE_YEAR -= 1;
        }
        THE_DATE -= 1;
        if (THE_DATE < 0) THE_DATE += 364;
      }
      THE_HOUR = now_i;
    }
    
    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_OBSERVED); // <<<<<<<<<<<<
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_OBSERVED);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_OBSERVED);
    
    WORLD.displayAll_SWOB = 1;
    WORLD.displayNear_SWOB = true;   
  }

  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;      
  
  SampleStation_Start = ENSEMBLE_OBSERVED_start;
  SampleStation_End = ENSEMBLE_OBSERVED_end;
}


void load_ENSEMBLE_OBSERVED (String FileName, int Load_Layer) {
  String lineSTR;
  String[] input;

  XML FileALL = loadXML(FileName);

  XML[] children0 = FileALL.getChildren("om:member");
  XML[] children1 = children0[0].getChildren("om:Observation");
  XML[] children2 = children1[0].getChildren("om:samplingTime");
  XML[] children3 = children2[0].getChildren("gml:TimeInstant");
  XML[] children4 = children3[0].getChildren("gml:timePosition");
  String _TimeInstant = String.valueOf(children4[0].getContent());
  //println(_TimeInstant);

  int THE_YEAR = int(_TimeInstant.substring(0, 4));
  int THE_MONTH = int(_TimeInstant.substring(5, 7));
  int THE_DAY = int(_TimeInstant.substring(8, 10));
  int THE_HOUR = int(_TimeInstant.substring(11, 13));

  //println(THE_YEAR, THE_MONTH, THE_DAY, THE_HOUR);

  int now_i = int(THE_HOUR);
  int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);

  //println(now_i, now_j);

  now_i -= int(-STATION.getTimelong() / 15);

  if (now_i < 0) {
    now_i += 24;
    now_j -= 1;
    if (now_j < 0) {
      now_j += 365;
    }
  }

  //println(now_i, now_j);
  //println("-------------");

  children2 = children1[0].getChildren("om:result");
  children3 = children2[0].getChildren("elements");
  children4 = children3[0].getChildren("element");

  for (int Li = 0; Li < children4.length; Li++) {

    String _a1 = children4[Li].getString("name");
    String _a2 = children4[Li].getString("value");
    String _a3 = children4[Li].getString("uom");

    //println("Li=", Li, _a1, _a2, _a3);

    if (_a2.toUpperCase().equals("MSNG")) { // missing values
      _a2 = String.valueOf(FLOAT_undefined);
    }

    if (_a1.equals("stn_pres")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_pressure.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("air_temp")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_drybulb.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("rel_hum")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_relhum.id][Load_Layer] = Float.valueOf(_a2);
    } 

    if (_a1.equals("tot_cld_amt")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_cloudcover.id][Load_Layer] = 0.1 * Float.valueOf(_a2);
    }    

    if (_a1.equals("avg_wnd_dir_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_winddir.id][Load_Layer] = Float.valueOf(_a2);
    }    

    if (_a1.equals("avg_wnd_spd_10m_mt50-60")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_windspd.id][Load_Layer] = Float.valueOf(_a2);
    }

    if (_a1.equals("pcpn_amt_pst6hrs")) {
      ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_precipitation.id][Load_Layer] = Float.valueOf(_a2); // past 6 hours!
    }

    if (_a1.equals("avg_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("W/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = 1000 * Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }

    if (_a1.equals("tot_globl_solr_radn_pst1hr")) {
      if (_a2.equals(STRING_undefined)) {
      } else {
        //if (_a3.equals("kJ/m²")) {
        ENSEMBLE_OBSERVED_values[now_i][now_j][LAYER_glohorrad.id][Load_Layer] = Float.valueOf(_a2) / 3.6; // we should check the units!
        //}
      }
    }
    
  }
  
}












class solarchvision_UITASK {
  
  private final static String CLASS_STAMP = "UITASK";
 
  private final static int LandOrbit_Pan_TargetRollZ = -19;
  private final static int LookAtDirection = -18;
  private final static int DistMouseXY_TargetRollXY_TargetRollZ = -17; 
  private final static int PanY_TargetRollXY_TargetRollZ = -16; 
  private final static int PanX_TargetRollXY_TargetRollZ = -15; 
  private final static int Pan_TargetRoll = -14; 
  private final static int CameraDistance_TargetRollXY_TargetRollZ = -13; 
  private final static int CameraRoll_Pan = -12; 
  private final static int CameraRollXY_CameraRollZ = -11; 
  private final static int TargetRoll_Pan = -10; 
  private final static int TargetRollXY_TargetRollZ = -9; 
  private final static int AllModelSize = -8; 
  private final static int SkydomeSize = -7; 
  private final static int Truck_Orbit = -6; 
  private final static int ModelSize_Pan_TargetRoll = -5; 
  private final static int Pan_Height = -4; 
  private final static int Zoom_Orbit_Pan = -3; 
  private final static int RectSelect = -2; 
  private final static int PickSelect = -1; 
  private final static int Create = 0; 
  private final static int Move = 1; 
  private final static int Scale = 2; 
  private final static int Rotate = 3; 
  private final static int Seed_Material = 4; 
  private final static int Tessellation = 5; 
  private final static int Layer = 6; 
  private final static int Visibility = 7; 
  private final static int Weight = 8; 
  private final static int DegreeMax = 9; 
  private final static int DegreeDif = 10; 
  private final static int DegreeMin = 11; 
  private final static int TrunkSize = 12; 
  private final static int LeafSize = 13; 
  private final static int All_Model1DsProps = 14; 
  private final static int Pivot = 15; 
  private final static int Normal = 16; 
  private final static int FirstVertex = 17; 
  private final static int Drop = 18; 
  private final static int GetLength = 19; 
  private final static int PowerX = 20; 
  private final static int PowerY = 21; 
  private final static int PowerZ = 22; 
  private final static int PowerAll = 23;  
  
}

solarchvision_UITASK UITASK = new solarchvision_UITASK();




class solarchvision_CREATE {
  
  private final static String CLASS_STAMP = "CREATE";

  private final static int Nothing    = 0;
  private final static int Plane      = 1;
  private final static int Poly       = 2;
  private final static int Extrude    = 3;
  private final static int Tri        = 4;
  private final static int Hyper      = 5;
  private final static int House1     = 6; 
  private final static int House2     = 7;
  private final static int SuperOBJ   = 8;
  private final static int Parametric = 9;
  private final static int Person     = 10;
  private final static int Plant      = 11;
  private final static int allModel1Ds    = 12;
  private final static int Face       = 13;
  private final static int Vertex     = 14;
  private final static int Curve      = 15;
  private final static int Solid      = 16;
  private final static int Section    = 17;
  private final static int Camera     = 18;
  
}

solarchvision_CREATE CREATE = new solarchvision_CREATE();




class solarchvision_OBJECTTYPE {
  
  private final static String CLASS_STAMP = "OBJECTTYPE";
  
  private final static int LANDPOINT = 0; 
  private final static int MODEL1D = 1; 
  private final static int MODEL2D = 2; 
  private final static int GROUP = 3;
  private final static int FACE = 4; 
  private final static int VERTEX = 5;
  private final static int SOFTVERTEX = 6;
  private final static int SOLID = 7;
  private final static int SECTION = 8;
  private final static int CAMERA = 9;
  private final static int CURVE = 10;
  
}

solarchvision_OBJECTTYPE ObjectCategory = new solarchvision_OBJECTTYPE(); 


class solarchvision_WINDOWTYPE {
  
  private final static String CLASS_STAMP = "WINDOWTYPE";
  
  private final static int SKY2D    = -2;
  private final static int LandGap  = -1;
  private final static int LandMesh = 0;
  private final static int STUDY    = 1;
  private final static int WORLD    = 2;
  private final static int WIN3D    = 3;
  private final static int OBJ      = 4;
  private final static int RAD      = 5;
  private final static int HTML     = 6;
  
}

solarchvision_WINDOWTYPE TypeWindow = new solarchvision_WINDOWTYPE(); 


class solarchvision_DATATYPE {
  
  private final static String CLASS_STAMP = "DATATYPE";
  
  private final static int SATELLITE_GOES = 0;
  private final static int FORECAST_HRDPS = 1;
  private final static int FORECAST_RDPS  = 2;
  private final static int FORECAST_GDPS  = 3;
  
}

solarchvision_DATATYPE DataType = new solarchvision_DATATYPE();


class solarchvision_SHADE {
  
  private final static String CLASS_STAMP = "SHADE";

  private final static int Surface_Wire = -1;
  private final static int Surface_Base = 0;
  private final static int Surface_White = 1;
  private final static int Surface_Materials = 2;
  private final static int Global_Solar = 3;
  private final static int Vertex_Solar = 4;
  private final static int Vertex_Solid = 5;
  private final static int Vertex_Elevation = 6;
  
  private final static int Options_num = 7;
  
  
  
  float[] vertexRender_Surface_White (int c) {  
  
    float[] COL = {
      c, c, c, c
    };
  
    return COL;
  }
  
  float[] vertexRender_Surface_Materials (int mt) {  
  
    float[] COL = {
      Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]
    };
  
    return COL;
  }
  
  
  float[] vertexRender_Vertex_Solar (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float _u = this.vertexU_Vertex_Solar(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);
  
    float[] COL = {0,0,0,0}; // default color for undefined values 
  
    if (is_undefined_FLOAT(_u) == false) {   
      COL = PAINT.getColorStyle(PAL_type, _u);
    }
  
    return COL;
  }
  
  
  float vertexU_Vertex_Solar (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float val = this.get_SolarImpact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);
  
    float _u = FLOAT_undefined;
  
    if (is_undefined_FLOAT(val) == false) { 
  
      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * val);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * val);  
    
      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
    }
  
    return _u;
  }
  
  
  float get_SolarImpact_atXYZ (float x, float y, float z) {
  
    float v = FLOAT_undefined;
    
    int q = this.findID_SolarImpact_atXYZ(x, y, z);
    
    if (q >= 0) {
      v = VertexSolar_amounts[Impact_TYPE][IMPACTS_displayDay][q];
    }
  
    return v;
  }
  
  
  int findID_SolarImpact_atXYZ (float x, float y, float z) {
  
    int n = -1;
  
    for (int q = 0; q < VertexSolar_XYZ.length; q++) {
      
      if (x == VertexSolar_XYZ[q][0]) {
      if (y == VertexSolar_XYZ[q][1]) {
      if (z == VertexSolar_XYZ[q][2]) {
        n = q;
        break;
      }
      }
      }
    }
  
    return n;
  }
  
  
  
  
  
  float[] vertexRender_Vertex_Solid (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float _u = this.vertexU_Vertex_Solid(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);
  
    float[] COL = PAINT.getColorStyle(PAL_type, _u);     
  
    return COL;
  }
  
  
  float vertexU_Vertex_Solid (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    allSolidImpacts.Type = 0;
    float val = allSolidImpacts.get_Impact_atXYZ(VERTEX_now[0], VERTEX_now[1], VERTEX_now[2]);
  
    float _u = 0.5 + 0.5 * (PAL_multiplier * val);
  
    if (PAL_direction == -1) _u = 1 - _u;
    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_direction == 2) _u =  0.5 * _u;
  
    return _u;
  }
  
  
  float[] vertexRender_Vertex_Elevation (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float _u = this.vertexU_Vertex_Elevation(VERTEX_now, PAL_type, PAL_direction, PAL_multiplier);
  
    float[] COL = PAINT.getColorStyle(PAL_type, _u);  
  
    return COL;
  }
  
  float vertexU_Vertex_Elevation (float[] VERTEX_now, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float _u = 0.5 + 0.5 * (PAL_multiplier * VERTEX_now[2]);
  
    if (PAL_direction == -1) _u = 1 - _u;
    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
    if (PAL_direction == 2) _u =  0.5 * _u;
  
    return _u;
  }
  
  
  float[] vertexRender_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    float _u = this.vertexU_Global_Solar(VERTEX_now, VERTEX_prev, VERTEX_next, PAL_type, PAL_direction, PAL_multiplier);
  
    float[] COL = {63,63,63,127}; // default color for undefined values 
  
    if (is_undefined_FLOAT(_u) == false) { 
      COL = PAINT.getColorStyle(PAL_type, _u);
    }
  
    return COL;
  }
  
  float vertexU_Global_Solar (float[] VERTEX_now, float[] VERTEX_prev, float[] VERTEX_next, int PAL_type, int PAL_direction, float PAL_multiplier) {
  
    PVector U = new PVector(VERTEX_next[0] - VERTEX_now[0], VERTEX_next[1] - VERTEX_now[1], VERTEX_next[2] - VERTEX_now[2]);
    PVector V = new PVector(VERTEX_prev[0] - VERTEX_now[0], VERTEX_prev[1] - VERTEX_now[1], VERTEX_prev[2] - VERTEX_now[2]);
    PVector UV = U.cross(V);
    float[] W = {
      UV.x, UV.y, UV.z
    };
    W = funcs.vec3_unit(W);
  
    float Alpha = funcs.asin_ang(W[2]);
    float Beta = funcs.atan2_ang(W[1], W[0]) + 90;       
  
    int a = int((Alpha + 90) / Sky3D.stp_slp);
    int b = int(Beta / Sky3D.stp_dir);
  
    if (a < 0) a += int(180 / Sky3D.stp_slp);
    if (b < 0) b += int(360 / Sky3D.stp_dir);
    if (a > int(180 / Sky3D.stp_slp)) a -= int(180 / Sky3D.stp_slp);
    if (b > int(360 / Sky3D.stp_dir)) b -= int(360 / Sky3D.stp_dir);
  
    float valuesSUM = GlobalSolar[Impact_TYPE][IMPACTS_displayDay][a][b];
  
    float _u = FLOAT_undefined;
  
    if (is_undefined_FLOAT(valuesSUM) == false) {
  
      if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
  
      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
    }
  
    return _u;
  }
  
  
  
  int get_PAL_type () {
  
    int PAL_type = 0; 
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_type = allFaces.ACTIVE_pallet_CLR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_type = allFaces.PASSIVE_pallet_CLR;
    }          
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_type = allSolids.pallet_CLR;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_type = Land3D.pallet_CLR;
    }  
  
    return PAL_type;
  }
  
  
  int get_PAL_direction () {
  
    int PAL_direction = 1;
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_direction = allFaces.ACTIVE_pallet_DIR;
      if (Impact_TYPE == Impact_PASSIVE) PAL_direction = allFaces.PASSIVE_pallet_DIR;
    }              
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_direction = allSolids.pallet_DIR;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_direction = Land3D.pallet_DIR;
    }  
  
    return PAL_direction;
  }
  
  
  float get_PAL_multiplier () {
  
    float PAL_multiplier = 1; 
  
    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT; 
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
    }              
  
    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
      PAL_multiplier = allSolids.pallet_MLT;
    }                  
  
    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
      PAL_multiplier = Land3D.pallet_MLT;
    }
  
    return PAL_multiplier;
  }

  
}  

solarchvision_SHADE SHADE = new solarchvision_SHADE();






class solarchvision_WIN3D {
  
  private final static String CLASS_STAMP = "WIN3D";
  
  // scales
  float scale; 
  // (top-left) corner
  int cX = 0;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  // width and height
  int dX = int(1.5 * SOLARCHVISION_pixel_H);
  int dY = SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);

  float position_X = 0;
  float position_Y = 50; //10;
  float position_Z = -50; //50; 
  float position_T = 1.0;
  
  float rotation_X = 90; //75; //0; 
  float rotation_Y = 0;
  float rotation_Z = 90; //0; //180; //135;
  float rotation_T = 5.0;
  
  float Zoom = 60.0; // / (SOLARCHVISION_pixel_H / 300.0);
  
  int ViewType = 1; // 0: Ortho 1: Perspective
  
  boolean update = true;
  boolean include = true;

  boolean fullPeriod_IMG = false;
  boolean record_IMG = false;
  boolean record_AUTO = false;  
  
  float ImageScale = 1.0;
  
  float CAM_x;
  float CAM_y;
  float CAM_z;
  float CAM_fov;
  float CAM_dist;
  
  float CAM_clipNear = 0.01;
  float CAM_clipFar = 2000000000.0;  
  
  float refScale = 100; // it improves displaying the shaded scene! 
  
  int currentCamera = 0; // 0 = Free Viewport | etc.= Saved Viewport
  
  int UI_CurrentTask = UITASK.Zoom_Orbit_Pan; 
  int UI_OptionXorY = 0; // 0-1
  int UI_TaskModifyParameter = 0; //to modify objects with several parameters e.g. allModel1Ds  


  int FacesShade = SHADE.Surface_Materials; //Shade_Surface_White; // <<<<<
  

  PGraphics graphics;
  
  void put_3DViewport () {  
  
    if (this.ViewType == 1) {
  
      float aspect = 1.0 / this.view_R;
  
      float zFar = this.CAM_dist * this.CAM_clipFar;
      float zNear = this.CAM_dist * this.CAM_clipNear;
  
      this.graphics.perspective(this.CAM_fov, aspect, zNear, zFar);
  
      this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
    } else {
  
      float ZOOM = WIN3D.Orthographic_ZOOM();
  
      this.graphics.ortho(ZOOM * this.dX * -1, ZOOM * this.dX * 1, ZOOM  * this.dY * -1, ZOOM  * this.dY * 1, 0.00001, 100000);
  
      this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
    }
  
    this.graphics.translate(this.position_X * this.scale, this.position_Y * this.scale, this.position_Z * this.scale);
  
    this.graphics.rotateX(this.rotation_X * PI / 180); 
    this.graphics.rotateZ(this.rotation_Z * PI / 180);
  }
  
  

  void drawView () {
    
    if (this.update) {
  
      if (this.record_IMG) this.ImageScale = 2; //3; 
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;
      //////////////////////////////////
  
      if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P3D);
      }  
      
      int firstDay = IMPACTS_displayDay;
      int lastDay = IMPACTS_displayDay;      

      int firstImpact = Impact_TYPE;
      int lastImpact = Impact_TYPE;      
      
      if (this.fullPeriod_IMG) {
        this.fullPeriod_IMG = false;
        
        firstDay = 0;
        lastDay = STUDY.j_End;
        
        firstImpact = 0;
        lastImpact = numberOfImpactVariations - 1;        
      }
      
      int keep_Impact_TYPE = Impact_TYPE;
      int keep_IMPACTS_displayDay = IMPACTS_displayDay;
      for (IMPACTS_displayDay = lastDay; IMPACTS_displayDay >= firstDay; IMPACTS_displayDay--) {
        for (Impact_TYPE = lastImpact; Impact_TYPE >= firstImpact; Impact_TYPE--) {

          this.graphics.beginDraw();  
      
          this.scale = this.dY / this.refScale; // fits field of view to window's height
      
          this.graphics.background(233);
      
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
      
          this.graphics.pushMatrix();
      
          this.graphics.hint(ENABLE_DEPTH_TEST);
      
          WIN3D.record_last3DViewport();
      
          WIN3D.transform_3DViewport();
      
          WIN3D.put_3DViewport();
      
          Sky3D.draw(TypeWindow.WIN3D);
      
          Sun3D.drawPattern(0, 0, 0, 0.975 * Sky3D.scale);
      
          Sun3D.drawPath(0, 0, 0, 0.975 * Sky3D.scale);

          Sun3D.drawGrid(0, 0, 0, 0.975 * Sky3D.scale);
      
          Sun3D.draw();
      
          Moon3D.draw();
          
          Earth3D.draw(TypeWindow.WIN3D);
      
          Land3D.draw(TypeWindow.WIN3D);
          
          Tropo3D.draw(TypeWindow.WIN3D, STUDY.i_Start, STUDY.i_End);
      
          allFaces.draw(TypeWindow.WIN3D);
          
          allCurves.draw(TypeWindow.WIN3D);
      
          allPoints.draw();
      
          allModel1Ds.draw(TypeWindow.WIN3D);
      
          allWindRoses.draw();
      
          allSections.draw(TypeWindow.WIN3D);
      
          allCameras.draw();
      
          allSolids.draw();
      
          allSolidImpacts.draw_lines();
      
          allSolidImpacts.draw_points();
      
          allModel2Ds.draw(TypeWindow.WIN3D);  
      
          allWindFlows.draw(TypeWindow.WIN3D);
          
          WIN3D.draw_AERIAL();
    
          this.graphics.hint(DISABLE_DEPTH_TEST);
      
          if ((this.record_IMG) || (this.record_AUTO)) {
          }
          else {
            WIN3D.draw_referencePivot();
          }
      
          this.graphics.popMatrix();
      
      
          this.drawPallet();  
      
          this.graphics.endDraw();
      
          if ((this.record_IMG) || (this.record_AUTO)) {
            String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP));
    
            if (Impact_TYPE == Impact_ACTIVE) {
              myFile += "_RAD";
            }
            if (Impact_TYPE == Impact_PASSIVE) {
              myFile += "_EFF";
            }        
            myFile += "_" + importedObjectName;
            myFile += ".jpg";
          
            this.graphics.save(myFile);
            SOLARCHVISION_explore_output(myFile);
            println("File created:" + myFile);
          }
        }
      }
      IMPACTS_displayDay = keep_IMPACTS_displayDay;
      Impact_TYPE = keep_Impact_TYPE;
  
      imageMode(CORNER);
      image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
  
  
  
      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;  
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;  
      //////////////////////////////////
  
      if (this.ImageScale != 1) {
        this.graphics = createGraphics(this.dX, this.dY, P3D);
        this.update = false; //true;
      } else {
        this.update = false;
        
        SOLARCHVISION_draw_Perspective_Internally();
      }
        
    }
  }

  
  
  void draw_referencePivot () {
  
  
    this.graphics.strokeWeight(3);
    this.graphics.stroke(127, 0, 255, 127);
    this.graphics.fill(127, 0, 255, 127);  
  
    float[] P = userSelections.getPivot();
  
    float x = P[0];
    float y = P[1];
    float z = P[2];
  
  
    this.graphics.pushMatrix(); 
    this.graphics.translate(x * this.scale, -y * this.scale, z * this.scale);
  
    //this.graphics.sphere(1); // <<<<<< size
  
    this.graphics.popMatrix();
  
    this.graphics.strokeWeight(0);
  }   
  
  

  void drawPallet () {
  
    boolean draw_pal = false;
  
    int PAL_type = 0; 
    int PAL_direction = 1;
    float PAL_multiplier = 1; 
  
    if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
  
      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = allFaces.ACTIVE_pallet_CLR; 
        PAL_direction = allFaces.ACTIVE_pallet_DIR; 
        PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = allFaces.PASSIVE_pallet_CLR; 
        PAL_direction = allFaces.PASSIVE_pallet_DIR;
        PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
      }   
  
      draw_pal = true;
    }
  
    if (this.FacesShade == SHADE.Vertex_Elevation) {
  
      PAL_type = Land3D.pallet_CLR; 
      PAL_direction = Land3D.pallet_DIR; 
      PAL_multiplier = Land3D.pallet_MLT; 
  
      draw_pal = true;
    }
  
    if (this.FacesShade == SHADE.Vertex_Solid) {
  
      PAL_type = allSolids.pallet_CLR; 
      PAL_direction = allSolids.pallet_DIR;
      PAL_multiplier = allSolids.pallet_MLT;
  
      draw_pal = true;
    }          

    if (draw_pal) {
  
      float the_scale = 1;
  
      if (this.ViewType == 1) {
        the_scale *= (0.5 / tan(0.5 * this.CAM_fov));
      } else {
        float ZOOM = WIN3D.Orthographic_ZOOM();
        the_scale *= (0.5 / ZOOM);
      }  
  
      this.graphics.pushMatrix();
  
      this.CAM_fov = this.Zoom * PI / 180;
  
      this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
      if (this.ViewType == 1) {
  
        float aspect = 1.0 / this.view_R;
  
        float zFar = this.CAM_dist * 1000;
        float zNear = this.CAM_dist * 0.001;
  
        this.graphics.translate(0.5 * this.dX, 0.5 * this.dY, 0); // << IMPORTANT!
      } else {
  
        float ZOOM = WIN3D.Orthographic_ZOOM();
  
        this.graphics.translate(0, 1.0 * this.dY, 0); // << IMPORTANT!
      }

      float pal_length = 1 * SOLARCHVISION_pixel_H * this.ImageScale / the_scale;
  
      float y1 = -0.2 * (pal_length / 11.0) + (0.4 * this.dY / the_scale);
      float y2 = y1 + 0.4 * (pal_length / 11.0);
  
      float txtSize = y2 - y1;
  
      for (int q = 0; q < 11; q++) {
        
        float x1 = -0.5 * pal_length + q * (pal_length / 11.0); 
        float x2 = x1 + (pal_length / 11.0);      
  
        float _u = 0.2 * q - 0.5;
  
        if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
          if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
        }
  
        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
  
        float[] COL = PAINT.getColorStyle(PAL_type, _u); 
  
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
        this.graphics.strokeWeight(0);
  
        this.graphics.beginShape();
        this.graphics.vertex(x1, y1, 0);
        this.graphics.vertex(x1, y2, 0);
        this.graphics.vertex(x2, y2, 0);
        this.graphics.vertex(x2, y1, 0);
        this.graphics.endShape(CLOSE);    
  
        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }  
  
        this.graphics.textSize(txtSize);
        this.graphics.textAlign(CENTER, CENTER);
  
        if ((this.FacesShade == SHADE.Global_Solar) || (this.FacesShade == SHADE.Vertex_Solar)) {
          if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
          if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
  
        if (this.FacesShade == SHADE.Vertex_Elevation) {
          this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
  
        if (this.FacesShade == SHADE.Vertex_Solid) {
          this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
        }
      }
  
      this.graphics.noStroke();
      this.graphics.fill(0);
      
      this.graphics.textAlign(LEFT, CENTER);
      if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(" kW/m²", 0.5 * pal_length, 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(" %kW°C/m²", 0.5 * pal_length, 0.5 * (y1 + y2) - 0.1 * txtSize, 0);
      
      String txt = "SOLARCHVISION ";
      
      if (Impact_TYPE == Impact_ACTIVE) txt += "active model ";
      if (Impact_TYPE == Impact_PASSIVE) txt += "passive model ";

      if (IMPACTS_displayDay != 0) {
        txt += TIME.getDayText((IMPACTS_displayDay - 1) * STUDY.perDays + 286 + TIME.beginDay);
      }
      else {
        txt += TIME.getDayText( STUDY.j_Start    * STUDY.perDays + 286 + TIME.beginDay) + " - ";
        txt += TIME.getDayText((STUDY.j_End - 1) * STUDY.perDays + 286 + TIME.beginDay);
      }
      
      txt += ", 3D-model: " + importedObjectName;

      this.graphics.textAlign(CENTER, CENTER);
      this.graphics.text(txt, 0, y1 - 1.0 * txtSize, 0);


  
      this.graphics.popMatrix();
    }
  }





  

  void draw_AERIAL () {
    this.graphics.sphereDetail(6, 4);

    if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {
      for (int n = 0; n < AERIAL_num; n++) {

        float _tgl = AERIAL_Locations[n][2];
        float _lat = AERIAL_Locations[n][1];
        float _lon = AERIAL_Locations[n][0]; 
        if (_lon > 180) _lon -= 360; // << important!

        double du = ((_lon - AERIAL_Center_Longitude) / 180.0) * (PI * DOUBLE_r_Earth);
        double dv = ((_lat - AERIAL_Center_Latitude) / 180.0) * (PI * DOUBLE_r_Earth);

        float x = 0.1 * (float) du * funcs.cos_ang((float) AERIAL_Center_Latitude); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float y = 0.1 * (float) dv;                                           // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 0.1
        float z = _tgl - HeightAboveGround;

        if (AERIAL_graphOption == 0) {
          //-----------------------------
          int PAL_type = 6; //12; 
          int PAL_direction = -1;
          float PAL_multiplier = 1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o++) {

            float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];

            if (is_undefined_FLOAT(_val) == false) {

              float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              float[] COL = PAINT.getColorStyle(PAL_type, _u);             

              this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
              this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
              //this.graphics.noFill();

              this.graphics.strokeWeight(0); // 2; <<<<<<<<<

              float R = 5;
              /*         
               this.graphics.beginShape();
               for (float teta = 0; teta < 360; teta += 360.0 / 6.0) {
               this.graphics.vertex((x + R * funcs.cos_ang(teta)) * OBJECTS_scale * this.scale, (y + R * funcs.sin_ang(teta)) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
               }
               this.graphics.endShape(CLOSE);
               */
              this.graphics.pushMatrix();
              this.graphics.translate(x * OBJECTS_scale * this.scale, y * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.sphere(R);
              this.graphics.popMatrix();
            }
          }
        }

        if (AERIAL_graphOption == 1) {

          //-----------------------------
          int PAL_type = 1;//12; 
          int PAL_direction = 1;//-1;
          float PAL_multiplier = 0.1;//1.0 / 30.0;
          //-----------------------------

          for (int o = 0; o < GRIB2_maxScenarios; o++) {

            //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
            float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

            if (is_undefined_FLOAT(_val) == false) {

              float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
              float D_teta = 15; 
              float R = 5.0 * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];

              float R_in = 0.0 * R; 
              float x1 = (R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta)));
              float y1 = (R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta)));
              float x2 = (R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta)));
              float y2 = (R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)));                      

              float x4 = (R * funcs.cos_ang(90 - (teta - 0.5 * D_teta)));
              float y4 = (R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta)));
              float x3 = (R * funcs.cos_ang(90 - (teta + 0.5 * D_teta)));
              float y3 = (R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)));          

              //float ox = -0.5 * (R * funcs.cos_ang(90 - teta));
              //float oy = -0.5 * (R * -funcs.sin_ang(90 - teta));
              //float ox = -1 * (R * funcs.cos_ang(90 - teta));
              //float oy = -1 * (R * -funcs.sin_ang(90 - teta));
              float ox = -2 * (R * funcs.cos_ang(90 - teta)) / 3.0;
              float oy = -2 * (R * -funcs.sin_ang(90 - teta)) / 3.0;            

              float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;

              float[] COL = PAINT.getColorStyle(PAL_type, _u);             

              this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
              //this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
              this.graphics.noFill();

              this.graphics.strokeWeight(2); // 0; <<<<<<<<<

              this.graphics.beginShape();
              this.graphics.vertex((x + x1 + ox) * OBJECTS_scale * this.scale, (y + y1 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x2 + ox) * OBJECTS_scale * this.scale, (y + y2 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x3 + ox) * OBJECTS_scale * this.scale, (y + y3 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.vertex((x + x4 + ox) * OBJECTS_scale * this.scale, (y + y4 + oy) * OBJECTS_scale * this.scale, z * OBJECTS_scale * this.scale);
              this.graphics.endShape(CLOSE);
            }
          }
        }
      }
    }   
  }  
  
  

  
  void keyPressed (KeyEvent e) {
  
    if (e.isAltDown()) {
      if (key == CODED) { 
        switch(keyCode) {
  
        case RIGHT :
          allSolidImpacts.rotation[allSolidImpacts.sectionType] = (allSolidImpacts.rotation[allSolidImpacts.sectionType] + 15) % 360; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case LEFT :
          allSolidImpacts.rotation[allSolidImpacts.sectionType] = (allSolidImpacts.rotation[allSolidImpacts.sectionType] + 360 - 15) % 360; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;           
  
        case UP   :
          allSolidImpacts.elevation[allSolidImpacts.sectionType] += allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;        
        case DOWN :
          allSolidImpacts.elevation[allSolidImpacts.sectionType] -= allSolidImpacts.positionStep; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true; 
          ROLLOUT.update = true;  
          break; 
  
        case 33 :
          allSolidImpacts.elevation[allSolidImpacts.sectionType] += 4 * allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;        
        case 34 :
          allSolidImpacts.elevation[allSolidImpacts.sectionType] -= 4 * allSolidImpacts.positionStep; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break; 
  
        case 35 :
          allSolidImpacts.U_scale[allSolidImpacts.sectionType] *= pow(2.0, 0.5); 
          allSolidImpacts.V_scale[allSolidImpacts.sectionType] *= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 36 :
          allSolidImpacts.U_scale[allSolidImpacts.sectionType] /= pow(2.0, 0.5); 
          allSolidImpacts.V_scale[allSolidImpacts.sectionType] /= pow(2.0, 0.5);                   
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        }
      } else {
        switch(key) {
  
        case 'U' :
          allSolidImpacts.U_offset[allSolidImpacts.sectionType] += allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 'u' :
          allSolidImpacts.U_offset[allSolidImpacts.sectionType] -= allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;        
        case 'V' :
          allSolidImpacts.V_offset[allSolidImpacts.sectionType] += allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case 'v' :
          allSolidImpacts.V_offset[allSolidImpacts.sectionType] -= allSolidImpacts.positionStep;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;  
  
        case ']' :
          allSolidImpacts.sectionType = (allSolidImpacts.sectionType + 1) % 4;
          allSolarImpacts.sectionType = allSolidImpacts.sectionType; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case '[' :
          allSolidImpacts.sectionType = (allSolidImpacts.sectionType + 4 - 1) % 4;
          allSolarImpacts.sectionType = allSolidImpacts.sectionType;
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;        
  
        case '0' :
          allSolidImpacts.elevation[allSolidImpacts.sectionType] = 0; 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '.' :
          allSolidImpacts.rotation[allSolidImpacts.sectionType] = 0; 
          allSolidImpacts.calculate_Impact_selectedSections();
          this.update = true;
          ROLLOUT.update = true;                   
          break;                  
  
        case '/' :
          allSolidImpacts.Power *= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '*' :
          allSolidImpacts.Power /= pow(2.0, 0.5);  
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '+' :
          allSolidImpacts.Grade *= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '-' :
          allSolidImpacts.Grade /= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
        case '>' :
          allSolidImpacts.Grade /= pow(2.0, 0.25); 
          allSolidImpacts.Power /= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
        case '<' :
          allSolidImpacts.Grade *= pow(2.0, 0.25); 
          allSolidImpacts.Power *= pow(2.0, 0.5); 
          allSolidImpacts.calculate_Impact_selectedSections(); 
          this.update = true;
          ROLLOUT.update = true;  
          break;
  
  
  
        case ENTER :
          allSolidImpacts.calculate_WindFlow(); 
          this.update = true; 
          break;
        }
      }
    } else if (e.isControlDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      } else {
        switch(key) {
  
        case '*': 
          allModel3Ds.select_All();
          this.update = true;
          ROLLOUT.update = true;
          break;             
  
        case '.' :
          this.position_X = 0;
          this.position_Y = 0;
          //this.Zoom = 60;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '-' :
          this.rotation_X = 90; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
  
        case '+' :
          this.rotation_X = 0;
          this.rotation_Y = 0;
          this.rotation_Z = 0; 
  
          this.position_X = 0;
          this.position_Y = 0;
          this.position_Z = -100;   
  
          this.position_T = 1;
  
          this.Zoom = 60;        
  
          this.currentCamera = 0;
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '0' :
          Land3D.displaySurface = !Land3D.displaySurface;
          if (Land3D.displaySurface) {
            current_ObjectCategory = ObjectCategory.LANDPOINT;
            UI_BAR_b.update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '1' :
          allModel1Ds.displayAll = !allModel1Ds.displayAll;
          if (allModel1Ds.displayAll) {
            current_ObjectCategory = ObjectCategory.MODEL1D;
            UI_BAR_b.update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '2' :
          allModel2Ds.displayAll = !allModel2Ds.displayAll;
          if (allModel2Ds.displayAll) {
            current_ObjectCategory = ObjectCategory.MODEL2D;
            UI_BAR_b.update = true;
          }
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '3' :
          allFaces.displayAll = !allFaces.displayAll;
          if (allFaces.displayAll) {
            current_ObjectCategory = ObjectCategory.GROUP;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '4' :
          allFaces.displayAll = !allFaces.displayAll;
          if (allFaces.displayAll) {
            current_ObjectCategory = ObjectCategory.FACE;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                  
  
        case '5' :
          allFaces.displayAll = !allFaces.displayAll;
          if (allFaces.displayAll) {
            current_ObjectCategory = ObjectCategory.VERTEX;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
        case '6' :
          allCurves.displayAll = !allCurves.displayAll;
          if (allFaces.displayAll) {
            current_ObjectCategory = ObjectCategory.CURVE;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                       
  
        case '7' :
          allSolids.displayAll = !allSolids.displayAll;
          if (allSolids.displayAll) {
            current_ObjectCategory = ObjectCategory.SOLID;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '8' :
          allSections.displayAll = !allSections.displayAll;
          if (allSections.displayAll) {
            current_ObjectCategory = ObjectCategory.SECTION;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '9' :
          allCameras.displayAll = !allCameras.displayAll;
          if (allCameras.displayAll) {
            current_ObjectCategory = ObjectCategory.CAMERA;
            UI_BAR_b.update = true;
          } 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
  
  
  
        case ' ' :
          allSolarImpacts.render_Shadows_selectedSections(); 
          this.update = true;
          break;
  
        case ENTER :
          allSolarImpacts.calculate_Impact_selectedSections();
          this.update = true;
          break;
        }
      }
    }
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
  
      if (key == CODED) { 
        switch(keyCode) {
  
        case DOWN :
          WIN3D.rotateZ_3DViewport_around_Selection(this.rotation_T);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case LEFT :
          WIN3D.rotateXY_3DViewport_around_Selection(-this.rotation_T);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case RIGHT :
          WIN3D.rotateXY_3DViewport_around_Selection(this.rotation_T);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case UP :
          WIN3D.rotateZ_3DViewport_around_Selection(-this.rotation_T);
          this.update = true; 
          ROLLOUT.update = true; 
          break;     
  
        case 33: 
          this.currentCamera += 1;
          if (this.currentCamera > allCameras.num - 1) this.currentCamera = 0;
          WIN3D.apply_currentCamera();
  
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 34: 
          this.currentCamera -= 1;
          if (this.currentCamera < 0) this.currentCamera = allCameras.num - 1;
          WIN3D.apply_currentCamera();
  
          SOLARCHVISION_modify_Viewport_Title();
  
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 35: 
  
          break;  
  
        case 36: 
  
          break;          
  
  
  
        case 155: // INSERT 
          allModel3Ds.deselect_All();
  
          this.update = true;
          ROLLOUT.update = true;
          break;
        }
      } else {
        switch(key) {
  
        case DELETE: 
          allModel3Ds.delete_Selection();
  
          this.update = true;
          ROLLOUT.update = true; 
  
          break;        
  
        case ',' :
          if (this.ViewType == 1) {
            this.position_Z += this.position_T * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom /= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '.' :
          if (this.ViewType == 1) {
            this.position_Z -= this.position_T * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom *= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '0' :
          if (this.ViewType == 1) {
            this.position_Z += this.position_T * OBJECTS_scale; 
            this.update = true; 
            ROLLOUT.update = true;
          } else {
            this.Zoom /= pow(2.0, 0.25); 
            this.update = true; 
            ROLLOUT.update = true;
          }
          break;
  
        case '5' :
          WIN3D.look_3DViewport_towards_Selection(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '4' :
          this.rotation_Z += this.rotation_T; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '6' :
          this.rotation_Z -= this.rotation_T; 
          WIN3D.reverseTransform_3DViewport();
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '2' :
          this.rotation_X -= this.rotation_T; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '8' :
          this.rotation_X += this.rotation_T; 
          WIN3D.reverseTransform_3DViewport(); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '1' :
          this.position_X += this.position_T * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '3' :
          this.position_X -= this.position_T * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case '9' :
          this.position_Y += this.position_T * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '7' :
          this.position_Y -= this.position_T * OBJECTS_scale; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;                  
  
  
        case '*' : 
          WIN3D.move_3DViewport_towards_Selection(2.0);
          this.update = true; 
          ROLLOUT.update = true; 
          break;        
        case '/' :
          WIN3D.move_3DViewport_towards_Selection(0.5); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
  
        case '+' :
          this.Zoom = 2 * funcs.atan_ang((1.0 / 1.1) * funcs.tan_ang(0.5 * this.Zoom)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '-' :
          this.Zoom = 2 * funcs.atan_ang((1.1 / 1.0) * funcs.tan_ang(0.5 * this.Zoom)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case 'O' :
          this.ViewType = 0; 
          this.update = true; 
          ROLLOUT.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'o' :
          this.ViewType = 0; 
          this.update = true; 
          ROLLOUT.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'P' ://this.Zoom = 60;
          this.ViewType = 1; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'p' ://this.Zoom = 60;
          this.ViewType = 1; 
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
  
        case ']' :
          IMPACTS_displayDay += 1;
          if (IMPACTS_displayDay > STUDY.j_End) IMPACTS_displayDay = 0;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case '[' :
          IMPACTS_displayDay -= 1;
          if (IMPACTS_displayDay < 0) IMPACTS_displayDay = STUDY.j_End;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
  
        case ENTER: 
          if (this.FacesShade == SHADE.Global_Solar) GlobalSolar_rebuild_array = true;   
          if (this.FacesShade == SHADE.Vertex_Solar) VertexSolar_rebuild_array = true;
          this.update = true;
          ROLLOUT.update = true;  
          break;                  
  
        case ' ': 
          SOLARCHVISION_RecordFrame();
          ROLLOUT.update = true; 
          break;       
         
        }
  
      }
    }
  }
  
  
  float Orthographic_ZOOM () {
  
    float ZOOM = 0.5 * this.Zoom * PI / 180;
    
    ZOOM *= pow(pow(this.position_X, 2) + pow(this.position_Y, 2) + pow(this.position_Z, 2), 0.5); 
  
    ZOOM /= this.refScale;
  
    return ZOOM;
  }
  
  
  
  void look_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    WIN3D.lookXY_3DViewport_towards_Direction(Image_X, Image_Y);
    WIN3D.lookZ_3DViewport_towards_Direction(Image_X, Image_Y);
  }
  
  void lookXY_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = WIN3D.calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = WIN3D.calculate_Click3D(Image_X, Image_Y);  
  
    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;  
  
  
    this.rotation_Z += funcs.atan2_ang((yB - yO), (xB - xO)) - funcs.atan2_ang((yA - yO), (xA - xO));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void lookZ_3DViewport_towards_Direction (float Image_X, float Image_Y) {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = WIN3D.calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = WIN3D.calculate_Click3D(Image_X, Image_Y);  
  
    float xB = P[0] / OBJECTS_scale;
    float yB = P[1] / OBJECTS_scale;
    float zB = P[2] / OBJECTS_scale;  
  
    this.rotation_X += funcs.atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - funcs.atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void look_3DViewport_towards_Selection () {
  
    WIN3D.lookXY_3DViewport_towards_Selection();
    WIN3D.lookZ_3DViewport_towards_Selection();
  }
  
  void lookXY_3DViewport_towards_Selection () {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = WIN3D.calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = userSelections.getPivot();
  
    float xB = P[0];
    float yB = P[1];
    float zB = P[2];  
  
  
    this.rotation_Z += funcs.atan2_ang((yB - yO), (xB - xO)) - funcs.atan2_ang((yA - yO), (xA - xO));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void lookZ_3DViewport_towards_Selection () {
  
    float xO = this.CAM_x / OBJECTS_scale;
    float yO = this.CAM_y / OBJECTS_scale;
    float zO = this.CAM_z / OBJECTS_scale;
  
    float[] ray_end = WIN3D.calculate_Click3D(0, 0);  
    float xA = ray_end[0] / OBJECTS_scale;
    float yA = ray_end[1] / OBJECTS_scale;
    float zA = ray_end[2] / OBJECTS_scale;
  
    float[] P = userSelections.getPivot();
  
    float xB = P[0];
    float yB = P[1];
    float zB = P[2];  
  
    this.rotation_X += funcs.atan2_ang((zB - zO), pow(pow(yB - yO, 2) + pow(xB - xO, 2), 0.5)) - funcs.atan2_ang((zA - zO), pow(pow(yA - yO, 2) + pow(xA - xO, 2), 0.5));
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  void move_3DViewport_towards_Mouse (float t) {
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float Image_X = mouseX - (this.cX + 0.5 * this.dX);
    float Image_Y = mouseY - (this.cY + 0.5 * this.dY);
  
    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);  
    float xO = ray_end[0] / OBJECTS_scale;
    float yO = ray_end[1] / OBJECTS_scale;
    float zO = ray_end[2] / OBJECTS_scale;
  
    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;
  
    float xB = xO + t * dx; 
    float yB = yO + t * dy;
    float zB = zO + t * dz;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;     
  
    WIN3D.reverseTransform_3DViewport();
  
  
    //this.position_T *= t; // just to adjust panning better
  }
  
  void move_3DViewport_towards_Selection (float t) {
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = userSelections.getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];         
  
    float dx = xA - xO;
    float dy = yA - yO;
    float dz = zA - zO;
  
    float xB = xO + t * dx; 
    float yB = yO + t * dy;
    float zB = zO + t * dz;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;     
  
    WIN3D.reverseTransform_3DViewport();
  
  
    //this.position_T *= t; // just to adjust panning better
  }
  
  void rotateZ_3DViewport_around_Selection (float t) {
  
    this.rotation_X += t;
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = userSelections.getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];         
  
    float xB = xA - xO;
    float yB = yA - yO;
    float zB = zA - zO;
  
    // rotate to make it on yz plane
  
    float xC = xB * funcs.cos_ang(-this.rotation_Z) - yB * funcs.sin_ang(-this.rotation_Z); 
    float yC = xB * funcs.sin_ang(-this.rotation_Z) + yB * funcs.cos_ang(-this.rotation_Z);
    float zC = zB;
  
    // rotate it on yz plane
  
    float xD = xC;
    float yD = yC * funcs.cos_ang(t) - zC * funcs.sin_ang(t);
    float zD = yC * funcs.sin_ang(t) + zC * funcs.cos_ang(t);
  
    // rotate to back from yz plane
  
    float xE = xD * funcs.cos_ang(this.rotation_Z) - yD * funcs.sin_ang(this.rotation_Z); 
    float yE = xD * funcs.sin_ang(this.rotation_Z) + yD * funcs.cos_ang(this.rotation_Z);
    float zE = zD;
  
    float xF = xE + xO;
    float yF = yE + yO;
    float zF = zE + zO;
  
    this.CAM_x = xF * OBJECTS_scale;           
    this.CAM_y = yF * OBJECTS_scale;
    this.CAM_z = zF * OBJECTS_scale; 
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void rotateXY_3DViewport_around_Selection (float t) {
  
    this.rotation_Z += t;
  
    float xA = this.CAM_x / OBJECTS_scale;
    float yA = this.CAM_y / OBJECTS_scale;
    float zA = this.CAM_z / OBJECTS_scale;
  
    float[] P = userSelections.getPivot();
  
    float xO = P[0];
    float yO = P[1];
    float zO = P[2];             
  
    float dx = xA - xO;
    float dy = yA - yO;
  
    float xB = xO + dx * funcs.cos_ang(t) - dy * funcs.sin_ang(t); 
    float yB = yO + dx * funcs.sin_ang(t) + dy * funcs.cos_ang(t);
    float zB = zA;
  
    this.CAM_x = xB * OBJECTS_scale;           
    this.CAM_y = yB * OBJECTS_scale;
    this.CAM_z = zB * OBJECTS_scale;   
  
    WIN3D.reverseTransform_3DViewport();
  }
  
  
  void rotateXY_3DViewport_around_LandIntersection (float t) {
  
    float Image_X = SOLARCHVISION_X_click1 - (this.cX + 0.5 * this.dX);
    float Image_Y = SOLARCHVISION_Y_click1 - (this.cY + 0.5 * this.dY);
  
    float[] ray_direction = new float [3];
  
    float[] ray_start = {
      this.CAM_x, this.CAM_y, this.CAM_z
    };
  
    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);
  
    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          
  
    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;
  
    if (this.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);
  
      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;
  
      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }
  
    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];  
    
    
    float[] RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
  
    if (RxP[0] >= 0) {  
  
      float xO = RxP[1] / OBJECTS_scale;
      float yO = RxP[2] / OBJECTS_scale;
      float zO = RxP[3] / OBJECTS_scale;             
  
      float xA = ray_start[0];
      float yA = ray_start[1];
      float zA = ray_start[2];
  
      float dx = xA - xO;
      float dy = yA - yO;
    
      this.rotation_Z += t;
    
      float xB = xO + dx * funcs.cos_ang(t) - dy * funcs.sin_ang(t); 
      float yB = yO + dx * funcs.sin_ang(t) + dy * funcs.cos_ang(t);
      float zB = zA;
    
      this.CAM_x = xB * OBJECTS_scale;           
      this.CAM_y = yB * OBJECTS_scale;
      this.CAM_z = zB * OBJECTS_scale;   
    
      WIN3D.reverseTransform_3DViewport();
    }
  }
  
  
  void reverseTransform_3DViewport () { // computing this.position_X, this.position_Y and this.position_Z from new set of camera start and end points.
  
    float px, py, pz;
  
    px = this.CAM_x;
    py = this.CAM_y;
    pz = this.CAM_z;  
  
    float CAM_x1, CAM_y1, CAM_z1;
  
    CAM_z1 = pz;
    CAM_x1 = px * funcs.cos_ang(-this.rotation_Z) - py * funcs.sin_ang(-this.rotation_Z);
    CAM_y1 = px * funcs.sin_ang(-this.rotation_Z) + py * funcs.cos_ang(-this.rotation_Z);  
  
    px = CAM_x1;
    py = CAM_y1;
    pz = CAM_z1;  
  
    CAM_x1 = px;
    CAM_y1 = py * funcs.cos_ang(-this.rotation_X) - pz * funcs.sin_ang(-this.rotation_X);
    CAM_z1 = py * funcs.sin_ang(-this.rotation_X) + pz * funcs.cos_ang(-this.rotation_X);    
  
  
    float CAM_x2, CAM_y2, CAM_z2;
  
    this.CAM_fov = this.Zoom * PI / 180;
  
    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
    CAM_x2 = 0;
    CAM_y2 = 0;
    CAM_z2 = this.CAM_dist;
  
    CAM_x2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_y2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    CAM_z2 *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);  
  
  
    this.position_X = CAM_x2 - CAM_x1; 
    this.position_Y = -(CAM_y2 - CAM_y1); 
    this.position_Z = CAM_z2 - CAM_z1;
  }
  
  
  void record_last3DViewport () {
  
    allCameras.options[this.currentCamera][0] = this.position_X;
    allCameras.options[this.currentCamera][1] = this.position_Y;
    allCameras.options[this.currentCamera][2] = this.position_Z;
    allCameras.options[this.currentCamera][3] = this.position_T;
    allCameras.options[this.currentCamera][4] = this.rotation_X;
    allCameras.options[this.currentCamera][5] = this.rotation_Y;
    allCameras.options[this.currentCamera][6] = this.rotation_Z;
    allCameras.options[this.currentCamera][7] = this.rotation_T;
    allCameras.options[this.currentCamera][8] = this.Zoom;
  
    allCameras.Type[this.currentCamera] = this.ViewType;
  }  
  
  
  void apply_currentCamera () {
  
    this.position_X = allCameras.options[this.currentCamera][0];
    this.position_Y = allCameras.options[this.currentCamera][1];
    this.position_Z = allCameras.options[this.currentCamera][2];
    this.position_T = allCameras.options[this.currentCamera][3];
    this.rotation_X = allCameras.options[this.currentCamera][4];
    this.rotation_Y = allCameras.options[this.currentCamera][5];
    this.rotation_Z = allCameras.options[this.currentCamera][6];
    this.rotation_T = allCameras.options[this.currentCamera][7];
    this.Zoom = allCameras.options[this.currentCamera][8];
  
    this.ViewType = allCameras.Type[this.currentCamera];
  }  
  
  
  void transform_3DViewport () {
  
    this.CAM_fov = this.Zoom * PI / 180;
  
    this.CAM_dist = (0.5 * this.refScale) / tan(0.5 * this.CAM_fov);
  
    this.CAM_x = 0;
    this.CAM_y = 0;
    this.CAM_z = this.CAM_dist;
  
  
    this.CAM_x *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_y *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
    this.CAM_z *= tan(0.5 * this.CAM_fov) / tan(0.5 * PI / 3.0);
  
    this.CAM_x -= this.position_X;
    this.CAM_y += this.position_Y;
    this.CAM_z -= this.position_Z;
  
    float px, py, pz;
  
    px = this.CAM_x;
    py = this.CAM_y * funcs.cos_ang(this.rotation_X) - this.CAM_z * funcs.sin_ang(this.rotation_X);
    pz = this.CAM_y * funcs.sin_ang(this.rotation_X) + this.CAM_z * funcs.cos_ang(this.rotation_X);
  
    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;
  
    pz = this.CAM_z;
    px = this.CAM_x * funcs.cos_ang(this.rotation_Z) - this.CAM_y * funcs.sin_ang(this.rotation_Z);
    py = this.CAM_x * funcs.sin_ang(this.rotation_Z) + this.CAM_y * funcs.cos_ang(this.rotation_Z);
  
    this.CAM_x = px;
    this.CAM_y = py;
    this.CAM_z = pz;   
  
    //println("Camera:", nf(this.CAM_x,0,4), nf(this.CAM_y,0,4), nf(this.CAM_z,0,4));
  }
  
  
  
  float[] calculate_Click3D (float Image_X, float Image_Y) {
  
    float PNT_x = FLOAT_undefined;
    float PNT_y = FLOAT_undefined;
    float PNT_z = FLOAT_undefined;
  
    if (this.ViewType == 1) {
  
      PNT_z = 0.5/ tan(0.5 * PI / 3.0); //100; // for perspective: any value the plane we need the results on!
  
      PNT_x = PNT_z * Image_X / ((0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale);
      PNT_y = PNT_z * -Image_Y / ((0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale);
    } else {
      float ZOOM = this.Orthographic_ZOOM();
  
      PNT_z = (0.5 * this.refScale) / tan(0.5 * PI / 3.0); // for orthographic: should be this.
  
      PNT_x = ZOOM * Image_X / (0.5 * this.scale);
      PNT_y = ZOOM * -Image_Y / (0.5 * this.scale);
    }
  
    float px, py, pz;
  
    px = PNT_x;
    py = PNT_y * funcs.cos_ang(-this.rotation_X) - PNT_z * funcs.sin_ang(-this.rotation_X);
    pz = PNT_y * funcs.sin_ang(-this.rotation_X) + PNT_z * funcs.cos_ang(-this.rotation_X);
  
    PNT_x = px;
    PNT_y = py;
    PNT_z = pz;
  
    pz = PNT_z;
    px = PNT_x * funcs.cos_ang(this.rotation_Z) - PNT_y * funcs.sin_ang(this.rotation_Z);
    py = PNT_x * funcs.sin_ang(this.rotation_Z) + PNT_y * funcs.cos_ang(this.rotation_Z);
  
    PNT_x = px;
    PNT_y = py;
    PNT_z = pz;    
  
    PNT_x += this.CAM_x;
    PNT_y += this.CAM_y;
    PNT_z -= this.CAM_z;  
  
    float[] return_array = {
      PNT_x, PNT_y, -PNT_z
    };
  
    return return_array;
  }
  
  
  
  
  float[] calculate_Perspective_Internally (float x, float y, float z) {
  
    float Image_X = FLOAT_undefined;
    float Image_Y = FLOAT_undefined;
    float Image_Z = -FLOAT_undefined; // negative so that it automatically illuminated by Draw function 
  
  
    float px, py, pz;
  
    x -= this.CAM_x;
    y -= this.CAM_y;
    z += this.CAM_z;
  
    pz = z;
    px = x * funcs.cos_ang(-this.rotation_Z) - y * funcs.sin_ang(-this.rotation_Z);
    py = x * funcs.sin_ang(-this.rotation_Z) + y * funcs.cos_ang(-this.rotation_Z);
  
    x = px;
    y = py;
    z = pz;    
  
    px = x;
    py = y * funcs.cos_ang(this.rotation_X) - z * funcs.sin_ang(this.rotation_X);
    pz = y * funcs.sin_ang(this.rotation_X) + z * funcs.cos_ang(this.rotation_X);
  
    x = px;
    y = py;
    z = pz;
  
  
    if (z > 0) {
      if (this.ViewType == 1) {
  
        Image_X = (x / z) * (0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale;
        Image_Y = -(y / z) * (0.5 * this.scale / tan(0.5 * this.CAM_fov)) * this.refScale;
        Image_Z = z;
      } else {
  
        float ZOOM = this.Orthographic_ZOOM();
  
        Image_X = (x / ZOOM) * (0.5 * this.scale);
        Image_Y = -(y / ZOOM) * (0.5 * this.scale);
        Image_Z = z;
      }
    }
  
    float[] theValues = {
      Image_X, Image_Y, Image_Z
    };
  
    return theValues;
  }
  
  

  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setFloat("CAM_x", this.CAM_x);
    parent.setFloat("CAM_y", this.CAM_y);
    parent.setFloat("CAM_z", this.CAM_z);
    parent.setFloat("CAM_fov", this.CAM_fov);
    parent.setFloat("CAM_dist", this.CAM_dist);
    parent.setFloat("CAM_clipNear", this.CAM_clipNear);
    parent.setFloat("CAM_clipFar", this.CAM_clipFar);
    parent.setInt("currentCamera", this.currentCamera);
    
    parent.setFloat("refScale", this.refScale);
    parent.setFloat("position_X", this.position_X);
    parent.setFloat("position_Y", this.position_Y);
    parent.setFloat("position_Z", this.position_Z);
    parent.setFloat("position_T", this.position_T);
    parent.setFloat("rotation_X", this.rotation_X);
    parent.setFloat("rotation_Y", this.rotation_Y);
    parent.setFloat("rotation_Z", this.rotation_Z);
    parent.setFloat("rotation_T", this.rotation_T);
    parent.setFloat("Zoom", this.Zoom);
    parent.setInt("ViewType", this.ViewType);
    parent.setInt("FacesShade", this.FacesShade);    
    
    parent.setInt("UI_CurrentTask", this.UI_CurrentTask);
    parent.setInt("UI_OptionXorY", this.UI_OptionXorY);
    parent.setInt("UI_TaskModifyParameter", this.UI_TaskModifyParameter);      
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.CAM_x = parent.getFloat("CAM_x");
    this.CAM_y = parent.getFloat("CAM_y");
    this.CAM_z = parent.getFloat("CAM_z");
    this.CAM_fov = parent.getFloat("CAM_fov");
    this.CAM_dist = parent.getFloat("CAM_dist");
    this.CAM_clipNear = parent.getFloat("CAM_clipNear");
    this.CAM_clipFar = parent.getFloat("CAM_clipFar");
    this.currentCamera = parent.getInt("currentCamera");
    
    this.refScale = parent.getFloat("refScale");
    this.position_X = parent.getFloat("position_X");
    this.position_Y = parent.getFloat("position_Y");
    this.position_Z = parent.getFloat("position_Z");
    this.position_T = parent.getFloat("position_T");
    this.rotation_X = parent.getFloat("rotation_X");
    this.rotation_Y = parent.getFloat("rotation_Y");
    this.rotation_Z = parent.getFloat("rotation_Z");
    this.rotation_T = parent.getFloat("rotation_T");
    this.Zoom = parent.getFloat("Zoom");
    this.ViewType = parent.getInt("ViewType");
    this.FacesShade = parent.getInt("FacesShade");

    this.UI_CurrentTask = parent.getInt("UI_CurrentTask");
    this.UI_OptionXorY = parent.getInt("UI_OptionXorY");
    this.UI_TaskModifyParameter = parent.getInt("UI_TaskModifyParameter");    
  }       

}

solarchvision_WIN3D WIN3D = new solarchvision_WIN3D();



class solarchvision_WORLD {

  private final static String CLASS_STAMP = "WORLD";
  
  // scales
  float sX = 1;
  float sY = 1;  
  // offsets
  float oX = 0;
  float oY = 0;
  // (top-left) corner
  int cX = int(1.5 * SOLARCHVISION_pixel_H);
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  // width and height
  int dX = int(2.0 * SOLARCHVISION_pixel_H);
  int dY = SOLARCHVISION_pixel_H;
  
  boolean update = true;
  boolean include = true;
  
  
  int numMaps;
  int Zoom = 1; //1:A 2:B 3:C 4:D 5:E and 6:L <<<

  boolean autoView = true;
  
  boolean record_IMG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;  

  float ImageScale = 1.0;

  String ViewFolder;
  
  PImage ViewImage;
  
  PGraphics graphics;

  int VIEW_id = 0;


  
  String[][] VIEW_Name;
  float[][] VIEW_BoundariesX;
  float[][] VIEW_BoundariesY; 
  int[] VIEW_displayGrid;
  String[] VIEW_Filenames;  
  
  int displayAll_SWOB = 0; // 0-2
  int displayAll_NAEFS = 0; // 0-2
  int displayAll_CWEEDS = 0; // 0-2
  int displayAll_CLMREC = 0; // 0-2
  int displayAll_TMYEPW = 1; // 0-2
  
  boolean displayNear_SWOB = false;
  boolean displayNear_NAEFS = false;
  boolean displayNear_CWEEDS = false;
  boolean displayNear_CLMREC = false;
  boolean displayNear_TMYEPW = false;

  void listAllImages () {
  
    this.VIEW_Filenames = sort(OPESYS.getFiles(this.ViewFolder));
  
    this.numMaps = this.VIEW_Filenames.length;
  
    this.VIEW_Name = new String [this.numMaps][2];
  
    this.VIEW_BoundariesX = new float [this.numMaps][2];
    this.VIEW_BoundariesY = new float [this.numMaps][2];
  
    this.VIEW_displayGrid = new int [this.numMaps];
  
    for (int i = 0; i < this.numMaps; i++) {
      String MapFilename = this.ViewFolder + "/" + this.VIEW_Filenames[i];
  
      String[] Parts = split(this.VIEW_Filenames[i], '_');
  
      this.VIEW_BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.VIEW_BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.VIEW_BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.VIEW_BoundariesY[i][1] =  float(Parts[4]) * 0.001;
  
      this.VIEW_Name[i][0] = Parts[5];
      this.VIEW_Name[i][1] = Parts[6];
  
      float a = (this.VIEW_BoundariesY[i][1] - this.VIEW_BoundariesY[i][0]) / 2;
      if (a < 1) a = 1;
      this.VIEW_displayGrid[i] = int(a);
    }
  }  
  
  
  int FindGoodViewport (float pointLongitude, float pointLatitude) {
  
    int return_VIEWPORT = this.VIEW_id;
  
    if (this.autoView) {
  
      float d1 = FLOAT_undefined;
      float d2 = FLOAT_undefined;
  
      for (int i = 0; i < this.numMaps; i++) {
  
        int check_it = 0; 
  
        String started_with = this.VIEW_Filenames[i].substring(0, 1);
  
        if (this.Zoom == 1) {
          if (started_with.equals("A")) check_it = 1;
        } else if (this.Zoom == 2) {
          if (started_with.equals("B")) check_it = 1;
        } else if (this.Zoom == 3) {
          if (started_with.equals("C")) check_it = 1;
        } else if (this.Zoom == 4) {
          if (started_with.equals("D")) check_it = 1;
        } else if (this.Zoom == 5) {
          if (started_with.equals("E")) check_it = 1;
        } else {
          check_it = 1;
        }
  
        if (check_it == 1) {  
  
          if (isInside(pointLongitude, pointLatitude, this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1]) == 1) {
            float d_Center = dist(pointLongitude, pointLatitude, 0.5 * (this.VIEW_BoundariesX[i][0] + this.VIEW_BoundariesX[i][1]), 0.5 * (this.VIEW_BoundariesY[i][0] + this.VIEW_BoundariesY[i][1]));
            float d_Size = dist(this.VIEW_BoundariesX[i][0], this.VIEW_BoundariesY[i][0], this.VIEW_BoundariesX[i][1], this.VIEW_BoundariesY[i][1]);
  
            if (d2 > 0.95 * d_Size) {
              if (d1 > d_Center) {
                d1 = d_Center;
                d2 = d_Size;
  
                return_VIEWPORT = i;
              }
            }
          }
        }
      }
    }
  
    if (return_VIEWPORT != this.VIEW_id) {
      this.loadImages(return_VIEWPORT);
  
      if (Earth3D.displaySurface) WIN3D.update = true;
    }
  
    return (return_VIEWPORT);
  }
  
  
  void loadImages (int n) {

    println("Loading:", this.ViewFolder + "/" + this.VIEW_Filenames[n]);
  
    this.ViewImage = loadImage(this.ViewFolder + "/" + this.VIEW_Filenames[n]);
  }
  

  void drawView () {
  
    if (this.update) {
  
      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_IMG) this.ImageScale = 2;
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;  
      //////////////////////////////////  
  
      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }
  
      this.graphics.background(0, 0, 0);
  
      this.graphics.image(this.ViewImage, 0, 0, this.dX, this.dY);
  
      this.oX = this.VIEW_BoundariesX[this.VIEW_id][0] + 180;
      this.oY = this.VIEW_BoundariesY[this.VIEW_id][1] - 90;
  
      this.sX = (this.VIEW_BoundariesX[this.VIEW_id][1] - this.VIEW_BoundariesX[this.VIEW_id][0]) / 360.0;
      this.sY = (this.VIEW_BoundariesY[this.VIEW_id][1] - this.VIEW_BoundariesY[this.VIEW_id][0]) / 180.0;    
  
      float _lon1 = this.VIEW_BoundariesX[this.VIEW_id][0];
      float _lon2 = this.VIEW_BoundariesX[this.VIEW_id][1];
      float _lat1 = this.VIEW_BoundariesY[this.VIEW_id][0];
      float _lat2 = this.VIEW_BoundariesY[this.VIEW_id][1];
  
      int x_point1 = int(this.dX * (( 1 * (_lon1 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point1 = int(this.dY * ((-1 * (_lat1 - this.oY) / 180.0) + 0.5) / this.sY);
      int x_point2 = int(this.dX * (( 1 * (_lon2 - this.oX) / 360.0) + 0.5) / this.sX);
      int y_point2 = int(this.dY * ((-1 * (_lat2 - this.oY) / 180.0) + 0.5) / this.sY); 
  
  
  
      Tropo3D.draw(TypeWindow.WORLD, STUDY.i_Start, STUDY.i_End);
  
  
      float R_station = 2 * this.ImageScale;
      if (this.VIEW_displayGrid[this.VIEW_id] == 1) R_station = 5; 
  
      this.graphics.ellipseMode(CENTER);
  
      for (int n = 0; n < AERIAL_num; n++) {
  
        //try {
  
        if ((AERIAL_Center_Longitude == STATION.getLongitude()) && (AERIAL_Center_Latitude == STATION.getLatitude())) {
  
          float _lat = AERIAL_Locations[n][1];
          float _lon = AERIAL_Locations[n][0]; 
          if (_lon > 180) _lon -= 360; // << important!
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY; 
  
          this.graphics.pushMatrix();
          this.graphics.translate(x_point, y_point);
  
          if (AERIAL_graphOption == 0) {
            //-----------------------------
            int PAL_type = 6; //12; 
            int PAL_direction = -1;
            float PAL_multiplier = 1.0 / 30.0;
            //-----------------------------
  
            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
                float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
  
                if (is_undefined_FLOAT(_val) == false) {
  
                  float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;
  
                  float[] COL = PAINT.getColorStyle(PAL_type, _u);             
  
                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
  
                    this.graphics.strokeWeight(0);
                    this.graphics.ellipse(0, 0, R_station, R_station);
                  }
  
                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);
  
                    _u = 0.5 + 0.5 * (PAL_multiplier * _val);
  
                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }              
                    if (is_undefined_FLOAT(_val) == false) this.graphics.text(nf(int(funcs.roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }  
  
          if (AERIAL_graphOption == 1) {
  
            //-----------------------------
            int PAL_type = 1;//12; 
            int PAL_direction = 1;//-1;
            float PAL_multiplier = 0.1;//1.0 / 30.0;
            //-----------------------------
  
            for (int _turn = 1; _turn <= 2; _turn++) {
              for (int o = 0; o < GRIB2_maxScenarios; o++) {
  
                //float _val = AERIAL_Data[GRIB2_Hour][LAYER_drybulb.id][n][o];
                float _val = AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
                if (is_undefined_FLOAT(_val) == false) {              
  
                  float teta = AERIAL_Data[GRIB2_Hour][LAYER_winddir.id][n][o];
                  float D_teta = 15; 
                  float R = 0.25 * R_station * AERIAL_Data[GRIB2_Hour][LAYER_windspd.id][n][o];
  
                  float R_in = 0.0 * R; 
                  float x1 = (R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y1 = (R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x2 = (R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y2 = (R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;                      
  
                  float x4 = (R * funcs.cos_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float y4 = (R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta))) * this.ImageScale;
                  float x3 = (R * funcs.cos_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;
                  float y3 = (R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta))) * this.ImageScale;          
  
                  //float ox = -0.5 * (R * funcs.cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -0.5 * (R * -funcs.sin_ang(90 - teta)) * this.ImageScale;
                  //float ox = -1 * (R * funcs.cos_ang(90 - teta)) * this.ImageScale;
                  //float oy = -1 * (R * -funcs.sin_ang(90 - teta)) * this.ImageScale;
                  float ox = -2 * (R * funcs.cos_ang(90 - teta)) / 3.0 * this.ImageScale;
                  float oy = -2 * (R * -funcs.sin_ang(90 - teta)) / 3.0 * this.ImageScale;            
  
                  float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;
  
                  float[] COL = PAINT.getColorStyle(PAL_type, _u);             
  
                  if (_turn == 1) {
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);           
  
                    this.graphics.strokeWeight(0);
                    //this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    this.graphics.quad(x1 + ox, y1 + oy, x2 + ox, y2 + oy, x3 + ox, y3 + oy, x4 + ox, y4 + oy);
                  }
  
                  if (_turn == 2) {
                    this.graphics.textSize(MessageSize * this.ImageScale);
                    this.graphics.textAlign(CENTER, CENTER);
  
                    _u = 0.5 + 0.5 * (PAL_multiplier * _val);
  
                    if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                      this.graphics.stroke(127);
                      this.graphics.fill(127);
                      this.graphics.strokeWeight(0);
                    } else {
                      this.graphics.stroke(255);
                      this.graphics.fill(255);
                      this.graphics.strokeWeight(2 * this.ImageScale);
                    }              
                    if (is_undefined_FLOAT(_val) == false) this.graphics.text(nf(int(funcs.roundTo(_val, 1)), 0), 0, 0);
                  }
                }
              }
            }
          }
  
          this.graphics.popMatrix();
        }
        //}
        //catch (Exception e) {
        //}
      }   
  
  
  
  
      {
        float _lat = STATION.getLatitude();
        float _lon = STATION.getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY; 
  
        this.graphics.strokeWeight(3 * this.ImageScale);
        this.graphics.stroke(0, 0, 127, 255);
        this.graphics.noFill();
  
        this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
      }   
  
      for ( int q = 0; q < ENSEMBLE_OBSERVED_numNearest; q++) {
  
        nearest_Station_ENSEMBLE_OBSERVED_id[q] = -1;
        nearest_Station_ENSEMBLE_OBSERVED_dist[q] = FLOAT_undefined;
    
        for (int f = 0; f < SWOB_Coordinates.length; f++) {
          boolean draw_info = false;
    
          if (this.displayAll_SWOB != 0) draw_info = true;
    
          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude(); 
          if (_lon > 180) _lon -= 360; // << important!
    
          if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
          if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
          if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
          if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
    
          if (draw_info) {
    
            float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
            float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
    
            this.graphics.strokeWeight(0);
            this.graphics.stroke(191, 0, 0, 191);
            this.graphics.fill(191, 0, 0, 191);      
            this.graphics.ellipse(x_point, y_point, R_station, R_station);
    
            if (this.displayAll_SWOB > 1) {
              this.graphics.strokeWeight(0);
              this.graphics.stroke(0);
              this.graphics.fill(0);      
              this.graphics.textAlign(RIGHT, CENTER); 
              this.graphics.textSize(MessageSize * this.ImageScale);
              this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
            }
          }
    
          float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
    
          if (nearest_Station_ENSEMBLE_OBSERVED_dist[q] > d) {
  
            int added_before = 0;
  
            for (int p = 0; p < q; p++) {
              if (nearest_Station_ENSEMBLE_OBSERVED_id[p] == f) added_before = 1;
            }
  
            if (added_before == 0) {
              nearest_Station_ENSEMBLE_OBSERVED_dist[q] = d;
              nearest_Station_ENSEMBLE_OBSERVED_id[q] = f;
            }
          }        
          
        }    
  
        if (this.displayNear_SWOB) {   
          int f = nearest_Station_ENSEMBLE_OBSERVED_id[q];
    
          float _lat = SWOB_Coordinates[f].getLatitude();
          float _lon = SWOB_Coordinates[f].getLongitude(); 
          if (_lon > 180) _lon -= 360; // << important!
    
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
    
          this.graphics.strokeWeight(0);
          this.graphics.stroke(0);
          this.graphics.fill(0);      
          this.graphics.textAlign(RIGHT, CENTER);
          this.graphics.textSize(MessageSize * this.ImageScale);
          this.graphics.text(SWOB_Coordinates[f].getCode(), x_point, y_point);
          //println(SWOB_Coordinates[f].getCode());
        }  
        
      }
  
  
  
      int nearest_WORLD_NAEFS = -1;
      float nearest_WORLD_NAEFS_dist = FLOAT_undefined;
  
      for (int f = 0; f < NAEFposition_Ts.length; f++) {
        boolean draw_info = false;
  
        if (this.displayAll_NAEFS != 0) draw_info = true;
  
        float _lat = NAEFposition_Ts[f].getLatitude();
        float _lon = NAEFposition_Ts[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(0);
          this.graphics.stroke(0, 63, 0, 127);
          this.graphics.fill(0, 63, 0, 127);
  
          this.graphics.ellipse(x_point, y_point, 5 * R_station, 5 * R_station);
  
          if (this.displayAll_NAEFS > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(NAEFposition_Ts[f].getCity(), x_point, y_point);
          }
        }
  
        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_NAEFS_dist > d) {
          nearest_WORLD_NAEFS_dist = d;
          nearest_WORLD_NAEFS = f;
        }
      }
  
      if (this.displayNear_NAEFS) {   
        int f = nearest_WORLD_NAEFS;
  
        float _lat = NAEFposition_Ts[f].getLatitude();
        float _lon = NAEFposition_Ts[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(NAEFposition_Ts[f].getCity(), x_point, y_point);
        //println(NAEFposition_Ts[f].getCity());
      }
  
  
      int nearest_WORLD_CWEEDS = -1;
      float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;
  
      for (int f = 0; f < CWEEDS_coordinates.length; f++) {
        boolean draw_info = false;
  
        if (this.displayAll_CWEEDS != 0) draw_info = true;
  
        float _lat = CWEEDS_coordinates[f].getLatitude();
        float _lon = CWEEDS_coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
          if (this.displayAll_CWEEDS > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(CWEEDS_coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_CWEEDS_dist > d) {
          nearest_WORLD_CWEEDS_dist = d;
          nearest_WORLD_CWEEDS = f;
        }
      } 
  
      if (this.displayNear_CWEEDS) {   
        int f = nearest_WORLD_CWEEDS;
  
        float _lat = CWEEDS_coordinates[f].getLatitude();
        float _lon = CWEEDS_coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CWEEDS_coordinates[f].getCity(), x_point, y_point);
        //println(CWEEDS_coordinates[f].getCity());
      }
  
  
      int nearest_WORLD_CLMREC = -1;
      float nearest_WORLD_CLMREC_dist = FLOAT_undefined;
  
      for (int f = 0; f < CLMREC_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (this.displayAll_CLMREC != 0) draw_info = true;
        
        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(1 * this.ImageScale);
          this.graphics.stroke(0, 0, 0, 191);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 0.5 * R_station, 0.5 * R_station);
  
          if (this.displayAll_CLMREC > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(0.5 * MessageSize * this.ImageScale);
            this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_CLMREC_dist > d) {
          nearest_WORLD_CLMREC_dist = d;
          nearest_WORLD_CLMREC = f;
        }
      } 
  
      if (this.displayNear_CLMREC) {   
        int f = nearest_WORLD_CLMREC;
  
        float _lat = CLMREC_Coordinates[f].getLatitude();
        float _lon = CLMREC_Coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(CLMREC_Coordinates[f].getCity(), x_point, y_point);
        //println(CLMREC_Coordinates[f].getCity());
      }
  
      int nearest_WORLD_TMYEPW = -1;
      float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;
  
      for (int f = 0; f < TMYEPW_Coordinates.length; f++) {
        boolean draw_info = false;
  
        if (this.displayAll_TMYEPW != 0) draw_info = true;
  
        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude(); 
        if (_lon > 180) _lon -= 360; // << important!
  
        if (_lon < this.VIEW_BoundariesX[this.VIEW_id][0]) draw_info = false;
        if (_lon > this.VIEW_BoundariesX[this.VIEW_id][1]) draw_info = false;
        if (_lat < this.VIEW_BoundariesY[this.VIEW_id][0]) draw_info = false;
        if (_lat > this.VIEW_BoundariesY[this.VIEW_id][1]) draw_info = false; 
  
        if (draw_info) {
  
          float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
          float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
          this.graphics.strokeWeight(2 * this.ImageScale);
          this.graphics.stroke(255, 0, 0, 127);
          this.graphics.noFill();
          this.graphics.ellipse(x_point, y_point, 3 * R_station, 3 * R_station);
  
          if (this.displayAll_TMYEPW > 1) {
            this.graphics.strokeWeight(0);
            this.graphics.stroke(0);
            this.graphics.fill(0);      
            this.graphics.textAlign(RIGHT, CENTER); 
            this.graphics.textSize(MessageSize * this.ImageScale);
            this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
          }
        }
  
        float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
        if (nearest_WORLD_TMYEPW_dist > d) {
          nearest_WORLD_TMYEPW_dist = d;
          nearest_WORLD_TMYEPW = f;
        }
      } 
  
      if (this.displayNear_TMYEPW) {   
        int f = nearest_WORLD_TMYEPW;
  
        float _lat = TMYEPW_Coordinates[f].getLatitude();
        float _lon = TMYEPW_Coordinates[f].getLongitude();  
        if (_lon > 180) _lon -= 360; // << important!      
  
        float x_point = this.dX * (( 1 * (_lon - this.oX) / 360.0) + 0.5) / this.sX;
        float y_point = this.dY * ((-1 * (_lat - this.oY) / 180.0) + 0.5) / this.sY;
  
        this.graphics.strokeWeight(0);
        this.graphics.stroke(0);
        this.graphics.fill(0);      
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.textSize(MessageSize * this.ImageScale);
        this.graphics.text(TMYEPW_Coordinates[f].getCity(), x_point, y_point);
        //println(TMYEPW_Coordinates[f].getCity());
      }
  
  
      this.graphics.strokeWeight(0);
  
  
      if (this.record_PDF) {
        endRecord();
  
        String myFile = MAKE_Filename(createStamp(0, CLASS_STAMP)) + ".pdf";
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();
  
        if ((this.record_IMG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".jpg";
          this.graphics.save(myFile);
          SOLARCHVISION_explore_output(myFile);
          println("File created:" + myFile);
        }
  
        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }
  
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;  
      //////////////////////////////////
  
      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.update = false; //1;
      } else {
        this.update = false;
      }
  
  
      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;
    }
  }
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setInt("Zoom", this.Zoom);
    
    parent.setInt("displayAll_SWOB", this.displayAll_SWOB);
    parent.setInt("displayAll_NAEFS", this.displayAll_NAEFS);
    parent.setInt("displayAll_CWEEDS", this.displayAll_CWEEDS);
    parent.setInt("displayAll_CLMREC", this.displayAll_CLMREC);
    parent.setInt("displayAll_TMYEPW", this.displayAll_TMYEPW);
    
    parent.setString("displayNear_SWOB", Boolean.toString(this.displayNear_SWOB));
    parent.setString("displayNear_NAEFS", Boolean.toString(this.displayNear_NAEFS));
    parent.setString("displayNear_CWEEDS", Boolean.toString(this.displayNear_CWEEDS));
    parent.setString("displayNear_CLMREC", Boolean.toString(this.displayNear_CLMREC));
    parent.setString("displayNear_TMYEPW", Boolean.toString(this.displayNear_TMYEPW));
  }

  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.Zoom = parent.getInt("Zoom");
    
    this.displayAll_SWOB = parent.getInt("displayAll_SWOB");
    this.displayAll_NAEFS = parent.getInt("displayAll_NAEFS");
    this.displayAll_CWEEDS = parent.getInt("displayAll_CWEEDS");
    this.displayAll_CLMREC = parent.getInt("displayAll_CLMREC");
    this.displayAll_TMYEPW = parent.getInt("displayAll_TMYEPW");

    this.displayNear_SWOB = Boolean.parseBoolean(parent.getString("displayNear_SWOB"));
    this.displayNear_NAEFS = Boolean.parseBoolean(parent.getString("displayNear_NAEFS"));
    this.displayNear_CWEEDS = Boolean.parseBoolean(parent.getString("displayNear_CWEEDS"));
    this.displayNear_CLMREC = Boolean.parseBoolean(parent.getString("displayNear_CLMREC"));      
    this.displayNear_TMYEPW = Boolean.parseBoolean(parent.getString("displayNear_TMYEPW"));        
  }    
    
}

solarchvision_WORLD WORLD = new solarchvision_WORLD();



class solarchvision_STUDY {
  
  private final static String CLASS_STAMP = "STUDY";

  int pallet_SORT_CLR = -1;
  int pallet_SORT_DIR = -1;
  float pallet_SORT_MLT = 2;
  
  int pallet_PROB_CLR = -1;
  int pallet_PROB_DIR = 1;
  float pallet_PROB_MLT = 0.5;
  
  int ACTIVE_pallet_CLR = 19; //15; //14; 
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1; //2;
  
  int PASSIVE_pallet_CLR = 1; 
  int PASSIVE_pallet_DIR = 1;
  float PASSIVE_pallet_MLT = 4; //1; 


  int cX = 0;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + SOLARCHVISION_pixel_H;
  int dX = 2 * SOLARCHVISION_pixel_W;
  int dY = 1 * SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);
  float view_S;
  
  boolean update = true;
  boolean include = true;

  boolean record_IMG = false;
  boolean record_PDF = false;
  boolean record_AUTO = false;   
  

  int i_Start = 0;
  int i_End = 23;
  
  int j_Start = 0; // constant
  int j_End = 12; //8; //6; //2; //16; // Variable  

  float perDays = 30.5; //1; //45; //61; //30.5;
  int joinDays = 31; //1; //30;//perDays; // it should be set up to 1 in order to plot only one day  
  
  boolean PrintTtitle = true;
  
  float T_scale = 0.5;
  float U_scale = 18.0 / float(j_End - j_Start);
  
  float V_scale;
  float V_offset;
  float V_belowLine;

  int skyScenario = 1; // 1: all scenarios, 2: Total Cloud Cover < 0.33, 3: middle range, 4: Total Cloud Cover > 0.66
  int filter = filter_DAILY;
  
  int TrendJoinHours = 24; //48;
  int TrendJoinType = -1; // -1: increasing weights, +1: equal weights
  
  boolean export_info_node = false;
  boolean export_info_norm = false;
  boolean export_info_prob = false;
  

  float X_control;
  float Y_control;
  
  
  float position_X = 0;
  float position_Y = 0;
  
  float O_scale = 50.0;
  float W_scale = 3.0;
  
  float rect_scale = 0.005;
  float rect_offset_x = 0.5;
  
  boolean impact_summary = false;
  
  int ImpactLayer = 1; // 4 = Median
  int PlotImpacts = 4; //-2/-1:wind 0/1:urban 2/3:globe 4/5:sun-path 6/7:view-from-sun 8/9:two-cycles
  boolean Impacts_update = true; 
  
  boolean displayRaws = false;
  boolean displaySorted = true;
  boolean displayNormals = true;
  boolean displayProbs = false;
  
  int sumInterval = 2;
  float LevelPix = 8;
  
  float Pix = 0; 
  
  color color_data_raws = color(0, 0, 0);
  
  int plotSetup = 14; //4; //12; //13;
  
  float ImageScale = 1.0;
  
  PGraphics graphics;
  
  
  
  
  
  boolean isInHourlyRange (float i) {
    boolean result = true;
    if (this.i_Start <= this.i_End) {
      result = false;
      if ((this.i_Start <= i) && (i <= (this.i_End + 24) % 24)) result = true;
    } else {
      result = true;
      if ((this.i_Start > i) && (i > (this.i_End + 24) % 24)) result = false;
    }
    return result;
  }  
  
  
  void keyPressed (KeyEvent e) {
  
    if (e.isAltDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      } else {
        switch(key) {
        case '0' : 
          Camera_Variation = 0; 
          this.update = true; 
          break;
        case '1' : 
          Camera_Variation = 1; 
          this.update = true; 
          break;
        case '2' : 
          Camera_Variation = 2; 
          this.update = true; 
          break;
        case '3' : 
          Camera_Variation = 3; 
          this.update = true; 
          break;
        case '4' : 
          Camera_Variation = 4; 
          this.update = true; 
          break;
        case '5' : 
          Camera_Variation = 5; 
          this.update = true; 
          break;
        case '6' : 
          Camera_Variation = 6; 
          this.update = true; 
          break;
          //case '7' : Camera_Variation = 7; this.update = true; break;
          //case '8' : Camera_Variation = 8; this.update = true; break;
          //case '9' : Camera_Variation = 9; this.update = true; break;
        }
      }
    } else if (e.isControlDown()) {
      if (key == CODED) { 
        switch(keyCode) {
          
        }
      } else {
        switch(key) {
  
        case 'r' : 
          this.record_AUTO = !this.record_AUTO; 
          this.update = false; 
          ROLLOUT.update = true; 
          break;
        case 'R' : 
          this.record_AUTO = !this.record_AUTO; 
          this.update = false; 
          ROLLOUT.update = true; 
          break;
  
        }
      }
    } else if (e.isShiftDown()) {
      if (key == CODED) { 
        switch(keyCode) {
        }
      }
    }
  
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
  
      if (key == CODED) { 
        switch(keyCode) {
  
        case 112 : //F1
          this.PlotImpacts = -2; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 113 : //F2
          this.PlotImpacts = -1; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 114 : //F3
          this.PlotImpacts = 4; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 115 : //F4
          this.PlotImpacts = 5; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;          
        case 116 : //F5
          this.PlotImpacts = 2; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        case 117 : //F6
          this.PlotImpacts = 3; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;                   
        case 118 : //F7
          this.PlotImpacts = 0; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;           
        case 119 : //F8
          this.PlotImpacts = 1; 
          this.update = true; 
          WIN3D.update = true;
          ROLLOUT.update = true; 
          break;
        }
      }
    }
  
    if ((e.isAltDown() != true) && (e.isControlDown() != true)) {
  
      if (key != CODED) { 
        switch(key) {
  
        case '|' :
          if (TIME.date == 1.0 * int(TIME.date)) TIME.date += 0.5;
          else TIME.date -= 0.5;
          TIME.updateDate(); 
          update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
          break;
  
        case ';': 
          this.impact_summary = !(this.impact_summary);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '?' :
          STUDY.refreshDateTabs();                   
          DevelopData_update = true;
          UI_BAR_d.update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '}' :
          this.j_End += 1; 
          if (this.j_End > this.j_Start + 61) this.j_End -= 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
           this.perDays = int(365 / float(this.j_End - this.j_Start));
           } 
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.perDays = 1;
           }
           */
          DevelopData_update = true;
  
          VertexSolar_rebuild_array = true;
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;
          allSections.resize_solarImpact_array();
  
          UI_BAR_d.update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '{' :
          this.j_End -= 1; 
          if (this.j_End <= this.j_Start) this.j_End += 1;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
          /*
           if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
           this.perDays = int(365 / float(this.j_End - this.j_Start));
           } 
           if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
           this.perDays = 1;
           }                  
           */
          DevelopData_update = true;
  
          VertexSolar_rebuild_array = true; 
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;   
          allSections.resize_solarImpact_array();
  
          UI_BAR_d.update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'a'  :
          Develop_AngleInclination -= 5;
          if (Develop_AngleInclination < -90) Develop_AngleInclination = -90;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'A'  :
          Develop_AngleInclination += 5;
          if (Develop_AngleInclination > 90) Develop_AngleInclination = 90;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'z' :
          Develop_AngleOrientation = (Develop_AngleOrientation - 5 + 360) % 360;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'Z' :
          Develop_AngleOrientation = (Develop_AngleOrientation + 5) % 360;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case 'd' :
          Develop_DayHour = (Develop_DayHour + 1) % 4;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
        case 'D' :
          Develop_DayHour = (Develop_DayHour - 1 + 4) % 4;
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break; 
  
        case '>' :
          if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) {
            this.O_scale *= pow(2.0, (1.0 / 4.0));
          } else {
            this.ImpactLayer = (this.ImpactLayer + 1) % 9;
          }
          this.update = true;
          ROLLOUT.update = true; 
          break;
        case '<' :
          if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) {
            this.O_scale *= pow(0.5, (1.0 / 4.0));
          } else {
            this.ImpactLayer = (this.ImpactLayer + 9 - 1) % 9;
          }
          this.update = true;
          ROLLOUT.update = true; 
          break;
  
  
  
  
          //case 'g' :this.filter = (this.filter + 1) % 2; DevelopData_update = true; this.update = true; ROLLOUT.update = true; break;
          //case 'G' :this.filter = (this.filter + 2 - 1) % 2; DevelopData_update = true; this.update = true; ROLLOUT.update = true; break;
  
        case '=' :
          this.V_scale *= pow(2.0, (1.0 / 2.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '_' :
          this.V_scale *= pow(0.5, (1.0 / 2.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'c' :
          COLOR_STYLE_Current = (COLOR_STYLE_Current + 1) % COLOR_STYLE_Number; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'C' :
          COLOR_STYLE_Current = (COLOR_STYLE_Current - 1 + COLOR_STYLE_Number) % COLOR_STYLE_Number; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'V' :
          this.displayRaws = !this.displayRaws; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'v' :
          this.displayRaws = !this.displayRaws; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '`' :
          this.joinDays += 2;
          if (this.joinDays > 365) this.joinDays = 365;
          DevelopData_update = true; 
          UI_BAR_d.update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '~' :
          this.joinDays -= 2;
          if (this.joinDays < 1) this.joinDays = 1;
          DevelopData_update = true; 
          UI_BAR_d.update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'l' :
          Materials_Selection += 1;
          Materials_Selection %= Materials_Number; 
          DevelopData_update = true;
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'L' :
          Materials_Selection += Materials_Number - 1;
          Materials_Selection %= Materials_Number;
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;  
  
        case 'm' :
          this.displaySorted = !this.displaySorted; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'M' :
          this.displaySorted = !this.displaySorted; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'n' :
          this.displayNormals = !this.displayNormals; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'N' :
          this.displayNormals = !this.displayNormals; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'b' :
          this.displayProbs = !this.displayProbs; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'B' :
          this.displayProbs = !this.displayProbs; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'j' :
          if (this.LevelPix < 32) this.LevelPix *= pow(2.0, (1.0 / 1.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'J' :
          if (this.LevelPix > 2) this.LevelPix *= pow(0.5, (1.0 / 1.0)); 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 'i' :
          if (this.sumInterval > 24) this.sumInterval -= 24;
          if (this.sumInterval > 6) this.sumInterval -= 6; 
          else if (this.sumInterval > 1) this.sumInterval -= 1;
          if (this.sumInterval == 5) this.sumInterval = 4;
          println(CLASS_STAMP + ".sumInterval =", this.sumInterval);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'I' :
          if (this.sumInterval < 6) this.sumInterval += 1;
          else if (this.sumInterval < 24) this.sumInterval += 6;
          else this.sumInterval += 24;
          if (this.sumInterval == 5) this.sumInterval = 6;
          println(CLASS_STAMP + ".sumInterval =", this.sumInterval);
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case '!' :
          this.skyScenario = 1; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '@' :
          this.skyScenario = 2; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '#' :
          this.skyScenario = 3; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case '$' :
          this.skyScenario = 4; 
          DevelopData_update = true; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
  
        case 's' : 
          this.record_IMG = true; 
          this.record_PDF = false; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        case 'S' : 
          this.record_PDF = true; 
          this.record_IMG = false; 
          this.update = true; 
          ROLLOUT.update = true; 
          break;
        }
      }
    }
  }
  


  void drawTimeGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    this.graphics.strokeWeight(this.T_scale * 1);
  
    float Shift_DOWN = 0;
    if (this.V_belowLine != 0) Shift_DOWN = -100;
  
    for (int i = 100; i >= Shift_DOWN; i -= 25) {
      if (-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1) != 0) {
        this.graphics.stroke(0, 63);
        this.graphics.fill(0, 63);
      } else {
        this.graphics.stroke(0);
        this.graphics.fill(0);
      }
      this.graphics.line(this.j_Start * sx_Plot, -i * this.view_S, this.j_End * sx_Plot, -i * this.view_S); 
  
      if ((i >= 0) || (this.V_belowLine != 0)) {  
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER);
        this.graphics.text(((nf(-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1), 0, 1)) + CurrentLayer_unit), -5, -i * this.view_S);
        //this.graphics.text(((String.valueOf(int(-this.V_offset + funcs.roundTo(i / this.V_scale, 0.1)))) + CurrentLayer_unit), -5, -i * this.view_S);
      }
    }
  
    this.graphics.stroke(0, 63);
    this.graphics.fill(0, 63); 
    for (int i = this.j_Start; i <= this.j_End; i++) {
      if (i < this.j_End) {
        int j_step = 3;
        for (int j = j_step; j <= 24; j += j_step) {
          if (j != 24) {
            this.graphics.line((i + j / 24.0) * sx_Plot, -5 * this.view_S, (i + j / 24.0) * sx_Plot, 5 * this.view_S);
          } else {
            this.graphics.line((i + j / 24.0) * sx_Plot, -105 * this.view_S, (i + j / 24.0) * sx_Plot, (5 - Shift_DOWN) * this.view_S);
          }
        }
      }
    }
  
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER); 
  
    for (int i = this.j_Start; i < this.j_End; i++) {
      if (this.U_scale >= 0.75) {
        this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
        this.graphics.text("12:00", (i - ((0 - 12) / 24.0)) * sx_Plot, 0.1 * sx_Plot / this.U_scale);
      }
    }
  
    this.drawInfo(sx_Plot, this.V_belowLine);
  }  
  
  
  
  void drawPositionGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int fill_back) {
    this.graphics.strokeWeight(this.T_scale * 1);
  
    if (fill_back != 0) {
      for (int i = this.j_Start; i < this.j_End; i++) {
  
        this.graphics.stroke(223);
        this.graphics.fill(223);
        this.graphics.ellipse((i + this.rect_offset_x) * sx_Plot, 0, 2 * 90 * this.rect_scale * sx_Plot, 2 * 90 * this.rect_scale * sx_Plot);
      }
    }
  
    for (int i = this.j_Start; i < this.j_End; i++) {
      for (int t = 0; t < 360; t += 15) {
  
        if ((t % 45) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.fill(0, 63);
        } else {
  
          this.graphics.stroke(0);
          this.graphics.fill(0);
        }
        int r = 0;
        if ((t % 45) != 0) r = 15;
  
        this.graphics.line((i + this.rect_offset_x + r * this.rect_scale * (funcs.cos_ang(t))) * sx_Plot, -(r * this.rect_scale * (funcs.sin_ang(t))) * sx_Plot, (i + this.rect_offset_x + 90 * this.rect_scale * (funcs.cos_ang(t))) * sx_Plot, -(90 * this.rect_scale * (funcs.sin_ang(t))) * sx_Plot); 
  
        if (((t + 45) % 90) == 0) {
          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.150 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);
  
          String ORI = "";
          switch((360 + 90 - t) % 360) {
          case 0 : 
            ORI = "N"; 
            break;
          case 45 : 
            ORI = "NE"; 
            break;
          case 90 : 
            ORI = "E"; 
            break;
          case 135 : 
            ORI = "SE"; 
            break;
          case 180 : 
            ORI = "S"; 
            break;
          case 225 : 
            ORI = "SW"; 
            break;
          case 270 : 
            ORI = "W"; 
            break;
          case 315 : 
            ORI = "NW"; 
            break;
          }
  
          this.graphics.text(ORI, (i + this.rect_offset_x + 110 * this.rect_scale * (funcs.cos_ang(t))) * sx_Plot, -(110 * this.rect_scale * (funcs.sin_ang(t))) * sx_Plot);
          //this.graphics.text(String.valueOf((360 + 90 - t) % 360), (i + this.rect_offset_x + 110 * this.rect_scale * (funcs.cos_ang(t))) * sx_Plot, -(110 * this.rect_scale * (funcs.sin_ang(t))) * sx_Plot);
        }
      }
  
      float impact_scale = 1;
      if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) impact_scale = LAYER_windspd.V_scale * 45 / 50.0;
  
      for (int r = 90; r > 0; r -= 15) {
        if ((r % 90) != 0) {
          this.graphics.stroke(0, 63);
          this.graphics.noFill();
        } else {
          this.graphics.stroke(0);
          this.graphics.noFill();
        }
  
        this.graphics.ellipse((i + this.rect_offset_x) * sx_Plot, 0, 2 * r * this.rect_scale * sx_Plot, 2 * r * this.rect_scale * sx_Plot);
  
        int t = 90;
        if (t == 90) {
          this.graphics.stroke(0, 127);
          this.graphics.fill(0, 127);
          this.graphics.textSize(sx_Plot * 0.200 / this.U_scale);
          this.graphics.textAlign(CENTER, CENTER);
          this.graphics.text(nf(int(r / impact_scale), 1), (i + this.rect_offset_x + r * this.rect_scale * (funcs.cos_ang(t))) * sx_Plot, -(r * this.rect_scale * (funcs.sin_ang(t))) * sx_Plot);
        }
      }
    }
  }  
  
  
  void drawDailyGrid (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textAlign(CENTER, CENTER); 
  
    for (int j = this.j_Start; j < this.j_End; j++) {
      if ((this.U_scale >= 0.75) || (((j - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
        this.graphics.text(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay), (j - ((0 - 12) / 24.0)) * sx_Plot, -1.0 * sx_Plot / this.U_scale);
        if (this.joinDays > 1) {
          this.graphics.text(("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -0.8 * sx_Plot);
        }
      }
    }
  
    this.drawInfo(sx_Plot, 1);
  }
  
  
  void drawInfo (float sx_Plot, float V_belowLine) {
    this.graphics.stroke(0);
    this.graphics.fill(0);
    this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
    this.graphics.textAlign(RIGHT, TOP);
    
    String txt = STATION.getCity();
  
    if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
      txt += "\n(" + nf(TIME.year, 4) + "_" + nf(TIME.month, 2) + "_" + nf(TIME.day, 2) + "_" + nf(TIME.hour, 2) + ")";
    }
  
    this.graphics.text(txt, -1.0 * sx_Plot / this.U_scale, -1.25 * sx_Plot / this.U_scale);
  
    switch(this.skyScenario) {
    case 1 : 
      this.graphics.stroke(0, 0, 0); 
      this.graphics.fill(0, 0, 0); 
      break;
    case 2 : 
      this.graphics.stroke(0, 0, 255); 
      this.graphics.fill(0, 0, 255); 
      break;
    case 3 : 
      this.graphics.stroke(0, 127, 0); 
      this.graphics.fill(0, 127, 0); 
      break;
    case 4 : 
      this.graphics.stroke(255, 0, 0); 
      this.graphics.fill(255, 0, 0); 
      break;
    }
  
    this.graphics.textAlign(RIGHT, TOP);
  
    this.graphics.text(skyScenario_Title[this.skyScenario], -0.8 * sx_Plot / this.U_scale, -1.0 * sx_Plot / this.U_scale);
  }  
  
  
  
  void drawData (float[] Ax_LINES, float[] Ay_LINES, float[] Az_LINES, float[] Bx_LINES, float[] By_LINES, float[] Bz_LINES) {
    //this.graphics.stroke(this.color_data_raws);
    //this.graphics.fill(this.color_data_raws);
    //this.graphics.strokeWeight(this.T_scale * 1);
  
    this.graphics.stroke(0, PAINT.getOpacity(this.O_scale));
    this.graphics.fill(0, PAINT.getOpacity(this.O_scale));
    this.graphics.strokeWeight(this.T_scale * 0.5);
  
    for (int i = 0; i < Ax_LINES.length; i++) {
      this.graphics.line(Ax_LINES[i], Ay_LINES[i], Bx_LINES[i], By_LINES[i]);
    }
  }
  
  
  void drawProbs (int i, int j, float[] valuesSUM, float[] valuesNUM, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {

    this.Pix = (100.0 * this.view_S / this.LevelPix);

    int PAL_type = this.pallet_PROB_CLR; 
    int PAL_direction = this.pallet_PROB_DIR;  
    float PAL_multiplier = this.pallet_PROB_MLT;
  
    float txt_max_width = (this.sumInterval * this.view_S * 100 / 24.0) * this.U_scale;
    float txt_max_height = this.Pix;
    if (txt_max_height > txt_max_width) {
      this.graphics.textSize(0.9 * txt_max_width);
    }
    else {
      this.graphics.textSize(0.9 * txt_max_height);
    }
    this.graphics.textAlign(CENTER, CENTER);
    this.graphics.strokeWeight(this.T_scale * 0);    
    
    
    
    
    
    
    
    
    float min_v = FLOAT_undefined;
    float max_v = -FLOAT_undefined;
  
    for (int k = 0; k < valuesSUM.length; k++) {
      if (is_undefined_FLOAT(valuesSUM[k]) == false) {
        if (min_v > valuesSUM[k]) min_v = valuesSUM[k];
        if (max_v < valuesSUM[k]) max_v = valuesSUM[k];
      }
    }     
    
    
    if ((is_undefined_FLOAT(min_v) == false) && (is_undefined_FLOAT(-max_v) == false)) {    
      min_v = funcs.roundTo((min_v * abs(sy_Plot)), this.Pix) / this.Pix;
      max_v = funcs.roundTo((max_v * abs(sy_Plot)), this.Pix) / this.Pix;
  
      if (CurrentLayer_id == LAYER_winddir.id) min_v = 0;
    
      int[] _probs;
      int total_probs = 0;
  
      _probs = new int [floor(max_v - min_v) + 1];
  
      for (int k = 0; k < valuesSUM.length; k++) {
        if (is_undefined_FLOAT(valuesSUM[k]) == false) {
          float the_value = valuesSUM[k];
  
          if (CurrentLayer_id == LAYER_winddir.id) {
            if (funcs.roundTo((the_value * abs(sy_Plot)), this.Pix) >= (360 * abs(sy_Plot))) the_value -= 360;
          }

          int h = int(funcs.roundTo((funcs.roundTo((the_value * abs(sy_Plot)), this.Pix) / this.Pix) - min_v, 1));
          
          if (h < 0) h = 0;
          else if (h > _probs.length - 1) h = _probs.length - 1; 
          _probs[h] += 1;
          total_probs += 1;
        }
      }

      if (total_probs != 0) {
        for (int n = 0; n < _probs.length; n++) {
          float prob_V = 1.0 * _probs[n] / total_probs;
  
          //if (int(funcs.roundTo(100 * prob_V, 1)) > 0) {
          if ((100 * prob_V) > 0) {
  
            float _u = PAL_multiplier * prob_V;
  
            if (PAL_direction == -1) _u = 1 - _u;
            if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_direction == 2) _u =  0.5 * _u;

            float[] COL = PAINT.getColorStyle(PAL_type, _u);
  
            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
  
            this.graphics.strokeWeight(this.T_scale * 0); 
            this.graphics.rect((j + ((i + 1) / 24.0)) * sx_Plot, -((min_v + n - 0.5) * this.Pix * -sy_Plot), -(this.sumInterval * this.view_S * 100 / 24.0) * this.U_scale, this.Pix * -sy_Plot); 
  
            if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
              this.graphics.stroke(127);
              this.graphics.fill(127);
              this.graphics.strokeWeight(0);
            } else {
              this.graphics.stroke(255);
              this.graphics.fill(255);
              this.graphics.strokeWeight(2);
            }   
            this.graphics.text((String.valueOf(int(funcs.roundTo(100 * prob_V, 1)))), (j + ((i + 1) / 24.0)) * sx_Plot - 0.5 * (this.sumInterval * this.view_S * 100 / 24.0) * this.U_scale, -((min_v + n) * this.Pix * sy_Plot) - 0.05 * txt_max_height);
  
            if ((this.export_info_prob) && (this.displayProbs)) {
              FILE_outputProbs[(j - this.j_Start)].print(nfs((min_v + n) * this.Pix / abs(sy_Plot) - this.V_offset, 5, 5) + ":\t" + nf(100 * prob_V, 3, 3) + "\t");
            }

          }
        }  
  
        if ((this.export_info_prob) && (this.displayProbs)) {
          FILE_outputProbs[(j - this.j_Start)].println("");
        }
      }
    }

    float pal_length = 400;
    float pal_ox = 700;
    float pal_oy = (50 * this.V_belowLine) + 50;
 
    for (int q = 0; q < 11; q++) {
      float prob_V = 10 * q / 100.0;

      float _u = PAL_multiplier * prob_V;
  
      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_type, _u);  
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);     
  
      this.graphics.strokeWeight(0); 

      this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);
  
      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }   
  
      this.graphics.textSize(15.0 * this.view_S);
      this.graphics.textAlign(CENTER, CENTER);
      this.graphics.text((String.valueOf(int(funcs.roundTo(100 * prob_V, 1)))), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
    }
  }
  
  
  void drawSorted (int i, int j, float[] valuesA, float[] valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    int PAL_type = this.pallet_SORT_CLR; 
    int PAL_direction = this.pallet_SORT_DIR;  
    float PAL_multiplier = this.pallet_SORT_MLT;
  
    float[] sortedvaluesA = sort(valuesA);
    int num_sortedvaluesA = 0;
    for (int l = 0; l < sortedvaluesA.length; l++) {
      if (is_undefined_FLOAT(sortedvaluesA[l]) == false) {
        num_sortedvaluesA += 1;
      } else break;
    }
  
    float[] sortedvaluesB = sort(valuesB);
    int num_sortedvaluesB = 0;
    for (int l = 0; l < sortedvaluesB.length; l++) {
      if (is_undefined_FLOAT(sortedvaluesB[l]) == false) {
        num_sortedvaluesB += 1;
      } else break;
    }
  
    int num_sortedvaluesAB = min(num_sortedvaluesA, num_sortedvaluesB);
  
    for (int l = 0; l < (num_sortedvaluesAB - 1); l++) {
      float sort_V = 1.1 * (0.5 - ((num_sortedvaluesAB - (l + 1)) / float(num_sortedvaluesAB)));
  
      float _u = 0.5 + 0.5 * (PAL_multiplier * sort_V);
  
      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_type, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);    
  
      this.graphics.strokeWeight(this.T_scale * 0.0); 
      //this.graphics.rect((j + ((i + 1) / 24.0)) * sx_Plot, sortedvaluesA[l] * sy_Plot, -(1 * 100 / 24.0) * this.U_scale, (sortedvaluesA[(l + 1)] - sortedvaluesA[l]) * sy_Plot);
  
      float P1x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P2x = (j + ((i + 0.5) / 24.0)) * sx_Plot;
      float P3x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
      float P4x = (j + ((i + 1.5) / 24.0)) * sx_Plot;
  
      float P1y = sortedvaluesA[l] * sy_Plot;
      float P2y = sortedvaluesA[(l + 1)] * sy_Plot;
      float P3y = sortedvaluesB[(l + 1)] * sy_Plot;
      float P4y = sortedvaluesB[l] * sy_Plot; 
  
      this.graphics.quad(P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y);
      /*
      this.graphics.stroke(255);
       this.graphics.strokeWeight(this.T_scale * 0.5); 
       this.graphics.line(P1x, P1y, P4x, P4y); 
       this.graphics.line(P2x, P2y, P3x, P3y);
       */
    }
  
    String[] _txt = {
      "MIN", "", "25%", "", "MED", "", "75%", "", "MAX"
    }; 
    float pal_length = 400;
    float pal_ox = 700;
    float pal_oy = (50 * this.V_belowLine) + 50;
  
    for (int q = 0; q < 9; q++) {
      float sort_V = 1.1 * (q - 4) / 8.0;
  
      float _u = 0.5 + 0.5 * (PAL_multiplier * sort_V);
  
      if (PAL_direction == -1) _u = 1 - _u;
      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
      if (PAL_direction == 2) _u =  0.5 * _u;
  
      float[] COL = PAINT.getColorStyle(PAL_type, _u);
      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);     

      //this.graphics.strokeWeight(0.0);
      this.graphics.stroke(255); 
      this.graphics.strokeWeight(0.5); 
      this.graphics.rect((pal_ox + q * (pal_length / 9.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 9.0) * this.view_S, 20 * this.view_S);
  
      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
        this.graphics.stroke(127);
        this.graphics.fill(127);
        this.graphics.strokeWeight(0);
      } else {
        this.graphics.stroke(255);
        this.graphics.fill(255);
        this.graphics.strokeWeight(2);
      }   
  
      this.graphics.textSize(15.0 * this.view_S);
      this.graphics.textAlign(CENTER, CENTER);
      this.graphics.text(_txt[q], (25 + pal_ox + q * (pal_length / 9.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
    }
  }
  
  
  void drawNormals (int i, int j, float[] valuesA, float[] valuesB, float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    float[] NormalsA = SOLARCHVISION_NORMAL(valuesA);
    float[] NormalsB = SOLARCHVISION_NORMAL(valuesB);
  
    if (CurrentLayer_id == LAYER_winddir.id) {
      float[] XvaluesA;
      float[] YvaluesA;
      XvaluesA = new float [valuesA.length];
      YvaluesA = new float [valuesA.length];
  
      for (int l = 0; l < valuesA.length; l++) {
        if (is_undefined_FLOAT(valuesA[l]) == false) {
          XvaluesA[l] = funcs.cos_ang(90 - valuesA[l]); 
          YvaluesA[l] = funcs.sin_ang(90 - valuesA[l]);
        } else {
          XvaluesA[l] = FLOAT_undefined; 
          YvaluesA[l] = FLOAT_undefined;
        }
      }
  
      float[] X_NormalsA = SOLARCHVISION_NORMAL(XvaluesA);
      float[] Y_NormalsA = SOLARCHVISION_NORMAL(YvaluesA);
  
      for (int l = 0; l < NormalsA.length; l++) {
        if (is_undefined_FLOAT(NormalsA[l]) == false) {
          NormalsA[l] = 90 - funcs.atan2_ang(Y_NormalsA[l], X_NormalsA[l]);
          if (NormalsA[l] < 0) NormalsA[l] += 360;
        }
  
        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsA[l] = FLOAT_undefined;
        }
      }
  
      float[] XvaluesB;
      float[] YvaluesB;
      XvaluesB = new float [valuesB.length];
      YvaluesB = new float [valuesB.length];
  
      for (int l = 0; l < valuesB.length; l++) {
        if (is_undefined_FLOAT(valuesB[l]) == false) {
          XvaluesB[l] = funcs.cos_ang(90 - valuesB[l]); 
          YvaluesB[l] = funcs.sin_ang(90 - valuesB[l]);
        } else {
          XvaluesB[l] = FLOAT_undefined; 
          YvaluesB[l] = FLOAT_undefined;
        }
      }
  
      float[] X_NormalsB = SOLARCHVISION_NORMAL(XvaluesB);
      float[] Y_NormalsB = SOLARCHVISION_NORMAL(YvaluesB);
  
      for (int l = 0; l < NormalsB.length; l++) {
        if (is_undefined_FLOAT(NormalsB[l]) == false) {
          NormalsB[l] = 90 - funcs.atan2_ang(Y_NormalsB[l], X_NormalsB[l]);
          if (NormalsB[l] < 0) NormalsB[l] += 360;
        }
  
        if ((l == STAT_N_Max) || (l == STAT_N_Min)) {
          NormalsB[l] = FLOAT_undefined;
        }
      }
    }
    int _OPACITY = 191;
  
    for (int l = 0; l < 9; l++) {
      //for (int l = 0; l < 3; l++) {
      //for (int l = 3; l < 9; l++) {
  
      //for (int p = 0; p < 3; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      //for (int p = 0; p < 1; p++) { 
      //int l = this.ImpactLayer;
  
  
      if (l == STAT_N_Middle) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 191, 0);
        this.graphics.fill(0, 191, 0);
      } else if (l == STAT_N_MidHigh) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(191, 0, 0);
        this.graphics.fill(191, 0, 0);
      } else if (l == STAT_N_MidLow) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 191);
        this.graphics.fill(0, 0, 191);
      } else if (l == STAT_N_Max) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(255, 127, 127);
        this.graphics.fill(255, 127, 127);
      } else if (l == STAT_N_Min) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 127, 255);
        this.graphics.fill(127, 127, 255);
      } else if (l == STAT_N_M50) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 127, 0);
        this.graphics.fill(0, 127, 0);
      } else if (l == STAT_N_M75) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(127, 0, 0);
        this.graphics.fill(127, 0, 0);
      } else if (l == STAT_N_M25) {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 127);
        this.graphics.fill(0, 0, 127);
      } else {
        this.graphics.strokeWeight(this.T_scale * 1);
        this.graphics.stroke(0, 0, 0);
        this.graphics.fill(0, 0, 0);
      }
  
  
      
      if (l == this.ImpactLayer) {
       this.graphics.strokeWeight(this.T_scale * 4);
       this.graphics.stroke(127, 127, 127, _OPACITY);
       this.graphics.fill(127, 127, 127, _OPACITY);
      }
      
  
  
  
      float z_l = 60; //l;
      if (l == STAT_N_M75) z_l = 61;
      if (l == STAT_N_M50) z_l = 61;
      if (l == STAT_N_M25) z_l = 61;
      if (l == STAT_N_Ave) z_l = 62;
  
      if ((is_undefined_FLOAT(NormalsA[l]) == false) && (is_undefined_FLOAT(NormalsB[l]) == false)) {
        this.graphics.line((j + ((i + 0.5) / 24.0)) * sx_Plot, NormalsA[l] * sy_Plot, (j + ((i + 0.5 + TIME.interval) / 24.0)) * sx_Plot, NormalsB[l] * sy_Plot);
      } 
  
      if ((this.export_info_norm) && (this.displayNormals)) {
        if (is_undefined_FLOAT(NormalsA[l]) == false) FILE_outputNorms[(j - this.j_Start)].print(nfs(NormalsA[l] - this.V_offset, 5, 5) + "\t"); 
        else FILE_outputNorms[(j - this.j_Start)].print("[undefined]\t");
      }
    }
    if ((this.export_info_norm) && (this.displayNormals)) FILE_outputNorms[(j - this.j_Start)].println();
  }  


 
  void plotHourly (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
    
    int DATA_start = getStart_CurrentDataSource();
    int DATA_end = getEnd_CurrentDataSource();
    String DATA_reference = getReference_CurrentDataSource();
  
    this.graphics.pushMatrix();
    this.graphics.translate(x_Plot, y_Plot);
  
    this.color_data_raws = color(0, 0, 63, PAINT.getOpacity(this.O_scale));
  
    this.drawTimeGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
  
    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;
    
  
    if (this.PrintTtitle) {
  
      this.graphics.stroke(0); 
      this.graphics.fill(0);
      this.graphics.strokeWeight(this.T_scale * 0);
  
      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(RIGHT, CENTER); 
  
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.0 * sx_Plot / this.U_scale);
  
  
      this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
      this.graphics.textAlign(LEFT, CENTER); 
      this.graphics.text((CurrentLayer_descriptions[Language_Active]), 0, 1.0 * sx_Plot / this.U_scale);
    }

    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
  
    float[] valuesA;
    float[] valuesB; 
    valuesA = new float [count_k * this.joinDays];
    valuesB = new float [count_k * this.joinDays]; 
  
    float[] valuesSUM; 
    float[] valuesNUM;
    int _interval = 0;
    valuesSUM = new float [count_k * this.joinDays];
    valuesNUM = new float [count_k * this.joinDays];
    
    for (int k = 0; k < count_k; k++) {
      for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
        valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
        valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
        valuesSUM[(k * this.joinDays + j_ADD)] = 0; // Note: must be initialized to zero; not undefined.
        valuesNUM[(k * this.joinDays + j_ADD)] = 0;
      }  
    }
  
    float[] Ax_LINES = new float [0];
    float[] Ay_LINES = new float [0];
    float[] Az_LINES = new float [0];
    float[] Bx_LINES = new float [0];
    float[] By_LINES = new float [0];
    float[] Bz_LINES = new float [0];
  
    FILE_outputRaw = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputNorms = new PrintWriter [(this.j_End - this.j_Start)];
    FILE_outputProbs = new PrintWriter [(this.j_End - this.j_Start)];
  
    String Main_name = MAKE_MainName();
  
    for (int j = this.j_Start; j < this.j_End; j++) { 
  
      this.graphics.stroke(0);
      this.graphics.fill(0);
      this.graphics.textAlign(CENTER, CENTER); 
  
      if ((this.U_scale >= 0.75) || (((j - this.j_Start) % int(1.5 / this.U_scale)) == 0)) {
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
        this.graphics.text(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay), (j - ((0 - 12) / 24.0)) * sx_Plot, -1.2 * sx_Plot / this.U_scale);
        if (this.joinDays > 1) {
          this.graphics.text(("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s"), (0 + j - ((0 - 12) / 24.0)) * sx_Plot, -1 * sx_Plot);
        }
      }
  
      String _FilenamesAdd = "";
      if (this.joinDays > 1) {
        _FilenamesAdd = ("±" + int(this.joinDays / 2) + TIME.WORDS[2][Language_Active] + "s");
      }
      if ((this.export_info_node) && (this.displayRaws)) {
        FILE_outputRaw[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_node_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputRaw[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly data");
  
        FILE_outputRaw[(j - this.j_Start)].print("Hour\t");
        for (int k = 0; k < count_k; k++) {   
          FILE_outputRaw[(j - this.j_Start)].print(nf(k, 4) + "        \t");
        }
        FILE_outputRaw[(j - this.j_Start)].println("");
      }
      if ((this.export_info_norm) && (this.displayNormals)) {
        FILE_outputNorms[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_norm_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputNorms[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly normal");
        FILE_outputNorms[(j - this.j_Start)].print("Hour\t");
        for (int l = 0; l < 9; l++) {
          FILE_outputNorms[(j - this.j_Start)].print(STAT_N_Title[l] + "\t");
        }
        FILE_outputNorms[(j - this.j_Start)].println("");
      }
      if ((this.export_info_prob) && (this.displayProbs)) {
        FILE_outputProbs[(j - this.j_Start)] = createWriter(Folder_Export + "/" + Main_name + "/" + databaseString[CurrentDataSource] + "_prob_" + STATION.getCity() + "_from_" + String.valueOf(start_k + DATA_start) + "_to_" + String.valueOf(end_k + DATA_start) + "_" + CurrentLayer_descriptions[Language_EN] + "_" + skyScenario_FileTXT[this.skyScenario] + "_" + TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + ".txt");
        FILE_outputProbs[(j - this.j_Start)].println(TIME.getDayText(j * this.perDays + 286 + TIME.beginDay) + _FilenamesAdd + "\t" + skyScenario_FileTXT[this.skyScenario] + "\t" + CurrentLayer_descriptions[Language_EN] + "(" + CurrentLayer_unit + ")" + "\tfrom:" + String.valueOf(start_k + DATA_start) + "\tto:" + String.valueOf(end_k + DATA_start) + "\t" + STATION.getCity() + "\tHourly probabilities");
  
        FILE_outputProbs[(j - this.j_Start)].print("Hour:\t");
        FILE_outputProbs[(j - this.j_Start)].println("");
      }
  
      for (int i = 0; i < 24; i++) {
        if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.export_info_norm) && (this.displayNormals)) FILE_outputNorms[(j - this.j_Start)].print(nf(i, 2) + "\t");
        if ((this.export_info_prob) && (this.displayProbs)) FILE_outputProbs[(j - this.j_Start)].print(nf(i, 2) + "\t");
  
        for (int k = 0; k < count_k; k++) {   
          for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
  
            valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
            valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
            valuesSUM[(k * this.joinDays + j_ADD)] = 0;
            valuesNUM[(k * this.joinDays + j_ADD)] = 1;
  
            float[] COL = PAINT.getColorStyle(COLOR_STYLE_Current, (1.0 * k / (1 + DATA_end - DATA_start)));
            this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
            this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
  
  
            int now_k = k + start_k;
            int now_i = i;
            int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
  
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }
  
            int next_i = now_i + 1;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i == 24) {
              next_i = 0;
              next_j += 1;
              if (next_j == 365) {
                next_j = 0;
                next_k += 1;
              }
            }
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, CurrentLayer_id); 
          
            if (is_undefined_FLOAT(Pa)) {
              valuesA[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
  
              if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
            } else {
              int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
  
              if (memberCount == 1) {
                valuesA[(k * this.joinDays + j_ADD)] = Pa;
                valuesA[(k * this.joinDays + j_ADD)] += this.V_offset;
  
                valuesSUM[(k * this.joinDays + j_ADD)] += valuesA[(k * this.joinDays + j_ADD)];
                valuesNUM[(k * this.joinDays + j_ADD)] += 1;
  
                if ((this.export_info_node) && (this.displayRaws)) {
                  if (is_undefined_FLOAT(valuesA[(k * this.joinDays + j_ADD)]) == false) FILE_outputRaw[(j - this.j_Start)].print(nfs(valuesA[(k * this.joinDays + j_ADD)] - this.V_offset, 5, 5) + "\t"); 
                  else FILE_outputRaw[(j - this.j_Start)].print("[undefined]\t");
                }
  
                if (next_k < (1 + DATA_end - DATA_start)) {
  
                  Pb = getValue_CurrentDataSource(next_i, next_j, next_k, CurrentLayer_id);                 
                  
                  if (is_undefined_FLOAT(Pb)) {
                    valuesB[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
                  } else {
                    valuesB[(k * this.joinDays + j_ADD)] = Pb;
                    valuesB[(k * this.joinDays + j_ADD)] += this.V_offset;
  
                    if (this.displayRaws) {
                      if ((CurrentLayer_id == LAYER_winddir.id) && (abs(valuesB[(k * this.joinDays + j_ADD)] - valuesA[(k * this.joinDays + j_ADD)]) > 180)) {
                      } else {                        
                        Ax_LINES = append(Ax_LINES, (j + ((i + 0.5) / 24.0)) * sx_Plot);
                        Ay_LINES = append(Ay_LINES, valuesA[(k * this.joinDays + j_ADD)] * sy_Plot);
                        Az_LINES = append(Az_LINES, now_k * sz_Plot * this.W_scale);
                        Bx_LINES = append(Bx_LINES, (j + ((i + 1.5) / 24.0)) * sx_Plot);
                        By_LINES = append(By_LINES, valuesB[(k * this.joinDays + j_ADD)] * sy_Plot);
                        Bz_LINES = append(Bz_LINES, next_k * sz_Plot * this.W_scale);
                      }
                    }
                  }
                }
              } else {
                if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].print("not_the_case\t");
              }
            }
          }
        }
        
  
        if ((this.export_info_node) && (this.displayRaws)) FILE_outputRaw[(j - this.j_Start)].println();
  
        if (this.displaySorted) {  
          _interval += 1; 
          if ((_interval % this.sumInterval) == 0) {
            for (int k = 0; k < count_k; k++) {
              for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {
                valuesSUM[(k * this.joinDays + j_ADD)] += valuesA[(k * this.joinDays + j_ADD)];
                valuesNUM[(k * this.joinDays + j_ADD)] += 1;
    
                if (valuesNUM[(k * this.joinDays + j_ADD)] != 0) {
                  valuesSUM[(k * this.joinDays + j_ADD)] /= valuesNUM[(k * this.joinDays + j_ADD)];
                }
                else {
                  valuesSUM[(k * this.joinDays + j_ADD)] = FLOAT_undefined;
                }
              }
            }        
            if (this.displayProbs) {
              this.drawProbs(i, j, valuesSUM, valuesNUM, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
            }
          }      
    
        
          this.drawSorted(i, j, valuesA, valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
  
        if (this.displayNormals) {
          this.drawNormals(i, j, valuesA, valuesB, x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
        }
      }
      
      if ((this.export_info_node) && (this.displayRaws)) {
        FILE_outputRaw[(j - this.j_Start)].flush(); 
        FILE_outputRaw[(j - this.j_Start)].close();
      }
  
      if ((this.export_info_norm) && (this.displayNormals)) {
        FILE_outputNorms[(j - this.j_Start)].flush(); 
        FILE_outputNorms[(j - this.j_Start)].close();
      }
  
      if ((this.export_info_prob) && (this.displayProbs)) {
        FILE_outputProbs[(j - this.j_Start)].flush(); 
        FILE_outputProbs[(j - this.j_Start)].close();
      }
      
  
    }
  
    if (this.displayRaws) {
      this.drawData(Ax_LINES, Ay_LINES, Az_LINES, Bx_LINES, By_LINES, Bz_LINES);
    }    
  
    this.graphics.popMatrix();
  } 
  
  
  void plotSetup () {
  
    if (this.plotSetup == 14) {
  
      if (FrameVariation == 2) {
  
        for (int p = 0; p < 3; p++) { 
          this.ImpactLayer = 3 * int(pre_STUDY_ImpactLayer / 3) + p;
  
          SOLARCHVISION_PlotIMPACT(0, (175 - p * 350) * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
        }
        this.ImpactLayer = pre_STUDY_ImpactLayer;
  
        this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
      } else {
  
        if ((this.PlotImpacts == 8) || (this.PlotImpacts == 9)) {
  
          int keep_TIME_BeginDay = TIME.beginDay;
          float keep_STUDY_perDays = this.perDays;
          int keep_STUDY_j_End = this.j_End;
          float keep_STUDY_U_scale = this.U_scale;
  
          TIME.beginDay = 183; //0; // 183: to put the summer diagram on the left similar to the YC book
          this.perDays = 183;
          this.j_End = 2;
          this.U_scale = 18.0 / float(this.j_End - this.j_Start);
  
          SOLARCHVISION_PlotIMPACT(0, 0 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
          TIME.beginDay = keep_TIME_BeginDay;
          this.perDays = keep_STUDY_perDays;
          this.j_End = keep_STUDY_j_End;
          this.U_scale = keep_STUDY_U_scale;
        } else {
          SOLARCHVISION_PlotIMPACT(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
          this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
        }
      }
    }  
  
    // -----------------------------------------------
  
    if (this.plotSetup == -2) {
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
        pre_TIME_Date = TIME.date;
        int keep_TIME_BeginDay = TIME.beginDay;
        int delta = 4;
  
        this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        TIME.date -= delta;
        TIME.updateDate();
        TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
        update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
        TIME.beginDay = (TIME.beginDay + delta) % 365;
        this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        TIME.date -= delta;
        TIME.updateDate();
        TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
        update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
        TIME.beginDay = (TIME.beginDay + 2 * delta) % 365;
        this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        TIME.date -= delta;
        TIME.updateDate();
        TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
        update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
        TIME.beginDay = (TIME.beginDay + 3 * delta) % 365;
        this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        TIME.date = pre_TIME_Date;
        TIME.updateDate();
        TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
        update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
        TIME.beginDay = keep_TIME_BeginDay;
      }
    }
  
  
    if (this.plotSetup == -1) {
      pre_CurrentDataSource = CurrentDataSource;
  
      CurrentDataSource = dataID_ENSEMBLE_FORECAST; 
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false; 
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      CurrentDataSource = dataID_CLIMATE_CWEEDS;
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
  
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false; 
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      CurrentDataSource = pre_CurrentDataSource;
    }
  
  
    if (this.plotSetup == 0) {
  
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
    }
  
  
    if (this.plotSetup == 1) {
  
      DevelopLayer_id = CurrentLayer_id;
      changeCurrentLayerTo(LAYER_developed.id); 
  
      Develop_Option = DEV_OP_01;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      Develop_Option = DEV_OP_02;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      Develop_Option = DEV_OP_03;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      Develop_Option = DEV_OP_04;
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      Develop_Option = pre_Develop_Option;
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }  
  
  
    if (this.plotSetup == 2) {
      if (CurrentLayer_id != LAYER_developed.id) {
  
  
        this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        DevelopLayer_id = CurrentLayer_id;
        changeCurrentLayerTo(LAYER_developed.id);
  
        Develop_Option = DEV_OP_06; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        Develop_Option = DEV_OP_07; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        Develop_Option = DEV_OP_08; 
        SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
        this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
        changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
      }
    }  
  
  
    if (this.plotSetup == 3) {
  
      changeCurrentLayerTo(LAYER_windspd200hPa.id);
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_pressure.id);
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_heightp500hPa.id);
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_thicknesses_1000_500.id);
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }
  
  
    if (this.plotSetup == 4) {
  
      changeCurrentLayerTo(LAYER_windspd.id);
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_precipitation.id);
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_relhum.id);
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_drybulb.id);
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
    }  
  
  
    if (this.plotSetup == 5) {
  
      changeCurrentLayerTo(LAYER_dirnorrad.id);
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_difhorrad.id);
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_developed.id);
      Develop_Option = DEV_OP_01; 
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_developed.id);
      Develop_Option = DEV_OP_03; 
      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(pre_STUDY_CurrentLayer_id);
      Develop_Option = pre_Develop_Option;
    }
  
  
    if (this.plotSetup == 6) {
  
      this.skyScenario = 4;
      this.plotHourly(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.skyScenario = 3;
      this.plotHourly(0, -175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.skyScenario = 2;
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.skyScenario = 1;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.skyScenario = pre_STUDY_SkyScenario;
    }  
  
  
    if (this.plotSetup == 7) {
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true; 
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false;
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = -2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = -1;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts;
    }
  
  
    if (this.plotSetup == 8) {    
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false; 
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 3;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
  
    if (this.plotSetup == 9) {
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false; 
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts;
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
    if (this.plotSetup == 10) {
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false;
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 4;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  
    if (this.plotSetup == 11) {
  
      this.displaySorted = false;
      this.displayNormals = false;
      this.displayRaws = true;
      this.displayProbs = true;
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.displaySorted = true;
      this.displayNormals = true;
      this.displayRaws = false;
      this.displayProbs = false;
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 5;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }  
  
    if (this.plotSetup == 12) {
  
      if (SOLARCHVISION_automated != 0) {
        this.displaySorted = false;
        this.displayNormals = true;
        this.displayRaws = false;
        this.displayProbs = true;
      }
  
      changeCurrentLayerTo(LAYER_windspd.id); 
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      //changeCurrentLayerTo(LAYER_precipitation.id); 
      //DevelopLayer_id = CurrentLayer_id);
      //changeCurrentLayerTo(LAYER_developed.id); 
      //Develop_Option = DEV_OP_09;
      //SOLARCHVISION_postProcess_developDATA(CurrentDataSource); 
      //this.plotHourly(0, 325 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_drybulb.id); 
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 1;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = -2;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
    }
  
    if (this.plotSetup == 13) {
  
      if (SOLARCHVISION_automated != 0) {
        this.displaySorted = true;
        this.displayNormals = true;
        this.displayRaws = false;
        this.displayProbs = false;
      }
  
      changeCurrentLayerTo(LAYER_dirnorrad.id); 
      this.plotHourly(0, 175 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S); 
  
      //changeCurrentLayerTo(LAYER_glohorrad.id; //LAYER_difhorrad.id; // <<<<<<<<<<<<<< 
      //this.plotHourly(0, 325 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      changeCurrentLayerTo(LAYER_cloudcover.id);
      this.plotHourly(0, 525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 0;
      SOLARCHVISION_PlotIMPACT(0, -525 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
      this.PlotImpacts = 2; //4;
      SOLARCHVISION_PlotIMPACT(0, -200 * this.view_S, 0, (100.0 * this.U_scale * this.view_S), (-1.0 * this.V_scale * this.view_S), 1.0 * this.view_S);
  
  
      this.PlotImpacts = pre_STUDY_PlotImpacts; 
      this.ImpactLayer = pre_STUDY_ImpactLayer;
    }
  }  
 

  void drawView () {
  
    cursor(WAIT);
  
  
    if (this.update) {
  
      if (this.record_PDF) this.ImageScale = 1;
      else if (this.record_IMG) this.ImageScale = 2;
      else this.ImageScale = 1;
  
      //////////////////////////////////
      this.dX *= this.ImageScale;
      this.dY *= this.ImageScale;  
      this.T_scale *= this.ImageScale;
      //////////////////////////////////  
  
      if (this.record_PDF) {
        println("PDF:begin");
        this.graphics = createGraphics(this.dX, this.dY, PDF, MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".pdf");
        beginRecord(this.graphics);
      } else if (this.ImageScale != 1) {
        println("IMG:high-res");
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.graphics.beginDraw();
      } else {
        this.graphics.beginDraw();
      }  
  
      DrawnFrame += 1;
      println("frame:", DrawnFrame);    
  
      if (DevelopData_update) {
        if (CurrentLayer_id == LAYER_developed.id) {
          SOLARCHVISION_postProcess_developDATA(CurrentDataSource);
    
        }
      }     
  
  
      this.view_S = (this.dX / 2100.0);
      this.U_scale = 18.0 / float(this.j_End - this.j_Start);
  
  
      this.position_X = -0.333 * this.dX;      
  
      this.position_Y = 1.0 * this.dY;
  
  
      this.graphics.background(255);
  
      this.graphics.blendMode(BLEND);
  
      this.graphics.strokeJoin(ROUND); 
  
      this.graphics.textFont(SOLARCHVISION_font);
  
      this.graphics.strokeWeight(0);
  
      //this.graphics.translate(this.position_X * -0.25, this.position_Y * 0.5); 
      this.graphics.translate(this.position_X * -0.425, this.position_Y * 0.5);
  
      this.plotSetup();
  
      //this.graphics.translate(this.position_X * 0.25, this.position_Y * 0.5);
      this.graphics.translate(this.position_X * 0.425, this.position_Y * 0.5);
  
      this.graphics.strokeWeight(this.T_scale * 1);
  
      this.graphics.stroke(63);
      this.graphics.fill(63);
      this.graphics.textAlign(CENTER, CENTER);
  
      String _text = "SOLARCHVISION post-processing";
  
      if (CurrentDataSource == dataID_CLIMATE_TMYEPW) _text += " based on typical-year data for Building Energy Simulation";  //"(TMYEPW - U.S. Department of Energy)";
      if (CurrentDataSource == dataID_CLIMATE_CWEEDS) _text += " based on long-term Canadian Weather Energy and Engineering Datasets (CWEEDS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_CLIMATE_CLMREC) _text += " based on Environment and Climate Change Canada's Climate website";
      if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) _text += " based on the North American Ensemble Forecast System (NAEFS - Environment and Climate Change Canada)";
      if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) _text += " based on real-time Surface Weather Observation (SWOB - Environment and Climate Change Canada)";
  
      //_text += ", www.solarchvision.com";
  
      this.graphics.textSize(this.dX * 0.01);
      ///this.graphics.text(_text, this.dX * 0.55, this.dY * -0.1666 / this.view_R, 0);
  
      if (this.record_PDF) {
        endRecord();
  
        String myFile = MAKE_Filename(createStamp(0, CLASS_STAMP)) + ".pdf";
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      } else {
        this.graphics.endDraw();
  
        if ((this.record_IMG) || (this.record_AUTO)) {
          String myFile = MAKE_Filename(createStamp(1, CLASS_STAMP)) + ".jpg";
          this.graphics.save(myFile);
          SOLARCHVISION_explore_output(myFile);
          println("File created:" + myFile);
        }
  
        imageMode(CORNER);
        image(this.graphics, this.cX, this.cY, this.dX / this.ImageScale, this.dY / this.ImageScale);
      }
  
      //////////////////////////////////
      this.dX /= this.ImageScale;
      this.dY /= this.ImageScale;
      this.T_scale /= this.ImageScale;
      //////////////////////////////////
  
      if ((this.ImageScale != 1) || (this.record_PDF)) {
        this.graphics = createGraphics(this.dX, this.dY, P2D);
        this.update = false; //1;
      } else {
        this.update = false;
      }
  
  
      if ((this.record_IMG) || (this.record_AUTO == false)) this.record_IMG = false;
    }
  
    this.export_info_node = false;
    this.export_info_norm = false;
    this.export_info_prob = false;
  
    cursor(ARROW);
  }
  
  
  void refreshDateTabs () {
    if ((CurrentDataSource == dataID_CLIMATE_CWEEDS) || (CurrentDataSource == dataID_CLIMATE_CLMREC) || (CurrentDataSource == dataID_CLIMATE_TMYEPW)) { 
      if (this.perDays == 1) { 
        this.perDays = int(365 / float(this.j_End - this.j_Start));
      } else {
        this.perDays = 1;
      }
    } 
    if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
      this.perDays = 1;
    }           
    if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
      if (this.perDays == 1) { 
        this.perDays = int(ENSEMBLE_OBSERVED_maxDays / float(this.j_End - this.j_Start));
      } else {
        this.perDays = 1;
      }
    }
  }    
  
  
  
  void SOLARCHVISION_PlotIMPACT (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot) {
  
    this.graphics.pushMatrix();
    this.graphics.translate(x_Plot, y_Plot);
  
    float keep_STUDY_perDays = this.perDays;
    int keep_STUDY_joinDays = this.joinDays;
  
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      this.perDays = 1;
      this.joinDays = 1;
    }
  
    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;
  
  
    if ((this.PlotImpacts == -2) || (this.PlotImpacts == -1)) {
  
      allWindRoses.resize_Image_array(); 
  
      int RES = allWindRoses.RES;
  
      allWindRoses.renderedRES = RES;
  
      if (this.PlotImpacts == -2) Impact_TYPE = Impact_ACTIVE; 
      if (this.PlotImpacts == -1) Impact_TYPE = Impact_PASSIVE;
  
      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
  
      float[] values_W_dir;
      float[] values_W_spd; 
      float[] values_W_tmp; 
      values_W_dir = new float [count_k];
      values_W_spd = new float [count_k]; 
      values_W_tmp = new float [count_k]; 
  
      for (int k = 0; k < count_k; k++) { 
        values_W_dir[k] = FLOAT_undefined;
        values_W_spd[k] = FLOAT_undefined;
        values_W_tmp[k] = FLOAT_undefined;
      }
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        //PAL_type = this.ACTIVE_pallet_CLR; PAL_direction = this.ACTIVE_pallet_DIR;
        PAL_type = 12; 
        PAL_direction = -1;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 1.0 / 30.0;
  
      for (int j = this.j_Start; j < this.j_End; j++) { 
  
        PGraphics WIND_graphics = createGraphics(RES, RES); 
        WIND_graphics.beginDraw();
        //WIND_graphics.background(255);
        WIND_graphics.translate(0.5 * RES, 0.5 * RES);
  
        for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {    
          for (int i = 0; i < 24; i++) {
            if (this.isInHourlyRange(i)) {
  
              for (int k = 0; k < count_k; k++) {
  
                values_W_dir[k] = FLOAT_undefined;
                values_W_spd[k] = FLOAT_undefined;
                values_W_tmp[k] = FLOAT_undefined;
  
                int _plot = 1;
  
                if (_plot == 1) {
  
                  int now_k = k + start_k;
                  int now_i = i;
                  int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }
  
                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);
  
                  if (is_undefined_FLOAT(Pa) || is_undefined_FLOAT(Pb) || is_undefined_FLOAT(Pc)) {
                    values_W_dir[k] = FLOAT_undefined;
                    values_W_spd[k] = FLOAT_undefined;
                    values_W_tmp[k] = FLOAT_undefined;
                  } else {
                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
  
                    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;
  
                    if (memberCount == 1) {
  
                      values_W_dir[k] = Pa;
                      values_W_spd[k] = Pb;
                      values_W_tmp[k] = Pc;
  
                      float T = values_W_tmp[k];
                      float teta = values_W_dir[k];
                      float D_teta = 15; 
                      float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (values_W_spd[k] / 50.0);
  
                      float R_in = 0; //0.75 * R; 
                      float x1 = R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y1 = R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x2 = R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y2 = R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)); 
  
                      float x4 = R * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y4 = R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x3 = R * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y3 = R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));
  
                      float _u = 0;
  
                      if (Impact_TYPE == Impact_ACTIVE) {
  
                        float _s = (this.O_scale / 100) * 255 / (0.333 * count_k); 
  
                        if (this.skyScenario > 1) _s *= 3; // to improve visibility of those cases.
  
                        _s /= float(this.joinDays);
  
                        if (_s < 10) _s = 10;
  
                        WIND_graphics.stroke(0, _s);
                        WIND_graphics.fill(0, _s); 
  
                        WIND_graphics.strokeWeight(this.T_scale * 0);
                      }
                      if (Impact_TYPE == Impact_PASSIVE) {
                        _u = 0.5 + 0.5 * (PAL_multiplier * T);
  
                        if (PAL_direction == -1) _u = 1 - _u;
                        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                        if (PAL_direction == 2) _u =  0.5 * _u;
  
                        float[] COL = PAINT.getColorStyle(PAL_type, _u);
  
                        WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
  
                        WIND_graphics.strokeWeight(this.T_scale * 2);
                        WIND_graphics.noFill();
                      }
  
                      WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    }
                  }
                }
              }
            }
          }
        }
        WIND_graphics.endDraw();
        allWindRoses.Image[j + 1] = WIND_graphics;
      }
  
  
  
  
      PGraphics total_WIND_graphics = createGraphics(RES, RES); 
      total_WIND_graphics.beginDraw();
      //total_WIND_graphics.background(255);
      total_WIND_graphics.translate(0.5 * RES, 0.5 * RES);
  
      for (int j = this.j_Start; j < this.j_End; j++) { 
        for (int j_ADD = 0; j_ADD < this.joinDays; j_ADD++) {    
          for (int i = 0; i < 24; i++) {
            if (this.isInHourlyRange(i)) {
  
              for (int k = 0; k < count_k; k++) {
  
                values_W_dir[k] = FLOAT_undefined;
                values_W_spd[k] = FLOAT_undefined;
                values_W_tmp[k] = FLOAT_undefined;
  
                int _plot = 1;
  
                if (_plot == 1) {
  
                  int now_k = k + start_k;
                  int now_i = i;
                  int now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }
  
                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_winddir.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);
  
                  if (is_undefined_FLOAT(Pa) || is_undefined_FLOAT(Pb) || is_undefined_FLOAT(Pc)) {
                    values_W_dir[k] = FLOAT_undefined;
                    values_W_spd[k] = FLOAT_undefined;
                    values_W_tmp[k] = FLOAT_undefined;
                  } else {
                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
                    
                    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) && (ENSEMBLE_FORECAST_flags[now_i][now_j][LAYER_winddir.id][now_k] == false)) memberCount = 0;
  
                    if (memberCount == 1) {
  
                      values_W_dir[k] = Pa;
                      values_W_spd[k] = Pb;
                      values_W_tmp[k] = Pc;
  
                      float T = values_W_tmp[k];
                      float teta = values_W_dir[k];
                      float D_teta = 15; 
                      float R = (0.5 * RES) * (LAYER_windspd.V_scale / 2.0) * (values_W_spd[k] / 50.0);
  
                      float R_in = 0; //0.75 * R; 
                      float x1 = R_in * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y1 = R_in * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x2 = R_in * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y2 = R_in * -funcs.sin_ang(90 - (teta + 0.5 * D_teta)); 
  
                      float x4 = R * funcs.cos_ang(90 - (teta - 0.5 * D_teta));
                      float y4 = R * -funcs.sin_ang(90 - (teta - 0.5 * D_teta));
                      float x3 = R * funcs.cos_ang(90 - (teta + 0.5 * D_teta));
                      float y3 = R * -funcs.sin_ang(90 - (teta + 0.5 * D_teta));
  
                      float _u = 0;
  
                      if (Impact_TYPE == Impact_ACTIVE) {
  
                        float _s = (this.O_scale / 100) * 255 / (0.333 * count_k) / (this.j_End - this.j_Start);
  
                        if (this.skyScenario > 1) _s *= 3; // to improve visibility of those cases.
  
                        _s /= float(this.joinDays);
  
                        if (_s < 10) _s = 10;
  
                        total_WIND_graphics.stroke(0, _s);
                        total_WIND_graphics.fill(0, _s); 
  
                        total_WIND_graphics.strokeWeight(this.T_scale * 0);
                      }
                      if (Impact_TYPE == Impact_PASSIVE) {
                        _u = 0.5 + 0.5 * (PAL_multiplier * T);
  
                        if (PAL_direction == -1) _u = 1 - _u;
                        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                        if (PAL_direction == 2) _u =  0.5 * _u;
  
                        float[] COL = PAINT.getColorStyle(PAL_type, _u);
                        total_WIND_graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
  
                        total_WIND_graphics.strokeWeight(this.T_scale * 2);
                        total_WIND_graphics.noFill();
                      }
  
                      total_WIND_graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                    }
                  }
                }
              }
            }
          }
        }
      }
      total_WIND_graphics.endDraw();
      allWindRoses.Image[0] = total_WIND_graphics;          
  
      for (int j = this.j_Start - 1; j < this.j_End; j++) {
        if ((j != -1) || (this.impact_summary)) {
          this.graphics.strokeWeight(this.T_scale * 0);
          this.graphics.stroke(223);
          this.graphics.fill(223); 
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
          this.graphics.strokeWeight(this.T_scale * 2);
          this.graphics.stroke(255);
          this.graphics.noFill(); 
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
          this.graphics.imageMode(CENTER); 
          this.graphics.image(allWindRoses.Image[j + 1], (j + 100 * this.rect_scale) * sx_Plot, 0, int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));
        }
      }   
  
      this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  
      if (this.impact_summary) {
        int j = -1; // << to put the summary graph before the daily graphs
  
        int keep_STUDY_j_Start = this.j_Start;
        int keep_STUDY_j_End = this.j_End;
        this.j_Start = j;
        this.j_End = j + 1;
        this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
        this.j_Start = keep_STUDY_j_Start;
        this.j_End = keep_STUDY_j_End;
  
        this.graphics.strokeWeight(this.T_scale * 2);
        this.graphics.stroke(0);
        this.graphics.noFill(); 
        this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
      }
  
      if (Impact_TYPE != Impact_ACTIVE) { 
  
        float pal_length = 400;
        float pal_ox = 700;
        float pal_oy = 125;
        for (int q = 0; q < 11; q++) {
          float _u = 0;
  
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.1 * q;
  
          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;
  
          float[] COL = PAINT.getColorStyle(PAL_type, _u);
          this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
          this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);         
  
          this.graphics.strokeWeight(0);
          this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S); 
  
          if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
            this.graphics.stroke(127);
            this.graphics.fill(127);
            this.graphics.strokeWeight(0);
          } else {
            this.graphics.stroke(255);
            this.graphics.fill(255);
            this.graphics.strokeWeight(2);
          }  
  
          this.graphics.textSize(15.0 * this.view_S);
          this.graphics.textAlign(CENTER, CENTER);
  
          if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(0.2 * (q - 5) / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        }
      }         
  
  
      if (this.PrintTtitle) {
  
        this.graphics.stroke(0); 
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP); 
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(("Wind direction and speed"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(("Wind direction and speed with air temperature"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
      }
  
      if (allWindRoses.displayImage) WIN3D.update = true;
    } 
  
  
  
  
  
    if ((this.PlotImpacts == 0) || (this.PlotImpacts == 1)) {
  
      if (this.Impacts_update) {
  
        allSolarImpacts.calculate_Impact_CurrentPreBaked();
  
        int RES1 = allSolarImpacts.RES1;
        int RES2 = allSolarImpacts.RES2;
  
        if (this.PlotImpacts == 0) Impact_TYPE = Impact_ACTIVE; 
        if (this.PlotImpacts == 1) Impact_TYPE = Impact_PASSIVE;
  
        float Pa = FLOAT_undefined;
        float Pb = FLOAT_undefined;
        float Pc = FLOAT_undefined;
        float Pd = FLOAT_undefined;
  
        float values_R_dir;
        float values_R_dif;
  
        float values_E_dir;
        float values_E_dif;
  
        int now_k = 0;
        int now_i = 0;
        int now_j = 0;
  
        int PAL_type = 0; 
        int PAL_direction = 1;
        float PAL_multiplier = 1; 
  
        if (Impact_TYPE == Impact_ACTIVE) {
          PAL_type = allFaces.ACTIVE_pallet_CLR; 
          PAL_direction = allFaces.ACTIVE_pallet_DIR;  
          PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT;
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          PAL_type = allFaces.PASSIVE_pallet_CLR; 
          PAL_direction = allFaces.PASSIVE_pallet_DIR;
          PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
        }        
  
        for (int p = 0; p < 1; p++) { 
          int l = this.ImpactLayer;
  
          for (int j = this.j_Start; j < this.j_End; j++) {
  
            now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;
  
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }
  
  
            this.graphics.strokeWeight(this.T_scale * 0);
            this.graphics.stroke(223);
            this.graphics.fill(223); 
            this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (1 * p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
            this.graphics.strokeWeight(this.T_scale * 2);
            this.graphics.stroke(255);
            this.graphics.noFill(); 
            this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (1 * p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
            this.graphics.imageMode(CENTER); 
            this.graphics.image(allSolarImpacts.Image[Impact_TYPE][j + 1], (j + 100 * this.rect_scale) * sx_Plot, - (1 * p * sx_Plot / this.U_scale), int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));
  
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(CENTER, CENTER); 
            this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
            String scenario_text = "";
            //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
            //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
            //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
            this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / this.U_scale);
          }
          
          ////////////////////////////
          this.impact_summary = true; 
          ////////////////////////////
          
          if (this.impact_summary) { 
            int j = -1; // << to put the summary graph before the daily graphs
  
            this.graphics.strokeWeight(this.T_scale * 0);
            this.graphics.stroke(223);
            this.graphics.fill(223); 
            //this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (1 * p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
            this.graphics.strokeWeight(this.T_scale * 2);
            this.graphics.stroke(0);
            this.graphics.noFill(); 
            //this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (1 * p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
            this.graphics.imageMode(CENTER); 
            //this.graphics.image(allSolarImpacts.Image[Impact_TYPE][j + 1], (j + 100 * this.rect_scale) * sx_Plot, - (1 * p * sx_Plot / this.U_scale), int((180 * this.rect_scale) * sx_Plot), int((180 * this.rect_scale) * sx_Plot));
  
            this.graphics.stroke(0);
            this.graphics.fill(0);
            this.graphics.textAlign(CENTER, CENTER); 
            this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          }
  
          String scenario_text = "";
          //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
          //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
          //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / this.U_scale);
  
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(RIGHT, CENTER); 
          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.strokeWeight(0); 
  
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(RIGHT, CENTER); 
          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.strokeWeight(0); 
  
          if (Impact_TYPE == Impact_ACTIVE) {  
            this.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / this.U_scale));
          }
          if (Impact_TYPE == Impact_PASSIVE) {  
            this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / this.U_scale));
          }            
          //?? French
        }
  
        float pal_length = 400;
        float pal_ox = 700;
        float pal_oy = 125;        
        for (int q = 0; q < 11; q++) {
          float _u = 0;
  
          if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
          if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
  
          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;
  
          float[] COL = PAINT.getColorStyle(PAL_type, _u);
          this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
          this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);         
  
          this.graphics.strokeWeight(0);
          this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S); 
  
          if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
            this.graphics.stroke(127);
            this.graphics.fill(127);
            this.graphics.strokeWeight(0);
          } else {
            this.graphics.stroke(255);
            this.graphics.fill(255);
            this.graphics.strokeWeight(2);
          }  
  
          this.graphics.textSize(15.0 * this.view_S);
          this.graphics.textAlign(CENTER, CENTER);
          if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
          if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        }
  
        if (this.PrintTtitle) {
  
          this.graphics.stroke(0); 
          this.graphics.fill(0);
          this.graphics.strokeWeight(this.T_scale * 0);
  
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(RIGHT, TOP); 
          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
  
  
          String Model_Description = "";
  
  
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
          this.graphics.textAlign(LEFT, TOP); 
          if (Impact_TYPE == Impact_ACTIVE) {  
            this.graphics.text((Model_Description + "Analysis of Active Potentials (kW/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
            //?? French
          }
          if (Impact_TYPE == Impact_PASSIVE) {  
            this.graphics.text((Model_Description + "Analysis of Passive Potentials (%kW°C/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
            //?? French
          }
        }
      }
  
      if (allSolarImpacts.displayImage) WIN3D.update = true;
    }
  
  
  
  
  
    if ((this.PlotImpacts == 2) || (this.PlotImpacts == 3)) {
  
      if (GlobalSolar_rebuild_array) {
        GlobalSolar_resize_array();
      }
  
      if (this.PlotImpacts == 2) Impact_TYPE = Impact_ACTIVE; 
      if (this.PlotImpacts == 3) Impact_TYPE = Impact_PASSIVE;
  
      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;
  
      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;
  
      int now_k = 0;
      int now_i = 0;
      int now_j = 0;
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT; 
  
      //for (int p = 0; p < 3; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      for (int p = 0; p < 1; p++) { 
        int l = this.ImpactLayer;
  
      //for (int p = 0; p < 1; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + 1; //this.ImpactLayer;    
  
        float[][] TOTALvaluesSUM_RAD = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
        float[][] TOTALvaluesSUM_EFF_P = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
        float[][] TOTALvaluesSUM_EFF_N = new float [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
        int[][] TOTALvaluesNUM = new int [1 + int(90 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  
        for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) { 
          for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
            TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
            TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
            TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
            TOTALvaluesNUM[a][b] = 0;
          }
        }
  
        for (int j = this.j_Start; j < this.j_End; j++) {
  
          now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / this.joinDays);
              int j_ADD = nk % this.joinDays; 
  
              for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) { 
                float Alpha = a * Sky3D.stp_slp;
                for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
                  float Beta = b * Sky3D.stp_dir;
  
                  float valuesSUM_RAD = 0;
                  float valuesSUM_EFF_P = 0;
                  float valuesSUM_EFF_N = 0;
                  int valuesNUM = 0; 
  
  
                  for (int i = 0; i < 24; i++) {
                    if (this.isInHourlyRange(i)) {              
                      float HOUR_ANGLE = i; 
                      float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                      if (SunR[3] > 0) {
  
                        now_k = k + start_k;
                        now_i = i;
                        now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                        if (now_j >= 365) {
                          now_j = now_j % 365;
                        }
                        if (now_j < 0) {
                          now_j = (now_j + 365) % 365;
                        }
  
                        Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                        Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                        Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                        Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
  
                        if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                          values_R_dir = FLOAT_undefined;
                          values_R_dif = FLOAT_undefined;
                          values_E_dir = FLOAT_undefined;
                          values_E_dif = FLOAT_undefined;
                        } else {
  
                          int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
                          
                          if (memberCount == 1) {
                            values_R_dir = 0.001 * Pa;
                            values_R_dif = 0.001 * Pb;
                            values_E_dir = 0.001 * Pc;
                            values_E_dif = 0.001 * Pd;
  
                            if (is_undefined_FLOAT(valuesSUM_RAD)) {
                              valuesSUM_RAD = 0;
                              valuesSUM_EFF_P = 0;
                              valuesSUM_EFF_N = 0;
                              valuesNUM = 0;
                            } else {
  
                              if (values_E_dir < 0) {
                                valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                              } else {
                                valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                              }
  
                              valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_R_dir, values_R_dif, Alpha, Beta, GlobalAlbedo); 
  
                              valuesNUM += 1;
                            }
                          }
                        }
                      }
                    }
                  }
  
  
                  if (valuesNUM != 0) {
                    //float valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);  
                    //float valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                    float valuesMUL = funcs.roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);
  
                    valuesSUM_RAD *= valuesMUL;
                    valuesSUM_EFF_P *= valuesMUL;
                    valuesSUM_EFF_N *= valuesMUL;
  
                    if (TOTALvaluesNUM[a][b] == 0) {
                      TOTALvaluesSUM_RAD[a][b] = 0;
                      TOTALvaluesSUM_EFF_P[a][b] = 0;
                      TOTALvaluesSUM_EFF_N[a][b] = 0;
                    }
  
                    TOTALvaluesSUM_RAD[a][b] += valuesSUM_RAD;
                    TOTALvaluesSUM_EFF_P[a][b] += valuesSUM_EFF_P;
                    TOTALvaluesSUM_EFF_N[a][b] += valuesSUM_EFF_N;
                    TOTALvaluesNUM[a][b] += 1;
                  } else {
                    valuesSUM_RAD = FLOAT_undefined;
                    valuesSUM_EFF_P = FLOAT_undefined;
                    valuesSUM_EFF_N = FLOAT_undefined;
                  }
  
  
                  float AVERAGE, PERCENTAGE, COMPARISON;
  
                  AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
                  if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N)); 
                  else PERCENTAGE = 0.0;
                  COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
  
                  float valuesSUM = FLOAT_undefined;
                  if (Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                  if (Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON; 
  
                  //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> valuesSUM_RAD:", valuesSUM_RAD, "COMPARISON:", COMPARISON);  
  
                  if (is_undefined_FLOAT(valuesSUM) == false) {
  
                    float _u = 0;
  
                    if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
  
                    if (PAL_direction == -1) _u = 1 - _u;
                    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_direction == 2) _u =  0.5 * _u;
  
                    //float[] COL = PAINT.getColorStyle(PAL_type, _u);
                    float[] COL = PAINT.getColorStyle(PAL_type, funcs.roundTo(_u, 0.1));
                    this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
  
  
                    this.graphics.strokeWeight(0);
  
                    float x1 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                    float y1 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                    float x2 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                    float y2 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot; 
  
                    float x3 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                    float y3 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot; 
                    float x4 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                    float y4 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot; 
  
                    this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
                  }
                }
              }
  
              this.graphics.stroke(0);
              this.graphics.fill(0);
              this.graphics.textAlign(CENTER, CENTER); 
              this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
              String scenario_text = "";
              //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
              //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
              //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
              this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / this.U_scale);
            }
          }
        }
  
  
  
        if (this.impact_summary) { 
  
          int j = -1; // << to put the summary graph before the daily graphs
  
          for (int a = 0; a <= int (90 / Sky3D.stp_slp); a++) { 
            float Alpha = a * Sky3D.stp_slp;
            for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
              float Beta = b * Sky3D.stp_dir;
  
              if (TOTALvaluesNUM[a][b] != 0) {
                TOTALvaluesSUM_RAD[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
                TOTALvaluesSUM_EFF_P[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
                TOTALvaluesSUM_EFF_N[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
              } else {
                TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
                TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
                TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
              }
  
  
              float AVERAGE, PERCENTAGE, COMPARISON;
  
              AVERAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]);
              if ((TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]) / (1.0 * (TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b])); 
              else PERCENTAGE = 0.0;
              COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
  
              float valuesSUM = FLOAT_undefined;
              if (Impact_TYPE == Impact_ACTIVE) valuesSUM = TOTALvaluesSUM_RAD[a][b];
              if (Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON; 
  
              //if ((Alpha == 90.0) && (Beta == 0.0)) println("SPHERICAL >> (TOTAL) valuesSUM_RAD:", TOTALvaluesSUM_RAD[a][b], "COMPARISON:", COMPARISON);  
  
              if (is_undefined_FLOAT(valuesSUM) == false) {
  
                float _u = 0;
  
                if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
                if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
  
                if (PAL_direction == -1) _u = 1 - _u;
                if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                if (PAL_direction == 2) _u =  0.5 * _u;
  
                //float[] COL = PAINT.getColorStyle(PAL_type, _u);
                float[] COL = PAINT.getColorStyle(PAL_type, funcs.roundTo(_u, 0.1));
                this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);               
  
                this.graphics.strokeWeight(0);
  
                float x1 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                float y1 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                float x2 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot;
                float y2 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 - 0.5 * Sky3D.stp_dir))) * sx_Plot; 
  
                float x3 = (j + this.rect_offset_x + (90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                float y3 = (                         -(90 - Alpha + 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot; 
                float x4 = (j + this.rect_offset_x + (90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.cos_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot;
                float y4 = (                         -(90 - Alpha - 0.5 * Sky3D.stp_slp) * this.rect_scale * (funcs.sin_ang(Beta - 90 + 0.5 * Sky3D.stp_dir))) * sx_Plot; 
  
                this.graphics.quad(x1, y1, x2, y2, x3, y3, x4, y4);
              }
            }
          }
  
          this.graphics.strokeWeight(this.T_scale * 2);
          this.graphics.stroke(0);
          this.graphics.noFill(); 
          this.graphics.rect((j + this.rect_offset_x - 100 * this.rect_scale) * sx_Plot, (-100 * this.rect_scale) * sx_Plot - (1 * p * sx_Plot / this.U_scale), (200 * this.rect_scale) * sx_Plot, (200 * this.rect_scale) * sx_Plot);
  
  
          this.graphics.stroke(0);
          this.graphics.fill(0);
          this.graphics.textAlign(CENTER, CENTER); 
          this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
          String scenario_text = "";
          //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
          //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
          //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
          this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95 * sx_Plot / this.U_scale);
  
          int keep_STUDY_j_Start = this.j_Start;
          int keep_STUDY_j_End = this.j_End;
          this.j_Start = j;
          this.j_End = j + 1;
          this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
          this.j_Start = keep_STUDY_j_Start;
          this.j_End = keep_STUDY_j_End;
        }
  
  
        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / this.U_scale);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(0); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / this.U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / this.U_scale));
        }            
        //?? French
      }
  
      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 125;      
      for (int q = 0; q < 11; q++) {
        float _u = 0;
  
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
  
        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
  
        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       
  
        this.graphics.strokeWeight(0);
        this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S); 
  
        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }   
  
        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);
        if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf((funcs.roundTo(0.1 * q / PAL_multiplier, 0.1)), 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
      }
  
  
      if (this.PrintTtitle) {
  
        this.graphics.stroke(0); 
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP); 
        
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(("Solar radiation on hemisphere (kW/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(("Solar effects on hemisphere (%kW°C/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
      }
  
      this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
    } 
  
  
  
    if ((this.PlotImpacts == 4) || (this.PlotImpacts == 5)) {
      if (this.PlotImpacts == 4) Impact_TYPE = Impact_ACTIVE; 
      if (this.PlotImpacts == 5) Impact_TYPE = Impact_PASSIVE;
  
      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;
  
      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;
  
      int now_k = 0;
      int now_i = 0;
      int now_j = 0;
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT;
  
      this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  
      //for (int p = 0; p < 3; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      for (int p = 0; p < 1; p++) { 
        int l = this.ImpactLayer;
  
        //for (int p = 0; p < 1; p++) { 
        //int l = 3 * int(this.ImpactLayer / 3) + 1; //this.ImpactLayer;    
  
        for (int j = this.j_Start; j < this.j_End; j++) {
  
          now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / this.joinDays);
              int j_ADD = nk % this.joinDays; 
  
              float valuesSUM_RAD = 0;
              float valuesSUM_EFF = 0;
              int valuesNUM = 0; 
  
              for (int i = 0; i < 24; i++) {
                if (this.isInHourlyRange(i)) {
                  if ((i+0.5 >= sunrise) && (i+0.5 <= sunset)) {
  
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                    float Alpha = 90 - funcs.acos_ang(SunR[3]);
                    float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);
  
                    now_k = k + start_k;
                    now_i = i;
                    now_j = int(j * this.perDays + (j_ADD - int(funcs.roundTo(0.5 * this.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                    if (now_j >= 365) {
                      now_j = now_j % 365;
                    }
                    if (now_j < 0) {
                      now_j = (now_j + 365) % 365;
                    }
  
                    Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                    Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                    Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                    Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
  
                    if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                      values_R_dir = FLOAT_undefined;
                      values_R_dif = FLOAT_undefined;
                      values_E_dir = FLOAT_undefined;
                      values_E_dif = FLOAT_undefined;
                    } else {
  
                      int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, this.filter, this.skyScenario, now_i, now_j, now_k);
                      
                      if (memberCount == 1) {
                        values_R_dir = 0.001 * Pa;
                        values_R_dif = 0.001 * Pb;
                        values_E_dir = 0.001 * Pc;
                        values_E_dif = 0.001 * Pd;
  
                        if (is_undefined_FLOAT(valuesSUM_RAD)) {
                          valuesSUM_RAD = 0;
                          valuesSUM_EFF = 0;
                          valuesNUM = 0;
                        } else {
                          valuesSUM_RAD = (values_R_dir); // direct beam radiation
                          valuesSUM_EFF = (values_E_dir); // direct beam effect
                          valuesNUM = 1;
                        }
                      }
                    }
  
                    float valuesSUM = FLOAT_undefined;
                    if (Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                    if (Impact_TYPE == Impact_PASSIVE) valuesSUM = valuesSUM_EFF; 
  
                    if (is_undefined_FLOAT(valuesSUM) == false) {
  
                      float _u = 0;
  
                      if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * valuesSUM);
                      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * valuesSUM);
  
                      if (PAL_direction == -1) _u = 1 - _u;
                      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_direction == 2) _u =  0.5 * _u;
  
                      float[] COL = PAINT.getColorStyle(PAL_type, _u);
                      this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                      this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);                     
  
                      this.graphics.strokeWeight(0);
  
                      this.graphics.ellipse((j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot, 0.075 * sx_Plot, 0.075 * sx_Plot);
  
                      if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
                        this.graphics.stroke(127);
                        this.graphics.fill(127);
                        this.graphics.strokeWeight(0);
                      } else {
                        this.graphics.stroke(255);
                        this.graphics.fill(255);
                        this.graphics.strokeWeight(2);
                      }   
  
                      this.graphics.textSize(this.view_S * 4.0 * this.U_scale);
  
                      this.graphics.textAlign(CENTER, CENTER);
                      if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf(valuesSUM, 1, 1), (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot);
                      if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(valuesSUM), 1), (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot);
                    }
                  }
                }
              }
  
              this.graphics.stroke(0);
              this.graphics.fill(0);
              this.graphics.textAlign(CENTER, CENTER); 
              this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
  
              String scenario_text = "";
              //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
              //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
              //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
              this.graphics.text(scenario_text, (j - ((0 - 12) / 24.0)) * sx_Plot, 0.95  * sx_Plot / this.U_scale);
            }
          }
        }
  
        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / this.U_scale);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(0); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / this.U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / this.U_scale));
        }            
        //?? French
      }
  
      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 125;      
      for (int q = 0; q < 11; q++) {
        float _u = 0;
  
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
  
        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
  
        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       
  
        this.graphics.strokeWeight(0);
        this.graphics.rect((pal_ox + q * (pal_length / 11.0)) * this.view_S, pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S); 
  
        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }   
  
        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);
  
        if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf(0.1 * q / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
        if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 + pal_oy - 0.05 * 20) * this.view_S);
      } 
  
  
      if (this.PrintTtitle) {
  
        this.graphics.stroke(0); 
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP); 
  
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
  
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(("Direct solar radiation (kWh/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(("Direct solar effects (kWh°C/m²)"), 0, 1.2 * sx_Plot / this.U_scale);
          //?? French
        }
      }
  
    } 
  
  
  
    if ((this.PlotImpacts == 6) || (this.PlotImpacts == 7)) {
      
      if (this.PlotImpacts == 6) Impact_TYPE = Impact_ACTIVE; 
      if (this.PlotImpacts == 7) Impact_TYPE = Impact_PASSIVE;
  
      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;
  
      float values_R_dir;
      float values_R_dif;
      float values_E_dir;
      float values_E_dif;
  
      int now_k = 0;
      int now_i = 0;
      int now_j = 0;
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT;
  
      this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  
  
      for (int j = this.j_Start; j < this.j_End; j++) {
  
        now_j = (j * int(this.perDays) + TIME.beginDay + 365) % 365;
  
        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }
  
        float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
        float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
        float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
        int[] Normals_COL_N;
        Normals_COL_N = new int [9];
        Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
        for (int i = 0; i < 24; i++) {
          //for (int i = 10; i <= 14; i += 2) {
          //for (int i = 12; i <= 12; i += 2) {
  
          float HOUR_ANGLE = i; 
          float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
          float Alpha = 90 - funcs.acos_ang(SunR[3]);
          float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);
  
          now_i = i;
          now_j = int(j * this.perDays + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
  
          int RES1 = SKY2D_X_View;
          int RES2 = SKY2D_Y_View;
          
          
          { // Direct
          
            this.graphics.endDraw(); 
            ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
            PImage Image_RGBA = SKY2D_graphics.get();
            this.graphics.beginDraw();
  
            
            Image_RGBA.save(Folder_ViewsFromSky + "/" + "Direct" + nf(j,2) + nf(i,2) + ".png");
  
  
            this.graphics.imageMode(CENTER); 
            this.graphics.image(Image_RGBA, (j + this.rect_offset_x + (90 - Alpha) * this.rect_scale * (funcs.cos_ang(Beta - 90))) * sx_Plot, -((90 - Alpha) * this.rect_scale * (funcs.sin_ang(Beta - 90))) * sx_Plot, RES1, RES2);
            this.graphics.imageMode(CORNER);
            /*
            if (Materials_DirectArea_Flags[now_i][now_j] == -1) {
  
              Materials_DirectArea_Flags[now_i][now_j] = 1; 
  
              for (int mt = 0; mt < Materials_Number; mt++) {                 
                Materials_DirectArea_Data[mt][now_i][now_j] = 0;
              }   
  
              if ((i+0.5 >= sunrise) && (i+0.5 <= sunset)) {
  
                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;
  
                  color COL = Image_RGBA.get(Image_X, Image_Y);
  
                  int COL_A = COL >> 24 & 0xFF;
  
                  if (COL_A != 0) {
                    int COL_R = COL >> 16 & 0xFF; 
                    int COL_G = COL >> 8 & 0xFF; 
                    int COL_B = COL & 0xFF;
  
                    for (int mt = 0; mt < Materials_Number; mt++) {  
  
                      if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                        Materials_DirectArea_Data[mt][now_i][now_j] += 1;
                      }
                    }
                  }
                }  
  
                for (int mt = 0; mt < Materials_Number; mt++) {                 
                  Materials_DirectArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2) ; //???
  
                  if (Materials_Selection == mt) println("Direct:", mt, now_i, now_j, Materials_DirectArea_Data[mt][now_i][now_j]);
                }
  
                
              }
            }
            */
          }
  
           /*
           { // Diffuse
              this.graphics.endDraw(); 
              ViewFromTheSky(0, 0, 0, 90-Alpha, 0, Beta);
              PImage Image_RGBA = SKY2D_graphics.get();
              this.graphics.beginDraw();
             
             if (Materials_DiffuseArea_Flags[now_i][now_j] == -1) {
               
               Materials_DiffuseArea_Flags[now_i][now_j] = 1; 
               
               for (int mt = 0; mt < Materials_Number; mt++) {                 
                 Materials_DiffuseArea_Data[mt][now_i][now_j] = 0;
               }                 
               
               int num_diffuse_views = 0;
               
               for (int vNo = 0; vNo < skyVertices.length; vNo++) {
                 
                 float skyAngle_Alpha = funcs.asin_ang(skyVertices[vNo][2]);
                 float skyAngle_Beta = funcs.atan2_ang(skyVertices[vNo][1], skyVertices[vNo][0]) + 90;
                 
                 if (skyAngle_Alpha >= 0) {
                   
                   num_diffuse_views += 1;
                   
                   PGraphics Image_RGBA = ViewFromTheSky(RES1,RES2,ZOOM, 0,0,0, 90-skyAngle_Alpha,0,skyAngle_Beta);
                   
                   //this.graphics.imageMode(CENTER); 
                   //this.graphics.image(Image_RGBA, (j + this.rect_offset_x + (90 - skyAngle_Alpha) * this.rect_scale * (funcs.cos_ang(skyAngle_Beta - 90))) * sx_Plot, -((90 - skyAngle_Alpha) * this.rect_scale * (funcs.sin_ang(skyAngle_Beta - 90))) * sx_Plot, RES1, RES2);
                   //this.graphics.imageMode(CORNER);
                   
                   for (int np = 0; np < (RES1 * RES2); np++) {
                     int Image_X = np % RES1;
                     int Image_Y = np / RES1;
                     
                     color COL = Image_RGBA.get(Image_X, Image_Y);
                     
                     int COL_A = COL >> 24 & 0xFF;
                     
                     if (COL_A != 0) {
                       int COL_R = COL >> 16 & 0xFF; 
                       int COL_G = COL >> 8 & 0xFF; 
                       int COL_B = COL & 0xFF;
                       
                       for (int mt = 0; mt < Materials_Number; mt++) {  
                         
                         if ((COL_R == Materials_Color[mt][1]) && (COL_G == Materials_Color[mt][2]) && (COL_B == Materials_Color[mt][3])) {
                           Materials_DiffuseArea_Data[mt][now_i][now_j] += 1;
                         }
                       }
                     }
                   }  
                   
                 }
               }
               for (int mt = 0; mt < Materials_Number; mt++) {                 
                 Materials_DiffuseArea_Data[mt][now_i][now_j] *= 0.975 * 1000.0 / (RES1 * RES2); //???
                 Materials_DiffuseArea_Data[mt][now_i][now_j] *= 2.0 / float(num_diffuse_views); // note: multiply by 2 to have a area equal to roof!
                 
                 if (Materials_Selection == mt) println("Diffuse:", mt, now_i, now_j, Materials_DiffuseArea_Data[mt][now_i][now_j]); 
               }
               
               //---------------------------------------------
               // applying calculated diffuse model at this time for the rest of year.
               for (int mt = 0; mt < Materials_Number; mt++) {
                 for (int loop_i = 0; loop_i < 24; loop_i++) {
                   for (int loop_j = 0; loop_j < 365; loop_j++) {
                     Materials_DiffuseArea_Data[mt][loop_i][loop_j] = Materials_DiffuseArea_Data[mt][now_i][now_j];
                     Materials_DiffuseArea_Flags[loop_i][loop_j] = 1;
                   }
                 }  
               }
               //---------------------------------------------                          
             }
           }
           */
           
  
        }
        
      }
      
      if (this.PrintTtitle) {
  
        this.graphics.stroke(0); 
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(LEFT, TOP); 
  
        this.graphics.text(("Solar perspectives"), 0, 1.2 * sx_Plot / this.U_scale);
      }
    } 
  
  
    if ((this.PlotImpacts == 8) || (this.PlotImpacts == 9)) {
  
      //for (int p = 0; p < 3; p++) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      //for (int p = 0; p < 3; p += 2) { 
      //int l = 3 * int(this.ImpactLayer / 3) + p;
  
      for (int p = 0; p < 1; p++) { 
        int l = this.ImpactLayer;
  
        //for (int p = 0; p < 1; p++) { 
        //int l = 3 * int(this.ImpactLayer / 3) + 1; //this.ImpactLayer;    
  
        int target_window = TypeWindow.STUDY;
        Sun3D.draw_Cycles(x_Plot, y_Plot - (1 * p * sx_Plot / this.U_scale), z_Plot, sx_Plot, sy_Plot, sz_Plot, l, target_window);
  
        this.drawPositionGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot, 0);
  
        String scenario_text = "";
        //if (CurrentDataSource == dataID_CLIMATE_CWEEDS) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CWEEDS_start - 1, 0);
        //if (CurrentDataSource == dataID_CLIMATE_CLMREC) scenario_text += "Year: " + nf(Normals_COL_N[l] + CLIMATE_CLMREC_start - 1, 0);
        //if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) scenario_text += "Member: " + nf(Normals_COL_N[l], 0);
        this.graphics.text(scenario_text, ((this.j_Start - 1) - ((0 - 12) / 24.0)) * sx_Plot, (0.9 - 1 * (p - 0.25)) * sx_Plot / this.U_scale);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, CENTER); 
        this.graphics.stroke(0);
        this.graphics.fill(0);
        this.graphics.strokeWeight(0); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(STAT_N_Title[l], 0, - (1 * p * sx_Plot / this.U_scale));
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(STAT_N_Title[STAT_reverse_N[l]], 0, - (1 * p * sx_Plot / this.U_scale));
        }            
        //?? French
      }    
  
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT;
  
      float pal_length = 400;
      float pal_ox = 700;
      float pal_oy = 125;  

      if (this.j_End == 2) {
        pal_oy = 325;
      }
  
      for (int q = 0; q < 11; q++) {
        float _u = 0;
  
        if (Impact_TYPE == Impact_ACTIVE) _u = 0.1 * q;
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.2 * q - 0.5;
  
        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
  
        float[] COL = PAINT.getColorStyle(PAL_type, _u);
        this.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
        this.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);       
  
        this.graphics.strokeWeight(0);
        this.graphics.rect((700 + q * (pal_length / 11.0)) * this.view_S, -pal_oy * this.view_S, (pal_length / 11.0) * this.view_S, 20 * this.view_S);
  
        if (COL[1] + COL[2] + COL[3] > 1.75 * 255) {
          this.graphics.stroke(127);
          this.graphics.fill(127);
          this.graphics.strokeWeight(0);
        } else {
          this.graphics.stroke(255);
          this.graphics.fill(255);
          this.graphics.strokeWeight(2);
        }   
  
        this.graphics.textSize(15.0 * this.view_S);
        this.graphics.textAlign(CENTER, CENTER);
        if (Impact_TYPE == Impact_ACTIVE) this.graphics.text(nf(0.1 * q / PAL_multiplier, 1, 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 - pal_oy - 0.05 * 20) * this.view_S);
        if (Impact_TYPE == Impact_PASSIVE) this.graphics.text(nf(int(funcs.roundTo(0.4 * (q - 5) / PAL_multiplier, 1)), 1), (20 + pal_ox + q * (pal_length / 11.0)) * this.view_S, (10 - pal_oy - 0.05 * 20) * this.view_S);
      } 
  
  
      if (this.PrintTtitle) {
  
        this.graphics.stroke(0); 
        this.graphics.fill(0);
        this.graphics.strokeWeight(this.T_scale * 0);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(RIGHT, TOP); 
  
        if (CurrentDataSource == dataID_CLIMATE_CWEEDS) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CWEEDS_start) + "-" + String.valueOf(end_k + CLIMATE_CWEEDS_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_CLIMATE_CLMREC) this.graphics.text(("[" + String.valueOf(start_k + CLIMATE_CLMREC_start) + "-" + String.valueOf(end_k + CLIMATE_CLMREC_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
        if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) this.graphics.text(("[" + String.valueOf(start_k + ENSEMBLE_FORECAST_start) + "-" + String.valueOf(end_k + ENSEMBLE_FORECAST_start) + "] "), 0, 1.2 * sx_Plot / this.U_scale);
  
        this.graphics.textSize(sx_Plot * 0.250 / this.U_scale);
        this.graphics.textAlign(CENTER, TOP); 
        if (Impact_TYPE == Impact_ACTIVE) {  
          this.graphics.text(("Direct solar radiation (kWh/m²)"), (700 + 5 * (pal_length / 11.0)) * this.view_S + (pal_length / 11.0) * this.view_S, -pal_oy * this.view_S + 20 * this.view_S);
          //?? French
        }
        if (Impact_TYPE == Impact_PASSIVE) {  
          this.graphics.text(("Direct solar effects (kWh°C/m²)"), (700 + 5 * (pal_length / 11.0)) * this.view_S + (pal_length / 11.0) * this.view_S, -pal_oy * this.view_S + 20 * this.view_S);
          //?? French
        }
      }
    } 
  
  
  
  
  
    if ((this.PlotImpacts == 8) || (this.PlotImpacts == 9)) {
    } else {
      this.drawDailyGrid(x_Plot, y_Plot, z_Plot, sx_Plot, sy_Plot, sz_Plot);
    }
  
    keep_STUDY_perDays = this.perDays;
    this.joinDays = keep_STUDY_joinDays;
  
  
    
  
    this.graphics.popMatrix();
  }  
  
  


  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);

    parent.setInt("i_Start", this.i_Start);
    parent.setInt("i_End", this.i_End);    
    parent.setInt("j_Start", this.j_Start);
    parent.setInt("j_End", this.j_End);
    parent.setFloat("perDays", this.perDays);
    parent.setInt("joinDays", this.joinDays);
    
    parent.setFloat("T_scale", this.T_scale);
    parent.setFloat("U_scale", this.U_scale);

    parent.setInt("skyScenario", this.skyScenario);    
    parent.setInt("filter", this.filter);
    parent.setInt("TrendJoinHours", this.TrendJoinHours);
    parent.setInt("TrendJoinType", this.TrendJoinType);
    parent.setString("export_info_node", Boolean.toString(this.export_info_node));
    parent.setString("export_info_norm", Boolean.toString(this.export_info_norm));
    parent.setString("export_info_prob", Boolean.toString(this.export_info_prob));
    parent.setInt("pallet_SORT_CLR", this.pallet_SORT_CLR);
    parent.setInt("pallet_SORT_DIR", this.pallet_SORT_DIR);
    parent.setFloat("pallet_SORT_MLT", this.pallet_SORT_MLT);
    parent.setInt("pallet_PROB_CLR", this.pallet_PROB_CLR);
    parent.setInt("pallet_PROB_DIR", this.pallet_PROB_DIR);
    parent.setFloat("pallet_PROB_MLT", this.pallet_PROB_MLT);
    parent.setInt("ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    parent.setInt("ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    parent.setFloat("ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    parent.setInt("PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    parent.setInt("PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    parent.setFloat("PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);    
    
    parent.setFloat("O_scale", this.O_scale);
    parent.setFloat("W_scale", this.W_scale);    
    parent.setFloat("rect_scale", this.rect_scale);
    parent.setFloat("rect_offset_x", this.rect_offset_x);
    
    parent.setString("impact_summary", Boolean.toString(this.impact_summary));
    parent.setInt("ImpactLayer", this.ImpactLayer);
    parent.setInt("PlotImpacts", this.PlotImpacts);
    parent.setString("Impacts_update", Boolean.toString(this.Impacts_update));   
   
    parent.setString("displayRaws", Boolean.toString(this.displayRaws));
    parent.setString("displaySorted", Boolean.toString(this.displaySorted));
    parent.setString("displayNormals", Boolean.toString(this.displayNormals));
    parent.setString("displayProbs", Boolean.toString(this.displayProbs));
    parent.setInt("sumInterval", this.sumInterval);
    parent.setFloat("LevelPix", this.LevelPix);
    parent.setFloat("Pix", this.Pix);
    parent.setInt("plotSetup", this.plotSetup);
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.i_Start = parent.getInt("i_Start");
    this.i_End = parent.getInt("i_End");
    this.j_Start = parent.getInt("j_Start");
    this.j_End = parent.getInt("j_End");
    this.perDays = parent.getFloat("perDays");
    this.joinDays = parent.getInt("joinDays");
    
    this.T_scale = parent.getFloat("T_scale");
    this.U_scale = parent.getFloat("U_scale");
    this.skyScenario = parent.getInt("skyScenario");      
    this.filter = parent.getInt("filter");
    this.TrendJoinHours = parent.getInt("TrendJoinHours");
    this.TrendJoinType = parent.getInt("TrendJoinType");
    this.export_info_node = Boolean.parseBoolean(parent.getString("export_info_node"));
    this.export_info_norm = Boolean.parseBoolean(parent.getString("export_info_norm"));
    this.export_info_prob = Boolean.parseBoolean(parent.getString("export_info_prob"));
    this.pallet_SORT_CLR = parent.getInt("pallet_SORT_CLR");
    this.pallet_SORT_DIR = parent.getInt("pallet_SORT_DIR");
    this.pallet_SORT_MLT = parent.getFloat("pallet_SORT_MLT");
    this.pallet_PROB_CLR = parent.getInt("pallet_PROB_CLR");
    this.pallet_PROB_DIR = parent.getInt("pallet_PROB_DIR");
    this.pallet_PROB_MLT = parent.getFloat("pallet_PROB_MLT");
    this.ACTIVE_pallet_CLR = parent.getInt("ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = parent.getInt("ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = parent.getFloat("ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = parent.getInt("PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = parent.getInt("PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = parent.getFloat("PASSIVE_pallet_MLT");
    
    
    this.O_scale = parent.getFloat("O_scale");
    this.W_scale = parent.getFloat("W_scale");
    this.rect_scale = parent.getFloat("rect_scale");
    this.rect_offset_x = parent.getFloat("rect_offset_x");
    
    this.impact_summary = Boolean.parseBoolean(parent.getString("impact_summary"));
    this.ImpactLayer = parent.getInt("ImpactLayer");
    this.PlotImpacts = parent.getInt("PlotImpacts");
    this.Impacts_update = Boolean.parseBoolean(parent.getString("Impacts_update"));
    
    this.displayRaws = Boolean.parseBoolean(parent.getString("displayRaws"));
    this.displaySorted = Boolean.parseBoolean(parent.getString("displaySorted"));
    this.displayNormals = Boolean.parseBoolean(parent.getString("displayNormals"));
    this.displayProbs = Boolean.parseBoolean(parent.getString("displayProbs"));
    this.sumInterval = parent.getInt("sumInterval");
    this.LevelPix = parent.getFloat("LevelPix");
    this.Pix = parent.getFloat("Pix");
    this.plotSetup = parent.getInt("plotSetup");
 
  }       

}

solarchvision_STUDY STUDY = new solarchvision_STUDY();




float SOLARCHVISION_Spinner (float x, float y, int update1, int update2, int update3, String caption, float v, float min_v, float max_v, float stp_v) {

  float new_value = v;

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v;    

  float cx, cy, cr;
  float w1, w2, h, o, t_o; 

  //w1 = 32.5 * ROLLOUT.view_S;
  //w2 = 142.5 * ROLLOUT.view_S;

  w1 = 100 * ROLLOUT.view_S;
  w2 = 200 * ROLLOUT.view_S;

  h = 16 * ROLLOUT.view_S;
  o = 2 * ROLLOUT.view_S;
  t_o = h * ROLLOUT.view_S / 8.0;

  STUDY.Y_control += 25 * ROLLOUT.view_S; //(h + 2 * o) * 1.25;

  strokeWeight(0); 
  stroke(0); 
  fill(0);
  rect(x + o, y - (h / 2) - o, 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  rect(x + o, y - (h / 2) - o + 0.5 * (h + 2 * o), 0.5 * (h + 2 * o), 0.5 * (h + 2 * o));
  stroke(255); 
  fill(255);
  cx = x + o + 0.25 * (h + 2 * o);
  cy = y - (h / 2) - o + 0.25 * (h + 2 * o);
  cr = 0.25 * (h + 2 * o);
  triangle(cx + cr * funcs.cos_ang(270), cy + 0.75 * cr * funcs.sin_ang(270), cx + 0.75 * cr * funcs.cos_ang(30), cy + 0.75 * cr * funcs.sin_ang(30), cx + 0.75 * cr * funcs.cos_ang(150), cy + 0.75 * cr * funcs.sin_ang(150));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {
    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value *= abs(stp_v);
      } else { 
        new_value += abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = max_v;
    }
  }

  cy += 2 * cr;
  triangle(cx + cr * funcs.cos_ang(90), cy + 0.75 * cr * funcs.sin_ang(90), cx + 0.75 * cr * funcs.cos_ang(210), cy + 0.75 * cr * funcs.sin_ang(210), cx + 0.75 * cr * funcs.cos_ang(330), cy + 0.75 * cr * funcs.sin_ang(330));

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx - cr, cy - cr, cx + cr, cy + cr) == 1) {

    if (mouseButton == LEFT) {

      if (stp_v < 0) {
        new_value /= abs(stp_v);
      } else { 
        new_value -= abs(stp_v);
      }
    } else if (mouseButton == RIGHT) {

      new_value = min_v;
    }
  }

  if (new_value < min_v) new_value = max_v; 
  if (new_value > max_v) new_value = min_v; 



  strokeWeight(0); 
  stroke(191); 
  fill(191);
  rect(x - (w1 + w2) - o, y - (h / 2) - o, (w1 + w2) + 2 * o, h + 2 * o);

  stroke(255); 
  fill(255);
  rect(x - w1, y - (h / 2), w1, h);

  float q = 0;

  if (max_v - min_v > 0.001) {
    q = (new_value - min_v) / (max_v - min_v);
  }

  if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x - w1, y - (h / 2), x, y + (h / 2)) == 1) {

    q = 1;

    if (max_v - min_v > 0.001) {
      q = (SOLARCHVISION_X_clicked - (x - w1)) / w1;
    }

    new_value = min_v + q * (max_v - min_v);

    if (new_value < min_v) new_value = max_v; 
    if (new_value > max_v) new_value = min_v;

    ROLLOUT.update = true;
  }

  strokeWeight(0); 
  stroke(191, 255, 191); 
  fill(191, 255, 191);
  rect(x - w1, y - (h / 2), q * w1, h);          


  strokeWeight(2); 
  stroke(0); 
  noFill();
  rect(x - w1, y - (h / 2), w1, h);    

  strokeWeight(0);
  stroke(0); 
  fill(0);
  textSize(1.0 * h);
  textAlign(RIGHT, CENTER);
  if ((new_value == int(new_value)) || (new_value >= 100)) {
    text(String.valueOf(int(new_value)), x - t_o, y - t_o);
  } else {
    text(nf(new_value, 0, 0), x - t_o, y - t_o);
  }


  strokeWeight(0);
  stroke(0); 
  fill(0);
  //textSize(1.0 * h);
  textSize(0.85 * h);
  //textAlign(RIGHT, CENTER); text(caption + ":", x - w1 - t_o, y - t_o);
  textAlign(LEFT, CENTER); 
  text(caption + ":", x - w1 - w2 + t_o, y - t_o);

  if (new_value != v) {
    if (update1 != 0) STUDY.update = true;
    if (update2 != 0) WIN3D.update = true;
    if (update3 != 0) WORLD.update = true;
  }

  return new_value;
}



String[][] allRollouts = {
  {
    "Location & Data", "Point", "Weather", "Space"
  }
  , 
  {
    "Geometries & Space", "General", "Create", "Modify", "Solid", "Surface", "Model2Ds", "Environment", "Viewport", "Simulation"
  }
  , 
  {
    "Period & Scenarios", "Time", "Ranges", "Filters"
  }
  , 
  {
    "Illustration Options", "2D-Layers", "2D-Colors", "3D-Solar", "3D-Spatial", "Selection"
  }
  , 
  {
    "Post-Processing", "Interpolation", "Developed", "Impacts"
  }
  , 
  {
    "Export Products", "Data", "Media"
  }
};


class solarchvision_ROLLOUT {
  
  private final static String CLASS_STAMP = "ROLLOUT";
  
  int cX = 2 * SOLARCHVISION_pixel_W;
  int cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
  int dX = 1 * SOLARCHVISION_pixel_H;
  int dY = 2 * SOLARCHVISION_pixel_H;
  float view_R = float(dY) / float(dX);
  float view_S = SOLARCHVISION_pixel_H / 325.0; //1; //0.75; // ?????
  
  boolean update = true;
  boolean include = true;
  
  int parent = 0; // 0: Location, 1: Geometry, 2: Time, etc.
  int child = 1; // number of the category inside e.g. 1, 2, ...


  void drawView () {
  
    stroke(255); 
    fill(255);
    strokeWeight(0);
    rect(this.cX, this.cY, this.dX, this.dY);
  
  
    float h = 20 * this.view_S;
  
    STUDY.X_control = this.cX;
    STUDY.Y_control = this.cY;
  
    STUDY.X_control += 307.5 * this.view_S;
    STUDY.Y_control += 7.5 * this.view_S;
  
    if (this.parent >= allRollouts.length) {
      this.parent = allRollouts.length - 1;
    }
  
    if (this.child >= allRollouts[this.parent].length) {
      this.child = allRollouts[this.parent].length - 1;
    }  
  
    if (this.parent < allRollouts.length) {
  
      for (int i = 0; i < allRollouts.length; i++) {
  
        float cx = this.cX + (150 * (i % 2) + 5) * this.view_S;
        float cy = STUDY.Y_control;
        float cr = 6.75 * this.view_S;      
  
        textAlign(LEFT, CENTER);    
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 150 * this.view_S, cy + cr) == 1) {
          this.parent = i;
          this.child = 1; // <<<<<
  
          this.update = true;
        }
  
        if (i == this.parent) {
          strokeWeight(2); 
          stroke(63); 
          fill(191);
          rect(cx - 2.5 * this.view_S, cy - 5 * this.view_S, 150 * this.view_S, 2 * 7.5 * this.view_S);
          strokeWeight(0); 
  
          stroke(0); 
          fill(0);
          textSize(15 * this.view_S);
        } else {
          stroke(127); 
          fill(127);
          textSize(15 * this.view_S);
        }
  
        text(nf(i + 1, 0) + ":" + allRollouts[i][0], cx, cy);
  
        if (i % 2 == 1) STUDY.Y_control += 15 * this.view_S;
      }
  
      strokeWeight(2); 
      stroke(63); 
      fill(63);
      rect(this.cX, STUDY.Y_control, this.dX, 17.5 * ceil((allRollouts[this.parent].length - 1) / 3.0) * this.view_S);
      strokeWeight(0);    
  
      STUDY.Y_control += 5 * this.view_S;
  
      for (int i = 1; i < allRollouts[this.parent].length; i++) {
  
        float cx = this.cX + (100 * ((i - 1) % 3) + 10) * this.view_S;
        float cy = STUDY.Y_control;
        float cr = 6.75 * this.view_S;        
  
        textAlign(LEFT, CENTER);     
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + 100 * this.view_S, cy + cr) == 1) {
          this.child = i;
  
          this.update = true;
        }      
  
        if (i == this.child) {
          stroke(255, 127, 0); 
          fill(255, 127, 0);
          textSize(15 * this.view_S);
        } else {
          stroke(255); 
          fill(255);
          textSize(12.5 * this.view_S);
        }
  
        text("[" + nf(i, 0) + "]" + allRollouts[this.parent][i], cx, cy);
  
        if (i % 3 == 0) STUDY.Y_control += 15 * this.view_S;
      }
  
      if (allRollouts[this.parent].length % 3 != 1) STUDY.Y_control += 15 * this.view_S;
  
      STUDY.Y_control += 15 * this.view_S;
    }
  
  
  
  
    if (this.parent == 0) { // Location & data
  
  
      if (this.child == 1) { // Point
  
        //WORLD.autoView = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Auto Fit", WORLD.autoView, 0, 1, 1), 1));
        //WORLD.VIEW_id = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,1, "Map Viewport", WORLD.VIEW_id, 0, WORLD.numMaps - 1, 1), 1));
  
        LocationLAT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Latitude", LocationLAT, -85, 85, LocationLAT_step);
        LocationLON = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Longitude", LocationLON, -180, 180, LocationLON_step);
        //LocationELE = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "Elevation", LocationELE, -100, 8000, LocationELE_step);
  
        LocationLAT_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Latitude_step", LocationLAT_step, 0.001, 10, -2);
        LocationLON_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Longitude_step", LocationLON_step, 0.001, 10, -2);
        //LocationELE_step = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Elevation_step", LocationELE_step, 0.125, 1024, -2);
  
      }
  
      if (this.child == 2) { // Weather
  
        WORLD.displayAll_TMYEPW = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayAll_TMYEPW", WORLD.displayAll_TMYEPW, 0, 2, 1), 1));
        //WORLD.displayNear_TMYEPW = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_TMYEPW", WORLD.displayNear_TMYEPW, 0, 1, 1), 1));
  
        WORLD.displayAll_CWEEDS = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayAll_CWEEDS", WORLD.displayAll_CWEEDS, 0, 2, 1), 1));
        //WORLD.displayNear_CWEEDS = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_CWEEDS", WORLD.displayNear_CWEEDS, 0, 1, 1), 1));
  
        WORLD.displayAll_CLMREC = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayAll_CLMREC", WORLD.displayAll_CLMREC, 0, 2, 1), 1));
        //WORLD.displayNear_CLMREC = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_CLMREC", WORLD.displayNear_CLMREC, 0, 1, 1), 1));
  
        WORLD.displayAll_SWOB = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayAll_SWOB", WORLD.displayAll_SWOB, 0, 2, 1), 1));
        //WORLD.displayNear_SWOB = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_SWOB", WORLD.displayNear_SWOB, 0, 1, 1), 1));
  
        WORLD.displayAll_NAEFS = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayAll_NAEFS", WORLD.displayAll_NAEFS, 0, 2, 1), 1));
        //WORLD.displayNear_NAEFS = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "WORLD.displayNear_NAEFS", WORLD.displayNear_NAEFS, 0, 1, 1), 1));
  
        
        //ENSEMBLE_FORECAST_load = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_FORECAST_load", ENSEMBLE_FORECAST_load, 0, 1, 1), 1));
        //ENSEMBLE_OBSERVED_load = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "ENSEMBLE_OBSERVED_load", ENSEMBLE_OBSERVED_load, 0, 1, 1), 1));
        //CLIMATE_CLMREC_load = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CLMREC_load", CLIMATE_CLMREC_load, 0, 1, 1), 1));
        //CLIMATE_CWEEDS_load = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_CWEEDS_load", CLIMATE_CWEEDS_load, 0, 1, 1), 1));
        //CLIMATE_TMYEPW_load = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "CLIMATE_TMYEPW_load", CLIMATE_TMYEPW_load, 0, 1, 1), 1));
  
        GRIB2_Hour_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Start", GRIB2_Hour_Start, 0, 48, 1), 1));
        GRIB2_Hour_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_End", GRIB2_Hour_End, 0, 48, 1), 1));
        GRIB2_Hour_Step = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Hour_Step", GRIB2_Hour_Step, 1, 24, 1), 1));
  
        GRIB2_Layer_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Start", GRIB2_Layer_Start, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_End", GRIB2_Layer_End, 0, numberOfLayers, 1), 1));
        GRIB2_Layer_Step = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "GRIB2_Layer_Step", GRIB2_Layer_Step, 1, numberOfLayers, 1), 1));
      }
  
      if (this.child == 3) { // Space
  
        //Tropo3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.displaySurface", Tropo3D.displaySurface, 0, 1, 1), 1));
        //Tropo3D.displayTexture = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Tropo3D.displayTexture", Tropo3D.displayTexture, 0, 1, 1), 1));      
  
        //Earth3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.displaySurface", Earth3D.displaySurface, 0, 1, 1), 1));
        //Earth3D.displayTexture = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Earth3D.displayTexture", Earth3D.displayTexture, 0, 1, 1), 1));
  
        //Moon3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.displaySurface", Moon3D.displaySurface, 0, 1, 1), 1));
        //Moon3D.displayTexture = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Moon3D.displayTexture", Moon3D.displayTexture, 0, 1, 1), 1));
  
        //Sun3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displaySurface", Sun3D.displaySurface, 0, 1, 1), 1));
        //Sun3D.displayTexture = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayTexture", Sun3D.displayTexture, 0, 1, 1), 1));      
  
        Planetary_Magnification = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Planetary_Magnification", Planetary_Magnification, 1, 100, 1.0);
      }
    } else if (this.parent == 1) { // Geometries & Space
  
      if (this.child == 1) { // General
  
        User3D.create_MeshOrSolid = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_MeshOrSolid", User3D.create_MeshOrSolid, 0, 1, 1), 1));
  
        allFaces.displayTessellation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Model3Ds.displayTessellation", allFaces.displayTessellation, 0, 4, 1), 1));
  
        Land3D.displayTessellation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayTessellation", Land3D.displayTessellation, 0, 4, 1), 1));
  
        Sky3D.displayTessellation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.displayTessellation", Sky3D.displayTessellation, 0, 4, 1), 1));   
        Sky3D.scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.scale", Sky3D.scale, 0.0000001, 1000000, -2);
  
        BIOSPHERE_drawResolution = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "BIOSPHERE_drawResolution", BIOSPHERE_drawResolution, 1, 10, 1), 1);
  
        OBJECTS_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "OBJECTS_scale", OBJECTS_scale, 0.0000001, 1000000, -2);      
  
        Load_DefaultModels = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Load_DefaultModels", Load_DefaultModels, 0, allModel3Ds.maximum_default_models, 1), 1));
      }
  
  
  
      if (this.child == 2) { // Create
  
        //addToLastGroup = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "addToLastGroup", addToLastGroup, 0, 1, 1), 1));
  
        User3D.default_Material = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.default_Material", User3D.default_Material, -1, 8, 1), 1));
        User3D.default_Tessellation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.default_Tessellation", User3D.default_Tessellation, 0, 6, 1), 1));
        User3D.default_Layer = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.default_Layer", User3D.default_Layer, 0, 16, 1), 1));
        User3D.default_Visibility = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.default_Visibility", User3D.default_Visibility, -1, 1, 1), 1));
        User3D.default_Weight = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "User3D.default_Weight" , User3D.default_Weight, -20, 20, 1), 1));
        User3D.default_Closed = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "User3D.default_Closed" , User3D.default_Closed, 0, 1, 1), 1));
  
        User3D.default_PivotType = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.default_PivotType", User3D.default_PivotType, 0, 4, 1), 1));
  
        User3D.create_Orientation = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Orientation", User3D.create_Orientation, 0, 360, 15);
  
        User3D.create_Length = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Length", User3D.create_Length, -50, 150, -2), 0.5); 
        User3D.create_Width = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Width", User3D.create_Width, -50, 150, -2), 0.5); 
        User3D.create_Height = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Height", User3D.create_Height, -50, 150, -2), 0.5);     
  
        User3D.create_Volume = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Volume", User3D.create_Volume, 0, 25000, 1000);
        
        User3D.create_Snap = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Snap", User3D.create_Snap, 0, 1, 1), 1));
      }    
  
      if (this.child == 3) { // Modify
  
        User3D.modify_OpenningDepth = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_OpenningDepth", User3D.modify_OpenningDepth, -10, 10, 0.1);
        User3D.modify_OpenningArea = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_OpenningArea", User3D.modify_OpenningArea, 0, 1, 0.05);
        User3D.modify_OpenningDeviation = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_OpenningDeviation", User3D.modify_OpenningDeviation, 0, 1, 0.05);
  
        User3D.modify_TessellateRows = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_TessellateRows", User3D.modify_TessellateRows, 1, 100, 1), 1));
        User3D.modify_TessellateColumns = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_TessellateColumns", User3D.modify_TessellateColumns, 1, 100, 1), 1));
  
        User3D.modify_OffsetAmount = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_OffsetAmount", User3D.modify_OffsetAmount, 0, 25, 0.001);
  
        User3D.modify_WeldTreshold = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.modify_WeldTreshold", User3D.modify_WeldTreshold, 0, 10, 0.001);      
  
        userSelections.softPower = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.softPower", userSelections.softPower, 0.125, 8, -2);
        userSelections.softRadius = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.softRadius", userSelections.softRadius, 0.01, 100, -2);
  
        userSelections.posVector = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.posVector", userSelections.posVector, 0, 3, 1), 1));
        userSelections.rotVector =  int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.rotVector", userSelections.rotVector, 0, 2, 1), 1));
        userSelections.scaleVector =  int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.scaleVector", userSelections.scaleVector, 0, 3, 1), 1));
  
        userSelections.posValue = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.posValue", userSelections.posValue, -50, 50, 1), 1));
        userSelections.rotValue = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.rotValue", userSelections.rotValue, -180, 180, 5), 5)); 
        userSelections.scaleValue = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.scaleValue", userSelections.scaleValue, -8, 8, 0.5), 0.5)); 
  
        userSelections.alignX = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.alignX", userSelections.alignX, -1, 1, 1), 1));
        userSelections.alignY = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.alignY", userSelections.alignY, -1, 1, 1), 1));
        userSelections.alignZ = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.alignZ", userSelections.alignZ, -1, 1, 1), 1));
      }
  
      if (this.child == 4) { // Solid
  
        //User3D.create_powRnd = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,0,0, "User3D.create_powRnd" , User3D.create_powRnd, 0, 1, 1), 1));    
        User3D.create_powAll = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_powAll", User3D.create_powAll, 0.5, CubePower, -2);
        User3D.create_powX = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_powX", User3D.create_powX, 0.5, CubePower, -2); 
        User3D.create_powY = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_powY", User3D.create_powY, 0.5, CubePower, -2); 
        User3D.create_powZ = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_powZ", User3D.create_powZ, 0.5, CubePower, -2);
      }  
  
      if (this.child == 5) { // Surface
  
        User3D.create_SphereDegree = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_SphereDegree", User3D.create_SphereDegree, 0, 5, 1), 1));      
  
        User3D.create_CylinderDegree = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_CylinderDegree", User3D.create_CylinderDegree, 3, 36, 1), 1));    
  
        User3D.create_PolyDegree = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_PolyDegree", User3D.create_PolyDegree, 3, 36, 1), 1));
  
        User3D.create_Parametric_Type = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Parametric_Type", User3D.create_Parametric_Type, 0, 7, 1), 1));
        User3D.create_Person_Type = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Person_Type", User3D.create_Person_Type, 0, allModel2Ds.num_files_PEOPLE, 1), 1));
        User3D.create_Plant_Type = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Plant_Type", User3D.create_Plant_Type, 0, allModel2Ds.num_files_TREES, 1), 1));
      }
  
      if (this.child == 6) { // allModel2Ds
  
        User3D.create_Model1D_Type = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_Type", User3D.create_Model1D_Type, 0, 0, 1), 1));
        User3D.create_Model1D_DegreeMin = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_DegreeMin", User3D.create_Model1D_DegreeMin, 1, 9, 1), 1));
        User3D.create_Model1D_DegreeMax = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_DegreeMax", User3D.create_Model1D_DegreeMax, 1, 9, 1), 1));
        User3D.create_Model1D_Seed = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_Seed", User3D.create_Model1D_Seed, -1, 32767, 1), 1));
        User3D.create_Model1D_TrunkSize = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_TrunkSize", User3D.create_Model1D_TrunkSize, 0, 10, 0.1), 0.1);
        User3D.create_Model1D_LeafSize = funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.create_Model1D_LeafSize", User3D.create_Model1D_LeafSize, 0, 10, 0.1), 0.1);
      }    
  
      if (this.child == 7) { // Environment
  
        //Land3D.loadTextures = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.loadTextures", Land3D.loadTextures, 0, 1, 1), 1));
        //Land3D.loadMesh = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.loadMesh", Land3D.loadMesh, 0, 1, 1), 1));
        //Land3D.Surface_SkipStart = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Surface_SkipStart", Land3D.Surface_SkipStart, 0, Land3D.num_rows - 1, 1), 1));
        //Land3D.Surface_SkipEnd = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.Surface_SkipEnd", Land3D.Surface_SkipEnd, 0, Land3D.num_rows - 1, 1), 1));
        //Land3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displaySurface", Land3D.displaySurface, 0, 1, 1), 1));
        //Land3D.displayTexture = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayTexture", Land3D.displayTexture, 0, 1, 1), 1));
        //Land3D.displayPoints = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayPoints", Land3D.displayPoints, 0, 1, 1), 1));     
        //Land3D.displayDepth = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.displayDepth", Land3D.displayDepth, 0, 1, 1), 1));
  
        //allModel2Ds.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel2Ds.displayAll", allModel2Ds.displayAll, 0, 1, 1), 1));
        //allModel1Ds.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel1Ds.displayAll", allModel1Ds.displayAll, 0, 1, 1), 1));
        //allModel1Ds.displayLeaves = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allModel1Ds.displayLeaves", allModel1Ds.displayLeaves, 0, 1, 1), 1));
        //allCurves.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allCurves.displayAll", allCurves.displayAll, 0, 1, 1), 1));
        //allFaces.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.displayAll", allFaces.displayAll, 0, 1, 1), 1));
  
        //allSolids.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.displayAll", allSolids.displayAll, 0, 1, 1), 1));
  
        //allSections.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSections.displayAll", allSections.displayAll, 0, 1, 1), 1));
  
  
  
  
        //allWindRoses.displayImage = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.displayImage", allWindRoses.displayImage, 0, 1, 1), 1));
  
        allWindRoses.scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.scale", allWindRoses.scale, 50, 3200, -2);
        allWindRoses.RES = int(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindRoses.resolution", allWindRoses.RES, 200, 600, 100));
  
  
  
        //Sky3D.displaySurface = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.displaySurface", Sky3D.displaySurface, 0, 1, 1), 1));
  
        //Sun3D.displayPath = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayPath", Sun3D.displayPath, 0, 1, 1), 1));
        //Sun3D.displayPattern = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.displayPattern", Sun3D.displayPattern, 0, 1, 1), 1));
      }
  
  
      if (this.child == 8) { // Viewport
  
        WIN3D.currentCamera = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.currentCamera", WIN3D.currentCamera, 0, allCameras.num, 1), 1));
  
        WIN3D.CAM_clipNear = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.CAM_clipNear", WIN3D.CAM_clipNear, 0.01, 100, -2);
        WIN3D.CAM_clipFar = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "WIN3D.CAM_clipFar", WIN3D.CAM_clipFar, 1000, 2000000000, -2);
  
        //WIN3D.FacesShade = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0,1,0, "WIN3D.FacesShade", WIN3D.FacesShade, 0, SHADE.Options_num - 1, 1), 1));
  
        //allPoints.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Model3Ds.displayVertices", allPoints.displayAll, 0, 1, 1), 1));
        //allFaces.displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Model3Ds.displayEdges", allFaces.displayEdges, 0, 1, 1), 1));
        //allFaces.displayNormals = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Model3Ds.displayNormals", allFaces.displayNormals, 0, 1, 1), 1));
  
        //allCameras.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allCameras.displayAll", allCameras.displayAll, 0, 1, 1), 1));
      }    
  
  
      if (this.child == 9) { // Simulation
  
        IMPACTS_displayDay = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "IMPACTS_displayDay", IMPACTS_displayDay, 0, STUDY.j_End - STUDY.j_Start, 1), 1));
  
        //allSolarImpacts.displayImage = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolarImpacts.displayImage", allSolarImpacts.displayImage, 0, 1, 1), 1));
        //allSolidImpacts.displayImage = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.displayImage", allSolidImpacts.displayImage, 0, 1, 1), 1));
  
        allSolarImpacts.sectionType = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolarImpacts.sectionType", allSolarImpacts.sectionType, 0, 3, 1), 1));      
        allSolidImpacts.sectionType = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.sectionType", allSolidImpacts.sectionType, 0, 3, 1), 1));
  
  
        allSolidImpacts.Grade = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Grade", allSolidImpacts.Grade, 0.0001, 64.0, -2);
        allSolidImpacts.Power = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.Power", allSolidImpacts.Power, 0.0001, 64.0, -2);      
        allSolidImpacts.rotation[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.rotation[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.rotation[allSolidImpacts.sectionType], -360, 360, -2);
        allSolidImpacts.elevation[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.elevation[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.elevation[allSolidImpacts.sectionType], -1000, 1000, -2);
        allSolidImpacts.positionStep = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.positionStep", allSolidImpacts.positionStep, 5, 80, -2);
  
        allSolidImpacts.U_scale[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.U_scale[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.U_scale[allSolidImpacts.sectionType], 0.125, 3200, -2);
        allSolidImpacts.V_scale[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.V_scale[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.V_scale[allSolidImpacts.sectionType], 0.125, 3200, -2);
        allSolidImpacts.U_offset[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.U_offset[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.U_offset[allSolidImpacts.sectionType], -10000, 10000, -2);
        allSolidImpacts.V_offset[allSolidImpacts.sectionType] = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.V_offset[" + nf(allSolidImpacts.sectionType, 0) + "]", allSolidImpacts.V_offset[allSolidImpacts.sectionType], -10000, 10000, -2);
  
  
        allSolidImpacts.WindSpeed = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.WindSpeed (m/s)", allSolidImpacts.WindSpeed, 1, 16, -2); 
        allSolidImpacts.WindDirection = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolidImpacts.WindDirection", allSolidImpacts.WindDirection, 0, 360, 15);
  
  
        allSolidImpacts.Process_subDivisions = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.Process_subDivisions", allSolidImpacts.Process_subDivisions, 0, 3, 1), 1));
  
        //allSolidImpacts.displayPoints = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.displayPoints", allSolidImpacts.displayPoints, 0, 1, 1), 1));
        //allSolidImpacts.displayLines = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allSolidImpacts.displayLines", allSolidImpacts.displayLines, 0, 1, 1), 1));
  
        //allWindFlows.displayAll = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "allWindFlows.displayAll", allWindFlows.displayAll, 0, 1, 1), 1));
      }
    } else if (this.parent == 2) { // Period & Scenarios
  
      if (this.child == 1) { // Time
  
        //TIME.date = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Solar date", TIME.date, 0, 364.5, 0.5);
        TIME.date = int(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Solar date", TIME.date, 0, 364, 1));
  
        TIME.day = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast day", TIME.day, 1, 31, 1), 1));
        TIME.month = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast month", TIME.month, 1, 12, 1), 1));
        TIME.year = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Forecast year", TIME.year, 1953, 2100, 1), 1));
  
        TIME.beginDay = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Plot start date", TIME.beginDay, 0, 364, 1), 1));
  
        STUDY.j_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Number of days to plot", STUDY.j_End, 1, 61, 1), 1));
  
        ENSEMBLE_OBSERVED_maxDays = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 1, "ENSEMBLE_OBSERVED_maxDays", ENSEMBLE_OBSERVED_maxDays, 0, 31, 1), 1));
            
      }
  
      if (this.child == 2) { // Ranges
        STUDY.i_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start hour", STUDY.i_Start, 0, 23, 1), 1));
        STUDY.i_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End hour", STUDY.i_End, 0, 23, 1), 1));
  
        STUDY.joinDays = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.joinDays", STUDY.joinDays, 1, 64, -2), 1));
        
  //??????
        SampleYear_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start year", SampleYear_Start, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
        SampleYear_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End year", SampleYear_End, CLIMATE_CWEEDS_start, CLIMATE_CLMREC_end, 1), 1));
  //??????
  
        SampleMember_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start member", SampleMember_Start, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));  
        SampleMember_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End member", SampleMember_End, ENSEMBLE_FORECAST_start, ENSEMBLE_FORECAST_end, 1), 1));
  
        SampleStation_Start = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Start station", SampleStation_Start, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));  
        SampleStation_End = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "End station", SampleStation_End, ENSEMBLE_OBSERVED_start, ENSEMBLE_OBSERVED_end, 1), 1));
  
  
      }
  
      if (this.child == 3) { // Filters
      
        STUDY.skyScenario = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Sky status", STUDY.skyScenario, 1, 4, 1), 1));
        STUDY.filter = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Hourly/daily filter", STUDY.filter, 0, 1, 1), 1));
      }
    } else if (this.parent == 3) { // Display Options
  
      if (this.child == 1) { // 2D-Layers
  
        FrameVariation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 1, 1, "Frame layout variation", FrameVariation, 0, 3, 1), 1));
  
        STUDY.plotSetup = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Diagram setup", STUDY.plotSetup, -2, 14, 1), 1));
  
        //STUDY.update = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Redraw scene", STUDY.update, 0, 1, 1), 1));  
  
        changeCurrentLayerTo(int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Layer", CurrentLayer_id, 0, (numberOfLayers - 1), 1), 1)));
        
        STUDY.V_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "V_scale[" + nf(CurrentLayer_id, 2) + "]", STUDY.V_scale, 0.0001, 10000, -pow(2.0, (1.0 / 2.0)));      
  
        //STUDY.displayRaws = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw data", STUDY.displayRaws, 0, 1, 1), 1));
        //STUDY.displaySorted = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw sorted", STUDY.displaySorted, 0, 1, 1), 1));
        //STUDY.displayNormals = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw statistics", STUDY.displayNormals, 0, 1, 1), 1));
        //STUDY.displayProbs = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Draw probabilities", STUDY.displayProbs, 0, 1, 1), 1));
        STUDY.sumInterval = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities interval", STUDY.sumInterval, 1, 24, 1), 1));
        STUDY.LevelPix = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Probabilities range", STUDY.LevelPix, 2, 32, -2), 1));
      }
  
      if (this.child == 2) { // 2D-Colors
  
        //COLOR_STYLE_Current = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1,0,0, "Hourly color scheme", COLOR_STYLE_Current, -1, (COLOR_STYLE_Number - 1), 1), 1));
  
        STUDY.ACTIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_CLR", STUDY.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.ACTIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_DIR", STUDY.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        STUDY.ACTIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.ACTIVE_pallet_MLT", STUDY.ACTIVE_pallet_MLT, 0.125, 8, -2);
  
        STUDY.PASSIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_CLR", STUDY.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.PASSIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_DIR", STUDY.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        STUDY.PASSIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.PASSIVE_pallet_MLT", STUDY.PASSIVE_pallet_MLT, 0.125, 8, -2);       
  
        STUDY.pallet_SORT_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_SORT_CLR", STUDY.pallet_SORT_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.pallet_SORT_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_SORT_DIR", STUDY.pallet_SORT_DIR, -2, 2, 2), 1));
        STUDY.pallet_SORT_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_SORT_MLT", STUDY.pallet_SORT_MLT, 0.125, 8, -2);
  
        STUDY.pallet_PROB_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_PROB_CLR", STUDY.pallet_PROB_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        STUDY.pallet_PROB_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_PROB_DIR", STUDY.pallet_PROB_DIR, -2, 2, 2), 1));
        STUDY.pallet_PROB_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "STUDY.pallet_PROB_MLT", STUDY.pallet_PROB_MLT, 0.125, 8, -2);
  
        STUDY.O_scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Windose opacity scale", STUDY.O_scale, 1, 100, -pow(2.0, (1.0 / 4.0)));
      }
  
      if (this.child == 3) { // 3D-Solar 
  
        allFaces.ACTIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_CLR", allFaces.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allFaces.ACTIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_DIR", allFaces.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        allFaces.ACTIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.ACTIVE_pallet_MLT", allFaces.ACTIVE_pallet_MLT, 0.125, 8, -2);
  
        allFaces.PASSIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_CLR", allFaces.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allFaces.PASSIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_DIR", allFaces.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        allFaces.PASSIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allFaces.PASSIVE_pallet_MLT", allFaces.PASSIVE_pallet_MLT, 0.125, 8, -2);
  
        Sky3D.ACTIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_CLR", Sky3D.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.ACTIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_DIR", Sky3D.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        Sky3D.ACTIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.ACTIVE_pallet_MLT", Sky3D.ACTIVE_pallet_MLT, 0.125, 8, -2);
  
        Sky3D.PASSIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_CLR", Sky3D.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sky3D.PASSIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_DIR", Sky3D.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        Sky3D.PASSIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sky3D.PASSIVE_pallet_MLT", Sky3D.PASSIVE_pallet_MLT, 0.125, 8, -2);
  
        Sun3D.ACTIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_CLR", Sun3D.ACTIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sun3D.ACTIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_DIR", Sun3D.ACTIVE_pallet_DIR, -2, 2, 1), 1));
        Sun3D.ACTIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.ACTIVE_pallet_MLT", Sun3D.ACTIVE_pallet_MLT, 0.125, 8, -2);
  
        Sun3D.PASSIVE_pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_CLR", Sun3D.PASSIVE_pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Sun3D.PASSIVE_pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_DIR", Sun3D.PASSIVE_pallet_DIR, -2, 2, 2), 1));
        Sun3D.PASSIVE_pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Sun3D.PASSIVE_pallet_MLT", Sun3D.PASSIVE_pallet_MLT, 0.125, 8, -2);
      }
  
  
  
  
      if (this.child == 4) { // 3D-Solid   
  
        allSolids.pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_CLR", allSolids.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allSolids.pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_DIR", allSolids.pallet_DIR, -2, 2, 2), 1));
        allSolids.pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allSolids.pallet_MLT", allSolids.pallet_MLT, 0.0001, 64, -2);      
  
        Land3D.pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_CLR", Land3D.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        Land3D.pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_DIR", Land3D.pallet_DIR, -2, 2, 2), 1));
        Land3D.pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "Land3D.pallet_MLT", Land3D.pallet_MLT, 0.001, 0.5, -2);   
  
        allWindFlows.pallet_CLR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_CLR", allWindFlows.pallet_CLR, -1, (COLOR_STYLE_Number - 1), 1), 1));
        allWindFlows.pallet_DIR = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_DIR", allWindFlows.pallet_DIR, -2, 2, 2), 1));
        allWindFlows.pallet_MLT = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 1, 0, "allWindFlows.pallet_MLT", allWindFlows.pallet_MLT, 0.01, 1.0, -2);
      }      
  
  
      if (this.child == 5) { // Selection
  
        //userSelections.Group_displayPivot = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Group_displayPivot", userSelections.Group_displayPivot, 0, 1, 1), 1));
        //userSelections.displayReferencePivot = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.displayReferencePivot", userSelections.displayReferencePivot, 0, 1, 1), 1));
        //userSelections.Group_displayBox = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Group_displayBox", userSelections.Group_displayBox, 0, 1, 1), 1));
        //userSelections.Group_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Group_displayEdges", userSelections.Group_displayEdges, 0, 1, 1), 1));
  
        //userSelections.Face_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Face_displayEdges", userSelections.Face_displayEdges, 0, 1, 1), 1));
        //userSelections.Face_displayVertexCount = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Face_displayVertexCount", userSelections.Face_displayVertexCount, 0, 1, 1), 1));
        //userSelections.Curve_displayVertexCount = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Curve_displayVertexCount", userSelections.Curve_displayVertexCount, 0, 1, 1), 1));
        //userSelections.Vertex_displayVertices = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Vertex_displayVertices", userSelections.Vertex_displayVertices, 0, 1, 1), 1));
        //userSelections.Curve_displayVertices = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Curve_displayVertices", userSelections.Curve_displayVertices, 0, 1, 1), 1));
  
        //userSelections.Model2D_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Model2D_displayEdges", userSelections.Model2D_displayEdges, 0, 1, 1), 1));
        //userSelections.Model1D_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Model1D_displayEdges", userSelections.Model1D_displayEdges, 0, 1, 1), 1));
  
        //userSelections.Solid_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Solid_displayEdges", userSelections.Solid_displayEdges, 0, 1, 1), 1));
  
        //userSelections.Section_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Section_displayEdges", userSelections.Section_displayEdges, 0, 1, 1), 1));
  
        //userSelections.Camera_displayEdges = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.Camera_displayEdges", userSelections.Camera_displayEdges, 0, 1, 1), 1));
  
        //userSelections.LandPoint_displayPoints = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "userSelections.LandPoint_displayPoints", userSelections.LandPoint_displayPoints, 0, 1, 1), 1));
      }
    } else if (this.parent == 4) { // Post-Processing
  
      if (this.child == 1) { // Interpolation
  
        Interpolation_Weight = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Interpolation_Weight", Interpolation_Weight, 0, 5, 0.5);
        CLIMATIC_SolarForecast = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based solar forecast", CLIMATIC_SolarForecast, 0, 1, 1), 1));
        CLIMATIC_WeatherForecast = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Climate-based temperature forecast", CLIMATIC_WeatherForecast, 0, 2, 1), 1));
      } 
      if (this.child == 2) { // Developed
        Develop_Option = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_Option", Develop_Option, 0, 11, 1), 1));
        Develop_DayHour = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Develop_DayHour", Develop_DayHour, 0, 3, 1), 1));
  
        STUDY.TrendJoinHours = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Trend period hours", STUDY.TrendJoinHours, 1, 24 * 16, 1), 1));
        STUDY.TrendJoinType = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Weighted/equal trend", STUDY.TrendJoinType, -1, 1, 2), 1));
  
        Develop_AngleInclination = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Inclination angle", Develop_AngleInclination, 0, 90, 5), 1));
        Develop_AngleOrientation = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Orientation angle", Develop_AngleOrientation, 0, 360, 15), 1));
      }
      if (this.child == 3) { // Impacts
        CurrentDataSource = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impacts Source", CurrentDataSource, 0, 3, 1), 1));
        STUDY.ImpactLayer = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Impact Min/50%/Max", STUDY.ImpactLayer, 0, 8, 1), 1));
        //STUDY.Impacts_update = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "update impacts", STUDY.Impacts_update, 0, 1, 1), 1));
      }
    } else if (this.parent == 5) { // Export Products
  
      if (this.child == 1) { // Data
  
        //STUDY.export_info_node = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII data", STUDY.export_info_node, 0, 1, 1), 1));
        //STUDY.export_info_norm = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII statistics", STUDY.export_info_norm, 0, 1, 1), 1));
        //STUDY.export_info_prob = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 1, 0, 0, "Export ASCII probabilities", STUDY.export_info_prob, 0, 1, 1), 1));
  
  
        User3D.export_Scale = SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_Scale", User3D.export_Scale, .001, 1000, -0.1);
        User3D.export_FlipZYaxis = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_FlipZYaxis", User3D.export_FlipZYaxis, 0, 1, 1), 1));
  
        User3D.export_PrecisionVertex = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_PrecisionVertex", User3D.export_PrecisionVertex, 0, 6, 1), 1));
        User3D.export_PrecisionVtexture = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_PrecisionVtexture", User3D.export_PrecisionVtexture, 0, 6, 1), 1));
        User3D.export_PolyToPoly = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_PolyToPoly", User3D.export_PolyToPoly, 0, 1, 1), 1));
  
        //User3D.export_MaterialLibrary = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_MaterialLibrary", User3D.export_MaterialLibrary, 0, 1, 1), 1));
        //User3D.export_BackSides = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_BackSides", User3D.export_BackSides, 0, 1, 1), 1));
        //User3D.export_PalletResolution = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "User3D.export_PalletResolution", User3D.export_PalletResolution, 32, 2048, -2), 1));
  
  
        //displayOutput_inExplorer = boolean(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "displayOutput_inExplorer", displayOutput_inExplorer, 0, 1, 1), 1));
      }  
  
      if (this.child == 2) { // Media
  
        allSolidImpacts.record_IMG = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in JPG", allSolidImpacts.record_IMG, 0, 1, 1), 1));
        allSolidImpacts.record_PDF = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record SolidImpact in PDF", allSolidImpacts.record_PDF, 0, 1, 1), 1));
  
        allSolarImpacts.record_IMG = int(funcs.roundTo(SOLARCHVISION_Spinner(STUDY.X_control, STUDY.Y_control, 0, 0, 0, "Record Solar Analysis in JPG", allSolarImpacts.record_IMG, 0, 1, 1), 1));
      }
  
    }    
  
    if (this.include) {
      if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, this.cX, this.cY, this.cX + this.dX, this.cY + this.dY) == 1) {  
        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      }
    }
  }
  
}

solarchvision_ROLLOUT ROLLOUT = new solarchvision_ROLLOUT();




class solarchvision_MESSAGE {
  
  private final static String CLASS_STAMP = "MESSAGE";
  
  int cX = 0;
  int cY = int(1 * SOLARCHVISION_pixel_H - 0.75 * MessageSize + 0.5 * (SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + SOLARCHVISION_pixel_C + SOLARCHVISION_pixel_D));
  int dX = 2 * SOLARCHVISION_pixel_W + ROLLOUT.dX;
  int dY = int(1.5 * MessageSize);
}

solarchvision_MESSAGE MESSAGE = new solarchvision_MESSAGE();








int WMS_type = DataType.FORECAST_GDPS; // <<<<<<<<<<<<<

// note we used .... float r = FLOAT_r_Earth + 10000; for clouds

final int TROPO_deltaTime = 1; 
final int TROPO_timeSteps = 24;







// Tropo3D.draw --- we only use the first image!

// should define subroutines to perfome this not inside draw! if ((STUDY.PlotImpacts == 6) || (STUDY.PlotImpacts == 7)) {


// bug using small STUDY.LevelPix 


// pick select LandPoint is not written. 


// diffuse model used in render is simple see note "adding approximate diffuse radiation effect anyway!" 


// snap for Curve objects is not developed yet.

// don't know if multiple allModel2Ds.Images[n].get(Image_X, Image_Y) in allModel2Ds selection can produce performance problems? 


// note: code for SOLARCHVISION_intersect_allSolids might run a bit slow. But it is OK for now.


// should see where else could add snap3D :)


// drop functions only works for allModel2Ds objects and not at Group level

// could add join/explode groups ?


// export and import of curves
// converting curves to faces e.g. Surface, Extrude, Connect

// Modify Normal at Curve level is not complete...

// allModel3Ds.autoNormalCurve_Selection

// writing export to rad completed for meshes and land - not allModel1Ds and 2Ds yet!

// colud record Climate data flags later.

// exporting shaded land is not written. 

// void userSelections.rotate_selectedGroups 
// serach for userSelections.rotate_Selection ( need to make them all correct for local pivots!
// local pivot


// solid rotations inside groups should be translated to locals to avoid problems!

// some rotations are not in degrees e.g. solids, allModel1Ds??, what else?


import processing.pdf.*;

void launch (String s) {
  open(s);
}
void launch (String[] s) {
  open(s);
}















float[][]   VertexSolar_XYZ; 
float[][][] VertexSolar_amounts; 

boolean VertexSolar_rebuild_array = true;
boolean GlobalSolar_rebuild_array = true;





float[][][][] GlobalSolar;








float pre_TIME_Date;
int pre_TIME_Hour;
int pre_TIME_Day;
int pre_TIME_Month;
int pre_TIME_Year;

int pre_SampleYear_Start; 
int pre_SampleYear_End; 
int pre_SampleMember_Start;
int pre_SampleMember_End;
int pre_SampleStation_Start; 
int pre_SampleStation_End;

int pre_STUDY_joinDays;
int pre_STUDY_i_Start;
int pre_STUDY_i_End;
int pre_STUDY_j_End;
int pre_STUDY_Setup;

int pre_IMPACTS_displayDay;
int pre_CurrentDataSource;

int pre_CLIMATIC_SolarForecast;
int pre_CLIMATIC_WeatherForecast;

boolean pre_CLIMATE_TMYEPW_load;
boolean pre_CLIMATE_CWEEDS_load;
boolean pre_CLIMATE_CLMREC_load;
boolean pre_ENSEMBLE_FORECAST_load;
boolean pre_ENSEMBLE_OBSERVED_load;    

boolean pre_Land3D_loadMesh;
boolean pre_Land3D_loadTextures;

float pre_LocationLAT;
float pre_LocationLON;

boolean pre_WORLD_autoView;

boolean pre_Selection_Model1D_displayEdges;
boolean pre_Selection_Model2D_displayEdges;

boolean pre_Selection_Solid_displayEdges;
boolean pre_Selection_Section_displayEdges;
boolean pre_Selection_Camera_displayEdges;

boolean pre_Selection_LandPoint_displayPoints;



float pre_Selection_softPower;
float pre_Selection_softRadius;

float pre_Selection_posValue;
float pre_Selection_rotValue;
float pre_Selection_scaleValue;

int pre_Selection_alignX;
int pre_Selection_alignY;
int pre_Selection_alignZ;

boolean pre_Selection_displayReferencePivot;

boolean pre_Selection_Group_displayPivot;
boolean pre_Selection_Group_displayEdges;
boolean pre_Selection_Group_displayBox;      

boolean pre_Selection_Face_displayEdges;
boolean pre_Selection_Face_displayVertexCount;
boolean pre_Selection_Curve_displayVertexCount;
boolean pre_Selection_Vertex_displayVertices;
boolean pre_Selection_Curve_displayVertices;

int pre_Load_DefaultModels;


int pre_WIN3D_currentCamera;

int pre_WIN3D_FacesShade;

int pre_allModel3Ds_Tessellation;

boolean pre_allPoints_displayAll;
boolean pre_allFaces_displayEdges;
boolean pre_allFaces_displayNormals;





int pre_Develop_Option;

int pre_STUDY_ImpactLayer;
int pre_STUDY_CurrentLayer_id;

int pre_STUDY_SkyScenario;
int pre_STUDY_PlotImpacts;

int pre_allSolids_pallet_CLR;
int pre_allSolids_pallet_DIR; 
float pre_allSolids_pallet_MLT; 





float pre_allSolidImpacts_Grade;
float pre_allSolidImpacts_Power;
float[] pre_allSolidImpacts_Rotation = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_Elevation = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_U_scale = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_V_scale = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_sU_offset = {
  0, 0, 0, 0
};
float[] pre_allSolidImpacts_sV_offset = {
  0, 0, 0, 0
};

float pre_allSolidImpacts_Wspd; 
float pre_allSolidImpacts_Wdir;

boolean pre_allSolidImpacts_displayPoints;
boolean pre_allSolidImpacts_displayLines;

int pre_allSolidImpacts_Process_subDivisions;

boolean pre_WindFlow_display;

float pre_USER_create_powAll;



float Interpolation_Weight = 0.5;// 0 = linear distance interpolation, 1 = square distance interpolation, 5 = nearest

final int Impact_ACTIVE = 0; // internal
final int Impact_PASSIVE = 1; // internal
final int numberOfImpactVariations = 2; // internal

int Impact_TYPE;

float CubePower = 16; //8; 
float StarPower = 0.25; 

final double DOUBLE_r_Earth = 6367470.0; //6373000.0;
final float FLOAT_r_Earth = (float) DOUBLE_r_Earth;

float CrustDepth = 100; // 100 = 100m .The actual crust ranges from 5–70 km

float EyeLevel = 1.5; // 1.5 abouve ground - applied for setting cameras - intreanl!

float GlobalAlbedo = 0; // 0-100


float BIOSPHERE_drawResolution = 5.0; //2.5; // 5: 5 degrees


float Planetary_Magnification = 4.0; // <<<<<<<<<<


int current_Material = 7;
int current_Tessellation = 0;
int current_Layer = 0;
int current_Visibility = 1;
int current_Weight = 0; 
int current_Closed = 0;

int current_PivotType = 0; // for allGroups

int current_ObjectCategory = ObjectCategory.GROUP; 
















int CreateObject = CREATE.Nothing;


boolean FRAME_record_AUTO = false;
boolean FRAME_record_IMG = false;
boolean FRAME_click_IMG = false;
boolean FRAME_drag_IMG = false;








//-------------------------------





int CLIMATIC_SolarForecast = 0; //                                   Used for solar radiation only
int CLIMATIC_WeatherForecast = 0; // 0:linear 1:average 2:sky-based. Used for some parameters namely: air temperature, humidity

int SOLARCHVISION_automated = 0; //0: User interface, 1: Automatic


 









int SavedScreenShots = 0;

String createStamp (int increment, String CLASS_STAMP) {

  SavedScreenShots += increment; 


  String txt = "";
  
  if (CLASS_STAMP == "WIN3D") {
    txt += "CAM" + nf(WIN3D.currentCamera, 2) + "_";
  }
  else {
    txt += "IMG" + nf(SavedScreenShots, 4) + "_";
  }
  
  txt += STATION.getCity() + "_";

  if (IMPACTS_displayDay != 0) {
    txt += TIME.getMM((IMPACTS_displayDay - 1) * STUDY.perDays + 286 + TIME.beginDay); 
  }
  else {
    txt += TIME.getMM( STUDY.j_Start    * STUDY.perDays + 286 + TIME.beginDay) + "-" + 
           TIME.getMM((STUDY.j_End - 1) * STUDY.perDays + 286 + TIME.beginDay);
  }
  
  return txt;  
}



void SOLARCHVISION_RecordFrame () {

  saveFrame(Folder_ScreenShots + "/" + createStamp(1, "Screen") + ".jpg");
}



String MAKE_Filename (String beginName) {

  String My_Filenames = Folder_ScreenShots + "/" + beginName;  

  return My_Filenames;
}



String MAKE_MainName () {

  String s = "";

  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) s = nf(TIME.year, 2) + nf(TIME.month, 2) + nf(TIME.day, 2) + "_" + nf(STUDY.j_End, 0) + "dayFORECAST_";

  return s;
}

String getFilename_SolidImpact () {

  return Folder_Graphics + "/" + nf(TIME.year, 2) + "-" + nf(TIME.month, 2) + "-" + nf(TIME.day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/Solid" + nf(allSolidImpacts.sectionType, 0) + "h" + nf(int(funcs.roundTo(allSolidImpacts.elevation[allSolidImpacts.sectionType], 1)), 4) + "r" + nf(int(funcs.roundTo(allSolidImpacts.rotation[allSolidImpacts.sectionType], 1)), 3) + "p" + nf(allSolidImpacts.Power, 2, 2).replace(".", "_") + "m" + nf(allSolidImpacts.Grade, 2, 2).replace(".", "_");
}

String getFilename_SolarImpact () {

  return Folder_Graphics + "/" + nf(TIME.year, 2) + "-" + nf(TIME.month, 2) + "-" + nf(TIME.day, 2) + "/" + databaseString[CurrentDataSource] + "/Impacts/Solar" + nf(allSolarImpacts.sectionType, 0) + "h" + nf(int(funcs.roundTo(allSolarImpacts.elevation, 1)), 4) + "r" + nf(int(funcs.roundTo(allSolarImpacts.rotation, 1)), 3);
}






float HeightAboveGround = 0; //2.5; // <<<<<<<<<



float LocationLAT = 0.0;
float LocationLON = 0.0;
float LocationELE = 0.0;

float LocationLAT_step = 0.1;
float LocationLON_step = 0.1;
float LocationELE_step = 1.0;

int save_frame_number = 0;





int COLOR_STYLE_Current = 0;
int COLOR_STYLE_Number = 20; //6;



final int dataID_ENSEMBLE_OBSERVED = 0;
final int dataID_ENSEMBLE_FORECAST = 1; // also used for Aerial
final int dataID_CLIMATE_CWEEDS = 2;
final int dataID_CLIMATE_CLMREC = 3;
final int dataID_CLIMATE_TMYEPW = 4;

int CurrentDataSource = dataID_CLIMATE_TMYEPW; 

final String[] databaseString = {
  "SWOB", "NAEFS", "CWEEDS", "CLMREC", "TMY"
};







int DrawnFrame = 0;

int SOLARCHVISION_X_clicked = -1;
int SOLARCHVISION_Y_clicked = -1;

int SOLARCHVISION_X_click1 = -1;
int SOLARCHVISION_Y_click1 = -1;
int SOLARCHVISION_X_click2 = -1;
int SOLARCHVISION_Y_click2 = -1;



























int Camera_Variation = 0; // 1;





















int Materials_Number = 11; //256; // 0, 1, 2, ... , 10

int Materials_Selection = 1; //2; // yellow

float[][][] Materials_DirectArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DirectArea_Flags = new int [24][365];

float[][][] Materials_DiffuseArea_Data = new float [Materials_Number][24][365]; 
int[][] Materials_DiffuseArea_Flags = new int [24][365];

int[][] Materials_Color = new int [Materials_Number][4]; // ARGB                            
{
  {
    int[] COL = {
      255, 255, 127, 0
    };    
    Materials_Color[0] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 0
    };    
    Materials_Color[1] = COL;
  }  
  {
    int[] COL = {
      255, 255, 255, 0
    };    
    Materials_Color[2] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 0
    };    
    Materials_Color[3] = COL;
  }
  {
    int[] COL = {
      255, 0, 255, 255
    };    
    Materials_Color[4] = COL;
  }
  {
    int[] COL = {
      255, 0, 0, 255
    };    
    Materials_Color[5] = COL;
  }
  {
    int[] COL = {
      255, 255, 0, 255
    };    
    Materials_Color[6] = COL;
  }
  {
    int[] COL = {
      255, 255, 255, 255
    };    
    Materials_Color[7] = COL;
  }
  {
    //int[] COL = {255, 63, 63, 63};    
    int[] COL = {
      63, 63, 63, 63
    };
    Materials_Color[8] = COL;
  }
  {
    //int[] COL = {255, 127, 127, 127};    
    int[] COL = {
      127, 127, 127, 127
    };
    Materials_Color[9] = COL;
  }
  {
    //int[] COL = {255, 191, 191, 191};    
    int[] COL = {
      191, 191, 191, 191
    };
    Materials_Color[10] = COL;
  }

  {
    for (int mt = 11; mt < Materials_Number; mt++) {
      int[] COL = {
        255, int(random(256)), int(random(256)), int(random(256))
      };
      Materials_Color[mt] = COL;
    }
  }
}

void SOLARCHVISION_empty_Materials_DirectArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 365; j++) {
        Materials_DirectArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DirectArea_Flags[i][j] = -1;
      }
    }
  }
}

void SOLARCHVISION_empty_Materials_DiffuseArea () {

  for (int mt = 0; mt < Materials_Number; mt++) {
    for (int i = 0; i < 24; i++) {
      for (int j = 0; j < 365; j++) {
        Materials_DiffuseArea_Data[mt][i][j] = FLOAT_undefined;
        Materials_DiffuseArea_Flags[i][j] = -1;
      }
    }
  }
}


















class solarchvision_Faces {
  
  private final static String CLASS_STAMP = "Faces";
  
  boolean displayAll = true; 
  boolean displayNormals = false;
  boolean displayEdges = true;
  
  int displayTessellation = 2;  
  
  int ACTIVE_pallet_CLR = 19; //15; //14;
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1; //2; 
  
  int PASSIVE_pallet_CLR = 1; 
  int PASSIVE_pallet_DIR = 1;  
  float PASSIVE_pallet_MLT = 8; //1;   
  
  
  int[][] nodes = new int[0][0];
  
  int[][] options = new int[0][6]; // 0:material, 1:tessellation, 2:layer, 3:visibility, 4:weight, 5:close
  
  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }  
  
  int getVisibility (int n) {
    return this.options[n][3];
  }   
  
  int getWeight (int n) {
    return this.options[n][4];
  }    
  
  int getClose (int n) {
    return this.options[n][5];
  }   
  
  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }  
  
  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }   
  
  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }    
  
  void setClose (int n, int close) {
    this.options[n][5] = close;
  }    
 


  void draw (int target_window) {
   
    if (this.displayAll) {
      
      if (target_window == TypeWindow.WIN3D) {
    
        if (this.displayNormals) {
    
          for (int f = 0; f < this.nodes.length; f++) {
    
            int vsb = this.getVisibility(f);
    
            if (vsb > 0) {
    
              float[][] base_Vertices = new float [this.nodes[f].length][3];
              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];
                base_Vertices[j][0] = allPoints.getX(vNo);
                base_Vertices[j][1] = allPoints.getY(vNo);
                base_Vertices[j][2] = allPoints.getZ(vNo);
              }
    
              float G_x0 = 0;
              float G_y0 = 0;
              float G_z0 = 0;
    
              float G_x1 = 0;
              float G_y1 = 0;
              float G_z1 = 0;
    
              float n = float(base_Vertices.length);
    
              for (int s = 0; s < base_Vertices.length; s++) {
    
                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
    
                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
                PVector UV = U.cross(V);
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);
    
                float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
                float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
                float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;
    
                float x1 = (base_Vertices[s][0] + W[0]) * OBJECTS_scale * WIN3D.scale;
                float y1 = (base_Vertices[s][1] + W[1]) * OBJECTS_scale * WIN3D.scale;
                float z1 = (base_Vertices[s][2] + W[2]) * OBJECTS_scale * WIN3D.scale;
    
                G_x0 += x0 / n;
                G_y0 += y0 / n;
                G_z0 += z0 / n;
    
                G_x1 += x1 / n;
                G_y1 += y1 / n;
                G_z1 += z1 / n;
              }
    
              WIN3D.graphics.strokeWeight(3);
              WIN3D.graphics.stroke(127, 255, 127);
              WIN3D.graphics.line(G_x0, -G_y0, G_z0, G_x1, -G_y1, G_z1);        
    
              WIN3D.graphics.strokeWeight(1);
              WIN3D.graphics.stroke(0, 127, 0);
    
              for (int s = 0; s < base_Vertices.length; s++) {
    
                float x0 = base_Vertices[s][0] * OBJECTS_scale * WIN3D.scale;
                float y0 = base_Vertices[s][1] * OBJECTS_scale * WIN3D.scale;
                float z0 = base_Vertices[s][2] * OBJECTS_scale * WIN3D.scale;
    
                WIN3D.graphics.line(x0, -y0, z0, G_x1, -G_y1, G_z1);
              }
            }
          }
        }
    
        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0, 0, 0);
        if (this.displayEdges == false) WIN3D.graphics.noStroke();
    
        int PAL_type = SHADE.get_PAL_type(); 
        int PAL_direction = SHADE.get_PAL_direction();
        float PAL_multiplier = SHADE.get_PAL_multiplier(); 
    
        for (int f = 0; f < this.nodes.length; f++) {
    
          int vsb = this.getVisibility(f);
    
          if (vsb > 0) {        
    
            if (WIN3D.FacesShade == SHADE.Surface_Base) {
    
              WIN3D.graphics.fill(255, 255, 255);
    
              WIN3D.graphics.beginShape();
    
              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];
    
                WIN3D.graphics.vertex(allPoints.getX(vNo) * OBJECTS_scale * WIN3D.scale, -(allPoints.getY(vNo) * OBJECTS_scale * WIN3D.scale), allPoints.getZ(vNo) * OBJECTS_scale * WIN3D.scale);
              }    
    
              WIN3D.graphics.endShape(CLOSE);
            } else {
    
              int mt = this.getMaterial(f);
    
              int Tessellation = this.getTessellation(f);
    
              int TotalSubNo = 1;  
              if (this.getMaterial(f) == 0) {
                Tessellation += this.displayTessellation;
              }
              if (Tessellation > 0) TotalSubNo = this.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
    
              float[][] base_Vertices = new float [this.nodes[f].length][3];
              for (int j = 0; j < this.nodes[f].length; j++) {
                int vNo = this.nodes[f][j];
                base_Vertices[j][0] = allPoints.getX(vNo);
                base_Vertices[j][1] = allPoints.getY(vNo);
                base_Vertices[j][2] = allPoints.getZ(vNo);
              }
    
              for (int n = 0; n < TotalSubNo; n++) {
    
                float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
    
                WIN3D.graphics.beginShape();
    
                for (int s = 0; s < subFace.length; s++) {
    
                  if (WIN3D.FacesShade != SHADE.Surface_Wire) {
    
                    float[] COL = {
                      255, 255, 255, 255
                    };
    
                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;
                      
                      COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                    }        
              
                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
    
                      COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }                   
    
                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
    
                      COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }
    
                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
    
                      COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }
    
                    if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                      COL = SHADE.vertexRender_Surface_Materials(mt);
                    }              
    
                    if (WIN3D.FacesShade == SHADE.Surface_White) {
                      COL = SHADE.vertexRender_Surface_White(255);
                    }
               
                    WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                  } else {
                    WIN3D.graphics.noFill();
                  }
    
                  WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -(subFace[s][1] * OBJECTS_scale * WIN3D.scale), subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                }
    
                WIN3D.graphics.endShape(CLOSE);
              }
            }
          }
        }
      }      
      
      
      if (target_window == TypeWindow.OBJ) {
    
        int Create_Face_Texture = 0;
    
        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solid) || (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {
          Create_Face_Texture = 1;
        }
    
        if (Create_Face_Texture == 0) {
    
          if (User3D.export_MaterialLibrary) {
    
            int[] Materials_Used = new int [Materials_Number];
    
            for (int i = 0; i < Materials_Used.length; i++) {
              Materials_Used[i] = 0;
            }
    
            for (int f = 0; f < this.nodes.length; f++) {
    
              int mt = this.getMaterial(f);
    
              Materials_Used[mt] += 1;
            }    
    
            for (int mt = 0; mt < Materials_Number; mt++) {
    
              if (Materials_Used[mt] != 0) {
    
                float a = Materials_Color[mt][0] / 255.0; 
                float r = Materials_Color[mt][1] / 255.0; 
                float g = Materials_Color[mt][2] / 255.0; 
                float b = Materials_Color[mt][3] / 255.0; 
    
                mtlOutput.println("newmtl SurfaceMaterial" + nf(mt, 0));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // ambient
                mtlOutput.println("\tKd " + nf(r, 0, 3) + " " + nf(g, 0, 3) + " " + nf(b, 0, 3)); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
                mtlOutput.println("\td " + nf(a, 0, 3)); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr " + nf(a, 0, 3)); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
              }
            }
          }
    
    
          for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
    
            if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {
    
              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {
    
                num_vertices_added = 0;
    
                for (int _turn = 1; _turn < 4; _turn++) {
    
                  if (_turn == 3) {
                    if (User3D.export_PolyToPoly == 1) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                    }
                  }  
    
                  int prev_mt = -1;
    
                  for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
    
                    if (_turn == 3) {
                      if (User3D.export_MaterialLibrary) {
                        int mt = this.getMaterial(f);
                        if (prev_mt != mt) {
                          objOutput.println("usemtl SurfaceMaterial" + nf(mt, 0));
                          prev_mt = mt;
                        }
                      }
                    }                  
    
                    int Tessellation = this.getTessellation(f);
    
                    int TotalSubNo = 1;  
                    if (this.getMaterial(f) == 0) {
                      Tessellation += this.displayTessellation;
                    }
    
                    if (Tessellation > 0) TotalSubNo = this.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
    
                    float[][] base_Vertices = new float [this.nodes[f].length][3];
                    for (int j = 0; j < this.nodes[f].length; j++) {
                      int vNo = this.nodes[f][j];
                      base_Vertices[j][0] = allPoints.getX(vNo);
                      base_Vertices[j][1] = allPoints.getY(vNo);
                      base_Vertices[j][2] = allPoints.getZ(vNo);
                    }
    
                    for (int n = 0; n < TotalSubNo; n++) {
    
                      float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
    
                      for (int s = 0; s < subFace.length; s++) {
    
                        if (_turn == 1) {
                          SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                        }
    
                        if (_turn == 2) {
    
                          float t = PI / float(subFace.length);
    
                          float u = 0.5 * cos((2 * s + 1) * t) / cos(t) + 0.5;
                          float v = 0.5 * sin((2 * s + 1) * t) / cos(t) + 0.5;
    
                          SOLARCHVISION_OBJprintVtexture(u, v, 0);
                        }
                      }
    
    
                      if (_turn == 3) {
    
                        num_vertices_added += subFace.length;
    
                        if (User3D.export_PolyToPoly == 0) {
                          obj_lastGroupNumber += 1;
                          objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                        }                    
    
                        obj_lastFaceNumber += 1;
    
                        objOutput.print("f ");
                        if (back_or_front == 1) {
                          for (int s = 0; s < subFace.length; s++) {
                            String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                            String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                            objOutput.print(n_txt + "/" + m_txt);
                            if (s < subFace.length - 1) {
                              objOutput.print(" ");
                            }
                          }
                        } else {
                          for (int s = subFace.length - 1; s >= 0; s--) {
                            String n_txt = nf(obj_lastVertexNumber + num_vertices_added - s, 0);
                            String m_txt = nf(obj_lastVtextureNumber + num_vertices_added - s, 0);  
                            objOutput.print(n_txt + "/" + m_txt);
                            if (s > 0) {
                              objOutput.print(" ");
                            }
                          }
                        }
                        objOutput.println("");
                      }
                    }
                  }
                }
    
                obj_lastVertexNumber += num_vertices_added;
                obj_lastVtextureNumber += num_vertices_added;
              }
            }
          }
        } else {
    
          int PAL_type = SHADE.get_PAL_type(); 
          int PAL_direction = SHADE.get_PAL_direction();
          float PAL_multiplier = SHADE.get_PAL_multiplier(); 
    
          String the_filename = "";
          String TEXTURE_path = "";
    
          if (User3D.export_MaterialLibrary) {
    
            the_filename = "shadePallet.bmp";
    
            TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
    
            println("Saving texture:", TEXTURE_path);
    
            int RES1 = User3D.export_PalletResolution; 
            int RES2 = User3D.export_PalletResolution / 16;      
    
            PImage pallet_Texture = createImage(RES1, RES2, ARGB);       
    
    
            pallet_Texture.loadPixels();
    
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
    
              float _val = (Image_X / (0.5 * RES1)) - 1; 
    
              float _u = 0.5 + _val;
    
              if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
              }            
    
              float[] COL = PAINT.getColorStyle(PAL_type, _u);  
    
              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }
    
            pallet_Texture.updatePixels();   
    
            pallet_Texture.save(TEXTURE_path);
    
    
    
            mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
            //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
         
          }
    
    
          for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
    
            if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {
    
              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {
    
                num_vertices_added = 0;
    
                for (int _turn = 1; _turn < 4; _turn++) {
    
                  int CurrentFaceTextureNumber = -1;
    
                  if (_turn == 3) {
    
                    if (User3D.export_PolyToPoly == 1) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0));
                    }
    
                    if (User3D.export_MaterialLibrary) {
    
                      objOutput.println("usemtl " +  the_filename.replace('.', '_'));
    
                    }
                  }  
    
                  for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
    
                    int Tessellation = this.getTessellation(f);
    
                    int TotalSubNo = 1;  
                    if (this.getMaterial(f) == 0) {
                      Tessellation += this.displayTessellation;
                    }
    
                    if (Tessellation > 0) TotalSubNo = this.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
    
                    float x1 = 0;
                    float y1 = 0;
                    float z1 = 0;
    
                    float x2 = 0;
                    float y2 = 0;
                    float z2 = 0;
    
                    float x3 = 0;
                    float y3 = 0;
                    float z3 = 0;
    
                    float x4 = 0;
                    float y4 = 0;
                    float z4 = 0;
    
                    float[][] base_Vertices = new float [this.nodes[f].length][3];
                    for (int j = 0; j < this.nodes[f].length; j++) {
                      int vNo = this.nodes[f][j];
                      base_Vertices[j][0] = allPoints.getX(vNo);
                      base_Vertices[j][1] = allPoints.getY(vNo);
                      base_Vertices[j][2] = allPoints.getZ(vNo);
                    }
    
                    for (int n = 0; n < TotalSubNo; n++) {
    
                      float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
    
                      CurrentFaceTextureNumber += 1;
    
                      if (_turn == 1) {   
    
                        if (User3D.export_MaterialLibrary) {
    
                          for (int s = 0; s < subFace.length; s++) {
    
                            float[] COL = {
                              255, 255, 255, 255
                            };
    
                            if (s == 0) {
                              x1 = subFace[s][0];
                              y1 = subFace[s][1];
                              z1 = subFace[s][2];
                            }
                            if (s == 1) {
                              x2 = subFace[s][0];
                              y2 = subFace[s][1];
                              z2 = subFace[s][2];
                            }            
                            if (s == 2) { 
                              x3 = subFace[s][0];
                              y3 = subFace[s][1];
                              z3 = subFace[s][2];
                            }          
                            if (s == 3) {
                              x4 = subFace[s][0];
                              y4 = subFace[s][1];
                              z4 = subFace[s][2];
                            }
                          }
    
                        }
    
                        SOLARCHVISION_OBJprintVertex(x1, y1, z1);
                        SOLARCHVISION_OBJprintVertex(x2, y2, z2);
                        SOLARCHVISION_OBJprintVertex(x3, y3, z3);
                        SOLARCHVISION_OBJprintVertex(x4, y4, z4);
                      }
    
                      if (_turn == 2) {
    
                        for (int s = 0; s < subFace.length; s++) {
    
                          float _u = 0;
    
                          if (WIN3D.FacesShade == SHADE.Global_Solar) {
                            int s_next = (s + 1) % subFace.length;
                            int s_prev = (s + subFace.length - 1) % subFace.length;
    
                            if (back_or_front == 0) {
                              int s_temp = s_next;
                              s_next = s_prev;
                              s_prev = s_temp;
                            }
    
                            _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                          }
            
                          if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
                            
                            _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }                            
    
                          if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
    
                            _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }                  
    
                          if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
    
                            _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                          }
    
    
                          float u0 = 0.5 * (_u + 0.5);
    
                          if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                            if (Impact_TYPE == Impact_ACTIVE) {
                              u0 = _u;
                            }
                          }
    
                          if (u0 > 1) u0 = 1;
                          if (u0 < 0) u0 = 0;
                          
                          SOLARCHVISION_OBJprintVtexture(u0, 0.5, 0);
                        }
    
                        
                      }
    
                      if (_turn == 3) {
    
                        num_vertices_added += 4;
    
                        if (User3D.export_PolyToPoly == 0) {
                          obj_lastGroupNumber += 1;
                          objOutput.println("g Object3D_" + nf(OBJ_NUM, 0) + "_side" + nf(back_or_front, 0) + "_face" + nf(f, 0) + "_sub" + nf(n, 0));
                        }
    
                        String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
                        String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                        String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                        String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
    
                        String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
                        String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
                        String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
                        String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
    
                        obj_lastFaceNumber += 1;
                        if (back_or_front == 1) {
                          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                        } else {
                          objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                        }
                      }
                    }
                  }
                }
    
                obj_lastVertexNumber += num_vertices_added;
                obj_lastVtextureNumber += num_vertices_added;
              }
            }
          }
        }
      }      
      
      if (target_window == TypeWindow.HTML) {
    
        int Create_Face_Texture = 0;
    
        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solid) || (WIN3D.FacesShade == SHADE.Vertex_Elevation)) {
          Create_Face_Texture = 1;
        }    
        
        int PAL_type = SHADE.get_PAL_type(); 
        int PAL_direction = SHADE.get_PAL_direction();
        float PAL_multiplier = SHADE.get_PAL_multiplier(); 
    
        String the_filename = "";
        String TEXTURE_path = "";        
    
        if (User3D.export_MaterialLibrary) {
          
          if (Create_Face_Texture == 0) {
            
            int[] Materials_Used = new int [Materials_Number];
    
            for (int i = 0; i < Materials_Used.length; i++) {
              Materials_Used[i] = 0;
            }
    
            for (int f = 0; f < this.nodes.length; f++) {
    
              int mt = this.getMaterial(f);
    
              Materials_Used[mt] += 1;
            }    
    
            for (int mt = 0; mt < Materials_Number; mt++) {
    
              if (Materials_Used[mt] != 0) {        
    
                htmlOutput.println("\t\t\t\t<Appearance DEF='SurfaceMaterial" + nf(mt, 0) + "'>");
                htmlOutput.print  ("\t\t\t\t\t<Material");
                htmlOutput.print  (" transparency='" + nf(1 - Materials_Color[mt][0] / 255.0, 0, 3) + "'");
                htmlOutput.print  (" diffuseColor='" + nf(Materials_Color[mt][1] / 255.0, 0, 3) + " " + nf(Materials_Color[mt][2] / 255.0, 0, 3) + " " + nf(Materials_Color[mt][3] / 255.0, 0, 3) + "'");
                htmlOutput.println("></Material>");
                htmlOutput.println("\t\t\t\t</Appearance>");
                
              }
            }
    
          } else {
            
            the_filename = "shadePallet.bmp";
            
            TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
            
            htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
            htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
            htmlOutput.println("\t\t\t\t</Appearance>");
    
            println("Saving texture:", TEXTURE_path);
    
            int RES1 = User3D.export_PalletResolution; 
            int RES2 = User3D.export_PalletResolution / 16;      
    
            PImage pallet_Texture = createImage(RES1, RES2, ARGB);       
    
            pallet_Texture.loadPixels();
    
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
    
              float _val = (Image_X / (0.5 * RES1)) - 1; 
    
              float _u = 0.5 + _val;
    
              if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
              }            
    
              float[] COL = PAINT.getColorStyle(PAL_type, _u);  
    
              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }
    
            pallet_Texture.updatePixels();   
    
            pallet_Texture.save(TEXTURE_path);  
    
          } 
        }
    
    
        for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
    
          if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {
    
            htmlOutput.println("\t\t\t\t<group>");
            
            for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
          
              if (this.nodes[f].length > 2) {
                
                int mt = this.getMaterial(f);
        
                int Tessellation = this.getTessellation(f);
        
                int TotalSubNo = 1;  
                if (this.getMaterial(f) == 0) {
                  Tessellation += this.displayTessellation;
                }
        
                if (Tessellation > 0) TotalSubNo = this.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
        
                float[][] base_Vertices = new float [this.nodes[f].length][3];
                for (int j = 0; j < this.nodes[f].length; j++) {
                  int vNo = this.nodes[f][j];
                  base_Vertices[j][0] = allPoints.getX(vNo);
                  base_Vertices[j][1] = allPoints.getY(vNo);
                  base_Vertices[j][2] = allPoints.getZ(vNo);
                }
        
                for (int n = 0; n < TotalSubNo; n++) {
        
                  float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
                  
                  for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {
        
                    htmlOutput.println("\t\t\t\t\t<shape>");
        
                    if (Create_Face_Texture == 0) {
                      htmlOutput.println("\t\t\t\t\t\t<Appearance USE='SurfaceMaterial" + nf(mt, 0) + "'></Appearance>");
                    }
                    else {
                      htmlOutput.println("\t\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");
                    }              
        
                    
                    htmlOutput.print  ("\t\t\t\t\t\t<IndexedFaceSet");
                    
                    htmlOutput.print  (" coordIndex='");
                    for (int q = 0; q < subFace.length; q++) {
                      if (q > 0) {
                        htmlOutput.print(" ");
                      }         
                      htmlOutput.print(nf(q, 0));          
                    }
                    htmlOutput.println(" -1'>");
                    
                    htmlOutput.print  ("\t\t\t\t\t\t\t<Coordinate point='");
                    for (int q = 0; q < subFace.length; q++) {
                      if (q > 0) {
                        htmlOutput.print(",");
                      }                  
                      int s = q;
                      if (back_or_front == 0) {
                        s = subFace.length - 1 - q;
                      }
                      
                      htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                    }                
                    htmlOutput.println("'></Coordinate>");
        
        
        
        
        
        
                    if (Create_Face_Texture == 1) {
         
                      htmlOutput.print  ("\t\t\t\t\t\t\t<TextureCoordinate point='");
                      for (int q = 0; q < subFace.length; q++) {
                        if (q > 0) {
                          htmlOutput.print(",");
                        }                  
                        int s = q;
                        if (back_or_front == 0) {
                          s = subFace.length - 1 - q;
                        }
                        
                        float _u = 0;
          
            
                        if (WIN3D.FacesShade == SHADE.Global_Solar) {
                          int s_next = (s + 1) % subFace.length;
                          int s_prev = (s + subFace.length - 1) % subFace.length;
            
                          if (back_or_front == 0) {
                            int s_temp = s_next;
                            s_next = s_prev;
                            s_prev = s_temp;
                          }
            
                          _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                        }
            
                        if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
                          
                          _u = SHADE.vertexU_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }                            
            
                        if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
            
                          _u = SHADE.vertexU_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }                  
            
                        if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
            
                          _u = SHADE.vertexU_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                        }
            
            
                        float u0 = 0.5 * (_u + 0.5);
            
                        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                          if (Impact_TYPE == Impact_ACTIVE) {
                            u0 = _u;
                          }
                        }
            
                        if (u0 > 1) u0 = 1;
                        if (u0 < 0) u0 = 0;
          
                        SOLARCHVISION_HTMLprintVtexture(u0, 0.5);
                      }                
                      
                      htmlOutput.println("'></TextureCoordinate>");           
                    }
                    
            
                    htmlOutput.println("\t\t\t\t\t\t</IndexedFaceSet>");
                   
                    htmlOutput.println("\t\t\t\t\t</shape>");
                    
                  }
                }
              }
            }
            htmlOutput.println("\t\t\t\t</group>");
          }
        }
      }      
      
      
      if (target_window == TypeWindow.RAD) {
    
        int[] Materials_Used = new int [Materials_Number];
    
        for (int i = 0; i < Materials_Used.length; i++) {
          Materials_Used[i] = 0;
        }
    
        for (int f = 0; f < this.nodes.length; f++) {
    
          int mt = this.getMaterial(f);
    
          Materials_Used[mt] += 1;
        }    
    
        for (int mt = 0; mt < Materials_Number; mt++) {
    
          if (Materials_Used[mt] != 0) {
    
            float a = Materials_Color[mt][0] / 255.0; 
            float r = Materials_Color[mt][1] / 255.0; 
            float g = Materials_Color[mt][2] / 255.0; 
            float b = Materials_Color[mt][3] / 255.0; 
    
            radOutput.println("void plastic " + "SurfaceMaterial" + nf(mt, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 " + nf(r, 0, User3D.export_PrecisionVtexture) + " " + nf(g, 0, User3D.export_PrecisionVtexture) + " " + nf(b, 0, User3D.export_PrecisionVtexture) + " 0 0");
    
          }
        }
      
        for (int f = 0; f < this.nodes.length; f++) {
      
          if (this.nodes[f].length > 2) {
    
            int mt = this.getMaterial(f);
    
            int Tessellation = this.getTessellation(f);
    
            int TotalSubNo = 1;  
            if (this.getMaterial(f) == 0) {
              Tessellation += this.displayTessellation;
            }
    
            if ((this.nodes[f].length > 4) && (Tessellation == 0)) { // don't need it for triangles
              Tessellation = 1; // <<<<<<<<<< to enforce all polygons having four vertices during baking process
            }
    
            if (Tessellation > 0) TotalSubNo = this.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
    
            float[][] base_Vertices = new float [this.nodes[f].length][3];
            for (int j = 0; j < this.nodes[f].length; j++) {
              int vNo = this.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }
    
            for (int n = 0; n < TotalSubNo; n++) {
    
              float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
              
              for (int back_or_front = 1 - int(User3D.export_BackSides); back_or_front <= 1; back_or_front++) {
    
                if (back_or_front == 1) {
    
                  radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");      
                  
                  radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));                
                  radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                  
                  if (subFace.length == 4) {
    
                    radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                    radOutput.println("0");
                    radOutput.println("0");
                    radOutput.println("9");      
                    
                    radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));                
                    radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                  }
                  
                  
                } else {
    
                  radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                  radOutput.println("0");
                  radOutput.println("0");
                  radOutput.println("9");    
                  
                  radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));                
                  radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                  radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][2], 0, User3D.export_PrecisionVertex));
                  
                  if (subFace.length == 4) { 
                    
                    radOutput.println("SurfaceMaterial" + nf(mt, 0) + " polygon " + "FACE");
                    radOutput.println("0");
                    radOutput.println("0");
                    radOutput.println("9");                   
                    
                    radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));                
                    radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
                    radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                  }
                }
              }
            }
              
            radOutput.println();
          }
        }
      } 
    }
  }
 
 

 
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP);
      
      parent.setInt("ni", this.nodes.length);
      for (int i = 0; i < this.nodes.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.nodes[i].length; j++) {
          lineSTR += nf(this.nodes[i][j], 0);
          if (j < this.nodes[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
      
      parent.setString("displayAll", Boolean.toString(this.displayAll));
      parent.setString("displayNormals", Boolean.toString(this.displayNormals));
      parent.setString("displayEdges", Boolean.toString(this.displayEdges));
      parent.setInt("displayTessellation", this.displayTessellation);
      
      parent.setInt("ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
      parent.setInt("ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
      parent.setFloat("ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
      parent.setInt("PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
      parent.setInt("PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
      parent.setFloat("PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);        
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".options");
      parent.setInt("ni", this.options.length);
      for (int i = 0; i < this.options.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.options[i].length; j++) {
          lineSTR += nf(this.options[i][j], 0);
          if (j < this.options[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

  }


  
    

    
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP);
      int ni = parent.getInt("ni");
      this.nodes = new int [0][0];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        int nj = parts.length;
        int[][] newFace = new int [1][nj];
        for (int j = 0; j < nj; j++) {
          newFace[0][j] = int(parts[j]);
        }
        this.nodes = (int[][]) concat(this.nodes, newFace);
      }
      
      this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
      this.displayNormals = Boolean.parseBoolean(parent.getString("displayNormals"));
      this.displayEdges = Boolean.parseBoolean(parent.getString("displayEdges"));
      this.displayTessellation = parent.getInt("displayTessellation");
      
      this.ACTIVE_pallet_CLR = parent.getInt("ACTIVE_pallet_CLR");
      this.ACTIVE_pallet_DIR = parent.getInt("ACTIVE_pallet_DIR");
      this.ACTIVE_pallet_MLT = parent.getFloat("ACTIVE_pallet_MLT");
      this.PASSIVE_pallet_CLR = parent.getInt("PASSIVE_pallet_CLR");
      this.PASSIVE_pallet_DIR = parent.getInt("PASSIVE_pallet_DIR");
      this.PASSIVE_pallet_MLT = parent.getFloat("PASSIVE_pallet_MLT");    
    }
    
    { 
      XML parent = xml.getChild(this.CLASS_STAMP + ".options");
      int ni = parent.getInt("ni");
      this.options = new int [ni][6];
      XML[] children = parent.getChildren("item"); 
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.options[i][j] = int(parts[j]);
        }
      }
    }
  }    
  
}

solarchvision_Faces allFaces = new solarchvision_Faces(); 

class solarchvision_Curves {
  
  private final static String CLASS_STAMP = "Curves";
  
  boolean displayAll = true; 

  int[][] nodes = new int[0][0];
  
  int[][] options = new int[0][6]; // 0:material, 1:tessellation, 2:layer, 3:visibility, 4:weight, 5:close
  
  int getMaterial (int n) {
    return this.options[n][0];
  }

  int getTessellation (int n) {
    return this.options[n][1];
  }

  int getLayer (int n) {
    return this.options[n][2];
  }  
  
  int getVisibility (int n) {
    return this.options[n][3];
  }   
  
  int getWeight (int n) {
    return this.options[n][4];
  }    
  
  int getClose (int n) {
    return this.options[n][5];
  }   
  
  void setMaterial (int n, int material) {
    this.options[n][0] = material;
  }

  void setTessellation (int n, int tessellation) {
    this.options[n][1] = tessellation;
  }

  void setLayer (int n, int layer) {
    this.options[n][2] = layer;
  }  
  
  void setVisibility (int n, int visibility) {
    this.options[n][3] = visibility;
  }   
  
  void setWeight (int n, int weight) {
    this.options[n][4] = weight;
  }    
  
  void setClose (int n, int close) {
    this.options[n][5] = close;
  }       
  
  
  
  void draw (int target_window) {
   
    if (allFaces.displayAll) {
      
      if (target_window == TypeWindow.WIN3D) {
  
        WIN3D.graphics.strokeWeight(3);
        
        WIN3D.graphics.noFill();      
          
        for (int f = 0; f < this.nodes.length; f++) {    
          
          int vsb = this.getVisibility(f);
    
          if (vsb > 0) {      
        
            int mt = this.getMaterial(f);  
        
            float[] COL = {
              Materials_Color[mt][0], Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3]
            };      
            
            float weight = 0.1 * this.getWeight(f);
          
            WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);    
        
            int Tessellation = int(pow(2, this.getTessellation(f)));
    
            float[][] base_Vertices = new float [this.nodes[f].length][3];
            for (int j = 0; j < this.nodes[f].length; j++) {
              int vNo = this.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }
            
            
            WIN3D.graphics.beginShape();
            
            int div = base_Vertices.length;
            
            for (int j = 0; j < base_Vertices.length; j++) {
              
              int drawSegment = 1;
              
              int nA = j % div;
              int nB = (j + 1)  % div;
              int nB_after = (j + 2) % div;
              int nA_before = (j - 1 + div) % div;        
              
              if (this.getClose(f) == 0) { // if not closed
    
                if (nB_after < nB) nB_after = nB;
                if (nA_before > nA) nA_before = nA; 
                
                if (j == base_Vertices.length - 1) drawSegment = 0; 
              }
              
              if (drawSegment == 1) {
    
                for (int q = 0; q <= Tessellation; q++) {
      
                  float[] P = {0, 0, 0};
                  
                  for (int i = 0; i < 3; i++) {
                    P[i] = ((Tessellation - q) * base_Vertices[nA][i] + q * base_Vertices[nB][i]) / float(Tessellation);
                  }
                  
                  
                  float[] ANG_start = {0, 0, 0};
                  float[] ANG_end = {0, 0, 0};
                  
                  for (int i = 0; i < 3; i++) {
                    ANG_start[i] = base_Vertices[nA][i] - base_Vertices[nA_before][i];
      
                    ANG_end[i] = base_Vertices[nB][i] - base_Vertices[nB_after][i];
                  }
                  
                  if ((ANG_start[0] != 0) || (ANG_start[1] != 0) || (ANG_start[2] != 0)) {
                    ANG_start = funcs.vec3_unit(ANG_start);
                  }
                  if ((ANG_end[0] != 0) || (ANG_end[1] != 0) || (ANG_end[2] != 0)) {
                    ANG_end = funcs.vec3_unit(ANG_end);
                  }
                
                
                  float dist_start = dist(P[0], P[1], P[2], base_Vertices[nA][0], base_Vertices[nA][1], base_Vertices[nA][2]);
                  float dist_end = dist(P[0], P[1], P[2], base_Vertices[nB][0], base_Vertices[nB][1], base_Vertices[nB][2]);
                  
                  for (int i = 0; i < 3; i++) {
                    ANG_start[i] *= dist_start;
                    ANG_end[i] *= dist_end;
                  }
                  
                  for (int i = 0; i < 3; i++) {
                    P[i] += weight * ((Tessellation - q) * ANG_start[i] + q * ANG_end[i]) / float(Tessellation);
                  }        
       
                  
                  
                  WIN3D.graphics.vertex(P[0] * OBJECTS_scale * WIN3D.scale, -(P[1] * OBJECTS_scale * WIN3D.scale), P[2] * OBJECTS_scale * WIN3D.scale);
                  
                }
              }
              
            }
            
            if (this.getClose(f) == 0) { // if not closed
              WIN3D.graphics.endShape();
            }
            else {
              WIN3D.graphics.endShape(CLOSE);
            }
              
              
          }
        }
        
        WIN3D.graphics.strokeWeight(0);
      }
    }
  }  
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP);
      
      parent.setInt("ni", this.nodes.length);
      for (int i = 0; i < this.nodes.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.nodes[i].length; j++) {
          lineSTR += nf(this.nodes[i][j], 0);
          if (j < this.nodes[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
      
      parent.setString("displayAll", Boolean.toString(this.displayAll));
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".options");
      parent.setInt("ni", this.options.length);
      for (int i = 0; i < this.options.length; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.options[i].length; j++) {
          lineSTR += nf(this.options[i][j], 0);
          if (j < this.options[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP);
      int ni = parent.getInt("ni");
      this.nodes = new int [0][0];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        int nj = parts.length;
        int[][] newFace = new int [1][nj];
        for (int j = 0; j < nj; j++) {
          newFace[0][j] = int(parts[j]);
        }
        this.nodes = (int[][]) concat(this.nodes, newFace);
      }
      
      this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
    }
    
    { 
      XML parent = xml.getChild(this.CLASS_STAMP + ".options");
      int ni = parent.getInt("ni");
      this.options = new int [ni][6];
      XML[] children = parent.getChildren("item"); 
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.options[i][j] = int(parts[j]);
        }
      }
    }
  }    
  
}

solarchvision_Curves allCurves = new solarchvision_Curves(); 


class solarchvision_Groups {
  
  private final static String CLASS_STAMP = "Groups";

  int[][] Curves = new int[0][2]; // start curve - end curve
  int[][] Faces = new int[0][2]; // start face - end face
  int[][] Solids = new int[0][2]; // start solid - end solid
  int[][] Model2Ds = new int[0][2]; // start object2D - end object2D
  int[][] Model1Ds = new int[0][2]; // start Model1Ds - end Model1Ds
  int num = 0; 
  
  float[][] PivotMatrix = new float[0][9];
  int[][] PivotType = new int[0][1]; // 0: no solar rotation, 1: allow X-axis solar rotation, 2: allow X-axis solar rotation, 3: allow Z-axis solar rotation 4: free solar rotation (double axis tracking)


  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Model2Ds");
      parent.setInt("ni", this.num);
      for (int i = 0; i < this.num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.Model2Ds[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(this.Model2Ds[i][j], 0);
          if (j < this.Model2Ds[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Model1Ds");
      parent.setInt("ni", this.num);
      for (int i = 0; i < this.num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.Model1Ds[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(this.Model1Ds[i][j], 0);
          if (j < this.Model1Ds[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Faces");
      parent.setInt("ni", this.num);
      for (int i = 0; i < this.num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.Faces[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(this.Faces[i][j], 0);
          if (j < this.Faces[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Curves");
      parent.setInt("ni", this.num);
      for (int i = 0; i < this.num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.Curves[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(this.Curves[i][j], 0);
          if (j < this.Curves[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {    
      XML parent = xml.addChild(this.CLASS_STAMP + ".Solids");
      parent.setInt("ni", this.num);
      for (int i = 0; i < this.num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.Solids[i].length; j++) {
        for (int j = 0; j < 2; j++) { // start, end
          lineSTR += nf(this.Solids[i][j], 0);
          if (j < this.Solids[i].length - 1) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".PivotMatrix");
      int ni = this.num;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.PivotMatrix[i].length; j++) {
          lineSTR += nf(this.PivotMatrix[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < this.PivotMatrix[i].length) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }  

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".PivotType");
      int ni = this.num;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        for (int j = 0; j < this.PivotType[i].length; j++) {
          lineSTR += nf(this.PivotType[i][j], 0, 4).replace(",", "."); // <<<<
          if (j + 1 < this.PivotType[i].length) lineSTR += ",";
        }
        child.setContent(lineSTR);
      }
    }
  }


  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".PivotMatrix");
    
      int ni = parent.getInt("ni");

      this.num = ni;

      this.PivotMatrix = new float [ni][9];

      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 9; j++) {
          this.PivotMatrix[i][j] = float(parts[j]);
        }
      }
    }  


    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".PivotType");
    
      int ni = parent.getInt("ni");

      this.PivotType = new int [ni][1];

      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 1; j++) {
          this.PivotType[i][j] = int(parts[j]);
        }
      }
    }          

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Faces");
    
      int ni = parent.getInt("ni");
      this.Faces = new int [ni][2];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Faces[i][j] = int(parts[j]);
        }
      }
    }
 
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Curves");
    
      int ni = parent.getInt("ni");
      this.Curves = new int [ni][2];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Curves[i][j] = int(parts[j]);
        }
      }
    }        

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Solids");
    
      int ni = parent.getInt("ni");
      this.Solids = new int [ni][2];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Solids[i][j] = int(parts[j]);
        }
      }
    } 

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Model2Ds");
    
      int ni = parent.getInt("ni");
      this.Model2Ds = new int [ni][2];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Model2Ds[i][j] = int(parts[j]);
        }
      }
    } 

    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Model1Ds");
    
      int ni = parent.getInt("ni");
      this.Model1Ds = new int [ni][2];
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Model1Ds[i][j] = int(parts[j]);
        }
      }
    }
  }  
  
}

solarchvision_Groups allGroups = new solarchvision_Groups();   



class solarchvision_SolidImpacts {
  
  private final static String CLASS_STAMP = "SolidImpacts";  
  
  float[] U_scale = {
    100, 100, 100, 100
  }; // i.e. 100m
  float[] V_scale = {
    100, 100, 100, 100
  }; // i.e. 100m
  
  float[] U_offset = {
    0, 0, 0, 0
  }; 
  float[] V_offset = {
    0, 0, 0, 0
  }; 
  
  int RES1 = 200; //400;
  int RES2 = 200; //400;
  
  PImage Image = createImage(this.RES1, this.RES2, ARGB);
  
  
  
  boolean displayImage = true;
  int sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)
  
  float[] elevation = {
    0, 0.1, 0, 0
  }; // <<<
  float[] rotation = {
    0, 0, 0, 0
  };
  
  float positionStep = 1.25;
  
  
  int record_PDF = 0;
  int record_IMG = 0;
  
  float WindSpeed = 5; // (5m/s = 18 km/h) 
  float WindDirection = 180.0;
  
  float Power = 1.0; //2.0; //3.0; // 1/2/3 
  float Grade = 0.02; //1.0; //0.1; //10.0; //contour lines   
  
  
  boolean displayPoints = false;
  boolean displayLines = true;  
  
  int Type = 0; // INTERNAL! 0:simple 1:complex
  
  float get_Impact_atXYZ (float x, float y, float z) {
  
    float v = 0;
  
    if (this.Type == 0) {
      v = this.calculate_Impact_atXYZ_simple(x, y, z);
    } else {
      v = this.calculate_Impact_atXYZ_complex(x, y, z);
    }
  
    return v;
  }
  
  
  
  float calculate_Impact_atXYZ_simple (float x, float y, float z) {
  
    float val = 1;
  
    for (int n = 0; n < allSolids.DEF.length; n++) {
  
      float r = allSolids.get_value(n);
      float d = allSolids.get_Distance(n, x, y, z);
  
      //d *= pow(d, this.Power);
      d *= pow(d, this.Power / float(allSolids.DEF.length));    
  
      if (val < 0) val *= abs(d - r);
      else {
        val *= d - r;
      }
    }
  
    if (allSolids.DEF.length > 0) {
      float val_sign = 1;
      if (val < 0) {
        val_sign = -1;
        val = abs(val);
      } 
      val = pow(val, 1.0 / float(allSolids.DEF.length));
      val *= val_sign;
    } 
  
    return val;
  }
  
  
  
  float calculate_Impact_atXYZ_complex (float x, float y, float z) {
  
    float deltaX = this.WindSpeed * funcs.cos_ang(this.WindDirection);
    float deltaY = this.WindSpeed * funcs.sin_ang(this.WindDirection);
  
    float[] val = {
      1, 1
    };
  
    for (int o = 0; o < 2; o++) {
  
      for (int n = 0; n < allSolids.DEF.length; n++) {
  
        float r = allSolids.get_value(n);
        float d = allSolids.get_Distance(n, x + o * deltaX, y + o * deltaY, z);
  
        //d *= pow(d, this.Power);
        d *= pow(d, this.Power / float(allSolids.DEF.length));
  
        if (val[o] < 0) val[o] *= abs(d - r);
        else {
          val[o] *= d - r;
        }
      }
  
      if (allSolids.DEF.length > 0) {
        float val_sign = 1;
        if (val[o] < 0) {
          val_sign = -1;
          val[o] = abs(val[o]);
        } 
        val[o] = pow(val[o], 1.0 / float(allSolids.DEF.length));
        val[o] *= val_sign;
      }
    }
  
    return val[1] - val[0];
  }


  void calculate_Impact_selectedSections () {
  
    println(CLASS_STAMP + ".calculate_Impact_selectedSections");
  
    for (int o = userSelections.Section_ids.length - 1; o >= 0; o--) {
  
      int f = userSelections.Section_ids[o];
  
      this.sectionType = allSections.Type[f];
      this.RES1 = allSections.RES1[f];
      this.RES2 = allSections.RES2[f];     
  
      this.U_offset[this.sectionType] = allSections.UVERAB[f][0];
      this.V_offset[this.sectionType] = allSections.UVERAB[f][1];
      this.elevation[this.sectionType] = allSections.UVERAB[f][2];
      this.rotation[this.sectionType] = allSections.UVERAB[f][3];
      this.U_scale[this.sectionType] = allSections.UVERAB[f][4];
      this.V_scale[this.sectionType] = allSections.UVERAB[f][5];
  
      {
        if ((this.Image.width != this.RES1) || (this.Image.height != this.RES2)) {
          this.Image = createImage(this.RES1, this.RES2, ARGB);
  
          allSections.SolidImpact[f] = createImage(this.RES1, this.RES2, ARGB);
        }
  
        this.calculate_Impact_CurrentSection();
  
        allSections.SolidImpact[f].copy(this.Image, 0, 0, this.RES1, this.RES2, 0, 0, this.RES1, this.RES2);
      }
    }
  
  }
  
  
  float[] traceContour2D (int traceType, float epsilon, float x, float y, float z, float dx, float dy, float dz, float v) {
  
    float t_max = FLOAT_undefined;
    float t_min = FLOAT_undefined;
    float t_equ = 0; //FLOAT_undefined;  
  
    float v_max = FLOAT_undefined;
    float v_min = FLOAT_undefined;
    float v_equ = FLOAT_undefined;
  
    float x_max = FLOAT_undefined;
    float x_min = FLOAT_undefined;
    float x_equ = x + dx; //FLOAT_undefined;
  
    float y_max = FLOAT_undefined;
    float y_min = FLOAT_undefined;
    float y_equ = y + dy; //FLOAT_undefined;
  
    float z_max = FLOAT_undefined;
    float z_min = FLOAT_undefined;
    float z_equ = z + dz; //FLOAT_undefined;
  
    float min_dist = FLOAT_undefined;  
  
    float r = epsilon;
  
    float t = funcs.atan2_ang(dy, dx);
  
    //for (int test_t = -180; test_t < 180; test_t += 5) { 
    for (int test_t = -150; test_t <= 150; test_t += 5) { // <<<<
  
      float a = r * funcs.cos_ang(t + test_t);
      float b = r * funcs.sin_ang(t + test_t);
      float c = 0;
  
      if (this.sectionType == 1) {
        float Qx = a * funcs.cos_ang(-this.rotation[this.sectionType]) - b * funcs.sin_ang(-this.rotation[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(-this.rotation[this.sectionType]) + b * funcs.cos_ang(-this.rotation[this.sectionType]));
        float Qz = c;
  
        a = Qx; 
        b = Qy; 
        c = Qz;
      } else if (this.sectionType == 2) {
        float Qx = a * funcs.cos_ang(this.rotation[this.sectionType]) - c * funcs.sin_ang(this.rotation[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(this.rotation[this.sectionType]) + c * funcs.cos_ang(this.rotation[this.sectionType]));
        float Qz = -b; 
  
        a = Qx; 
        b = Qy; 
        c = Qz;
      } else if (this.sectionType == 3) {
        float Qx = a * funcs.cos_ang(90 - this.rotation[this.sectionType]) - c * funcs.sin_ang(90 - this.rotation[this.sectionType]);
        float Qy = -(a * funcs.sin_ang(90 - this.rotation[this.sectionType]) + c * funcs.cos_ang(90 - this.rotation[this.sectionType]));
        float Qz = -b; 
  
        a = Qx; 
        b = Qy; 
        c = Qz;
      }
  
      float test_x = x + a;
      float test_y = y + b;
      float test_z = z + c;
  
      float test_v = this.get_Impact_atXYZ(test_x, test_y, test_z);        
  
      if ((test_v < v_min) || (is_undefined_FLOAT(v_min))) {
        v_min = test_v;
        t_min = test_t;
        x_min = test_x;
        y_min = test_y;
        z_min = test_z;
      }
      if ((test_v > v_max) || (is_undefined_FLOAT(v_max))) {
        v_max = test_v;
        t_max = test_t;
        x_max = test_x;
        y_max = test_y;          
        z_max = test_z;
      }
  
      //if (((abs(test_v - v) < min_dist) && (funcs.vec2_dot(test_x - x, test_y - y, dx, dy) >= 0)) || (is_undefined_FLOAT(v_equ)))  {
      if ((abs(test_v - v) < min_dist) || (is_undefined_FLOAT(v_equ))) {
        //if (funcs.vec2_dot(test_x - x, test_y - y, dx, dy) >= 0) {
  
        min_dist = abs(test_v - v);
  
        v_equ = test_v;
        t_equ = test_t;
        x_equ = test_x;
        y_equ = test_y;          
        z_equ = test_z;
        //}
      }
    }     
  
  
    float the_X = 0, the_Y = 0, the_Z = 0, the_T = 0;
  
    if (traceType == 0) {
      the_X = x_equ;
      the_Y = y_equ;
      the_Z = z_equ;
      the_T = t_equ;
    }
    if (traceType == -1) {
      the_X = x_min;
      the_Y = y_min;
      the_Z = z_min;
      the_T = t_min;
    }
    if (traceType == 1) {
      the_X = x_max;
      the_Y = y_max;
      the_Z = z_max;
      the_T = t_max;
    }
  
    float[] return_array = {
      the_X, the_Y, the_Z, funcs.cos_ang(t + the_T), funcs.sin_ang(t + the_T), 0
    };
  
    return return_array;
  }
  
  
  float[][] traceContour3D (float epsilon, float x, float y, float z, float v) {
  
    float tz_max = FLOAT_undefined;
    float tz_min = FLOAT_undefined;
    float tz_equ = FLOAT_undefined;  
  
    float txy_max = FLOAT_undefined;
    float txy_min = FLOAT_undefined;
    float txy_equ = FLOAT_undefined;  
  
    float v_max = FLOAT_undefined;
    float v_min = FLOAT_undefined;
    float v_equ = FLOAT_undefined;
  
    float x_max = FLOAT_undefined;
    float x_min = FLOAT_undefined;
    float x_equ = FLOAT_undefined;
  
    float y_max = FLOAT_undefined;
    float y_min = FLOAT_undefined;
    float y_equ = FLOAT_undefined;
  
    float z_max = FLOAT_undefined;
    float z_min = FLOAT_undefined;
    float z_equ = FLOAT_undefined;
  
    float min_dist = FLOAT_undefined;  
  
    float r = epsilon;
  
    for (int test_tz = -90; test_tz <= 90; test_tz += 30) { // in the space 
      //for (int test_tz = 0; test_tz <= 0; test_tz += 30) { // on the surface! 
  
      float c = r * funcs.sin_ang(test_tz);
  
      for (int test_txy = -180; test_txy < 180; test_txy += 15) { 
  
        float a = r * funcs.cos_ang(test_tz) * funcs.cos_ang(test_txy);
        float b = r * funcs.cos_ang(test_tz) * funcs.sin_ang(test_txy);
  
  
        float test_x = x + a;
        float test_y = y + b;
        float test_z = z + c;
  
        float test_v = this.get_Impact_atXYZ(test_x, test_y, test_z);        
  
        if ((test_v < v_min) || (is_undefined_FLOAT(v_min))) {
          v_min = test_v;
          tz_min = test_tz;
          txy_min = test_txy;
          x_min = test_x;
          y_min = test_y;
          z_min = test_z;
        }
        if ((test_v > v_max) || (is_undefined_FLOAT(v_max))) {
          v_max = test_v;
          tz_max = test_tz;
          txy_max = test_txy;
          x_max = test_x;
          y_max = test_y;          
          z_max = test_z;
        }
  
        if ((abs(test_v - v) < min_dist) || (is_undefined_FLOAT(v_equ))) {
  
          min_dist = abs(test_v - v);
  
          v_equ = test_v;
          tz_equ = test_tz;
          txy_equ = test_txy;
          x_equ = test_x;
          y_equ = test_y;          
          z_equ = test_z;
        }
      }
    }
  
    float[][] return_array = {
      {
        x_min, y_min, z_min, v_min
      }
      , {
        x_equ, y_equ, z_equ, v_equ
      }
      , {
        x_max, y_max, z_max, v_max
      }
    };
  
    return return_array;
  }
  
  
  
  
  
  float[][] Contours_U1Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  float[][] Contours_V1Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  float[][] Contours_V2Vertices = {
    {
      0, 0, 0, 0
    }
  }; // keeping SolidImpact value at the 4th member
  int[][] Contours_U1Lines = {
    {
      0, 0
    }
  };
  int[][] Contours_V1Lines = {
    {
      0, 0
    }
  };
  int[][] Contours_V2Lines = {
    {
      0, 0
    }
  };
  
  int Process_subDivisions = 1; //1; // 0,1,2,3
  
  float deltaStep = 0.05;
  float deltaLines = 0.1 * this.deltaStep;
  
  
  void calculate_Impact_CurrentSection () {
  
    if (this.sectionType != 0) {
  
      cursor(WAIT);
  
      this.Contours_U1Vertices = new float [1][4];
      this.Contours_U1Vertices[0][0] = 0; 
      this.Contours_U1Vertices[0][1] = 0; 
      this.Contours_U1Vertices[0][2] = 0; 
      this.Contours_U1Vertices[0][3] = 0;   
  
      this.Contours_V1Vertices = new float [1][4];
      this.Contours_V1Vertices[0][0] = 0; 
      this.Contours_V1Vertices[0][1] = 0; 
      this.Contours_V1Vertices[0][2] = 0; 
      this.Contours_V1Vertices[0][3] = 0;
  
      this.Contours_V2Vertices = new float [1][4];
      this.Contours_V2Vertices[0][0] = 0; 
      this.Contours_V2Vertices[0][1] = 0; 
      this.Contours_V2Vertices[0][2] = 0; 
      this.Contours_V2Vertices[0][3] = 0;
  
      this.Contours_U1Lines = new int [1][2];
      this.Contours_U1Lines[0][0] = 0;
      this.Contours_U1Lines[0][1] = 0;
  
      this.Contours_V1Lines = new int [1][2];
      this.Contours_V1Lines[0][0] = 0;
      this.Contours_V1Lines[0][1] = 0;
  
      this.Contours_V2Lines = new int [1][2];
      this.Contours_V2Lines[0][0] = 0;
      this.Contours_V2Lines[0][1] = 0;  
  
  
      int PAL_type = allSolids.pallet_CLR; 
      int PAL_direction = allSolids.pallet_DIR;
      float PAL_multiplier = allSolids.pallet_MLT;     
  
      this.Image.loadPixels();
  
      float Section_U_offset = this.U_offset[this.sectionType];
      float Section_V_offset = this.V_offset[this.sectionType];
      float Section_elevation = this.elevation[this.sectionType];
      float Section_rotation = this.rotation[this.sectionType];
      float Section_U_scale = this.U_scale[this.sectionType];
      float Section_V_scale = this.V_scale[this.sectionType];
  
      int Section_Type = this.sectionType;
      int Section_RES1 = this.RES1;
      int Section_RES2 = this.RES2; 
  
      float[][] ImageVertex = allSections.getCorners(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
  
      float[] SectionCorner_A = ImageVertex[1];
      float[] SectionCorner_B = ImageVertex[2];
      float[] SectionCorner_C = ImageVertex[3];
      float[] SectionCorner_D = ImageVertex[4]; 
  
      for (int i = 0; i < this.RES1; i++) {
        for (int j = 0; j < this.RES2; j++) {
  
          float x = funcs.bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(this.RES1), 1 - j / float(this.RES2));
          float y = funcs.bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(this.RES1), 1 - j / float(this.RES2));
          float z = funcs.bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(this.RES1), 1 - j / float(this.RES2));
  
          this.Type = 0;
          float val = this.get_Impact_atXYZ(x, y, z);     
  
          float g =      funcs.roundTo(this.Grade * val, this.deltaStep) - 0.5 * this.deltaStep;
          float g_line = funcs.roundTo(this.Grade * val, this.deltaLines);
  
          float _u = PAL_multiplier * val + 0.5;
  
          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;
  
          float[] COL = PAINT.getColorStyle(PAL_type, _u);     
  
          if ((this.Process_subDivisions == 1) || (this.Process_subDivisions == 2)) {
            //if ((g == g_line) && (g != 0)) {
            if ((abs(g - g_line) < 0.001) && (g != 0)) {      
              COL[0] = 0;    
              COL[1] = 0;//255;
              COL[2] = 0;//255;
              COL[3] = 0;//255;
            }
          } 
  
          if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {
  
            if ((abs(g - g_line) < 0.0001) && (g != 0) && (g_line <= 1)) {
              //if ((g_line > 1 - this.deltaLines) && (g_line <= 1)) { // not sure!
  
              float dx = 1;
              float dy = 0;
              float dz = 0;             
  
              float[] test_point_dir = {
                x, y, z, dx, dy, dz
              };
  
              trace_U1Line(test_point_dir, g_line, 100);
            }
          }
  
          this.Image.pixels[i + j * this.RES1] = color(COL[1], COL[2], COL[3], COL[0]);
        }
      }
  
      this.Image.updatePixels();
  
      if (this.record_IMG == 1) {
        String myFile = getFilename_SolidImpact() + ".jpg";
        this.Image.save(myFile);
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }    
  
  
  
      if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {
        /*    
         for (int k = 1; k < this.Contours_U1Vertices.length; k++) {  
         
         float x = this.Contours_U1Vertices[k][0];
         float y = this.Contours_U1Vertices[k][1];
         float z = this.Contours_U1Vertices[k][2];
         
         float val = this.Contours_U1Vertices[k][3]; //this.get_Impact_atXYZ(x, y, z);
         
         float g =      funcs.roundTo(this.Grade * val, this.deltaStep) - 0.5 * this.deltaStep;
         float g_line = funcs.roundTo(this.Grade * val, this.deltaLines);
         
         float dx = 1;
         float dy = 0;
         float dz = 0;   
         
         float[] test_point_dir = {x, y, z, dx, dy, dz}; 
         
         // making the first VVertex on the UVertice
         {
         float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade}};
         this.Contours_V1Vertices = (float[][]) concat(this.Contours_V1Vertices, newVertex);
         }      
         
         // making the first WVertex on the UVertice
         {
         float[][] newVertex = {{test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade}};
         this.Contours_V2Vertices = (float[][]) concat(this.Contours_V2Vertices, newVertex);
         }      
         
         
         trace_V1Line(test_point_dir, g_line, 100);
         }
         */
      }
  
      if (this.record_PDF == 1) {
  
        String myFile = getFilename_SolidImpact() + ".pdf";
  
        PGraphics pdf = createGraphics(this.RES1, this.RES2, PDF, myFile);
  
        pdf.beginDraw();
  
        pdf.image(this.Image, 0, 0, this.RES1, this.RES2);
  
        if ((this.Process_subDivisions == 2) || (this.Process_subDivisions == 3)) {
          if (this.displayLines) {
  
            for (int U_or_V_or_W = 0; U_or_V_or_W < 3; U_or_V_or_W++) {
  
              if (U_or_V_or_W == 0) {
                pdf.strokeWeight(0.25);
                pdf.stroke(255, 0, 0);
                pdf.fill(255, 0, 0);
              } 
              if (U_or_V_or_W == 1) {
                pdf.strokeWeight(0.25);
                pdf.stroke(0, 255, 0);
                pdf.fill(0, 255, 0);
              }
              if (U_or_V_or_W == 2) {
                pdf.strokeWeight(0.25);
                pdf.stroke(0, 0, 255);
                pdf.fill(0, 0, 255);
              }
  
              int q_num = 0;
              if (U_or_V_or_W == 0) {
                q_num = this.Contours_U1Lines.length;
              } 
              if (U_or_V_or_W == 1) {
                q_num = this.Contours_V1Lines.length;
              }
              if (U_or_V_or_W == 2) {
                q_num = this.Contours_V2Lines.length;
              }
  
              for (int q = 1; q < q_num; q++) {
  
                float[] i = {
                  0, 0
                };
                float[] j = {
                  0, 0
                };
  
                for (int p = 0; p < 2; p++) {
  
                  int n = 0;
                  float x0 = 0, y0 = 0, z0 = 0;
  
                  if (U_or_V_or_W == 0) {
                    n = this.Contours_U1Lines[q][p];
                    x0 = this.Contours_U1Vertices[n][0];
                    y0 = this.Contours_U1Vertices[n][1];
                    z0 = this.Contours_U1Vertices[n][2];
                  }
                  if (U_or_V_or_W == 1) {
                    n = this.Contours_V1Lines[q][p];        
                    x0 = this.Contours_V1Vertices[n][0];
                    y0 = this.Contours_V1Vertices[n][1];
                    z0 = this.Contours_V1Vertices[n][2];
                  }
                  if (U_or_V_or_W == 2) {
                    n = this.Contours_V2Lines[q][p];        
                    x0 = this.Contours_V2Vertices[n][0];
                    y0 = this.Contours_V2Vertices[n][1];
                    z0 = this.Contours_V2Vertices[n][2];
                  }
  
                  float r = 0;
  
                  if (this.sectionType == 1) {
                    r = -this.rotation[this.sectionType];
                  } else if (this.sectionType == 2) {
                    r = this.rotation[this.sectionType];
                  } else if (this.sectionType == 3) {
                    r = -this.rotation[this.sectionType];
                  }     
  
                  float x = x0 * funcs.cos_ang(r) - y0 * funcs.sin_ang(r);
                  float y = x0 * funcs.sin_ang(r) + y0 * funcs.cos_ang(r);
                  float z = z0;
  
                  float a = 0;
                  float b = 0;
  
                  if (this.sectionType == 1) {
                    a = x;
                    b = -y;
                  } else if (this.sectionType == 2) {
                    a = x;
                    b = -z;
                  } else if (this.sectionType == 3) {
                    a = -y;
                    b = -z;
                  }
  
                  i[p] = this.RES1 * ((a - this.U_offset[this.sectionType]) / this.U_scale[this.sectionType] + 0.5);
                  j[p] = this.RES2 * ((b + this.V_offset[this.sectionType]) / this.V_scale[this.sectionType] + 0.5);
                }   
  
                pdf.line(i[0], j[0], i[1], j[1]);
              }
            }
          }
  
          if (this.displayPoints) {
            pdf.strokeWeight(0.5);
            pdf.stroke(255, 127, 0);
            pdf.noFill();  
            pdf.ellipseMode(CENTER);
  
            for (int n = 1; n < this.Contours_U1Vertices.length; n++) {
  
              float x0 = this.Contours_U1Vertices[n][0];
              float y0 = this.Contours_U1Vertices[n][1];
              float z0 = this.Contours_U1Vertices[n][2];
  
              float r = 0;
  
              if (this.sectionType == 1) {
                r = -this.rotation[this.sectionType];
              } else if (this.sectionType == 2) {
                r = this.rotation[this.sectionType];
              } else if (this.sectionType == 3) {
                r = -this.rotation[this.sectionType];
              }     
  
              float x = x0 * funcs.cos_ang(r) - y0 * funcs.sin_ang(r);
              float y = x0 * funcs.sin_ang(r) + y0 * funcs.cos_ang(r);
              float z = z0;
  
              float a = 0;
              float b = 0;
  
              if (this.sectionType == 1) {
                a = x;
                b = -y;
              } else if (this.sectionType == 2) {
                a = x;
                b = -z;
              } else if (this.sectionType == 3) {
                a = -y;
                b = -z;
              }
  
              float i = this.RES1 * ((a - this.U_offset[this.sectionType]) / this.U_scale[this.sectionType] + 0.5);
              float j = this.RES2 * ((b + this.V_offset[this.sectionType]) / this.V_scale[this.sectionType] + 0.5);
  
              pdf.ellipse(i, j, 1, 1);
            }
  
            pdf.strokeWeight(0);
          }
        }
  
  
        pdf.dispose();
  
        pdf.endDraw();
  
        SOLARCHVISION_explore_output(myFile);
        println("File created:" + myFile);
      }
  
      cursor(ARROW);
    }
  }
  
  
  
  void draw_lines () {
  
    if (this.displayLines) {
  
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(255, 0, 0);
      WIN3D.graphics.fill(255, 0, 0);  
  
      for (int q = 1; q < this.Contours_U1Lines.length; q++) {
  
        int n1 = this.Contours_U1Lines[q][0];
        int n2 = this.Contours_U1Lines[q][1];
  
        float x1 = this.Contours_U1Vertices[n1][0];
        float y1 = this.Contours_U1Vertices[n1][1];
        float z1 = this.Contours_U1Vertices[n1][2];
  
        float x2 = this.Contours_U1Vertices[n2][0];
        float y2 = this.Contours_U1Vertices[n2][1];
        float z2 = this.Contours_U1Vertices[n2][2];
  
        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }
  
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(0, 255, 0);
      WIN3D.graphics.fill(0, 255, 0);  
  
      for (int q = 1; q < this.Contours_V1Lines.length; q++) {
  
        int n1 = this.Contours_V1Lines[q][0];
        int n2 = this.Contours_V1Lines[q][1];
  
        float x1 = this.Contours_V1Vertices[n1][0];
        float y1 = this.Contours_V1Vertices[n1][1];
        float z1 = this.Contours_V1Vertices[n1][2];
  
        float x2 = this.Contours_V1Vertices[n2][0];
        float y2 = this.Contours_V1Vertices[n2][1];
        float z2 = this.Contours_V1Vertices[n2][2];
  
        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }
  
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(255, 0, 0);
      WIN3D.graphics.fill(255, 0, 0);  
  
      for (int q = 1; q < this.Contours_V2Lines.length; q++) {
  
        int n1 = this.Contours_V2Lines[q][0];
        int n2 = this.Contours_V2Lines[q][1];
  
        float x1 = this.Contours_V2Vertices[n1][0];
        float y1 = this.Contours_V2Vertices[n1][1];
        float z1 = this.Contours_V2Vertices[n1][2];
  
        float x2 = this.Contours_V2Vertices[n2][0];
        float y2 = this.Contours_V2Vertices[n2][1];
        float z2 = this.Contours_V2Vertices[n2][2];
  
        WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
      }
  
      WIN3D.graphics.strokeWeight(0);
    }
  }
  
  void draw_points () {
    if (this.displayPoints) {
  
      WIN3D.graphics.strokeWeight(0);
      WIN3D.graphics.stroke(255, 127, 0);
      WIN3D.graphics.fill(255, 127, 0);  
  
      float R = 1; //0.2;
  
      for (int n = 1; n < this.Contours_U1Vertices.length; n++) {
  
        float x = this.Contours_U1Vertices[n][0];
        float y = this.Contours_U1Vertices[n][1];
        float z = this.Contours_U1Vertices[n][2];
  
        WIN3D.graphics.pushMatrix();
        WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.sphere(R);
        WIN3D.graphics.popMatrix();
      }
    }
  }
  
  float MinimumDistance_traceU = 1.0;
  float MinimumDistance_traceV = 0.25;
  
  void trace_U1Line (float[] test_point_dir, float g_line, int n_Tries) {
  
    int point_prev = 0; 
    int point_next = 0;
  
    for (int n = 0; n < n_Tries; n++) {
  
      float[][] preVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };
  
      if (point_prev == 0) {
        float nearestPointDist = FLOAT_undefined;
        int nearestPointNum = 0;
  
        for (int q = 1; q < this.Contours_U1Vertices.length; q++) {
          //if (preVertex[0][3] == this.Contours_U1Vertices[q][3]) {
          if (preVertex[0][3] - this.Contours_U1Vertices[q][3] < 0.0001) {
  
            float d = dist(preVertex[0][0], preVertex[0][1], preVertex[0][2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);
  
            if (nearestPointDist > d) {
              nearestPointDist = d;
              nearestPointNum = q;
            }
          }
        }
  
        if (nearestPointDist < 0.5) {  //i.e. 0.5m 
          point_prev = nearestPointNum;
  
          test_point_dir[0] = this.Contours_U1Vertices[point_prev][0];
          test_point_dir[1] = this.Contours_U1Vertices[point_prev][1];
          test_point_dir[2] = this.Contours_U1Vertices[point_prev][2];
        }
      } 
  
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      test_point_dir = this.traceContour2D(0, MinimumDistance_traceU, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / this.Grade);
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
      float[][] newVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };
      point_next = 0; 
  
      float nearestPointDist = FLOAT_undefined;
      int nearestPointNum = 0;
  
      int next_point_existed = 0;
  
      for (int q = 1; q < this.Contours_U1Vertices.length; q++) {
        //if (newVertex[0][3] == this.Contours_U1Vertices[q][3]) {
        if (abs(newVertex[0][3] - this.Contours_U1Vertices[q][3]) < 0.0001) {
  
          float d = dist(newVertex[0][0], newVertex[0][1], newVertex[0][2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);
  
          if ((nearestPointDist > d) && (point_prev != q)) { 
            nearestPointDist = d;
            nearestPointNum = q;
          }
        }
      }
  
      if (nearestPointDist < MinimumDistance_traceU) {
        point_next = nearestPointNum;
  
        test_point_dir[0] = this.Contours_U1Vertices[point_next][0];
        test_point_dir[1] = this.Contours_U1Vertices[point_next][1];
        test_point_dir[2] = this.Contours_U1Vertices[point_next][2];
  
        next_point_existed = 1;
      }
  
  
      if (point_next == 0) {
  
        this.Contours_U1Vertices = (float[][]) concat(this.Contours_U1Vertices, newVertex);              
        point_next = this.Contours_U1Vertices.length - 1;
      } 
  
      if ((point_prev != 0) && (point_next != 0)) {
        int[][] newU1Line = {
          {
            point_prev, point_next
          }
        };
        this.Contours_U1Lines = (int[][]) concat(this.Contours_U1Lines, newU1Line);
  
        point_prev = point_next;
      }
  
      if (next_point_existed == 1) {
        break; // when reaching an existing line
      }
    }
  }
  
  void trace_V1Line (float[] test_point_dir, float g_line, int n_Tries) {
  
    int point_prev = this.Contours_V1Vertices.length - 1; // the last added point
    int point_next = 0;
  
    for (int n = 0; n < n_Tries; n++) {
  
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      test_point_dir = this.traceContour2D(-1, MinimumDistance_traceV, test_point_dir[0], test_point_dir[1], test_point_dir[2], test_point_dir[3], test_point_dir[4], test_point_dir[5], g_line / this.Grade);
      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
      float[][] newVertex = {
        {
          test_point_dir[0], test_point_dir[1], test_point_dir[2], g_line / this.Grade
        }
      };
  
      point_next = 0;
  
      {
        this.Contours_V1Vertices = (float[][]) concat(this.Contours_V1Vertices, newVertex);              
        point_next = this.Contours_V1Vertices.length - 1;
      }
  
      if ((point_prev != 0) && (point_next != 0)) {
        int[][] newV1Line = {
          {
            point_prev, point_next
          }
        };
        this.Contours_V1Lines = (int[][]) concat(this.Contours_V1Lines, newV1Line);
  
        float val_new = this.get_Impact_atXYZ(test_point_dir[0], test_point_dir[1], test_point_dir[2]);
        float g_new =      funcs.roundTo(this.Grade * val_new, this.deltaStep) - 0.5 * this.deltaStep;
        float g_line_new = funcs.roundTo(this.Grade * val_new, this.deltaLines);
  
        if (g_line - g_line_new >= this.deltaStep) {
  
  
          float nearestPointDist = FLOAT_undefined;
          int nearestPointNum = 0;
  
          for (int q = 1; q < this.Contours_U1Vertices.length; q++) {
  
            //if (abs(g_line_new / this.Grade - this.Contours_U1Vertices[q][3]) < 0.0001) {
            if (g_line - g_line_new < 2 * this.deltaStep) {
  
              float d = dist(test_point_dir[0], test_point_dir[1], test_point_dir[2], this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2]);
  
              if (nearestPointDist > d) { 
                nearestPointDist = d;
                nearestPointNum = q;
              }
            }
          }
  
          if (nearestPointDist < MinimumDistance_traceU) {
  
            int q = nearestPointNum;
  
            float[][] endVertex = {
              {
                this.Contours_U1Vertices[q][0], this.Contours_U1Vertices[q][1], this.Contours_U1Vertices[q][2], this.Contours_U1Vertices[q][3]
              }
            };
            this.Contours_V2Vertices = (float[][]) concat(this.Contours_V2Vertices, endVertex);
  
            int[][] newV2Line = {
              {
                this.Contours_V2Vertices.length - 2, this.Contours_V2Vertices.length - 1
              }
            }; // last two WVertices
            this.Contours_V2Lines = (int[][]) concat(this.Contours_V2Lines, newV2Line);
          }
  
  
          break; // when reaching the area outside contour level
        }
  
        point_prev = point_next;
      }
    }
  }
  
  float[][] Wind_Vertices = new float [0][4]; // keeping values at the 4th member
  int[][] Wind_Lines = new int [0][2];
  
  void calculate_WindFlow () {
  
    cursor(WAIT);  
  
    this.Wind_Vertices = new float [0][4];
  
    this.Wind_Lines = new int [0][2];
  
  
  
  
    float deltaX = -this.WindSpeed * funcs.cos_ang(this.WindDirection);
    float deltaY = -this.WindSpeed * funcs.sin_ang(this.WindDirection);
    float deltaZ = 0;   
  
    /* 
     
     float Section_U_offset = this.U_offset[this.sectionType];
     float Section_V_offset = this.V_offset[this.sectionType];
     float Section_elevation = this.elevation[this.sectionType];
     float Section_rotation = this.rotation[this.sectionType];
     float Section_U_scale = this.U_scale[this.sectionType];
     float Section_V_scale = this.V_scale[this.sectionType];
     
     int Section_Type = this.sectionType;
     int Section_RES1 = this.RES1;
     int Section_RES2 = this.RES2; 
     
     float[][] ImageVertex = allSections.getCorners(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2); 
     
     float[] SectionCorner_A = ImageVertex[1];
     float[] SectionCorner_B = ImageVertex[2];
     float[] SectionCorner_C = ImageVertex[3];
     float[] SectionCorner_D = ImageVertex[4]; 
     
     for (int i = 0; i < this.RES1; i += 10) {
     for (int j = 0; j < this.RES2; j += 10) {
     
     float x = funcs.bilinear(SectionCorner_A[0], SectionCorner_B[0], SectionCorner_C[0], SectionCorner_D[0], i / float(this.RES1), 1 - j / float(this.RES2));
     float y = funcs.bilinear(SectionCorner_A[1], SectionCorner_B[1], SectionCorner_C[1], SectionCorner_D[1], i / float(this.RES1), 1 - j / float(this.RES2));
     float z = funcs.bilinear(SectionCorner_A[2], SectionCorner_B[2], SectionCorner_C[2], SectionCorner_D[2], i / float(this.RES1), 1 - j / float(this.RES2));
     
     */
  
  
    for (float z = 2.5; z <= 30; z += 5.0) {
      for (float y = -80; y <= 80; y += 5.0) {
        for (float x = -80; x <= 80; x += 5.0) {
  
  
  
          float[] test_point = {
            x, y, z
          };
  
  
          int num_steps = 1; //1; //4;
  
          for (int n = 0; n < num_steps; n++) {
  
            this.Type = 0;
            float inside_or_outside = this.get_Impact_atXYZ(test_point[0], test_point[1], test_point[2]);
  
            if (inside_or_outside > 0) {
  
              this.Type = 1;
              float val = this.get_Impact_atXYZ(test_point[0], test_point[1], test_point[2]);
  
  
              float MinimumDistance_trace = 1 / float(num_steps);
  
              //-----------------------------------------------------------------------------------------------------------------------------------------
              float[][] tracedPoints = this.traceContour3D(MinimumDistance_trace, test_point[0], test_point[1], test_point[2], val);
              //-----------------------------------------------------------------------------------------------------------------------------------------
  
              float[] point_min = tracedPoints[0];
              //float[] point_equ = tracedPoints[1];
              //float[] point_max = tracedPoints[2];
  
              float[] v1 = {
                deltaX, deltaY, deltaZ
              };
  
              float[] v2 = {
                point_min[0] - x, point_min[1] - y, point_min[2] - z
              };
  
              float acceleration = -this.WindSpeed * (point_min[3] - val);
  
              float dx = v1[0] + v2[0] * acceleration;
              float dy = v1[1] + v2[1] * acceleration;
              float dz = v1[2] + v2[2] * acceleration;
  
              //float scale = 1.0 / float(num_steps);
              float scale = 0.1 / float(num_steps); // <<<<<<<<<<<<<<<<<<<<
  
              float x1 = test_point[0] - 0.5 * dx * scale;
              float y1 = test_point[1] - 0.5 * dy * scale;
              float z1 = test_point[2] - 0.5 * dz * scale;
  
              float x2 = test_point[0] + 0.5 * dx * scale;
              float y2 = test_point[1] + 0.5 * dy * scale;
              float z2 = test_point[2] + 0.5 * dz * scale;
  
  
              float AB = (dist(x1, y1, z1, x2, y2, z2) / scale - this.WindSpeed) / this.WindSpeed; 
  
              int point_prev = 0;
              int point_next = 0;
  
              {
                float[][] newVertex = {
                  {
                    x1, y1, z1, AB
                  }
                };
                this.Wind_Vertices = (float[][]) concat(this.Wind_Vertices, newVertex);
  
                point_prev = this.Wind_Vertices.length - 1;
              }      
  
  
              {
                float[][] newVertex = {
                  {
                    x2, y2, z2, AB
                  }
                };
                this.Wind_Vertices = (float[][]) concat(this.Wind_Vertices, newVertex);
  
                point_next = this.Wind_Vertices.length - 1;
              }      
  
              if ((point_prev != 0) && (point_next != 0)) {
                int[][] newU1Line = {
                  {
                    point_prev, point_next
                  }
                };
                this.Wind_Lines = (int[][]) concat(this.Wind_Lines, newU1Line);
  
                point_prev = point_next;
              }      
  
  
              test_point[0] = x2;       
              test_point[1] = y2;
              test_point[2] = z2;
            }
          }
        }
      }
    }  
  
    cursor(ARROW);  
  
    allWindFlows.displayAll = true;                
    ROLLOUT.update = true;
  }
  



  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);

    parent.setFloat(this.CLASS_STAMP + ".WindSpeed", this.WindSpeed); 
    parent.setFloat(this.CLASS_STAMP + ".WindDirection", this.WindDirection);
    parent.setFloat(this.CLASS_STAMP + ".Power", this.Power);
    parent.setString(this.CLASS_STAMP + ".displayPoints", Boolean.toString(this.displayPoints));
    parent.setString(this.CLASS_STAMP + ".displayLines", Boolean.toString(this.displayLines));  
    
    parent.setInt(this.CLASS_STAMP + ".RES1", this.RES1);
    parent.setInt(this.CLASS_STAMP + ".RES2", this.RES2);
    parent.setFloat(this.CLASS_STAMP + ".Grade", this.Grade);
    parent.setString(this.CLASS_STAMP + ".displayImage", Boolean.toString(this.displayImage));
    parent.setInt(this.CLASS_STAMP + ".sectionType", this.sectionType);
    parent.setFloat(this.CLASS_STAMP + ".positionStep", this.positionStep);
    parent.setInt(this.CLASS_STAMP + ".Process_subDivisions", this.Process_subDivisions);
    parent.setFloat(this.CLASS_STAMP + ".deltaStep", this.deltaStep);
    parent.setFloat(this.CLASS_STAMP + ".deltaLines", this.deltaLines);
    parent.setFloat(this.CLASS_STAMP + ".MinimumDistance_traceU", this.MinimumDistance_traceU);
    parent.setFloat(this.CLASS_STAMP + ".MinimumDistance_traceV", this.MinimumDistance_traceV);  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".elevation");
      int ni = this.elevation.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.elevation[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".rotation");
      int ni = this.rotation.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.rotation[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".U_scale");
      int ni = this.U_scale.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.U_scale[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".V_scale");
      int ni = this.V_scale.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.V_scale[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".U_offset");
      int ni = this.U_offset.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.U_offset[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".V_offset");
      int ni = this.V_offset.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.V_offset[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
    
  }



  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);

    this.WindSpeed = parent.getFloat(this.CLASS_STAMP + ".WindSpeed"); 
    this.WindDirection = parent.getFloat(this.CLASS_STAMP + ".WindDirection");
    this.Power = parent.getFloat(this.CLASS_STAMP + ".Power");

    this.displayPoints = Boolean.parseBoolean(parent.getString(this.CLASS_STAMP + ".displayPoints"));
    this.displayLines = Boolean.parseBoolean(parent.getString(this.CLASS_STAMP + ".displayLines"));
    
    this.RES1 = parent.getInt(this.CLASS_STAMP + ".RES1");
    this.RES2 = parent.getInt(this.CLASS_STAMP + ".RES2");
    this.Grade = parent.getFloat(this.CLASS_STAMP + ".Grade");
    this.displayImage = Boolean.parseBoolean(parent.getString(this.CLASS_STAMP + ".displayImage"));
    this.sectionType = parent.getInt(this.CLASS_STAMP + ".sectionType");
    this.positionStep = parent.getFloat(this.CLASS_STAMP + ".positionStep");
    this.Process_subDivisions = parent.getInt(this.CLASS_STAMP + ".Process_subDivisions");
    this.deltaStep = parent.getFloat(this.CLASS_STAMP + ".deltaStep");
    this.deltaLines = parent.getFloat(this.CLASS_STAMP + ".deltaLines");
    this.MinimumDistance_traceU = parent.getFloat(this.CLASS_STAMP + ".MinimumDistance_traceU");
    this.MinimumDistance_traceV = parent.getFloat(this.CLASS_STAMP + ".MinimumDistance_traceV");

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".elevation");
    
      int ni = child.getInt("ni");
      this.elevation = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.elevation[i] = float(parts[i]);
      }
    } 

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".rotation");
    
      int ni = child.getInt("ni");
      this.rotation = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.rotation[i] = float(parts[i]);
      }
    } 

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".U_scale");
    
      int ni = child.getInt("ni");
      this.U_scale = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.U_scale[i] = float(parts[i]);
      }
    } 

    {
        XML child = xml.getChild(this.CLASS_STAMP + ".V_scale");
    
      int ni = child.getInt("ni");
      this.V_scale = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.V_scale[i] = float(parts[i]);
      }
    }     

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".U_offset");
    
      int ni = child.getInt("ni");
      this.U_offset = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.U_offset[i] = float(parts[i]);
      }
    } 


    {
      XML child = xml.getChild(this.CLASS_STAMP + ".V_offset");
    
      int ni = child.getInt("ni");
      this.V_offset = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.V_offset[i] = float(parts[i]);
      }
    }  
  }    
}

solarchvision_SolidImpacts allSolidImpacts = new solarchvision_SolidImpacts();   





class solarchvision_SolarImpacts {
  
  private final static String CLASS_STAMP = "SolarImpacts";  
  
  boolean rebuild_Image_array = true;
  
  PImage[][] Image;
  
  boolean displayImage = false;
  int sectionType = 0; // 0:off, 1:horizontal, 2:vertical(front), 3:vertical(side)
  
  float rotation = 0; // North is up by default
  
  float U_scale = 500; // i.e. 500 = 500m 
  float V_scale = 500; // i.e. 500 = 500m 
  
  float U_offset = 0;
  float V_offset = 0; 
  
  int RES1 = 100; //200;
  int RES2 = 100; //200;
  
  float elevation;
  
  int record_IMG = 0;  
  
  void resize_Image_array () {
  
    this.Image = new PImage [2][(1 + STUDY.j_End - STUDY.j_Start)];
  
    for (int i = 0; i < this.Image.length; i++) {
      for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) { // total image at j = -1 
    
        this.Image[i][j + 1] = createImage(2, 2, RGB); // empty and small
      }  
    }
  
    allSolarImpacts.rebuild_Image_array = false;
  }

  
  void calculate_Impact_CurrentPreBaked () {
  
    if (allSolarImpacts.rebuild_Image_array) {
      this.resize_Image_array();
    }
    
    println("AAA");
  
    if (this.sectionType != 0) {
  
      println("BBB");
      
      cursor(WAIT);
  
      int[] startK_endK = get_startK_endK();
      int start_k = startK_endK[0]; 
      int end_k = startK_endK[1];
      int count_k = 1 + end_k - start_k; 
      if (count_k < 0) count_k = 0;
  
  
      int RES1 = this.RES1;
      int RES2 = this.RES2;
  
      float Pa = FLOAT_undefined;
      float Pb = FLOAT_undefined;
      float Pc = FLOAT_undefined;
      float Pd = FLOAT_undefined;
  
      float values_R_dir;
      float values_R_dif;
  
      float values_E_dir;
      float values_E_dif;
  
      int now_k = 0;
      int now_i = 0;
      int now_j = 0;
  
      for (int p = 0; p < 1; p++) { 
        int l = STUDY.ImpactLayer;
  
        PImage[] total_Image_RGBA = new PImage[2];
        for (int q = 0; q < numberOfImpactVariations; q++) {
          total_Image_RGBA[q] = createImage(RES1, RES2, RGB);
        }
  
        float[][][][] total_Matrix_ARGB;
        total_Matrix_ARGB = new float [2][4][RES1][RES2];
  
        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;
          
          for (int q = 0; q < numberOfImpactVariations; q++) {
            total_Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
            total_Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
          }
        }
  
        for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {
  
          now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          int DATE_ANGLE_approximate = int((DATE_ANGLE + 15) / 30) * 30;
          if (DATE_ANGLE_approximate == 360) DATE_ANGLE_approximate = 0;
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
          //println(DATE_ANGLE, DATE_ANGLE_approximate);
  
          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
          //println("j =", j);
          //println(Normals_COL_N);
  
          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays; 
  
              float[][][][] Matrix_ARGB;
  
              Matrix_ARGB = new float [2][4][RES1][RES2];
  
              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;
                
                for (int q = 0; q < numberOfImpactVariations; q++) {
                  Matrix_ARGB[q][0][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][1][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][2][Image_X][Image_Y] = FLOAT_undefined;
                  Matrix_ARGB[q][3][Image_X][Image_Y] = FLOAT_undefined;
                }
              }
  
              PImage[] Image_RGBA = new PImage[2];
              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q] = createImage(RES1, RES2, RGB);
              }
              
              int valuesNUM = 0;  
  
              for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not available out of this period. 
                if (STUDY.isInHourlyRange(i)) {
  
                  float HOUR_ANGLE = i; 
                  float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                  if (SunR[3] > 0) {
  
                    now_k = k + start_k;
                    now_i = i;
                    now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                    if (now_j >= 365) {
                      now_j = now_j % 365;
                    }
                    if (now_j < 0) {
                      now_j = (now_j + 365) % 365;
                    }
  
                    Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                    Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                    Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                    Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
          
                    if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                      values_R_dir = FLOAT_undefined;
                      values_R_dif = FLOAT_undefined;
                      values_E_dir = FLOAT_undefined;
                      values_E_dif = FLOAT_undefined;
                    } else {
  
                      int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                      
                      if (memberCount == 1) {
                        values_R_dir = 0.001 * Pa;  
                        values_R_dif = 0.001 * Pb; 
                        values_E_dir = 0.001 * Pc;
                        values_E_dif = 0.001 * Pd;
  
                        for (int RAD_TYPE = 0; RAD_TYPE <= 1; RAD_TYPE++) { 
                          float RAD_VALUE = 0;
                          float EFF_VALUE = 0;
                          if (RAD_TYPE == 0) {
                            RAD_VALUE = values_R_dir; 
                            EFF_VALUE = values_E_dir;
                          } else { 
                            //float MULT_dif = 2.0;
                            float MULT_dif = FLOAT_e; // 2.718
  
                            RAD_VALUE = values_R_dif * MULT_dif;
                            EFF_VALUE = values_E_dif * MULT_dif;
                          }
  
                          PImage[] Shadings = new PImage [2];
                          for (int SHD = 0; SHD <= 1; SHD++) {
                            String[] STR_SHD = {
                              "F", "T"
                            };
                            String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;
  
                            if (RAD_TYPE == 0) {
                              File_Name += nf(DATE_ANGLE_approximate, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);
                            } else {
                              File_Name += "DIF_" + STR_SHD[SHD];
                            }
  
                            File_Name += "_Camera" + nf(Camera_Variation, 2) + ".png";
  
  
                            println(File_Name);
                            Shadings[SHD]  = loadImage(File_Name);
                          }   
  
                          for (int np = 0; np < (RES1 * RES2); np++) {
                            int Image_X = np % RES1;
                            int Image_Y = np / RES1;
  
                            for (int q = 0; q < numberOfImpactVariations; q++) {
                              if (is_undefined_FLOAT(Matrix_ARGB[q][0][Image_X][Image_Y])) {
                              
                                Matrix_ARGB[q][0][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][1][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][2][Image_X][Image_Y] = 0;
                                Matrix_ARGB[q][3][Image_X][Image_Y] = 0;
                              }
                            }                             
  
                            color COL0 = Shadings[0].get(Image_X, Image_Y);
                            color COL1 = Shadings[1].get(Image_X, Image_Y);
                            //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                            float COL_V0 = (COL0 >> 8 & 0xFF) / 255.0; 
                            float COL_V1 = (COL1 >> 8 & 0xFF) / 255.0;
  
                            float COL_Alpha = (COL1 >> 24 & 0xFF);
  
                            Matrix_ARGB[Impact_ACTIVE][0][Image_X][Image_Y] = COL_Alpha;
                            Matrix_ARGB[Impact_PASSIVE][0][Image_X][Image_Y] = COL_Alpha;
  
                            Matrix_ARGB[Impact_ACTIVE][2][Image_X][Image_Y] += RAD_VALUE * COL_V1;
  
                            if (EFF_VALUE < 0) {
                              Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] -= EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] -= EFF_VALUE * (COL_V0 - COL_V1);
                            } else {
                              Matrix_ARGB[Impact_PASSIVE][3][Image_X][Image_Y] += EFF_VALUE * COL_V1;
                              if (COL_V0 != COL_V1) Matrix_ARGB[Impact_PASSIVE][1][Image_X][Image_Y] += EFF_VALUE * (COL_V0 - COL_V1);
                            }
  
                            if (np == 0) valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
  
              float valuesMUL = 0;
  
              if (valuesNUM != 0) {
                //valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);  
                //valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                valuesMUL = funcs.roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);
              }
  
  
              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q].loadPixels();
              }
  
              for (int np = 0; np < (RES1 * RES2); np++) {
                int Image_X = np % RES1;
                int Image_Y = np / RES1;
                
                for (int q = 0; q < numberOfImpactVariations; q++) {
  
                  float Image_A = Matrix_ARGB[q][0][Image_X][Image_Y] * valuesMUL;
                  float Image_R = Matrix_ARGB[q][1][Image_X][Image_Y] * valuesMUL;
                  float Image_G = Matrix_ARGB[q][2][Image_X][Image_Y] * valuesMUL;
                  float Image_B = Matrix_ARGB[q][3][Image_X][Image_Y] * valuesMUL;
    
                  total_Matrix_ARGB[q][0][Image_X][Image_Y] += Image_A;
                  total_Matrix_ARGB[q][1][Image_X][Image_Y] += Image_R;
                  total_Matrix_ARGB[q][2][Image_X][Image_Y] += Image_G;
                  total_Matrix_ARGB[q][3][Image_X][Image_Y] += Image_B; 
                
                  float[] _c = {
                    0, 0, 0, 0
                  };
    
                  float _u = 0;
    
                  float valuesSUM = FLOAT_undefined;
    
                  int PAL_type = 0; 
                  int PAL_direction = 1;
                  float PAL_multiplier = 1; 
    
                  if (q == Impact_ACTIVE) {
                    valuesSUM = Image_G;
    
                    PAL_type = allFaces.ACTIVE_pallet_CLR; 
                    PAL_direction = allFaces.ACTIVE_pallet_DIR;  
                    PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT;
    
                    //_u = 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                    //_u = (0.1 * PAL_multiplier * valuesSUM);
                    _u = (0.2 * PAL_multiplier * valuesSUM);
                  }
    
                  if (q == Impact_PASSIVE) {
                    float AVERAGE, PERCENTAGE, COMPARISON;
    
                    AVERAGE = (Image_B - Image_R);
                    if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
                    else PERCENTAGE = 0.0;
                    COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
    
                    valuesSUM = COMPARISON;
    
                    PAL_type = allFaces.PASSIVE_pallet_CLR; 
                    PAL_direction = allFaces.PASSIVE_pallet_DIR;
                    PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
    
                    //_u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                    _u = 0.5 + 0.5 * (0.2 * PAL_multiplier * valuesSUM);
                  }
    
    
                  //if ((Image_X == RES1 / 2) && (Image_Y == RES2 / 2)) println("Image Processing: <CENTER> valuesSUM =", valuesSUM); 
                  //if ((Image_X == RES1 - 1) && (Image_Y == RES2 - 1)) println("Image Processing: <CORNER> valuesSUM =", valuesSUM); 
    
                  if (PAL_direction == -1) _u = 1 - _u;
                  if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                  if (PAL_direction == 2) _u =  0.5 * _u;
    
                  _c = PAINT.getColorStyle(PAL_type, _u);
    
                  if (Image_A != 0) Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
                  else Image_RGBA[q].pixels[np] = color(223, 223, 223);
                }
              }
              
              for (int q = 0; q < numberOfImpactVariations; q++) {
                Image_RGBA[q].updatePixels();
  
    
                //if (Camera_Variation == 0) {
                this.Image[q][j + 1] = Image_RGBA[q];           
                if (this.record_IMG == 1) {
                  String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(j + 1, 0) + ".jpg";
                  this.Image[q][j + 1].save(myFile);
                  if (j == 0) SOLARCHVISION_explore_output(myFile);
                  println("File created:" + myFile);
                }
                //}
              }
            }
          }
        }
  
        { 
          int j = -1; // << to put the summary graph before the daily graphs
          
          for (int q = 0; q < numberOfImpactVariations; q++) {
            total_Image_RGBA[q].loadPixels();
          }
  
          for (int np = 0; np < (RES1 * RES2); np++) {
            int Image_X = np % RES1;
            int Image_Y = np / RES1;
  
            for (int q = 0; q < numberOfImpactVariations; q++) {
              
              float Image_A = total_Matrix_ARGB[q][0][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_R = total_Matrix_ARGB[q][1][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_G = total_Matrix_ARGB[q][2][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
              float Image_B = total_Matrix_ARGB[q][3][Image_X][Image_Y] / (1.0 * (STUDY.j_End - STUDY.j_Start));
  
              float[] _c = {
                0, 0, 0, 0
              };
    
              float _u = 0;
    
              float valuesSUM = FLOAT_undefined;
  
              int PAL_type = 0; 
              int PAL_direction = 1;
              float PAL_multiplier = 1; 
    
              if (q == Impact_ACTIVE) {
                valuesSUM = Image_G;
    
                PAL_type = allFaces.ACTIVE_pallet_CLR; 
                PAL_direction = allFaces.ACTIVE_pallet_DIR;  
                PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT;
    
                //_u = 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                //_u = (0.1 * PAL_multiplier * valuesSUM);
                _u = (0.2 * PAL_multiplier * valuesSUM);
              }
    
              if (q == Impact_PASSIVE) {
                float AVERAGE, PERCENTAGE, COMPARISON;
    
                AVERAGE = (Image_B - Image_R);
                if ((Image_B + Image_R) > 0.00001) PERCENTAGE = (Image_B - Image_R) / (1.0 * (Image_B + Image_R)); 
                else PERCENTAGE = 0.0;
                COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
     
                valuesSUM = COMPARISON;
    
                PAL_type = allFaces.PASSIVE_pallet_CLR; 
                PAL_direction = allFaces.PASSIVE_pallet_DIR;
                PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
    
                //_u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
                _u = 0.5 + 0.5 * (0.2 * PAL_multiplier * valuesSUM);
              }
    
              if (PAL_direction == -1) _u = 1 - _u;
              if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
              if (PAL_direction == 2) _u =  0.5 * _u;
    
              _c = PAINT.getColorStyle(PAL_type, _u);
    
              if (Image_A != 0) total_Image_RGBA[q].pixels[np] = color(_c[1], _c[2], _c[3]);
              else total_Image_RGBA[q].pixels[np] = color(223, 223, 223);
            }
          }
          
          for (int q = 0; q < numberOfImpactVariations; q++) {
    
            total_Image_RGBA[q].updatePixels(); 
    
            //if (Camera_Variation == 0) {
            this.Image[q][0] = total_Image_RGBA[q];           
            if (this.record_IMG == 1) {
              String myFile = getFilename_SolarImpact() + "_solar_" + nf(q, 1) + "_" + nf(0, 0) + ".jpg";
              this.Image[q][0].save(myFile);
              //SOLARCHVISION_explore_output(myFile);
              println("File created:" + myFile);
            }
            //}
          }
        }
      }
  
      cursor(ARROW);
    }
  }
  
  
  
  void render_Shadows_selectedSections () {
  
    for (int o = userSelections.Section_ids.length - 1; o >= 0; o--) {
  
      int f = userSelections.Section_ids[o];
  
      this.sectionType = allSections.Type[f];
      this.RES1 = allSections.RES1[f];
      this.RES2 = allSections.RES2[f];     
  
      this.U_offset = allSections.UVERAB[f][0];
      this.V_offset = allSections.UVERAB[f][1];
      this.elevation = 0.1 + allSections.UVERAB[f][2];
      this.rotation = allSections.UVERAB[f][3];
      this.U_scale = allSections.UVERAB[f][4];
      this.V_scale = allSections.UVERAB[f][5];
  
      SceneName = "Section_" + Section_Stamp();
  
      SOLARCHVISION_render_Shadows_CurrentSection();
    }
  
    this.displayImage = true;
    allSolidImpacts.displayImage = false;
    ROLLOUT.update = true;
  }
  
  
  
  
  void calculate_Impact_selectedSections () {
  
    for (int o = userSelections.Section_ids.length - 1; o >= 0; o--) {
  
      int f = userSelections.Section_ids[o];
  
      this.sectionType = allSections.Type[f];
      this.RES1 = allSections.RES1[f];
      this.RES2 = allSections.RES2[f];     
  
      this.U_offset = allSections.UVERAB[f][0];
      this.V_offset = allSections.UVERAB[f][1];
      this.elevation = 0.1 + allSections.UVERAB[f][2];
      this.rotation = allSections.UVERAB[f][3];
      this.U_scale = allSections.UVERAB[f][4];
      this.V_scale = allSections.UVERAB[f][5];
  
      SceneName = "Section_" + Section_Stamp();
  
      this.calculate_Impact_CurrentPreBaked();
      
      
      for (int j = STUDY.j_Start - 1; j < STUDY.j_End; j++) {
        for (int q = 0; q < numberOfImpactVariations; q++) {
          allSections.SolarImpact[f][j + 1][q] = createImage(this.RES1, this.RES2, RGB);
  
          allSections.SolarImpact[f][j + 1][q].copy(this.Image[q][j + 1], 0, 0, this.RES1, this.RES2, 0, 0, this.RES1, this.RES2);
        }
      }
    }
  }
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setString("displayImage", Boolean.toString(this.displayImage));
    parent.setInt("sectionType", this.sectionType);
    parent.setFloat("rotation", this.rotation);
    parent.setFloat("U_scale", this.U_scale);
    parent.setFloat("V_scale", this.V_scale);
    parent.setFloat("U_offset", this.U_offset);
    parent.setFloat("V_offset", this.V_offset);  
    parent.setInt("RES1", this.RES1);
    parent.setInt("RES2", this.RES2);
    parent.setFloat("elevation", this.elevation);      

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displayImage = Boolean.parseBoolean(parent.getString("displayImage"));
    this.sectionType = parent.getInt("sectionType");
    this.rotation = parent.getFloat("rotation");
    this.U_scale = parent.getFloat("U_scale");
    this.V_scale = parent.getFloat("V_scale");
    this.U_offset = parent.getFloat("U_offset");
    this.V_offset = parent.getFloat("V_offset");      
    this.RES1 = parent.getInt("RES1");
    this.RES2 = parent.getInt("RES2");
    this.elevation = parent.getFloat("elevation");
  }      


}

solarchvision_SolarImpacts allSolarImpacts = new solarchvision_SolarImpacts();   






class solarchvision_Selections {
  
  private final static String CLASS_STAMP = "Selections";

  int posVector = 2; // 0:X, 1:Y, 2:Z, 3: All
  int rotVector = 2; // 0:X, 1:Y, 2:Z
  int scaleVector = 2; // 0:X, 1:Y, 2:Z, 3:All
  
  float posValue = 0;
  float rotValue = 0;  
  float scaleValue = 0; 
  
  int alignX = 0;
  int alignY = 0;
  int alignZ = 0;
  
  
  boolean displayReferencePivot = true;
  
  boolean Group_displayPivot = true;
  boolean Group_displayEdges = false; 
  boolean Group_displayBox = true;
  
  boolean Face_displayEdges = true;
  boolean Face_displayVertexCount = false;
  boolean Curve_displayVertexCount = false;
  boolean Vertex_displayVertices = true;
  boolean Curve_displayVertices = true;
  
  
  boolean Model2D_displayEdges = true;
  boolean Model1D_displayEdges = true;
  boolean Solid_displayEdges = true;
  boolean Section_displayEdges = true;
  boolean Camera_displayEdges = true;
  boolean LandPoint_displayPoints = true;
  
  int[] LandPoint_ids = new int[0];
  int[] Camera_ids = new int[0];
  int[] Section_ids = new int[0];
  int[] Solid_ids = new int[0];
  int[] Model1D_ids = new int[0];
  int[] Model2D_ids = new int[0];
  int[] Group_ids = new int[0];
  int[] Face_ids = new int[0];
  int[] Vertex_ids = new int[0];
  int[] Curve_ids = new int[0];
  
  int[] Vertex_softSelectionVertices = new int[0]; 
  float[] Vertex_softSelectionValues = new float[0];
  
  float softPower = 1;
  float softRadius = 2; // 2 = 2m
  
  
  float[][] BoundingBox = {
    {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
    , {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
    , {
      0, 0, 0, 1, 1, 1, 0, 0, 0
    }
  }; // [min|mid|max]
  

  
  int[] get_Face_Vertices () {
  
    int[] FaceVertices = new int [0];
  
    for (int o = this.Face_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Face_ids[o];
  
      int f = OBJ_NUM;
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
  
        int vertex_listed = -1;
  
        for (int q = 0; q < FaceVertices.length; q++) {
          if (vNo == FaceVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }         
  
        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          FaceVertices = concat(FaceVertices, newVertexListed);
        }
      }
    }
  
  
    return FaceVertices;
  } 
  
  
  int[] get_Curve_Vertices () {
  
    int[] CurveVertices = new int [0];
  
    for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Curve_ids[o];
  
      int f = OBJ_NUM;
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
        int vNo = allCurves.nodes[f][j];
  
        int vertex_listed = -1;
  
        for (int q = 0; q < CurveVertices.length; q++) {
          if (vNo == CurveVertices[q]) {
            vertex_listed = 1;
            break;
          }
        }         
  
        if (vertex_listed == -1) {
          int[] newVertexListed = {
            vNo
          };
          CurveVertices = concat(CurveVertices, newVertexListed);
        }
      }
    }
  
    return CurveVertices;
  } 
  
  
  
  int[] get_Group_Vertices () {
  
    int[] PolymeshVertices = new int [0];
  
    for (int o = this.Group_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Group_ids[o];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
  
        if ((0 <= f) && (f < allFaces.nodes.length)) { 
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
            int vNo = allFaces.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
  
  
  
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
  
        if ((0 <= f) && (f < allCurves.nodes.length)) { 
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
            int vNo = allCurves.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices.length; q++) {
              if (vNo == PolymeshVertices[q]) {
                vertex_listed = 1;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices = concat(PolymeshVertices, newVertexListed);
            }
          }
        }
      }
    }    
  
    return PolymeshVertices;
  }   
    
    
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
    
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Face_ids.length][7];
  
    for (int o = 0; o < this.Face_ids.length; o++) {
      hitPoint[o][0] = FLOAT_undefined;
      hitPoint[o][1] = FLOAT_undefined;
      hitPoint[o][2] = FLOAT_undefined;
      hitPoint[o][3] = FLOAT_undefined;
      hitPoint[o][4] = FLOAT_undefined;
      hitPoint[o][5] = FLOAT_undefined;
      hitPoint[o][6] = FLOAT_undefined;
    }
    
    
    for (int o = 0; o < this.Face_ids.length; o++) {
      
      int f = this.Face_ids[o];     
      
      if (f > 0) {  
  
        int n = allFaces.nodes[f].length;
        
        if (n > 2) {
          
          int vsb = allFaces.getVisibility(f);
      
          if (vsb > 0) {    
    
            float X_intersect = FLOAT_undefined;         
            float Y_intersect = FLOAT_undefined;
            float Z_intersect = FLOAT_undefined;
            float dist2intersect = FLOAT_undefined;
            float[] face_norm = {0,0,0};
            
            boolean InPoly = false;
            
            if (n < 5) { // works if n==3 or n==4
        
              float[] A = allPoints.getPosition(allFaces.nodes[f][0]);
              float[] B = allPoints.getPosition(allFaces.nodes[f][1]);
              float[] C = allPoints.getPosition(allFaces.nodes[f][n - 2]);
              float[] D = allPoints.getPosition(allFaces.nodes[f][n - 1]);
              
              float[] AC = funcs.vec3_diff(A, C);
              float[] BD = funcs.vec3_diff(B, D);
              
              face_norm = funcs.vec3_cross(AC, BD);
              
              float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
            
              float R = -funcs.vec3_dot(ray_dir, face_norm);
        
              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
        
                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {
      
                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                  
                  float[] P = {X_intersect, Y_intersect, Z_intersect};
                  
                  if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                  else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case
    
                }
              }
            }
            else {        
    
              int[] tmpFace = new int[n];
              float[] G = {
                0, 0, 0
              }; 
              for (int j = 0; j < n; j++) {
                tmpFace[j] = allFaces.nodes[f][j];
                G[0] += allPoints.getX(tmpFace[j]) / float(n); 
                G[1] += allPoints.getY(tmpFace[j]) / float(n);
                G[2] += allPoints.getZ(tmpFace[j]) / float(n);
              }  
              
              for (int j = 0; j < n; j++) {
        
                int j_next = (j + 1) % n;
        
                float[] A = {
                  allPoints.getX(allFaces.nodes[f][j]),
                  allPoints.getY(allFaces.nodes[f][j]),
                  allPoints.getZ(allFaces.nodes[f][j])
                };            
                
                float[] B = {
                  allPoints.getX(allFaces.nodes[f][j_next]),
                  allPoints.getY(allFaces.nodes[f][j_next]),
                  allPoints.getZ(allFaces.nodes[f][j_next])
                };                
      
                float[] AG = funcs.vec3_diff(A, G);
                float[] BG = funcs.vec3_diff(B, G);
                
                face_norm = funcs.vec3_cross(AG, BG);
                  
                float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
                
                float R = -funcs.vec3_dot(ray_dir, face_norm);
          
                if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                  dist2intersect = FLOAT_huge;
                }
                else {
                  dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
          
                  //if (dist2intersect > 0) {
                  if (dist2intersect > FLOAT_tiny) {
        
                    X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                    Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                    Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                    
                    float[] P = {X_intersect, Y_intersect, Z_intersect};
      
                    InPoly = funcs.isInside_Triangle(P, A, B, G); 
                    
                  }
                }
                
                if (InPoly) break;
              }
            }
                  
            if (InPoly) {
              hitPoint[f][0] = X_intersect;
              hitPoint[f][1] = Y_intersect;
              hitPoint[f][2] = Z_intersect;
              hitPoint[f][3] = dist2intersect;
              hitPoint[f][4] = face_norm[0];
              hitPoint[f][5] = face_norm[1];
              hitPoint[f][6] = face_norm[2];             
            }               
    
          }
        }
      }
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int o = 0; o < this.Face_ids.length; o++) {
      
      if (pre_dist > hitPoint[o][3]) {
  
        pre_dist = hitPoint[o][3];
  
        return_point[0] = o;
        return_point[1] = hitPoint[o][0];
        return_point[2] = hitPoint[o][1];
        return_point[3] = hitPoint[o][2];
        return_point[4] = hitPoint[o][3];
        return_point[5] = hitPoint[o][4];
        return_point[6] = hitPoint[o][5];
        return_point[7] = hitPoint[o][6];
  
      }
  
    }
  
    return return_point;
  }
    
    
    
  
  void calculate_selection_BoundingBox () {
  
    int keep_selection_alignX = this.alignX;
    int keep_selection_alignY = this.alignY;
    int keep_selection_alignZ = this.alignZ;
  
    this.alignX = 0; // apply the centre
    this.alignY = 0; // apply the centre
    this.alignZ = 0; // apply the centre
  
    int[] theVertices = new int [0];
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      theVertices = this.Camera_ids;
    } 
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
      theVertices = this.Section_ids;
    } 
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
      theVertices = this.Solid_ids;
    } 
  
    if ((current_ObjectCategory == ObjectCategory.VERTEX) || (current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {
      theVertices = this.Vertex_ids;
    }
    if (current_ObjectCategory == ObjectCategory.FACE) {
      theVertices = this.get_Face_Vertices();
    }  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
      theVertices = this.get_Curve_Vertices();
    }    
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      theVertices = this.get_Group_Vertices();
    }
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      theVertices = this.Model2D_ids;
    }
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      theVertices = this.Model1D_ids;
    }  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      theVertices = this.LandPoint_ids;
    }    
  
    float posX = 0;
    float posY = 0;
    float posZ = 0;
  
    float scaleX = 1; 
    float scaleY = 1; 
    float scaleZ = 1; 
  
    float rotX = 0;
    float rotY = 0;
    float rotZ = 0;
  
    if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
      if (this.Group_ids.length > 0) {
      
        int o = this.Group_ids.length - 1; // applying the local coordinates of the last selected object <<<<<<<<<<<<<<<<<<<<<<<
    
        int OBJ_NUM = this.Group_ids[o];
    
        posX = allGroups.PivotMatrix[OBJ_NUM][0];
        posY = allGroups.PivotMatrix[OBJ_NUM][1];
        posZ = allGroups.PivotMatrix[OBJ_NUM][2];
    
        scaleX = allGroups.PivotMatrix[OBJ_NUM][3];
        scaleY = allGroups.PivotMatrix[OBJ_NUM][4];
        scaleZ = allGroups.PivotMatrix[OBJ_NUM][5];
    
        rotX = allGroups.PivotMatrix[OBJ_NUM][6];
        rotY = allGroups.PivotMatrix[OBJ_NUM][7];
        rotZ = allGroups.PivotMatrix[OBJ_NUM][8];
      }
    }
  
  
    for (int i = 0; i < 3; i++) {
      float ratio = 0.5 * i;
      this.BoundingBox[i][0] = posX;
      this.BoundingBox[i][1] = posY;
      this.BoundingBox[i][2] = posZ;
  
      this.BoundingBox[i][3] = scaleX;
      this.BoundingBox[i][4] = scaleY;
      this.BoundingBox[i][5] = scaleZ;
  
      this.BoundingBox[i][6] = rotX;
      this.BoundingBox[i][7] = rotY;
      this.BoundingBox[i][8] = rotZ;
    }   
  
  
    float posX_min = FLOAT_undefined;
    float posY_min = FLOAT_undefined;
    float posZ_min = FLOAT_undefined;
  
    float posX_max = -FLOAT_undefined;  
    float posY_max = -FLOAT_undefined;  
    float posZ_max = -FLOAT_undefined;
  
  
  
    for (int q = 0; q < theVertices.length; q++) {
  
      float x = 0;
      float y = 0;
      float z = 0;
  
      if (current_ObjectCategory == ObjectCategory.CAMERA) {
        int n = theVertices[q];
  
        if (n < allCameras.num) {
  
          float Camera_pX = allCameras.options[n][0];
          float Camera_pY = allCameras.options[n][1];
          float Camera_pZ = allCameras.options[n][2];
          float Camera_pT = allCameras.options[n][3];
          float Camera_rX = allCameras.options[n][4];
          float Camera_rY = allCameras.options[n][5];
          float Camera_rZ = allCameras.options[n][6];
          float Camera_rT = allCameras.options[n][7];
          float Camera_ZOOM = allCameras.options[n][8];
  
          int Camera_type = allCameras.Type[n];
  
          float[][] ImageVertex = allCameras.getCorners(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_ZOOM);
  
          // the first vertex is the Camera point
          x = ImageVertex[0][0]; 
          y = ImageVertex[0][1]; 
          z = ImageVertex[0][2];
        }
      }  
  
      if (current_ObjectCategory == ObjectCategory.SECTION) {
        int n = theVertices[q];
  
        if (n < allSections.num) {
  
          float Section_U_offset = allSections.UVERAB[n][0];
          float Section_V_offset = allSections.UVERAB[n][1];
          float Section_elevation = allSections.UVERAB[n][2];
          float Section_rotation = allSections.UVERAB[n][3];
          float Section_U_scale = allSections.UVERAB[n][4];
          float Section_V_scale = allSections.UVERAB[n][5];
  
          int Section_Type = allSections.Type[n];
          int Section_RES1 = allSections.RES1[n];
          int Section_RES2 = allSections.RES2[n];
  
          float[][] ImageVertex = allSections.getCorners(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
  
          // the first vertex is the center of Section plane
          x = ImageVertex[0][0]; 
          y = ImageVertex[0][1]; 
          z = ImageVertex[0][2];
        }
      }  
  
      if (current_ObjectCategory == ObjectCategory.SOLID) {
        int n = theVertices[q];
  
        if (n < allSolids.DEF.length) {
  
          float Solid_posX = allSolids.get_posX(n);
          float Solid_posY = allSolids.get_posY(n);
          float Solid_posZ = allSolids.get_posZ(n);
          float Solid_powX = allSolids.get_powX(n);
          float Solid_powY = allSolids.get_powY(n);
          float Solid_powZ = allSolids.get_powZ(n);
          float Solid_scaleX = allSolids.get_scaleX(n);
          float Solid_scaleY = allSolids.get_scaleY(n);
          float Solid_scaleZ = allSolids.get_scaleZ(n);
          float Solid_rotX = allSolids.get_rotX(n);
          float Solid_rotY = allSolids.get_rotY(n);
          float Solid_rotZ = allSolids.get_rotZ(n);
          float Solid_value = allSolids.get_value(n);
  
          float[][] ImageVertex = allSolids.getCorners(0, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
          // the first vertex is the center of Solid plane
          x = ImageVertex[0][0]; 
          y = ImageVertex[0][1]; 
          z = ImageVertex[0][2];
        }
      }  
  
  
      if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX) || (current_ObjectCategory == ObjectCategory.SOFTVERTEX)) {
        int n = theVertices[q];
  
        x = allPoints.getX(n);
        y = allPoints.getY(n);
        z = allPoints.getZ(n);
      }
      if (current_ObjectCategory == ObjectCategory.MODEL2D) {
        int n = theVertices[q];
  
        x = allModel2Ds.getX(n);
        y = allModel2Ds.getY(n);
        z = allModel2Ds.getZ(n);
      }     
      if (current_ObjectCategory == ObjectCategory.MODEL1D) {
        int n = theVertices[q];
  
        x = allModel1Ds.getX(n);
        y = allModel1Ds.getY(n);
        z = allModel1Ds.getZ(n);
      }  
      if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
        int n = theVertices[q];
  
        int OBJ_NUM = n;
  
        int the_i = OBJ_NUM / Land3D.num_columns;
        int the_j = OBJ_NUM % Land3D.num_columns;
  
        x = Land3D.Mesh[the_i][the_j][0];
        y = Land3D.Mesh[the_i][the_j][1];
        z = Land3D.Mesh[the_i][the_j][2];
  
      }             
  
  
  
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = A[0];
      y = A[1];
      z = A[2];
  
  
      if (posX_min > x) posX_min = x;   
      if (posY_min > y) posY_min = y;   
      if (posZ_min > z) posZ_min = z;
  
      if (posX_max < x) posX_max = x;   
      if (posY_max < y) posY_max = y;   
      if (posZ_max < z) posZ_max = z;
    }   
  
    if ((posX_min != FLOAT_undefined) && (posX_max != -FLOAT_undefined) && (posY_min != FLOAT_undefined) && (posY_max != -FLOAT_undefined) && (posZ_min != FLOAT_undefined) && (posZ_max != -FLOAT_undefined)) {
  
      float dx = posX;
      float dy = posY;
      float dz = posZ;
  
      posX_min += dx;
      posY_min += dy;
      posZ_min += dz;    
  
      posX_max += dx;
      posY_max += dy;
      posZ_max += dz;   
  
      for (int i = 0; i < 3; i++) {
        float ratio = 0.5 * i;
        this.BoundingBox[i][0] = (1 - ratio) * posX_min + ratio * posX_max;
        this.BoundingBox[i][1] = (1 - ratio) * posY_min + ratio * posY_max;
        this.BoundingBox[i][2] = (1 - ratio) * posZ_min + ratio * posZ_max;
  
        this.BoundingBox[i][3] = scaleX;
        this.BoundingBox[i][4] = scaleY;
        this.BoundingBox[i][5] = scaleZ;
  
        this.BoundingBox[i][6] = rotX;
        this.BoundingBox[i][7] = rotY;
        this.BoundingBox[i][8] = rotZ;
      }
    }
  
  
  
    this.alignX = keep_selection_alignX;
    this.alignY = keep_selection_alignY;
    this.alignZ = keep_selection_alignZ;
  }
  
  
  
  void save_current_BoundingBox () {
  
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 9; j++) {
        saved_BoundingBox[i][j] = this.BoundingBox[i][j];
      }
    } 
  
    saved_alignX = this.alignX;
    saved_alignY = this.alignY;
    saved_alignZ = this.alignZ;
  }
  
  
  void apply_saved_BoundingBox () {
  
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 9; j++) {
        this.BoundingBox[i][j] = saved_BoundingBox[i][j];
      }
    } 
  
    this.alignX = saved_alignX;
    this.alignY = saved_alignY;
    this.alignZ = saved_alignZ;
  }
  
  
  void apply_origin_ReferenceBox () {
  
    for (int i = 0; i < 3; i++) {
      this.BoundingBox[i][0] = 0;
      this.BoundingBox[i][1] = 0;
      this.BoundingBox[i][2] = 0;
      this.BoundingBox[i][3] = 1;
      this.BoundingBox[i][4] = 1;
      this.BoundingBox[i][5] = 1;
      this.BoundingBox[i][6] = 0;
      this.BoundingBox[i][7] = 0;
      this.BoundingBox[i][8] = 0;
    }
  
    //this.alignX = 0;
    //this.alignY = 0;
    //this.alignZ = 0;
  }
  
  
  
  
  void reset_selectedRefValues () {
  
    this.posValue = 0;  
    this.rotValue = 0;  
    this.scaleValue = 0;
  }
    
    
    
  
  
  
  
  
  void move_selectedGroups (float dx, float dy, float dz) {
  
    int[] PolymeshVertices = this.get_Group_Vertices();
  
    for (int q = 0; q < PolymeshVertices.length; q++) {
  
      int n = PolymeshVertices[q];
  
      allPoints.addX(n, dx); 
      allPoints.addY(n, dy);
      allPoints.addZ(n, dz);
    }
  
    boolean allSolids_updated = false;
  
    for (int o = this.Group_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Group_ids[o];
  
      {
        allGroups.PivotMatrix[OBJ_NUM][0] += dx;
        allGroups.PivotMatrix[OBJ_NUM][1] += dy;
        allGroups.PivotMatrix[OBJ_NUM][2] += dz;
      }
  
      for (int f = allGroups.Model1Ds[OBJ_NUM][0]; f <= allGroups.Model1Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {
  
          allModel1Ds.addX(f, dx);
          allModel1Ds.addY(f, dy);
          allModel1Ds.addZ(f, dz);
        }
      }
  
      for (int f = allGroups.Model2Ds[OBJ_NUM][0]; f <= allGroups.Model2Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {
  
          allModel2Ds.addX(f, dx);
          allModel2Ds.addY(f, dy);
          allModel2Ds.addZ(f, dz);
        }
      }
  
      for (int f = allGroups.Solids[OBJ_NUM][0]; f <= allGroups.Solids[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {
  
          float Solid_posX = allSolids.get_posX(f);
          float Solid_posY = allSolids.get_posY(f);
          float Solid_posZ = allSolids.get_posZ(f);
  
          allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);
  
          allSolids_updated = true;
        }
      }
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  void rotate_selectedGroups (float r, int the_Vector) {
  
    int[] PolymeshVertices = this.get_Group_Vertices();
  
    for (int q = 0; q < PolymeshVertices.length; q++) {
  
      int n = PolymeshVertices[q];
  
      float x = allPoints.getX(n); 
      float y = allPoints.getY(n); 
      float z = allPoints.getZ(n);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = A[0];
      y = A[1];
      z = A[2];
  
      {
        float a = x;
        float b = y;
        float c = z;
  
        if (the_Vector == 2) {
          a = x * cos(r) - y * sin(r); 
          b = x * sin(r) + y * cos(r);
          c = z;
        } else if (the_Vector == 1) {
          a = z * sin(r) + x * cos(r); 
          b = y;
          c = z * cos(r) - x * sin(r);
        } else if (the_Vector == 0) {
          a = x;
          b = y * cos(r) - z * sin(r);
          c = y * sin(r) + z * cos(r);
        }   
  
        x = a;
        y = b;
        z = c;
      }
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];
  
      allPoints.setX(n, x); 
      allPoints.setY(n, y);
      allPoints.setZ(n, z);
    }
  
  
  
  
  
  
    boolean allSolids_updated = false;
  
    for (int o = this.Group_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Group_ids[o];
  
      { 
        float x = allGroups.PivotMatrix[OBJ_NUM][0]; 
        float y = allGroups.PivotMatrix[OBJ_NUM][1]; 
        float z = allGroups.PivotMatrix[OBJ_NUM][2];
  
        float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
        x = A[0];
        y = A[1];
        z = A[2];
  
        {
          float a = x;
          float b = y;
          float c = z;
  
          if (the_Vector == 2) {
            a = x * cos(r) - y * sin(r); 
            b = x * sin(r) + y * cos(r);
            c = z;
          } else if (the_Vector == 1) {
            a = z * sin(r) + x * cos(r); 
            b = y;
            c = z * cos(r) - x * sin(r);
          } else if (the_Vector == 0) {
            a = x;
            b = y * cos(r) - z * sin(r);
            c = y * sin(r) + z * cos(r);
          }   
  
          x = a;
          y = b;
          z = c;
        }
  
        float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
        x = B[0];
        y = B[1];
        z = B[2];
  
        allGroups.PivotMatrix[OBJ_NUM][0] = x;
        allGroups.PivotMatrix[OBJ_NUM][1] = y;
        allGroups.PivotMatrix[OBJ_NUM][2] = z;
  
        if (the_Vector == 2) {
          allGroups.PivotMatrix[OBJ_NUM][8] += r * 180.0 / PI;
        } else if (the_Vector == 1) {
          allGroups.PivotMatrix[OBJ_NUM][7] += r * 180.0 / PI;
        } else if (the_Vector == 0) {
          allGroups.PivotMatrix[OBJ_NUM][6] += r * 180.0 / PI;
        }
      }    
  
  
      for (int f = allGroups.Model1Ds[OBJ_NUM][0]; f <= allGroups.Model1Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {
  
          float x = allModel1Ds.getX(f); 
          float y = allModel1Ds.getY(f); 
          float z = allModel1Ds.getZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = A[0];
          y = A[1];
          z = A[2];
  
          {
            float a = x;
            float b = y;
            float c = z;
  
            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   
  
            x = a;
            y = b;
            z = c;
          }
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0];
          y = B[1];
          z = B[2];
  
          allModel1Ds.setX(f, x);
          allModel1Ds.setY(f, y);
          allModel1Ds.setZ(f, z);
  
  
          if (the_Vector == 2) {
            allModel1Ds.setR(f, allModel1Ds.getR(f) + r); // <<<<<<<<<
          } else if (the_Vector == 1) {
          } else if (the_Vector == 0) {
          }
        }
      }         
  
      for (int f = allGroups.Model2Ds[OBJ_NUM][0]; f <= allGroups.Model2Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {
  
          float x = allModel2Ds.getX(f); 
          float y = allModel2Ds.getY(f); 
          float z = allModel2Ds.getZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = A[0];
          y = A[1];
          z = A[2];
  
          {
            float a = x;
            float b = y;
            float c = z;
  
            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   
  
            x = a;
            y = b;
            z = c;
          }
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0];
          y = B[1];
          z = B[2];
  
          allModel2Ds.setX(f, x);
          allModel2Ds.setY(f, y);
          allModel2Ds.setZ(f, z);
        }
      }         
  
      for (int f = allGroups.Solids[OBJ_NUM][0]; f <= allGroups.Solids[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {
  
          float x = allSolids.get_posX(f);
          float y = allSolids.get_posY(f);
          float z = allSolids.get_posZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = A[0];
          y = A[1];
          z = A[2];
  
          {
            float a = x;
            float b = y;
            float c = z;
  
            if (the_Vector == 2) {
              a = x * cos(r) - y * sin(r); 
              b = x * sin(r) + y * cos(r);
              c = z;
            } else if (the_Vector == 1) {
              a = z * sin(r) + x * cos(r); 
              b = y;
              c = z * cos(r) - x * sin(r);
            } else if (the_Vector == 0) {
              a = x;
              b = y * cos(r) - z * sin(r);
              c = y * sin(r) + z * cos(r);
            }   
  
            x = a;
            y = b;
            z = c;
          }
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0];
          y = B[1];
          z = B[2];
  
  
          allSolids.updatePosition(f, x, y, z);
  
          // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Note: these rotations could be translated to locals to avoid problems!
          if (the_Vector == 2) {
            allSolids.RotateZ(f, r * 180 / PI);
          } else if (the_Vector == 1) {
            allSolids.RotateY(f, r * 180 / PI);
          } else if (the_Vector == 0) {
            allSolids.RotateX(f, r * 180 / PI);
          }
  
          allSolids_updated = true;
        }
      }
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  
  
  void scale_selectedGroups (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    int[] PolymeshVertices = this.get_Group_Vertices();
  
    for (int q = 0; q < PolymeshVertices.length; q++) {
  
      int n = PolymeshVertices[q];
  
      float x = allPoints.getX(n); 
      float y = allPoints.getY(n); 
      float z = allPoints.getZ(n);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];
  
      allPoints.setX(n, x); 
      allPoints.setY(n, y);
      allPoints.setZ(n, z);
    }
  
    int n1 = allModel2Ds.num_files_PEOPLE;
  
    boolean allSolids_updated = false;
  
    for (int o = this.Group_ids.length - 1; o >= 0; o--) {
  
      int OBJ_NUM = this.Group_ids[o];
  
      {
        float x = allGroups.PivotMatrix[OBJ_NUM][0]; 
        float y = allGroups.PivotMatrix[OBJ_NUM][1]; 
        float z = allGroups.PivotMatrix[OBJ_NUM][2];
  
        float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
        x = sx * (A[0] - x0) + x0;
        y = sy * (A[1] - y0) + y0;
        z = sz * (A[2] - z0) + z0;
  
        float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
        x = B[0];
        y = B[1];
        z = B[2];
  
        allGroups.PivotMatrix[OBJ_NUM][0] = x; 
        allGroups.PivotMatrix[OBJ_NUM][1] = y;
        allGroups.PivotMatrix[OBJ_NUM][2] = z;        
  
        // ???????
        //allGroups.PivotMatrix[OBJ_NUM][3] *= sx; 
        //allGroups.PivotMatrix[OBJ_NUM][4] *= sy;
        //allGroups.PivotMatrix[OBJ_NUM][5] *= sz;
        // ???????
      }
  
  
      for (int f = allGroups.Model1Ds[OBJ_NUM][0]; f <= allGroups.Model1Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel1Ds.num)) {
  
          float x = allModel1Ds.getX(f);
          float y = allModel1Ds.getY(f); 
          float z = allModel1Ds.getZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0];
          y = B[1];
          z = B[2];
  
          allModel1Ds.setX(f, x);
          allModel1Ds.setY(f, y);
          allModel1Ds.setZ(f, z);
  
          allModel1Ds.magS(f, sz);
        }
      }  
  
  
      for (int f = allGroups.Model2Ds[OBJ_NUM][0]; f <= allGroups.Model2Ds[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allModel2Ds.num)) {
  
          float x = allModel2Ds.getX(f);
          float y = allModel2Ds.getY(f); 
          float z = allModel2Ds.getZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0];
          y = B[1];
          z = B[2];         
  
          allModel2Ds.setX(f, x); 
          allModel2Ds.setY(f, y);
          allModel2Ds.setZ(f, z);
  
          int n = allModel2Ds.MAP[f];
  
          if (abs(n) > n1) { // does not scale poeple!    
            allModel2Ds.magS(f, sz);
          }
        }
      }     
  
      for (int f = allGroups.Solids[OBJ_NUM][0]; f <= allGroups.Solids[OBJ_NUM][1]; f++) {
        if ((0 <= f) && (f < allSolids.DEF.length)) {
  
          float x = allSolids.get_posX(f);
          float y = allSolids.get_posY(f);
          float z = allSolids.get_posZ(f);
  
          float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
          x = sx * (A[0] - x0) + x0;
          y = sy * (A[1] - y0) + y0;
          z = sz * (A[2] - z0) + z0;
  
          float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
          x = B[0]; 
          y = B[1];
          z = B[2];
  
          allSolids.updatePosition(f, x, y, z);
  
          allSolids.Scale(f, sx, sy, sz);
  
          allSolids_updated = true;
        }
      }
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  
  
  void move_selectedFaces (float dx, float dy, float dz) {
  
    int[] FaceVertices = this.get_Face_Vertices();
  
    for (int q = 0; q < FaceVertices.length; q++) {
  
      int f = FaceVertices[q];
  
      allPoints.addX(f, dx); 
      allPoints.addY(f, dy);
      allPoints.addZ(f, dz);
    }
  }
  
  void rotate_selectedFaces (float x0, float y0, float z0, float r, int the_Vector) {
  
    int[] FaceVertices = this.get_Face_Vertices();
  
    for (int q = 0; q < FaceVertices.length; q++) {
  
      int f = FaceVertices[q];
  
      float x = allPoints.getX(f) - x0; 
      float y = allPoints.getY(f) - y0; 
      float z = allPoints.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r))); 
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r))); 
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x)); 
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }
  }
  
  void scale_selectedFaces (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    int[] FaceVertices = this.get_Face_Vertices();
  
    for (int q = 0; q < FaceVertices.length; q++) {
  
      int f = FaceVertices[q];
  
      float x = allPoints.getX(f);
      float y = allPoints.getY(f);
      float z = allPoints.getZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];    
  
      allPoints.setX(f, x); 
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }
  }
  
  
  void move_selectedCurves (float dx, float dy, float dz) {
  
    int[] CurveVertices = this.get_Curve_Vertices();
  
    for (int q = 0; q < CurveVertices.length; q++) {
  
      int f = CurveVertices[q];
  
      allPoints.addX(f, dx); 
      allPoints.addY(f, dy);
      allPoints.addZ(f, dz);
    }
  }
  
  void rotate_selectedCurves (float x0, float y0, float z0, float r, int the_Vector) {
  
    int[] CurveVertices = this.get_Curve_Vertices();
  
    for (int q = 0; q < CurveVertices.length; q++) {
  
      int f = CurveVertices[q];
  
      float x = allPoints.getX(f) - x0; 
      float y = allPoints.getY(f) - y0; 
      float z = allPoints.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r))); 
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r))); 
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x)); 
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }
  }
  
  void scale_selectedCurves (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    int[] CurveVertices = this.get_Curve_Vertices();
  
    for (int q = 0; q < CurveVertices.length; q++) {
  
      int f = CurveVertices[q];
  
      float x = allPoints.getX(f);
      float y = allPoints.getY(f);
      float z = allPoints.getZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];    
  
      allPoints.setX(f, x); 
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }
  }
  
  void move_selectedVertices (float dx, float dy, float dz) {
  
    for (int q = 0; q < this.Vertex_ids.length; q++) {
  
      int f = this.Vertex_ids[q];
  
      allPoints.addX(f, dx); 
      allPoints.addY(f, dy);
      allPoints.addZ(f, dz);
    }
  }
  
  
  void rotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {
  
    for (int q = 0; q < this.Vertex_ids.length; q++) {
  
      int f = this.Vertex_ids[q];
  
      float x = allPoints.getX(f) - x0; 
      float y = allPoints.getY(f) - y0; 
      float z = allPoints.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r) - y * sin(r))); 
        allPoints.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r) + x * cos(r))); 
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x)); 
        allPoints.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allPoints.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }
  }
  
  
  void scale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    for (int q = 0; q < this.Vertex_ids.length; q++) {
  
      int f = this.Vertex_ids[q];
  
      float x = allPoints.getX(f); 
      float y = allPoints.getY(f); 
      float z = allPoints.getZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];
  
      allPoints.setX(f, x); 
      allPoints.setY(f, y);
      allPoints.setZ(f, z);
    }
  }
  
  
  
  
  float softVertexSelectionFunction (float d_min) {
  
    float v = 0;
  
    if (d_min < this.softRadius) {
      v = pow(funcs.cos_ang(90 * d_min / this.softRadius), this.softPower);
    }
  
    return v;
  }
  
  void softMove_selectedVertices (float dx, float dy, float dz) {
  
    for (int q = 0; q < this.Vertex_softSelectionVertices.length; q++) {
  
      int f = this.Vertex_softSelectionVertices[q];
  
      float v = this.Vertex_softSelectionValues[q];
  
      allPoints.addX(f, dx * v); 
      allPoints.addY(f, dy * v);
      allPoints.addZ(f, dz * v);
    }
  }
  
  
  void softRotate_selectedVertices (float x0, float y0, float z0, float r, int the_Vector) {
  
    for (int q = 0; q < this.Vertex_softSelectionVertices.length; q++) {
  
      int f = this.Vertex_softSelectionVertices[q];
  
      float v = this.Vertex_softSelectionValues[q];
  
      float x = allPoints.getX(f) - x0; 
      float y = allPoints.getY(f) - y0; 
      float z = allPoints.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allPoints.setX(f, x0 + (x * cos(r * v) - y * sin(r * v))); 
        allPoints.setY(f, y0 + (x * sin(r * v) + y * cos(r * v)));
        allPoints.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allPoints.setX(f, x0 + (z * sin(r * v) + x * cos(r * v))); 
        allPoints.setY(f, y0 + (y));
        allPoints.setZ(f, z0 + (z * cos(r * v) - x * sin(r * v)));
      } else if (the_Vector == 0) {
        allPoints.setX(f, x0 + (x)); 
        allPoints.setY(f, y0 + (y * cos(r * v) - z * sin(r * v)));
        allPoints.setZ(f, z0 + (y * sin(r * v) + z * cos(r * v)));
      }
    }
  }
  
  
  
  void softScale_selectedVertices (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    for (int q = 0; q < this.Vertex_softSelectionVertices.length; q++) {
  
      int f = this.Vertex_softSelectionVertices[q];
  
      float v = this.Vertex_softSelectionValues[q];    
  
      float x = allPoints.getX(f) - x0; 
      float y = allPoints.getY(f) - y0; 
      float z = allPoints.getZ(f) - z0;
  
      allPoints.setX(f, (x0 + sx * x) * v + (x0 + x) * (1 - v)); 
      allPoints.setY(f, (y0 + sy * y) * v + (y0 + y) * (1 - v)); 
      allPoints.setZ(f, (z0 + sz * z) * v + (z0 + z) * (1 - v));
    }
  }
  
  
  
  void scale_selectedModel2D (float x0, float y0, float z0, float sx, float sy, float sz) { 
  
    int n1 = allModel2Ds.num_files_PEOPLE;    
  
    for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
  
      int f = this.Model2D_ids[o];
  
      float x = allModel2Ds.getX(f);
      float y = allModel2Ds.getY(f); 
      float z = allModel2Ds.getZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];         
  
      allModel2Ds.setX(f, x); 
      allModel2Ds.setY(f, y);
      allModel2Ds.setZ(f, z);    
  
  
      int n = allModel2Ds.MAP[f];
  
      if (abs(n) > n1) { // does not scale poeple!    
        allModel2Ds.magS(f, sz);
      }
    }
  }
  
  
  void rotate_selectedModel2D (float x0, float y0, float z0, float r, int the_Vector) {
  
    for (int q = 0; q < this.Model2D_ids.length; q++) {
  
      int f = this.Model2D_ids[q];
  
      float x = allModel2Ds.getX(f) - x0; 
      float y = allModel2Ds.getY(f) - y0; 
      float z = allModel2Ds.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allModel2Ds.setX(f, x0 + (x * cos(r) - y * sin(r))); 
        allModel2Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allModel2Ds.setZ(f, z0 + (z));
      } else if (the_Vector == 1) {
        allModel2Ds.setX(f, x0 + (z * sin(r) + x * cos(r))); 
        allModel2Ds.setY(f, y0 + (y));
        allModel2Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allModel2Ds.setX(f, x0 + (x)); 
        allModel2Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allModel2Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }
  }
  
  
  
  void move_selectedModel2D (float dx, float dy, float dz) {
  
    for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
  
      int f = this.Model2D_ids[o];
      
      allModel2Ds.addX(f, dx); 
      allModel2Ds.addY(f, dy); 
      allModel2Ds.addZ(f, dz);
    }
  } 
  
  
  void scale_selectedModel1D (float x0, float y0, float z0, float sx, float sy, float sz) { 
  
    for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
  
      int f = this.Model1D_ids[o];
  
      float x = allModel1Ds.getX(f);
      float y = allModel1Ds.getY(f); 
      float z = allModel1Ds.getZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];
  
      allModel1Ds.setX(f, x);
      allModel1Ds.setY(f, y);
      allModel1Ds.setZ(f, z);
  
      allModel1Ds.magS(f, sz);
    }
  }
  
  
  void rotate_selectedModel1D (float x0, float y0, float z0, float r, int the_Vector) {
  
    for (int q = 0; q < this.Model1D_ids.length; q++) {
  
      int f = this.Model1D_ids[q];
  
      float x = allModel1Ds.getX(f) - x0; 
      float y = allModel1Ds.getY(f) - y0; 
      float z = allModel1Ds.getZ(f) - z0;
  
      if (the_Vector == 2) {
        allModel1Ds.setX(f, x0 + (x * cos(r) - y * sin(r))); 
        allModel1Ds.setY(f, y0 + (x * sin(r) + y * cos(r)));
        allModel1Ds.setZ(f, z0 + (z));
  
        allModel1Ds.setR(f, allModel1Ds.getR(f) + r); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      } else if (the_Vector == 1) {
        allModel1Ds.setX(f, x0 + (z * sin(r) + x * cos(r))); 
        allModel1Ds.setY(f, y0 + (y));
        allModel1Ds.setZ(f, z0 + (z * cos(r) - x * sin(r)));
      } else if (the_Vector == 0) {
        allModel1Ds.setX(f, x0 + (x)); 
        allModel1Ds.setY(f, y0 + (y * cos(r) - z * sin(r)));
        allModel1Ds.setZ(f, z0 + (y * sin(r) + z * cos(r)));
      }
    }
  }
  
  
  void move_selectedModel1D (float dx, float dy, float dz) {
  
    for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
  
      int f = this.Model1D_ids[o];
  
      allModel1Ds.addX(f, dx); 
      allModel1Ds.addY(f, dy); 
      allModel1Ds.addZ(f, dz);
    }
  } 
  
  
  void move_selectedSolids (float dx, float dy, float dz) {
  
    boolean allSolids_updated = false; 
  
    for (int q = 0; q < this.Solid_ids.length; q++) {
  
      int f = this.Solid_ids[q];
  
      float Solid_posX = allSolids.get_posX(f);
      float Solid_posY = allSolids.get_posY(f);
      float Solid_posZ = allSolids.get_posZ(f);
  
      allSolids.updatePosition(f, Solid_posX + dx, Solid_posY + dy, Solid_posZ + dz);
  
      allSolids_updated = true;
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  
  void rotate_selectedSolids (float x0, float y0, float z0, float r, int the_Vector) {
  
    boolean allSolids_updated = false; 
  
    for (int q = 0; q < this.Solid_ids.length; q++) {
  
      int f = this.Solid_ids[q];
  
      float Solid_posX = allSolids.get_posX(f);
      float Solid_posY = allSolids.get_posY(f);
      float Solid_posZ = allSolids.get_posZ(f);
  
  
      float x = Solid_posX - x0; 
      float y = Solid_posY - y0; 
      float z = Solid_posZ - z0;
  
      if (the_Vector == 2) {
        allSolids.updatePosition(f, x0 + (x * cos(r) - y * sin(r)), y0 + (x * sin(r) + y * cos(r)), z0 + (z));
  
        allSolids.RotateZ(f, r * 180 / PI);
      } else if (the_Vector == 1) {
        allSolids.updatePosition(f, x0 + (z * sin(r) + x * cos(r)), y0 + (y), z0 + (z * cos(r) - x * sin(r)));
  
        allSolids.RotateY(f, r * 180 / PI);
      } else if (the_Vector == 0) {
        allSolids.updatePosition(f, x0 + (x), y0 + (y * cos(r) - z * sin(r)), z0 + (y * sin(r) + z * cos(r)));
  
        allSolids.RotateX(f, r * 180 / PI);
      }
  
      allSolids_updated = true;
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  
  void scale_selectedSolids (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    boolean allSolids_updated = false; 
  
    for (int q = 0; q < this.Solid_ids.length; q++) {
  
      int f = this.Solid_ids[q];
  
      float x = allSolids.get_posX(f);
      float y = allSolids.get_posY(f);
      float z = allSolids.get_posZ(f);
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0]; 
      y = B[1];
      z = B[2];
  
      allSolids.updatePosition(f, x, y, z);
  
      allSolids.Scale(f, sx, sy, sz);    
  
      allSolids_updated = true;
    }
  
    if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  }
  
  
  void move_selectedSections (float dx, float dy, float dz) {
  
    for (int q = 0; q < this.Section_ids.length; q++) {
  
      int f = this.Section_ids[q];
  
      allSections.UVERAB[f][0] += dx;
      allSections.UVERAB[f][1] += dy;
      allSections.UVERAB[f][2] += dz;
    }
  
    allSolidImpacts.calculate_Impact_selectedSections();
  
    WIN3D.update = true;
    ROLLOUT.update = true;
  }
  
  
  void rotate_selectedSections (float r) {
  
    for (int q = 0; q < this.Section_ids.length; q++) {
  
      int f = this.Section_ids[q];
  
      allSections.UVERAB[f][3] += r * 180.0 / PI;
    }
  
    allSolidImpacts.calculate_Impact_selectedSections(); 
  
    WIN3D.update = true;
    ROLLOUT.update = true;
  }
  
  void scale_selectedSections (float sx, float sy) {
  
    for (int q = 0; q < this.Section_ids.length; q++) {
  
      int f = this.Section_ids[q];
  
      allSections.UVERAB[f][4] *= sx;
      allSections.UVERAB[f][5] *= sy;
    }
  
    allSolidImpacts.calculate_Impact_selectedSections(); 
  
    WIN3D.update = true;
    ROLLOUT.update = true;
  }
  
  
  void move_selectedCameras (float dx, float dy, float dz) {
  
    // swapping y and z vectors to match camera's local coordinate
    float tmp = dz;
    dz = dy;
    dy = tmp;
  
    for (int q = 0; q < this.Camera_ids.length; q++) {
  
      int f = this.Camera_ids[q];
  
      allCameras.options[f][0] += dx; 
      allCameras.options[f][1] += dy;
      allCameras.options[f][2] += dz;
  
      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }
  }
  
  
  void rotate_selectedCameras (float x0, float y0, float z0, float r, int the_Vector) {
  
    // swapping y and z vectors to match camera's local coordinate
    if (the_Vector == 2) the_Vector = 1;
    else if (the_Vector == 1) the_Vector = 2;
  
    for (int q = 0; q < this.Camera_ids.length; q++) {
  
      int f = this.Camera_ids[q];
  
      float x = allCameras.options[f][0] - x0; 
      float y = allCameras.options[f][1] - y0; 
      float z = allCameras.options[f][2] - z0;
  
      if (the_Vector == 2) {
        allCameras.options[f][0] = x0 + (x * cos(r) - y * sin(r)); 
        allCameras.options[f][1] = y0 + (x * sin(r) + y * cos(r));
        allCameras.options[f][2] = z0 + (z);
      } else if (the_Vector == 1) {
        allCameras.options[f][0] = x0 + (z * sin(r) + x * cos(r)); 
        allCameras.options[f][1] = y0 + (y);
        allCameras.options[f][2] = z0 + (z * cos(r) - x * sin(r));
      } else if (the_Vector == 0) {
        allCameras.options[f][0] = x0 + (x); 
        allCameras.options[f][1] = y0 + (y * cos(r) - z * sin(r));
        allCameras.options[f][2] = z0 + (y * sin(r) + z * cos(r));
      }    
  
      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }
  }
  
  
  void scale_selectedCameras (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    // swapping y and z vectors to match camera's local coordinate
    float tmp = sz;
    sz = sy;
    sy = tmp;
  
    for (int q = 0; q < this.Camera_ids.length; q++) {
  
      int f = this.Camera_ids[q];
  
      float x = allCameras.options[f][0] - x0; 
      float y = allCameras.options[f][1] - y0; 
      float z = allCameras.options[f][2] - z0;
  
      allCameras.options[f][0] = x0 + sx * x; 
      allCameras.options[f][1] = y0 + sy * y;
      allCameras.options[f][2] = z0 + sz * z;
  
      if (f == WIN3D.currentCamera) WIN3D.apply_currentCamera();
    }
  }
  
  
  void flatten_selectedLandPoints () {
  
    for (int q = 0; q < this.LandPoint_ids.length; q++) {
  
      int f = this.LandPoint_ids[q];
  
      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;
  
      Land3D.Mesh[i][j][2] = 0;
  
    }
  }
  
  
  
  void move_selectedLandPoints (float dx, float dy, float dz) {
  
    for (int q = 0; q < this.LandPoint_ids.length; q++) {
  
      int f = this.LandPoint_ids[q];
  
      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;
  
      Land3D.Mesh[i][j][0] += dx; 
      Land3D.Mesh[i][j][1] += dy;
      Land3D.Mesh[i][j][2] += dz;
    }
  }
  
  
  void rotate_selectedLandPoints (float x0, float y0, float z0, float r, int the_Vector) {
  
    for (int q = 0; q < this.LandPoint_ids.length; q++) {
  
      int f = this.LandPoint_ids[q];
  
      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;
  
      float x = Land3D.Mesh[i][j][0] - x0; 
      float y = Land3D.Mesh[i][j][1] - y0; 
      float z = Land3D.Mesh[i][j][2] - z0;
  
      if (the_Vector == 2) {
        Land3D.Mesh[i][j][0] = x0 + (x * cos(r) - y * sin(r)); 
        Land3D.Mesh[i][j][1] = y0 + (x * sin(r) + y * cos(r));
        Land3D.Mesh[i][j][2] = z0 + (z);
      } else if (the_Vector == 1) {
        Land3D.Mesh[i][j][0] = x0 + (z * sin(r) + x * cos(r)); 
        Land3D.Mesh[i][j][1] = y0 + (y);
        Land3D.Mesh[i][j][2] = z0 + (z * cos(r) - x * sin(r));
      } else if (the_Vector == 0) {
        Land3D.Mesh[i][j][0] = x0 + (x); 
        Land3D.Mesh[i][j][1] = y0 + (y * cos(r) - z * sin(r));
        Land3D.Mesh[i][j][2] = z0 + (y * sin(r) + z * cos(r));
      }
    }
  }
  
  
  void scale_selectedLandPoints (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    for (int q = 0; q < this.LandPoint_ids.length; q++) {
  
      int f = this.LandPoint_ids[q];
  
      int i = f / Land3D.num_columns;
      int j = f % Land3D.num_columns;
  
      float x = Land3D.Mesh[i][j][0];
      float y = Land3D.Mesh[i][j][1]; 
      float z = Land3D.Mesh[i][j][2];
  
      float[] A = userSelections.translateOutside_ReferencePivot(x, y, z);
  
      x = sx * (A[0] - x0) + x0;
      y = sy * (A[1] - y0) + y0;
      z = sz * (A[2] - z0) + z0;
  
      float[] B = userSelections.translateInside_ReferencePivot(x, y, z);
  
      x = B[0];
      y = B[1];
      z = B[2];
  
      Land3D.Mesh[i][j][0] = x; 
      Land3D.Mesh[i][j][1] = y;
      Land3D.Mesh[i][j][2] = z;
  
    }
  }
  
  
  
  void scale_Selection (float x0, float y0, float z0, float sx, float sy, float sz) {
  
    float[] O = userSelections.translateOutside_ReferencePivot(x0, y0, z0);
  
    x0 = O[0];
    y0 = O[1];
    z0 = O[2];    
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      this.scale_selectedCameras(x0, y0, z0, sx, sy, sz);
    }   
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      this.scale_selectedSections(sx, sy);
    }   
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
      this.scale_selectedSolids(x0, y0, z0, sx, sy, sz);
    }       
  
    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
  
      this.softScale_selectedVertices(x0, y0, z0, sx, sy, sz);
    }    
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
      this.scale_selectedVertices(x0, y0, z0, sx, sy, sz);
    }  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      this.scale_selectedFaces(x0, y0, z0, sx, sy, sz);
    }  
    
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      this.scale_selectedCurves(x0, y0, z0, sx, sy, sz);
    }    
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      this.scale_selectedGroups(x0, y0, z0, sx, sy, sz);
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      this.scale_selectedModel2D(x0, y0, z0, sx, sy, sz);
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      this.scale_selectedModel1D(x0, y0, z0, sx, sy, sz);
    }  
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
  
      this.scale_selectedLandPoints(x0, y0, z0, sx, sy, sz);
    }
  }
  
  
  
  void rotate_Selection (float x0, float y0, float z0, float r, int the_Vector) {
    
    r *= PI / 180; // <<<<<<<<
  
    float[] A = userSelections.translateInside_ReferencePivot(0, 0, 0);
    float[] B = userSelections.translateInside_ReferencePivot(x0, y0, z0);
  
    x0 = B[0] - A[0];
    y0 = B[1] - A[1];
    z0 = B[2] - A[2];  
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      this.rotate_selectedCameras(x0, y0, z0, r, the_Vector);
    }  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      this.rotate_selectedSections(r);
    }   
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      this.rotate_selectedSolids(x0, y0, z0, r, the_Vector);
    }       
  
    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
  
      this.softRotate_selectedVertices(x0, y0, z0, r, the_Vector);
    }  
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
      this.rotate_selectedVertices(x0, y0, z0, r, the_Vector);
    }  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      this.rotate_selectedFaces(x0, y0, z0, r, the_Vector);
    }  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      this.rotate_selectedCurves(x0, y0, z0, r, the_Vector);
    }  
    
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      this.rotate_selectedGroups(r, the_Vector);
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      this.rotate_selectedModel2D(x0, y0, z0, r, the_Vector);
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      this.rotate_selectedModel1D(x0, y0, z0, r, the_Vector);
    }   
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
  
      this.rotate_selectedLandPoints(x0, y0, z0, r, the_Vector);
    }
  } 
  
  
  
  
  
  
  void move_Selection (float dx, float dy, float dz) {
    
    println("Move: dx=", dx, ", dy=", dy, ", dz=", dz);
  
    float[] A = userSelections.translateInside_ReferencePivot(0, 0, 0);
    float[] B = userSelections.translateInside_ReferencePivot(dx, dy, dz);
  
    dx = B[0] - A[0];
    dy = B[1] - A[1];
    dz = B[2] - A[2];
  
  
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      this.move_selectedCameras(dx, dy, dz);
    }     
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      this.move_selectedSections(dx, dy, dz);
    }   
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      this.move_selectedSolids(dx, dy, dz);
    }      
  
    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
  
      this.softMove_selectedVertices(dx, dy, dz);
    }    
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
      this.move_selectedVertices(dx, dy, dz);
    }  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      this.move_selectedFaces(dx, dy, dz);
    }  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      this.move_selectedCurves(dx, dy, dz);
    }
    
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      this.move_selectedGroups(dx, dy, dz);
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      this.move_selectedModel2D(dx, dy, dz);
    }  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      this.move_selectedModel1D(dx, dy, dz);
    }    
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
  
      this.move_selectedLandPoints(dx, dy, dz);
    }
  }
  
  
  void drop_Selection () {
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
    }     
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
    }   
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
    }      
  
    if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
    }    
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
    }  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
    }  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
    }  
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Model2D_ids[o];
  
        float x = allModel2Ds.getX(OBJ_NUM);
        float y = allModel2Ds.getY(OBJ_NUM);
        float z = allModel2Ds.getZ(OBJ_NUM);
  
        float[] ray_start = {
          x, y, z
        };
  
        float[] ray_direction = {
          0, 0, -1
        };
  
        float[] RxP = new float [8];
  
        if (WIN3D.UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 1) {
          RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }
  
        if (RxP[0] >= 0) {
          allModel2Ds.setX(OBJ_NUM, RxP[1]); 
          allModel2Ds.setY(OBJ_NUM, RxP[2]); 
          allModel2Ds.setZ(OBJ_NUM, RxP[3]);
        } else {
          ray_direction[2] = 1; // <<<< going upwards
  
          if (WIN3D.UI_TaskModifyParameter == 0) { 
            RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
          } else if (WIN3D.UI_TaskModifyParameter == 2) {
            RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
          } else {
            RxP[0] = -1; // undefined
          }
  
          if (RxP[0] >= 0) {
            allModel2Ds.setX(OBJ_NUM, RxP[1]); 
            allModel2Ds.setY(OBJ_NUM, RxP[2]); 
            allModel2Ds.setZ(OBJ_NUM, RxP[3]);
          }
        }
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Model1D_ids[o];
  
        float x = allModel1Ds.getX(OBJ_NUM);
        float y = allModel1Ds.getY(OBJ_NUM);
        float z = allModel1Ds.getZ(OBJ_NUM);
  
        float[] ray_start = {
          x, y, z
        };
  
        float[] ray_direction = {
          0, 0, -1
        };
  
        float[] RxP = new float [8];
  
        if (WIN3D.UI_TaskModifyParameter == 0) { 
          RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
        } else if (WIN3D.UI_TaskModifyParameter == 1) {
          RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
        } else {
          RxP[0] = -1; // undefined
        }
  
        if (RxP[0] >= 0) {
          allModel1Ds.setX(OBJ_NUM, RxP[1]); 
          allModel1Ds.setY(OBJ_NUM, RxP[2]); 
          allModel1Ds.setZ(OBJ_NUM, RxP[3]);
        } else {
          ray_direction[2] = 1; // <<<< going upwards
  
          if (WIN3D.UI_TaskModifyParameter == 0) { 
            RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
          } else if (WIN3D.UI_TaskModifyParameter == 2) {
            RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);
          } else {
            RxP[0] = -1; // undefined
          }
  
          if (RxP[0] >= 0) {
            allModel1Ds.setX(OBJ_NUM, RxP[1]); 
            allModel1Ds.setY(OBJ_NUM, RxP[2]); 
            allModel1Ds.setZ(OBJ_NUM, RxP[3]);
          }
        }
      }
    }    
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }
  }
  
  
  
  void changeProperties_Selection (int p) {
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      for (int o = this.Camera_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Camera_ids[o];
  
        int f = OBJ_NUM;
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
          int n = allCameras.Type[f];
          n += p;
          if (n > 1) n = 0;
          if (n < 0) n = 1;
          allCameras.Type[f] = n;         
  
          if (f == WIN3D.currentCamera) WIN3D.ViewType = allCameras.Type[f];
        }
      }
    }    
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      boolean allSolids_updated = false;  
  
      for (int o = this.Section_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Section_ids[o];
  
        int f = OBJ_NUM;
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
          int n = allSections.Type[f];
          n += p;
          if (n > 3) n = 0;
          if (n < 0) n = 3;
          allSections.Type[f] = n;         
  
          allSolids_updated = true;
        }        
  
        if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
          int n = allSections.RES1[f];
          if (p > 0) n *= 2;
          if (p < 0) n /= 2;
  
          if (n > 1600) n = 100;
          if (n < 100) n = 1600;
          allSections.RES1[f] = n;
  
          allSections.RES2[f] = n; // also modifying the other one
  
          println("RES:", n);
  
          allSolids_updated = true;
        }
  
      } 
  
      if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
    }  
  
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      boolean allSolids_updated = false;  
  
      for (int o = this.Solid_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Solid_ids[o];
  
        int f = OBJ_NUM;
  
        if ((WIN3D.UI_CurrentTask == UITASK.PowerX) ||  (WIN3D.UI_CurrentTask == UITASK.PowerY) ||  (WIN3D.UI_CurrentTask == UITASK.PowerZ) ||  (WIN3D.UI_CurrentTask == UITASK.PowerAll)) {
  
  
          float Solid_powX = allSolids.get_powX(f);
          float Solid_powY = allSolids.get_powY(f);
          float Solid_powZ = allSolids.get_powZ(f);
  
  
          float n = 2;
  
          if (WIN3D.UI_CurrentTask == UITASK.PowerX) n = Solid_powX; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerY) n = Solid_powY; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerZ) n = Solid_powZ; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
            n = Solid_powX;
          }          
  
          if (p > 0) n *= 2;
          if (p < 0) n /= 2;
  
          if (n > CubePower) n = StarPower;
          if (n < StarPower) n = CubePower;
  
          if (WIN3D.UI_CurrentTask == UITASK.PowerX) Solid_powX = n; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerY) Solid_powY = n; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerZ) Solid_powZ = n; 
          if (WIN3D.UI_CurrentTask == UITASK.PowerAll) {
            Solid_powX = n;
            Solid_powY = n;
            Solid_powZ = n;
          } 
  
          allSolids.updatePowers(f, Solid_powX, Solid_powY, Solid_powZ);          
  
          allSolids_updated = true;
        }
      }
  
      if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
    }    
  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      for (int o = this.Face_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Face_ids[o];
  
        int f = OBJ_NUM;
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
          int n = allFaces.getMaterial(f);
          n += p;
          if (n > 8) n = 0;
          if (n < 0) n = 8;
          allFaces.setMaterial(f, n);
        }
  
        if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
          int n = allFaces.getTessellation(f);
          n += p;
          if (n > 4) n = 0;
          if (n < 0) n = 4;
          allFaces.setTessellation(f, n);
        }   
  
        if (WIN3D.UI_CurrentTask == UITASK.Layer) {
          int n = allFaces.getLayer(f);
          n += p;
          if (n > 16) n = 0;
          if (n < 0) n = 16;
          allFaces.setLayer(f, n);
        }  
  
        if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
          int n = allFaces.getVisibility(f);
          n += p;
          if (n > 2) n = 0;
          if (n < 0) n = 2;
          allFaces.setVisibility(f, n);
        }
        
        if (WIN3D.UI_CurrentTask == UITASK.Weight) {
          int n = allFaces.getWeight(f);
          n += p;
          if (n > 20) n = -20;
          if (n < -20) n = 20;
          allFaces.setWeight(f, n);
        }        
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Curve_ids[o];
  
        int f = OBJ_NUM;
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
          int n = allCurves.getMaterial(f);
          n += p;
          if (n > 8) n = 0;
          if (n < 0) n = 8;
          allCurves.setMaterial(f, n);
        }
  
        if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
          int n = allCurves.getTessellation(f);
          n += p;
          if (n > 4) n = 0;
          if (n < 0) n = 4;
          allCurves.setTessellation(f, n);
        }   
  
        if (WIN3D.UI_CurrentTask == UITASK.Layer) {
          int n = allCurves.getLayer(f);
          n += p;
          if (n > 16) n = 0;
          if (n < 0) n = 16;
          allCurves.setLayer(f, n);
        }  
  
        if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
          int n = allCurves.getVisibility(f);
          n += p;
          if (n > 2) n = 0;
          if (n < 0) n = 2;
          allCurves.setVisibility(f, n);
        }
        
        if (WIN3D.UI_CurrentTask == UITASK.Weight) {
          int n = allCurves.getWeight(f);
          n += p;
          if (n > 20) n = -20;
          if (n < -20) n = 20;
          allCurves.setWeight(f, n);
        }        
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      for (int o = this.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Group_ids[o];
  
        for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allFaces.nodes.length)) {
  
            if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
              int n = allFaces.getMaterial(f);
              n += p;
              if (n > 8) n = 0;
              if (n < 0) n = 8;
              allFaces.setMaterial(f, n);
            }
  
            if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
              int n = allFaces.getTessellation(f);
              n += p;
              if (n > 4) n = 0;
              if (n < 0) n = 4;
              allFaces.setTessellation(f, n);
            }      
  
            if (WIN3D.UI_CurrentTask == UITASK.Layer) {
              int n = allFaces.getLayer(f);
              n += p;
              if (n > 16) n = 0;
              if (n < 0) n = 16;
              allFaces.setLayer(f, n);
            }  
  
            if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
              int n = allFaces.getVisibility(f);
              n += p;
              if (n > 2) n = 0;
              if (n < 0) n = 2;
              allFaces.setVisibility(f, n);
            }
            
            if (WIN3D.UI_CurrentTask == UITASK.Weight) {
              int n = allFaces.getWeight(f);
              n += p;
              if (n > 20) n = -20;
              if (n < -20) n = 20;
              allFaces.setWeight(f, n);
            }            
          }
        }
        
        for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allCurves.nodes.length)) {
  
            if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
              int n = allCurves.getMaterial(f);
              n += p;
              if (n > 8) n = 0;
              if (n < 0) n = 8;
              allCurves.setMaterial(f, n);
            }
  
            if (WIN3D.UI_CurrentTask == UITASK.Tessellation) {
              int n = allCurves.getTessellation(f);
              n += p;
              if (n > 4) n = 0;
              if (n < 0) n = 4;
              allCurves.setTessellation(f, n);
            }      
  
            if (WIN3D.UI_CurrentTask == UITASK.Layer) {
              int n = allCurves.getLayer(f);
              n += p;
              if (n > 16) n = 0;
              if (n < 0) n = 16;
              allCurves.setLayer(f, n);
            }  
  
            if (WIN3D.UI_CurrentTask == UITASK.Visibility) {
              int n = allCurves.getVisibility(f);
              n += p;
              if (n > 2) n = 0;
              if (n < 0) n = 2;
              allCurves.setVisibility(f, n);
            }
            
            if (WIN3D.UI_CurrentTask == UITASK.Weight) {
              int n = allCurves.getWeight(f);
              n += p;
              if (n > 20) n = -20;
              if (n < -20) n = 20;
              allCurves.setWeight(f, n);
            }            
          }
        }        
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Model2D_ids[o];
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
  
          int n = allModel2Ds.MAP[OBJ_NUM];
          int sign_n = 1;
          if (n < 0) sign_n = -1;
  
          n = abs(n);
  
          int n1 = allModel2Ds.num_files_PEOPLE;
          int n2 = allModel2Ds.num_files_PEOPLE + allModel2Ds.num_files_TREES;
  
  
          if (n <= n1) { // case: people 
  
            n += p;
  
            if (n > n1) {
              n = 1; 
              sign_n *= -1;
            }
            if (n < 1) {
              n = n1; 
              sign_n *= -1;
            }
          } else { // case: trees
  
            n += p;
  
            if (n > n2) {
              n = n1 + 1; 
              sign_n *= -1;
            }
            if (n < n1 + 1) {
              n = n2; 
              sign_n *= -1;
            }
          }
  
          n *= sign_n;
  
          allModel2Ds.MAP[OBJ_NUM] = n;
        }
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = this.Model1D_ids[o];
  
        if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
  
          allModel1Ds.setSeed(OBJ_NUM, allModel1Ds.getSeed(OBJ_NUM) + p);
        } 
        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) {
          int q = allModel1Ds.getDegreeMax(OBJ_NUM);
  
          q += p;
  
          if (q < 0) q = 0;
  
          allModel1Ds.setDegreeMax(OBJ_NUM, q);
  
          User3D.create_Model1D_DegreeMax = q;
          ROLLOUT.update = true;
        }
        if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
          int q1 = allModel1Ds.getDegreeMin(OBJ_NUM);
          int q2 = allModel1Ds.getDegreeMax(OBJ_NUM);
          q1 += p;
          q2 += p;
  
          int change_them = 1; 
  
          if (q1 < 0) {
            q1 = 0; 
            change_them = 0;
          } 
          if (q2 < 0) {
            q2 = 0; 
            change_them = 0;
          }
  
          if (change_them == 1) {
  
            allModel1Ds.setDegreeMin(OBJ_NUM, q1);
            allModel1Ds.setDegreeMax(OBJ_NUM, q2);
  
            User3D.create_Model1D_DegreeMin = q1;
            User3D.create_Model1D_DegreeMax = q2;
  
            ROLLOUT.update = true;
          }
        }
        if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) {
          int q = allModel1Ds.getDegreeMin(OBJ_NUM);
  
          q += p;
  
          if (q < 0) q = 0;
  
          allModel1Ds.setDegreeMin(OBJ_NUM, q);
  
          User3D.create_Model1D_DegreeMin = q;
          ROLLOUT.update = true;
        }        
        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) {
          float q = allModel1Ds.getTrunkSize(OBJ_NUM);
  
          q += 0.25 * p;
  
          if (q < 0) q = 0;
  
          allModel1Ds.setTrunkSize(OBJ_NUM, q);
  
          User3D.create_Model1D_TrunkSize = q;
          ROLLOUT.update = true;
        }
        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) {
          float q = allModel1Ds.getLeafSize(OBJ_NUM);
  
          q += 0.25 * p;
  
          if (q < 0) q = 0;
  
          allModel1Ds.setLeafSize(OBJ_NUM, q);
  
          User3D.create_Model1D_LeafSize = q;
          ROLLOUT.update = true;
        }
      }
    }
  }     
  
  
  
  float[] translateInside_ReferencePivot (float a, float b, float c) {
  
  
    float rotX = this.BoundingBox[1 + this.alignX][6];
    float rotY = this.BoundingBox[1 + this.alignY][7];
    float rotZ = this.BoundingBox[1 + this.alignZ][8];
  
    float y1 = b * funcs.cos_ang(rotX) - c * funcs.sin_ang(rotX); 
    float z1 = b * funcs.sin_ang(rotX) + c * funcs.cos_ang(rotX);
    float x1 = a;
  
    a = x1;
    b = y1;
    c = z1;  
  
    float z2 = c * funcs.cos_ang(rotY) - a * funcs.sin_ang(rotY);
    float x2 = c * funcs.sin_ang(rotY) + a * funcs.cos_ang(rotY);
    float y2 = b; 
  
    a = x2;
    b = y2;
    c = z2;      
  
    float x = a * funcs.cos_ang(rotZ) - b * funcs.sin_ang(rotZ);
    float y = a * funcs.sin_ang(rotZ) + b * funcs.cos_ang(rotZ); 
    float z = c;      
  
    x *= this.BoundingBox[1 + this.alignX][3];
    y *= this.BoundingBox[1 + this.alignY][4];
    z *= this.BoundingBox[1 + this.alignZ][5]; 
  
    x += this.BoundingBox[1 + this.alignX][0];
    y += this.BoundingBox[1 + this.alignY][1];
    z += this.BoundingBox[1 + this.alignZ][2];  
  
    float[] return_array = {
      x, y, z
    };
  
    return return_array;
  }
  
  
  
  float[] translateOutside_ReferencePivot (float a, float b, float c) {
  
    a -= this.BoundingBox[1 + this.alignX][0];
    b -= this.BoundingBox[1 + this.alignY][1];
    c -= this.BoundingBox[1 + this.alignZ][2];   
  
    a /= this.BoundingBox[1 + this.alignX][3];
    b /= this.BoundingBox[1 + this.alignY][4];
    c /= this.BoundingBox[1 + this.alignZ][5];    
  
  
  
    float rotX = this.BoundingBox[1 + this.alignX][6];
    float rotY = this.BoundingBox[1 + this.alignY][7];
    float rotZ = this.BoundingBox[1 + this.alignZ][8];
  
    float x1 = a * funcs.cos_ang(-rotZ) - b * funcs.sin_ang(-rotZ);
    float y1 = a * funcs.sin_ang(-rotZ) + b * funcs.cos_ang(-rotZ); 
    float z1 = c;      
  
    a = x1;
    b = y1;
    c = z1;  
  
    float z2 = c * funcs.cos_ang(-rotY) - a * funcs.sin_ang(-rotY);
    float x2 = c * funcs.sin_ang(-rotY) + a * funcs.cos_ang(-rotY);
    float y2 = b; 
  
    a = x2;
    b = y2;
    c = z2;      
  
    float y = b * funcs.cos_ang(-rotX) - c * funcs.sin_ang(-rotX); 
    float z = b * funcs.sin_ang(-rotX) + c * funcs.cos_ang(-rotX);
    float x = a;  
  
  
    float[] return_array = {
      x, y, z
    };
  
    return return_array;
  }
  
  
  
  
  float[] getPivot () {
  
    float posX = this.BoundingBox[1][0];
    float posY = this.BoundingBox[1][1];
    float posZ = this.BoundingBox[1][2];
  
    float x = this.BoundingBox[1 + this.alignX][0];
    float y = this.BoundingBox[1 + this.alignY][1];
    float z = this.BoundingBox[1 + this.alignZ][2];
  
    {
      int keep_selection_alignX = this.alignX;
      int keep_selection_alignY = this.alignY;
      int keep_selection_alignZ = this.alignZ;
  
      this.alignX = 0; // apply the centre
      this.alignY = 0; // apply the centre
      this.alignZ = 0; // apply the centre
  
      float[] A = userSelections.translateInside_ReferencePivot(x - posX, y - posY, z - posZ);  
  
      x = A[0];
      y = A[1];
      z = A[2];
  
      this.alignX = keep_selection_alignX;
      this.alignY = keep_selection_alignY;
      this.alignZ = keep_selection_alignZ;
    }
  
    float[] return_array = {
      x, y, z
    };
  
    return return_array;
  }
  
  
  
  void selectPick (float[] RxP) {
    
    if (addNewSelectionToPreviousSelection == 0) allModel3Ds.deselect_All();
  
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.LandPoint_ids.length - 1; o >= 0; o--) {
          if (this.LandPoint_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.LandPoint_ids, 0, found_at);
        int[] endList = (int[]) subset(this.LandPoint_ids, found_at + 1);
  
        this.LandPoint_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.LandPoint_ids = (int[]) concat(this.LandPoint_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
          if (this.Model1D_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Model1D_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Model1D_ids, found_at + 1);
  
        this.Model1D_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Model1D_ids = (int[]) concat(this.Model1D_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
          if (this.Model2D_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Model2D_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Model2D_ids, found_at + 1);
  
        this.Model2D_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Model2D_ids = (int[]) concat(this.Model2D_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      int f = int(RxP[0]);
  
      int OBJ_NUM = 0;
  
      for (int i = 0; i < allGroups.num; i++) {
        if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
  
          OBJ_NUM = i;
  
          WIN3D.update = true;
          break;
        }
      }
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Group_ids.length - 1; o >= 0; o--) {
          if (this.Group_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Group_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Group_ids, found_at + 1);
  
        this.Group_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Group_ids = (int[]) concat(this.Group_ids, newObject_id);
      }
  
  
  
      this.calculate_selection_BoundingBox();
    }
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Face_ids.length - 1; o >= 0; o--) {
          if (this.Face_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Face_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Face_ids, found_at + 1);
  
        this.Face_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Face_ids = (int[]) concat(this.Face_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
          if (this.Curve_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Curve_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Curve_ids, found_at + 1);
  
        this.Curve_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Curve_ids = (int[]) concat(this.Curve_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
    
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
      int f = int(RxP[0]);
  
      int OBJ_NUM = 0;
      float min_dist = FLOAT_undefined;  
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
  
        float x = allPoints.getX(vNo);
        float y = allPoints.getY(vNo);          
        float z = allPoints.getZ(vNo);
  
        float now_dist = dist(x, y, z, RxP[1], RxP[2], RxP[3]);
  
        if (min_dist > now_dist) {
          min_dist = now_dist;
          OBJ_NUM = vNo;
        }
      }
  
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Vertex_ids.length - 1; o >= 0; o--) {
          if (this.Vertex_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Vertex_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Vertex_ids, found_at + 1);
  
        this.Vertex_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Vertex_ids = (int[]) concat(this.Vertex_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
  
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Solid_ids.length - 1; o >= 0; o--) {
          if (this.Solid_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Solid_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Solid_ids, found_at + 1);
  
        this.Solid_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Solid_ids = (int[]) concat(this.Solid_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Section_ids.length - 1; o >= 0; o--) {
          if (this.Section_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Section_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Section_ids, found_at + 1);
  
        this.Section_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Section_ids = (int[]) concat(this.Section_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      int OBJ_NUM = int(RxP[0]);
  
      int found_at = -1;
  
      int use_it = 0; // 0:nothing 1:add -1:subtract
  
      if (addNewSelectionToPreviousSelection == 0) use_it = 1;
      if (addNewSelectionToPreviousSelection == 1) use_it = 1;
      if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
      if (addNewSelectionToPreviousSelection != 0) {
  
        for (int o = this.Camera_ids.length - 1; o >= 0; o--) {
          if (this.Camera_ids[o] == OBJ_NUM) {
            found_at = o;
            if (addNewSelectionToPreviousSelection == 1) {
              use_it = 0;
            }
            if (addNewSelectionToPreviousSelection == -1) {
              use_it = -1;
            }
            break;
          }
        }
      }
  
      if (use_it == -1) {
        int[] startList = (int[]) subset(this.Camera_ids, 0, found_at);
        int[] endList = (int[]) subset(this.Camera_ids, found_at + 1);
  
        this.Camera_ids = (int[]) concat(startList, endList);
      }
  
      if (use_it == 1) {
        int[] newObject_id = {
          OBJ_NUM
        };
  
        this.Camera_ids = (int[]) concat(this.Camera_ids, newObject_id);
      }
  
      WIN3D.update = true;
  
      this.calculate_selection_BoundingBox();
    }
  }
  
  
  void selectRect (float corner1x, float corner1y, float corner2x, float corner2y) {
  
    if (addNewSelectionToPreviousSelection == 0) allModel3Ds.deselect_All();
  
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < Land3D.num_rows * Land3D.num_columns; OBJ_NUM++) {
  
        int i = OBJ_NUM / Land3D.num_columns;
        int j = OBJ_NUM % Land3D.num_columns;      
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        for (int k = 0; k < 1; k++) { // just a loop to make those break commands relevant!  
  
          float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
          float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
          float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }
        }        
  
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.LandPoint_ids.length - 1; o >= 0; o--) {
              if (this.LandPoint_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.LandPoint_ids, 0, found_at);
            int[] endList = (int[]) subset(this.LandPoint_ids, found_at + 1);
  
            this.LandPoint_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.LandPoint_ids = (int[]) concat(this.LandPoint_ids, newObject_id);
          }
        }
      }
    }   
  
  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allModel1Ds.Faces.length; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        int f = OBJ_NUM;
  
        for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {
  
          int vNo = allModel1Ds.Faces[f][j];
  
          float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
          float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                  
  
          if (break_loops == 1) break;
        }
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Model1D_ids.length - 1; o >= 0; o--) {
              if (this.Model1D_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Model1D_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Model1D_ids, found_at + 1);
  
            this.Model1D_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Model1D_ids = (int[]) concat(this.Model1D_ids, newObject_id);
          }
        }
      }
    }    
  
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1]) {
  
          if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
          if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
          for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
            if ((0 <= f) && (f < allFaces.nodes.length)) { 
  
              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                int vNo = allFaces.nodes[f][j];
  
                float x = allPoints.getX(vNo) * OBJECTS_scale;
                float y = allPoints.getY(vNo) * OBJECTS_scale;            
                float z = -allPoints.getZ(vNo) * OBJECTS_scale;
  
                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                    if (mouseButton == RIGHT) {
                      include_OBJ_in_newSelection = 1;
                      break_loops = 1;
                    }
                  } else {
                    if (mouseButton == LEFT) {
                      include_OBJ_in_newSelection = 0;
                      break_loops = 1;
                    }
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }                        
  
                if (break_loops == 1) break;
              }
  
              if (break_loops == 1) break;
            }
          }
        }
        
        if (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1]) {
  
          if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
          if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
          for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
            if ((0 <= f) && (f < allCurves.nodes.length)) { 
  
              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                int vNo = allCurves.nodes[f][j];
  
                float x = allPoints.getX(vNo) * OBJECTS_scale;
                float y = allPoints.getY(vNo) * OBJECTS_scale;            
                float z = -allPoints.getZ(vNo) * OBJECTS_scale;
  
                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
                    if (mouseButton == RIGHT) {
                      include_OBJ_in_newSelection = 1;
                      break_loops = 1;
                    }
                  } else {
                    if (mouseButton == LEFT) {
                      include_OBJ_in_newSelection = 0;
                      break_loops = 1;
                    }
                  }
                } else {
                  if (mouseButton == LEFT) {
                    include_OBJ_in_newSelection = 0;
                    break_loops = 1;
                  }
                }                        
  
                if (break_loops == 1) break;
              }
  
              if (break_loops == 1) break;
            }
          }
        }      
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Group_ids.length - 1; o >= 0; o--) {
              if (this.Group_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Group_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Group_ids, found_at + 1);
  
            this.Group_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Group_ids = (int[]) concat(this.Group_ids, newObject_id);
          }
        }
      }
    }
  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allFaces.nodes.length; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        for (int j = 0; j < allFaces.nodes[OBJ_NUM].length; j++) {
          int vNo = allFaces.nodes[OBJ_NUM][j];
  
          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;            
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                        
  
          if (break_loops == 1) break;
        }
  
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Face_ids.length - 1; o >= 0; o--) {
              if (this.Face_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Face_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Face_ids, found_at + 1);
  
            this.Face_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Face_ids = (int[]) concat(this.Face_ids, newObject_id);
          }
        }
      }
    }                
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allCurves.nodes.length; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        for (int j = 0; j < allCurves.nodes[OBJ_NUM].length; j++) {
          int vNo = allCurves.nodes[OBJ_NUM][j];
  
          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;            
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                        
  
          if (break_loops == 1) break;
        }
  
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Curve_ids.length - 1; o >= 0; o--) {
              if (this.Curve_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Curve_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Curve_ids, found_at + 1);
  
            this.Curve_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Curve_ids = (int[]) concat(this.Curve_ids, newObject_id);
          }
        }
      }
    }    
  
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allPoints.getLength(); OBJ_NUM++) {
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        float x = allPoints.getX(OBJ_NUM) * OBJECTS_scale;
        float y = allPoints.getY(OBJ_NUM) * OBJECTS_scale;            
        float z = -allPoints.getZ(OBJ_NUM) * OBJECTS_scale;
  
        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
            if (mouseButton == RIGHT) {
              include_OBJ_in_newSelection = 1;
            }
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
            }
          }
        } else {
          if (mouseButton == LEFT) {
            include_OBJ_in_newSelection = 0;
          }
        }                        
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Vertex_ids.length - 1; o >= 0; o--) {
              if (this.Vertex_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Vertex_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Vertex_ids, found_at + 1);
  
            this.Vertex_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Vertex_ids = (int[]) concat(this.Vertex_ids, newObject_id);
          }
        }
      }
    }             
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      for (int f = 0; f < allModel2Ds.Faces.length; f++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        int OBJ_NUM = f / allModel2Ds.num_visualFaces;
  
        //println(f, OBJ_NUM);
  
        for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {
  
          int vNo = allModel2Ds.Faces[f][j];
  
          float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
          float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                  
  
          if (break_loops == 1) break;
        }
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Model2D_ids.length - 1; o >= 0; o--) {
              if (this.Model2D_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Model2D_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Model2D_ids, found_at + 1);
  
            this.Model2D_ids = (int[]) concat(startList, endList);
          }
  
  
  
          if (use_it == 1) {
            
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Model2D_ids = (int[]) concat(this.Model2D_ids, newObject_id);
            
            // skip the same object's drawn faces
            f += allModel2Ds.num_visualFaces - (f % allModel2Ds.num_visualFaces) - 1;
          }
        }
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      for (int f = 0; f < allSolids.Faces.length; f++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        int OBJ_NUM = f / allSolids.num_visualFaces;
  
        //println(f, OBJ_NUM);
  
        for (int j = 0; j < allSolids.Faces[f].length; j++) {
  
          int vNo = allSolids.Faces[f][j];
  
          float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
          float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                  
  
          if (break_loops == 1) break;
        }
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Solid_ids.length - 1; o >= 0; o--) {
              if (this.Solid_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Solid_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Solid_ids, found_at + 1);
  
            this.Solid_ids = (int[]) concat(startList, endList);
          }
  
  
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Solid_ids = (int[]) concat(this.Solid_ids, newObject_id);
            
            // skip the same object's drawn faces
            f += allSolids.num_visualFaces - (f % allSolids.num_visualFaces) - 1;          
          }
        }
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allSections.Faces.length; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        int f = OBJ_NUM;
  
        for (int j = 0; j < allSections.Faces[f].length; j++) {
  
          int vNo = allSections.Faces[f][j];
  
          float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
          float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                  
  
          if (break_loops == 1) break;
        }
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Section_ids.length - 1; o >= 0; o--) {
              if (this.Section_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Section_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Section_ids, found_at + 1);
  
            this.Section_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Section_ids = (int[]) concat(this.Section_ids, newObject_id);
          }
        }
      }
    }  
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      for (int OBJ_NUM = 0; OBJ_NUM < allCameras.Faces.length; OBJ_NUM++) {
  
        int break_loops = 0;
  
        int include_OBJ_in_newSelection = -1;    
  
        if (mouseButton == RIGHT) include_OBJ_in_newSelection = 0;
        if (mouseButton == LEFT) include_OBJ_in_newSelection = 1;
  
        int f = OBJ_NUM;
  
        for (int j = 0; j < allCameras.Faces[f].length; j++) {
  
          int vNo = allCameras.Faces[f][j];
  
          float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
          float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
          float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;
  
          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            
  
          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], corner1x, corner1y, corner2x, corner2y) == 1) {
              if (mouseButton == RIGHT) {
                include_OBJ_in_newSelection = 1;
                break_loops = 1;
              }
            } else {
              if (mouseButton == LEFT) {
                include_OBJ_in_newSelection = 0;
                break_loops = 1;
              }
            }
  
            if (break_loops == 1) break;
          } else {
            if (mouseButton == LEFT) {
              include_OBJ_in_newSelection = 0;
              break_loops = 1;
            }
          }                  
  
          if (break_loops == 1) break;
        }
  
  
        if (include_OBJ_in_newSelection == 1) {
  
          int found_at = -1;
  
          int use_it = 0; // 0:nothing 1:add -1:subtract
  
          if (addNewSelectionToPreviousSelection == 0) use_it = 1;
          if (addNewSelectionToPreviousSelection == 1) use_it = 1;
          if (addNewSelectionToPreviousSelection == -1) use_it = 0;
  
          if (addNewSelectionToPreviousSelection != 0) {
  
            for (int o = this.Camera_ids.length - 1; o >= 0; o--) {
              if (this.Camera_ids[o] == OBJ_NUM) {
                found_at = o;
                if (addNewSelectionToPreviousSelection == 1) {
                  use_it = 0;
                }
                if (addNewSelectionToPreviousSelection == -1) {
                  use_it = -1;
                }
                break;
              }
            }
          }
  
          if (use_it == -1) {
            int[] startList = (int[]) subset(this.Camera_ids, 0, found_at);
            int[] endList = (int[]) subset(this.Camera_ids, found_at + 1);
  
            this.Camera_ids = (int[]) concat(startList, endList);
          }
  
          if (use_it == 1) {
            int[] newObject_id = {
              OBJ_NUM
            };
  
            this.Camera_ids = (int[]) concat(this.Camera_ids, newObject_id);
          }
        }
      }
    }
  }
  
  
  

  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setInt("posVector", this.posVector);
    parent.setInt("rotVector", this.rotVector);
    parent.setInt("scaleVector", this.scaleVector);
    parent.setFloat("posValue", this.posValue);
    parent.setFloat("rotValue", this.rotValue);
    parent.setFloat("scaleValue", this.scaleValue);
    parent.setInt("alignX", this.alignX);
    parent.setInt("alignY", this.alignY);
    parent.setInt("alignZ", this.alignZ);
  
    parent.setString("Face_displayEdges", Boolean.toString(this.Face_displayEdges));
    parent.setString("Face_displayVertexCount", Boolean.toString(this.Face_displayVertexCount));
    parent.setString("Curve_displayVertexCount", Boolean.toString(this.Curve_displayVertexCount));
    parent.setString("Vertex_displayVertices", Boolean.toString(this.Vertex_displayVertices));
    parent.setString("Curve_displayVertices", Boolean.toString(this.Curve_displayVertices));
    parent.setString("Group_displayPivot", Boolean.toString(this.Group_displayPivot));  
    parent.setString("displayReferencePivot", Boolean.toString(this.displayReferencePivot));
    parent.setString("Group_displayEdges", Boolean.toString(this.Group_displayEdges));
    parent.setString("Group_displayBox", Boolean.toString(this.Group_displayBox));
    parent.setString("Model2D_displayEdges", Boolean.toString(this.Model2D_displayEdges));
    parent.setString("Model1D_displayEdges", Boolean.toString(this.Model1D_displayEdges));
    parent.setString("Solid_displayEdges", Boolean.toString(this.Solid_displayEdges));
    parent.setString("Section_displayEdges", Boolean.toString(this.Section_displayEdges));
    parent.setString("Camera_displayEdges", Boolean.toString(this.Camera_displayEdges));
    parent.setString("LandPoint_displayPoints", Boolean.toString(this.LandPoint_displayPoints));
  
    parent.setFloat("softPower", this.softPower);
    parent.setFloat("softRadius", this.softRadius);    
    
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".LandPoint_ids");
      int ni = this.LandPoint_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.LandPoint_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Model1D_ids");
      int ni = this.Model1D_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Model1D_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Model2D_ids");
      int ni = this.Model2D_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Model2D_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Group_ids");
      int ni = this.Group_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Group_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Face_ids");
      int ni = this.Face_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Face_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Curve_ids");
      int ni = this.Curve_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Curve_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Vertex_ids");
      int ni = this.Vertex_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Vertex_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Vertex_softSelectionVertices");
      int ni = this.Vertex_softSelectionVertices.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Vertex_softSelectionVertices[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Vertex_softSelectionValues");
      int ni = this.Vertex_softSelectionValues.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += nf(this.Vertex_softSelectionValues[i], 0, 4).replace(",", "."); // <<<<
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Solid_ids");
      int ni = this.Solid_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Solid_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Section_ids");
      int ni = this.Section_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Section_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }
  
    {
      XML child = xml.addChild(this.CLASS_STAMP + ".Camera_ids");
      int ni = this.Camera_ids.length;
      child.setInt("ni", ni);
      String lineSTR = "";
      for (int i = 0; i < ni; i++) {
        lineSTR += this.Camera_ids[i];
        if (i < ni - 1) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
  }
  


  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);

    this.posVector = parent.getInt("posVector");
    this.rotVector = parent.getInt("rotVector");
    this.scaleVector = parent.getInt("scaleVector");
    this.posValue = parent.getFloat("posValue");
    this.rotValue = parent.getFloat("rotValue");
    this.scaleValue = parent.getFloat("scaleValue");
    this.alignX = parent.getInt("alignX");
    this.alignY = parent.getInt("alignY");
    this.alignZ = parent.getInt("alignZ");

    this.displayReferencePivot = Boolean.parseBoolean(parent.getString("displayReferencePivot"));
    this.Group_displayPivot = Boolean.parseBoolean(parent.getString("Group_displayPivot"));
    this.Group_displayEdges = Boolean.parseBoolean(parent.getString("Group_displayEdges"));
    this.Group_displayBox = Boolean.parseBoolean(parent.getString("Group_displayBox"));
    this.Face_displayEdges = Boolean.parseBoolean(parent.getString("Face_displayEdges"));
    this.Face_displayVertexCount = Boolean.parseBoolean(parent.getString("Face_displayVertexCount"));
    this.Curve_displayVertexCount = Boolean.parseBoolean(parent.getString("Curve_displayVertexCount"));
    this.Vertex_displayVertices = Boolean.parseBoolean(parent.getString("Vertex_displayVertices"));      
    this.Curve_displayVertices = Boolean.parseBoolean(parent.getString("Curve_displayVertices"));
    this.Model2D_displayEdges = Boolean.parseBoolean(parent.getString("Model2D_displayEdges"));
    this.Model1D_displayEdges = Boolean.parseBoolean(parent.getString("Model1D_displayEdges"));
    this.Solid_displayEdges = Boolean.parseBoolean(parent.getString("Solid_displayEdges"));
    this.Section_displayEdges = Boolean.parseBoolean(parent.getString("Section_displayEdges"));
    this.Camera_displayEdges = Boolean.parseBoolean(parent.getString("Camera_displayEdges"));
    this.LandPoint_displayPoints = Boolean.parseBoolean(parent.getString("LandPoint_displayPoints"));

    this.softPower = parent.getFloat("softPower");
    this.softRadius = parent.getFloat("softRadius");

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".LandPoint_ids");
    
      int ni = child.getInt("ni");
      this.LandPoint_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.LandPoint_ids[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Model1D_ids");
    
      int ni = child.getInt("ni");
      this.Model1D_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Model1D_ids[i] = int(parts[i]);
      }
    } 

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Model2D_ids");
    
      int ni = child.getInt("ni");
      this.Model2D_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Model2D_ids[i] = int(parts[i]);
      }
    } 

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Group_ids");
    
      int ni = child.getInt("ni");
      this.Group_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Group_ids[i] = int(parts[i]);
      }
    } 

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Face_ids");
    
      int ni = child.getInt("ni");
      this.Face_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Face_ids[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Curve_ids");
    
      int ni = child.getInt("ni");
      this.Curve_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Curve_ids[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Vertex_ids");
    
      int ni = child.getInt("ni");
      this.Vertex_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Vertex_ids[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Vertex_softSelectionVertices");
    
      int ni = child.getInt("ni");
      this.Vertex_softSelectionVertices = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Vertex_softSelectionVertices[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Vertex_softSelectionValues");
    
      int ni = child.getInt("ni");
      this.Vertex_softSelectionValues = new float [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Vertex_softSelectionValues[i] = float(parts[i]);
      }
    }


    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Solid_ids");
    
      int ni = child.getInt("ni");
      this.Solid_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Solid_ids[i] = int(parts[i]);
      }
    }


    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Section_ids");
    
      int ni = child.getInt("ni");
      this.Section_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Section_ids[i] = int(parts[i]);
      }
    }

    {
      XML child = xml.getChild(this.CLASS_STAMP + ".Camera_ids");
    
      int ni = child.getInt("ni");
      this.Camera_ids = new int [ni];
      String lineSTR = child.getContent();
      String[] parts = split(lineSTR, ',');
      for (int i = 0; i < ni; i++) {
        this.Camera_ids[i] = int(parts[i]);
      }
    }
  }

}

solarchvision_Selections userSelections = new solarchvision_Selections();     


float[][] saved_BoundingBox = userSelections.BoundingBox;

int saved_alignX = userSelections.alignX;
int saved_alignY = userSelections.alignY;
int saved_alignZ = userSelections.alignZ;  


int addNewSelectionToPreviousSelection = 0; // internal

boolean addToLastGroup = false; // internal










int Load_DefaultModels = 0; // internal

int[] GRIB2_TGL_Selected = {
  1, 0, 0, 0
}; // for levels above ground level 
int GRIB2_TGL_number = GRIB2_TGL_Selected.length;


















PrintWriter[] FILE_outputRaw;
PrintWriter[] FILE_outputNorms;
PrintWriter[] FILE_outputProbs;



void setup () {

  //size(1200, 696, P2D);
  size(2 * SOLARCHVISION_pixel_W + ROLLOUT.dX, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + SOLARCHVISION_pixel_D, P2D);


  SOLARCHVISION_draw_frameIcon();

  TIME.date = (286 + TIME.convert2Date(TIME.month, TIME.day)) % 365; // 0 presents March 21, 286 presents Jan.01, 345 presents March.01
  //if (TIME.hour >= 12) TIME.date += 0.5;   

  SOLARCHVISION_empty_Materials_DirectArea();
  SOLARCHVISION_empty_Materials_DiffuseArea();

  VertexSolar_resize_array(); 
  GlobalSolar_resize_array();
  
  Tropo3D.resize_images();
  
  Earth3D.resize_images();

  Sun3D.load_images();
  Moon3D.load_images();

  WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

  WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);  

  STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  
  SKY2D_graphics = createGraphics(SKY2D_X_View, SKY2D_Y_View, P3D);

  SOLARCHVISION_loadDefaultFontStyle();  

  changeCurrentLayerTo(8); // pointing to air temperature variable i.e. on the list of allLayers 

  frameRate(24);

  loop();
}

void SOLARCHVISION_draw_frameIcon () {
  int frame_icon_size = 64;

  PGraphics frame_icon = createGraphics(frame_icon_size, frame_icon_size);  

  frame_icon.beginDraw();

  //frame_icon.image(loadImage(BaseFolder + "/Input/BackgroundImages/Standard/Maps/Icon/s-icon.png"), 0, 0 );

  frame_icon.background(0);
  //frame_icon.background(63,63,255,255);

  //frame_icon.fill(255,127);
  frame_icon.fill(255, 255, 0, 127);

  frame_icon.textAlign(CENTER, CENTER);
  frame_icon.textSize(1.0 * frame_icon_size);
  frame_icon.text("S", 0.20 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("A", 0.50 * frame_icon_size, 0.4 * frame_icon_size);
  frame_icon.text("V", 0.80 * frame_icon_size, 0.4 * frame_icon_size);

  frame_icon.endDraw();
  frame.setIconImage(frame_icon.image);  

  frame.setTitle("SOLARCHVISION-" + SOLARCHVISION_version);
}



void SOLARCHVISION_update_station (int Step) {

  if ((Step == 0) || (Step == 1)) {

    VertexSolar_rebuild_array = true;
    GlobalSolar_rebuild_array = true;
    allSolarImpacts.rebuild_Image_array = true;
    allWindRoses.rebuild_Image_array = true;    

    WORLD.update = true;
    WIN3D.update = true; 
    STUDY.update = true;

    LocationLAT = STATION.getLatitude();
    LocationLON = STATION.getLongitude();

    WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
    
    TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
  }

  if ((Step == 0) || (Step == 2)) update_CLIMATE_TMYEPW();

  if ((Step == 0) || (Step == 3)) update_CLIMATE_CWEEDS();  
  
  if ((Step == 0) || (Step == 4)) update_CLIMATE_CLMREC();

  if ((Step == 0) || (Step == 5)) SOLARCHVISION_update_ENSEMBLE_OBSERVED();

  if ((Step == 0) || (Step == 6)) update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

  if ((Step == 0) || (Step == 7)) Land3D.update_mesh();
}

void SOLARCHVISION_update_models (int Step) {

  if ((Step == 0) || (Step == 1)) allModel3Ds.delete_allGroups(); //not deleting all
  if ((Step == 0) || (Step == 2)) allModel3Ds.add_Model_Main();
}


int Last_initializationStep = 1000;
int InitializationStep = 0;





 

void draw () {

  //println("frameCount:", frameCount);

  Impact_TYPE = STUDY.PlotImpacts % 2; // <<<<<<<<<<<

  
  
  if (frameCount == 1) {

    background(223);

    SOLARCHVISION_update_folders();

    float cr;

    cr = SOLARCHVISION_pixel_W / 4.0;
    PImage SOLARCHVISION_logo = loadImage(Folder_Backgrounds + "/" + "SOLARCHVISION.jpg");
    imageMode(CENTER);
    image(SOLARCHVISION_logo, 0.5 * width, 0.5 * height - 0.75 * MessageSize - cr + (0.075 * cr), 3.05 * cr, 3.05 * cr);
    imageMode(CORNER);

    strokeWeight(1);
    stroke(0);
    noFill();


    ellipseMode(CENTER);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);
    strokeWeight(1);
    stroke(255);
    noFill();    
    SOLARCHVISION_draw_logo(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.2 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(1);
    stroke(127);
    noFill();  
    //SOLARCHVISION_draw_logo(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, 0);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.5 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);
    stroke(191);
    fill(191);    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);    
    strokeWeight(1);
    stroke(255);
    noFill();  
    SOLARCHVISION_draw_logo(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 0, cr, -1);
    strokeWeight(2);
    stroke(0);
    noFill();    
    ellipse(0.8 * width, 0.5 * height - 0.75 * MessageSize - cr, 2 * cr, 2 * cr);

    strokeWeight(0);

    stroke(255);
    fill(255);
    textAlign(CENTER, CENTER); 
    textSize(3 * MessageSize);
    text("SOLARCHVISION model integrations " + SOLARCHVISION_version, 0.5 * width, 0.05 * height); 

    stroke(0);
    fill(0);
    textAlign(CENTER, CENTER); 
    textSize(1.5 * MessageSize);
    text("Raz, Mehr, Mehraz solarch studio\n1998-" + SOLARCHVISION_version + "\nAuthor: Mojtaba Samimi\nwww.solarchvision.com", 0.5 * width, 0.75 * height);

    textAlign(CENTER, CENTER); 
    textSize(MessageSize);
  } else if (frameCount == 2) {
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("WORLD.listAllImages", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 3) {
    WORLD.listAllImages();
    WORLD.loadImages(WORLD.VIEW_id); // to load the globe image into memory

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Model2Ds.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 4) {
    allModel2Ds.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_SWOB", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 5) {
    inputCoordinates_SWOB(); 

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_NAEFS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 6) {
    inputCoordinates_NAEFS(); 
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 7) {
    inputCoordinates_CWEEDS();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 8) {
    inputCoordinates_CLMREC();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("inputCoordinates_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 9) {
    inputCoordinates_TMYEPW();  
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("TIME.updateDate", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 10) {
    TIME.updateDate();
    
    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_station(start)", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 11) {
    SOLARCHVISION_update_station(1);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_TMYEPW", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 12) {
    SOLARCHVISION_update_station(2);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_CWEEDS", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 13) {
    SOLARCHVISION_update_station(3);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_CLIMATE_CLMREC", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 14) {
    SOLARCHVISION_update_station(4);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_ENSEMBLE_OBSERVED", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 15) {
    SOLARCHVISION_update_station(5);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("update_ENSEMBLE_FORECAST", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 16) {
    SOLARCHVISION_update_station(6);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Land3D.update_mesh", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 17) {
    SOLARCHVISION_update_station(7);

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Earth3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 18) {
    Earth3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);    
    
    stroke(255); fill(255); text("Tropo3D.load_images", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 19) {
    Tropo3D.load_images();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY);    
 
    stroke(255); fill(255); text("build_SkySphere", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);
  } else if (frameCount == 20) {
    
    SOLARCHVISION_build_SkySphere(1); //1 - 3
    GlobalSolar_resize_array();    
    VertexSolar_resize_array();

    stroke(0); fill(0); rect(MESSAGE.cX, MESSAGE.cY, MESSAGE.dX, MESSAGE.dY); 

    stroke(255); fill(255); text("Please wait while integrating the models.", MESSAGE.cX + 0.5 * MESSAGE.dX, MESSAGE.cY + 0.5 * MESSAGE.dY);

    MESSAGE.dX = 2 * SOLARCHVISION_pixel_W;

    SOLARCHVISION_X_clicked = -1;
    SOLARCHVISION_Y_clicked = -1;
    
    UI_BAR_a.update = true;
    UI_BAR_b.update = true;
    UI_BAR_c.update = true;
    UI_BAR_d.update = true;

    InitializationStep = frameCount; 
    Last_initializationStep = frameCount;
  } else {
    
    if (ROLLOUT.include) {
      if (ROLLOUT.update) {
        ROLLOUT.update = false;

        pre_SampleYear_Start = SampleYear_Start;
        pre_SampleYear_End = SampleYear_End;
        pre_SampleMember_Start = SampleMember_Start;
        pre_SampleMember_End = SampleMember_End;
        pre_SampleStation_Start = SampleStation_Start; 
        pre_SampleStation_End = SampleStation_End;
        pre_STUDY_joinDays = STUDY.joinDays;
        pre_STUDY_i_Start = STUDY.i_Start;
        pre_STUDY_i_End = STUDY.i_End;        
        pre_STUDY_j_End = STUDY.j_End;
        pre_IMPACTS_displayDay = IMPACTS_displayDay;
        pre_STUDY_Setup = STUDY.plotSetup;
        pre_CurrentDataSource = CurrentDataSource;
        pre_TIME_Year = TIME.year;
        pre_TIME_Month = TIME.month;
        pre_TIME_Day = TIME.day;
        pre_TIME_Date = TIME.date;
        pre_TIME_Hour = TIME.hour;
        pre_CLIMATIC_SolarForecast = CLIMATIC_SolarForecast;
        pre_CLIMATIC_WeatherForecast = CLIMATIC_WeatherForecast;

        pre_CLIMATE_TMYEPW_load = CLIMATE_TMYEPW_load;
        pre_CLIMATE_CWEEDS_load = CLIMATE_CWEEDS_load;
        pre_CLIMATE_CLMREC_load = CLIMATE_CLMREC_load;
        pre_ENSEMBLE_FORECAST_load = ENSEMBLE_FORECAST_load;
        pre_ENSEMBLE_OBSERVED_load = ENSEMBLE_OBSERVED_load;       

        pre_LocationLAT = LocationLAT;
        pre_LocationLON = LocationLON;

        pre_WORLD_autoView = WORLD.autoView;

        pre_Land3D_loadMesh = Land3D.loadMesh;
        pre_Land3D_loadTextures = Land3D.loadTextures;

        pre_allSolids_pallet_CLR = allSolids.pallet_CLR;
        pre_allSolids_pallet_DIR = allSolids.pallet_DIR; 
        pre_allSolids_pallet_MLT = allSolids.pallet_MLT;         

        pre_USER_create_powAll = User3D.create_powAll;

        pre_allSolidImpacts_U_scale = allSolidImpacts.U_scale;
        pre_allSolidImpacts_V_scale = allSolidImpacts.V_scale;

        pre_allSolidImpacts_sU_offset = allSolidImpacts.U_offset;
        pre_allSolidImpacts_sV_offset = allSolidImpacts.V_offset;

        pre_allSolidImpacts_Grade = allSolidImpacts.Grade;
        pre_allSolidImpacts_Power = allSolidImpacts.Power;
        pre_allSolidImpacts_Rotation[allSolidImpacts.sectionType] = allSolidImpacts.rotation[allSolidImpacts.sectionType];
        pre_allSolidImpacts_Elevation[allSolidImpacts.sectionType] = allSolidImpacts.elevation[allSolidImpacts.sectionType];

        pre_allSolidImpacts_Wspd = allSolidImpacts.WindSpeed; 
        pre_allSolidImpacts_Wdir = allSolidImpacts.WindDirection;

        pre_allSolidImpacts_Process_subDivisions = allSolidImpacts.Process_subDivisions;

        pre_allSolidImpacts_displayPoints = allSolidImpacts.displayPoints;
        pre_allSolidImpacts_displayLines = allSolidImpacts.displayLines;

        pre_WindFlow_display = allWindFlows.displayAll;



        pre_Selection_Solid_displayEdges = userSelections.Solid_displayEdges;

        pre_Selection_Section_displayEdges = userSelections.Section_displayEdges;

        pre_Selection_Camera_displayEdges = userSelections.Camera_displayEdges;

        pre_Selection_LandPoint_displayPoints = userSelections.LandPoint_displayPoints;

        pre_Selection_Model1D_displayEdges = userSelections.Model1D_displayEdges;
        pre_Selection_Model2D_displayEdges = userSelections.Model2D_displayEdges;
        pre_allPoints_displayAll = allPoints.displayAll;
        pre_allFaces_displayEdges = allFaces.displayEdges;
        pre_allFaces_displayNormals = allFaces.displayNormals;

        pre_Selection_softPower = userSelections.softPower;
        pre_Selection_softRadius = userSelections.softRadius;


        pre_Selection_posValue = userSelections.posValue;
        pre_Selection_rotValue = userSelections.rotValue;
        pre_Selection_scaleValue = userSelections.scaleValue;        

        pre_Selection_alignX = userSelections.alignX;
        pre_Selection_alignY = userSelections.alignY;
        pre_Selection_alignZ = userSelections.alignZ;

        pre_Selection_displayReferencePivot = userSelections.displayReferencePivot;

        pre_Selection_Group_displayPivot = userSelections.Group_displayPivot;
        pre_Selection_Group_displayEdges = userSelections.Group_displayEdges;
        pre_Selection_Group_displayBox = userSelections.Group_displayBox;        

        pre_Selection_Face_displayEdges = userSelections.Face_displayEdges;
        pre_Selection_Face_displayVertexCount = userSelections.Face_displayVertexCount;
        pre_Selection_Curve_displayVertexCount = userSelections.Curve_displayVertexCount;
        pre_Selection_Vertex_displayVertices = userSelections.Vertex_displayVertices;
        pre_Selection_Curve_displayVertices = userSelections.Curve_displayVertices;

        pre_WIN3D_currentCamera = WIN3D.currentCamera; 

        pre_WIN3D_FacesShade = WIN3D.FacesShade;

        pre_allModel3Ds_Tessellation = allFaces.displayTessellation;


        pre_Load_DefaultModels = Load_DefaultModels;

        pre_STUDY_ImpactLayer = STUDY.ImpactLayer;

        pre_Develop_Option = Develop_Option;

        pre_STUDY_CurrentLayer_id = CurrentLayer_id;

        pre_STUDY_SkyScenario = STUDY.skyScenario;

        pre_STUDY_PlotImpacts = STUDY.PlotImpacts;

        ROLLOUT.drawView();

        if (pre_STUDY_PlotImpacts != STUDY.PlotImpacts) {
          WIN3D.update = true;
          STUDY.update = true;
        }

        if (pre_SampleYear_Start != SampleYear_Start) {
          UI_BAR_d.update = true;
        }            
        if (pre_SampleYear_End != SampleYear_End) {
          UI_BAR_d.update = true;
        }            

        if (pre_SampleMember_Start != SampleMember_Start) {
          UI_BAR_d.update = true;
        }  

        if (pre_SampleMember_End != SampleMember_End) {
          UI_BAR_d.update = true;
        }  

        if (pre_SampleStation_Start != SampleStation_Start) {
          UI_BAR_d.update = true;
        }  

        if (pre_SampleStation_End != SampleStation_End) {
          UI_BAR_d.update = true;
        }  

        if (pre_STUDY_joinDays != STUDY.joinDays) {
          UI_BAR_d.update = true;
        }            

        if (pre_STUDY_i_Start != STUDY.i_Start) {
          UI_BAR_d.update = true;
        }      

        if (pre_STUDY_i_End != STUDY.i_End) {
          UI_BAR_d.update = true;
        }      


        if (pre_STUDY_j_End != STUDY.j_End) {
          UI_BAR_d.update = true;

          VertexSolar_rebuild_array = true;
          GlobalSolar_rebuild_array = true;
          allSolarImpacts.rebuild_Image_array = true;
          allWindRoses.rebuild_Image_array = true;      

          allSections.resize_solarImpact_array();
        }

        if (pre_IMPACTS_displayDay != IMPACTS_displayDay) {
          UI_BAR_d.update = true;
        }

        if (pre_TIME_Date != TIME.date) {
          UI_BAR_d.update = true;

          TIME.updateDate();
          ROLLOUT.drawView();
        }

        if ((pre_TIME_Year != TIME.year) || (pre_TIME_Month != TIME.month) || (pre_TIME_Day != TIME.day) || (pre_TIME_Hour != TIME.hour) || (pre_CLIMATIC_SolarForecast != CLIMATIC_SolarForecast) || (pre_CLIMATIC_WeatherForecast != CLIMATIC_WeatherForecast)) {
          UI_BAR_d.update = true;

          TIME.beginDay = TIME.convert2Date(TIME.month, TIME.day);
          TIME.hour = int(24 * (TIME.date - int(TIME.date)));
          TIME.date = (TIME.hour / 24.0) + (286 + TIME.convert2Date(TIME.month, TIME.day)) % 365;
          println("DATE:", TIME.date, "\tHOUR:", TIME.hour);
          update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

          ROLLOUT.drawView();
        }

        

        if (pre_CLIMATE_TMYEPW_load != CLIMATE_TMYEPW_load) update_CLIMATE_TMYEPW();
        if (pre_CLIMATE_CWEEDS_load != CLIMATE_CWEEDS_load) update_CLIMATE_CWEEDS();
        if (pre_CLIMATE_CLMREC_load != CLIMATE_CLMREC_load) update_CLIMATE_CLMREC();
        if (pre_ENSEMBLE_OBSERVED_load != ENSEMBLE_OBSERVED_load) SOLARCHVISION_update_ENSEMBLE_OBSERVED();
        if (pre_ENSEMBLE_FORECAST_load != ENSEMBLE_FORECAST_load) update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);

        if (pre_WORLD_autoView != WORLD.autoView) {
          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
        }



        if ((pre_LocationLAT != LocationLAT) || (pre_LocationLON != LocationLON)) {

          WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
          WORLD.update = true;
        }




        if (pre_Land3D_loadMesh != Land3D.loadMesh) {
          Land3D.update_mesh();
          WIN3D.update = true;
        }

        if (pre_Land3D_loadTextures != Land3D.loadTextures) {
          Land3D.update_textures();
          WIN3D.update = true;
        }



        if (pre_Selection_Camera_displayEdges != userSelections.Camera_displayEdges) {
          WIN3D.update = true;
        }

        if (pre_Selection_Section_displayEdges != userSelections.Section_displayEdges) {
          WIN3D.update = true;
        }         

        if (pre_Selection_Solid_displayEdges != userSelections.Solid_displayEdges) {
          WIN3D.update = true;
        }  

        if (pre_Selection_LandPoint_displayPoints != userSelections.LandPoint_displayPoints) {
          WIN3D.update = true;
        }          


        if (pre_Selection_Model1D_displayEdges != userSelections.Model1D_displayEdges) {
          WIN3D.update = true;
        }     

        if (pre_Selection_Model2D_displayEdges != userSelections.Model2D_displayEdges) {
          WIN3D.update = true;
        }     


        if (pre_Selection_softPower != userSelections.softPower) {    
          allModel3Ds.convert_Vertex_to_softSelection();
          WIN3D.update = true;
        }  

        if (pre_Selection_softRadius != userSelections.softRadius) {
          allModel3Ds.convert_Vertex_to_softSelection();
          WIN3D.update = true;
        }  


        if (pre_Selection_alignX != userSelections.alignX) {    
          userSelections.calculate_selection_BoundingBox();
          WIN3D.update = true;
        }        

        if (pre_Selection_alignY != userSelections.alignY) {   
          userSelections.calculate_selection_BoundingBox();
          WIN3D.update = true;
        }      

        if (pre_Selection_alignZ != userSelections.alignZ) {        
          userSelections.calculate_selection_BoundingBox();
          WIN3D.update = true;
        }      

        if (pre_Selection_posValue != userSelections.posValue) {

          float d = userSelections.posValue - pre_Selection_posValue;

          float dx = d;
          float dy = d;
          float dz = d;

          int the_Vector = userSelections.posVector;

          if (the_Vector == 0) {
            dy = 0; 
            dz = 0;
          }  
          if (the_Vector == 1) {
            dz = 0; 
            dx = 0;
          }  
          if (the_Vector == 2) {
            dx = 0; 
            dy = 0;
          }            

          userSelections.move_Selection(dx, dy, dz);
          WIN3D.update = true;
        }
        if (pre_Selection_rotValue != userSelections.rotValue) {

          float[] P = userSelections.getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float r = userSelections.rotValue - pre_Selection_rotValue;

          int the_Vector = userSelections.rotVector;

          userSelections.rotate_Selection(x0, y0, z0, r, the_Vector);
          WIN3D.update = true;
        }
        if (pre_Selection_scaleValue != userSelections.scaleValue) {

          float[] P = userSelections.getPivot();

          float x0 = P[0];
          float y0 = P[1];
          float z0 = P[2];

          float s = pow(2.0, userSelections.scaleValue - pre_Selection_scaleValue);

          float sx = s;
          float sy = s;
          float sz = s;

          int the_Vector = userSelections.scaleVector;

          if (the_Vector == 0) {
            sy = 1; 
            sz = 1;
          }  
          if (the_Vector == 1) {
            sz = 1; 
            sx = 1;
          }  
          if (the_Vector == 2) {
            sx = 1; 
            sy = 1;
          }           

          userSelections.scale_Selection(x0, y0, z0, sx, sy, sz);
          WIN3D.update = true;
        }        


        if (pre_Selection_displayReferencePivot != userSelections.displayReferencePivot) {
          WIN3D.update = true;
        }

        if (pre_Selection_Group_displayPivot != userSelections.Group_displayPivot) {
          WIN3D.update = true;
        }             

        if (pre_Selection_Group_displayEdges != userSelections.Group_displayEdges) {
          WIN3D.update = true;
        }

        if (pre_Selection_Group_displayBox != userSelections.Group_displayBox) {
          WIN3D.update = true;
        }     

        if (pre_Selection_Face_displayEdges != userSelections.Face_displayEdges) {
          WIN3D.update = true;
        }     

        if (pre_Selection_Face_displayVertexCount != userSelections.Face_displayVertexCount) {
          WIN3D.update = true;
        }     
        
        if (pre_Selection_Curve_displayVertexCount != userSelections.Curve_displayVertexCount) {
          WIN3D.update = true;
        }           

        if (pre_Selection_Vertex_displayVertices != userSelections.Vertex_displayVertices) {
          WIN3D.update = true;
        }     

        if (pre_Selection_Curve_displayVertices != userSelections.Curve_displayVertices) {
          WIN3D.update = true;
        }     


        if (pre_WIN3D_currentCamera != WIN3D.currentCamera) {
          WIN3D.apply_currentCamera();

          SOLARCHVISION_modify_Viewport_Title();
          WIN3D.update = true;
        }


        if (pre_WIN3D_FacesShade != WIN3D.FacesShade) {
          WIN3D.update = true;
        }             

        if (pre_allModel3Ds_Tessellation != allFaces.displayTessellation) {
          //VertexSolar_rebuild_array = true;
        }




        if (pre_Load_DefaultModels != Load_DefaultModels) {

          SOLARCHVISION_delete_All();

          allModel3Ds.add_DefaultModel(Load_DefaultModels);

          allSolidImpacts.calculate_Impact_selectedSections();

          WIN3D.update = true;

          ROLLOUT.update = true;
        }


        if (pre_USER_create_powAll != User3D.create_powAll) {
          User3D.create_powX = User3D.create_powAll;
          User3D.create_powY = User3D.create_powAll;
          User3D.create_powZ = User3D.create_powAll;

          ROLLOUT.update = true;
        }


        if (pre_allSolids_pallet_CLR != allSolids.pallet_CLR) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolids_pallet_DIR != allSolids.pallet_DIR) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolids_pallet_MLT != allSolids.pallet_MLT) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }

        if (pre_allSolidImpacts_Grade != allSolidImpacts.Grade) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_Power != allSolidImpacts.Power) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_Rotation[allSolidImpacts.sectionType] != allSolidImpacts.rotation[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_Elevation[allSolidImpacts.sectionType] != allSolidImpacts.elevation[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }

        if (pre_allSolidImpacts_U_scale[allSolidImpacts.sectionType] != allSolidImpacts.U_scale[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_V_scale[allSolidImpacts.sectionType] != allSolidImpacts.V_scale[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }

        if (pre_allSolidImpacts_sU_offset[allSolidImpacts.sectionType] != allSolidImpacts.U_offset[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_sV_offset[allSolidImpacts.sectionType] != allSolidImpacts.V_offset[allSolidImpacts.sectionType]) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }


        if (pre_allSolidImpacts_Wspd != allSolidImpacts.WindSpeed) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }
        if (pre_allSolidImpacts_Wdir != allSolidImpacts.WindDirection) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }


        if (pre_allSolidImpacts_Process_subDivisions != allSolidImpacts.Process_subDivisions) {
          allSolidImpacts.calculate_Impact_selectedSections(); 
          WIN3D.update = true;
        }

        if (pre_allSolidImpacts_displayPoints != allSolidImpacts.displayPoints) WIN3D.update = true;
        if (pre_allSolidImpacts_displayLines != allSolidImpacts.displayLines) WIN3D.update = true;

        if (pre_allPoints_displayAll != allPoints.displayAll) WIN3D.update = true;
        if (pre_allFaces_displayEdges != allFaces.displayEdges) WIN3D.update = true;
        if (pre_allFaces_displayNormals != allFaces.displayNormals) WIN3D.update = true;

        if (pre_WindFlow_display != allWindFlows.displayAll) WIN3D.update = true;


        if (STUDY.plotSetup != pre_STUDY_Setup) {
          STUDY.Impacts_update = true;
          UI_BAR_d.update = false;
        }

        if (CurrentDataSource != pre_CurrentDataSource) {
          STUDY.Impacts_update = true;
          UI_BAR_d.update = false;
        }
      }
    }



    if (FRAME_record_AUTO) {
      if (STUDY.update) FRAME_record_IMG = true;
      if (WIN3D.update) FRAME_record_IMG = true;
      if (WORLD.update) FRAME_record_IMG = true;
      //if (UI_BAR_a.update) FRAME_record_IMG = true;
      //if (UI_BAR_b.update) FRAME_record_IMG = true;
      //if (UI_BAR_d.update) FRAME_record_IMG = true;
    }




    int Illustrations_Animate = 0;

    //if ((STUDY.update == false) && (WIN3D.update == false)) {
    if (STUDY.update == false) {
      //Illustrations_Animate = 1;
    }

    if (STUDY.include) {
      if (STUDY.update) {

        STUDY.drawView();
      }
    }
    STUDY.update = false;

    if (STUDY.record_PDF == false) {
      /*      
       if (Illustrations_Animate != 0) {
       GRIB2_Layer = GRIB2_Layer_Start;
       
       GRIB2_Hour = GRIB2_Hour_Start;
       
       int d = (GRIB2_Hour_End - GRIB2_Hour_Start) / GRIB2_Hour_Step;      
       
       if (d > 1) {
       
       GRIB2_Hour += GRIB2_Hour_Step * (frameCount % d);
       
       if (GRIB2_Hour > GRIB2_Hour_End) GRIB2_Hour = GRIB2_Hour_Start;
       
       WORLD.update = true;
       WIN3D.update = true; // <<<<<<<<<<<
       }
       }
       */

      if (WORLD.include) {
        if (WORLD.update) {

          WORLD.drawView();
        }
      }

      if (WORLD.record_PDF == false) {      
        if (WIN3D.include) {
          if (WIN3D.update) {
            
            SOLARCHVISION_regenerate_desired_bakings();

            WIN3D.drawView();
          }
        }

        if (UI_BAR_a.update) {
          UI_BAR_a.draw();
        }

        if (UI_BAR_b.update) {
          UI_BAR_b.draw();
        }

        if (UI_BAR_c.update) {
          UI_BAR_c.draw();
        }  

        if (UI_BAR_d.update) {
          UI_BAR_d.draw();
        }    



        if (FRAME_record_IMG) {
          SOLARCHVISION_RecordFrame();
          FRAME_record_IMG = false;
        }
      } else {
        WORLD.record_PDF = false;
      }
    } else {
      STUDY.record_PDF = false;
    }


    //WIN3D.update = false;
    //WORLD.update = false;
    //STUDY.update = false;

    //noLoop(); // <<<<<<<<<<<<
  
  }
} 

void SOLARCHVISION_find_which_bakings_to_regenerate () {

  if (WIN3D.FacesShade == SHADE.Global_Solar) {
    GlobalSolar_rebuild_array = true;
  }
  if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
    VertexSolar_rebuild_array = true;
  }  
  if (allSolarImpacts.displayImage) {
    allSolarImpacts.rebuild_Image_array = true;
  }     
  if (allWindRoses.displayImage) {
    allWindRoses.rebuild_Image_array = true;
  }      
}  



void SOLARCHVISION_regenerate_desired_bakings () {
  
  if (VertexSolar_rebuild_array) {
    SOLARCHVISION_calculate_VertexSolar_array();
  }
  
  if (GlobalSolar_rebuild_array) {
    SOLARCHVISION_calculate_GlobalSolar_array();
  }
  
}







class solarchvision_PAINT {
  
  private final static String CLASS_STAMP = "PAINT";
  
  
  int getOpacity (float O_scale) {
    int k = int(O_scale * 0.01 * 256);
    if (k > 255) k = 255;
    if (k < 0) k = 0;
  
    return k;
  }  

  float[] WBGRW (float _variable) {
    _variable *= 600.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
  
    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = v;
      COL[3] = v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
  
  float[] BGR (float _variable) {
    _variable *= 400.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
  
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DBGR (float _variable) {
    _variable *= 500.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DWBGR (float _variable) {
    _variable *= 600.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DWYR (float _variable) {
    _variable *= 400.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < 100) {
      v = ((_variable) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 255 - 0.5 * v;
      COL[2] = 0;
      COL[3] = 0;
    } else {
      COL[1] = 127;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  
  float[] VDWBGR (float _variable) {
    _variable *= 700.0;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < 0) {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 255;
    } else if (_variable < 100) {
      v = ((_variable - 0) * 2.55);
      COL[1] = (255 - v);
      COL[2] = 0;
      COL[3] = (255 - v);
    } else if (_variable < 200) {
      v = ((_variable - 100) * 2.55);
      COL[1] = v;
      COL[2] = v;
      COL[3] = v;
    } else if (_variable < 300) {
      v = ((_variable - 200) * 2.55);
      COL[1] = (255 - v);
      COL[2] = (255 - v);
      COL[3] = 255;
    } else if (_variable < 400) {
      v = ((_variable - 300) * 2.55);
      COL[1] = 0;
      COL[2] = v;
      COL[3] = 255;
    } else if (_variable < 500) {
      v = ((_variable - 400) * 2.55);
      COL[1] = 0;
      COL[2] = 255;
      COL[3] = (255 - v);
    } else if (_variable < 600) {
      v = ((_variable - 500) * 2.55);
      COL[1] = v;
      COL[2] = 255;
      COL[3] = 0;
    } else if (_variable < 700) {
      v = ((_variable - 600) * 2.55);
      COL[1] = 255;
      COL[2] = (255 - v);
      COL[3] = 0;
    } else {
      COL[1] = 255;
      COL[2] = 0;
      COL[3] = 0;
    }
  
    return COL;
  }
  
  float[] DRYWCBD (float _variable) {
  
    _variable *= 1.5;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable <= -2.75) {
      COL[1] = 63;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else if (_variable < 1) {
      v = (_variable * 255);
      COL[1] = 255 - v;
      COL[2] = 255;
      COL[3] = 255;
    } else if (_variable < 2) {
      v = ((_variable - 1) * 255);
      COL[1] = 0;
      COL[2] = 255 - v;
      COL[3] = 255;
    } else if (_variable < 2.75) {
      v = ((_variable - 2) * 255);
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 255 - v;
    } else {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 63;
    }
  
    return COL;
  }
  
  
  float[] DBCW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    float r, g, b;
    r = COL[3]; 
    g = COL[2];
    b = COL[1];
    COL[1] = r;
    COL[2] = g;
    COL[3] = b;
  
    return COL;
  }
  
  float[] DRYW (float _variable) {
    _variable = 1 - _variable;
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
  
  float[] WYRD (float _variable) {
    _variable *= -3;
  
    float v;
    float[] COL = {
      255, 0, 0, 0
    };
    if (_variable < -3) {
      COL[1] = 0;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -2) {
      v = (-(_variable + 2) * 255);
      COL[1] = 255 - v;
      COL[2] = 0;
      COL[3] = 0;
    } else if (_variable < -1) {
      v = (-(_variable + 1) * 255);
      COL[1] = 255;
      COL[2] = 255 - v;
      COL[3] = 0;
    } else if (_variable < 0) {
      v = (-_variable * 255);
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255 - v;
    } else {
      COL[1] = 255;
      COL[2] = 255;
      COL[3] = 255;
    }
  
    return COL;
  }
    
    
  float[] getColorStyle (int COLOR_STYLE_Current, float j) {
    float[] c = {
      255, 0, 0, 0
    };
  
    if (COLOR_STYLE_Current == 0) {
      c[0] = PAINT.getOpacity(STUDY.O_scale);
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == 19) {
      float[] COL = this.DWYR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 18) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 17) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    } else if (COLOR_STYLE_Current == 16) {
      float[] COL = this.DBCW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 15) {
      float[] COL = this.DRYW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 14) {
      float[] COL = this.DBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 13) {
      float[] COL = this.DWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 12) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 11) {
      float[] COL = this.BGR(j);
      c[0] = 127;
      c[1] = 255 - 0.5 * COL[1];
      c[2] = 255 - 0.5 * COL[2];
      c[3] = 255 - 0.5 * COL[3];
    } else if (COLOR_STYLE_Current == 10) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 9) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 8) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 7) {
      float[] COL = this.WBGRW(j);
      c[0] = 255;
      c[1] = 255 - COL[1];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[3];
    } else if (COLOR_STYLE_Current == 6) {
      float[] COL = this.BGR(j);
      c[0] = 255;
      c[1] = COL[3];
      c[2] = COL[2];
      c[3] = COL[1];
    } else if (COLOR_STYLE_Current == 4) {
      float[] COL = this.VDWBGR(j);
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 3) {
      float[] COL = this.VDWBGR(j);
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 2) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = STUDY.O_scale;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = COL[1];
      c[2] = COL[2];
      c[3] = COL[3];
    } else if (COLOR_STYLE_Current == 5) {
      c[0] = 255;
      c[1] = 0;
      c[2] = 0;
      c[3] = 0;
    } else if (COLOR_STYLE_Current == -1) {
      float[] COL = this.DRYWCBD(2.0 * (j - 0.5));
      c[0] = 255;
      c[1] = 255 - COL[3];
      c[2] = 255 - COL[2];
      c[3] = 255 - COL[1];
    } 
  
  
    return c;
  }    
}

solarchvision_PAINT PAINT = new solarchvision_PAINT();









int STAT_N_MidLow = 0;
int STAT_N_Middle = 1;
int STAT_N_MidHigh = 2;

int STAT_N_M25 = 3;
int STAT_N_M50 = 4;
int STAT_N_M75 = 5;

int STAT_N_Min = 6;
int STAT_N_Ave = 7;
int STAT_N_Max = 8;

String[] STAT_N_Title = {
  "Mid-Low*       ", 
  "Middle*        ", 
  "Mid-High*      ", 

  "25th Percentile", 
  "50th P.(Median)", 
  "75th Percentile", 

  "Minimum        ", 
  "Average        ", 
  "Maximum        "
};

int[] STAT_reverse_N;
{
  STAT_reverse_N = new int [9];
  STAT_reverse_N[STAT_N_MidLow] = STAT_N_MidHigh;
  STAT_reverse_N[STAT_N_Middle] = STAT_N_Middle;
  STAT_reverse_N[STAT_N_MidHigh] = STAT_N_MidLow;
  STAT_reverse_N[STAT_N_M25] = STAT_N_M75;
  STAT_reverse_N[STAT_N_M50] = STAT_N_M50;
  STAT_reverse_N[STAT_N_M75] = STAT_N_M25;
  STAT_reverse_N[STAT_N_Min] = STAT_N_Max;
  STAT_reverse_N[STAT_N_Ave] = STAT_N_Ave;
  STAT_reverse_N[STAT_N_Max] = STAT_N_Min;
}

float[] SOLARCHVISION_NORMAL (float[] _values) {

  float[] weight_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  float[] return_array = {
    0, 0, 0, 0, 0, 0, 0, 0, 0
  };

  int NV = 0; // the number of values without counting undefined values
  float _weight = 0; 

  _values = sort(_values);
  for (int i = 0; i < _values.length; i++) {
    if (is_undefined_FLOAT(_values[i]) == false) NV += 1;
  }

  if (NV > 0) {
    for (int i = 0; i < NV; i++) {
      if (is_undefined_FLOAT(_values[i]) == false) {
        _weight = 1;
        weight_array[STAT_N_Ave] += _weight;
        return_array[STAT_N_Ave] += _values[i];

        _weight = (0.5 * (NV + 1)) - abs((0.5 * (NV + 1)) - (i + 1));
        weight_array[STAT_N_Middle] += _weight;
        return_array[STAT_N_Middle] += _values[i] * _weight;

        _weight = (i + 1);
        weight_array[STAT_N_MidHigh] += _weight;
        return_array[STAT_N_MidHigh] += _values[i] * _weight;

        _weight = (NV + 1 - i);
        weight_array[STAT_N_MidLow] += _weight;
        return_array[STAT_N_MidLow] += _values[i] * _weight;
      }
    }

    return_array[STAT_N_Ave] /= weight_array[STAT_N_Ave];
    return_array[STAT_N_Middle] /= weight_array[STAT_N_Middle];
    return_array[STAT_N_MidHigh] /= weight_array[STAT_N_MidHigh];
    return_array[STAT_N_MidLow] /= weight_array[STAT_N_MidLow];

    return_array[STAT_N_Max] = _values[(NV - 1)];
    return_array[STAT_N_Min] = _values[0];

    if ((NV % 2) == 1) {

      return_array[STAT_N_M50] = _values[(floor(NV / 2))];
    } else {

      return_array[STAT_N_M50] = 0.5 * (_values[(floor(NV / 2))] + _values[(floor(NV / 2) - 1)]);
    }

    int q;

    q = int(funcs.roundTo((NV * 0.75), 1));
    if (q > NV - 1) q = NV - 1;
    return_array[STAT_N_M75] = _values[q];

    q = int(funcs.roundTo((NV * 0.25), 1));
    if (q < 0) q = 0;
    return_array[STAT_N_M25] = _values[q];
  } else {
    for (int i = 0; i < return_array.length; i++) {
      return_array[i] = FLOAT_undefined;
    }
  }

  return return_array;
}



int SOLARCHVISION_filter (int dataID, int cloudCover_id, int type_of_filter, int scenario_of_sky, int now_i, int now_j, int now_k) {

  float total_sky = 0;
  int num_sky = 0;

  int start_q = now_i;
  int end_q = now_i;

  if (type_of_filter == filter_DAILY) {
    start_q = 0;
    end_q = 23;
  }

  for (int q = start_q; q <= end_q; q++) {
    float _sky = FLOAT_undefined;
    if (dataID == dataID_ENSEMBLE_OBSERVED)      _sky = ENSEMBLE_OBSERVED_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_ENSEMBLE_FORECAST) _sky = ENSEMBLE_FORECAST_values[q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CWEEDS)    _sky = CLIMATE_CWEEDS_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_CLMREC)    _sky = CLIMATE_CLMREC_values   [q][now_j][cloudCover_id][now_k];
    else if (dataID == dataID_CLIMATE_TMYEPW)    _sky = CLIMATE_TMYEPW_values   [q][now_j][cloudCover_id][now_k];
    else {
      println("ERROR: This dataID is not declared:", dataID);
    }

    if (is_undefined_FLOAT(_sky)) {
    } else {
      total_sky += _sky;
      num_sky += 1;
    }
  }


  int _return = 0;

  if (num_sky != 0) {
    total_sky /= num_sky;

    if (scenario_of_sky == 1) _return = 1;
    else if ((scenario_of_sky == 4) && (total_sky <= 3.33)) _return = 1;
    else if ((scenario_of_sky == 3) && (total_sky > 3.33) && (total_sky <= 6.66)) _return = 1; 
    else if ((scenario_of_sky == 2) && (total_sky > 6.66)) _return = 1;
  }

  return _return;
}


int[] SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS (float[] _values) {

  float[] _normals = SOLARCHVISION_NORMAL(_values);

  int[] return_array = new int [9];

  for (int l = 0; l < 9; l++) {
    return_array[l] = -1;
    if (is_undefined_FLOAT(_normals[l]) == false) {

      float _dist = FLOAT_undefined;

      for (int i = 0; i < _values.length; i++) {
        if (_dist > abs(_normals[l] - _values[i])) {
          _dist = abs(_normals[l] - _values[i]);
          return_array[l] = i;
        }
      }
    } else return_array[l] = -1;
  }

  return return_array;
}


int[] SOLARCHVISION_PROCESS_DAILY_SCENARIOS (int start_k, int end_k, int j, float DATE_ANGLE) {
  
  int count_k = 1 + end_k - start_k;
  if (count_k < 0) count_k = 0;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  float[] valuesSUM_RAD; 
  float[] valuesSUM_EFF;
  float[] valuesNUM;
  valuesSUM_RAD = new float [(count_k * STUDY.joinDays)];
  valuesSUM_EFF = new float [(count_k * STUDY.joinDays)];
  valuesNUM = new float [(count_k * STUDY.joinDays)];

  for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {
    for (int k = 0; k < count_k; k++) { 
      valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] = FLOAT_undefined;
      valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] = FLOAT_undefined;
      valuesNUM[(k * STUDY.joinDays + j_ADD)] = 0;
    }
  }

  for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {

    for (int k = 0; k < count_k; k++) {

      for (int i = 0; i < 24; i++) {

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

        int now_k = k + start_k;
        int now_i = i;
        int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

        if (now_j >= 365) {
          now_j = now_j % 365;
        }
        if (now_j < 0) {
          now_j = (now_j + 365) % 365;
        }

        Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
        Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
        Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
        Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);

        if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
        } else {

          int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k); 

          if (memberCount == 1) {
            values_R_dir = 0.001 * Pa;
            values_R_dif = 0.001 * Pb;
            values_E_dir = 0.0001 * Pc;
            values_E_dif = 0; //0.0001 * Pd;

            if (is_undefined_FLOAT(valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)])) {
              valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] = 0;
              valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] = 0;
              valuesNUM[(k * STUDY.joinDays + j_ADD)] = 0;
            }                  

            valuesSUM_RAD[(k * STUDY.joinDays + j_ADD)] += ((values_R_dir * SunR[3]) + (values_R_dif)); // calculates total horizontal radiation
            valuesSUM_EFF[(k * STUDY.joinDays + j_ADD)] += ((values_E_dir * SunR[3]) + (values_E_dif)); // calculates total horizontal effects
            valuesNUM[(k * STUDY.joinDays + j_ADD)] += 1;
          }
        }
      }
    }
  }

  if (Impact_TYPE == Impact_PASSIVE) 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(valuesSUM_EFF);
  else 
    return SOLARCHVISION_FIND_SCENARIOS_CLOSE_TO_NORMALS(valuesSUM_RAD);
}


 






















int FrameVariation = 0;

void SOLARCHVISION_update_frame_layout () {

  if (FrameVariation == 0) {

    STUDY.include = true;
    WIN3D.include = true;
    WORLD.include = true;

    WIN3D.cX = 0;
    WIN3D.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WIN3D.dX = int(1.5 * SOLARCHVISION_pixel_H);
    WIN3D.dY = SOLARCHVISION_pixel_H;
    WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);

    WORLD.cX = int(1.5 * SOLARCHVISION_pixel_H);
    WORLD.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WORLD.dX = int(2.0 * SOLARCHVISION_pixel_H);
    WORLD.dY = SOLARCHVISION_pixel_H;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + SOLARCHVISION_pixel_H;
    STUDY.dX = 2 * SOLARCHVISION_pixel_W;
    STUDY.dY = 1 * SOLARCHVISION_pixel_H;
    STUDY.view_R = float(STUDY.dY) / float(STUDY.dX);   
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 1) {

    STUDY.include = false;
    WIN3D.include = true;
    WORLD.include = false;

    WIN3D.cX = 0;
    WIN3D.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WIN3D.dX = 2 * SOLARCHVISION_pixel_W;
    WIN3D.dY = 2 * SOLARCHVISION_pixel_H;
    WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
    WIN3D.graphics = createGraphics(WIN3D.dX, WIN3D.dY, P3D);
  } else if (FrameVariation == 2) {

    STUDY.include = true;
    WIN3D.include = false;
    WORLD.include = false;

    STUDY.cX = 0;
    STUDY.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    STUDY.dX = 2 * SOLARCHVISION_pixel_W;
    STUDY.dY = 2 * SOLARCHVISION_pixel_H;
    STUDY.view_R = float(STUDY.dY) / float(STUDY.dX);   
    STUDY.graphics = createGraphics(STUDY.dX, STUDY.dY, P2D);
  } else if (FrameVariation == 3) {

    STUDY.include = false;
    WIN3D.include = false;
    WORLD.include = true;

    WORLD.cX = 0;
    WORLD.cY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 0;
    WORLD.dX = 2 * SOLARCHVISION_pixel_W;
    WORLD.dY = 2 * SOLARCHVISION_pixel_H;
    WORLD.graphics = createGraphics(WORLD.dX, WORLD.dY, P2D);
  } 

  WORLD.update = true;
  WIN3D.update = true; 
  STUDY.update = true;
}




void keyPressed (KeyEvent e) {

  //println("key: " + key);
  //println("keyCode: " + keyCode);  
  
  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;

      if ((UI_BAR_a.selected_parent != -1) || (UI_BAR_a.selected_child != 0)) {

        UI_BAR_a.selected_parent = -1;
        UI_BAR_a.selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_pixel_A);
      }

      addNewSelectionToPreviousSelection = 0;


      if (typeUserCommand == 0) {

        UI_BAR_c.update = false;
        
        STUDY.keyPressed(e);
  
        WIN3D.keyPressed(e);
      }
      else {
        
        UI_BAR_c.update = true;
        
        COMIN_keyPressed(e);
      }
      

      if (e.isAltDown()) {

        if (key == CODED) { 
          switch(keyCode) {
          }
        } else {
          switch(key) {
          case 'l' : 
            FrameVariation = (FrameVariation + 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT.update = true; 
            break;
          case 'L' : 
            FrameVariation = (FrameVariation + 4 - 1) % 4; 
            SOLARCHVISION_update_frame_layout(); 
            ROLLOUT.update = true; 
            break;
          }
        }
      } else if (e.isControlDown()) {

        addNewSelectionToPreviousSelection = 1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : //F1
            ROLLOUT.parent = 0; 
            ROLLOUT.update = true; 
            break;
          case 113 : //F2
            ROLLOUT.parent = 1; 
            ROLLOUT.update = true; 
            break;
          case 114 : //F3
            ROLLOUT.parent = 2; 
            ROLLOUT.update = true; 
            break;
          case 115 : //F4
            ROLLOUT.parent = 3; 
            ROLLOUT.update = true; 
            break;
          case 116 : //F5
            ROLLOUT.parent = 4; 
            ROLLOUT.update = true; 
            break;
          case 117 : //F6
            ROLLOUT.parent = 5; 
            ROLLOUT.update = true; 
            break;
          case 118 : //F7
            ROLLOUT.parent = 6; 
            ROLLOUT.update = true; 
            break;
          case 119 : //F8
            ROLLOUT.parent = 7; 
            ROLLOUT.update = true; 
            break;
          }
        } else {
          switch(key) {

          case 'f' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD.update = true;
            WIN3D.update = true; 
            STUDY.update = true;
            ROLLOUT.update = true; 
            break;

          case 'F' :
            SOLARCHVISION_ResetFontStyle();     
            WORLD.update = true;
            WIN3D.update = true; 
            STUDY.update = true;
            ROLLOUT.update = true; 
            break;
          }
        }
      } else if (e.isShiftDown()) {

        addNewSelectionToPreviousSelection = -1;

        if (key == CODED) { 
          switch(keyCode) {
          case 112 : //F1
            ROLLOUT.child = 1; 
            ROLLOUT.update = true; 
            break;
          case 113 : //F2
            ROLLOUT.child = 2; 
            ROLLOUT.update = true; 
            break;
          case 114 : //F3
            ROLLOUT.child = 3; 
            ROLLOUT.update = true; 
            break;
          case 115 : //F4
            ROLLOUT.child = 4; 
            ROLLOUT.update = true; 
            break;
          case 116 : //F5
            ROLLOUT.child = 5; 
            ROLLOUT.update = true; 
            break;
          case 117 : //F6
            ROLLOUT.child = 6; 
            ROLLOUT.update = true; 
            break;
          case 118 : //F7
            ROLLOUT.child = 7; 
            ROLLOUT.update = true; 
            break;
          case 119 : //F8
            ROLLOUT.child = 8; 
            ROLLOUT.update = true; 
            break;
          }
        }
      }


      if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {
        if (key == CODED) { 
          switch(key) {
          }
        }
      }

      if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

        if (key != CODED) { 
          switch(key) {

            case TAB: 
              typeUserCommand = (typeUserCommand + 1) % 2;
              UI_BAR_c.update = true;
              break; 
          }

        }
      }      

      if ((STUDY.update) || (WORLD.update) || (WIN3D.update) || (ROLLOUT.update)) redraw();
    }
  }
}

void keyReleased () {   

  addNewSelectionToPreviousSelection = 0;
}


float EquationOfTime (float DateAngle) {
  float b = DateAngle;

  return 0.01  * (9.87 * funcs.sin_ang(2 * b) - 7.53 * funcs.cos_ang(b) - 1.5 * funcs.sin_ang(b));
}

float FLOAT_e = 2.7182818284;


float correctHourAngle (float DateAngle, float HourAngleOrigin) {
  return EquationOfTime(DateAngle) + HourAngleOrigin + 0.5; // here we also add 0.5 hour becaue hour 1 is passed by index 0.
}

float[] SOLARCHVISION_SunPositionRadiation (float DateAngle, float HourAngleOrigin, float CloudCover) {
  float HourAngle = correctHourAngle(DateAngle, HourAngleOrigin);

  float Declination = 23.45 * funcs.sin_ang(DateAngle - 180.0);

  float a = funcs.sin_ang(Declination);
  float b = funcs.cos_ang(Declination) * -funcs.cos_ang(15.0 * HourAngleOrigin);
  float c = funcs.cos_ang(Declination) *  funcs.sin_ang(15.0 * HourAngleOrigin);

  float x = c; 
  float y = -(a * funcs.cos_ang(STATION.getLatitude()) + b * funcs.sin_ang(STATION.getLatitude()));
  float z = -a * funcs.sin_ang(STATION.getLatitude()) + b * funcs.cos_ang(STATION.getLatitude());

  float Io = 1367.0; // W/m²
  Io = Io * (1.0 - (0.0334 * funcs.sin_ang(DateAngle)));

  float ALT_ = (funcs.asin_ang(z)) * PI / 180; 
  float ALT_true = ALT_ + 0.061359 * (0.1594 + 1.1230 * ALT_ + 0.065656 * ALT_ * ALT_) / (1 + 28.9344 * ALT_ + 277.3971 * ALT_ * ALT_);

  float PPo = pow(FLOAT_e, (-STATION.getElevation() / 8435.2));
  float Bb = ((funcs.sin_ang (ALT_true * 180 / PI)) + (0.50572 * pow((57.29578 * ALT_true + 6.07995), -1.6364)));
  float m = PPo / Bb;

  float StationTurbidity;

  StationTurbidity = (2.0 - 0.2) * (0.1 * CloudCover) + 0.2;

  float AtmosphereRatio;
  if (z < 0.01) AtmosphereRatio = 0.0; 
  else AtmosphereRatio = pow(FLOAT_e, (-m * StationTurbidity));

  float Idirect = Io * AtmosphereRatio; // Optical air mass: global Meteorological Database for Engineers, Planners and Education; Version 5.00 - Edition 2003

  float Idiffuse;
  if (z < 0.01) Idiffuse = 0.0;
  else Idiffuse = ((0.5 + 0.5 * (0.1 * CloudCover)) * z * (Io - Idirect)) / (1.0 - 1.4 * z * log(Idirect / Io));

  float[] return_array = {
    0, x, y, z, Idirect, Idiffuse
  }; 
  return return_array;
}

float[] SOLARCHVISION_SunPosition (float Latitude, float DateAngle, float HourAngleOrigin) {
  float HourAngle = correctHourAngle(DateAngle, HourAngleOrigin);

  float Declination = 23.45 * funcs.sin_ang(DateAngle - 180.0);

  float a = funcs.sin_ang(Declination);
  float b = funcs.cos_ang(Declination) * -funcs.cos_ang(15.0 * HourAngle);
  float c = funcs.cos_ang(Declination) *  funcs.sin_ang(15.0 * HourAngle);

  float x = c; 
  float y = -(a * funcs.cos_ang(Latitude) + b * funcs.sin_ang(Latitude));
  float z = -a * funcs.sin_ang(Latitude) + b * funcs.cos_ang(Latitude);

  float[] return_array = {
    0, x, y, z
  }; 
  return return_array;
}

float SOLARCHVISION_Sunrise (float Latitude, float DateAngle) {

  float a = 0;

  float Declination = 23.5 * funcs.sin_ang(DateAngle - 180.0);

  float q = -(funcs.tan_ang(Declination) * funcs.tan_ang(Latitude));
  if (q > 1.0) {
    a = 0.0;
  } else if (q < -1.0) {
    a = 24.0;
  } else a = funcs.acos_ang(q) / 15.0;

  return (a - EquationOfTime(DateAngle));
}

float SOLARCHVISION_Sunset (float Latitude, float DateAngle) {

  return 24.0 - SOLARCHVISION_Sunrise(Latitude, DateAngle) - EquationOfTime(DateAngle);
}

float SOLARCHVISION_DayTime (float Latitude, float DateAngle) {
  return abs((SOLARCHVISION_Sunset(Latitude, DateAngle)) - (SOLARCHVISION_Sunrise(Latitude, DateAngle)));
}

String Default_Font = "MS Sans Serif";

/*
"MS Sans Serif"
 "Microsoft Sans Serif"
 "Arial Narrow"
 "Arial"
 "Times New Roman"
 "Calibri"
 "Cambria"
 "Georgia"
 "Courier New"
 "Franklin Gothic Medium"
 "BankGothic Md BT"
 */

PFont SOLARCHVISION_font;

void SOLARCHVISION_loadDefaultFontStyle () {

  println("Loading font:", Default_Font);

  SOLARCHVISION_font = createFont(Default_Font, 36, true);

  SOLARCHVISION_ResetFontStyle();
}

void SOLARCHVISION_ResetFontStyle () {

  textFont(SOLARCHVISION_font);
  WORLD.graphics.textFont(SOLARCHVISION_font);
  WIN3D.graphics.textFont(SOLARCHVISION_font);
  STUDY.graphics.textFont(SOLARCHVISION_font);
}





























void SOLARCHVISION_export_objects_SCR () {
  
  String fileBasename = ProjectName;

  String scrFilename = Folder_Model3Ds + "/" + fileBasename + ".scr";  

  PrintWriter scrOutput = createWriter(scrFilename);

  scrOutput.println("-osnap off");

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if ((allFaces.nodes[f].length == 3) || (allFaces.nodes[f].length == 4)) {

      scrOutput.println("3dface");

      for (int j = 0; j < allFaces.nodes[f].length; j++) {

        float x = allPoints.getX(allFaces.nodes[f][j]);
        float y = allPoints.getY(allFaces.nodes[f][j]);
        float z = allPoints.getZ(allFaces.nodes[f][j]);

        scrOutput.println(nf(x, 0, User3D.export_PrecisionVertex) + "," + nf(y, 0, User3D.export_PrecisionVertex) + "," + nf(z, 0, User3D.export_PrecisionVertex));
      }
      scrOutput.println();
      scrOutput.println();
    }
  }
  
  for (int f = 0; f < allCurves.nodes.length; f++) {

    scrOutput.println("line");

    for (int j = 0; j < allCurves.nodes[f].length; j++) {

      float x = allPoints.getX(allCurves.nodes[f][j]);
      float y = allPoints.getY(allCurves.nodes[f][j]);
      float z = allPoints.getZ(allCurves.nodes[f][j]);

      scrOutput.println(nf(x, 0, User3D.export_PrecisionVertex) + "," + nf(y, 0, User3D.export_PrecisionVertex) + "," + nf(z, 0, User3D.export_PrecisionVertex));
    }
    
    if (allCurves.getMaterial(f) == 1) {
      scrOutput.println("c");
    }
    else {
      scrOutput.println();
    }
  }  

  scrOutput.println("zoom e");

  scrOutput.flush(); 
  scrOutput.close();   

  println("End of scripting lines and meshes."); 

  SOLARCHVISION_explore_output(scrFilename);
  println("File created:" + scrFilename);
}


PrintWriter radOutput;

void SOLARCHVISION_export_objects_RAD () {

  String fileBasename = ProjectName;

  String radFilename = Folder_Model3Ds + "/" + fileBasename + ".rad";  

  radOutput = createWriter(radFilename);

  radOutput.println("#SOLARCHVISION");
  radOutput.println();



  Land3D.draw(TypeWindow.RAD);

  allFaces.draw(TypeWindow.RAD);


  
  for (int i = 15; i < 180; i += 15) {
    radOutput.println("!gensky -ang " + nf(i, 0) + " 45 +s -trb 4.0");
  }   
  
  radOutput.flush(); 
  radOutput.close();   

  println("End of creating rad file."); 

  SOLARCHVISION_explore_output(radFilename);
  println("File created:" + radFilename);
  
  
  String batFilename = radFilename.replace(".rad", ".bat");
  PrintWriter batOutput = createWriter(batFilename);

  String Command1 = "oconv " + radFilename;
  String octFilename = radFilename.replace(".rad", ".oct");
  Command1 += " > " + octFilename;
  batOutput.println(Command1);
  
  String Command2 = "rvu";

  //Command2 += " -vtl"; //parallel
  Command2 += " -vtv"; //perspective
  //Command2 += " -vth"; //hemispherical
  //Command2 += " -vtc"; //cylindrical
  //Command2 += " -vta"; //angular
  //Command2 += " -vts"; //stereographic 
  
  Command2 += " -vv " + nf(WIN3D.Zoom, 0, 0);
  Command2 += " -vh " + nf(2 * funcs.atan_ang((WIN3D.dX / float(WIN3D.dY)) * funcs.tan_ang(0.5 * WIN3D.Zoom)), 0, 0);  

  Command2 += " -vp " + nf(WIN3D.CAM_x / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_y / OBJECTS_scale, 0, 0) + " " + nf(WIN3D.CAM_z / OBJECTS_scale, 0, 0);

  float dx = funcs.cos_ang(90 - WIN3D.rotation_X) * funcs.cos_ang(90 - WIN3D.rotation_Z);
  float dy = funcs.cos_ang(90 - WIN3D.rotation_X) * funcs.sin_ang(90 - WIN3D.rotation_Z);
  float dz = funcs.sin_ang(90 - WIN3D.rotation_X);
  
  Command2 += " -vd " + nf(-dx , 0, 0) + " " + nf(dy, 0, 0) + " " + nf(-dz, 0, 0);

  float ux = 0;
  float uy = 0;
  float uz = 1;
  if (abs(dz) > 0.99) {
    ux = funcs.cos_ang(90 + WIN3D.rotation_Z);
    uy = funcs.sin_ang(90 + WIN3D.rotation_Z);
    uz = 0; 
  }
  Command2 += " -vu " + nf(ux, 0, 0) + " " + nf(uy, 0, 0) + " " + nf(uz, 0, 0);



  

 
  
  Command2 += " -av 0.5 0.5 0.5";
  Command2 += " -pe 0.001";
  Command2 += " -ab 1";
  Command2 += " " + octFilename.replace('/', char(92));
  batOutput.println(Command2);
  
  batOutput.println("cmd /k"); // leave command prompt open

  batOutput.flush(); 
  batOutput.close();   


}



PrintWriter htmlOutput;

void SOLARCHVISION_export_objects_HTML () {

  String fileBasename = ProjectName;

  String htmlFilename = Folder_Model3Ds + "/" + fileBasename + ".html";  

  htmlOutput = createWriter(htmlFilename);

  htmlOutput.println("<html>");
  htmlOutput.println("\t<head>");
  htmlOutput.println("\t\t<title>" + ProjectName + "</title>");   
  htmlOutput.println("\t\t<script type='text/javascript' src='http://www.x3dom.org/download/x3dom.js'></script>");
  htmlOutput.println("\t\t<link rel='stylesheet' type='text/css' href='http://www.x3dom.org/download/x3dom.css'></link>");
  htmlOutput.println("\t</head>"); 
  htmlOutput.println("\t<body>"); 
  htmlOutput.println("\t\t<x3d width='900px' height='600px'>");  
  htmlOutput.println("\t\t\t<scene>"); 

  htmlOutput.println("\t\t\t\t<viewpoint position='0 0 100'></Viewpoint>");
/*
{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM00'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");

  float c1 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM01'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_X * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM02'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM03'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_X * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}


{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM04'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  
  
  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}

{
  htmlOutput.print  ("\t\t\t\t<viewpoint id='CAM05'");
  htmlOutput.print  (" position='" + nf(WIN3D.CAM_x, 0, 0) + " " + nf(WIN3D.CAM_y, 0, 0) + " " + nf(WIN3D.CAM_z, 0, 0) + "'");
  
  float c1 = funcs.cos_ang(WIN3D.rotation_Y * 0.5);
  float s1 = funcs.sin_ang(WIN3D.rotation_Y * 0.5);
  float c2 = funcs.cos_ang(WIN3D.rotation_X * 0.5);
  float s2 = funcs.sin_ang(WIN3D.rotation_X * 0.5);
  float c3 = funcs.cos_ang(WIN3D.rotation_Z * 0.5);
  float s3 = funcs.sin_ang(WIN3D.rotation_Z * 0.5);

  float qw = c1*c2*c3 + s1*s2*s3;
  float qx = s1*s2*c3 - c1*c2*s3;
  float qy = s1*c2*c3 + c1*s2*s3;
  float qz = c1*s2*c3 - s1*c2*s3;  

  htmlOutput.print  (" orientation='" + nf(qw, 0, 0) + " " + nf(qx, 0, 0) + " " + nf(qy, 0, 0) + " " + nf(qz, 0, 0) + "'");
  htmlOutput.println("></Viewpoint>");
}
*/


  Earth3D.draw(TypeWindow.HTML);

  Land3D.draw(TypeWindow.HTML);

  Tropo3D.draw(TypeWindow.HTML, STUDY.i_Start, STUDY.i_End);
  
  allSections.draw(TypeWindow.HTML);
  
  allModel2Ds.draw(TypeWindow.HTML);
  
  allFaces.draw(TypeWindow.HTML);

  
  
  
  
  htmlOutput.println("\t\t\t</scene>"); 
  htmlOutput.println("\t\t</x3d>"); 
  
/*  
  htmlOutput.println("\t\t<div id='camera_buttons' style='display: block;'>");
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM00').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM00<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM01').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM01<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM02').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM02<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM03').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM03<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM04').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM04<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t\t<button  onclick=\"document.getElementById('CAM05').setAttribute('set_bind','true');\" style='border: none; background: transparent; display: block'>CAM05<br><img src='camera.png'></button>");  
  htmlOutput.println("\t\t</div>");
*/

  htmlOutput.println("\t</body>"); 
  htmlOutput.println("</html>");
  
  htmlOutput.flush(); 
  htmlOutput.close();   

  println("End of creating html file."); 

  SOLARCHVISION_explore_output(htmlFilename);
  println("File created:" + htmlFilename);

}



void SOLARCHVISION_export_objects_OBJ_timeSeries () {

  int keep_STUDY_i_Start = STUDY.i_Start;
  
  for (int i = 0; i < 24; i++) {

    STUDY.i_Start = i;
    
    SOLARCHVISION_find_which_bakings_to_regenerate();
    SOLARCHVISION_regenerate_desired_bakings();
      
    
    SOLARCHVISION_export_objects_OBJ("_" + nf(i, 2));
  
  }
  
  STUDY.i_Start = keep_STUDY_i_Start;
}



void SOLARCHVISION_export_objects_OBJ_dateSeries () {

  int keep_IMPACTS_displayDay = IMPACTS_displayDay;
  
  for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {

    IMPACTS_displayDay = j;
    
    SOLARCHVISION_export_objects_OBJ("_" + nf(j, 3));
  
  }
  
  IMPACTS_displayDay = keep_IMPACTS_displayDay;
}




PrintWriter mtlOutput;
PrintWriter objOutput;


int obj_lastVertexNumber;
int obj_lastVtextureNumber;
int obj_lastFaceNumber;
int obj_lastGroupNumber;



int num_vertices_added = 0;

void SOLARCHVISION_export_objects_OBJ (String suffix) {

  String fileBasename = ProjectName + suffix;

  String objFilename = Folder_Model3Ds + "/" + fileBasename + ".obj";
  String mtlFilename = Folder_Model3Ds + "/" + fileBasename + ".mtl";


  if (User3D.export_MaterialLibrary) {
    mtlOutput = createWriter(mtlFilename);
    mtlOutput.println("#SOLARCHVISION");
  }

  objOutput = createWriter(objFilename);
  objOutput.println("#SOLARCHVISION");
  if (User3D.export_MaterialLibrary) {
    objOutput.println("mtllib " + fileBasename + ".mtl");
  }

  obj_lastVertexNumber = 0; 
  obj_lastVtextureNumber = 0; 
  obj_lastFaceNumber = 0;
  obj_lastGroupNumber = 0;






  Earth3D.draw(TypeWindow.OBJ);

  Land3D.draw(TypeWindow.OBJ);

  Tropo3D.draw(TypeWindow.OBJ, STUDY.i_Start, STUDY.i_End);  
  
  allSections.draw(TypeWindow.OBJ);
  
  allModel1Ds.draw(TypeWindow.OBJ);
  
  allModel2Ds.draw(TypeWindow.OBJ);
  
  allFaces.draw(TypeWindow.OBJ);

  allWindFlows.draw(TypeWindow.OBJ);

  Sky3D.draw(TypeWindow.OBJ);

  if (Sun3D.displayPattern) {

    float keep_STUDY_perDays = STUDY.perDays;
    int keep_STUDY_joinDays = STUDY.joinDays;
    if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
      STUDY.perDays = 1;
      STUDY.joinDays = 1;
    }    

    float previous_DATE = TIME.date;

    Sun3D.draw_Cycles(0, 0, 0, 0.975 * Sky3D.scale, 0.975 * Sky3D.scale, 0.975 * Sky3D.scale, STUDY.ImpactLayer, 4);

    STUDY.perDays = keep_STUDY_perDays;
    STUDY.joinDays = keep_STUDY_joinDays; 
    TIME.date = previous_DATE;
    TIME.updateDate();
  }

  if (User3D.export_MaterialLibrary) {
    mtlOutput.flush(); 
    mtlOutput.close();
  }

  objOutput.flush(); 
  objOutput.close();   


  println("End of exporting the mesh."); 

  SOLARCHVISION_explore_output(objFilename);
  println("File created:" + objFilename);
}

void SOLARCHVISION_OBJprintVertex (float x, float y, float z) {

  float a = x * User3D.export_Scale;
  float b = y * User3D.export_Scale;
  float c = z * User3D.export_Scale;

  if (User3D.export_FlipZYaxis == 0) {

    objOutput.println("v " + nf(a, 0, User3D.export_PrecisionVertex) + " " +  nf(b, 0, User3D.export_PrecisionVertex) + " " +  nf(c, 0, User3D.export_PrecisionVertex));
  } else {

    objOutput.println("v " + nf(-a, 0, User3D.export_PrecisionVertex) + " " +  nf(c, 0, User3D.export_PrecisionVertex) + " " +  nf(b, 0, User3D.export_PrecisionVertex));
  }
}



void SOLARCHVISION_OBJprintVtexture (float u, float v, float w) {

  objOutput.println("vt " + nf(u, 0, User3D.export_PrecisionVtexture) + " " + nf(v, 0, User3D.export_PrecisionVtexture) + " " + nf(w, 0, User3D.export_PrecisionVtexture));
}  


void SOLARCHVISION_HTMLprintVtexture (float u, float v) {

  htmlOutput.print(nf(u, 0, User3D.export_PrecisionVtexture) + " " + nf(v, 0, User3D.export_PrecisionVtexture));
}  


String importedObjectName = "";

void SOLARCHVISION_import_objects_OBJ (String FileName, int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz) {
  
  if (m == -1) current_Material = 0;
  else current_Material = m;

  int[] importVerticeNumber = {
    0
  };

  String[] FileALL = loadStrings(FileName);
  
  importedObjectName = OPESYS.getFilenameFromPath(FileName);
  
  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  float Progress = 0;

  for (int f = 0; f < FileALL.length; f++) {

    if (1 + Progress < 100 * f / float(FileALL.length)) { 
      Progress = 100 * f / float(FileALL.length);
      println("Progress:", int(Progress), "%");
    }

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("g")) {
      if (m == -1) current_Material = 1 + (current_Material % 8);

      if (addToLastGroup == false) allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      int[] v = {
        allModel3Ds.add_Vertex(x, y, z)
      };

      importVerticeNumber = concat(importVerticeNumber, v);
    }

    if (parts[0].toLowerCase().equals("f")) {

      //println(parts);

      int FaceDegree = parts.length - 1; // if we don't have space at the end of the line.

      if (parts[FaceDegree].equals("")) {  // if we have 1 space at the end of the line.
        FaceDegree -= 1;
      }

      int[] newFace = new int [FaceDegree]; 

      for (int n = 0; n < newFace.length; n++) {

        String[] the_numbers = split(parts[n + 1], '/');

        int vertexNumber = int(the_numbers[0]);

        if (vertexNumber > 0) {
          newFace[n] = importVerticeNumber[vertexNumber];
        } else if (vertexNumber < 0) { // for negative numbering
          newFace[n] = allPoints.getLength() - abs(vertexNumber);
        } else { // case 0
        }
      }

      //println(newFace);

      allModel3Ds.add_Face(newFace);
    }
  }

  println("Progress: 100 %");
}  






float SOLARCHVISION_import_objects_asParametricBox_OBJ (String FileName, int m, float cx, float cy, float cz, float sx, float sy, float sz) {

  float[][] importVertices = {
    {
    }
  };

  String[] FileALL = loadStrings(FileName);
  
  importedObjectName = OPESYS.getFilenameFromPath(FileName);

  String lineSTR;
  String[] input;

  //println("lines = ", FileALL.length);

  for (int f = 0; f < FileALL.length; f++) {

    lineSTR = FileALL[f];
    //println(lineSTR);

    lineSTR = lineSTR.replace("  ", " ");

    String[] parts = split(lineSTR, ' ');

    if (parts[0].toLowerCase().equals("v")) {

      float x = cx + sx * float(parts[1]);
      float y = cy + sy * float(parts[2]);
      float z = cz + sz * float(parts[3]);

      float[][] v = {
        {
          x, y, z
        }
      };

      importVertices = (float[][]) concat(importVertices, v);
    }
  }

  float min_X = FLOAT_undefined;
  float max_X = -FLOAT_undefined;
  float min_Y = FLOAT_undefined;
  float max_Y = -FLOAT_undefined;
  float min_Z = FLOAT_undefined;
  float max_Z = -FLOAT_undefined;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    if (min_X > x) min_X = x;
    if (max_X < x) max_X = x;
    if (min_Y > y) min_Y = y;
    if (max_Y < y) max_Y = y;
    if (min_Z > z) min_Z = z;
    if (max_Z < z) max_Z = z;
  }

  float cen_X = 0.5 * (min_X + max_X);
  float cen_Y = 0.5 * (min_Y + max_Y);
  float cen_Z = 0.5 * (min_Z + max_Z);

  float R_out = 0;
  float X_out = 0;
  float Y_out = 0;
  float Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = importVertices[vNo][0];
    float y = importVertices[vNo][1];
    float z = importVertices[vNo][2];

    float r = dist(cen_X, cen_Y, cen_Z, x, y, z);

    if (R_out < r) {
      R_out = r;

      X_out = x;
      Y_out = y;
      Z_out = z;
    }
  }  

  float T_out = funcs.atan2_ang(Y_out, X_out);

  X_out = 0;
  Y_out = 0;
  Z_out = 0;

  for (int vNo = 1; vNo < importVertices.length; vNo++) {
    float x = (importVertices[vNo][0] - cen_X) * funcs.cos_ang(-T_out) - (importVertices[vNo][1] - cen_Y) * funcs.sin_ang(-T_out);
    float y = (importVertices[vNo][0] - cen_X) * funcs.sin_ang(-T_out) + (importVertices[vNo][1] - cen_Y) * funcs.cos_ang(-T_out);
    float z = importVertices[vNo][2];

    if (X_out < abs(x)) X_out = abs(x);
    if (Y_out < abs(y)) Y_out = abs(y);
    if (Z_out < abs(z)) Z_out = abs(z);
  }  

  //allModel3Ds.add_Box_Core(m, cen_X,cen_Y,cen_Z, X_out,Y_out,Z_out, T_out);
  allModel3Ds.add_Solid(cen_X, cen_Y, cen_Z, CubePower, CubePower, CubePower, X_out, Y_out, Z_out, 0, 0, T_out, 1);

  return min_Z;
}  












void SOLARCHVISION_delete_All () {
  
  allModel1Ds.delete();
  allModel2Ds.delete();

  allModel3Ds.delete_Faces();
  allModel3Ds.delete_Curves();
  allModel3Ds.delete_Vertices();

  allModel3Ds.delete_allSolids();
  allModel3Ds.delete_allSections();
  allModel3Ds.delete_allCameras();

  allModel3Ds.delete_allGroups(); 

  WIN3D.update = true;
}


























  






float OBJECTS_scale = 1.0;  


int SKY2D_X_View = 50;
int SKY2D_Y_View = 50;
float SKY2D_ZOOM = 5;
PGraphics SKY2D_graphics;


void ViewFromTheSky (float SKY2D_position_X, float SKY2D_position_Y, float SKY2D_position_Z, float SKY2D_rotation_X, float SKY2D_rotation_Y, float SKY2D_rotation_Z) {

  SKY2D_graphics.beginDraw();

  SKY2D_graphics.background(233);

  SKY2D_graphics.ortho(SKY2D_X_View / -SKY2D_ZOOM, SKY2D_X_View / SKY2D_ZOOM, SKY2D_Y_View / -SKY2D_ZOOM, SKY2D_Y_View / SKY2D_ZOOM, 0.00001, 100000);

  SKY2D_graphics.translate(0, 1.0 * SKY2D_Y_View, 0); // << IMPORTANT! 

  SKY2D_graphics.translate(SKY2D_position_X, SKY2D_position_Y, SKY2D_position_Z);
  SKY2D_graphics.rotateX(SKY2D_rotation_X * PI / 180); 
  SKY2D_graphics.rotateY(SKY2D_rotation_Y * PI / 180);
  SKY2D_graphics.rotateZ(SKY2D_rotation_Z * PI / 180); 

  SKY2D_graphics.hint(ENABLE_DEPTH_TEST);
  
  Land3D.draw(TypeWindow.SKY2D);

  for (int f = 0; f < allFaces.nodes.length; f++) {

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      color c = color(0, 0, 0);

      int mt = allFaces.getMaterial(f);
      c = color(Materials_Color[mt][1], Materials_Color[mt][2], Materials_Color[mt][3], Materials_Color[mt][0]);

      SKY2D_graphics.stroke(c);
      SKY2D_graphics.fill(c);

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allFaces.displayTessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);

        SKY2D_graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {

          SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
        }

        SKY2D_graphics.endShape(CLOSE);
      }
    }
  }
  
  SKY2D_graphics.endDraw();
}






















int getLoactationTimeZone () {
  return int(funcs.roundTo(STATION.getLongitude() / 15, 15)); 
}


int[] getNow_inUTC () {
  
  int LoactationTimeZone = getLoactationTimeZone();
  
  int CurrentYear = year();
  int CurrentMonth = month();
  int CurrentDay = day();
  int CurrentHour = hour();

   
  // converting from local time to global time 
  
  if (LoactationTimeZone > 0) {
    CurrentHour -= LoactationTimeZone;
    
    if (CurrentHour < 0) {
      CurrentHour += 24;
      CurrentDay -= 1;

      if (CurrentDay < 1) { 
        
        CurrentMonth -= 1;
        
        if (CurrentMonth < 1) {
          CurrentMonth = 12;
          CurrentYear -= 1;
        }
        
        CurrentDay = TIME.lengthOfMonths[CurrentMonth - 1];
      }
    }
  }
  else if (LoactationTimeZone < 0) {
    CurrentHour += abs(LoactationTimeZone);
    
    if (CurrentHour > 23) {
      CurrentHour -= 24;
      CurrentDay += 1;

      if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) { 
        CurrentDay = 1;
        CurrentMonth += 1;
        
        if (CurrentMonth > 12) {
          CurrentMonth = 1;
          CurrentYear += 1;
        }
      }
    }
  }  

  int[] return_array = {CurrentYear, CurrentMonth, CurrentDay, CurrentHour};
  
  return return_array;
}





class solarchvision_Tropo3D {
  
  private final static String CLASS_STAMP = "Tropo3D";

  
  boolean displaySurface = false;
  boolean displayTexture = true;  
  
  String[] Filenames;
  PImage[] Map;
  
  float[][] BoundariesX;
  float[][] BoundariesY;
  
  
  void resize_images () {
    
    this.Filenames = new String [TROPO_timeSteps];
    this.Map = new PImage [TROPO_timeSteps];
    
    this.BoundariesX = new float[TROPO_timeSteps][2];
    this.BoundariesY = new float[TROPO_timeSteps][2];
    
    for (int i = 0; i < TROPO_timeSteps; i++) {
  
      this.Filenames[i] = "";
      this.Map[i] = createImage(2, 2, RGB); // empty and small
      
      this.BoundariesX[i][0] = 0;
      this.BoundariesX[i][1] = 0;
      this.BoundariesY[i][0] = 0;
      this.BoundariesY[i][1] = 0;
      
    }
  }
  
  
  void load_images () {
    
    String[] allFilenames = sort(OPESYS.getFiles(Folder_GEOMET));
    
  
    
    int LoactationTimeZone = getLoactationTimeZone();
    
    int[] rightNow = getNow_inUTC();
    
    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];
   
    for (int i = 0; i < TROPO_timeSteps; i++) {
      
      CurrentHour += 1;
      
      if (CurrentHour > 23) {
        CurrentHour -= 24;
        CurrentDay += 1;
  
        if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) { 
          CurrentDay = 1;
          CurrentMonth += 1;
          
          if (CurrentMonth > 12) {
            CurrentMonth = 1;
            CurrentYear += 1;
          }
        }
      }
      
      
      
      for (int q = 0; q < allFilenames.length; q++) {
        
        String[] Parts = split(allFilenames[q], '_');
        
        //if (Parts[0].equals(nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2))) {
        if (Parts[0].equals(nf((CurrentHour + LoactationTimeZone) % 24, 2))) {
          
          this.Filenames[i] = allFilenames[q];
          
          this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
          this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
          this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
          this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;
          
          println("Loading:", Folder_GEOMET + "/" + this.Filenames[i]);
  
          this.Map[i] = loadImage(Folder_GEOMET + "/" + this.Filenames[i]);
  
          break;        
        }
      }
  
    }
    
    WIN3D.update = true;
  }
  
  
  void download_images () {
  
    int LoactationTimeZone = getLoactationTimeZone();
    
    int[] rightNow = getNow_inUTC();
    
    int CurrentYear = rightNow[0];
    int CurrentMonth = rightNow[1];
    int CurrentDay = rightNow[2];
    int CurrentHour = rightNow[3];
   
    for (int i = 0; i < TROPO_timeSteps; i++) {
      
      if (WMS_type == DataType.SATELLITE_GOES) {
        
        CurrentHour -= 1;
        
        if (CurrentHour < 0) {
          CurrentHour += 24;
          CurrentDay -= 1;
    
          if (CurrentDay < 0) { 
            
            CurrentMonth -= 1;
  
            if (CurrentMonth < 0) {
              CurrentMonth = 12;
              CurrentYear -= 1;
            }
            
            CurrentDay = TIME.lengthOfMonths[CurrentMonth - 1];
          }
        }
            
      }
      else {
      
        CurrentHour += 1;
        
        if (CurrentHour > 23) {
          CurrentHour -= 24;
          CurrentDay += 1;
    
          if (CurrentDay > TIME.lengthOfMonths[CurrentMonth - 1]) { 
            CurrentDay = 1;
            CurrentMonth += 1;
            
            if (CurrentMonth > 12) {
              CurrentMonth = 1;
              CurrentYear += 1;
            }
          }
        }
      
      }
      String the_service = "";
      
      if (WMS_type == DataType.SATELLITE_GOES) {
        the_service = "http://mesonet.agron.iastate.edu/cgi-bin/wms/goes/east_vis.cgi";
      }
      else {
        the_service = "http://geo.weather.gc.ca/geomet/";
      } 
  
  
      String the_link = the_service + "?SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&FORMAT=image%2Fpng&TRANSPARENT=true";
      
      
      String ParameterStamp = ""; 
  
      if (WMS_type == DataType.SATELLITE_GOES) {
        ParameterStamp = ""; 
      }
      else {
        ParameterStamp = "_NT&STYLES=CLOUD"; // Cloud cover
        //ParameterStamp = "_GZ&STYLES=DEFAULT"; // Geopotential height (Value range mapping)
        //ParameterStamp = "_UU&STYLES=WINDSPEED"; // Windspeed in knots
        //ParameterStamp = "_UU&STYLES=WINDSPEEDKMH"; // Windspeed in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROWKMH"; // Wind arrows in km/h
        //ParameterStamp = "_UU&STYLES=WINDARROW"; // Wind arrows in knots
        //ParameterStamp = "_TT&STYLES=TEMPERATURE"; // Air temperature
        //ParameterStamp = "_TT&STYLES=TEMPSUMMER"; // Air temperaturesummer range
        //ParameterStamp = "_TT&STYLES=TEMPWINTER"; // Air temperaturewinter range
        //ParameterStamp = "_ES&STYLES=DEWPOINTDEP"; // Dew point depression
        //ParameterStamp = "_P0&STYLES=PRESSURE"; // Surface pressure
        //ParameterStamp = "_PN&STYLES=PRESSURE4_LINE"; // Sea level pressure contour 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURE4"; // Sea level pressure 4mb
        //ParameterStamp = "_PN&STYLES=PRESSURESEAHIGH"; // Sea level pressure high range
        //ParameterStamp = "_PN&STYLES=PRESSURESEALOW"; // Sea level pressure low range
        //ParameterStamp = "_PR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_PR&STYLES=CAPA24"; // Precipitations in millimeters (CaPA24)
        //ParameterStamp = "_RT&STYLES=PRECIPRTMMH"; // Rate of precipitations in millimeters per hour
        //ParameterStamp = "_RN&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_FR&STYLES=PRECIPMM"; // Precipitations in millimeters
        //ParameterStamp = "_SN&STYLES=PRECIPSNOW"; // Precipitations in centimeters
        //ParameterStamp = "_I0&STYLES=TEMPSOIL"; // Soil Temperature
        //ParameterStamp = "_I1&STYLES=WATERCONTENT"; // Water content
        //ParameterStamp = "_I2&STYLES=ICECONTENT"; // Soil volumetric ice content
        //ParameterStamp = "_I3&STYLES=WATERRETAINED"; // Water retained on the vegetation 
        //ParameterStamp = "_I4&STYLES=WATERRETAINED"; // Water retained in the snow pack
        //ParameterStamp = "_I5&STYLES=SNOWMASS"; // Snow mass
        //ParameterStamp = "_I8&STYLES=ICETHICK"; // Sea ice thickness
        
        //ParameterStamp = "_WGE&STYLES=MS2KTSGUST"; // Windgust estimate intervals in knots
        //ParameterStamp = "_WGE&STYLES=MS2KTS"; // Windspeed estimate in knots
        //ParameterStamp = "_WGE&STYLES=MS2KMH"; // Windspeed estimate in km/h
        
        //ParameterStamp = "_WGN&STYLES=MS2KTSGUST"; // Windgust minimum intervals in knots
        //ParameterStamp = "_WGN&STYLES=MS2KTS"; // Windspeed minimum in knots
        //ParameterStamp = "_WGN&STYLES=MS2KMH"; // Windspeed minimum in km/h
        
        //ParameterStamp = "_WGX&STYLES=MS2KTSGUST"; // Windgust maximum intervals in knots
        //ParameterStamp = "_WGX&STYLES=MS2KTS"; // Windspeed maximum in knots
        //ParameterStamp = "_WGX&STYLES=MS2KMH"; // Windspeed maximum in km/h
      }
      
     
      
      String DomainStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        DomainStamp = "east_vis_1km";
      }
      else if (WMS_type == DataType.FORECAST_HRDPS) {
        DomainStamp = "HRDPS.CONTINENTAL";
      }
      else if (WMS_type == DataType.FORECAST_RDPS) {
        DomainStamp = "RDPS.ETA";
      } 
      else if (WMS_type == DataType.FORECAST_GDPS) {
        DomainStamp = "GDPS.ETA";
      }
      
      this.BoundariesX[i][0] = STATION.getLongitude() - 15;
      this.BoundariesX[i][1] = STATION.getLongitude() + 15;
      this.BoundariesY[i][0] = STATION.getLatitude() - 15 * funcs.cos_ang(STATION.getLatitude());
      this.BoundariesY[i][1] = STATION.getLatitude() + 15 * funcs.cos_ang(STATION.getLatitude());
  
      
      
      int RES1 = 1200; // 1800;
      int RES2 = 600; // 900;
   
  
      the_link += "&LAYERS=" + DomainStamp + ParameterStamp + "&WIDTH=" + nf(RES1, 0) + "&HEIGHT=" + nf(RES2, 0);
      the_link += "&SRS=EPSG%3A4326&BBOX=";
      the_link += nf(this.BoundariesX[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][0], 0, 3) + ",";
      the_link += nf(this.BoundariesX[i][1], 0, 3) + ",";
      the_link += nf(this.BoundariesY[i][1], 0, 3);
      
      int the_hour = i * TROPO_deltaTime; 
  
      String timeStamp = "";
      if (WMS_type == DataType.SATELLITE_GOES) {
        timeStamp = "&date=" + nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "&time=" + nf(CurrentHour, 2) + ":00";
      }
      else {
        timeStamp = nf(CurrentYear, 4) + "-" + nf(CurrentMonth, 2) + "-" + nf(CurrentDay, 2) + "T" + nf(CurrentHour, 2);
      }
      
      //the_link += "%26time%3D" + timeStamp +"%3A22%3A00Z";
      the_link += "%26time%3D" + timeStamp +"%3A00Z";
      
      this.Map[i] = createImage(2, 2, RGB); // empty and small
      
      //String FN = nf(CurrentYear, 4) + nf(CurrentMonth, 2) + nf(CurrentDay, 2) + nf(CurrentHour, 2) + "_";
      String FN = nf((CurrentHour + LoactationTimeZone) % 24, 2) + "_";
      FN += nf(int(funcs.roundTo(-1000 * this.BoundariesX[i][0], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo( 1000 * this.BoundariesY[i][0], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo(-1000 * this.BoundariesX[i][1], 1)), 6) + "_";
      FN += nf(int(funcs.roundTo( 1000 * this.BoundariesY[i][1], 1)), 6) + "_";
      FN += ".png";
  
      String the_target = Folder_GEOMET + "/" + FN;
  
      File dir = new File(the_target);
      if (!dir.isFile()) {
        
        boolean new_file_downloaded = false;
  
        println("Try downloading: " + the_link);
  
        try {
          saveBytes(the_target, loadBytes(the_link));
          
          new_file_downloaded = true;
        }
        
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
       
        if (new_file_downloaded) {
          
          if (ParameterStamp.equals("_NT&STYLES=CLOUD")) {
            println("image processing cloud layer");
            
            PImage img = loadImage(the_target);
            img.loadPixels();        
                
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
            
              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              
              float COL_A = (COL >> 24 & 0xFF);
              
              if (COL_A == 0) {
                img.pixels[np] = color(0,0);
              }
              else {
                float COL_V = (COL >> 16 & 0xFF);
                img.pixels[np] = color(255 - 0.125 * COL_V, COL_V);
              }        
            }
            img.updatePixels();
            img.save(the_target);
          }
  
  
  
  
          if (WMS_type == DataType.SATELLITE_GOES) {
            println("image processing cloud layer");
  
            PImage img = loadImage(the_target);
            
            img.loadPixels();        
                
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
            
              color COL = img.get(Image_X, Image_Y);
              //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
              
              float COL_V = (COL >> 16 & 0xFF);
              
              float N = 3; //3.5; //4; 
              
              if (COL_V < 255 / N) {
                img.pixels[np] = color(191,191,255,255); //color(0,0);
              }
              else {
                img.pixels[np] = color((255 - COL_V) * N / (N - 1), 255);
              }
            }
            img.updatePixels();
            img.save(the_target);
          }
          
        }      
  
      }
    }
  
    Tropo3D.load_images();
  }  
    
  
  
  
  
  
  void draw (int target_window, int start_hour, int end_hour) {
    
    ///////////////////////////////// for now we only use the first image
    end_hour = start_hour;
    /////////////////////////////////
  
  
    boolean proceed = true;
  
    if ((displaySurface == false) || (displayTexture == false)) {
      proceed = false;
    }
  
    if (target_window == TypeWindow.STUDY) {  
      proceed = false;
    }
  
    if (proceed) {    
  
      for (int n_Map = start_hour; n_Map <= end_hour; n_Map++) {
          
        if (this.Filenames[n_Map].equals("")) { // not to display empty images 
          } else {
          
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
            
            if (User3D.export_MaterialLibrary) {
      
              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='TropoSphere" + nf(n_Map, 0) + "'>");
              }            
              
              if (target_window == TypeWindow.OBJ) {
              
                mtlOutput.println("newmtl TropoSphere" + nf(n_Map, 0));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
        
                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
              }
  
              if (Tropo3D.displayTexture) {
      
                String old_Texture_path = Folder_GEOMET + "/" + this.Filenames[n_Map];
      
                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
      
                String new_Texture_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
      
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
      
                if (target_window == TypeWindow.OBJ) {
      
                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
                }
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                }                    
                    
              }
            }
  
            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t</Appearance>");
            } 
          
            if (target_window == TypeWindow.OBJ) {
          
              if (User3D.export_PolyToPoly == 1) {
                obj_lastGroupNumber += 1;  
                objOutput.println("g TropoSphere" + nf(n_Map, 0));
              }
        
              if (User3D.export_MaterialLibrary) {
                objOutput.println("usemtl TropoSphere" + nf(n_Map, 0));
              }     
            }
       
          }     
            
    
          float OffsetX = this.BoundariesX[n_Map][0] + 180;
          float OffsetY = this.BoundariesY[n_Map][1] - 90;
    
          float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
          float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;
    
          float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
          float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);
    
          float delta_Alpha = -BIOSPHERE_drawResolution;
          float delta_Beta = -BIOSPHERE_drawResolution;
    
          float r = FLOAT_r_Earth + 10000;
          
          
          num_vertices_added = 0;
          
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
  
            int f = 0;
            for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
              for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
                f += 1;
      
                float[][] subFace = new float [4][7];
      
                for (int s = 0; s < 4; s++) {
      
                  float a = Alpha;
                  float b = Beta;
      
                  if ((s == 2) || (s == 3)) {
                    a += delta_Alpha;
                  }
      
                  if ((s == 1) || (s == 2)) {
                    b += delta_Beta;
                  }
      
                  float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a); 
                  float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
                  float z0 = r * funcs.sin_ang(a);
      
                  float _lon = b - CEN_lon;
                  float _lat = a - CEN_lat;
      
                  if (Tropo3D.displayTexture) {
                    // calculating u and v
                    subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
                    subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
                  }         
      
                  // rotating to location coordinates 
                  float tb = -STATION.getLongitude();
                  float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
                  float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
                  float z1 = z0;
      
                  float ta = 90 - STATION.getLatitude();
                  float x2 = x1;
                  float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
                  float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);
      
                  // move it down!
                  z2 -= FLOAT_r_Earth;
      
                  subFace[s][0] = x2;
                  subFace[s][1] = y2;
                  subFace[s][2] = z2;
                  
                  subFace[s][5] = a;
                  subFace[s][6] = b;
                }
                
                boolean UVs_OK = true;
                
                for (int s = 0; s < subFace.length; s++) {
                  if (subFace[s][3] < 0) UVs_OK = false;
                  if (subFace[s][3] > 1) UVs_OK = false;
                  if (subFace[s][4] < 0) UVs_OK = false;
                  if (subFace[s][4] > 1) UVs_OK = false;
                }
                
                if (UVs_OK) {
                
                  if (target_window == TypeWindow.WORLD) {
                    WORLD.graphics.beginShape();
                    WORLD.graphics.noStroke();
                    if (Tropo3D.displayTexture) {
                      WORLD.graphics.texture(this.Map[n_Map]);
                    }
          
                    for (int s = 0; s < subFace.length; s++) {
                      
                      float _lat = subFace[s][5];
                      float _lon = subFace[s][6];
                      if (_lon > 180) _lon -= 360; // << important!
              
                      float x_point = WORLD.dX * (( 1 * (_lon - WORLD.oX) / 360.0) + 0.5) / WORLD.sX;
                      float y_point = WORLD.dY * ((-1 * (_lat - WORLD.oY) / 180.0) + 0.5) / WORLD.sY; 
    
                      WORLD.graphics.vertex(x_point, y_point, subFace[s][3] * this.Map[n_Map].width, subFace[s][4] * this.Map[n_Map].height);
                    }
          
                    WORLD.graphics.endShape(CLOSE);
                    
                  }
  
  
                  if (target_window == TypeWindow.HTML) {
        
                    htmlOutput.println("\t\t\t\t<shape>");
        
                    if (n_Map != -1) {   
                      htmlOutput.println("\t\t\t\t\t<Appearance USE='TropoSphere" + nf(n_Map, 0) + "'></Appearance>");
                    }      
                    
                    htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
                    
                    htmlOutput.print  (" coordIndex='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(" ");
                      }         
                      htmlOutput.print(nf(s, 0));          
                    }
                    htmlOutput.println(" -1'>");
                    
                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    for (int s = 0; s < subFace.length; s++) {
                      if (s > 0) {
                        htmlOutput.print(",");
                      }                  
                      
                      htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                    }                
                    htmlOutput.println("'></Coordinate>");
                    
                  }
                
                  if (target_window == TypeWindow.WIN3D) {
                    
                    WIN3D.graphics.strokeWeight(1);
                    
                    WIN3D.graphics.beginShape();
                    WIN3D.graphics.noStroke();
                    if (Tropo3D.displayTexture) {
                      WIN3D.graphics.texture(this.Map[n_Map]);
                    }
                  }    
                 
                  
                  for (int s = 0; s < subFace.length; s++) {
                    
                    float x = subFace[s][0];
                    float y = subFace[s][1];
                    float z = subFace[s][2];
                    float u = subFace[s][3];
                    float v = subFace[s][4];
  
                    if (u > 1) u = 1;
                    if (u < 0) u = 0;
                    if (v > 1) v = 1;
                    if (v < 0) v = 0;                     
  
  
                  
                    if (target_window == TypeWindow.WIN3D) {
  
                      WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * this.Map[n_Map].width, v * this.Map[n_Map].height);
                    }                    
                  
                    if (target_window == TypeWindow.OBJ) {
        
                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(x, y, z);
                      }
        
                      if (_turn == 2) {
  
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
        
                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }
        
                      if (_turn == 3) {
                        obj_lastVertexNumber += 1;
                        obj_lastVtextureNumber += 1;
                      }
                    }
                    
                    if (target_window == TypeWindow.HTML) {
                      
                      if (n_Map != -1) {   
                      
                        if (s == 0) {
                          htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                        }
                        if (s > 0) {
                          htmlOutput.print(",");
                        }                  
        
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                        SOLARCHVISION_HTMLprintVtexture(u, v);
                        
                        if (s == subFace.length - 1) {
                          htmlOutput.println("'></TextureCoordinate>");
                        }       
                      }              
         
                    }                  
                    
                  }
                  
                  
                  if (target_window == TypeWindow.HTML) {
        
                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                    
                    htmlOutput.println("\t\t\t\t</shape>");
        
                  }                 
                  
                  if (target_window == TypeWindow.WIN3D) {
  
                    WIN3D.graphics.endShape(CLOSE);
                  }    
   
                  if (target_window == TypeWindow.OBJ) {
      
                    String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
                    String n2_txt = nf(obj_lastVertexNumber - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber - 0, 0);
        
                    String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
        
                    if (User3D.export_PolyToPoly == 0) {
                      if (_turn == 3) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g TropoSphere" + nf(n_Map, 0) + "_" + nf(f, 0));
                      }
                    } 
        
                    if (_turn == 3) {
                      obj_lastFaceNumber += 1;            
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (User3D.export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }
                  }               
                }
                
              }
            }
          }
        }
      }
    }
  }
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setString("displaySurface", Boolean.toString(this.displaySurface));
    parent.setString("displayTexture", Boolean.toString(this.displayTexture));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
    this.displayTexture = Boolean.parseBoolean(parent.getString("displayTexture"));
  }   
}

solarchvision_Tropo3D Tropo3D = new solarchvision_Tropo3D();



class solarchvision_Sky3D {
  
  private final static String CLASS_STAMP = "Sky3D";
  
  boolean displaySurface = false;
  int displayTessellation = 3; //3;
  float scale = 1000000; //25000; //10000; //10km:Troposphere 25km:Ozone layer 100km:Karman line.


  int ACTIVE_pallet_CLR = 18; //-1; //7; //8;
  int ACTIVE_pallet_DIR = 1; //-1;
  float ACTIVE_pallet_MLT = 0.5; //1; //0.25;
  
  int PASSIVE_pallet_CLR = 18; 
  int PASSIVE_pallet_DIR = -1;  
  float PASSIVE_pallet_MLT = 1; //2;

  float stp_slp;
  float stp_dir;
  int num_slp;  
  int num_dir;

  float calculatedResolution = 2.5; //1, 2.5, 5
  

  void draw (int target_window) {
  
    boolean proceed = true;
  
    if (this.displaySurface == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }

    
    if (proceed) {  

      int PAL_type = 0; 
      int PAL_direction = 1;
      float PAL_multiplier = 1; 

      if (Impact_TYPE == Impact_ACTIVE) {
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;  
        PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;  
        PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT;
      }        
    
      if (target_window == TypeWindow.OBJ) {
    
        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
    
          String the_filename = "";
          String TEXTURE_path = "";  
    
          if (User3D.export_MaterialLibrary) {
    
            the_filename = "skyPatternPallet.bmp";
    
            TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
    
            println("Saving texture:", TEXTURE_path);
    
            int RES1 = User3D.export_PalletResolution; 
            int RES2 = User3D.export_PalletResolution / 16;      
    
            PImage pallet_Texture = createImage(RES1, RES2, ARGB);       
    
    
            pallet_Texture.loadPixels();
    
            for (int np = 0; np < (RES1 * RES2); np++) {
              int Image_X = np % RES1;
              int Image_Y = np / RES1;
    
              float _val = (Image_X / (0.5 * RES1)) - 1; 
    
              float _u = 0.5 + _val;
    
              if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
    
              float[] COL = PAINT.getColorStyle(PAL_type, _u);  
    
              pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
            }
    
            pallet_Texture.updatePixels();   
    
            pallet_Texture.save(TEXTURE_path);      
    
    
            mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
            //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
            mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
          }      
    
          obj_lastGroupNumber += 1;
          objOutput.println("g skyPattern");
    
          if (User3D.export_MaterialLibrary) {      
            objOutput.println("usemtl " +  the_filename.replace('.', '_'));
          }      
    
          num_vertices_added = 0;
    
          for (int _turn = 1; _turn < 4; _turn++) {
    
            for (int f = 0; f < skyFaces.length; f++) {
    
              int Tessellation = 0;
    
              int TotalSubNo = 1;  
              Tessellation = Sky3D.displayTessellation;
              if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
    
              float[][] base_Vertices = new float [skyFaces[f].length][3];
              for (int j = 0; j < skyFaces[f].length; j++) {
                int vNo = skyFaces[f][j];
                base_Vertices[j][0] = skyVertices[vNo][0];
                base_Vertices[j][1] = skyVertices[vNo][1];
                base_Vertices[j][2] = skyVertices[vNo][2];
              }
    
              for (int n = 0; n < TotalSubNo; n++) {
    
                float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
    
                for (int j = 0; j < subFace.length; j++) {
                  subFace[j] = funcs.vec3_unit(subFace[j]);
                }
    
    
    
                for (int s = 0; s < subFace.length; s++) {
    
                  int s_next = (s + 1) % subFace.length;
                  int s_prev = (s + subFace.length - 1) % subFace.length;
    
                  float x = subFace[s][0] * Sky3D.scale * WIN3D.scale;
                  float y = subFace[s][1] * Sky3D.scale * WIN3D.scale;
                  float z = subFace[s][2] * Sky3D.scale * WIN3D.scale;
    
                  float _u = SHADE.vertexU_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
    
    
                  if (_turn == 1) {
    
                    SOLARCHVISION_OBJprintVertex(x, y, z);
                  }
    
                  if (_turn == 2) { 
                    float u1 = 0.5 * (_u + 0.5);
    
                    if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) { 
                      if  (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                    }
    
                    if (u1 > 0.999) u1 = 0.999;
                    if (u1 < 0.001) u1 = 0.001;
    
                    SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
                  }
    
                  if (_turn == 3) {
                    num_vertices_added += 1;
                  }
                }
    
                if (_turn == 3) {
                  String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                  String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                  String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                  String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
    
                  String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                  String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                  String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                  String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
    
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);  
                  if (User3D.export_BackSides) {
                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                  }
                }
              }
            }
          }
    
          obj_lastVertexNumber += num_vertices_added;
          obj_lastVtextureNumber += num_vertices_added;
        }
      }
    
      if (target_window == TypeWindow.WIN3D) {
    
        if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
  
          for (int f = 0; f < skyFaces.length; f++) {      
      
            int Tessellation = 0;
      
            int TotalSubNo = 1;  
            Tessellation = this.displayTessellation;
            if (Tessellation > 0) TotalSubNo = skyFaces[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
      
            float[][] base_Vertices = new float [skyFaces[f].length][3];
            for (int j = 0; j < skyFaces[f].length; j++) {
              int vNo = skyFaces[f][j];
              base_Vertices[j][0] = skyVertices[vNo][0];
              base_Vertices[j][1] = skyVertices[vNo][1];
              base_Vertices[j][2] = skyVertices[vNo][2];
            }
      
            for (int n = 0; n < TotalSubNo; n++) {
      
              float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
      
              for (int j = 0; j < subFace.length; j++) {
                subFace[j] = funcs.vec3_unit(subFace[j]);
              }
      
              WIN3D.graphics.beginShape();
      
              for (int s = 0; s < subFace.length; s++) {
      
                int s_next = (s + 1) % subFace.length;
                int s_prev = (s + subFace.length - 1) % subFace.length;
      
                float[] COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
      
                WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
      
                WIN3D.graphics.vertex(subFace[s][0] * this.scale * WIN3D.scale, -(subFace[s][1] * this.scale * WIN3D.scale), subFace[s][2] * this.scale * WIN3D.scale);
              }
      
              WIN3D.graphics.endShape(CLOSE);
            }
          }
        } else {
    
          color c = color(191, 191, 255);
    
          WIN3D.graphics.noStroke();
    
          if (WIN3D.FacesShade == SHADE.Surface_Materials) {
            WIN3D.graphics.fill(c);
            //WIN3D.graphics.noFill();
          } else {
            WIN3D.graphics.fill(c);
          }    
          
          for (int f = 0; f < skyFaces.length; f++) {
    
            WIN3D.graphics.beginShape();
      
            for (int j = 0; j < skyFaces[f].length; j++) {
              int vNo = skyFaces[f][j];
              WIN3D.graphics.vertex(skyVertices[vNo][0] * this.scale * WIN3D.scale, -(skyVertices[vNo][1] * this.scale * WIN3D.scale), skyVertices[vNo][2] * this.scale * WIN3D.scale);
            }    
      
            WIN3D.graphics.endShape(CLOSE);
          }
        }
    
      }
    }
  }
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setString("displaySurface", Boolean.toString(this.displaySurface));
    parent.setInt("displayTessellation", this.displayTessellation);
    parent.setFloat("scale", this.scale);
    parent.setInt("ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    parent.setInt("ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    parent.setFloat("ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    parent.setInt("PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    parent.setInt("PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    parent.setFloat("PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);
    
    parent.setFloat("stp_slp", this.stp_slp);
    parent.setFloat("stp_dir", this.stp_dir);
    parent.setInt("num_slp", this.num_slp);
    parent.setInt("num_dir", this.num_dir);
    
    parent.setFloat("calculatedResolution", this.calculatedResolution);
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
    this.displayTessellation = parent.getInt("displayTessellation");
    this.scale = parent.getFloat("scale");
    this.ACTIVE_pallet_CLR = parent.getInt("ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = parent.getInt("ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = parent.getFloat("ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = parent.getInt("PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = parent.getInt("PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = parent.getFloat("PASSIVE_pallet_MLT");
    
    this.stp_slp = parent.getFloat("stp_slp");
    this.stp_dir = parent.getFloat("stp_dir");
    this.num_slp = parent.getInt("num_slp");
    this.num_dir = parent.getInt("num_dir");   
    
    this.calculatedResolution = parent.getFloat("calculatedResolution");
  }   
}

solarchvision_Sky3D Sky3D = new solarchvision_Sky3D();



class solarchvision_Sun3D {
  
  private final static String CLASS_STAMP = "Sun3D";
  
  int ACTIVE_pallet_CLR = 15;
  int ACTIVE_pallet_DIR = 1;
  float ACTIVE_pallet_MLT = 1;
  
  int PASSIVE_pallet_CLR = 18; 
  int PASSIVE_pallet_DIR = -1;  
  float PASSIVE_pallet_MLT = 8; //1;
  
  boolean displayGrid = true;
  boolean displayPath = true;
  boolean displayPattern = false;
  
  boolean displaySurface = false;
  boolean displayTexture = true;
 
  String Filename = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Sun/Sun.jpg";
  
  PImage Map;
  
  void load_images () {
    Map = loadImage(Filename);
  }
  
  void draw () {
    if (this.displaySurface) {
  
      WIN3D.graphics.strokeWeight(1);

      float OffsetX = 0; 
      float OffsetY = 0; 
    
      float ScaleX = 1; 
      float ScaleY = 1;   

      float CEN_lon = 0; 
      float CEN_lat = 0; 
  
      float delta_Alpha = -5;
      float delta_Beta = -10;
  
      float r = 696.0 * Planetary_Magnification; // * 1000000; // multiply this later
      float d = 150000.0; // * 1000000; // multiply this later 
  
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s++) {
  
            float a = Alpha;
            float b = Beta;
  
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a); 
            float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
            float z0 = r * funcs.sin_ang(a);
  
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
  
            if (this.displayTexture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }         
  
            // rotating to location coordinates
  
            float tb = 0;
            float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
            float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
            float z1 = z0;
  
            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
            float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);
  
            // scale it here!
            x2 *= 1000000.0;
            y2 *= 1000000.0;
            z2 *= 1000000.0;
  
            // move it to scale here!
            y2 += 1000000.0 * d * funcs.sin_ang(-STATION.getLatitude());      
            z2 += 1000000.0 * d * funcs.cos_ang(-STATION.getLatitude());
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }
  
          WIN3D.graphics.beginShape();
  
          WIN3D.graphics.noStroke();
  
          if (this.displayTexture) {
  
            WIN3D.graphics.texture(this.Map);
          }
  
          for (int s = 0; s < subFace.length; s++) {
  
            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, subFace[s][3] * this.Map.width, subFace[s][4] * this.Map.height);
          }
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }
  

  
 
  
  
  
  
  void drawGrid (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 
  
    if (this.displayGrid) {
  
      WIN3D.graphics.pushMatrix();
      WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);
  
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(0);
  
      for (float j = 90; j <= 270; j += 30) {
        
        float HOUR_step = 0.25;
        for (float i = 0; i <= 24; i += HOUR_step) {

          float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, i);
          float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, i + HOUR_step);
          
          if ((SunA[3] > 0) || (SunB[3] > 0)) {
            WIN3D.graphics.line(s_SunPath * SunA[1] * WIN3D.scale, -s_SunPath * SunA[2] * WIN3D.scale, s_SunPath * SunA[3] * WIN3D.scale, s_SunPath * SunB[1] * WIN3D.scale, -s_SunPath * SunB[2] * WIN3D.scale, s_SunPath * SunB[3] * WIN3D.scale);
          }
        }
      }
  
      for (float i = 0; i <= 24; i += 1) {
        float DATE_step = 1;
        for (float j = 0; j <= 360; j += DATE_step) {
          
          float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), j, i);
          float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(),  j + DATE_step, i);
          
          if ((SunA[3] > 0) || (SunB[3] > 0)) {            
            WIN3D.graphics.line(s_SunPath * SunA[1] * WIN3D.scale, -s_SunPath * SunA[2] * WIN3D.scale, s_SunPath * SunA[3] * WIN3D.scale, s_SunPath * SunB[1] * WIN3D.scale, -s_SunPath * SunB[2] * WIN3D.scale, s_SunPath * SunB[3] * WIN3D.scale);
          }
        }
      }
  
      WIN3D.graphics.popMatrix();
    }
  } 
  
  
  
  
  void drawPath (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 
  
    if (this.displayPath) {
      
      float keep_STUDY_perDays = STUDY.perDays;
      int keep_STUDY_joinDays = STUDY.joinDays;
      if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
        STUDY.perDays = 1;
        STUDY.joinDays = 1;
      }    
  
      float previous_DATE = TIME.date;
  
  
  
  
      int TES_hour = 4; // 1 = every 1 hour, 4 = every 15 minutes
  
      int PAL_type = 0; 
      int PAL_direction = 1;
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
      }             
  
      float PAL_multiplier = 1; 
      if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * this.ACTIVE_pallet_MLT;
      if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * this.PASSIVE_pallet_MLT;
  
  
  
      WIN3D.graphics.pushMatrix();
      WIN3D.graphics.translate(x_SunPath, y_SunPath, z_SunPath);
  
      WIN3D.graphics.strokeWeight(0); 
      WIN3D.graphics.stroke(0, 0, 0);
      WIN3D.graphics.fill(0, 0, 0);
  
      WIN3D.graphics.line(-1 * s_SunPath, 0, 0, 1 * s_SunPath, 0, 0); 
      WIN3D.graphics.line(0, -1 * s_SunPath, 0, 0, 1 * s_SunPath, 0);
  
      WIN3D.graphics.stroke(255, 255, 0);
  
  
  
      int[] startK_endK = get_startK_endK();
      int start_k = startK_endK[0]; 
      int end_k = startK_endK[1];
      int count_k = 1 + end_k - start_k; 
      if (count_k < 0) count_k = 0;
  
      for (int p = 0; p < 1; p++) { 
  
        int l = STUDY.ImpactLayer;
  
        int DATE_step = 1;
  
        int J_START = STUDY.j_Start;
        int J_END = STUDY.j_End;
  
        if (IMPACTS_displayDay > 0) {
          J_START = IMPACTS_displayDay - 1;
          J_END = IMPACTS_displayDay;
        }
  
        for (int j = J_START; j < J_END; j += DATE_step) {
  
          int now_k = 0;
          int now_i1 = 0;
          int now_i2 = 0;
          int now_j = 0;
  
          now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          //println(j, now_j, DATE_ANGLE);
  
          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays; 
  
              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
                if (STUDY.isInHourlyRange(i)) {

                  float HOUR_ANGLE = i; 
                  float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                  now_k = k + start_k;
  
                  now_i1 = floor(i);
                  now_i2 = (1 + now_i1) % 24;
                  float i_ratio = i - now_i1;
  
                  now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }
  
                  float Pa1 = FLOAT_undefined;
                  float Pa2 = FLOAT_undefined;
  
                  if (Impact_TYPE == Impact_ACTIVE) {
                    
                    Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
                    Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);                  
  
                  } 
  
                  if (Impact_TYPE == Impact_PASSIVE) {
                    
                    Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
                    Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);  
                    
                  }                  
  
                  if ((is_undefined_FLOAT(Pa1)) && (is_undefined_FLOAT(Pa2))) {
                  } else {
  
                    float sun_V = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
  
                    float _u = 0;
  
                    if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * sun_V);
                    if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * sun_V);
  
                    if (PAL_direction == -1) _u = 1 - _u;
                    if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                    if (PAL_direction == 2) _u =  0.5 * _u;
  
                    float[] COL = PAINT.getColorStyle(PAL_type, _u);    
  
                    WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
                    WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
                    WIN3D.graphics.strokeWeight(0.01 * WIN3D.dY);
  
                    float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE - 0.5 * (1.0 / float(TES_hour)));
                    float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE + 0.5 * (1.0 / float(TES_hour)));
  
                    if ((SunA[3] > 0) || (SunB[3] > 0)) {    
  
                      float x1 = SunA[1] * WIN3D.scale * s_SunPath;
                      float y1 = SunA[2] * WIN3D.scale * s_SunPath;
                      float z1 = SunA[3] * WIN3D.scale * s_SunPath;
    
                      float x2 = SunB[1] * WIN3D.scale * s_SunPath;
                      float y2 = SunB[2] * WIN3D.scale * s_SunPath;
                      float z2 = SunB[3] * WIN3D.scale * s_SunPath;
    
                      WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
                    }
                  }
                }
              }
            }
          }
        }
      }  
  
      WIN3D.graphics.popMatrix();
  
  
  
      STUDY.perDays = keep_STUDY_perDays;
      STUDY.joinDays = keep_STUDY_joinDays; 
      TIME.date = previous_DATE;
      TIME.updateDate();
    }
  }
  


  void drawPattern (float x_SunPath, float y_SunPath, float z_SunPath, float s_SunPath) { 
  
    if (this.displayPattern) {
  
      float keep_STUDY_perDays = STUDY.perDays;
      int keep_STUDY_joinDays = STUDY.joinDays;
      if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
        STUDY.perDays = 1;
        STUDY.joinDays = 1;
      }    
  
      float previous_DATE = TIME.date;
  
      Sun3D.draw_Cycles(x_SunPath, x_SunPath, x_SunPath, s_SunPath, s_SunPath, s_SunPath, STUDY.ImpactLayer, 3);
  
      STUDY.perDays = keep_STUDY_perDays;
      STUDY.joinDays = keep_STUDY_joinDays; 
      TIME.date = previous_DATE;
      TIME.updateDate();
    }
  }  
  
  
  
  void draw_Cycles (float x_Plot, float y_Plot, float z_Plot, float sx_Plot, float sy_Plot, float sz_Plot, int l, int target_window) {
  
    // target_window: 1:STUDY, 2:WORLD, 3:WIN3D 4:OBJ-export
  
    int[] startK_endK = get_startK_endK();
    int start_k = startK_endK[0]; 
    int end_k = startK_endK[1];
    int count_k = 1 + end_k - start_k; 
    if (count_k < 0) count_k = 0;
  
  
  
    int TES_hour = 1; //4; // 1 = every 1 hour, 4 = every 15 minutes
  
    if (STUDY.PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE;
    else Impact_TYPE = Impact_PASSIVE;
  
    float Pa1 = FLOAT_undefined;
    float Pb1 = FLOAT_undefined;
    float Pc1 = FLOAT_undefined;
    float Pd1 = FLOAT_undefined;
  
    float Pa2 = FLOAT_undefined;
    float Pb2 = FLOAT_undefined;
    float Pc2 = FLOAT_undefined;
    float Pd2 = FLOAT_undefined;
  
    float values_R_dir;
    float values_R_dif;
    float values_E_dir;
    float values_E_dif;
  
    int now_k = 0;
    int now_i1 = 0;
    int now_i2 = 0;
    int now_j = 0;
  
    int PAL_type = 0; 
    int PAL_direction = 1;
  
    float PAL_multiplier = 1; 
    if (Impact_TYPE == Impact_ACTIVE) PAL_multiplier = 1.0 * STUDY.ACTIVE_pallet_MLT;
    if (Impact_TYPE == Impact_PASSIVE) PAL_multiplier = 0.05 * STUDY.PASSIVE_pallet_MLT;
  
    if ((target_window == TypeWindow.WIN3D) || (target_window == TypeWindow.OBJ)) {
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = this.ACTIVE_pallet_CLR; 
        PAL_direction = this.ACTIVE_pallet_DIR;
        PAL_multiplier = this.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = this.PASSIVE_pallet_CLR; 
        PAL_direction = this.PASSIVE_pallet_DIR;
        PAL_multiplier = this.PASSIVE_pallet_MLT;
      }
    } else {
  
      if (Impact_TYPE == Impact_ACTIVE) {  
        PAL_type = STUDY.ACTIVE_pallet_CLR; 
        PAL_direction = STUDY.ACTIVE_pallet_DIR;
        PAL_multiplier = STUDY.ACTIVE_pallet_MLT;
      }
      if (Impact_TYPE == Impact_PASSIVE) {  
        PAL_type = STUDY.PASSIVE_pallet_CLR; 
        PAL_direction = STUDY.PASSIVE_pallet_DIR;
        PAL_multiplier = STUDY.PASSIVE_pallet_MLT;
      }
    }  
  
  
  
  
    String the_filename = "";
    String TEXTURE_path = "";
  
    if (target_window == TypeWindow.OBJ) {
  
      num_vertices_added = 0;
  
      if (User3D.export_MaterialLibrary) {
  
        the_filename = "sunPatternPallet.bmp";
  
        TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
  
        println("Saving texture:", TEXTURE_path);
  
        int RES1 = User3D.export_PalletResolution; 
        int RES2 = User3D.export_PalletResolution / 16;      
  
        PImage pallet_Texture = createImage(RES1, RES2, ARGB);       
  
  
        pallet_Texture.loadPixels();
  
        for (int np = 0; np < (RES1 * RES2); np++) {
          int Image_X = np % RES1;
          int Image_Y = np / RES1;
  
          float _val = (Image_X / (0.5 * RES1)) - 1; 
  
          float _u = 0.5 + _val;
  
          if (Impact_TYPE == Impact_ACTIVE) _u = 0.5 + 0.5 * _val;
  
          float[] COL = PAINT.getColorStyle(PAL_type, _u);  
  
          pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
        }
  
        pallet_Texture.updatePixels();   
  
        pallet_Texture.save(TEXTURE_path);      
  
  
        mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
        mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
        mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
        mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
        mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
        mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
        mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
        mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
        mtlOutput.println("\tTr 1.000"); //  0-1 transparency
        mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
  
        //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
        mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
      }
    }  
  
  
  
    num_vertices_added = 0;
  
    int end_turn = 1;
    if (target_window == TypeWindow.OBJ) end_turn = 3;
    for (int _turn = 1; _turn <= end_turn; _turn++) {
  
  
      if (target_window == TypeWindow.OBJ) {
  
        if (_turn == 3) {
  
          obj_lastGroupNumber += 1;
          objOutput.println("g sunPattern");
  
          if (User3D.export_MaterialLibrary) {      
            objOutput.println("usemtl " +  the_filename.replace('.', '_'));
          }
        }
      }    
  
  
  
      for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {
  
        float[][][] SunPathMesh = new float [24 * TES_hour][1 + int(STUDY.perDays / STUDY.joinDays)][3];        
  
        for (int more_J = 0; more_J < STUDY.perDays; more_J += STUDY.joinDays) {
  
          now_j = (more_J + j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
          int[] Normals_COL_N;
          Normals_COL_N = new int [9];
          {
            int keep_filter_type = STUDY.filter;
            STUDY.filter = filter_HOURLY;
  
            Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, more_J + j, DATE_ANGLE);
  
            STUDY.filter = keep_filter_type;
          }
  
          for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
            if (nk != -1) {
              int k = int(nk / STUDY.joinDays);
              int j_ADD = nk % STUDY.joinDays; 
  
              float valuesSUM_RAD = 0;
              float valuesSUM_EFF = 0;
              int valuesNUM = 0; 
  
              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
  
                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                float Alpha = 90 - funcs.acos_ang(SunR[3]);
                float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);
  
                //-------------- to extend graph to the horizon ---------------
                if (Alpha < 0) {              
  
                  if (SunR[1] > 0) { 
                    float[] SunR_rise = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, sunrise);
  
                    Alpha = 0;
                    Beta = 180 - funcs.atan2_ang(SunR_rise[1], SunR_rise[2]);
                  } else {
                    float[] SunR_set = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, sunset);
  
                    Alpha = 0;
                    Beta = 180 - funcs.atan2_ang(SunR_set[1], SunR_set[2]);
                  }
                }
                //-----------------------------------------------------------
  
                now_k = k + start_k;
  
                now_i1 = floor(i);
                now_i2 = (1 + now_i1) % 24;
                float i_ratio = i - now_i1; 
  
                now_j = int(more_J + j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                if (now_j >= 365) {
                  now_j = now_j % 365;
                }
                if (now_j < 0) {
                  now_j = (now_j + 365) % 365;
                }
  
                Pa1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_dirnorrad.id);
                Pb1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difhorrad.id);
                Pc1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_direffect.id);
                Pd1 = getValue_CurrentDataSource(now_i1, now_j, now_k, LAYER_difeffect.id);
  
                Pa2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_dirnorrad.id);
                Pb2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difhorrad.id);
                Pc2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_direffect.id);
                Pd2 = getValue_CurrentDataSource(now_i2, now_j, now_k, LAYER_difeffect.id);
                
                if ((is_undefined_FLOAT(Pa1)) || (is_undefined_FLOAT(Pb1)) || (is_undefined_FLOAT(Pc1)) || (is_undefined_FLOAT(Pd1))
                  || (is_undefined_FLOAT(Pa2)) || (is_undefined_FLOAT(Pb2)) || (is_undefined_FLOAT(Pc2)) || (is_undefined_FLOAT(Pd2))) {
                  values_R_dir = FLOAT_undefined;
                  values_R_dif = FLOAT_undefined;
                  values_E_dir = FLOAT_undefined;
                  values_E_dif = FLOAT_undefined;
                } else {
  
                  int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i1, now_j, now_k);
                  
                  if (memberCount == 1) {
                    values_R_dir = 0.001 * (Pa1 * (1 - i_ratio) + Pa2 * i_ratio);
                    values_R_dif = 0.001 * (Pb1 * (1 - i_ratio) + Pb2 * i_ratio);
                    values_E_dir = 0.001 * (Pc1 * (1 - i_ratio) + Pc2 * i_ratio);
                    values_E_dif = 0.001 * (Pd1 * (1 - i_ratio) + Pd2 * i_ratio);
  
                    if (is_undefined_FLOAT(valuesSUM_RAD)) {
                      valuesSUM_RAD = 0;
                      valuesSUM_EFF = 0;
                      valuesNUM = 0;
                    } else {
                      valuesSUM_RAD = (values_R_dir); // direct beam radiation
                      valuesSUM_EFF = (values_E_dir); // direct beam effect
                      valuesNUM = 1;
                    }
                  }
                }
  
                float valuesSUM = FLOAT_undefined;
                if (Impact_TYPE == Impact_ACTIVE) valuesSUM = valuesSUM_RAD;
                if (Impact_TYPE == Impact_PASSIVE) valuesSUM = valuesSUM_EFF; 
  
                int row_J = more_J / STUDY.joinDays;
  
                SunPathMesh[floor(i * TES_hour)][row_J][0] = Alpha;
                SunPathMesh[floor(i * TES_hour)][row_J][1] = Beta;
                SunPathMesh[floor(i * TES_hour)][row_J][2] = valuesSUM;
              }
            } else {
              for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {
  
                float valuesSUM = FLOAT_undefined; 
  
                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                float Alpha = 90 - funcs.acos_ang(SunR[3]);
                float Beta = 180 - funcs.atan2_ang(SunR[1], SunR[2]);
  
                int row_J = more_J / STUDY.joinDays;
  
                SunPathMesh[floor(i * TES_hour)][row_J][0] = Alpha;
                SunPathMesh[floor(i * TES_hour)][row_J][1] = Beta;
                SunPathMesh[floor(i * TES_hour)][row_J][2] = valuesSUM;
              }
            }
          }
        }
  
  
  
        for (int more_J = 0; more_J < STUDY.perDays - STUDY.joinDays; more_J += STUDY.joinDays) { //count one less!
  
          now_j = (more_J + j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;
  
          if (now_j >= 365) {
            now_j = now_j % 365;
          }
          if (now_j < 0) {
            now_j = (now_j + 365) % 365;
          }
  
          float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
          for (float i = 0; i < 24; i += 1.0 / float (TES_hour)) {  
            if (STUDY.isInHourlyRange(i)) {
              if ((i > sunrise - 1.0 / float(TES_hour)) && (i < sunset + 1.0 / float(TES_hour))) {              
  
                if (target_window == TypeWindow.OBJ) {
                } else if (target_window == TypeWindow.WIN3D) {
                  WIN3D.graphics.beginShape();
                  WIN3D.graphics.noStroke();
                } else if (target_window == TypeWindow.WORLD) {
                  WORLD.graphics.beginShape();
                  WORLD.graphics.noStroke();
                } else if (target_window == TypeWindow.STUDY) {
                  STUDY.graphics.beginShape();
                  STUDY.graphics.noStroke();
                }  
  
                for (int s = 0; s < 4; s++) {
  
                  int a = int(i * TES_hour);
                  int b = more_J / STUDY.joinDays;
  
                  if ((s == 1) || (s == 2)) {
                    a += 1;
                  }
  
                  if ((s == 2) || (s == 3)) {
                    b += 1;
                  }
  
                  if (a > (24 * TES_hour - 1)) a = a % (24 * TES_hour);
  
                  float Alpha = SunPathMesh[a][b][0];
                  float Beta = SunPathMesh[a][b][1];
                  float valuesSUM = SunPathMesh[a][b][2];
  
                  if (Alpha >= 0) {
  
                    if (is_undefined_FLOAT(valuesSUM) == false) {
  
                      float _u = 0;
  
                      if (Impact_TYPE == Impact_ACTIVE) _u = (PAL_multiplier * valuesSUM);
                      if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (PAL_multiplier * valuesSUM);
  
                      if (PAL_direction == -1) _u = 1 - _u;
                      if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
                      if (PAL_direction == 2) _u =  0.5 * _u;
  
                      float[] COL = PAINT.getColorStyle(PAL_type, _u);
  
                      float r = sx_Plot;
  
                      if (target_window == TypeWindow.OBJ) {
  
                        float x = funcs.cos_ang(Alpha) * (funcs.cos_ang(Beta - 90)) * WIN3D.scale * r + x_Plot;
                        float y = funcs.cos_ang(Alpha) * (funcs.sin_ang(Beta - 90)) * WIN3D.scale * r + y_Plot;
                        float z = funcs.sin_ang(Alpha) * WIN3D.scale * sz_Plot + z_Plot;
  
                        if (_turn == 1) {
                          SOLARCHVISION_OBJprintVertex(x, y, z);
                        }
  
                        if (_turn == 2) { 
                          float u1 = 0.5 * (_u + 0.5);
  
                          if ((WIN3D.FacesShade == SHADE.Global_Solar) || (WIN3D.FacesShade == SHADE.Vertex_Solar)) {
                            if (Impact_TYPE == Impact_ACTIVE) u1 = _u;
                          }
  
                          if (u1 > 0.999) u1 = 0.999;
                          if (u1 < 0.001) u1 = 0.001;
  
                          SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
                        }
  
                        if (_turn == 3) {
                          num_vertices_added += 1;
                        }
                      } else if (target_window == TypeWindow.WIN3D) {
                        WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);
  
                        float x = funcs.cos_ang(Alpha) * (funcs.cos_ang(Beta - 90)) * WIN3D.scale * r + x_Plot;
                        float y = funcs.cos_ang(Alpha) * (funcs.sin_ang(Beta - 90)) * WIN3D.scale * r + y_Plot;
                        float z = funcs.sin_ang(Alpha) * WIN3D.scale * sz_Plot + z_Plot;
  
                        WIN3D.graphics.vertex(x, -y, z);
                      } else if (target_window == TypeWindow.WORLD) {
                        // ??????????????????????????
                      } else if (target_window == TypeWindow.STUDY) {
  
                        STUDY.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
                        float x = (90 - Alpha) * (funcs.cos_ang(Beta - 90)) * STUDY.rect_scale * r + x_Plot * STUDY.rect_scale;
                        float y = (90 - Alpha) * (funcs.sin_ang(Beta - 90)) * STUDY.rect_scale * r + y_Plot * STUDY.rect_scale;
  
                        float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
                        STUDY.graphics.vertex(ox + x, -y);
                      }
                    }
                  }
                }
  
                if (target_window == TypeWindow.OBJ) {
  
                  if (_turn == 3) {
  
                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
  
                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
  
                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                  }
                } else if (target_window == TypeWindow.WIN3D) {
                  WIN3D.graphics.endShape(CLOSE);
                } else if (target_window == TypeWindow.WORLD) {
                  WORLD.graphics.endShape(CLOSE);
                } else if (target_window == TypeWindow.STUDY) {
                  STUDY.graphics.endShape(CLOSE);
                }
              }
            }
          }
        }
      }
  
  
      if (target_window == TypeWindow.OBJ) {
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }
    }  
  
  
  
  
  
    if (target_window == TypeWindow.WIN3D) {
      WIN3D.graphics.strokeWeight(1);
      WIN3D.graphics.stroke(127);
    } else if (target_window == TypeWindow.WORLD) {
      WORLD.graphics.strokeWeight(1);
      WORLD.graphics.stroke(127);
    } else if (target_window == TypeWindow.STUDY) {
      STUDY.graphics.strokeWeight(1);
      STUDY.graphics.stroke(127);
    }
  
    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {    
  
      int max_j_to_draw_grid = STUDY.j_End;
      if ((target_window == TypeWindow.WIN3D) || (target_window == TypeWindow.OBJ)) {
        max_j_to_draw_grid = 1; // draw it just once!
      }
      if (j < max_j_to_draw_grid) {
  
  
        float s_SunPath = sx_Plot;
  
        for (int myDATE = 90; myDATE <= 270; myDATE += 30) {
  
          float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), myDATE); 
          float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), myDATE);        
  
          float myHOUR_step = 1.0 / float(TES_hour);
  
          for (float myHOUR = 0; myHOUR < 24; myHOUR += myHOUR_step) {
  
  
  
            float HourA = myHOUR;
            float HourB = myHOUR + myHOUR_step;
  
            float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, HourA);
            float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, HourB);
  
            if ((SunA[3] < 0) && (SunB[3] > 0)) {
              SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, sunrise);
              SunA[3] = 0;
            }
            if ((SunA[3] > 0) && (SunB[3] < 0)) {
              SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, sunset);
              SunB[3] = 0;
            }
  
  
  
            if ((SunA[3] >= 0) && (SunB[3] >= 0)) {
  
              if (target_window == TypeWindow.WIN3D) {
  
                float x1 = SunA[1] * WIN3D.scale * s_SunPath + x_Plot;
                float y1 = SunA[2] * WIN3D.scale * s_SunPath + y_Plot;
                float z1 = SunA[3] * WIN3D.scale * s_SunPath + z_Plot;
  
                float x2 = SunB[1] * WIN3D.scale * s_SunPath + x_Plot;
                float y2 = SunB[2] * WIN3D.scale * s_SunPath + y_Plot;
                float z2 = SunB[3] * WIN3D.scale * s_SunPath + z_Plot;
  
                WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
              } else if (target_window == TypeWindow.WORLD) {
                // ??????????????????????????
              } else if (target_window == TypeWindow.STUDY) {
  
                float Alpha1 = funcs.asin_ang(SunA[3]);
                float Beta1 = funcs.atan2_ang(SunA[2], SunA[1]) + 90;          
  
                float Alpha2 = funcs.asin_ang(SunB[3]);
                float Beta2 = funcs.atan2_ang(SunB[2], SunB[1]) + 90;          
  
                float x1 = (90 - Alpha1) * (funcs.cos_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
                float y1 = (90 - Alpha1) * (funcs.sin_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;
  
                float x2 = (90 - Alpha2) * (funcs.cos_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
                float y2 = (90 - Alpha2) * (funcs.sin_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;
  
                float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
                STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
              }
            }
          }
        }
  
        for (float myHOUR = 0; myHOUR < 24; myHOUR++) {
  
          int myDATE_step = STUDY.joinDays;
  
          int myDATE_start = 0;
          int myDATE_end = 360; 
  
          if (target_window != 3) {
            if (STUDY.j_End == 2) {
              if (j == 0) {
                myDATE_start = 90;
                myDATE_end = 270;
              }
              if (j == 1) {
                myDATE_start = 270;
                myDATE_end = 450;
              }
            }
          }
  
          for (int myDATE = myDATE_start; myDATE <= myDATE_end; myDATE += myDATE_step) {
            float[] SunA = SOLARCHVISION_SunPosition(STATION.getLatitude(), myDATE, myHOUR);
            float[] SunB = SOLARCHVISION_SunPosition(STATION.getLatitude(), (myDATE + myDATE_step), myHOUR);
            if ((SunA[3] >= 0) && (SunB[3] >= 0)) {
  
              if (target_window == TypeWindow.WIN3D) {        
  
                float x1 = SunA[1] * WIN3D.scale * s_SunPath + x_Plot;
                float y1 = SunA[2] * WIN3D.scale * s_SunPath + y_Plot;
                float z1 = SunA[3] * WIN3D.scale * s_SunPath + z_Plot;
  
                float x2 = SunB[1] * WIN3D.scale * s_SunPath + x_Plot;
                float y2 = SunB[2] * WIN3D.scale * s_SunPath + y_Plot;
                float z2 = SunB[3] * WIN3D.scale * s_SunPath + z_Plot;
  
                float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
                WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
              } else if (target_window == TypeWindow.WORLD) {
                // ??????????????????????????
              } else if (target_window == TypeWindow.STUDY) {
  
                float Alpha1 = funcs.asin_ang(SunA[3]);
                float Beta1 = funcs.atan2_ang(SunA[2], SunA[1]) + 90;          
  
                float Alpha2 = funcs.asin_ang(SunB[3]);
                float Beta2 = funcs.atan2_ang(SunB[2], SunB[1]) + 90;          
  
                float x1 = (90 - Alpha1) * (funcs.cos_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
                float y1 = (90 - Alpha1) * (funcs.sin_ang(Beta1 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;
  
                float x2 = (90 - Alpha2) * (funcs.cos_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + x_Plot * STUDY.rect_scale;
                float y2 = (90 - Alpha2) * (funcs.sin_ang(Beta2 - 90)) * STUDY.rect_scale * s_SunPath + y_Plot * STUDY.rect_scale;
  
                float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
                STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
              }
            }
          }
        }
  
  
  
        if (target_window == TypeWindow.WIN3D) {  
          WIN3D.graphics.stroke(0);
          WIN3D.graphics.fill(0);
          WIN3D.graphics.textAlign(CENTER, CENTER);
        } else if (target_window == TypeWindow.WORLD) {  
          WORLD.graphics.stroke(0);
          WORLD.graphics.fill(0);
          WORLD.graphics.textAlign(CENTER, CENTER);
        } else if (target_window == TypeWindow.STUDY) {  
          STUDY.graphics.stroke(0);
          STUDY.graphics.fill(0);
          STUDY.graphics.textAlign(CENTER, CENTER);
        }      
  
        for (int i = 0; i < 360; i++) {
          if (target_window == TypeWindow.WIN3D) {  
  
            float x1 = s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
            float y1 = s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
            float z1 = 0 + z_Plot;
  
            float x2 = s_SunPath * cos((i + 5) * PI / 180) * WIN3D.scale + x_Plot;
            float y2 = s_SunPath * sin((i + 5) * PI / 180) * WIN3D.scale + y_Plot;
            float z2 = 0 + z_Plot;
  
            WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
          } else if (target_window == TypeWindow.WORLD) {
            // ??????????????????????????
          } else if (target_window == TypeWindow.STUDY) {
            // no nead for a circle here in this case!
          }
        }
  
        for (int i = 0; i < 360; i += 5) {
          if (target_window == TypeWindow.WIN3D) {  
  
            float x1 = s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
            float y1 = s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
            float z1 = 0 + z_Plot;
  
            float x2 = 1.05 * s_SunPath * cos((i) * PI / 180) * WIN3D.scale + x_Plot;
            float y2 = 1.05 * s_SunPath * sin((i) * PI / 180) * WIN3D.scale + y_Plot;
            float z2 = 0 + z_Plot;
  
            WIN3D.graphics.line(x1, -y1, z1, x2, -y2, z2);
          } else if (target_window == TypeWindow.WORLD) {
            // ??????????????????????????
          } else if (target_window == TypeWindow.STUDY) {
  
            float x1 = 90 * s_SunPath * cos(i * PI / 180) * STUDY.rect_scale + x_Plot * STUDY.rect_scale;
            float y1 = 90 * s_SunPath * sin(i * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;
  
            float x2 = 90 * 1.05 * s_SunPath * cos((i) * PI / 180) * STUDY.rect_scale + x_Plot * STUDY.rect_scale;
            float y2 = 90 * 1.05 * s_SunPath * sin((i) * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;
  
            float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
            STUDY.graphics.line(ox + x1, -y1, ox + x2, -y2);
          }
        }
  
  /*
        for (int i = 0; i < 360; i += 15) {
  
          String txt = nf((90 - i + 360) % 360, 0);
          if (i == 0) {
            txt = "E";
          } else if (i == 90) {
            txt = "N";
          } else if (i == 180) {
            txt = "W";
          } else if (i == 270) {
            txt = "S";
          }
  
          float txtSize = 0.1;
          if (txt.length() > 1) txtSize *= 0.75;
  
          if (target_window == TypeWindow.WIN3D) {
  
            float x = 1.10 * s_SunPath * cos(i * PI / 180) * WIN3D.scale + x_Plot;
            float y = 1.10 * s_SunPath * sin(i * PI / 180) * WIN3D.scale + y_Plot;
            float z = 0 + z_Plot;
  
            WIN3D.graphics.textSize(txtSize * WIN3D.scale * s_SunPath);
            WIN3D.graphics.text(txt, x, -y, z);
          } else if (target_window == TypeWindow.WORLD) {
            // ??????????????????????????
          } else if (target_window == TypeWindow.STUDY) {
            float x = 90 * 1.10 * s_SunPath * cos(i * PI / 180) * STUDY.rect_scale+ x_Plot * STUDY.rect_scale;
            float y = 90 * 1.10 * s_SunPath * sin(i * PI / 180) * STUDY.rect_scale + y_Plot * STUDY.rect_scale;
  
            float ox = (j + STUDY.rect_offset_x) * sx_Plot;
  
            STUDY.graphics.textSize(txtSize * 0.4 * s_SunPath);
            STUDY.graphics.text(txt, ox + x, -y);
          }
        }
  */
      }
    }
  }  
  
  
  
  
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setInt("ACTIVE_pallet_CLR", this.ACTIVE_pallet_CLR);
    parent.setInt("ACTIVE_pallet_DIR", this.ACTIVE_pallet_DIR);
    parent.setFloat("ACTIVE_pallet_MLT", this.ACTIVE_pallet_MLT);
    parent.setInt("PASSIVE_pallet_CLR", this.PASSIVE_pallet_CLR);
    parent.setInt("PASSIVE_pallet_DIR", this.PASSIVE_pallet_DIR);
    parent.setFloat("PASSIVE_pallet_MLT", this.PASSIVE_pallet_MLT);
    
    parent.setString("displayGrid", Boolean.toString(this.displayGrid));
    parent.setString("displayPath", Boolean.toString(this.displayPath));
    parent.setString("displayPattern", Boolean.toString(this.displayPattern));
           
    
    parent.setString("displaySurface", Boolean.toString(this.displaySurface));
    parent.setString("displayTexture", Boolean.toString(this.displayTexture));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.ACTIVE_pallet_CLR = parent.getInt("ACTIVE_pallet_CLR");
    this.ACTIVE_pallet_DIR = parent.getInt("ACTIVE_pallet_DIR");
    this.ACTIVE_pallet_MLT = parent.getFloat("ACTIVE_pallet_MLT");
    this.PASSIVE_pallet_CLR = parent.getInt("PASSIVE_pallet_CLR");
    this.PASSIVE_pallet_DIR = parent.getInt("PASSIVE_pallet_DIR");
    this.PASSIVE_pallet_MLT = parent.getFloat("PASSIVE_pallet_MLT");
    
    this.displayGrid = Boolean.parseBoolean(parent.getString("displayGrid"));      
    this.displayPath = Boolean.parseBoolean(parent.getString("displayPath"));
    this.displayPattern = Boolean.parseBoolean(parent.getString("displayPattern"));      
    
    this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
    this.displayTexture = Boolean.parseBoolean(parent.getString("displayTexture"));
  }   
}

solarchvision_Sun3D Sun3D = new solarchvision_Sun3D();


class solarchvision_Moon3D {
  
  private final static String CLASS_STAMP = "Moon3D";
  
  boolean displaySurface = false;
  boolean displayTexture = true;
  
  String Filename = BaseFolder + "/Input/BackgroundImages/Standard/Maps/Moon/Moon.jpg";

  PImage Map; 
  
  void load_images () {
    Map = loadImage(Filename);
  }  
  
  void draw () {
    if (this.displaySurface) {
  
      WIN3D.graphics.strokeWeight(1);
  
      float OffsetX = 0; 
      float OffsetY = 0; 
  
      float ScaleX = 1; 
      float ScaleY = 1; 
  
      float CEN_lon = 0; 
      float CEN_lat = 0; 
  
      float delta_Alpha = -5;
      float delta_Beta = -10;
  
      float r = 1737000.0 * Planetary_Magnification;
      float d = 384400000.0 - FLOAT_r_Earth;
  
      for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
        for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
  
          float[][] subFace = new float [4][5];
  
          for (int s = 0; s < 4; s++) {
  
            float a = Alpha;
            float b = Beta;
  
            if ((s == 2) || (s == 3)) {
              a += delta_Alpha;
            }
  
            if ((s == 1) || (s == 2)) {
              b += delta_Beta;
            }
  
            float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a); 
            float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
            float z0 = r * funcs.sin_ang(a);
  
            float _lon = b - CEN_lon;
            float _lat = a - CEN_lat;
  
            if (this.displayTexture) {
              // calculating u and v
              subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
              subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
            }         
  
            // rotating to location coordinates
  
  
            float tb = 0;
            float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
            float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
            float z1 = z0;
  
            float ta = -90 - STATION.getLatitude();
            float x2 = x1;
            float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
            float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);
  
            // move it up here!
            y2 += d * funcs.sin_ang(-STATION.getLatitude());      
            z2 += d * funcs.cos_ang(-STATION.getLatitude());
  
            subFace[s][0] = x2;
            subFace[s][1] = y2;
            subFace[s][2] = z2;
          }
  
          WIN3D.graphics.beginShape();
  
          WIN3D.graphics.noStroke();
  
          if (this.displayTexture) {
  
            WIN3D.graphics.texture(this.Map);
          }
  
          for (int s = 0; s < subFace.length; s++) {
  
            WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, subFace[s][3] * this.Map.width, subFace[s][4] * this.Map.height);
          }
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
    }
  }
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setString("displaySurface", Boolean.toString(this.displaySurface));
    parent.setString("displayTexture", Boolean.toString(this.displayTexture));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
    this.displayTexture = Boolean.parseBoolean(parent.getString("displayTexture"));
  }   
}

solarchvision_Moon3D Moon3D = new solarchvision_Moon3D();






class solarchvision_Earth3D {
  
  private final static String CLASS_STAMP = "Earth3D";
    
  boolean displaySurface = false; //true;
  boolean displayTexture = true;
  
  PImage[] Map;
  
  float[][] BoundariesX;
  float[][] BoundariesY;
  
  String Path = BaseFolder + "/Input/BackgroundImages/Standard/Maps/EarthSurface";
  
  String[] Filenames = sort(OPESYS.getFiles(this.Path));
  
  
  void resize_images () {
  
    int n = this.Filenames.length;
  
    this.Map = new PImage [n];
  
    this.BoundariesX = new float [n][2];
    this.BoundariesY = new float [n][2];
    
  }
  
  
  void load_images () {
  
    for (int i = 0; i < this.Filenames.length; i++) {
  
      String MapFilename = this.Path + "/" + this.Filenames[i];
  
      String[] Parts = split(this.Filenames[i], '_');
  
      this.BoundariesX[i][0] = -float(Parts[1]) * 0.001;
      this.BoundariesY[i][0] =  float(Parts[2]) * 0.001;
      this.BoundariesX[i][1] = -float(Parts[3]) * 0.001;
      this.BoundariesY[i][1] =  float(Parts[4]) * 0.001;
  
      println("Loading:", MapFilename);
  
      this.Map[i] = loadImage(MapFilename);
    }
  }
  
  
  
  void draw (int target_window) {
  
    boolean proceed = true;
  
    if ((this.displaySurface == false) || (this.displayTexture == false)) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
  
    if (proceed) {
  
      int n_Map = 0;
      if (IMPACTS_displayDay < this.Map.length) n_Map = IMPACTS_displayDay;
  
      float OffsetX = this.BoundariesX[n_Map][0] + 180;
      float OffsetY = this.BoundariesY[n_Map][1] - 90;
  
      float ScaleX = (this.BoundariesX[n_Map][1] - this.BoundariesX[n_Map][0]) / 360.0;
      float ScaleY = (this.BoundariesY[n_Map][1] - this.BoundariesY[n_Map][0]) / 180.0;
  
      float CEN_lon = 0.5 * (this.BoundariesX[n_Map][0] + this.BoundariesX[n_Map][1]);
      float CEN_lat = 0.5 * (this.BoundariesY[n_Map][0] + this.BoundariesY[n_Map][1]);
  
      float delta_Alpha = -BIOSPHERE_drawResolution;
      float delta_Beta = -BIOSPHERE_drawResolution;
  
      float r = FLOAT_r_Earth;
      
  
      if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
      
        if (User3D.export_MaterialLibrary) {
  
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='EarthSphere" + nf(n_Map, 0) + "'>");
          }
          
          if (target_window == TypeWindow.OBJ) {
    
            mtlOutput.println("newmtl EarthSphere");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
    
          if (this.displayTexture) {
    
            String old_Texture_path = this.Path + "/" + this.Filenames[n_Map];
    
            String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
            String new_Texture_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
    
            println("Copying texture:", old_Texture_path, ">", new_Texture_path);
            saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
            if (target_window == TypeWindow.OBJ) {
    
              //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
              mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map        
              mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
            }
            
            if (target_window == TypeWindow.HTML) {
              htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
            }                
  
          }
        }
        
        if (target_window == TypeWindow.HTML) {
          htmlOutput.println("\t\t\t\t</Appearance>");
        }              
    
        if (target_window == TypeWindow.OBJ) {
          if (User3D.export_PolyToPoly == 1) {
            obj_lastGroupNumber += 1;  
            objOutput.println("g EarthSphere");
          }
      
          if (User3D.export_MaterialLibrary) {
            objOutput.println("usemtl EarthSphere");
          }
        }
        
      }
  
      
      num_vertices_added = 0;
  
      int end_turn = 1;
      if (target_window == TypeWindow.OBJ) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {
  
        int f = 0;
        for (float Alpha = 90; Alpha > -90; Alpha += delta_Alpha) {
          for (float Beta = 180; Beta > -180; Beta += delta_Beta) {
            f += 1;
    
            float[][] subFace = new float [4][5];
    
            for (int s = 0; s < 4; s++) {
    
              float a = Alpha;
              float b = Beta;
    
              if ((s == 2) || (s == 3)) {
                a += delta_Alpha;
              }
    
              if ((s == 1) || (s == 2)) {
                b += delta_Beta;
              }
    
              float x0 = r * funcs.cos_ang(b - 90) * funcs.cos_ang(a); 
              float y0 = r * funcs.sin_ang(b - 90) * funcs.cos_ang(a);
              float z0 = r * funcs.sin_ang(a);
    
              float _lon = b - CEN_lon;
              float _lat = a - CEN_lat;
    
              if (this.displayTexture) {
                // calculating u and v
                subFace[s][3] = (_lon / ScaleX / 360.0 + 0.5); 
                subFace[s][4] = (-_lat / ScaleY / 180.0 + 0.5);
              }         
    
              // rotating to location coordinates 
              float tb = -STATION.getLongitude();
              float x1 = x0 * funcs.cos_ang(tb) - y0 * funcs.sin_ang(tb);
              float y1 = x0 * funcs.sin_ang(tb) + y0 * funcs.cos_ang(tb);
              float z1 = z0;
    
              float ta = 90 - STATION.getLatitude();
              float x2 = x1;
              float y2 = z1 * funcs.sin_ang(ta) + y1 * funcs.cos_ang(ta);
              float z2 = z1 * funcs.cos_ang(ta) - y1 * funcs.sin_ang(ta);
    
              // move it down!
              z2 -= FLOAT_r_Earth;
    
              subFace[s][0] = x2;
              subFace[s][1] = y2;
              subFace[s][2] = z2;
            }
    
  
            if (target_window == TypeWindow.HTML) {
  
              htmlOutput.println("\t\t\t\t<shape>");
  
              if (n_Map != -1) {   
                htmlOutput.println("\t\t\t\t\t<Appearance USE='EarthSphere" + nf(n_Map, 0) + "'></Appearance>");
              }      
              
              htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
              
              htmlOutput.print  (" coordIndex='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(" ");
                }         
                htmlOutput.print(nf(s, 0));          
              }
              htmlOutput.println(" -1'>");
              
              htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
              for (int s = 0; s < subFace.length; s++) {
                if (s > 0) {
                  htmlOutput.print(",");
                }                  
                
                htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
              }                
              htmlOutput.println("'></Coordinate>");
              
            }
  
            if (target_window == TypeWindow.WIN3D) {
              
              WIN3D.graphics.strokeWeight(1);
              
              WIN3D.graphics.beginShape();
      
              WIN3D.graphics.noStroke();
              
              if (this.displayTexture) {
      
                WIN3D.graphics.texture(this.Map[n_Map]);
              }            
            }
            
            
    
            for (int s = 0; s < subFace.length; s++) {
  
              float x = subFace[s][0];
              float y = subFace[s][1];
              float z = subFace[s][2];
              float u = subFace[s][3];
              float v = subFace[s][4];
              
              if (u > 1) u = 1;
              if (u < 0) u = 0;
              if (v > 1) v = 1;
              if (v < 0) v = 0;            
    
              if (target_window == TypeWindow.WIN3D) {
        
                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * this.Map[n_Map].width, v * this.Map[n_Map].height);
              }
  
              
              if (target_window == TypeWindow.OBJ) {
                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }
    
                if (_turn == 2) {
  
                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }
    
                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }    
              }
             
              if (target_window == TypeWindow.HTML) {
                
                if (n_Map != -1) {   
                
                  if (s == 0) {
                    htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                  }
                  if (s > 0) {
                    htmlOutput.print(",");
                  }                  
  
                  v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                  SOLARCHVISION_HTMLprintVtexture(u, v);
                  
                  if (s == subFace.length - 1) {
                    htmlOutput.println("'></TextureCoordinate>");
                  }       
                }              
   
              }
              
            }
            
            if (target_window == TypeWindow.HTML) {
  
              htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
              
              htmlOutput.println("\t\t\t\t</shape>");
  
            }          
            
            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }
            
            if (target_window == TypeWindow.OBJ) {
              String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
              String n2_txt = nf(obj_lastVertexNumber - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber - 0, 0);
    
              String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
              String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
              String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
    
              if (User3D.export_PolyToPoly == 0) {
                if (_turn == 3) {
                  obj_lastGroupNumber += 1;
                  objOutput.println("g EarthSphere_" + nf(f, 0));
                }
              } 
    
              if (_turn == 3) {
                obj_lastFaceNumber += 1;            
                objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                if (User3D.export_BackSides) {
                  obj_lastFaceNumber += 1;
                  objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                }
              }          
            }
          }
        }
      }
    }
  }


  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setString("displaySurface", Boolean.toString(this.displaySurface));
    parent.setString("displayTexture", Boolean.toString(this.displayTexture));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
    this.displayTexture = Boolean.parseBoolean(parent.getString("displayTexture"));
  }      

}

solarchvision_Earth3D Earth3D = new solarchvision_Earth3D(); 



class solarchvision_Land3D {
  
  private final static String CLASS_STAMP = "Land3D";
  
  boolean loadMesh = true; 
  boolean loadTextures = true;
  
  boolean displaySurface = true; 
  boolean displayPoints = false;
  boolean displayTexture = true;
  boolean displayDepth = false;  
  
  int pallet_CLR = 1; 
  int pallet_DIR = -1; 
  float pallet_MLT = 0.05; 
  
  float[][][] Mesh;
  
  float[] Textures_U_scale;
  float[] Textures_V_scale;
  PImage[] Textures_Map;
  String[] Textures_ImagePath;
  int Textures_num = 0;
  
  
  //Polar
  int num_rows = 24;  
  int num_columns = 48 + 1;  
  
  int Surface_SkipStart = 0; 
  int Surface_SkipEnd = 0;  
  
  int displayTessellation = 1; //0; //2;  

  
  void update_textures () {
  
    this.Textures_U_scale = new float [0];
    this.Textures_V_scale = new float [0];
    this.Textures_Map = new PImage [0];
    this.Textures_ImagePath = new String [0];
    this.Textures_num = 0;
  
    this.displayTexture = false;
  
    if (this.loadTextures) {
  
      try {     
    
        String[] filenames = sort(OPESYS.getFiles(Folder_Land)); // important to sort
    
        if (filenames != null) {
          for (int i = 0; i < filenames.length; i++) {
            println(filenames[i]);
    
            int _L = filenames[i].length();
            String _Extention = filenames[i].substring(_L - 4, _L);
            //println(_Extention);
            if (_Extention.toLowerCase().equals(".jpg")) {
    
              String[] Parts = split(filenames[i], '_');
    
              if (Parts[0].toUpperCase().equals("ELEV")) {
    
                if (Parts.length > 1) {
    
                  String dir = Folder_Land + "/" + filenames[i];
    
                  {
                    String[] new_item = {
                      dir
                    };
    
                    this.Textures_ImagePath = (String[]) concat(this.Textures_ImagePath, new_item);
                  }
    
                  float u = float(Parts[1]);
                  float v = u;
    
                  {
                    PImage[] new_item = {
                      loadImage(dir)
                    };
    
                    this.Textures_Map = (PImage[]) concat(this.Textures_Map, new_item);
                    
                    int w = new_item[0].width;
                    int h = new_item[0].height;
                    
                    if (w < h) {
                      if (h != 0) {
                        u *= w / (1.0 * h);
                      } 
                    }
                    
                    if (w > h) {
                      if (w != 0) {
                        v *= h / (1.0 * w);
                      } 
                    }
                    
                  }
    
    
    
                  {
                    float[] new_item = {
                      u
                    };
    
                    this.Textures_U_scale = (float[]) concat(this.Textures_U_scale, new_item);
                  }  
    
                  {
                    float[] new_item = {
                      v
                    };
    
                    this.Textures_V_scale = (float[]) concat(this.Textures_V_scale, new_item);
                  }
    
                  this.Textures_num += 1;
    
    
                  this.displayTexture = true;
                }
              }
            }
          }
        }
      }
      catch (Exception e) {
        println("ERROR loading this.Textures_Map!");
      }
    }
    
    WIN3D.update = true;
  }
  
  
  
  
  void update_mesh () {
  
    this.Mesh = new float [this.num_rows][this.num_columns][3];
  
    for (int i = 0; i < this.num_rows; i++) {
      for (int j = 0; j < this.num_columns; j++) {
        this.Mesh[i][j][0] = FLOAT_undefined;
        this.Mesh[i][j][1] = FLOAT_undefined;
        this.Mesh[i][j][2] = FLOAT_undefined;
      }
    }
  
    Boolean using_default_mesh = false;
  
    try { 
  
      if (this.loadMesh) {
        
        for (int i = 0; i < this.num_rows; i++) {
  
          XML FileALL = loadXML(Folder_Land + "/" + nf(i, 0) + ".xml");
  
          XML[] children0 = FileALL.getChildren("result");
  
          for (int j = 0; j < this.num_columns; j++) {
  
            String txt_elevation = children0[j].getChild("elevation").getContent();
  
            XML[] children1 = children0[j].getChildren("location");
  
            String txt_latitude = children1[0].getChild("lat").getContent();
            String txt_longitude = children1[0].getChild("lng").getContent();
  
            //println(txt_longitude, txt_latitude, txt_elevation);
  
            double _lon = Double.parseDouble(txt_longitude); 
            double _lat = Double.parseDouble(txt_latitude); 
  
            float[] XY = funcs.convert_lonlat2XY(STATION.getLongitude(), STATION.getLatitude(), _lon, _lat);
  
            float x = XY[0];
            float y = XY[1]; 
            float z = float(txt_elevation);
  
            this.Mesh[i][j][0] = x;      
            this.Mesh[i][j][1] = y;      
            this.Mesh[i][j][2] = z;
          }
        }
  
        float h = this.Mesh[0][0][2];
  
        h += HeightAboveGround;
  
        for (int i = 0; i < this.num_rows; i++) {
          for (int j = 0; j < this.num_columns; j++) {
  
            this.Mesh[i][j][2] -= h;
          }
        }
        
        /*
        // this is to modify the surronding ponits and set them at the same elevation of the the central point 
        for (int j = 0; j < 2; j++) {
          if (j < this.num_columns) {
            for (int i = 0; i < this.num_rows; i++) {
              this.Mesh[i][j][2] = this.Mesh[0][0][2];
            }
          }
        }
        */
        
      }
    }
    catch (Exception e) {
      println("Warning: problem in loading topography from file.");
      
      using_default_mesh = true;
    }
    
    if (using_default_mesh) {
      println("Using default flat mesh:");
      
      this.flat_mesh();
    }    
  
  
    this.update_textures();
  }
  
  
  
  void flat_mesh () {
  
    this.Mesh = new float [this.num_rows][this.num_columns][3];
  
    for (int i = 0; i < this.num_rows; i++) {
      
     
      for (int j = 0; j < this.num_columns; j++) {
  
       
        double[] LON_LAT = getLandGrid(i,j);
        
        double _lon = LON_LAT[0];
        double _lat = LON_LAT[1]; 
  
        float[] XY = funcs.convert_lonlat2XY(STATION.getLongitude(), STATION.getLatitude(), _lon, _lat);
  
        this.Mesh[i][j][0] = XY[0];      
        this.Mesh[i][j][1] = XY[1];      
        this.Mesh[i][j][2] = 0; 
  
      }
  
    }
  
    this.loadMesh = true;
  }
  
  
  
  void download_mesh () {
  
    this.Mesh = new float [this.num_rows][this.num_columns][3];
  
    for (int i = 0; i < this.num_rows; i++) {
      
      String the_target = Folder_Land + "/" + nf(i, 0) + ".xml";
      
      File dir = new File(the_target);
      if (!dir.isFile()) {
  
        String the_link = "";
        
        for (int j = 0; j < this.num_columns; j++) {
    
          if (the_link.equals("")) the_link = "https://maps.googleapis.com/maps/api/elevation/xml?locations=";
          else the_link += "%7C"; //"|";
          
          double[] LON_LAT = getLandGrid(i,j);
  
          String txt_latitude = nf((float) LON_LAT[1], 0, 5);
          String txt_longitude = nf((float) LON_LAT[0], 0, 5);            
    
          the_link += txt_latitude + "," + txt_longitude;
        }
    
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
  
    }
    
    this.loadMesh = true;
    this.update_mesh();
  
  }
  
  
  void download_textures () {
    
    float[] ratios = { 
      1128.497220,
      2256.994440,
      4513.988880,
      9027.977761,
      18055.95552,
      36111.91104,
      72223.82209,
      144447.6442,
      288895.2884,
      577790.5767,
      1155581.153,
      2311162.307,
      4622324.614,
      9244649.227,
      18489298.45,
      36978596.91,
      73957193.82,
      147914387.6,
      295828775.3,
      591657550.5
    };
    
    for (int i = 0; i <= 15; i++) {
  
      String the_target = Folder_Land + "/ELEV_" + nf(int(0.05 * ratios[i]), 7) + "_.jpg";
      
      File dir = new File(the_target);
      if (!dir.isFile()) {    
      
        String the_link = "https://maps.googleapis.com/maps/api/staticmap?center=" + nf(STATION.getLatitude(), 0, 5) + "," + nf(STATION.getLongitude(), 0, 5) + "&zoom=" + nf(20 - i, 0) + "&size=640x640&maptype=satellite&format=jpg";
       
        println("Try downloading: " + the_link);
    
        try {
          saveBytes(the_target, loadBytes(the_link));
        } 
        catch (Exception e) {
          println("LINK NOT AVAILABLE:", the_link);
        }
      }
    }
    
    this.loadTextures = true;
    this.update_textures();
  
  }
  
  
  
  
  void draw (int target_window) {
  
    boolean proceed = true;
  
    if ((this.displaySurface == false) || (this.loadMesh == false)) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {  
      proceed = true;
    }
    
    if (proceed) {
  
      int PAL_type = SHADE.get_PAL_type(); 
      int PAL_direction = SHADE.get_PAL_direction();
      float PAL_multiplier = SHADE.get_PAL_multiplier(); 
  
      if (User3D.export_MaterialLibrary) {
  
        for (int n_Map = 0; n_Map < this.Textures_num; n_Map++) {
  
          if (target_window == TypeWindow.RAD) {
  
            radOutput.println("void plastic " + "LandMap" + nf(n_Map, 0));
            radOutput.println("0");
            radOutput.println("0");
            radOutput.println("5 0 0 0 0 0");
            
          }
  
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t<Appearance DEF='LandMap" + nf(n_Map, 0) + "'>");
          }
          
          if (target_window == TypeWindow.OBJ) {
          
            mtlOutput.println("newmtl LandMap" + nf(n_Map, 0));
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
            mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
  
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
            
          }
  
  
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
  
            if (this.displayTexture) {
              if (n_Map != -1) {
    
                String old_Texture_path = this.Textures_ImagePath[n_Map]; 
    
                String the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
                String new_Texture_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
    
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
    
                if (target_window == TypeWindow.OBJ) {
                    
                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + the_filename); // diffuse map
                }
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                }                 
    
              }
            }
          }
          
          
          if (target_window == TypeWindow.HTML) {
            htmlOutput.println("\t\t\t\t</Appearance>");
          }        
          
        }
  
      }
      
      if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {
        
        current_Material = User3D.default_Material;
        current_Tessellation = User3D.default_Tessellation;
        current_Layer = User3D.default_Layer;
        current_Visibility = User3D.default_Visibility;
        current_Weight = User3D.default_Weight;
        current_Closed = User3D.default_Closed;            
        
        allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        
      }
  
  
      num_vertices_added = 0;
  
      int end_turn = 1;
      if (target_window == TypeWindow.OBJ) end_turn = 3;
      for (int _turn = 1; _turn <= end_turn; _turn++) {
  
  
        if (target_window == TypeWindow.OBJ) {
  
          if (_turn == 3) {
            
            if (this.displayTexture) {   
  
              obj_lastGroupNumber += 1;
              objOutput.println("g LandMap");
            
            }
          }
        }    
  
  
  
        int Tessellation = this.displayTessellation;
        if (WIN3D.FacesShade == SHADE.Surface_Base) {
          Tessellation = 0;
        }
  
        if ((target_window == TypeWindow.LandGap) || (target_window == TypeWindow.LandMesh)) {
          Tessellation = 0;
        }
  
        int TotalSubNo = 1;  
        if (Tessellation > 0) TotalSubNo = 4 * int(funcs.roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
  
        int i_start = this.Surface_SkipStart;
        int i_end = this.num_rows - 1 - this.Surface_SkipEnd;
  
        if (target_window == TypeWindow.LandGap) {
          i_start = 0;
          i_end = this.Surface_SkipStart;
          
          target_window = TypeWindow.LandMesh; // because the rest is simillar to that
        }
  
         
        for (int i = i_start; i < i_end; i++) {
          
          for (int j = 0; j < this.num_columns - 1; j++) {
  
            float[][] base_Vertices = new float [4][3];
  
            base_Vertices[0][0] = this.Mesh[i][j][0];
            base_Vertices[0][1] = this.Mesh[i][j][1];
            base_Vertices[0][2] = this.Mesh[i][j][2];
  
            base_Vertices[1][0] = this.Mesh[i+1][j][0];
            base_Vertices[1][1] = this.Mesh[i+1][j][1];
            base_Vertices[1][2] = this.Mesh[i+1][j][2];
  
            base_Vertices[2][0] = this.Mesh[i+1][j+1][0];
            base_Vertices[2][1] = this.Mesh[i+1][j+1][1];
            base_Vertices[2][2] = this.Mesh[i+1][j+1][2];
  
            base_Vertices[3][0] = this.Mesh[i][j+1][0];
            base_Vertices[3][1] = this.Mesh[i][j+1][1];
            base_Vertices[3][2] = this.Mesh[i][j+1][2];        
  
            for (int n = 0; n < TotalSubNo; n++) {
  
              float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
  
              int n_Map = -1; 
              if (this.displayTexture) { 
  
                for (int q = 0; q < this.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map
  
                  n_Map = q; 
  
                  for (int s = 0; s < subFace.length; s++) {
  
                    float u = (subFace[s][0] / this.Textures_U_scale[q] + 0.5);
                    float v = (-subFace[s][1] / this.Textures_V_scale[q] + 0.5);
  
                    //if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {
                    if ((0.05 > u) || (u > 0.95) || (0.05 > v) || (v > 0.95)) { // simply not to include the legends printed at the margin
  
                      n_Map = -1;
  
                      break;
                    }
                  }
  
                  if (n_Map == q) break;
                }
              }
              
              if (target_window == TypeWindow.SKY2D) {
                
                SKY2D_graphics.beginShape();
                SKY2D_graphics.fill(255);
                SKY2D_graphics.noStroke();
               
              }
  
              if (target_window == TypeWindow.WIN3D) {
  
                WIN3D.graphics.beginShape();
  
                WIN3D.graphics.strokeWeight(1);
                WIN3D.graphics.stroke(0, 0, 0);
                if (allFaces.displayEdges == false) WIN3D.graphics.noStroke();
                if (this.displayTexture) WIN3D.graphics.noStroke();
  
                if (this.displayTexture) {
                  if (n_Map != -1) {
                    WIN3D.graphics.texture(this.Textures_Map[n_Map]);
                  } else {
                    WIN3D.graphics.noFill();   
                    WIN3D.graphics.strokeWeight(1);
                    WIN3D.graphics.stroke(0, 0, 0);
                  }
                }
              }
  
              if (target_window == TypeWindow.OBJ) {
  
                if (_turn == 3) {
  
                  if (this.displayTexture) {
  
                    if (User3D.export_MaterialLibrary) {
                      if (n_Map != -1) {    
                        objOutput.println("usemtl LandMap" + nf(n_Map, 0));
                      }
                    }
                  }
                }
              }    
              
              if (target_window == TypeWindow.HTML) {
  
                htmlOutput.println("\t\t\t\t<shape>");
    
                if (n_Map != -1) {   
                  htmlOutput.println("\t\t\t\t\t<Appearance USE='LandMap" + nf(n_Map, 0) + "'></Appearance>");
                }      
                
                htmlOutput.print  ("\t\t\t\t\t<IndexedFaceSet solid='false'"); // force two-sided
                
                htmlOutput.print  (" coordIndex='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(" ");
                  }         
                  htmlOutput.print(nf(s, 0));          
                }
                htmlOutput.println(" -1'>");
                
                htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                for (int s = 0; s < subFace.length; s++) {
                  if (s > 0) {
                    htmlOutput.print(",");
                  }                  
                  
                  htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
                }                
                htmlOutput.println("'></Coordinate>");
                
              }
              
  
              
              
              
              for (int s = 0; s < subFace.length; s++) {
                
                if (target_window == TypeWindow.SKY2D) {
                  SKY2D_graphics.vertex(subFace[s][0], -subFace[s][1], subFace[s][2]);
                }           
  
                if (this.displayTexture == false) {
  
                  if (WIN3D.FacesShade != SHADE.Surface_Wire) {
  
                    float[] COL = {
                      255, 255, 255, 255
                    };
  
                    if (WIN3D.FacesShade == SHADE.Global_Solar) {
                      int s_next = (s + 1) % subFace.length;
                      int s_prev = (s + subFace.length - 1) % subFace.length;
  
                      COL = SHADE.vertexRender_Global_Solar(subFace[s], subFace[s_prev], subFace[s_next], PAL_type, PAL_direction, PAL_multiplier);
                    }
  
                    if (WIN3D.FacesShade == SHADE.Vertex_Solar) {
  
                      COL = SHADE.vertexRender_Vertex_Solar(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }  
                    
                    if (WIN3D.FacesShade == SHADE.Vertex_Solid) {
  
                      COL = SHADE.vertexRender_Vertex_Solid(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }      
        
                    if (WIN3D.FacesShade == SHADE.Vertex_Elevation) {
  
                      COL = SHADE.vertexRender_Vertex_Elevation(subFace[s], PAL_type, PAL_direction, PAL_multiplier);
                    }   
  
                    if (WIN3D.FacesShade == SHADE.Surface_White) {
                      COL = SHADE.vertexRender_Surface_White(255);
                    }                   
  
                    if (WIN3D.FacesShade == SHADE.Surface_Materials) {
                      //COL = SHADE.vertexRender_Surface_Materials(mt);
                      COL = SHADE.vertexRender_Surface_White(223);
                    }    
  
            
                     
  
                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
                    }
                  } else {
  
                    if (target_window == TypeWindow.WIN3D) {
                      WIN3D.graphics.noFill();
                    }
                  }
  
                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                  }
                  
                  if (target_window == TypeWindow.RAD) {
  
                    if (this.displayTexture) {   
                    
                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");      
                      
                      radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));                
                      radOutput.println(" " + nf(subFace[1][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[1][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));
                      
                      radOutput.println("LandMesh_0" + " polygon " + "LAND");
                      radOutput.println("0");
                      radOutput.println("0");
                      radOutput.println("9");      
                      
                      radOutput.println(" " + nf(subFace[2][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[2][2], 0, User3D.export_PrecisionVertex));                
                      radOutput.println(" " + nf(subFace[3][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[3][2], 0, User3D.export_PrecisionVertex));
                      radOutput.println(" " + nf(subFace[0][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[0][2], 0, User3D.export_PrecisionVertex));
  
                    }
                  }
                                  
  
                  
                } else {       
                  
                  float u = 0;
                  float v = 0;
                  if (n_Map != -1) {
                    u = (subFace[s][0] / this.Textures_U_scale[n_Map] + 0.5);
                    v = (-subFace[s][1] / this.Textures_V_scale[n_Map] + 0.5);
                  }
  
                  if (target_window == TypeWindow.WIN3D) {
                    if (n_Map != -1) {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                    }
                    else {
                      WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);                    
                    }
                  }
  
                  if (target_window == TypeWindow.OBJ) {
                    
                    if (this.displayTexture) {   
                    
                      if (_turn == 1) {
                        SOLARCHVISION_OBJprintVertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                      }
                      if (_turn == 2) { 
    
                        v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
    
                        SOLARCHVISION_OBJprintVtexture(u, v, 0);
                      }
                      if (_turn == 3) {
                        num_vertices_added += 1;
                      }
                    }
                  }
                  
                  if (target_window == TypeWindow.LandMesh) {
                    if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center
                      allModel3Ds.add_Vertex(subFace[s][0], subFace[s][1], subFace[s][2]);
                    }
                  }
                  
                  
                  if (target_window == TypeWindow.HTML) {
                    
                    if (n_Map != -1) {   
                    
                      if (s == 0) {
                        htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
                      }
                      if (s > 0) {
                        htmlOutput.print(",");
                      }                  
  
                      v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
                      SOLARCHVISION_HTMLprintVtexture(u, v);
                      
                      if (s == subFace.length - 1) {
                        htmlOutput.println("'></TextureCoordinate>");
                      }       
                    }              
     
                  }                
               
                }
              }
  
  
              if (target_window == TypeWindow.HTML) {
  
                htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                
                htmlOutput.println("\t\t\t\t</shape>");
  
              }
              
  
              if (target_window == TypeWindow.SKY2D) {
                SKY2D_graphics.endShape(CLOSE);
              }
  
              if (target_window == TypeWindow.WIN3D) {
                WIN3D.graphics.endShape(CLOSE);
              }
  
              if (target_window == TypeWindow.OBJ) {
  
                if (_turn == 3) {
                  
                  if (this.displayTexture) {   
  
                    String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
                    String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
                    String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
    
                    String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
                    String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
                    String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
                    String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
    
                    obj_lastFaceNumber += 1;
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
                    if (User3D.export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }
                }
              }
              
              if (target_window == TypeWindow.LandMesh) {
                if (i != 0) { // This is to avoid creation of surfaces with duplicate points at the center 
                  int[] newFace = new int[4];
                  newFace[0] = allPoints.getLength() - 4;
                  newFace[1] = allPoints.getLength() - 3;
                  newFace[2] = allPoints.getLength() - 2;
                  newFace[3] = allPoints.getLength() - 1;
                  allModel3Ds.add_Face(newFace);
                }
              }
              
  
  
              if (this.displayTexture) {
  
                if (this.displayDepth) {
  
  
                  if (target_window == TypeWindow.WIN3D) {
                    WIN3D.graphics.fill(223, 223, 223);
                    WIN3D.graphics.noStroke();
                  }
  
                  for (int s = 0; s < subFace.length; s++) {
  
                    int s_next = (s + 1) % subFace.length;
                    
                    float u = 0;
                    float v = 0;
                    if (n_Map != -1) {
                      u = (subFace[s][0] / this.Textures_U_scale[n_Map] + 0.5);
                      v = (-subFace[s][1] / this.Textures_V_scale[n_Map] + 0.5);
                    }
  
                    float u_next = (subFace[s_next][0] / this.Textures_U_scale[n_Map] + 0.5);
                    float v_next = (-subFace[s_next][1] / this.Textures_V_scale[n_Map] + 0.5);
  
                    if (target_window == TypeWindow.WIN3D) {
  
                      WIN3D.graphics.beginShape();
                      
                      if (n_Map != -1) {
                        WIN3D.graphics.texture(this.Textures_Map[n_Map]);                  
    
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_Map[n_Map].width, v_next * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u_next * this.Textures_Map[n_Map].width, v_next * this.Textures_Map[n_Map].height);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale, u * this.Textures_Map[n_Map].width, v * this.Textures_Map[n_Map].height);
                      }
                      else {
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, subFace[s][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, subFace[s_next][2] * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s_next][0] * OBJECTS_scale * WIN3D.scale, -subFace[s_next][1] * OBJECTS_scale * WIN3D.scale, (subFace[s_next][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                        WIN3D.graphics.vertex(subFace[s][0] * OBJECTS_scale * WIN3D.scale, -subFace[s][1] * OBJECTS_scale * WIN3D.scale, (subFace[s][2] - CrustDepth) * OBJECTS_scale * WIN3D.scale);
                      }
  
                      WIN3D.graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }
          }
          
          
          
          if (target_window == TypeWindow.LandMesh) {
            // This is to create a polygon around the center
            if (i == 0) {
              
              int[] newFace = new int[this.num_columns - 1];
              for (int j = 0; j < newFace.length; j++) {
                newFace[j] = allModel3Ds.add_Vertex(this.Mesh[i + 1][j][0], this.Mesh[i + 1][j][1], this.Mesh[i + 1][j][2]);
              }
              allModel3Ds.add_Face(newFace);
            }
          }
        }
      }
  
      if (target_window == TypeWindow.OBJ) {
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }    
  
      if (target_window == TypeWindow.WIN3D) {
        if (this.displayPoints) {
  
          WIN3D.graphics.fill(191, 191, 0); 
          WIN3D.graphics.noStroke();
  
          WIN3D.graphics.sphereDetail(6, 4);
  
          for (int i = 0; i < this.num_rows; i++) {
            for (int j = 0; j < this.num_columns; j++) {
  
              float x = this.Mesh[i][j][0];
              float y = this.Mesh[i][j][1];
              float z = this.Mesh[i][j][2];
  
              float R = 2.0 * OBJECTS_scale; // <<<<<<<<<<
  
              WIN3D.graphics.pushMatrix();
              WIN3D.graphics.translate(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
              WIN3D.graphics.sphere(R);
              WIN3D.graphics.popMatrix();
            }
          }
        }
      }
      
      if (target_window == TypeWindow.LandMesh) {
        userSelections.Group_ids = new int [1];
        userSelections.Group_ids[0] = allGroups.num - 1;
        
        allModel3Ds.weldObjectsVertices_Selection(0);
        
      }    
      
    }
  }
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP);
      
      parent.setInt("displayTessellation", this.displayTessellation);
      parent.setString("loadTextures", Boolean.toString(this.loadTextures));  
      parent.setString("loadMesh", Boolean.toString(this.loadMesh));
      parent.setString("displaySurface", Boolean.toString(this.displaySurface));
      parent.setString("displayPoints", Boolean.toString(this.displayPoints));
      parent.setString("displayTexture", Boolean.toString(this.displayTexture));
      parent.setString("displayDepth", Boolean.toString(this.displayDepth));
      parent.setInt("pallet_CLR", this.pallet_CLR);
      parent.setInt("pallet_DIR", this.pallet_DIR);
      parent.setFloat("pallet_MLT", this.pallet_MLT);
      parent.setInt("Surface_SkipStart", this.Surface_SkipStart);
      parent.setInt("Surface_SkipEnd", this.Surface_SkipEnd);
      parent.setInt("num_rows", this.num_rows);
      parent.setInt("num_columns", this.num_columns);
      

      int vNo = 0;
      for (int i = 0; i < this.Mesh.length; i++) {
        for (int j = 0; j < this.Mesh[i].length; j++) {
          XML child = parent.addChild("item");
          child.setInt("id", vNo);
          String lineSTR = "";
          //for (int k = 0; k < this.Mesh[i][j].length; k++) {
          for (int k = 0; k < 3; k++) { // x, y, z 
            lineSTR += nf(this.Mesh[i][j][k], 0, 4).replace(",", "."); // <<<<
            if (k < this.Mesh[i][j].length - 1) lineSTR += ",";
          }
          child.setContent(lineSTR);
          vNo += 1;
        }
      }  
    }    
    
    {
      boolean TEXTURE_copied = false;
  
      String the_dir = save_folder;
  
      for (int q = 0; q < this.Textures_num; q++) {
  
        int n_Map = q; 
  
        String the_filename = this.Textures_ImagePath[n_Map].substring(this.Textures_ImagePath[n_Map].lastIndexOf("/") + 1); // image name
  
        String new_Texture_path = the_dir + "/Textures/" +  the_filename;
  
        if (this.Textures_ImagePath[n_Map].toUpperCase().equals(new_Texture_path.toUpperCase())) {
          TEXTURE_copied = false;
        } else {
  
          println("Copying texture:", this.Textures_ImagePath[n_Map], ">", new_Texture_path);
          saveBytes(new_Texture_path, loadBytes(this.Textures_ImagePath[n_Map]));
          this.Textures_ImagePath[n_Map] = new_Texture_path;
  
          TEXTURE_copied = true;
        }
  
        //if (TEXTURE_copied == false) {
        //  println("Saving texture from the scene.");
        //  this.Textures_Map[n_Map].save(new_Texture_path);
        //}
      }

      XML parent = xml.addChild(this.CLASS_STAMP + ".Textures");
      parent.setInt("ni", this.Textures_num); 
      
      for (int i = 0; i < this.Textures_num; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        child.setFloat("U_scale", this.Textures_U_scale[i]);
        child.setFloat("V_scale", this.Textures_U_scale[i]);
        child.setContent(this.Textures_ImagePath[i]);          
      }
    }  
  
  }
  
  



  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP);
      
      this.displayTessellation = parent.getInt("displayTessellation");
      this.loadTextures = Boolean.parseBoolean(parent.getString("loadTextures"));      
      this.loadMesh = Boolean.parseBoolean(parent.getString("loadMesh"));
      this.displaySurface = Boolean.parseBoolean(parent.getString("displaySurface"));
      this.displayPoints = Boolean.parseBoolean(parent.getString("displayPoints"));
      this.displayTexture = Boolean.parseBoolean(parent.getString("displayTexture"));
      this.displayDepth = Boolean.parseBoolean(parent.getString("displayDepth"));
      this.pallet_CLR = parent.getInt("pallet_CLR");
      this.pallet_DIR = parent.getInt("pallet_DIR");
      this.pallet_MLT = parent.getFloat("pallet_MLT");  
      this.Surface_SkipStart = parent.getInt("Surface_SkipStart");
      this.Surface_SkipEnd = parent.getInt("Surface_SkipEnd");
      this.num_rows = parent.getInt("num_rows");
      this.num_columns = parent.getInt("num_columns");


      this.Mesh = new float [this.num_rows][this.num_columns][3];

      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < this.num_rows * this.num_columns; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < parts.length; j++) {
          this.Mesh[(i / this.num_columns)][(i % this.num_columns)][j] = float(parts[j]);
        }
      }
    }    
        
    {
      
      XML parent = xml.getChild(this.CLASS_STAMP + ".Textures");
      
      int pre_Land3D_Textures_num = this.Textures_num;
      this.Textures_num = parent.getInt("ni");
  
      if (pre_Land3D_Textures_num != this.Textures_num) {
        int ni = this.Textures_num;
        this.Textures_ImagePath = new String [ni];
        this.Textures_Map = new PImage [ni];
        for (int i = 0; i < this.Textures_num; i++) {
          this.Textures_ImagePath[i] = "";
          this.Textures_Map[i] = createImage(2, 2, RGB); // empty and small
        }
      }

      XML[] children = parent.getChildren("item");       
      for (int i = 0; i < this.Textures_num; i++) {
        
        this.Textures_U_scale[i] = children[i].getFloat("U_scale");
        this.Textures_V_scale[i] = children[i].getFloat("V_scale");
  
        String new_Texture_path = children[i].getContent();
  
        if (this.Textures_ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
        } else {
  
          this.Textures_ImagePath[i] = new_Texture_path;
  
          if (this.Textures_ImagePath[i].equals("")) {
          } else {
            println("Loading texture:", this.Textures_ImagePath[i]);
            this.Textures_Map[i] = loadImage(this.Textures_ImagePath[i]);
          }
        }
      }
    }
    
        
  }    
  
  
}


solarchvision_Land3D Land3D = new solarchvision_Land3D();





class solarchvision_Model2Ds {
  
  private final static String CLASS_STAMP = "Model2Ds";

  boolean displayAll = true;

  float[][] XYZS = new float[0][4];
  
  float getX (int n) {
    return this.XYZS[n][0]; 
  }

  float getY (int n) {
    return this.XYZS[n][1]; 
  }

  float getZ (int n) {
    return this.XYZS[n][2]; 
  }

  float getS (int n) {
    return this.XYZS[n][3]; 
  }

  void setX (int n, float x) {
    this.XYZS[n][0] = x;  
  }

  void setY (int n, float y) {
    this.XYZS[n][1] = y;  
  }

  void setZ (int n, float z) {
    this.XYZS[n][2] = z;  
  }
  
  void setS (int n, float s) {
    this.XYZS[n][3] = s;  
  }  

  void addX (int n, float dx) {
    this.XYZS[n][0] += dx;  
  }

  void addY (int n, float dy) {
    this.XYZS[n][1] += dy;  
  }

  void addZ (int n, float dz) {
    this.XYZS[n][2] += dz;  
  }
  
  void magS (int n, float ds) {
    this.XYZS[n][3] *= ds;  
  }
  
  int[] MAP = new int[0];
  int num = 0; 
  
  String[] ImagePath;
  int num_files_PEOPLE = 0;
  int num_files_TREES = 0; 

  int num_visualFaces = 3; // internal - number of faces: Vertical, Horizontal Front, Horizontal Back
 
  String[] Filenames_PEOPLE;
  String[] Filenames_TREES; 
 
  PImage[] Images;
  float[] ImageRatios;
  
  float[][] Vertices;
  int[][] Faces;  
  
  void load_images () {
  
    this.ImagePath = new String [1];
    this.ImagePath[0] = "";
  
    this.Filenames_PEOPLE = sort(OPESYS.getFiles(Folder_People));
    this.Filenames_TREES = sort(OPESYS.getFiles(Folder_Trees));  
  
    this.ImagePath = concat(this.ImagePath, this.Filenames_PEOPLE);
    this.ImagePath = concat(this.ImagePath, this.Filenames_TREES);
  
    this.num_files_PEOPLE = this.Filenames_PEOPLE.length;
    this.num_files_TREES = this.Filenames_TREES.length;
  
  
    int n = this.ImagePath.length;
  
    this.Images = new PImage [n + 1];
    this.ImageRatios = new float [n + 1];
  
    for (int i = 1; i < n; i++) { // leaving [0] null  
  
      if (i <= this.num_files_PEOPLE) {
        this.ImagePath[i] = Folder_People + "/" + this.ImagePath[i];
      } else {
        this.ImagePath[i] = Folder_Trees + "/" + this.ImagePath[i];
      }
    }
  
    for (int i = 1; i < n; i++) {
      //println(this.ImagePath[i]);
      this.Images[i] = loadImage(this.ImagePath[i]);
  
      if (this.Images[i].height != 0) {
        this.ImageRatios[i] = float(this.Images[i].width) / float(this.Images[i].height);
      } else {
        this.ImageRatios[i] = 1;
      }
    }
  } 
  
  
  void draw (int target_window) {
  
    this.Faces = new int [this.num * this.num_visualFaces][4];
  
    this.Vertices = new float [4 * this.num * this.num_visualFaces][5]; // note we are keeping u & v at 3rd and 4th members
    
    
    boolean proceed = true;
  
    if (this.displayAll == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if (proceed) {  
  
      if (User3D.export_MaterialLibrary) {
      
        if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {  
    
          int[] ImageUsed = new int [this.ImagePath.length];
    
          for (int i = 0; i < ImageUsed.length; i++) {
            ImageUsed[i] = 0;
          }
    
          for (int f = 0; f < this.num; f++) {
    
            int n = abs(this.MAP[f]);
    
            ImageUsed[n] += 1;
          }
    
          for (int i = 1; i < this.ImagePath.length; i++) {
    
            if (ImageUsed[i] != 0) {
    
              String old_Texture_path = this.ImagePath[i];
    
              String new_Texture_path = "";
    
              String opacity_Texture_path = "";
    
              String the_filename = "";
    
              if (this.ImagePath[i].equals("")) {
              } else {
    
                the_filename = old_Texture_path.substring(old_Texture_path.lastIndexOf("/") + 1); // image name
    
                new_Texture_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
                opacity_Texture_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + "opacity_" + the_filename;
    
                println("Copying texture:", old_Texture_path, ">", new_Texture_path);
                saveBytes(new_Texture_path, loadBytes(old_Texture_path));
    
                println("Making opacity texture:", new_Texture_path);
    
                int RES1 = this.Images[i].width;
                int RES2 = this.Images[i].height;
    
                PImage Opacity_Texture = createImage(RES1, RES2, ARGB);
    
                Opacity_Texture.loadPixels();
    
                for (int np = 0; np < (RES1 * RES2); np++) {
                  int Image_X = np % RES1;
                  int Image_Y = np / RES1;
    
                  color COL = this.Images[i].get(Image_X, Image_Y);
                  //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
    
                  float COL_V = (COL >> 24 & 0xFF);
    
                  Opacity_Texture.pixels[np] = color(COL_V, COL_V, COL_V, COL_V);
                }
    
                Opacity_Texture.updatePixels();
    
                Opacity_Texture.save(opacity_Texture_path);
                
                if (target_window == TypeWindow.HTML) {
                  htmlOutput.println("\t\t\t\t<Appearance DEF='this." + the_filename + "'>");
                  htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                  htmlOutput.println("\t\t\t\t</Appearance>");
                }
    
                if (target_window == TypeWindow.OBJ) { 
      
                  mtlOutput.println("newmtl " + CLASS_STAMP + the_filename);
                  mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                  mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                  mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                  mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                  mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                  mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
                  mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                  mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                  mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      
                  //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                  mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map        
                  mtlOutput.println("\tmap_d " + Subfolder_exportMaps + "opacity_" + the_filename); // diffuse map
                }
              }
            }
          }
        }    
      }
      
      
      
      
  
      float[] DistZ = new float [this.num];
  
      for (int f = 0; f < this.num; f++) {
        float x = this.XYZS[f][0] * OBJECTS_scale;
        float y = this.XYZS[f][1] * OBJECTS_scale;
        float z = this.XYZS[f][2] * OBJECTS_scale;
  
        DistZ[f] = dist(x, y, z, WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z);
      }
  
      for (int g = 0; g < this.num; g++) {
  
        int f = -1;
        float max_dist = -1;
  
        for (int q = 0; q < this.num; q++) {
          if (max_dist < DistZ[q]) {
            max_dist = DistZ[q];
            f = q;
          }
        }
  
        DistZ[f] = -1;
  
  
  
        if (f != -1) {
          
          int n = abs(this.MAP[f]);
  
          int w = this.Images[n].width; 
          int h = this.Images[n].height;
  
          float x = this.XYZS[f][0] * OBJECTS_scale;
          float y = this.XYZS[f][1] * OBJECTS_scale;
          float z = this.XYZS[f][2] * OBJECTS_scale;
  
          float rh = this.XYZS[f][3] * 0.5 * OBJECTS_scale;
          float rw = rh * this.ImageRatios[n];
  
          float t = PI + WIN3D.rotation_Z * PI / 180.0;
          if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI;
         
          if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
            t = 0;
          }     
  
          if (this.MAP[f] < 0) t += PI;     
      
  
          float dx = rw * cos(t);
          float dy = rw * sin(t);
          
          float x1 = x - dx;
          float y1 = y - dy;
  
          float x2 = x + dx;
          float y2 = y + dy;
  
          if (target_window == TypeWindow.OBJ) { 
  
            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;  
              objOutput.println("g this." + nf(f, 0) + "_type" + nf(n, 0));
            }
      
            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1).replace('.', '_'));
            }
          }
    
          num_vertices_added = 0;
    
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
            
            for (int back_front = -1; back_front <= 1; back_front++) {
              
              if (back_front == 0) {
                
                if (target_window == TypeWindow.WIN3D) { 
    
                  WIN3D.graphics.beginShape();
          
                  WIN3D.graphics.texture(this.Images[n]);    
                  WIN3D.graphics.stroke(255, 255, 255, 0);
                  WIN3D.graphics.fill(255, 255, 255, 0);        
          
                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, z * WIN3D.scale, 0, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, z * WIN3D.scale, w, h);
                  WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, w, 0);
                  WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh) * WIN3D.scale, 0, 0);
          
                  WIN3D.graphics.endShape(CLOSE);        
                }
                
                if (target_window == TypeWindow.OBJ) { 
                  if (_turn == 1) {
    
                    SOLARCHVISION_OBJprintVertex(x1, y1, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, z);
                    SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh));
                    SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh));
        
                    num_vertices_added += 4;
                  }              
                  
                  if (_turn == 2) {
                    htmlOutput.println("\t\t\t\t\t\t<TextureCoordinate point='1 0,0 0,0 1,1 1'></TextureCoordinate>");
                  }     
                  
                  if (_turn == 3) {
                    obj_lastVertexNumber += num_vertices_added;
                    obj_lastVtextureNumber += num_vertices_added;
        
                    String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 1, 0); 
                    String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 2, 0);
                    String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 3, 0);
                    String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4, 0);
        
                    String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 1, 0); 
                    String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 2, 0);
                    String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 3, 0);
                    String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4, 0);      
        
                    if (User3D.export_PolyToPoly == 0) {
                      obj_lastGroupNumber += 1;
                      objOutput.println("g this." + nf(f, 0) + "_ver");
                    } 
        
                    obj_lastFaceNumber += 1;            
                    objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                    if (User3D.export_BackSides) {
                      obj_lastFaceNumber += 1;
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                    }
                  }         
                }   
            
            
                if (target_window == TypeWindow.HTML) {
                  
                  htmlOutput.println("\t\t\t\t<shape>");
        
                  htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");
        
                  htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
                  
                  htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                  htmlOutput.print  (      nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf(z, 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf(z, 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, User3D.export_PrecisionVertex));
                  htmlOutput.print  ("," + nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh), 0, User3D.export_PrecisionVertex));
                  htmlOutput.println("'></Coordinate>");          
                  
                  htmlOutput.println("\t\t\t\t\t\t<TextureCoordinate point='1 0,0 0,0 1,1 1'></TextureCoordinate>");
          
                  htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                 
                  htmlOutput.println("\t\t\t\t</shape>");          
                }              
    
                int nv = f * this.num_visualFaces * 4;
                int nf = f * this.num_visualFaces;
                
                this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 0][3] = 0;
                this.Vertices[nv + 0][4] = 1;
      
                this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                this.Vertices[nv + 1][3] = 1;
                this.Vertices[nv + 1][4] = 1;
      
                this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 2][3] = 1;
                this.Vertices[nv + 2][4] = 0;
      
                this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                this.Vertices[nv + 3][3] = 0;
                this.Vertices[nv + 3][4] = 0;
      
                this.Faces[nf][0] = nv + 0;
                this.Faces[nf][1] = nv + 1;
                this.Faces[nf][2] = nv + 2;
                this.Faces[nf][3] = nv + 3;
              }     
              else {
                
                int nv = f * this.num_visualFaces * 4;
                int nf = f * this.num_visualFaces;  
                
                if (back_front == -1) {
                  nv += 4;
                  nf += 1;
                }
                else {
                  nv += 8;
                  nf += 2;
                }            
                
                if (n > this.num_files_PEOPLE) { // case: trees   
    
                  float ratio = 0.5;
                  
                  float rot = back_front * PI / 2 + t;
      
                  dx = rw * cos(rot);
                  dy = rw * sin(rot);
                  
                  float x3 = x2 + dx;
                  float y3 = y2 + dy;
      
                  float x4 = x1 + dx;
                  float y4 = y1 + dy;
                  
                  if (target_window == TypeWindow.WIN3D) {
      
                    WIN3D.graphics.beginShape();
        
                    WIN3D.graphics.texture(this.Images[n]);    
                    WIN3D.graphics.stroke(255, 255, 255, 0);
                    WIN3D.graphics.fill(255, 255, 255, 0);
        
                    WIN3D.graphics.vertex(x1 * WIN3D.scale, -y1 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, h * ratio);
                    WIN3D.graphics.vertex(x2 * WIN3D.scale, -y2 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, h * ratio);
                    WIN3D.graphics.vertex(x3 * WIN3D.scale, -y3 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, w, 0);
                    WIN3D.graphics.vertex(x4 * WIN3D.scale, -y4 * WIN3D.scale, (z + 2 * rh * ratio) * WIN3D.scale, 0, 0);
        
                    WIN3D.graphics.endShape(CLOSE);
                  }
                  
                  if (target_window == TypeWindow.OBJ) {
                    if (_turn == 1) {
        
                      SOLARCHVISION_OBJprintVertex(x1, y1, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x2, y2, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x3, y3, (z + 2 * rh * ratio));
                      SOLARCHVISION_OBJprintVertex(x4, y4, (z + 2 * rh * ratio));
        
                      num_vertices_added += 4;
                    }
        
                    if (_turn == 2) {
        
                      SOLARCHVISION_OBJprintVtexture(1, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1 - ratio, 0);
                      SOLARCHVISION_OBJprintVtexture(0, 1, 0);
                      SOLARCHVISION_OBJprintVtexture(1, 1, 0);
                    }
        
                    if (_turn == 3) {
        
                      int q = (back_front + 1) / 2;
        
                      String n1_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
                      String n2_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String n3_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String n4_txt = nf(obj_lastVertexNumber - num_vertices_added + 4 * (q + 1) + 4, 0);
        
                      String m1_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 1, 0); 
                      String m2_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 2, 0);
                      String m3_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 3, 0);
                      String m4_txt = nf(obj_lastVtextureNumber - num_vertices_added + 4 * (q + 1) + 4, 0);      
        
                      if (User3D.export_PolyToPoly == 0) {
                        obj_lastGroupNumber += 1;
                        objOutput.println("g this." + nf(f, 0) + "_hor" + nf(q, 0));
                      } 
        
                      obj_lastFaceNumber += 1;            
                      objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
                      if (User3D.export_BackSides) {
                        obj_lastFaceNumber += 1;
                        objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
                      }
                    }                    
                  }
                  
                  if (target_window == TypeWindow.HTML) {
                    
                    htmlOutput.println("\t\t\t\t<shape>");
          
                    htmlOutput.println("\t\t\t\t\t<Appearance USE='this." + this.ImagePath[n].substring(this.ImagePath[n].lastIndexOf("/") + 1) + "'></Appearance>");
          
                    htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
                    
                    htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
                    htmlOutput.print  (      nf(x1, 0, User3D.export_PrecisionVertex) + " " + nf(y1, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x2, 0, User3D.export_PrecisionVertex) + " " + nf(y2, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x3, 0, User3D.export_PrecisionVertex) + " " + nf(y3, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.print  ("," + nf(x4, 0, User3D.export_PrecisionVertex) + " " + nf(y4, 0, User3D.export_PrecisionVertex) + " " + nf((z + 2 * rh * ratio), 0, User3D.export_PrecisionVertex));
                    htmlOutput.println("'></Coordinate>");          
                    
                    htmlOutput.print ("\t\t\t\t\t\t<TextureCoordinate point='");
                    
                    SOLARCHVISION_HTMLprintVtexture(1, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1 - ratio);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(0, 1);
                    htmlOutput.print (",");
                    SOLARCHVISION_HTMLprintVtexture(1, 1);                  
                    htmlOutput.println("'></TextureCoordinate>");
            
                    htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
                   
                    htmlOutput.println("\t\t\t\t</shape>");          
                  }                              
    
                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = ratio;
              
                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = ratio;
              
                  this.Vertices[nv + 2][0] = x3 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y3 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;
                  
                  this.Vertices[nv + 3][0] = x4 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y4 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh * ratio) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;      
              
                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;
                }
                else { // case: people
                  this.Vertices[nv + 0][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 0][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 0][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 0][3] = 0;
                  this.Vertices[nv + 0][4] = 1;
        
                  this.Vertices[nv + 1][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 1][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 1][2] = (z) / OBJECTS_scale;
                  this.Vertices[nv + 1][3] = 1;
                  this.Vertices[nv + 1][4] = 1;
        
                  this.Vertices[nv + 2][0] = x2 / OBJECTS_scale;
                  this.Vertices[nv + 2][1] = y2 / OBJECTS_scale;
                  this.Vertices[nv + 2][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 2][3] = 1;
                  this.Vertices[nv + 2][4] = 0;
        
                  this.Vertices[nv + 3][0] = x1 / OBJECTS_scale;
                  this.Vertices[nv + 3][1] = y1 / OBJECTS_scale;
                  this.Vertices[nv + 3][2] = (z + 2 * rh) / OBJECTS_scale;
                  this.Vertices[nv + 3][3] = 0;
                  this.Vertices[nv + 3][4] = 0;
        
                  this.Faces[nf][0] = nv + 0;
                  this.Faces[nf][1] = nv + 1;
                  this.Faces[nf][2] = nv + 2;
                  this.Faces[nf][3] = nv + 3;              
                }
              }
            }
          }
        }
      }
    }
  }
  
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][6];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
      hitPoint[f][4] = FLOAT_undefined;
      hitPoint[f][5] = FLOAT_undefined;    
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
      
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      //boolean InPoly = false;
      float[] UV = {FLOAT_undefined, FLOAT_undefined};
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);
      
      float[] face_norm = funcs.vec3_cross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          UV = funcs.uvInside_Rectangle(P, A, B, C);
        }
      }
      
      float u = UV[0];
      float v = UV[1];
      
      if ((u >= 0) && (v >= 0) && (u <= 1) && (v <= 1)) {
    
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
        // converting rom face UV to image UV
        hitPoint[f][4] = (1 - u) * B[3] + u * A[3];
        hitPoint[f][5] = (1 - v) * B[4] + v * C[4];
  
      }
    }
  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
      
      int OBJ_NUM = f / this.num_visualFaces;
  
      if (pre_dist > hitPoint[f][3]) {
        
        float u = hitPoint[f][4];
        float v = hitPoint[f][5];
  
        int n = abs(this.MAP[OBJ_NUM]);
       
        int RES1 = this.Images[n].width; 
        int RES2 = this.Images[n].height;    
     
        this.Images[n].loadPixels();
        
        if (n < 0) u = 1 - u;
        
        println("uv,n", u, v, n);
        
        int Image_X = int(u * RES1); 
        int Image_Y = int(v * RES2);
    
        color COL = this.Images[n].get(Image_X, Image_Y);
        //alpha: COL >> 24 & 0xFF; red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
    
        float COL_V = (COL >> 24 & 0xFF);
        
        if (COL_V > 0) {
  
          pre_dist = hitPoint[f][3];
    
          return_point[0] = OBJ_NUM;
          return_point[1] = hitPoint[f][0];
          return_point[2] = hitPoint[f][1];
          return_point[3] = hitPoint[f][2];
          return_point[4] = hitPoint[f][3];
        }
      }
  
    }
  
    return return_point;
  }

  void add_onLand (int people_or_trees) {

    println(CLASS_STAMP + ".add_onLand");
  
    randomSeed(0);
  
    float[][] treesXYZS = {
      {
        0, 0, 0, 0
      }
    };
  
    int Tessellation = Land3D.displayTessellation;
    if (WIN3D.FacesShade == SHADE.Surface_Base) {
      Tessellation = 0;
    }
  
    int TotalSubNo = 1;  
    if (Tessellation > 0) TotalSubNo = 4 * int(funcs.roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
  
  
  
    if ((Land3D.displayTexture) && (people_or_trees != 1)) { // using another algorithm for people << i.e. no image processing from green colors of the map!
  
      for (int i = Land3D.Surface_SkipStart; i < Land3D.num_rows - 1 - Land3D.Surface_SkipEnd; i++) {
        for (int j = 0; j < Land3D.num_columns - 1; j++) {
  
          float[][] base_Vertices = new float [4][3];
  
          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];
  
          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];
  
          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];
  
          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];
  
          for (int n = 0; n < TotalSubNo; n++) {
  
            float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
  
            int n_Map = -1; 
            for (int q = 0; q < Land3D.Textures_num; q++) { // increase the resolution until all the vertices located inside the appropriate map
  
              n_Map = q; 
  
              for (int s = 0; s < subFace.length; s++) {
  
                float u = (subFace[s][0] / Land3D.Textures_U_scale[q] + 0.5);
                float v = (-subFace[s][1] / Land3D.Textures_V_scale[q] + 0.5);
  
                if ((0 > u) || (u > 1) || (0 > v) || (v > 1)) {
  
                  n_Map = -1;
  
                  break;
                }
              }            
  
              if (n_Map == q) break;
            }
  
            if (n_Map != -1) {
  
              int max_o = int(10000 / pow(2, Land3D.displayTessellation)); // number of tries to find green points!
  
              //if (max_o > 100) max_o = 100;
  
              if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
              //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
              //if (i < 4) max_o = 0; // <<<<<<< do not create at near distances <<<<<<<<<<<<<<<
  
              for (int o = 0; o < max_o; o++) {
  
                float di = random(1);
                float dj = random(1);
  
                float x = funcs.bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
                float y = funcs.bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
                float z = funcs.bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);
  
                float u = (x / Land3D.Textures_U_scale[n_Map] + 0.5);
                float v = (-y / Land3D.Textures_V_scale[n_Map] + 0.5);
  
                int uPixel = int(u * Land3D.Textures_Map[n_Map].width);
                int vPixel = int(v * Land3D.Textures_Map[n_Map].height);
  
                color COL = Land3D.Textures_Map[n_Map].get(uPixel, vPixel);
                //red: COL >> 16 & 0xFF; green: COL >>8 & 0xFF; blue: COL & 0xFF;
                float r = COL >> 16 & 0xFF; 
                float g = COL >> 8 & 0xFF;
                float b = COL & 0xFF;
  
                //if ((g > r + 8) && (g > b + 16)) { // looks more green
                if ((g > r - 4) && (g > b + 16)) { // looks more green, slightly red is acceptible
  
                  if (g < 56) { // not on grass (light green) 
  
                    //if (z + STATION.getElevation() > 5) { // not in water (below see level)
  
                    //float s = 5 + random(10); 
                    float s = 5 + random(12.5);
                    //float s = 10 + random(20); // bigger trees        
  
                    int foundNearTree = 0;
  
                    for (int f = 1; f < treesXYZS.length; f++) {
  
                      float x0 = treesXYZS[f][0];
                      float y0 = treesXYZS[f][1];
                      float z0 = treesXYZS[f][2];
                      float s0 = treesXYZS[f][3];
  
                      //if (dist(x0, y0, z0, x, y, z) < 0.25 * (s0 + s)) { //avoids creating trees close to each other 
                      if (dist(x0, y0, z0, x, y, z) < 0.5 * (s0 + s)) { //avoids creating trees close to each other
                        foundNearTree = 1;
  
                        break;
                      }
                    }
  
                    if (foundNearTree == 0) {
  
                      if (people_or_trees == 2) {
                        this.add_single("TREES", 0, x, y, z, s);
                      } else {
                        allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, s, random(360), User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                      }                  
  
  
                      float[][] newTree = {
                        {
                          x, y, z, s
                        }
                      };
                      treesXYZS = (float [][]) concat(treesXYZS, newTree);
                    }
                    //}
                  }
                }
              }
            }
          }
        }
      }
    } else {
  
      for (int i = Land3D.Surface_SkipStart; i < Land3D.num_rows - 1 - Land3D.Surface_SkipEnd; i++) {
        for (int j = 0; j < Land3D.num_columns - 1; j++) {
  
          float[][] base_Vertices = new float [4][3];
  
          base_Vertices[0][0] = Land3D.Mesh[i][j][0];
          base_Vertices[0][1] = Land3D.Mesh[i][j][1];
          base_Vertices[0][2] = Land3D.Mesh[i][j][2];
  
          base_Vertices[1][0] = Land3D.Mesh[i+1][j][0];
          base_Vertices[1][1] = Land3D.Mesh[i+1][j][1];
          base_Vertices[1][2] = Land3D.Mesh[i+1][j][2];
  
          base_Vertices[2][0] = Land3D.Mesh[i+1][j+1][0];
          base_Vertices[2][1] = Land3D.Mesh[i+1][j+1][1];
          base_Vertices[2][2] = Land3D.Mesh[i+1][j+1][2];
  
          base_Vertices[3][0] = Land3D.Mesh[i][j+1][0];
          base_Vertices[3][1] = Land3D.Mesh[i][j+1][1];
          base_Vertices[3][2] = Land3D.Mesh[i][j+1][2];      
  
          for (int n = 0; n < TotalSubNo; n++) {
  
            float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
  
            int max_o = int((16.0 / pow(2, Land3D.displayTessellation)) * pow(random(1), 8)); // i.e. maximum 3 people in each pixel for tes=2
  
  
            if (i > 6) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
            //if (i > 14) max_o = 0; // <<<<<<< do not create at far distances <<<<<<<<<<<<<<<
  
            for (int o = 0; o < max_o; o++) {
  
              float di = random(1);
              float dj = random(1);
  
              float x = funcs.bilinear(subFace[0][0], subFace[1][0], subFace[2][0], subFace[3][0], di, dj);
              float y = funcs.bilinear(subFace[0][1], subFace[1][1], subFace[2][1], subFace[3][1], di, dj);
              float z = funcs.bilinear(subFace[0][2], subFace[1][2], subFace[2][2], subFace[3][2], di, dj);
  
              if (z + STATION.getElevation() > 0) { // i.e. above sea level 
  
                if (dist(x, y, 0, 0) > 10.0) { // i.e. No 2D at the center!
  
                  if (people_or_trees == 1) {
                    this.add_single("PEOPLE", 0, x, y, z, 2.5);
                  } else if (people_or_trees == 2) {
                    this.add_single("TREES", 0, x, y, z, 5 + random(10));
                  } else {
                    allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, 5 + random(10), random(360), User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  void add_polar (int people_or_trees, int n, float x0, float y0, float z0, float r1, float r2) {
  
    for (int i = 0; i < n; i++) {
  
      float a = random(360);
      float b = pow(random(pow(r1, 2), pow(r2, 2)), 0.5); // to make it uniform on the surface
  
      float x = x0 + b * funcs.cos_ang(a);
      float y = y0 + b * funcs.sin_ang(a);
      float z = z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, 5 + random(10), random(360), User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }
  }
  
  void add_plane (int people_or_trees, int n, float x0, float y0, float z0, float rx, float ry, float rot) {
  
    for (int i = 0; i < n; i++) {
  
      //float a = random(-rx, rx); 
      //float b = random(-ry, ry);
  
      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);  
      float b = random(1-ry, ry-1);
  
      float x = a * funcs.cos_ang(rot) - b * funcs.sin_ang(rot);
      float y = a * funcs.sin_ang(rot) + b * funcs.cos_ang(rot);
      float z = 0;
  
      x += x0;
      y += y0;
      z += z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, 5 + random(10), random(360), User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }
  }
  
  void add_Mesh2 (int people_or_trees, int n, float x1, float y1, float z1, float x2, float y2, float z2) {
  
    float x0 = 0.5 * (x1 + x2);
    float y0 = 0.5 * (y1 + y2);
    float z0 = 0.5 * (z1 + z2);
  
    float rx = 0.5 * abs(x2 - x1);
    float ry = 0.5 * abs(y2 - y1);
  
    for (int i = 0; i < n; i++) {
  
      //float a = random(-rx, rx); 
      //float b = random(-ry, ry);
  
      // 1 meter offset from the edge! <<<<<<<<<<<<<<<<<<<
      float a = random(1-rx, rx-1);  
      float b = random(1-ry, ry-1);
  
      float x = x0 + a;
      float y = y0 + b;
      float z = z0;
  
      if (people_or_trees == 1) {
        this.add_single("PEOPLE", 0, x, y, z, 2.5);
      } else if (people_or_trees == 2) {
        this.add_single("TREES", 0, x, y, z, 5 + random(10));
      } else {
        allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, 5 + random(10), random(360), User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
      }
    }
  }  
  
  void add_single (String t, int m, float x, float y, float z, float s) {
  
    int n1 = this.num_files_PEOPLE;    
    int n2 = this.num_files_PEOPLE + this.num_files_TREES;
  
    int n = m;
  
    if (n == 0) {
      if (t.equals("PEOPLE")) n = int(random(1, 1 + n1));
      else if (t.equals("TREES")) n = int(random(1 + n1, 1 + n2));
    }
  
    int d = 1; 
    int r = int(random(2));
    if (r == 0) d = -1; 
  
    int[] Temp_MAP = {
      d * n
    }; 
    this.MAP = concat(this.MAP, Temp_MAP);
  
    float[][] Temp_XYZS = {
      {
        x, y, z, s
      }
    };
    this.XYZS = (float[][]) concat(this.XYZS, Temp_XYZS);
  
    this.num += 1;
  
    if (abs(n) > n1) {
  
      if (User3D.create_MeshOrSolid != 0) {
  
        float x0 = x;
        float y0 = y;
        float z0 = 0.5 * s + z;
        float r0 = 0.4 * s; // <<<<<<< approximate
  
        allModel3Ds.add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, User3D.create_MeshOrSolid);
      }
    }
  
    if (allGroups.num > 0) allGroups.Model2Ds[allGroups.num - 1][1] = this.num - 1;
  }  
  
  void delete () {
  
    this.XYZS = new float [0][4]; 
  
    this.MAP = new int [0];
  
    this.num = 0;
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Model2Ds[q][0] = 0;
      allGroups.Model2Ds[q][1] = -1;
    }  
  
    allModel3Ds.deselect_All();
  }  
  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP);
      
      int ni = this.num;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.XYZS[i].length; j++) {
        for (int j = 0; j < 4; j++) { // x, y, z, s 
          lineSTR += nf(this.XYZS[i][j], 0, 4).replace(",", "."); // <<<<
          lineSTR += ",";
        }
        lineSTR += this.MAP[i];
  
        child.setContent(lineSTR);
      }  
      
      parent.setString("displayAll", Boolean.toString(this.displayAll));
      parent.setInt("num_files_PEOPLE", this.num_files_PEOPLE);
      parent.setInt("num_files_TREES", this.num_files_TREES);   
    }
    
    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".Textures");
      int ni = this.ImagePath.length;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
  
        boolean TEXTURE_copied = false;
  
        String the_dir = save_folder; 
  
        String the_filename = "";
        if (this.ImagePath[i].equals("")) {
        } else {
          the_filename = this.ImagePath[i].substring(this.ImagePath[i].lastIndexOf("/") + 1); // image name
  
  
          String new_Texture_path = the_dir + "/Textures/" + the_filename;
  
          if (this.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase())) {
            TEXTURE_copied = false;
          } else {
            if (this.ImagePath[i].equals("")) {
            } else {
              println("Copying texture:", this.ImagePath[i], ">", new_Texture_path);
              saveBytes(new_Texture_path, loadBytes(this.ImagePath[i]));
              this.ImagePath[i] = new_Texture_path;
  
              TEXTURE_copied = true;
            }
          }
  
          //if (TEXTURE_copied == false) {
          //  println("Saving texture from the scene.");
          //  this.Images[i].save(new_Texture_path);
          //}
        }
  
        XML child = parent.addChild("item");
        child.setInt("id", i); 
        child.setContent(this.ImagePath[i]);
      }
    }
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP);
      int ni = parent.getInt("ni");
  
      this.XYZS = new float [ni][4];
      this.MAP = new int [ni];
      this.num = ni;
  
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 4; j++) {
          this.XYZS[i][j] = float(parts[j]);
        }
        this.MAP[i] = int(parts[4]);
      }
      
      this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
      this.num_files_PEOPLE = parent.getInt("num_files_PEOPLE");
      this.num_files_TREES = parent.getInt("num_files_TREES");  
    }
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".Textures");
    
      int ni = parent.getInt("ni");
  
      int reload_All_textures = 0;
  
      if (this.ImagePath.length != ni) {
        this.Images = new PImage [ni];
        this.ImageRatios = new float [ni];
  
        reload_All_textures = 1;
      }
  
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {      
  
        String new_Texture_path = children[i].getContent();
        if ((reload_All_textures == 0) && (this.ImagePath[i].toUpperCase().equals(new_Texture_path.toUpperCase()))) {
        } else {
          this.ImagePath[i] = new_Texture_path;
          this.Images[i] = createImage(2, 2, RGB); // empty and small
          if (this.ImagePath[i].equals("")) {
          } else {
            println("Loading texture(" + i + "):", this.ImagePath[i]);
            this.Images[i] = loadImage(this.ImagePath[i]);
            println("loaded!");
  
            if (this.Images[i].height != 0) {
              this.ImageRatios[i] = float(this.Images[i].width) / float(this.Images[i].height);
            } else {
              this.ImageRatios[i] = 1;
            }
          }
        }
      }
    }
  }    
}

solarchvision_Model2Ds allModel2Ds = new solarchvision_Model2Ds();



class solarchvision_Model1Ds {
  
  private final static String CLASS_STAMP = "Model1Ds";

  boolean displayAll = true;
  boolean displayLeaves = true;

  float[][] XYZSR = new float[0][5];
  
  float getX (int n) {
    return this.XYZSR[n][0]; 
  }

  float getY (int n) {
    return this.XYZSR[n][1]; 
  }

  float getZ (int n) {
    return this.XYZSR[n][2]; 
  }

  float getS (int n) {
    return this.XYZSR[n][3]; 
  }
  
  float getR (int n) {
    return this.XYZSR[n][4]; 
  }  

  void setX (int n, float x) {
    this.XYZSR[n][0] = x;  
  }

  void setY (int n, float y) {
    this.XYZSR[n][1] = y;  
  }

  void setZ (int n, float z) {
    this.XYZSR[n][2] = z;  
  }

  void setS (int n, float s) {
    this.XYZSR[n][3] = s;  
  }  
  
  void setR (int n, float r) {
    this.XYZSR[n][4] = r;  
  }     
  
  void addX (int n, float dx) {
    this.XYZSR[n][0] += dx;  
  }  

  void addY (int n, float dy) {
    this.XYZSR[n][1] += dy;  
  }  

  void addZ (int n, float dz) {
    this.XYZSR[n][2] += dz;  
  }  
  
  void magS (int n, float ds) {
    this.XYZSR[n][3] *= ds;  
  }    

  
  int[] Type = new int[0];
  int[] Seed = new int[0];  
  int[] DegreeMin = new int[0];
  int[] DegreeMax = new int[0];
  
  int getType (int n) {
    return this.Type[n]; 
  }  

  void setType (int n, int t) {
    this.Type[n] = t;  
  }  
  
  int getSeed (int n) {
    return this.Seed[n]; 
  }  

  void setSeed (int n, int t) {
    this.Seed[n] = t;  
  }    
  
  int getDegreeMin (int n) {
    return this.DegreeMin[n]; 
  }  

  void setDegreeMin (int n, int t) {
    this.DegreeMin[n] = t;  
  }    
  
  int getDegreeMax (int n) {
    return this.DegreeMax[n]; 
  }  

  void setDegreeMax (int n, int t) {
    this.DegreeMax[n] = t;  
  }  


  float[] TrunkSize = new float[0];
  float[] LeafSize = new float[0];

  float getTrunkSize (int n) {
    return this.TrunkSize[n]; 
  }  

  void setTrunkSize (int n, float t) {
    this.TrunkSize[n] = t;  
  }  
  
  float getLeafSize (int n) {
    return this.LeafSize[n]; 
  }  

  void setLeafSize (int n, float t) {
    this.LeafSize[n] = t;  
  }   
  
  
  int num = 0; 
  
  
  float[][] Vertices;
  int[][] Faces;
  


  void draw (int target_window) {
  
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
    boolean proceed = true;
  
    if (this.displayAll == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }

    
    if (proceed) {  
      
      if (target_window == TypeWindow.OBJ) {
        if (User3D.export_MaterialLibrary) {
    
          if (allModel1Ds.num != 0) {
    
            mtlOutput.println("newmtl " + "Model1Ds_Trunk");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 1.000 0.750 0.500"); // ambient
            mtlOutput.println("\tKd 1.000 0.750 0.500"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
    
            mtlOutput.println("newmtl " + "Model1Ds_Leaf");
            mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
            mtlOutput.println("\tKa 0.500 0.750 0.250"); // ambient
            mtlOutput.println("\tKd 0.500 0.750 0.250"); // diffuse
            mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
            mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
            mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
            mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
            mtlOutput.println("\tTr 1.000"); //  0-1 transparency
            mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
          }
        }
      }      
      
      
  
      for (int f = 0; f < this.num; f++) {
  
        float x = this.XYZSR[f][0];
        float y = this.XYZSR[f][1];
        float z = this.XYZSR[f][2];
  
        float r = this.XYZSR[f][3] * 0.5;
        float rot = this.XYZSR[f][4];
  
        int n = this.Type[f];
  
        int dMin = this.DegreeMin[f];
  
        int dMax = this.DegreeMax[f];
  
        int s = this.Seed[f];
  
        float TrunkSize = this.TrunkSize[f];
  
        float LeafSize = this.LeafSize[f];
  
        randomSeed(s);
  
  

        if (n == 0) {
          
          if (target_window == TypeWindow.OBJ) {
          
            num_vertices_added = 0;
    
            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;
              objOutput.println("g allModel1Ds_" + nf(f, 0));
            }    
          }
  
          float Alpha = 0;
          float Beta = rot; 
  
  
          if (target_window == TypeWindow.OBJ) {
            for (int _turn = 1; _turn < 4; _turn++) {
              allModel1Ds.branch_export(_turn, x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);
            }
    
            obj_lastVertexNumber += num_vertices_added;
            obj_lastVtextureNumber += num_vertices_added;  
          }
          
          if (target_window == TypeWindow.WIN3D) {
  
            this.branch_main(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize);
    
            // ----------------
            x *= OBJECTS_scale;
            y *= OBJECTS_scale;
            z *= OBJECTS_scale;
            r *= OBJECTS_scale;
            // ----------------        
    
            float t = PI + WIN3D.rotation_Z * PI / 180.0;
            if (WIN3D.ViewType == 1) t = atan2(y - WIN3D.CAM_y, x - WIN3D.CAM_x) + 0.5 * PI; 
    
    
            this.Vertices[f * 4 + 0][0] = (x - r * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 0][1] = (y - r * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 0][2] = (z) / OBJECTS_scale;
    
            this.Vertices[f * 4 + 1][0] = (x + r * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 1][1] = (y + r * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 1][2] = (z) / OBJECTS_scale;
    
            this.Vertices[f * 4 + 2][0] = (x + r * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 2][1] = (y + r * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 2][2] = (z + 2 * r) / OBJECTS_scale;
    
            this.Vertices[f * 4 + 3][0] = (x - r * cos(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 3][1] = (y - r * sin(t)) / OBJECTS_scale;
            this.Vertices[f * 4 + 3][2] = (z + 2 * r) / OBJECTS_scale;
    
            this.Faces[f][0] = f * 4 + 0;
            this.Faces[f][1] = f * 4 + 1;
            this.Faces[f][2] = f * 4 + 2;
            this.Faces[f][3] = f * 4 + 3;
          }
  
        }
      }
    }
  }
  
  
  
  
  void branch_export (int _turn, float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        //float[] COL = {255, 100 - 6 * w, 50 - 3 * w, 0};
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (this.displayAll) {
          int nSeg = 6; 
          for (int q = 0; q < nSeg; q++) {
  
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
  
              float x = Trunk_x_new;
              float y = Trunk_y_new;
              float z = Trunk_z_new;
              float u = the_U;
              float v = the_V;
  
              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
              if (_turn == 1) {
  
                SOLARCHVISION_OBJprintVertex(x, y, z);
              }
  
              if (_turn == 2) {
  
                SOLARCHVISION_OBJprintVtexture(u, v, 0);
              }
            }
  
            if (_turn == 3) {
  
              num_vertices_added += 4;
  
              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
  
              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);               
  
              if (User3D.export_PolyToPoly == 0) {
                obj_lastGroupNumber += 1;
                objOutput.println(("g allModel1Ds_Trunk_n" + nf(q, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
              }
  
              if (User3D.export_MaterialLibrary) {
                objOutput.println("usemtl allModel1Ds_Trunk");
              }
  
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            }
          }
        }
  
        this.branch_export(_turn, x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (this.displayLeaves) {
  
        float LeafVertices[][] = {
          {
            0, 0, 0
          }
          , {
            1, 0, 1
          }
          , {
            0, 1, 1
          }
          , {
            -1, 0, 1
          }
          , {
            0, -1, 1
          }
          , {
            0, 0, 2
          }
        };
        int LeafFaces[][] = {
          {
            0, 1, 2, 5
          }
          , {
            0, 2, 3, 5
          }
          , {
            0, 3, 4, 5
          }
          , {
            0, 4, 1, 5
          }
        };
  
        for (int i = 0; i < 4; i++) { // 4: LeafFaces.length
          for (int j = 0; j < 4; j++) { // 4: LeafFaces[i].length
  
            float the_U = 0;
            if ((j == 1) || (j == 2)) the_U = 1;
  
            float the_V = 0;
            if ((j == 2) || (j == 3)) the_V = 1;
  
  
            float Leaf_x_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][0];
            float Leaf_y_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][1];
            float Leaf_z_dif = 0.5 * LeafSize * LeafVertices[LeafFaces[i][j]][2];
  
            float Leaf_x_rot = Leaf_z_dif * sin(rotZX) +  Leaf_x_dif * cos(rotZX);
            float Leaf_y_rot = Leaf_y_dif;
            float Leaf_z_rot = Leaf_z_dif * cos(rotZX) - Leaf_x_dif * sin(rotZX);
  
            float Leaf_x_new = x0 + Leaf_x_rot * cos(rotXY) - Leaf_y_rot * sin(rotXY);
            float Leaf_y_new = y0 + Leaf_x_rot * sin(rotXY) + Leaf_y_rot * cos(rotXY);
            float Leaf_z_new = z0 + Leaf_z_rot; 
  
            float x = Leaf_x_new;
            float y = Leaf_y_new;
            float z = Leaf_z_new;
            float u = the_U;
            float v = the_V;
  
            v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
            if (_turn == 1) {
  
              SOLARCHVISION_OBJprintVertex(x, y, z);
            }
  
            if (_turn == 2) {
  
              SOLARCHVISION_OBJprintVtexture(u, v, 0);
            }
          }
  
  
          if (_turn == 3) {  
  
            num_vertices_added += 4;
  
            String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
  
            String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);        
  
            if (User3D.export_PolyToPoly == 0) {
              obj_lastGroupNumber += 1;
              objOutput.println(("g allModel1Ds_Leaf_n" + nf(i, 0) + "_x" + nf(x0, 0, 3) + "_y" + nf(y0, 0, 3) + "_z" + nf(z0, 0, 3)).replace('.', '_'));
            }
  
            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl allModel1Ds_Leaf");
            }
  
            obj_lastFaceNumber += 1;
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);   
            if (User3D.export_BackSides) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
          }
        }
      }
    }
  }
  
  
  
  
  float getRatio_Plant_branch (float d) {
    return (0.75 / pow(d, 0.06125));
  }
  
  void branch_main (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        float[] COL = {
          255, 100 - 6 * w, 50 - 3 * w, 0
        };
  
        WIN3D.graphics.strokeWeight(1);
  
        if (allFaces.displayEdges == false) {
          WIN3D.graphics.noStroke();
        } else {
          WIN3D.graphics.stroke(0);
        }
  
        WIN3D.graphics.fill(COL[1], COL[2], COL[3]);
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (this.displayAll) {
          int nSeg = 6; 
          for (int q = 0; q < nSeg; q++) {
            WIN3D.graphics.beginShape();
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
              WIN3D.graphics.vertex(Trunk_x_new * OBJECTS_scale * WIN3D.scale, -Trunk_y_new * OBJECTS_scale * WIN3D.scale, Trunk_z_new * OBJECTS_scale * WIN3D.scale);
            }
            WIN3D.graphics.endShape(CLOSE);
          }
        }
  
        this.branch_main(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (this.displayLeaves) {
  
        WIN3D.graphics.strokeWeight(0);
  
        float[] COL = {
          127, 2 * c, 191 - c, 0
        };  // opaque!
  
        WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]); 
        WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
  
        WIN3D.graphics.pushMatrix(); 
        WIN3D.graphics.translate(x0 * OBJECTS_scale * WIN3D.scale, -y0 * OBJECTS_scale * WIN3D.scale, z0 * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.sphere(0.5 * LeafSize * OBJECTS_scale * WIN3D.scale);
        WIN3D.graphics.popMatrix();
      }
    }
  }
  
  
  void branch_add_allSolids (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize) {
  
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
  
  
  
        float cx = 0.5 * (x0 + x_new); 
        float cy = 0.5 * (y0 + y_new); 
        float cz = 0.5 * (z0 + z_new);
  
        float the_thickness = 0.025 * w * h;
        float rx = 0.5 * the_thickness;
        float ry = 0.5 * the_thickness;
        //float rz = 0.5 * abs(z_new - z0);
        float rz = 0.5 * abs(z_new - z0) * 1.25; // <<<<<<< to somehow compensate the shrinkage!
  
        allModel3Ds.add_Solid(cx, cy, cz, 2, 2, 2, rx, ry, rz, 0, (rotZX * 180 / PI), (rotXY * 180 / PI), User3D.create_MeshOrSolid);
  
  
        this.branch_add_allSolids(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int c = int(random(127));  
  
      if (this.displayLeaves) {
  
        float r0 = 0.5 * LeafSize;
        allModel3Ds.add_Solid(x0, y0, z0, 2, 2, 2, r0, r0, r0, 0, 0, 0, User3D.create_MeshOrSolid);
      }
    }
  }
  
  void branch_shadow (float x0, float y0, float z0, float Alpha, float Beta, float h, int Plant_min_degree, int d, int Plant_max_degree, float TrunkSize, float LeafSize, float[] SunR_Rotated, float Shades_scaleX, float Shades_scaleY, float Shades_offsetX, float Shades_offsetY) {
  
    SHADOW_graphics.strokeWeight(0);
  
    SHADOW_graphics.stroke(0);
    SHADOW_graphics.fill(0);
  
    h *= getRatio_Plant_branch(d);
  
    int birth = 1;
  
    if ((birth != 0) && (d < Plant_max_degree)) {
  
      for (int i = 1; i <= d; i++) {  
  
        float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
        float rotXY = Beta + random(-PI, PI);
  
        float w = TrunkSize * 0.5 * pow(Plant_max_degree - d + 1, 1.25);
  
        float x_dif = 0;
        float y_dif = 0;
        float z_dif = h;
  
        float x_rot = z_dif * sin(rotZX) +  x_dif * cos(rotZX);
        float y_rot = y_dif;
        float z_rot = z_dif * cos(rotZX) - x_dif * sin(rotZX);
  
        float x_new = x0 + x_rot * cos(rotXY) - y_rot * sin(rotXY);
        float y_new = y0 + x_rot * sin(rotXY) + y_rot * cos(rotXY);
        float z_new = z0 + z_rot; 
  
        if (this.displayAll) {
          int nSeg = 6; 
          float[][] subFace = new float [nSeg * 4][3];
          for (int q = 0; q < nSeg; q++) {
            for (int j = 0; j < 4; j++) {
  
              float the_U = 0;
              if ((j == 1) || (j == 2)) the_U = 1;
  
              float the_V = 0;
              if ((j == 2) || (j == 3)) the_V = 1;
  
              float the_thickness = 0.025 * w * h;
              if ((j == 2) || (j == 3)) the_thickness *= getRatio_Plant_branch(d + 1); // for conic trunks
  
              float Trunk_x_dif = the_thickness * cos((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_y_dif = the_thickness * sin((q + the_U) * TWO_PI / float(nSeg));
              float Trunk_z_dif = h * the_V;
  
              float Trunk_x_rot = Trunk_z_dif * sin(rotZX) +  Trunk_x_dif * cos(rotZX);
              float Trunk_y_rot = Trunk_y_dif;
              float Trunk_z_rot = Trunk_z_dif * cos(rotZX) - Trunk_x_dif * sin(rotZX);
  
              float Trunk_x_new = x0 + Trunk_x_rot * cos(rotXY) - Trunk_y_rot * sin(rotXY);
              float Trunk_y_new = y0 + Trunk_x_rot * sin(rotXY) + Trunk_y_rot * cos(rotXY);
              float Trunk_z_new = z0 + Trunk_z_rot; 
  
              subFace[q * 4 + j][0] = Trunk_x_new;
              subFace[q * 4 + j][1] = Trunk_y_new; 
              subFace[q * 4 + j][2] = Trunk_z_new;
            }
          }
  
          float[][] subFace_Rotated = subFace;
  
          for (int s = 0; s < subFace_Rotated.length; s++) {
            if (allSolarImpacts.sectionType == 2) {
              float a = subFace_Rotated[s][0];
              float b = -subFace_Rotated[s][1];
              float c = subFace_Rotated[s][2];
  
              subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
              subFace_Rotated[s][1] = c;    
              subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
            } else if (allSolarImpacts.sectionType == 3) {
            }
          }  
  
          SHADOW_graphics.beginShape();
  
          for (int s = 0; s < subFace_Rotated.length; s++) {
  
            float z = subFace_Rotated[s][2] - allSolarImpacts.elevation;
            float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
            float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
            if (z >= 0) {
  
              if (allSolarImpacts.sectionType == 1) {                    
                float px = x;
                float py = y;
  
                x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
              } 
  
              SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY);
            } else {
              int s_next = (s + 1) % subFace_Rotated.length;
              int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
              float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.elevation;
              float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
              float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
  
              if (z_prev > 0) { 
                float ratio = z_prev / (z_prev - z);
  
                float x_trim = x_prev * (1 - ratio) + x * ratio;
                float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                if (allSolarImpacts.sectionType == 1) {
                  float px = x_trim;
                  float py = y_trim;
  
                  x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                  y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                } 
  
                SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
              }
  
              float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.elevation;
              float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
              float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
              if (z_next > 0) { 
                float ratio = z_next / (z_next - z);
  
                float x_trim = x_next * (1 - ratio) + x * ratio;
                float y_trim = y_next * (1 - ratio) + y * ratio;
  
                if (allSolarImpacts.sectionType == 1) {
                  float px = x_trim;
                  float py = y_trim;
  
                  x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                  y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                } 
  
                SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -(y_trim - Shades_offsetY) * Shades_scaleY);
              }
            }
          }
  
          SHADOW_graphics.endShape(CLOSE);
        }
  
        this.branch_shadow(x_new, y_new, z_new, rotZX, rotXY, h, Plant_min_degree, d + 1, Plant_max_degree, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetY, Shades_offsetY);
      }
    } else {
  
      // must pass all the random values here.
      float rotZX = Alpha + (1 + d - Plant_min_degree) * random(-PI / 8, PI / 8);
      float rotXY = Beta + random(-PI, PI);
      int COL = int(random(127));      
  
      if (this.displayLeaves) {
  
        float x0_Rotated = x0;
        float y0_Rotated = y0;
        float z0_Rotated = z0;
  
        if (allSolarImpacts.sectionType == 2) {
          float a = x0;
          float b = -y0;
          float c = z0;
  
          x0_Rotated = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
          y0_Rotated = c;    
          z0_Rotated= a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
        } else if (allSolarImpacts.sectionType == 3) {
        }
  
  
        float z = z0_Rotated - allSolarImpacts.elevation;
        float x = x0_Rotated - z * SunR_Rotated[1] / SunR_Rotated[3];
        float y = y0_Rotated - z * SunR_Rotated[2] / SunR_Rotated[3];
  
        if (z >= 0) {
  
          if (allSolarImpacts.sectionType == 1) {                    
            float px = x;
            float py = y;
  
            x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
            y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
          } 
  
  
  
          SHADOW_graphics.ellipse((x - Shades_offsetX) * Shades_scaleX, -(y - Shades_offsetY) * Shades_scaleY, LeafSize * Shades_scaleX, LeafSize * Shades_scaleY);
        }
      }
    }
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);
      
      float[] face_norm = funcs.vec3_cross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }  
  
  
  
  
  void add_single (int PlantType, float x, float y, float z, float s, float rot, int PlantDegreeMin, int PlantDegreeMax, int PlantSeed, float TrunkSize, float LeafSize) {
  
    float[] TempallModel1Ds_TrunkSize = {
      TrunkSize
    }; 
    this.TrunkSize = concat(this.TrunkSize, TempallModel1Ds_TrunkSize);  
  
    float[] TempallModel1Ds_LeafSize = {
      LeafSize
    }; 
    this.LeafSize = concat(this.LeafSize, TempallModel1Ds_LeafSize);
  
    int[] TempallModel1Ds_Type = {
      PlantType
    }; 
    this.Type = concat(this.Type, TempallModel1Ds_Type);
  
    int[] TempallModel1Ds_DegreeMin = {
      PlantDegreeMin
    }; 
    this.DegreeMin = concat(this.DegreeMin, TempallModel1Ds_DegreeMin);
  
    int[] TempallModel1Ds_DegreeMax = {
      PlantDegreeMax
    }; 
    this.DegreeMax = concat(this.DegreeMax, TempallModel1Ds_DegreeMax);
  
    int q = PlantSeed;
    if (q == -1) q = int(random(32767));
  
    int[] TempallModel1Ds_Seed = {
      q
    }; 
    this.Seed = concat(this.Seed, TempallModel1Ds_Seed);
  
    float[][] TempallModel1Ds_XYZSR = {
      {
        x, y, z, s, rot
      }
    };
    this.XYZSR = (float[][]) concat(this.XYZSR, TempallModel1Ds_XYZSR);
  
    this.num += 1;
  
  
  
    if (User3D.create_MeshOrSolid != 0) {
  
      randomSeed(q);
  
      this.branch_add_allSolids(x, y, z, 0, rot, 0.5 * s, PlantDegreeMin, PlantDegreeMin, PlantDegreeMax, TrunkSize, LeafSize);
    }
  
  
    if (allGroups.num > 0) allGroups.Model1Ds[allGroups.num - 1][1] = this.num - 1;
  
  }  
  
  
  void delete () {
  
    this.XYZSR = new float [0][5]; 
  
    this.Type = new int [0];
  
    this.DegreeMin = new int [0];
  
    this.DegreeMax = new int [0];
  
    this.Seed = new int [0];
  
    this.TrunkSize = new float [0];
  
    this.LeafSize = new float [0];
  
    this.num = 0;
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Model1Ds[q][0] = 0;
      allGroups.Model1Ds[q][1] = -1;
    }    
  
    allModel3Ds.deselect_All();
  }  
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.XYZSR[i].length; j++) {
      for (int j = 0; j < 5; j++) { // x, y, z, s, rot
        lineSTR += nf(this.XYZSR[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(this.getType(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getDegreeMin(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getDegreeMax(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getSeed(i), 0);
      lineSTR += ",";
      lineSTR += nf(this.getTrunkSize(i), 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(this.getLeafSize(i), 0, 4).replace(",", "."); // <<<<

      child.setContent(lineSTR);
    } 
    
    
    parent.setString("displayAll", Boolean.toString(this.displayAll));
    parent.setString("displayLeaves", Boolean.toString(this.displayLeaves));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = parent.getInt("ni");

    this.XYZSR = new float [ni][5];
    this.Type = new int [ni];
    this.DegreeMin = new int [ni];
    this.DegreeMax = new int [ni];
    this.Seed = new int [ni];
    this.TrunkSize = new float [ni];
    this.LeafSize = new float [ni];
    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 5; j++) {
        this.XYZSR[i][j] = float(parts[j]);
      }

      this.setType(i, int(parts[5]));
      this.setDegreeMin(i, int(parts[6]));
      this.setDegreeMax(i, int(parts[7]));
      this.setSeed(i, int(parts[8]));
      this.setTrunkSize(i, float(parts[9]));
      this.setLeafSize(i, float(parts[10]));
    }
    
    this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
    this.displayLeaves = Boolean.parseBoolean(parent.getString("displayLeaves"));
  }    
}

solarchvision_Model1Ds allModel1Ds = new solarchvision_Model1Ds();



class solarchvision_Solids {
  
  private final static String CLASS_STAMP = "Solids";
  
  boolean displayAll = true;  
  int pallet_CLR = 17; //1; 
  int pallet_DIR = -1; 
  float pallet_MLT = 0.01; //1; 

  float[][] DEF = new float[0][13];
  
  void updatePosition (int n, float a, float b, float c) {
  
    this.DEF[n][0] = a;
    this.DEF[n][1] = b;
    this.DEF[n][2] = c;
  } 
  
  void updatePowers (int n, float a, float b, float c) {
  
    this.DEF[n][3] = a;
    this.DEF[n][4] = b;
    this.DEF[n][5] = c;
  } 
  
  void Scale (int n, float a, float b, float c) {
  
    this.DEF[n][6] *= a;
    this.DEF[n][7] *= b;
    this.DEF[n][8] *= c;
  } 
  
  void RotateX (int n, float t) {
  
    this.DEF[n][9] += t;
  } 
  
  void RotateY (int n, float t) {
  
    this.DEF[n][10] += t;
  } 
  
  void RotateZ (int n, float t) {
  
    this.DEF[n][11] += t;
  } 
  
  void set_posX (int n, float r) { 
  
    this.DEF[n][0] = r;
  } 
  
  void set_posY (int n, float r) { 
  
    this.DEF[n][1] = r;
  } 
  
  void set_posZ (int n, float r) { 
  
    this.DEF[n][2] = r;
  } 
  
  void set_powX (int n, float r) { 
  
    this.DEF[n][3] = r;
  } 
  
  void set_powY (int n, float r) { 
  
    this.DEF[n][4] = r;
  } 
  
  void set_powZ (int n, float r) { 
  
    this.DEF[n][5] = r;
  } 
  
  void set_scaleX (int n, float r) { 
  
    this.DEF[n][6] = r;
  } 
  
  void set_scaleY (int n, float r) { 
  
    this.DEF[n][7] = r;
  } 
  
  void set_scaleZ (int n, float r) { 
  
    this.DEF[n][8] = r;
  } 
  
  void set_rotX (int n, float r) { 
  
    this.DEF[n][9] = r;
  } 
  
  
  void set_rotY (int n, float r) { 
  
    this.DEF[n][10] = r;
  } 
  
  void set_rotZ (int n, float r) { 
  
    this.DEF[n][11] = r;
  } 
  
  void set_value (int n, float r) { 
  
    this.DEF[n][12] = r;
  }   
  
  float get_posX (int n) { 
  
    return this.DEF[n][0];
  } 
  
  float get_posY (int n) { 
  
    return this.DEF[n][1];
  } 
  
  float get_posZ (int n) { 
  
    return this.DEF[n][2];
  } 
  
  float get_powX (int n) { 
  
    return this.DEF[n][3];
  } 
  
  float get_powY (int n) { 
  
    return this.DEF[n][4];
  } 
  
  float get_powZ (int n) { 
  
    return this.DEF[n][5];
  } 
  
  float get_scaleX (int n) { 
  
    return this.DEF[n][6];
  } 
  
  float get_scaleY (int n) { 
  
    return this.DEF[n][7];
  } 
  
  float get_scaleZ (int n) { 
  
    return this.DEF[n][8];
  } 
  
  float get_rotX (int n) { 
  
    return this.DEF[n][9];
  } 
  
  
  float get_rotY (int n) { 
  
    return this.DEF[n][10];
  } 
  
  float get_rotZ (int n) { 
  
    return this.DEF[n][11];
  } 
  
  float get_value (int n) { 
  
    return this.DEF[n][12];
  } 
  
  float get_Distance (int n, float a, float b, float c) {
  
    float posX = this.DEF[n][0];
    float posY = this.DEF[n][1];
    float posZ = this.DEF[n][2];
    float powX = this.DEF[n][3];
    float powY = this.DEF[n][4];
    float powZ = this.DEF[n][5];
    float scaleX = this.DEF[n][6];
    float scaleY = this.DEF[n][7];
    float scaleZ = this.DEF[n][8];
    float rotX = this.DEF[n][9];
    float rotY = this.DEF[n][10];
    float rotZ = this.DEF[n][11];
    float value = this.DEF[n][12];
  
    a -= posX;
    b -= posY;    
    c -= posZ;
  
    ///////////////////////// NOT SURE START!    
  
    float y1 = b * funcs.cos_ang(-rotX) - c * funcs.sin_ang(-rotX); 
    float z1 = b * funcs.sin_ang(-rotX) + c * funcs.cos_ang(-rotX);
    float x1 = a;
  
    a = x1;
    b = y1;
    c = z1;  
  
    float z2 = c * funcs.cos_ang(-rotY) - a * funcs.sin_ang(-rotY);
    float x2 = c * funcs.sin_ang(-rotY) + a * funcs.cos_ang(-rotY);
    float y2 = b; 
  
    a = x2;
    b = y2;
    c = z2;      
    ///////////////////////// NOT SURE END!
  
    float x = a * funcs.cos_ang(-rotZ) - b * funcs.sin_ang(-rotZ);
    float y = a * funcs.sin_ang(-rotZ) + b * funcs.cos_ang(-rotZ); 
    float z = c;    
  
    x += posX;
    y += posY;  
    z += posZ;
  
     
    return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))));
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    //return(pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / (value * scaleX * scaleY * scaleZ * 0.001));
    //return(scaleX * scaleY * scaleZ * 0.01 * pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
    
  
  }  
  
  
  int num_visualFaces = 3; // internal - number of faces: XY, YZ, ZX
  int numdisplayAllDegree = 16; //8; // internal - number of each face corners 
  
  private float[][] Vertices;
  private int[][] Faces;

  void draw () {
  
    this.Faces = new int [this.num_visualFaces * this.DEF.length][this.numdisplayAllDegree]; 
  
    this.Vertices = new float [this.num_visualFaces * this.numdisplayAllDegree * this.DEF.length][3];
  
    if (this.displayAll) {
  
      WIN3D.graphics.strokeWeight(2);
  
      for (int f = 0; f < this.DEF.length; f++) {
  
        float Solid_posX = this.get_posX(f);
        float Solid_posY = this.get_posY(f);
        float Solid_posZ = this.get_posZ(f);
        float Solid_powX = this.get_powX(f);
        float Solid_powY = this.get_powY(f);
        float Solid_powZ = this.get_powZ(f);
        float Solid_scaleX = this.get_scaleX(f);
        float Solid_scaleY = this.get_scaleY(f);
        float Solid_scaleZ = this.get_scaleZ(f);
        float Solid_rotX = this.get_rotX(f);
        float Solid_rotY = this.get_rotY(f);
        float Solid_rotZ = this.get_rotZ(f);
        float Solid_value = this.get_value(f);
  
        for (int plane_type = 0; plane_type < this.num_visualFaces; plane_type++) {
  
          WIN3D.graphics.noFill();        
          WIN3D.graphics.stroke(0);
  
          if (plane_type == 0) {
            WIN3D.graphics.stroke(0, 255, 0);
          }  
          if (plane_type == 1) {
            WIN3D.graphics.stroke(255, 0, 0);
          }          
          if (plane_type == 2) {
            WIN3D.graphics.stroke(0, 0, 255);
          }          
  
          WIN3D.graphics.beginShape();
  
          float[][] ImageVertex = this.getCorners(plane_type, Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
          for (int q = 1; q <= this.numdisplayAllDegree; q++) {
  
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
  
            if (q != 0) {
  
              int vNo = (f * this.num_visualFaces + plane_type) * this.numdisplayAllDegree + q - 1;
  
              this.Vertices[vNo][0] = x;
              this.Vertices[vNo][1] = y;
              this.Vertices[vNo][2] = z;
  
              int fNo = (f * this.num_visualFaces + plane_type);
  
              this.Faces[fNo][q - 1] = vNo;
            }
          }        
  
          WIN3D.graphics.endShape(CLOSE);
        }
      }
  
      WIN3D.graphics.noStroke();
      WIN3D.graphics.strokeWeight(0);
    }
  }
  
  
  float[][] getCorners (int plane_type, float Solid_posX, float Solid_posY, float Solid_posZ, float Solid_powX, float Solid_powY, float Solid_powZ, float Solid_scaleX, float Solid_scaleY, float Solid_scaleZ, float Solid_rotX, float Solid_rotY, float Solid_rotZ, float Solid_value) {
  
    float[][] ImageVertex = new float [this.numdisplayAllDegree + 1][3];
  
    for (int q = 0; q <= this.numdisplayAllDegree; q++) {
  
      float qx = 0;
      float qy = 0;
      float qz = 0;
  
      if (q != 0) {
        if (plane_type == 0) {
          qx = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qy = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }
  
        if (plane_type == 1) {
          qy = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qz = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }
  
        if (plane_type == 2) {
          qz = funcs.cos_ang(q * 360.0 / float(this.numdisplayAllDegree));
          qx = funcs.sin_ang(q * 360.0 / float(this.numdisplayAllDegree));
        }
      }
  
      if (q != 0) { // normalizing
  
        float d = pow(pow(abs(qx), Solid_powX) + pow(abs(qy), Solid_powY) + pow(abs(qz), Solid_powZ), 3.0 / (Solid_powX + Solid_powY + Solid_powZ));
  
        if (d != 0) {
          qx /= d;
          qy /= d;
          qz /= d;
        }
      }
  
  
      float a = qx * Solid_scaleX;
      float b = qy * Solid_scaleY;
      float c = qz * Solid_scaleZ;  
  
      ///////////////////////// NOT SURE START!    
  
      float y1 = b * funcs.cos_ang(Solid_rotX) - c * funcs.sin_ang(Solid_rotX); 
      float z1 = b * funcs.sin_ang(Solid_rotX) + c * funcs.cos_ang(Solid_rotX);
      float x1 = a;
  
      a = x1;
      b = y1;
      c = z1;  
  
      float z2 = c * funcs.cos_ang(Solid_rotY) - a * funcs.sin_ang(Solid_rotY);
      float x2 = c * funcs.sin_ang(Solid_rotY) + a * funcs.cos_ang(Solid_rotY);
      float y2 = b; 
  
      a = x2;
      b = y2;
      c = z2;      
      ///////////////////////// NOT SURE END!
  
      float x = a * funcs.cos_ang(Solid_rotZ) - b * funcs.sin_ang(Solid_rotZ);
      float y = a * funcs.sin_ang(Solid_rotZ) + b * funcs.cos_ang(Solid_rotZ);
      float z = c;         
  
  
      x += Solid_posX;
      y += Solid_posY;
      z += Solid_posZ;  
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }
  
    return ImageVertex;
  }

  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
      
      int n = this.Faces[f].length;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);
      
      float[] face_norm = funcs.vec3_cross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
      
      float dist2intersect = FLOAT_undefined;
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          float X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          float Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          float Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
    
          float AnglesAll = 0;      
    
          for (int i = 0; i < n; i++) {
            int next_i = (i + 1) % n;
    
            float[] vect1 = {this.Vertices[this.Faces[f][i]][0] - X_intersect, this.Vertices[this.Faces[f][i]][1] - Y_intersect, this.Vertices[this.Faces[f][i]][2] - Z_intersect};
            float[] vect2 = {this.Vertices[this.Faces[f][next_i]][0] - X_intersect, this.Vertices[this.Faces[f][next_i]][1] - Y_intersect, this.Vertices[this.Faces[f][next_i]][2] - Z_intersect};
    
            float t = funcs.acos_ang(funcs.vec_dot(funcs.vec3_unit(vect1), funcs.vec3_unit(vect2)));
    
            AnglesAll += t;
          }
          
          if (AnglesAll > 359) { // <<<<<<<<<
          
            hitPoint[f][0] = X_intersect;
            hitPoint[f][1] = Y_intersect;
            hitPoint[f][2] = Z_intersect;
            hitPoint[f][3] = dist2intersect;
          }
        }
      }
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = int(f / this.num_visualFaces);
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
  
      }
  
    }
  
    return return_point;
  }


  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    int ni = this.DEF.length;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.DEF[i].length; j++) {
      for (int j = 0; j < 13; j++) { // x, y, y, px, py, pz, sx, sy, sz, rx, ry, rz, v
        lineSTR += nf(this.DEF[i][j], 0, 4).replace(",", "."); // <<<<
        if (j + 1 != this.DEF[i].length) lineSTR += ",";
      }
      child.setContent(lineSTR);
    }    
    
    parent.setString("displayAll", Boolean.toString(this.displayAll));
    parent.setInt("pallet_CLR", this.pallet_CLR);
    parent.setInt("pallet_DIR", this.pallet_DIR);
    parent.setFloat("pallet_MLT", this.pallet_MLT);
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    int ni = parent.getInt("ni");

    this.DEF = new float [ni][13];

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 13; j++) {
        this.DEF[i][j] = float(parts[j]);
      }
    }
    
    this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));    
    this.pallet_CLR = parent.getInt("pallet_CLR");
    this.pallet_DIR = parent.getInt("pallet_DIR");
    this.pallet_MLT = parent.getFloat("pallet_MLT");   
  }    

}

solarchvision_Solids allSolids = new solarchvision_Solids();















 
float[][] allVertices = new float[0][3];

// to increase performance we defined vertices array outside Points class

class solarchvision_Points {
  
  private final static String CLASS_STAMP = "Points";
    
  boolean displayAll = false;
  
  void setX (int n, float x) { 
  
    allVertices[n][0] = x;
  }   

  void setY (int n, float y) { 
  
    allVertices[n][1] = y;
  }   

  void setZ (int n, float z) { 
  
    allVertices[n][2] = z;
  }   
  
  void addX (int n, float dx) { 
  
    allVertices[n][0] += dx;
  }     
  
  void addY (int n, float dy) { 
  
    allVertices[n][1] += dy;
  }     

  void addZ (int n, float dz) { 
  
    allVertices[n][2] += dz;
  }       
  
  int getLength () {
    return  allVertices.length;
  }
  
  float getX (int n) { 
  
    return allVertices[n][0];
  } 

  float getY (int n) { 
  
    return allVertices[n][1];
  } 

  float getZ (int n) { 
  
    return allVertices[n][2];
  } 

  float[] getPosition (int n) {
   
    float[] result = {this.getX(n), this.getY(n), this.getZ(n)};
  
    return result;
  } 
  

  
  
  void draw () {
  
    if (this.displayAll) {
      
      WIN3D.graphics.strokeWeight(3);
    
      WIN3D.graphics.stroke(0); 
      
      WIN3D.graphics.noFill();      
      
      float d = 0.5; // <<<<<<<<<<<<<< distance 
  
      for (int f = 0; f < allPoints.getLength(); f++) {    
                
        float x = allPoints.getX(f);
        float y = allPoints.getY(f);
        float z = allPoints.getZ(f);
        
        WIN3D.graphics.line((x - d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, (x + d) * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);
  
        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -((y - d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -((y + d) * OBJECTS_scale * WIN3D.scale), z * OBJECTS_scale * WIN3D.scale);
  
        WIN3D.graphics.line(x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z - d) * OBJECTS_scale * WIN3D.scale, x * OBJECTS_scale * WIN3D.scale, -(y * OBJECTS_scale * WIN3D.scale), (z + d) * OBJECTS_scale * WIN3D.scale);
              
      }
      
      WIN3D.graphics.strokeWeight(0);
    }
  }  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setInt("ni", allPoints.getLength());
    for (int i = 0; i < allPoints.getLength(); i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      lineSTR += nf(allPoints.getX(i), 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(allPoints.getY(i), 0, 4).replace(",", "."); // <<<<
      lineSTR += ",";
      lineSTR += nf(allPoints.getZ(i), 0, 4).replace(",", "."); // <<<<
      child.setContent(lineSTR);
    }    

    parent.setString("displayAll", Boolean.toString(this.displayAll));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    int ni = parent.getInt("ni");
    allVertices = new float [ni][3];
    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {
      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
 
      allPoints.setX(i, float(parts[0]));
      allPoints.setY(i, float(parts[1]));
      allPoints.setZ(i, float(parts[2]));
    }    
    
    this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
  }      
  
  
}

solarchvision_Points allPoints = new solarchvision_Points();

          


class solarchvision_User3D {
  
  private final static String CLASS_STAMP = "User3D";

  int default_Material = 7; //0; 
  int default_Tessellation = 0;
  int default_Layer = 0;
  int default_Visibility = 1; // 1: view 0: hide -1:freeze 
  int default_Weight = 0; 
  int default_Closed = 0; 
  int default_PivotType = 0;

  float create_Length = 10;
  float create_Width = 10;
  float create_Height = 10;
  float create_Volume = 0; //3000;
  float create_Orientation = 360; //0; // 360: random
  float create_powX = CubePower; 
  float create_powY = CubePower; 
  float create_powZ = CubePower; 
  float create_powAll = 8;
  int create_powRnd = 0;
  int create_SphereDegree = 2; //4;
  int create_CylinderDegree = 24; 
  int create_PolyDegree = 6;
  int create_Parametric_Type = 0;
  int create_Person_Type = 0;
  int create_Plant_Type = 0;
  int create_Model1D_Type = 0;
  int create_Model1D_DegreeMin = 1; //2; 
  int create_Model1D_DegreeMax = 6; //5; //8;
  int create_Model1D_Seed = -1; // -1:random, 0-99 choice
  float create_Model1D_TrunkSize = 1; //0.5;
  float create_Model1D_LeafSize = 1; //1; 
  int create_MeshOrSolid = 0; // 0:Mesh 1:Solid
  int create_Snap = 0;

  int modify_TessellateRows = 6;
  int modify_TessellateColumns = 30;
  float modify_OpenningDepth = 1; // 1 = 1m 
  float modify_OpenningArea = 0.25; //0-1, 0.25: 25% of the face area (i.e. for parallel openings) 
  float modify_OpenningDeviation = 0.5; //0-1, 0.5: middle of the face edge (could be applied in rotated openning)
  float modify_OffsetAmount = 1.0; // 1 = 1m
  float modify_WeldTreshold = 0.1; 

  float export_Scale = 1.0; //0.001; // 0.001: 1km --> 1
  int export_FlipZYaxis = 1; //1; // 1: to fit in Unity3D
  
  int export_PrecisionVertex = 6; 
  int export_PrecisionVtexture = 4;
  int export_PolyToPoly = 1; // 0: Exports each group3D to different individual faces, 1: Exports group3D to group3D 
  
  boolean export_MaterialLibrary = true; 
  boolean export_BackSides = true; 
  int export_PalletResolution = 256;
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    parent.setInt("default_Material", this.default_Material);  
    parent.setInt("default_Tessellation", this.default_Tessellation);
    parent.setInt("default_Layer", this.default_Layer);
    parent.setInt("default_Visibility", this.default_Visibility);
    parent.setInt("default_Weight", this.default_Weight);
    parent.setInt("default_Closed", this.default_Closed);
    parent.setInt("default_PivotType", this.default_PivotType);
  
    parent.setFloat("create_Length", this.create_Length);
    parent.setFloat("create_Width", this.create_Width);
    parent.setFloat("create_Height", this.create_Height);
    parent.setFloat("create_Volume", this.create_Volume);
    parent.setFloat("create_Orientation", this.create_Orientation);
    parent.setFloat("create_powX", this.create_powX);
    parent.setFloat("create_powY", this.create_powY);
    parent.setFloat("create_powZ", this.create_powZ);
    parent.setFloat("create_powAll", this.create_powAll);
    parent.setInt("create_powRnd", this.create_powRnd);
    parent.setInt("create_SphereDegree", this.create_SphereDegree);
    parent.setInt("create_CylinderDegree", this.create_CylinderDegree);
    parent.setInt("create_PolyDegree", this.create_PolyDegree);
    parent.setInt("create_Parametric_Type", this.create_Parametric_Type);
    parent.setInt("create_Person_Type", this.create_Person_Type);
    parent.setInt("create_Plant_Type", this.create_Plant_Type);
    parent.setInt("create_Model1D_Type", this.create_Model1D_Type);
    parent.setInt("create_Model1D_DegreeMin", this.create_Model1D_DegreeMin);
    parent.setInt("create_Model1D_DegreeMax", this.create_Model1D_DegreeMax);
    parent.setInt("create_Model1D_Seed", this.create_Model1D_Seed);
    parent.setFloat("create_Model1D_TrunkSize", this.create_Model1D_TrunkSize);
    parent.setFloat("create_Model1D_LeafSize", this.create_Model1D_LeafSize);
    parent.setInt("create_MeshOrSolid", this.create_MeshOrSolid);
    parent.setInt("create_Snap", this.create_Snap);

    parent.setInt("modify_TessellateRows", this.modify_TessellateRows);
    parent.setInt("modify_TessellateColumns", this.modify_TessellateColumns);
    parent.setFloat("modify_OpenningDepth", this.modify_OpenningDepth);
    parent.setFloat("modify_OpenningArea", this.modify_OpenningArea);
    parent.setFloat("modify_OpenningDeviation", this.modify_OpenningDeviation);
    parent.setFloat("modify_WeldTreshold", this.modify_WeldTreshold);
    parent.setFloat("modify_OffsetAmount", this.modify_OffsetAmount);
    
    parent.setFloat("export_Scale", this.export_Scale);
    parent.setInt("export_FlipZYaxis", this.export_FlipZYaxis);
    parent.setInt("export_PrecisionVertex", this.export_PrecisionVertex);
    parent.setInt("export_PrecisionVtexture", this.export_PrecisionVtexture);
    parent.setInt("export_PolyToPoly", this.export_PolyToPoly);
    parent.setString("export_MaterialLibrary", Boolean.toString(this.export_MaterialLibrary));
    parent.setString("export_BackSides", Boolean.toString(this.export_BackSides));
    parent.setInt("export_PalletResolution", this.export_PalletResolution);

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.default_Material = parent.getInt("default_Material");
    this.default_Tessellation = parent.getInt("default_Tessellation");
    this.default_Layer = parent.getInt("default_Layer");
    this.default_Visibility = parent.getInt("default_Visibility");
    this.default_Weight = parent.getInt("default_Weight");
    this.default_Closed = parent.getInt("default_Closed");
    this.default_PivotType = parent.getInt("default_PivotType");

    this.create_Length = parent.getFloat("create_Length");
    this.create_Width = parent.getFloat("create_Width");
    this.create_Height = parent.getFloat("create_Height");
    this.create_Volume = parent.getFloat("create_Volume");
    this.create_Orientation = parent.getFloat("create_Orientation");
    this.create_powX = parent.getFloat("create_powX");
    this.create_powY = parent.getFloat("create_powY");
    this.create_powZ = parent.getFloat("create_powZ");
    this.create_powAll = parent.getFloat("create_powAll");
    this.create_powRnd = parent.getInt("create_powRnd");
    this.create_SphereDegree = parent.getInt("create_SphereDegree");
    this.create_CylinderDegree = parent.getInt("create_CylinderDegree");
    this.create_PolyDegree = parent.getInt("create_PolyDegree");
    this.create_Parametric_Type = parent.getInt("create_Parametric_Type");
    this.create_Person_Type = parent.getInt("create_Person_Type");
    this.create_Plant_Type = parent.getInt("create_Plant_Type");
    this.create_Model1D_Type = parent.getInt("create_Model1D_Type");
    this.create_Model1D_DegreeMin = parent.getInt("create_Model1D_DegreeMin");
    this.create_Model1D_DegreeMax = parent.getInt("create_Model1D_DegreeMax");
    this.create_Model1D_Seed = parent.getInt("create_Model1D_Seed");
    this.create_Model1D_TrunkSize = parent.getFloat("create_Model1D_TrunkSize");
    this.create_Model1D_LeafSize = parent.getFloat("create_Model1D_LeafSize");
    this.create_MeshOrSolid = parent.getInt("create_MeshOrSolid");
    this.create_Snap = parent.getInt("create_Snap");
    
    this.modify_TessellateRows = parent.getInt("modify_TessellateRows");
    this.modify_TessellateColumns = parent.getInt("modify_TessellateColumns");
    this.modify_OpenningDepth = parent.getFloat("modify_OpenningDepth");
    this.modify_OpenningArea = parent.getFloat("modify_OpenningArea");
    this.modify_OpenningDeviation = parent.getFloat("modify_OpenningDeviation");
    this.modify_WeldTreshold = parent.getFloat("modify_WeldTreshold");
    this.modify_OffsetAmount = parent.getFloat("modify_OffsetAmount");
    
    this.export_Scale = parent.getFloat("export_Scale");
    this.export_FlipZYaxis = parent.getInt("export_FlipZYaxis");
    this.export_PrecisionVertex = parent.getInt("export_PrecisionVertex");
    this.export_PrecisionVtexture = parent.getInt("export_PrecisionVtexture");
    this.export_PolyToPoly = parent.getInt("export_PolyToPoly");
    this.export_MaterialLibrary  = Boolean.parseBoolean(parent.getString("export_MaterialLibrary"));
    this.export_BackSides = Boolean.parseBoolean(parent.getString("export_BackSides"));
    this.export_PalletResolution = parent.getInt("export_PalletResolution");    
    
  }      
  
  
}

solarchvision_User3D User3D = new solarchvision_User3D();

          







class solarchvision_Model3Ds {
  
  private final static String CLASS_STAMP = "Model3Ds";
  
  void beginNewCurve () {
  
    int[] newCurve_nodes = {};    
    
    this.add_Curve(newCurve_nodes);
    
  }
  
  void beginNewFace () {
  
    int[] newFace_nodes = {};    
    
    this.add_Face(newFace_nodes);
    
  }
  
  void add_VertexToLastFace (float x, float y, float z) {
    
    int n = allFaces.nodes.length - 1;
    
    int[] newVertex = {
      this.add_Vertex(x, y, z)
    }; 
      
    allFaces.nodes[n] = (int[]) concat(allFaces.nodes[n], newVertex);
  
  }
  
  void add_VertexToLastCurve (float x, float y, float z) {
  
    int n = allCurves.nodes.length - 1;
    
    int[] newVertex = {
      this.add_Vertex(x, y, z)
    }; 
      
    allCurves.nodes[n] = (int[]) concat(allCurves.nodes[n], newVertex);
  
  }
  
  
  
  
  int add_Vertex (float x, float y, float z) {
  
    float[][] newVertex = {
      {
        x, y, z
      }
    }; 
  
    allVertices = (float[][]) concat(allVertices, newVertex);
  
    return(allPoints.getLength() - 1);
  }
  
  
  
  int add_Face (int[] f) {
  
    {
  
      int[][] newFace_options = {
        {
          current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
        }
      }; 
  
      allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);
  
      int[][] newFace_nodes = {
        f
      }; 
  
      allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
    }
  
    if (allGroups.num > 0) allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
  
    return(allFaces.nodes.length - 1);
  }
  
  int add_Curve (int[] f) {
  
    {
  
      int[][] newCurve_options = {
        {
          current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
        }
      }; 
  
      allCurves.options =  (int[][]) concat(allCurves.options, newCurve_options);
  
      int[][] newCurve_nodes = {
        f
      }; 
  
      allCurves.nodes = (int[][]) concat(allCurves.nodes, newCurve_nodes);
    }
  
    if (allGroups.num > 0) allGroups.Curves[allGroups.num - 1][1] = allCurves.nodes.length - 1;
  
    return(allCurves.nodes.length - 1);
  }


  void add_Spline (int m, int tes, int lyr, int vsb, int wgt, int clz, float[][] points) {
    
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;  
    current_Closed = clz;
  
    int[] newCurve_nodes = new int[points.length];
   
    for (int i = 0; i < points.length; i++) {
      newCurve_nodes[i] = this.add_Vertex(points[i][0], points[i][1], points[i][2]);
    }
  
    this.add_Curve(newCurve_nodes);
  }
  
  
  void add_Arc (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot, float TotalAngle) {
  
    float AngleStep = TotalAngle / float(n);
    int EndOfLoop = n;
    if (TotalAngle % 360 == 0) {
      EndOfLoop -= 1;
      clz = 1; // for right closing of a circle 
    }
    
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;
  
  
    int[] newCurve_nodes = {
      this.add_Vertex(cx + r * funcs.cos_ang(0), cy + r * funcs.sin_ang(0), cz)
    };
    for (int i = 1; i <= EndOfLoop; i++) {
      float t = i * AngleStep + rot;
      int[] f = {
        this.add_Vertex(cx + r * funcs.cos_ang(t), cy + r * funcs.sin_ang(t), cz)
      };
      newCurve_nodes = concat(newCurve_nodes, f);
    } 
  
    this.add_Curve(newCurve_nodes);
  }
  
  


  
  
  int add_Solid (float x, float y, float z, float px, float py, float pz, float sx, float sy, float sz, float tx, float ty, float tz, float v) {
  
    {
  
      float[][] newSolid = {
        {
          x, y, z, px, py, pz, sx, sy, sz, tx, ty, tz, v
        }
      };
      allSolids.DEF = (float[][]) concat(allSolids.DEF, newSolid);
    }
  
    if (allGroups.num > 0) allGroups.Solids[allGroups.num - 1][1] = allSolids.DEF.length - 1;
  
    return(allSolids.DEF.length - 1);
  }
  
  
  
  void add_Camera (int n, float x, float y, float z, float s, float rx, float ry, float rz, float rs, float f) {
  
    int[] TempCamera_type = {
      n
    }; 
    allCameras.Type = concat(allCameras.Type, TempCamera_type);
  
    float[][] TempCamera_options = {
      {
        x, y, z, s, rx, ry, rz, rs, f
      }
    };
    allCameras.options = (float[][]) concat(allCameras.options, TempCamera_options);
  
    allCameras.num += 1;
  }
  
  
  void add_Section (int n, float u, float v, float elev, float rot, float dU, float dV, int RES1, int RES2) {
  
    int[] TempSection_Type = {
      n
    }; 
    allSections.Type = concat(allSections.Type, TempSection_Type);
  
    int[] TempSection_RES1 = {
      RES1
    }; 
    allSections.RES1 = concat(allSections.RES1, TempSection_RES1);
  
    int[] TempSection_RES2 = {
      RES2
    }; 
    allSections.RES2 = concat(allSections.RES2, TempSection_RES2);
  
    PImage[] TempSection_SolidImpact = {
      createImage(RES1, RES2, RGB)
    }; 
    allSections.SolidImpact = (PImage[]) concat(allSections.SolidImpact, TempSection_SolidImpact);
  
    PImage[][][] TempSection_SolarImpact = new PImage [1][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      int i = 0;
      for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) {
        for (int q = 0; q < numberOfImpactVariations; q++) { 
          TempSection_SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
        }
      }
    }
    allSections.SolarImpact = (PImage[][][]) concat(allSections.SolarImpact, TempSection_SolarImpact);    
  
    float[][] TempSection_UVERAB = {
      {
        u, v, elev, rot, dU, dV
      }
    };
    allSections.UVERAB = (float[][]) concat(allSections.UVERAB, TempSection_UVERAB);
  
    allSections.num += 1;
  }  
  
  
  
  int beginNewGroup (float x, float y, float z, float sx, float sy, float sz, float rx, float ry, float rz) {
  
    float[][] newObject_PivotMatrix = {
      {
        x, y, z, sx, sy, sz, rx, ry, rz
      }
    }; 
  
    allGroups.PivotMatrix = (float[][]) concat(allGroups.PivotMatrix, newObject_PivotMatrix);
  
    int[][] newObject_Pivot = {
      {
        current_PivotType
      }
    };
  
    allGroups.PivotType = (int[][]) concat(allGroups.PivotType, newObject_Pivot);  
  
  
    int[][] newObject_allModel1Ds = {
      {
        allModel1Ds.num, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.Model1Ds = (int[][]) concat(allGroups.Model1Ds, newObject_allModel1Ds);     
  
    int[][] newObject_allModel2Ds = {
      {
        allModel2Ds.num, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.Model2Ds = (int[][]) concat(allGroups.Model2Ds, newObject_allModel2Ds);   
  
    int[][] newObject_allSolids = {
      {
        allSolids.DEF.length, -1
      }
    }; // i.e. null because start > end 
  
    allGroups.Solids = (int[][]) concat(allGroups.Solids, newObject_allSolids);      
  
    int[][] newObject_Faces = {
      {
        allFaces.nodes.length, -1
      }
    }; // i.e. null because start > end   
  
    allGroups.Faces = (int[][]) concat(allGroups.Faces, newObject_Faces);
  
    int[][] newObject_Curves = {
      {
        allCurves.nodes.length, -1
      }
    }; // i.e. null because start > end   
  
    allGroups.Curves = (int[][]) concat(allGroups.Curves, newObject_Curves);
    
  
  
    allGroups.num += 1;
    
    return(allGroups.num - 1);  
  }
  
  
  
  void duplicate_Selection (int produce_another_variation) {
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      int number_of_allModel1Ds_before = allModel1Ds.num; 
  
      for (int o = 0; o < userSelections.Model1D_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Model1D_ids[o];
  
        float x = allModel1Ds.getX(OBJ_NUM);
        float y = allModel1Ds.getY(OBJ_NUM);
        float z = allModel1Ds.getZ(OBJ_NUM);
        float d = allModel1Ds.getS(OBJ_NUM);
        float rot = allModel1Ds.getR(OBJ_NUM);
  
        int n = allModel1Ds.getType(OBJ_NUM);
        int dMin = allModel1Ds.getDegreeMin(OBJ_NUM);
        int dMax = allModel1Ds.getDegreeMax(OBJ_NUM);
        int s = allModel1Ds.getSeed(OBJ_NUM);
        float TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
        float LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
  
        if (produce_another_variation == 1) randomSeed(millis());
        allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
      }
  
      // selecting new objetcs
  
      userSelections.Model1D_ids = new int [0];
  
      for (int o = number_of_allModel1Ds_before; o < allModel1Ds.num; o++) {
  
        int[] newlyAddedallModel1Ds = {o};
  
        userSelections.Model1D_ids = concat(userSelections.Model1D_ids, newlyAddedallModel1Ds);
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      int n1 = allModel2Ds.num_files_PEOPLE;
  
      int number_of_allModel2Ds_before = allModel2Ds.num; 
  
      for (int o = 0; o < userSelections.Model2D_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Model2D_ids[o];
  
        float x = allModel2Ds.getX(OBJ_NUM);
        float y = allModel2Ds.getY(OBJ_NUM);
        float z = allModel2Ds.getZ(OBJ_NUM);
        float s = allModel2Ds.getS(OBJ_NUM);
  
        int n = allModel2Ds.MAP[OBJ_NUM];
        if (abs(n) > n1) {
          if (produce_another_variation == 1) n = 0; // this makes it random
          allModel2Ds.add_single("TREES", n, x, y, z, s);
        } else {
          if (produce_another_variation == 1) n = 0; // this makes it random
          allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
        }
      }
  
      // selecting new objetcs
  
      userSelections.Model2D_ids = new int [0];
  
      for (int o = number_of_allModel2Ds_before; o < allModel2Ds.num; o++) {
  
        int[] newlyAddedallModel2Ds = {o};
  
        userSelections.Model2D_ids = concat(userSelections.Model2D_ids, newlyAddedallModel2Ds);
      }
    }
  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      int number_of_Faces_before = allFaces.nodes.length;
  
      for (int o = 0; o < userSelections.Face_ids.length; o++) {
  
        int f = userSelections.Face_ids[o];        
  
        int number_of_Vertices_before = allPoints.getLength();
  
        int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
        if ((0 <= f) && (f < allFaces.nodes.length)) {
  
          int[] newFace_nodes = {
          };
  
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
            int vNo = allFaces.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
              if (vNo == PolymeshVertices_OLD[q]) {
                vertex_listed = q;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
              float x = allPoints.getX(vNo);
              float y = allPoints.getY(vNo);
              float z = allPoints.getZ(vNo);
  
              int[] newVertexAdded = {
                this.add_Vertex(x, y, z)
              };
              PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
              vertex_listed = PolymeshVertices_OLD.length;
            } 
  
            //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
  
            int[] new_vertexItem = {
              number_of_Vertices_before + vertex_listed - 1
            };
  
            newFace_nodes = concat(newFace_nodes, new_vertexItem);
          }
  
          current_Material = allFaces.getMaterial(f);
          current_Tessellation = allFaces.getTessellation(f);
          current_Layer = allFaces.getLayer(f);
          current_Visibility = allFaces.getVisibility(f);        
  
          this.add_Face(newFace_nodes);
        }
      }
  
  
      // selecting new objetcs
  
      userSelections.Face_ids = new int [0];
  
      for (int o = number_of_Faces_before; o < allFaces.nodes.length; o++) {
  
        int[] newlyAddedFace = {o};
  
        userSelections.Face_ids = concat(userSelections.Face_ids, newlyAddedFace);
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      int number_of_Curves_before = allCurves.nodes.length;
  
      for (int o = 0; o < userSelections.Curve_ids.length; o++) {
  
        int f = userSelections.Curve_ids[o];        
  
        int number_of_Vertices_before = allPoints.getLength();
  
        int[] PolymeshVertices_OLD = new int [0];  // keeps the list of exiting vertex numbers
        int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
        if ((0 <= f) && (f < allCurves.nodes.length)) {
  
          int[] newCurve_nodes = {
          };
  
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
            int vNo = allCurves.nodes[f][j];
  
            int vertex_listed = -1;
  
            for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
              if (vNo == PolymeshVertices_OLD[q]) {
                vertex_listed = q;
                break;
              }
            }         
  
            if (vertex_listed == -1) {
              int[] newVertexListed = {
                vNo
              };
              PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
              float x = allPoints.getX(vNo);
              float y = allPoints.getY(vNo);
              float z = allPoints.getZ(vNo);
  
              int[] newVertexAdded = {
                this.add_Vertex(x, y, z)
              };
              PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
              vertex_listed = PolymeshVertices_OLD.length;
            } 
  
            //println("number_of_Vertices_before + vertex_listed - 1", number_of_Vertices_before + vertex_listed - 1);
  
            int[] new_vertexItem = {
              number_of_Vertices_before + vertex_listed - 1
            };
  
            newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
          }
  
          current_Material = allCurves.getMaterial(f);
          current_Tessellation = allCurves.getTessellation(f);
          current_Layer = allCurves.getLayer(f);
          current_Visibility = allCurves.getVisibility(f);        
          current_Weight = allCurves.getWeight(f);
          current_Closed = allCurves.getClose(f);
  
          this.add_Curve(newCurve_nodes);
        }
      }
  
  
      // selecting new objetcs
  
      userSelections.Curve_ids = new int [0];
  
      for (int o = number_of_Curves_before; o < allCurves.nodes.length; o++) {
  
        int[] newlyAddedCurve = {o};
  
        userSelections.Curve_ids = concat(userSelections.Curve_ids, newlyAddedCurve);
      }
    }
  
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      int number_of_Solid_before = allSolids.DEF.length; 
  
      for (int o = 0; o < userSelections.Solid_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Solid_ids[o];
  
        float Solid_posX = allSolids.get_posX(OBJ_NUM);
        float Solid_posY = allSolids.get_posY(OBJ_NUM);
        float Solid_posZ = allSolids.get_posZ(OBJ_NUM);
        float Solid_powX = allSolids.get_powX(OBJ_NUM);
        float Solid_powY = allSolids.get_powY(OBJ_NUM);
        float Solid_powZ = allSolids.get_powZ(OBJ_NUM);
        float Solid_scaleX = allSolids.get_scaleX(OBJ_NUM);
        float Solid_scaleY = allSolids.get_scaleY(OBJ_NUM);
        float Solid_scaleZ = allSolids.get_scaleZ(OBJ_NUM);
        float Solid_rotX = allSolids.get_rotX(OBJ_NUM);
        float Solid_rotY = allSolids.get_rotY(OBJ_NUM);
        float Solid_rotZ = allSolids.get_rotZ(OBJ_NUM);
        float Solid_value = allSolids.get_value(OBJ_NUM);
  
        this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
      }
  
      // selecting new objetcs
  
      userSelections.Solid_ids = new int [0];
  
      for (int o = number_of_Solid_before; o < allSolids.DEF.length; o++) {
  
        int[] newlyAddedSolid = {o};
  
        userSelections.Solid_ids = concat(userSelections.Solid_ids, newlyAddedSolid);
      }
    }    
  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      int number_of_Section_before = allSections.num; 
  
      for (int o = 0; o < userSelections.Section_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Section_ids[o];
  
        float Section_U_offset = allSections.UVERAB[OBJ_NUM][0];
        float Section_V_offset = allSections.UVERAB[OBJ_NUM][1];
        float Section_elevation = allSections.UVERAB[OBJ_NUM][2];
        float Section_rotation = allSections.UVERAB[OBJ_NUM][3];
        float Section_U_scale = allSections.UVERAB[OBJ_NUM][4];
        float Section_V_scale = allSections.UVERAB[OBJ_NUM][5];
  
        int Section_Type = allSections.Type[OBJ_NUM];
        int Section_RES1 = allSections.RES1[OBJ_NUM];
        int Section_RES2 = allSections.RES2[OBJ_NUM];
  
        this.add_Section(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
      }
  
      // selecting new objetcs
  
      userSelections.Section_ids = new int [0];
  
      for (int o = number_of_Section_before; o < allSections.num; o++) {
  
        int[] newlyAddedSection = {o};
  
        userSelections.Section_ids = concat(userSelections.Section_ids, newlyAddedSection);
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      int number_of_Camera_before = allCameras.num; 
  
      for (int o = 0; o < userSelections.Camera_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Camera_ids[o];
  
        float Camera_pX = allCameras.options[OBJ_NUM][0];
        float Camera_pY = allCameras.options[OBJ_NUM][1];
        float Camera_pZ = allCameras.options[OBJ_NUM][2];
        float Camera_pT = allCameras.options[OBJ_NUM][3];
        float Camera_rX = allCameras.options[OBJ_NUM][4];
        float Camera_rY = allCameras.options[OBJ_NUM][5];
        float Camera_rZ = allCameras.options[OBJ_NUM][6];
        float Camera_rT = allCameras.options[OBJ_NUM][7];
        float Camera_ZOOM = allCameras.options[OBJ_NUM][8];
  
        int Camera_type = allCameras.Type[OBJ_NUM];
  
        this.add_Camera(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_ZOOM);
      }
  
      // selecting new objetcs
  
      userSelections.Camera_ids = new int [0];
  
      for (int o = number_of_Camera_before; o < allCameras.num; o++) {
  
        int[] newlyAddedCamera = {o};
  
        userSelections.Camera_ids = concat(userSelections.Camera_ids, newlyAddedCamera);
      }
    }  
  
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      int n1 = allModel2Ds.num_files_PEOPLE;
  
      int SOLID_added = 0;
  
      int number_of_allGroups_before = allGroups.num;
  
      for (int o = 0; o < userSelections.Group_ids.length; o++) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        if ((0 <= allGroups.Faces[OBJ_NUM][0]) && (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1])) { 
  
          int number_of_Vertices_before = allPoints.getLength();
  
          this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
          int new_OBJ_NUM = allGroups.num - 1;
  
          allGroups.PivotType[new_OBJ_NUM][0] = allGroups.PivotType[OBJ_NUM][0];
  
          for (int j = 0; j < allGroups.PivotMatrix[OBJ_NUM].length; j++) { 
            allGroups.PivotMatrix[new_OBJ_NUM][j] = allGroups.PivotMatrix[OBJ_NUM][j];
          }
  
          if ((0 <= allGroups.Model1Ds[OBJ_NUM][1]) && (allGroups.Model1Ds[OBJ_NUM][0] <= allGroups.Model1Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.Model1Ds[OBJ_NUM][0]; q <= allGroups.Model1Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel1Ds.getX(q);
              float y = allModel1Ds.getY(q);
              float z = allModel1Ds.getZ(q);
  
              float d = allModel1Ds.getS(q);
              float rot = allModel1Ds.getR(q);
  
              int n = allModel1Ds.getType(q);
  
              int dMin = allModel1Ds.getDegreeMin(q);
  
              int dMax = allModel1Ds.getDegreeMax(q);
  
              int s = allModel1Ds.getSeed(q);
  
              float TrunkSize = allModel1Ds.getTrunkSize(q);
  
              float LeafSize = allModel1Ds.getLeafSize(q);
  
              if (produce_another_variation == 1) {
                randomSeed(millis());
  
                rot = random(360);
                s = int(random(32767));
              }
              allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
            }
          }
  
          if ((0 <= allGroups.Model2Ds[OBJ_NUM][1]) && (allGroups.Model2Ds[OBJ_NUM][0] <= allGroups.Model2Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.Model2Ds[OBJ_NUM][0]; q <= allGroups.Model2Ds[OBJ_NUM][1]; q++) {
    
              float x = allModel2Ds.getX(q);
              float y = allModel2Ds.getY(q);
              float z = allModel2Ds.getZ(q);
              float s = allModel2Ds.getS(q);
    
              int n = allModel2Ds.MAP[q];
    
              if (abs(n) > n1) {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("TREES", n, x, y, z, s);
              } else {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
              }
            }
          }
  
  
          if ((0 <= allGroups.Solids[OBJ_NUM][1]) && (allGroups.Solids[OBJ_NUM][0] <= allGroups.Solids[OBJ_NUM][1])) { 
            for (int q = allGroups.Solids[OBJ_NUM][0]; q <= allGroups.Solids[OBJ_NUM][1]; q++) {
  
              float Solid_posX = allSolids.get_posX(q);
              float Solid_posY = allSolids.get_posY(q);
              float Solid_posZ = allSolids.get_posZ(q);
              float Solid_powX = allSolids.get_powX(q);
              float Solid_powY = allSolids.get_powY(q);
              float Solid_powZ = allSolids.get_powZ(q);
              float Solid_scaleX = allSolids.get_scaleX(q);
              float Solid_scaleY = allSolids.get_scaleY(q);
              float Solid_scaleZ = allSolids.get_scaleZ(q);
              float Solid_rotX = allSolids.get_rotX(q);
              float Solid_rotY = allSolids.get_rotY(q);
              float Solid_rotZ = allSolids.get_rotZ(q);
              float Solid_value = allSolids.get_value(q);
  
              this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
              SOLID_added += 1;
            }
          }
  
  
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
  
            if ((0 <= f) && (f < allFaces.nodes.length)) {
  
              int[] newFace_nodes = {
              };
  
              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                int vNo = allFaces.nodes[f][j];
  
                int vertex_listed = -1;
  
                for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;
                  }
                }         
  
                if (vertex_listed == -1) {
                  int[] newVertexListed = {
                    vNo
                  };
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                  float x = allPoints.getX(vNo);
                  float y = allPoints.getY(vNo);
                  float z = allPoints.getZ(vNo);
  
                  int[] newVertexAdded = {
                    this.add_Vertex(x, y, z)
                  };
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                  vertex_listed = PolymeshVertices_OLD.length - 1;
                }
  
                int[] new_vertexItem = {
                  number_of_Vertices_before + vertex_listed
                };
  
                newFace_nodes = concat(newFace_nodes, new_vertexItem);
              }
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);
  
              this.add_Face(newFace_nodes);
              
              println("newFace_nodes");
              println(newFace_nodes);
            }
          }
        }
        
        if ((0 <= allGroups.Curves[OBJ_NUM][0]) && (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1])) { 
  
          int number_of_Vertices_before = allPoints.getLength();
  
          this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
          int new_OBJ_NUM = allGroups.num - 1;
  
          allGroups.PivotType[new_OBJ_NUM][0] = allGroups.PivotType[OBJ_NUM][0];
  
          for (int j = 0; j < allGroups.PivotMatrix[OBJ_NUM].length; j++) { 
            allGroups.PivotMatrix[new_OBJ_NUM][j] = allGroups.PivotMatrix[OBJ_NUM][j];
          }
  
          if ((0 <= allGroups.Model1Ds[OBJ_NUM][1]) && (allGroups.Model1Ds[OBJ_NUM][0] <= allGroups.Model1Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.Model1Ds[OBJ_NUM][0]; q <= allGroups.Model1Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel1Ds.getX(q);
              float y = allModel1Ds.getY(q);
              float z = allModel1Ds.getZ(q);
  
              float d = allModel1Ds.getS(q);
              float rot = allModel1Ds.getR(q);
  
              int n = allModel1Ds.getType(q);
  
              int dMin = allModel1Ds.getDegreeMin(q);
  
              int dMax = allModel1Ds.getDegreeMax(q);
  
              int s = allModel1Ds.getSeed(q);
  
              float TrunkSize = allModel1Ds.getTrunkSize(q);
  
              float LeafSize = allModel1Ds.getLeafSize(q);
  
              if (produce_another_variation == 1) {
                randomSeed(millis());
  
                rot = random(360);
                s = int(random(32767));
              }
              allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
            }
          }
  
          if ((0 <= allGroups.Model2Ds[OBJ_NUM][1]) && (allGroups.Model2Ds[OBJ_NUM][0] <= allGroups.Model2Ds[OBJ_NUM][1])) { 
            for (int q = allGroups.Model2Ds[OBJ_NUM][0]; q <= allGroups.Model2Ds[OBJ_NUM][1]; q++) {
  
              float x = allModel2Ds.getX(q);
              float y = allModel2Ds.getY(q);
              float z = allModel2Ds.getZ(q);
              float s = allModel2Ds.getS(q);
  
              int n = allModel2Ds.MAP[q];
  
              if (abs(n) > n1) {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("TREES", n, x, y, z, s);
              } else {
                if (produce_another_variation == 1) n = 0; // this makes it random
                allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
              }
            }
          }
  
          if ((0 <= allGroups.Solids[OBJ_NUM][1]) && (allGroups.Solids[OBJ_NUM][0] <= allGroups.Solids[OBJ_NUM][1])) { 
            for (int q = allGroups.Solids[OBJ_NUM][0]; q <= allGroups.Solids[OBJ_NUM][1]; q++) {
  
              float Solid_posX = allSolids.get_posX(q);
              float Solid_posY = allSolids.get_posY(q);
              float Solid_posZ = allSolids.get_posZ(q);
              float Solid_powX = allSolids.get_powX(q);
              float Solid_powY = allSolids.get_powY(q);
              float Solid_powZ = allSolids.get_powZ(q);
              float Solid_scaleX = allSolids.get_scaleX(q);
              float Solid_scaleY = allSolids.get_scaleY(q);
              float Solid_scaleZ = allSolids.get_scaleZ(q);
              float Solid_rotX = allSolids.get_rotX(q);
              float Solid_rotY = allSolids.get_rotY(q);
              float Solid_rotZ = allSolids.get_rotZ(q);
              float Solid_value = allSolids.get_value(q);
  
              this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
  
              SOLID_added += 1;
            }
          }
  
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
  
            if ((0 <= f) && (f < allCurves.nodes.length)) {
  
              int[] newCurve_nodes = {
              };
  
              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                int vNo = allCurves.nodes[f][j];
  
                int vertex_listed = -1;
  
                for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                  if (vNo == PolymeshVertices_OLD[q]) {
                    vertex_listed = q;
                    break;
                  }
                }         
  
                if (vertex_listed == -1) {
                  int[] newVertexListed = {
                    vNo
                  };
                  PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                  float x = allPoints.getX(vNo);
                  float y = allPoints.getY(vNo);
                  float z = allPoints.getZ(vNo);
  
                  int[] newVertexAdded = {
                    this.add_Vertex(x, y, z)
                  };
                  PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                  vertex_listed = PolymeshVertices_OLD.length - 1;
                } 
  
                int[] new_vertexItem = {
                  number_of_Vertices_before + vertex_listed
                };
  
                newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
              }
  
              current_Material = allCurves.getMaterial(f);
              current_Tessellation = allCurves.getTessellation(f);
              current_Layer = allCurves.getLayer(f);
              current_Visibility = allCurves.getVisibility(f);
              current_Weight = allCurves.getWeight(f);
              current_Closed = allCurves.getClose(f);
  
              this.add_Curve(newCurve_nodes);
            }
          }
        }        
      }
    
  
  
      // selecting new objetcs
  
      userSelections.Group_ids = new int [0];
  
      for (int o = number_of_allGroups_before; o < allGroups.num; o++) {
  
        int[] newlyAddedGroup = {o};
  
        userSelections.Group_ids = concat(userSelections.Group_ids, newlyAddedGroup);
      }       
  
  
      if (SOLID_added != 0) allSolidImpacts.calculate_Impact_selectedSections();
    }
  }
  
  
  
  
  
  void group_Selection (int createNewGroup) { // if this option == 0 then the objects are added to the last group
  
  
    int run_process = 0;
  
    if (current_ObjectCategory == ObjectCategory.SOLID) run_process = 1;
    if (current_ObjectCategory == ObjectCategory.FACE) run_process = 1;
    if (current_ObjectCategory == ObjectCategory.CURVE) run_process = 1;
    if (current_ObjectCategory == ObjectCategory.MODEL2D) run_process = 1;
    if (current_ObjectCategory == ObjectCategory.MODEL1D) run_process = 1;
  
    if (run_process == 1) {
  
      if (createNewGroup == 1) {
        float x = userSelections.BoundingBox[1 + userSelections.alignX][0];
        float y = userSelections.BoundingBox[1 + userSelections.alignX][1];
        float z = userSelections.BoundingBox[1 + userSelections.alignX][2];
  
        float rot = User3D.create_Orientation;
        if (rot == 360) rot = WIN3D.rotation_Z;
  
        this.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
      }
  
  
      boolean pre_addToLastGroup = addToLastGroup;
      addToLastGroup = true;
  
  
      if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
        for (int o = 0; o < userSelections.Model1D_ids.length; o++) {
  
          int OBJ_NUM = userSelections.Model1D_ids[o];
  
          float x = allModel1Ds.getX(OBJ_NUM);
          float y = allModel1Ds.getY(OBJ_NUM);
          float z = allModel1Ds.getZ(OBJ_NUM);
          float d = allModel1Ds.getS(OBJ_NUM);
          float rot = allModel1Ds.getR(OBJ_NUM);
  
          int n = allModel1Ds.getType(OBJ_NUM);
          int dMin = allModel1Ds.getDegreeMin(OBJ_NUM);
          int dMax = allModel1Ds.getDegreeMax(OBJ_NUM);
          int s = allModel1Ds.getSeed(OBJ_NUM);
          float TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
          float LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
  
          allModel1Ds.add_single(n, x, y, z, d, rot, dMin, dMax, s, TrunkSize, LeafSize);
        }
      }  
  
      if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
        int n1 = allModel2Ds.num_files_PEOPLE;
  
        for (int o = 0; o < userSelections.Model2D_ids.length; o++) {
  
          int OBJ_NUM = userSelections.Model2D_ids[o];
  
          float x = allModel2Ds.getX(OBJ_NUM);
          float y = allModel2Ds.getY(OBJ_NUM);
          float z = allModel2Ds.getZ(OBJ_NUM);
          float s = allModel2Ds.getS(OBJ_NUM);
  
          int n = allModel2Ds.MAP[OBJ_NUM];
          if (abs(n) > n1) {
            allModel2Ds.add_single("TREES", n, x, y, z, s);
          } else {
            allModel2Ds.add_single("PEOPLE", n, x, y, z, s);
          }
        }
      }
  
  
      if (current_ObjectCategory == ObjectCategory.SOLID) {
  
        for (int o = 0; o < userSelections.Solid_ids.length; o++) {
  
          int OBJ_NUM = userSelections.Solid_ids[o];
  
          float Solid_posX = allSolids.get_posX(OBJ_NUM);
          float Solid_posY = allSolids.get_posY(OBJ_NUM);
          float Solid_posZ = allSolids.get_posZ(OBJ_NUM);
          float Solid_powX = allSolids.get_powX(OBJ_NUM);
          float Solid_powY = allSolids.get_powY(OBJ_NUM);
          float Solid_powZ = allSolids.get_powZ(OBJ_NUM);
          float Solid_scaleX = allSolids.get_scaleX(OBJ_NUM);
          float Solid_scaleY = allSolids.get_scaleY(OBJ_NUM);
          float Solid_scaleZ = allSolids.get_scaleZ(OBJ_NUM);
          float Solid_rotX = allSolids.get_rotX(OBJ_NUM);
          float Solid_rotY = allSolids.get_rotY(OBJ_NUM);
          float Solid_rotZ = allSolids.get_rotZ(OBJ_NUM);
          float Solid_value = allSolids.get_value(OBJ_NUM);
  
          this.add_Solid(Solid_posX, Solid_posY, Solid_posZ, Solid_powX, Solid_powY, Solid_powZ, Solid_scaleX, Solid_scaleY, Solid_scaleZ, Solid_rotX, Solid_rotY, Solid_rotZ, Solid_value);
        }
      }
  
  
  
  
      if (current_ObjectCategory == ObjectCategory.FACE) {
  
        for (int o = 0; o < userSelections.Face_ids.length; o++) {
  
          int f = userSelections.Face_ids[o];        
  
          int number_of_Vertices_before = allPoints.getLength();
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          if ((0 <= f) && (f < allFaces.nodes.length)) {
  
            int[] newFace_nodes = {
            };
  
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
  
              int vertex_listed = -1;
  
              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }         
  
              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);
  
                int[] newVertexAdded = {
                  this.add_Vertex(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                vertex_listed = PolymeshVertices_OLD.length - 1;
              } 
  
              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };
  
              newFace_nodes = concat(newFace_nodes, new_vertexItem);
            }
  
            current_Material = allFaces.getMaterial(f);
            current_Tessellation = allFaces.getTessellation(f);
            current_Layer = allFaces.getLayer(f);
            current_Visibility = allFaces.getVisibility(f);        
  
            this.add_Face(newFace_nodes);
          }
        }
      }
  
  
      if (current_ObjectCategory == ObjectCategory.CURVE) {
  
        for (int o = 0; o < userSelections.Curve_ids.length; o++) {
  
          int f = userSelections.Curve_ids[o];        
  
          int number_of_Vertices_before = allPoints.getLength();
  
          int[] PolymeshVertices_OLD = new int [0]; // keeps the list of exiting vertex numbers
          int[] PolymeshVertices_NEW = new int [0]; // keeps the list of new vertex numbers
  
          if ((0 <= f) && (f < allCurves.nodes.length)) {
  
            int[] newCurve_nodes = {
            };
  
            for (int j = 0; j < allCurves.nodes[f].length; j++) {
              int vNo = allCurves.nodes[f][j];
  
              int vertex_listed = -1;
  
              for (int q = 0; q < PolymeshVertices_OLD.length; q++) {
                if (vNo == PolymeshVertices_OLD[q]) {
                  vertex_listed = q;
                  break;
                }
              }         
  
              if (vertex_listed == -1) {
                int[] newVertexListed = {
                  vNo
                };
                PolymeshVertices_OLD = concat(PolymeshVertices_OLD, newVertexListed);
  
                float x = allPoints.getX(vNo);
                float y = allPoints.getY(vNo);
                float z = allPoints.getZ(vNo);
  
                int[] newVertexAdded = {
                  this.add_Vertex(x, y, z)
                };
                PolymeshVertices_NEW = concat(PolymeshVertices_NEW, newVertexAdded);
  
                vertex_listed = PolymeshVertices_OLD.length - 1;
              } 
  
              int[] new_vertexItem = {
                number_of_Vertices_before + vertex_listed
              };
  
              newCurve_nodes = concat(newCurve_nodes, new_vertexItem);
            }
  
            current_Material = allCurves.getMaterial(f);
            current_Tessellation = allCurves.getTessellation(f);
            current_Layer = allCurves.getLayer(f);
            current_Visibility = allCurves.getVisibility(f);      
            current_Weight = allCurves.getWeight(f);
            current_Closed = allCurves.getClose(f);          
  
            this.add_Curve(newCurve_nodes);
          }
        }
      }
  
  
  
      addToLastGroup = pre_addToLastGroup;
  
  
      this.delete_Selection();
  
  
      userSelections.Group_ids = new int [1];
      userSelections.Group_ids[0] = allGroups.num - 1;
  
  
      current_ObjectCategory = ObjectCategory.GROUP;
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void ungroup_Selection () {
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
  
      userSelections.Group_ids = sort(userSelections.Group_ids);
  
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        allGroups.Faces[OBJ_NUM][0] = 0;
        allGroups.Faces[OBJ_NUM][1] = -1;
  
        allGroups.Curves[OBJ_NUM][0] = 0;
        allGroups.Curves[OBJ_NUM][1] = -1;
  
        allGroups.Model1Ds[OBJ_NUM][0] = 0;
        allGroups.Model1Ds[OBJ_NUM][1] = -1;
  
        allGroups.Model2Ds[OBJ_NUM][0] = 0;
        allGroups.Model2Ds[OBJ_NUM][1] = -1;
  
        allGroups.Solids[OBJ_NUM][0] = 0;
        allGroups.Solids[OBJ_NUM][1] = -1;
      }
  
      this.delete_Selection();
    }
  }
  
  
  void dettachFromallGroups_Selection () {
  
    this.group_Selection(1);
    this.ungroup_Selection();
  }
  
  
  void deleteEmptyallGroups_Scene () {
  
    int pre_current_ObjectCategory = current_ObjectCategory;
  
    current_ObjectCategory = ObjectCategory.GROUP;
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {  
  
      userSelections.Group_ids = new int [0];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        int notEmpty = 0;
  
        if ((0 <= allGroups.Faces[OBJ_NUM][0]) && (allGroups.Faces[OBJ_NUM][0] <= allGroups.Faces[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.Curves[OBJ_NUM][0]) && (allGroups.Curves[OBJ_NUM][0] <= allGroups.Curves[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.Model1Ds[OBJ_NUM][0]) && (allGroups.Model1Ds[OBJ_NUM][0] <= allGroups.Model1Ds[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.Model2Ds[OBJ_NUM][0]) && (allGroups.Model2Ds[OBJ_NUM][0] <= allGroups.Model2Ds[OBJ_NUM][1])) notEmpty = 1;
        if ((0 <= allGroups.Solids[OBJ_NUM][0]) && (allGroups.Solids[OBJ_NUM][0] <= allGroups.Solids[OBJ_NUM][1])) notEmpty = 1;
  
        if (notEmpty == 0) {
  
          int[] emptyGroup = {
            OBJ_NUM
          };
  
          userSelections.Group_ids = concat(userSelections.Group_ids, emptyGroup);
        }
      }
  
      this.delete_Selection();
    }
  
    current_ObjectCategory = pre_current_ObjectCategory;
  }
  
  
  
  void delete_Selection () {
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
    }
  
  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
  
      userSelections.Camera_ids = sort(userSelections.Camera_ids);
  
      for (int o = userSelections.Camera_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Camera_ids[o];
  
        {
          float[][] startList = (float[][]) subset(allCameras.options, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allCameras.options, OBJ_NUM + 1);
  
          allCameras.options = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allCameras.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allCameras.Type, OBJ_NUM + 1);
  
          allCameras.Type = (int[]) concat(startList, endList);
        }
  
        allCameras.num -= 1;
  
        if (OBJ_NUM == WIN3D.currentCamera) {
    
          WIN3D.currentCamera = 0;
          
          SOLARCHVISION_modify_Viewport_Title();
        }
      }
    }
  
  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
  
      userSelections.Section_ids = sort(userSelections.Section_ids);
  
      for (int o = userSelections.Section_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Section_ids[o];
  
        {
          float[][] startList = (float[][]) subset(allSections.UVERAB, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSections.UVERAB, OBJ_NUM + 1);
  
          allSections.UVERAB = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.Type, OBJ_NUM + 1);
  
          allSections.Type = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.RES1, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.RES1, OBJ_NUM + 1);
  
          allSections.RES1 = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allSections.RES2, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allSections.RES2, OBJ_NUM + 1);
  
          allSections.RES2 = (int[]) concat(startList, endList);
        }
  
        {
          PImage[] startList = (PImage[]) subset(allSections.SolidImpact, 0, OBJ_NUM);
          PImage[] endList = (PImage[]) subset(allSections.SolidImpact, OBJ_NUM + 1);
  
          allSections.SolidImpact = (PImage[]) concat(startList, endList);
        }
  
        {
          PImage[][][] startList = (PImage[][][]) subset(allSections.SolarImpact, 0, OBJ_NUM);
          PImage[][][] endList = (PImage[][][]) subset(allSections.SolarImpact, OBJ_NUM + 1);
  
          allSections.SolarImpact = (PImage[][][]) concat(startList, endList);
        }        
  
        allSections.num -= 1;
      }
    }
  
  
  
  
  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
      userSelections.Model1D_ids = sort(userSelections.Model1D_ids);
  
      for (int o = userSelections.Model1D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Model1D_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Model1Ds[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Model1Ds[q][1])) {
            if (allGroups.Model1Ds[q][1] >= 0) allGroups.Model1Ds[q][1] -= 1;
          } else if (allGroups.Model1Ds[q][0] > OBJ_NUM) {
            if (allGroups.Model1Ds[q][0] >= 0) allGroups.Model1Ds[q][0] -= 1;
            if (allGroups.Model1Ds[q][1] >= 0) allGroups.Model1Ds[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allModel1Ds.XYZSR, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allModel1Ds.XYZSR, OBJ_NUM + 1);
  
          allModel1Ds.XYZSR = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.Type, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.Type, OBJ_NUM + 1);
  
          allModel1Ds.Type = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.DegreeMin, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.DegreeMin, OBJ_NUM + 1);
  
          allModel1Ds.DegreeMin = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.DegreeMax, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.DegreeMax, OBJ_NUM + 1);
  
          allModel1Ds.DegreeMax = (int[]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel1Ds.Seed, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel1Ds.Seed, OBJ_NUM + 1);
  
          allModel1Ds.Seed = (int[]) concat(startList, endList);
        }
  
        {
          float[] startList = (float[]) subset(allModel1Ds.TrunkSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allModel1Ds.TrunkSize, OBJ_NUM + 1);
  
          allModel1Ds.TrunkSize = (float[]) concat(startList, endList);
        }
  
        {
          float[] startList = (float[]) subset(allModel1Ds.LeafSize, 0, OBJ_NUM);
          float[] endList = (float[]) subset(allModel1Ds.LeafSize, OBJ_NUM + 1);
  
          allModel1Ds.LeafSize = (float[]) concat(startList, endList);
        }
  
        allModel1Ds.num -= 1;
      }
    }
  
  
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
      userSelections.Model2D_ids = sort(userSelections.Model2D_ids);
  
      for (int o = userSelections.Model2D_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Model2D_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Model2Ds[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Model2Ds[q][1])) {
            if (allGroups.Model2Ds[q][1] >= 0) allGroups.Model2Ds[q][1] -= 1;
          } else if (allGroups.Model2Ds[q][0] > OBJ_NUM) {
            if (allGroups.Model2Ds[q][0] >= 0) allGroups.Model2Ds[q][0] -= 1;
            if (allGroups.Model2Ds[q][1] >= 0) allGroups.Model2Ds[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allModel2Ds.XYZS, OBJ_NUM + 1);
  
          allModel2Ds.XYZS = (float[][]) concat(startList, endList);
        }
  
        {
          int[] startList = (int[]) subset(allModel2Ds.MAP, 0, OBJ_NUM);
          int[] endList = (int[]) subset(allModel2Ds.MAP, OBJ_NUM + 1);
  
          allModel2Ds.MAP = (int[]) concat(startList, endList);
        }   
  
        allModel2Ds.num -= 1;
      }
  
    }
  
  
  
  
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
  
      userSelections.Solid_ids = sort(userSelections.Solid_ids);
  
      for (int o = userSelections.Solid_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Solid_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Solids[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Solids[q][1])) {
            if (allGroups.Solids[q][1] >= 0) allGroups.Solids[q][1] -= 1;
          } else if (allGroups.Solids[q][0] > OBJ_NUM) {
            if (allGroups.Solids[q][0] >= 0) allGroups.Solids[q][0] -= 1;
            if (allGroups.Solids[q][1] >= 0) allGroups.Solids[q][1] -= 1;
          }
        }
  
  
        {
          float[][] startList = (float[][]) subset(allSolids.DEF, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allSolids.DEF, OBJ_NUM + 1);
  
          allSolids.DEF = (float[][]) concat(startList, endList);
        }
      }
    }
  
  
  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
  
      userSelections.Face_ids = sort(userSelections.Face_ids);
  
      for (int o = userSelections.Face_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Face_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Faces[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Faces[q][1])) {
            if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
          } else if (allGroups.Faces[q][0] > OBJ_NUM) {
            if (allGroups.Faces[q][0] >= 0) allGroups.Faces[q][0] -= 1;
            if (allGroups.Faces[q][1] >= 0) allGroups.Faces[q][1] -= 1;
          }
        }
  
  
        {
          int[][] startList = (int[][]) subset(allFaces.nodes, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces.nodes, OBJ_NUM + 1);
  
          allFaces.nodes = (int[][]) concat(startList, endList);
        }
  
        {
          int[][] startList = (int[][]) subset(allFaces.options, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allFaces.options, OBJ_NUM + 1);
  
          allFaces.options = (int[][]) concat(startList, endList);
        }
      }
    }
  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
  
      userSelections.Curve_ids = sort(userSelections.Curve_ids);
  
      for (int o = userSelections.Curve_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Curve_ids[o];
  
        for (int q = 0; q < allGroups.num; q++) {
  
          if ((allGroups.Curves[q][0] <= OBJ_NUM) && (OBJ_NUM <= allGroups.Curves[q][1])) {
            if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
          } else if (allGroups.Curves[q][0] > OBJ_NUM) {
            if (allGroups.Curves[q][0] >= 0) allGroups.Curves[q][0] -= 1;
            if (allGroups.Curves[q][1] >= 0) allGroups.Curves[q][1] -= 1;
          }
        }
  
  
        {
          int[][] startList = (int[][]) subset(allCurves.nodes, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allCurves.nodes, OBJ_NUM + 1);
  
          allCurves.nodes = (int[][]) concat(startList, endList);
        }
  
        {
          int[][] startList = (int[][]) subset(allCurves.options, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allCurves.options, OBJ_NUM + 1);
  
          allCurves.options = (int[][]) concat(startList, endList);
        }
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      
      /////////////////////////////
      //SOLARCHVISION_hold_project();
      /////////////////////////////    
      
      
      
      this.convert_allGroups_to_Vertices(); // finding vertices so that we could delete the isolated ones later  
  
      userSelections.Group_ids = sort(userSelections.Group_ids);
  
      boolean allSolids_updated = false;  
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        int startFace = allGroups.Faces[OBJ_NUM][0];
        int endFace = allGroups.Faces[OBJ_NUM][1];
  
        {
  
          if ((0 <= startFace) && (startFace <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] -= 1 + endFace - startFace;
  
                if (allGroups.Faces[i][j] < 0) allGroups.Faces[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.Faces, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Faces, OBJ_NUM + 1);
  
          allGroups.Faces = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startFace) && (startFace <= endFace)) {
          {
            int[][] startList = (int[][]) subset(allFaces.nodes, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces.nodes, endFace + 1);
  
            allFaces.nodes = (int[][]) concat(startList, endList);
          }
  
          {
            int[][] startList = (int[][]) subset(allFaces.options, 0, startFace);
            int[][] endList = (int[][]) subset(allFaces.options, endFace + 1);
  
            allFaces.options = (int[][]) concat(startList, endList);
          }
        }
  
  
        int startCurve = allGroups.Curves[OBJ_NUM][0];
        int endCurve = allGroups.Curves[OBJ_NUM][1];
  
        {
  
          if ((0 <= startCurve) && (startCurve <= endCurve)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Curves[i][j] -= 1 + endCurve - startCurve;
  
                if (allGroups.Curves[i][j] < 0) allGroups.Curves[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.Curves, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Curves, OBJ_NUM + 1);
  
          allGroups.Curves = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startCurve) && (startCurve <= endCurve)) {
          {
            int[][] startList = (int[][]) subset(allCurves.nodes, 0, startCurve);
            int[][] endList = (int[][]) subset(allCurves.nodes, endCurve + 1);
  
            allCurves.nodes = (int[][]) concat(startList, endList);
          }
  
          {
            int[][] startList = (int[][]) subset(allCurves.options, 0, startCurve);
            int[][] endList = (int[][]) subset(allCurves.options, endCurve + 1);
  
            allCurves.options = (int[][]) concat(startList, endList);
          }
        }
  
  
        int startallModel1Ds = allGroups.Model1Ds[OBJ_NUM][0];
        int endallModel1Ds = allGroups.Model1Ds[OBJ_NUM][1];
  
        {
  
          if ((0 <= startallModel1Ds) && (startallModel1Ds <= endallModel1Ds)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
  
                allGroups.Model1Ds[i][j] -= 1 + endallModel1Ds - startallModel1Ds;
  
                if (allGroups.Model1Ds[i][j] < 0) allGroups.Model1Ds[i][j] = 0;
              }
            }
          }   
  
          int[][] startList = (int[][]) subset(allGroups.Model1Ds, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Model1Ds, OBJ_NUM + 1);
  
          allGroups.Model1Ds = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startallModel1Ds) && (startallModel1Ds <= endallModel1Ds)) {
  
          {
            float[][] startList = (float[][]) subset(allModel1Ds.XYZSR, 0, startallModel1Ds);
            float[][] endList = (float[][]) subset(allModel1Ds.XYZSR, endallModel1Ds + 1);
  
            allModel1Ds.XYZSR = (float[][]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.Type, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.Type, endallModel1Ds + 1);
  
            allModel1Ds.Type = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.DegreeMin, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.DegreeMin, endallModel1Ds + 1);
  
            allModel1Ds.DegreeMin = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.DegreeMax, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.DegreeMax, endallModel1Ds + 1);
  
            allModel1Ds.DegreeMax = (int[]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel1Ds.Seed, 0, startallModel1Ds);
            int[] endList = (int[]) subset(allModel1Ds.Seed, endallModel1Ds + 1);
  
            allModel1Ds.Seed = (int[]) concat(startList, endList);
          }
  
          {
            float[] startList = (float[]) subset(allModel1Ds.TrunkSize, 0, startallModel1Ds);
            float[] endList = (float[]) subset(allModel1Ds.TrunkSize, endallModel1Ds + 1);
  
            allModel1Ds.TrunkSize = (float[]) concat(startList, endList);
          }
  
          {
            float[] startList = (float[]) subset(allModel1Ds.LeafSize, 0, startallModel1Ds);
            float[] endList = (float[]) subset(allModel1Ds.LeafSize, endallModel1Ds + 1);
  
            allModel1Ds.LeafSize = (float[]) concat(startList, endList);
          }
  
  
          allModel1Ds.num = allModel1Ds.XYZSR.length;
        }
  
        int startallModel2Ds = allGroups.Model2Ds[OBJ_NUM][0];
        int endallModel2Ds = allGroups.Model2Ds[OBJ_NUM][1];
  
        {
  
          if ((0 <= startallModel2Ds) && (startallModel2Ds <= endallModel2Ds)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
  
                allGroups.Model2Ds[i][j] -= 1 + endallModel2Ds - startallModel2Ds;
  
                if (allGroups.Model2Ds[i][j] < 0) allGroups.Model2Ds[i][j] = 0;
              }
            }
          }   
  
          int[][] startList = (int[][]) subset(allGroups.Model2Ds, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Model2Ds, OBJ_NUM + 1);
  
          allGroups.Model2Ds = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startallModel2Ds) && (startallModel2Ds <= endallModel2Ds)) {
  
          {
            float[][] startList = (float[][]) subset(allModel2Ds.XYZS, 0, startallModel2Ds);
            float[][] endList = (float[][]) subset(allModel2Ds.XYZS, endallModel2Ds + 1);
  
            allModel2Ds.XYZS = (float[][]) concat(startList, endList);
          }
  
          {
            int[] startList = (int[]) subset(allModel2Ds.MAP, 0, startallModel2Ds);
            int[] endList = (int[]) subset(allModel2Ds.MAP, endallModel2Ds + 1);
  
            allModel2Ds.MAP = (int[]) concat(startList, endList);
          }
  
          allModel2Ds.num = allModel2Ds.XYZS.length;
        }
  
        int startSolid = allGroups.Solids[OBJ_NUM][0];
        int endSolid = allGroups.Solids[OBJ_NUM][1];
  
        {
          if ((0 <= startSolid) && (startSolid <= endSolid)) {
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
  
              for (int j = 0; j < 2; j++) {
                allGroups.Solids[i][j] -= 1 + endSolid - startSolid;
  
                if (allGroups.Solids[i][j] < 0) allGroups.Solids[i][j] = 0;
              }
            }
          }  
  
          int[][] startList = (int[][]) subset(allGroups.Solids, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.Solids, OBJ_NUM + 1);
  
          allGroups.Solids = (int[][]) concat(startList, endList);
        }  
  
        if ((0 <= startSolid) && (startSolid <= endSolid)) {
  
          float[][] startList = (float[][]) subset(allSolids.DEF, 0, startSolid);
          float[][] endList = (float[][]) subset(allSolids.DEF, endSolid + 1);
  
          allSolids.DEF = (float[][]) concat(startList, endList);
  
          allSolids_updated = true;
        }
  
  
        {
          float[][] startList = (float[][]) subset(allGroups.PivotMatrix, 0, OBJ_NUM);
          float[][] endList = (float[][]) subset(allGroups.PivotMatrix, OBJ_NUM + 1);
  
          allGroups.PivotMatrix = (float[][]) concat(startList, endList);
        } 
  
        {
          int[][] startList = (int[][]) subset(allGroups.PivotType, 0, OBJ_NUM);
          int[][] endList = (int[][]) subset(allGroups.PivotType, OBJ_NUM + 1);
  
          allGroups.PivotType = (int[][]) concat(startList, endList);
        } 
  
        allGroups.num -= 1;
      }
      
      if (allSolids_updated) allSolidImpacts.calculate_Impact_selectedSections();
  
    }
  
  
  
  
  
    if ((current_ObjectCategory == ObjectCategory.VERTEX) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.GROUP)) { 
  
      println("deleteIsolatedVerticesSelection");
  
      this.deleteIsolatedVertices_Selection();
    }  
  
  
  
  
    if (allCameras.num == 0) {
      this.add_veryFirstCamera();
    }
  
    this.deselect_All();
  }
  
  
  void deleteIsolatedVertices_Selection () { 
  
    userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
    for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) { 
  
      int vNo = userSelections.Vertex_ids[o];
  
      int found = -1;
      
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
  
              found = 1;
            }
  
            if (found != -1) break;
          }
  
          if (found != -1) break;
        }  
      }
      
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
  
              found = 1;
            }
  
            if (found != -1) break;
          }
  
          if (found != -1) break;
        }        
      }
      
  
      if (found == -1) {
  
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {
  
              allFaces.nodes[i][j] -= 1;
            }
          }
        }             
  
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {
  
              allCurves.nodes[i][j] -= 1;
            }
          }
        }  
  
        float[][] startList = (float[][]) subset(allVertices, 0, vNo);
        float[][] endList = (float[][]) subset(allVertices, vNo + 1);
  
        allVertices = (float[][]) concat(startList, endList);
      }
    }
  
    userSelections.Vertex_ids = new int [0];
  }
  
  
  void deleteIsolatedVertices_Scene () {
  
    for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) {
  
      int found = -1;
  
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) {
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        {
          float[][] startList = (float[][]) subset(allVertices, 0, vNo);
          float[][] endList = (float[][]) subset(allVertices, vNo + 1);
  
          allVertices = (float[][]) concat(startList, endList);
        }
  
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] > vNo) {
  
              allFaces.nodes[i][j] -= 1;
            }
          }
        }
        
        for (int i = 0; i < allCurves.nodes.length; i++) {
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] > vNo) {
  
              allCurves.nodes[i][j] -= 1;
            }
          }
        }      
      }
  
  
    } 
  
    userSelections.Vertex_ids = new int [0];
  }
  
  
  void selectIsolatedVertices_Scene () {
  
    userSelections.Vertex_ids = new int [0];
  
    for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) { 
  
      int found = -1;
  
      if (found == -1) {
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
            if (allFaces.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
            if (allCurves.nodes[i][j] == vNo) {
              found = 1;
            }
          }
        }
      }
  
      if (found == -1) {
  
        int[] newIsolatedVertex = {
          vNo
        };
  
        userSelections.Vertex_ids = concat(userSelections.Vertex_ids, newIsolatedVertex);
  
  
      }
    } 
  
    current_ObjectCategory = ObjectCategory.VERTEX; 
    UI_BAR_b.update = true;
  
    userSelections.calculate_selection_BoundingBox();
  }
  
  
  
  void selectNearVertices_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
      int[] pre_Selection_Vertex_ids = userSelections.Vertex_ids;
  
      for (int vNo = allPoints.getLength() - 1; vNo >= 0; vNo--) {
  
        int isNearEnough = -1;
  
        for (int i = 0; i < pre_Selection_Vertex_ids.length; i++) {
  
          int q = pre_Selection_Vertex_ids[i];
  
          int found = -1;
  
          for (int j = 0; j < userSelections.Vertex_ids.length; j++) {
  
            if (vNo == userSelections.Vertex_ids[j]) {
  
              found = 1;
  
              break;
            }
          } 
  
          if (found == -1) { 
  
            float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
            if (d <= User3D.modify_WeldTreshold) { 
  
              isNearEnough = 1;
  
              break;
            }
          }
        }
  
  
        if (isNearEnough == 1) {
  
          int[] newVertex_id = {
            vNo
          };
  
          userSelections.Vertex_ids = concat(userSelections.Vertex_ids, newVertex_id);
        }
      } 
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void weldSceneVertices_Selection (float max_distance) {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = userSelections.Vertex_ids[o];
  
        int found = -1;
        
        if (found != -1) {
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
  
              int q = allFaces.nodes[i][j];
  
              if (q > vNo) { // it is faster than (q != vNo)
  
                float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
                if (d <= max_distance) { 
  
                  allFaces.nodes[i][j] = vNo;
  
                  found = q;
                }
              }
            }
          }
        }
  
        if (found != -1) {
          for (int i = 0; i < allCurves.nodes.length; i++) { 
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
  
              int q = allCurves.nodes[i][j];
  
              if (q > vNo) { // it is faster than (q != vNo)
  
                float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
                if (d <= max_distance) { 
  
                  allCurves.nodes[i][j] = vNo;
  
                  found = q;
                }
              }
            }
          }
        }
  
        if (found != -1) {
  
          int q = found;
  
          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);
  
            allVertices = (float[][]) concat(startList, endList);
          }
  
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {
  
                allFaces.nodes[i][j] -= 1;
              }
            }
          }
          
          for (int i = 0; i < allCurves.nodes.length; i++) {
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {
  
                allCurves.nodes[i][j] -= 1;
              }
            }
          }          
        }
      }
  
      userSelections.Vertex_ids = new int [0];
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void weldObjectsVertices_Selection (float max_distance) {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      this.convert_Vertices_to_Faces();
      this.convert_Vertices_to_Curves();
  
      userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) {  
  
        int vNo = userSelections.Vertex_ids[o];
  
        int found = -1;
  
        for (int m = o - 1; m >= 0; m--) {
  
          int q = userSelections.Vertex_ids[m];
  
          float d = dist(allPoints.getX(q), allPoints.getY(q), allPoints.getZ(q), allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
          if (d <= max_distance) { 
  
            for (int i = 0; i < userSelections.Face_ids.length; i++) {
              int f = userSelections.Face_ids[i];
  
              for (int j = 0; j < allFaces.nodes[f].length; j++) {
                if (allFaces.nodes[f][j] == q) {
  
                  allFaces.nodes[f][j] = vNo;
  
                  found = q;
                }
              }
            }
            
            for (int i = 0; i < userSelections.Curve_ids.length; i++) {
              int f = userSelections.Curve_ids[i];
  
              for (int j = 0; j < allCurves.nodes[f].length; j++) {
                if (allCurves.nodes[f][j] == q) {
  
                  allCurves.nodes[f][j] = vNo;
  
                  found = q;
                }
              }
            }              
          }
        }
  
        if (found != -1) {
  
          int q = found;
  
          {
            float[][] startList = (float[][]) subset(allVertices, 0, q);
            float[][] endList = (float[][]) subset(allVertices, q + 1);
  
            allVertices = (float[][]) concat(startList, endList);
          }
  
          for (int i = 0; i < allFaces.nodes.length; i++) { 
            for (int j = 0; j < allFaces.nodes[i].length; j++) {
              if (allFaces.nodes[i][j] > q) {
  
                allFaces.nodes[i][j] -= 1;
              }
            }
          }
          
          for (int i = 0; i < allCurves.nodes.length; i++) { 
            for (int j = 0; j < allCurves.nodes[i].length; j++) {
              if (allCurves.nodes[i][j] > q) {
  
                allCurves.nodes[i][j] -= 1;
              }
            }
          }          
        }
      }
  
      userSelections.Vertex_ids = new int [0];
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void repositionVertices_Selection () {
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) { 
  
      userSelections.calculate_selection_BoundingBox();
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) { 
  
        int vNo = userSelections.Vertex_ids[o];
  
        allPoints.setX(vNo, userSelections.BoundingBox[1][0]); // center
        allPoints.setY(vNo, userSelections.BoundingBox[1][1]); // center
        allPoints.setZ(vNo, userSelections.BoundingBox[1][2]); // center
      } 
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void separateVertices_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) { 
  
        int vNo = userSelections.Vertex_ids[o];
  
        for (int i = 0; i < allFaces.nodes.length; i++) { 
          for (int j = 0; j < allFaces.nodes[i].length; j++) {
  
            if (allFaces.nodes[i][j] == vNo) { 
  
              allFaces.nodes[i][j] = this.add_Vertex(allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
            }
          }
        }
        
        for (int i = 0; i < allCurves.nodes.length; i++) { 
          for (int j = 0; j < allCurves.nodes[i].length; j++) {
  
            if (allCurves.nodes[i][j] == vNo) { 
  
              allCurves.nodes[i][j] = this.add_Vertex(allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
            }
          }
        }        
      }
  
  
      userSelections.Vertex_ids = new int [0];
  
      userSelections.calculate_selection_BoundingBox();
    }
  }
  
  
  
  void insertCornerOpennings_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                
                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
  
                  new_Vertices[i][j] = pow(User3D.modify_OpenningArea, 0.5) * base_Vertices[i][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_Vertex_ids = new int [allFaces.nodes[f].length];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_Vertex_ids[s] = this.add_Vertex(new_Vertices[s][0], new_Vertices[s][1], new_Vertices[s][2]);
              } 
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);              
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace_nodes = {
                  {
                    new_Vertex_ids[s], allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_Vertex_ids[s_next]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }
  
  
              { // modifying the base face to shape the openning  
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_Vertex_ids[s];
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void insertParallelOpennings_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) {
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += 2 * allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += 2 * allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) { 
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += 2 * allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                
                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
  
              float[][] new_A_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_B_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_A_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * 0.5 * (base_Vertices[s_prev][j] + base_Vertices[s][j]);
                  new_B_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * 0.5 * (base_Vertices[s_next][j] + base_Vertices[s][j]);
  
                  new_CenterVertices[s][j] = pow(User3D.modify_OpenningArea, 0.5) * base_Vertices[s][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_A_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge (1/3)
              int[] new_B_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the other edge (2/3)
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_A_EdgeVertex_ids[s] = this.add_Vertex(new_A_EdgeVertices[s][0], new_A_EdgeVertices[s][1], new_A_EdgeVertices[s][2]); 
                new_B_EdgeVertex_ids[s] = this.add_Vertex(new_B_EdgeVertices[s][0], new_B_EdgeVertices[s][1], new_B_EdgeVertices[s][2]);
                new_CenterVertex_ids[s] = this.add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              }               
  
  
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                {
                  int[][] newFace_nodes = {
                    {
                      allFaces.nodes[f][s], new_B_EdgeVertex_ids[s], new_CenterVertex_ids[s], new_A_EdgeVertex_ids[s]
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  }; 
  
                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
                }   
  
                {
                  int[][] newFace_nodes = {
                    {
                      new_B_EdgeVertex_ids[s], new_A_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  }; 
  
                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
                }
              }
  
  
              { // modifying the base face to shape the openning  
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void insertRotatedOpennings_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) {
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                
                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);                
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
              float[][] new_CenterVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * base_Vertices[s_prev][j];
  
                  new_CenterVertices[s][j] = pow(User3D.modify_OpenningArea, 0.5) * new_EdgeVertices[s][j] + (1 - pow(User3D.modify_OpenningArea, 0.5)) * G_face[j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
              int[] new_CenterVertex_ids = new int [allFaces.nodes[f].length]; // in the center
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]); 
                new_CenterVertex_ids[s] = this.add_Vertex(new_CenterVertices[s][0], new_CenterVertices[s][1], new_CenterVertices[s][2]);
              } 
  
  
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_ids[s_next], new_CenterVertex_ids[s]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }
  
  
              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_CenterVertex_ids[s];
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void insertEdgeOpennings_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = (int[][]) subset(allFaces.nodes, f, 1);
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = (int[][]) subset(allFaces.options, f, 1);
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
  
                  new_EdgeVertices[s][j] = User3D.modify_OpenningDeviation * base_Vertices[s][j] + (1 - User3D.modify_OpenningDeviation) * base_Vertices[s_prev][j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              } 
  
  
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next]
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }
  
  
              { // modifying the base face to match new center face
                for (int s = 0; s < allFaces.nodes[f].length; s++) {
                  allFaces.nodes[f][s] = new_EdgeVertex_ids[s];
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateRowsColumnsFaceSelection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            if (allFaces.nodes[f].length == 4) {
  
              for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroups.Faces[i][j] += User3D.modify_TessellateColumns * User3D.modify_TessellateRows - 1;
                }
              }  
              allGroups.Faces[OBJ_NUM][1] += User3D.modify_TessellateColumns * User3D.modify_TessellateRows - 1; // because adding the faces also changes the end pointer of the same object 
  
              for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
                if (new_selection_Face_ids[p] != 0) {
  
                  if (new_selection_Face_ids[p] > f) {  
                    new_selection_Face_ids[p] += User3D.modify_TessellateColumns * User3D.modify_TessellateRows - 1;
                  }
                }
              }             
  
  
              int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces_nodes = new int [0][0];
              int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
              int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_options = new int [0][0];
              int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
              { 
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {

                  base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                  base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                  base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                }
  
  
  
                float[][] new_EdgeVertices = new float [(User3D.modify_TessellateColumns + 1) * (User3D.modify_TessellateRows + 1)][3];
  
                for (int i = 0; i <= User3D.modify_TessellateColumns; i++) {
  
                  for (int j = 0; j <= User3D.modify_TessellateRows; j++) {
  
                    int s = i * (User3D.modify_TessellateRows + 1) + j;
  
                    for (int k = 0; k < 3; k++) {
  
                      float u = i / float(User3D.modify_TessellateColumns);
                      float v = j / float(User3D.modify_TessellateRows);
  
                      new_EdgeVertices[s][k] = funcs.bilinear(base_Vertices[0][k], base_Vertices[1][k], base_Vertices[2][k], base_Vertices[3][k], u, v);
                    }
                  }
                }
  
                int[] new_EdgeVertex_ids = new int [(User3D.modify_TessellateColumns + 1) * (User3D.modify_TessellateRows + 1)]; // on the edge
  
                for (int i = 0; i <= User3D.modify_TessellateColumns; i++) {
  
                  for (int j = 0; j <= User3D.modify_TessellateRows; j++) {
  
                    int s = i * (User3D.modify_TessellateRows + 1) + j;
  
                    if ((i == 0) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][0];
                    } else if ((i == User3D.modify_TessellateColumns) && (j == 0)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][1];
                    } else if ((i == User3D.modify_TessellateColumns) && (j == User3D.modify_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][2];
                    } else if ((i == 0) && (j == User3D.modify_TessellateRows)) {
                      new_EdgeVertex_ids[s] = allFaces.nodes[f][3];
                    } else {
                      new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
                    }
                  }
                }
  
  
                current_Material = allFaces.getMaterial(f);
                current_Tessellation = allFaces.getTessellation(f);
                current_Layer = allFaces.getLayer(f);
                current_Visibility = allFaces.getVisibility(f);
  
                for (int i = 0; i < User3D.modify_TessellateColumns; i++) {
  
                  for (int j = 0; j < User3D.modify_TessellateRows; j++) {
  
                    int s = i * User3D.modify_TessellateRows + j;  // number of face
  
                    // number of vertices
                    int s00 = i * (User3D.modify_TessellateRows + 1) + j; 
                    int s01 = s00 + 1;
                    int s10 = s00 + (User3D.modify_TessellateRows + 1);
                    int s11 = s00 + (User3D.modify_TessellateRows + 1) + 1;
  
                    int[][] newFace_nodes = {
                      {
                        new_EdgeVertex_ids[s00], new_EdgeVertex_ids[s10], new_EdgeVertex_ids[s11], new_EdgeVertex_ids[s01]
                      }
                    };
                    int[][] newFace_options = {
                      {
                        current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                      }
                    }; 
  
                    midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                    midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options); 
  
                    if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                      int[] newFace_nodes_number = {
                        f + s
                      }; 
                      new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, newFace_nodes_number);
                    }
                  }
                }
              }
  
              startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
              startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
              allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
              allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
              { // to avoid processing the faces twice they should be deleted from the list.
                for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                  userSelections.Face_ids[i] -= 1;
                }              
  
                int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
                int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
                userSelections.Face_ids = (int[]) concat(startList, endList);
              }
            }
          }
        }
      }
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateRectangularFaceSelection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length - 1;
                }
              }
            }             
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = new int [0][0];
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = new int [0][0];
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
              float[][] new_EdgeVertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
                for (int j = 0; j < 3; j++) {
                  new_EdgeVertices[s][j] = 0.5 * base_Vertices[s][j] + 0.5 * base_Vertices[s_prev][j];
                }
              }
  
              int[] new_EdgeVertex_ids = new int [allFaces.nodes[f].length]; // on the edge
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                new_EdgeVertex_ids[s] = this.add_Vertex(new_EdgeVertices[s][0], new_EdgeVertices[s][1], new_EdgeVertices[s][2]);
              } 
  
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);              
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace_nodes = {
                  {
                    new_EdgeVertex_ids[s], allFaces.nodes[f][s], new_EdgeVertex_ids[s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options); 
  
                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_nodes_number = {
                    f + s
                  }; 
                  new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, newFace_nodes_number);
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  void tessellateTriangularFaceSelection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) {
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length - 1;
                }
              }
            }             
  
  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes = new int [0][0];
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options = new int [0][0];
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {

                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
              }
  
              float[] G_face = {
                0, 0, 0
              };  
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                for (int j = 0; j < 3; j++) {
                  G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                }
              }
  
  
              int new_CenterVertex_number = 0; // at the center
              new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);                
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                int s_next = (s + 1) % allFaces.nodes[f].length;
  
                int[][] newFace_nodes = {
                  {
                    allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                  }
                };
                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options); 
  
                if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                  int[] newFace_nodes_number = {
                    f + s
                  }; 
                  new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, newFace_nodes_number);
                }
              }
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void forceTriangulateFaces_Selection () {  
    
    // this function is the copy of above function (this.tessellateTriangularFaceSelection) 
    // but only processed the faces with degrees above 3.
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) {
  
          int f = userSelections.Face_ids[q];
  
          if (allFaces.nodes[f].length > 3) { // <<<<<<<<<<< the condition to perform the process 
  
            int startFace = allGroups.Faces[OBJ_NUM][0];
            int endFace = allGroups.Faces[OBJ_NUM][1];          
  
            if ((startFace <= f) && (f <= endFace)) {
  
              for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
                for (int j = 0; j < 2; j++) {
                  allGroups.Faces[i][j] += allFaces.nodes[f].length - 1;
                }
              }  
              allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length - 1; // because adding the faces also changes the end pointer of the same object 
  
              for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
                if (new_selection_Face_ids[p] != 0) {
  
                  if (new_selection_Face_ids[p] > f) {  
                    new_selection_Face_ids[p] += allFaces.nodes[f].length - 1;
                  }
                }
              }             
  
              int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
              int[][] midList_Faces_nodes = new int [0][0];
              int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
              int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
              int[][] midList_Faces_options = new int [0][0];
              int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
              { 
                float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {

                  base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                  base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                  base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                }
  
                float[] G_face = {
                  0, 0, 0
                };  
  
                for (int i = 0; i < allFaces.nodes[f].length; i++) {
                  for (int j = 0; j < 3; j++) {
                    G_face[j] += base_Vertices[i][j] / float(allFaces.nodes[f].length);
                  }
                }
  
  
                int new_CenterVertex_number = 0; // at the center
                new_CenterVertex_number = this.add_Vertex(G_face[0], G_face[1], G_face[2]); 
  
  
                current_Material = allFaces.getMaterial(f);
                current_Tessellation = allFaces.getTessellation(f);
                current_Layer = allFaces.getLayer(f);
                current_Visibility = allFaces.getVisibility(f);                
  
                for (int s = 0; s < allFaces.nodes[f].length; s++) { 
  
                  int s_next = (s + 1) % allFaces.nodes[f].length;
  
                  int[][] newFace_nodes = {
                    {
                      allFaces.nodes[f][s], allFaces.nodes[f][s_next], new_CenterVertex_number
                    }
                  };
                  int[][] newFace_options = {
                    {
                      current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                    }
                  }; 
  
                  midList_Faces_nodes = (int[][]) concat(midList_Faces_nodes, newFace_nodes);
                  midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options); 
  
                  if (s > 0) { // the first tessellated face was replaced by the base face... so only add other items
                    int[] newFace_nodes_number = {
                      f + s
                    }; 
                    new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, newFace_nodes_number);
                  }
                }
              }
  
              startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
              startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
              allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
              allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);           
            }           
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  


  void optimizeFaceSelection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) {
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          

          if ((startFace <= f) && (f <= endFace)) {
            
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
              int vNo = allFaces.nodes[f][s];
  
              base_Vertices[s][0] = allPoints.getX(vNo);      
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);
            }      
            
            float[][] new_Vertices = funcs.optimizeVertices(base_Vertices);            
            
            int[] newList = new int[0];
            // finding ids of new vertices in old vertices
            for (int k = 0; k < new_Vertices.length; k++) {
              for (int s = 0; s < base_Vertices.length; s++) {
                if (funcs.arePointsClose(new_Vertices[k], base_Vertices[s])) {
                  int[] newItem = {allFaces.nodes[f][s]};
                  newList = (int []) concat(newList, newItem);
                  break;
                }
              }  
            }
            allFaces.nodes[f] = newList;   
          }
          
        }
      }
  
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }



  void triangulateFaceSelection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
      }
  
      int[] new_selection_Face_ids = userSelections.Face_ids;
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            for (int i = OBJ_NUM + 1; i < allGroups.num; i++) {
              for (int j = 0; j < 2; j++) {
                allGroups.Faces[i][j] += allFaces.nodes[f].length;
              }
            }  
            allGroups.Faces[OBJ_NUM][1] += allFaces.nodes[f].length; // because adding the faces also changes the end pointer of the same object 
  
            for (int p = new_selection_Face_ids.length - 1; p >= 0; p--) {
  
              if (new_selection_Face_ids[p] != 0) {
  
                if (new_selection_Face_ids[p] > f) {  
                  new_selection_Face_ids[p] += allFaces.nodes[f].length;
                }
              }
            }              

  
            int[][] startList_Faces_nodes = (int[][]) subset(allFaces.nodes, 0, f);
            int[][] midList_Faces_nodes;
            int[][] endList_Faces_nodes = (int[][]) subset(allFaces.nodes, f + 1);
  
  
            int[][] startList_Faces_options = (int[][]) subset(allFaces.options, 0, f);
            int[][] midList_Faces_options;
            int[][] endList_Faces_options = (int[][]) subset(allFaces.options, f + 1);
  
            { 
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int i = 0; i < allFaces.nodes[f].length; i++) {
                
                base_Vertices[i][0] = allPoints.getX(allFaces.nodes[f][i]);
                base_Vertices[i][1] = allPoints.getY(allFaces.nodes[f][i]);
                base_Vertices[i][2] = allPoints.getZ(allFaces.nodes[f][i]);
                
              }
              
              midList_Faces_nodes = funcs.reduceDegreePolygon(base_Vertices);
              midList_Faces_options = new int[0][0];   
         
              current_Material = allFaces.getMaterial(f);
              current_Tessellation = allFaces.getTessellation(f);
              current_Layer = allFaces.getLayer(f);
              current_Visibility = allFaces.getVisibility(f);                         
              
              for (int s = 0; s < midList_Faces_nodes.length; s++) { 

                int[][] newFace_options = {
                  {
                    current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
                  }
                }; 
  
                midList_Faces_options = (int[][]) concat(midList_Faces_options, newFace_options);
              }
  
            }
  
            startList_Faces_nodes = (int[][]) concat(startList_Faces_nodes, midList_Faces_nodes);
            startList_Faces_options = (int[][]) concat(startList_Faces_options, midList_Faces_options);  
  
            allFaces.nodes = (int[][]) concat(startList_Faces_nodes, endList_Faces_nodes);
            allFaces.options = (int[][]) concat(startList_Faces_options, endList_Faces_options);                      
  
            { // to avoid processing the faces twice they should be deleted from the list.
              for (int i = q + 1; i < userSelections.Face_ids.length; i++) {
                userSelections.Face_ids[i] -= 1;
              }              
  
              int[] startList = (int[]) subset(userSelections.Face_ids, 0, q);
              int[] endList = (int[]) subset(userSelections.Face_ids, q + 1);
  
              userSelections.Face_ids = (int[]) concat(startList, endList);
            }
          }
        }
      }
  
  
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }





  
  
  void autoNormalFaces_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
  
      if ((current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.GROUP)) {
  
  
        for (int o = 0; o < userSelections.Face_ids.length; o++) {
    
          int f = userSelections.Face_ids[o];     
        
          int n = allFaces.nodes[f].length;
    
          if (n > 2) {
            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            }; 
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allPoints.getX(tmpFace[j]) / float(n); 
              G[1] += allPoints.getY(tmpFace[j]) / float(n);
              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
            }  
            
            PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);                       
            PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);
    
            PVector GAxGB = AG.cross(BG);
  
            float[] ray_start = {G[0], G[1], G[2]};
            float[] ray_direction = {GAxGB.x, GAxGB.y, GAxGB.z};
  
            float[] RxP = userSelections.intersect(ray_start, ray_direction);
  
            if (RxP[0] >= 0) {
  
              for (int j = 0; j < n; j++) {
                allFaces.nodes[f][j] = tmpFace[n - j - 1];
              }
            }
          }
        }
      }
  
      current_ObjectCategory = ObjectCategory.FACE; 
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void extrudeFaceEdges_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Faces();    
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        userSelections.Face_ids = sort(userSelections.Face_ids);
  
        this.convert_Faces_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = {};
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
        for (int q = userSelections.Face_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Face_ids[q];
  
          int startFace = allGroups.Faces[OBJ_NUM][0];
          int endFace = allGroups.Faces[OBJ_NUM][1];          
  
          if ((startFace <= f) && (f <= endFace)) {
  
            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            float[][] top_Vertices = new float [allFaces.nodes[f].length][3];
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
              int vNo = allFaces.nodes[f][s];
  
              base_Vertices[s][0] = allPoints.getX(vNo);
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);
  
              top_Vertices[s][0] = allPoints.getX(vNo);
              top_Vertices[s][1] = allPoints.getY(vNo);
              top_Vertices[s][2] = allPoints.getZ(vNo);
            }
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allFaces.nodes[f].length;
              int s_prev = (s + allFaces.nodes[f].length - 1) % allFaces.nodes[f].length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = funcs.vec3_unit(W);
  
              top_Vertices[s][0] += W[0] * User3D.modify_OpenningDepth;
              top_Vertices[s][1] += W[1] * User3D.modify_OpenningDepth;
              top_Vertices[s][2] += W[2] * User3D.modify_OpenningDepth;
            }  
  
            int[] base_Vertex_ids = new int [allFaces.nodes[f].length];
            int[] top_Vertex_ids = new int [allFaces.nodes[f].length];
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              base_Vertex_ids[s] = this.add_Vertex(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
              top_Vertex_ids[s] = this.add_Vertex(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }        
  
            for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allFaces.nodes[f].length;
  
              if (User3D.modify_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              } else {
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              }       
  
              int[][] newFace_options = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);
            }  
  
            { // adding the cap
              int[][] newFace_nodes = {
                top_Vertex_ids
              };  
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);         
  
              int[][] newFace_options = {
                {
                  allFaces.getMaterial(f), allFaces.getTessellation(f), allFaces.getLayer(f), allFaces.getVisibility(f), allFaces.getWeight(f), allFaces.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);  
  
              int[] lastFace = {
                allFaces.nodes.length - 1
              };
  
              new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, lastFace);
            }
  
            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }
  
      userSelections.Face_ids = new_selection_Face_ids;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void extrudeCurveEdges_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.CURVE)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
  
        this.convert_allGroups_to_Curves();    
  
        userSelections.Curve_ids = sort(userSelections.Curve_ids);
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        userSelections.Curve_ids = sort(userSelections.Curve_ids);
  
        this.convert_Curves_to_allGroups();    
  
        userSelections.Group_ids = sort(userSelections.Group_ids);
      }
  
      int[] new_selection_Face_ids = {};
  
      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) { 
  
        int OBJ_NUM = userSelections.Group_ids[o];
  
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
        for (int q = userSelections.Curve_ids.length - 1; q >= 0; q--) { 
  
          int f = userSelections.Curve_ids[q];
  
          int startCurve = allGroups.Curves[OBJ_NUM][0];
          int endCurve = allGroups.Curves[OBJ_NUM][1];          
  
          if ((startCurve <= f) && (f <= endCurve)) {
  
            float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
            float[][] top_Vertices = new float [allCurves.nodes[f].length][3];
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
              int vNo = allCurves.nodes[f][s];
  
              base_Vertices[s][0] = allPoints.getX(vNo);
              base_Vertices[s][1] = allPoints.getY(vNo);
              base_Vertices[s][2] = allPoints.getZ(vNo);
  
              top_Vertices[s][0] = allPoints.getX(vNo);
              top_Vertices[s][1] = allPoints.getY(vNo);
              top_Vertices[s][2] = allPoints.getZ(vNo);
            }
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allCurves.nodes[f].length;
              int s_prev = (s + allCurves.nodes[f].length - 1) % allCurves.nodes[f].length;
  
              PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]);
              PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]);
              PVector UV = U.cross(V);
              float[] W = {
                UV.x, UV.y, UV.z
              };
              W = funcs.vec3_unit(W);
  
              top_Vertices[s][0] += W[0] * User3D.modify_OpenningDepth;
              top_Vertices[s][1] += W[1] * User3D.modify_OpenningDepth;
              top_Vertices[s][2] += W[2] * User3D.modify_OpenningDepth;
            }  
  
            int[] base_Vertex_ids = new int [allCurves.nodes[f].length];
            int[] top_Vertex_ids = new int [allCurves.nodes[f].length];
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              base_Vertex_ids[s] = this.add_Vertex(base_Vertices[s][0], base_Vertices[s][1], base_Vertices[s][2]); 
              top_Vertex_ids[s] = this.add_Vertex(top_Vertices[s][0], top_Vertices[s][1], top_Vertices[s][2]);
            }        
  
            for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
              int s_next = (s + 1) % allCurves.nodes[f].length;
  
              if (User3D.modify_OpenningDepth < 0) { // reverse direction for negative extrude heights
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], top_Vertex_ids[s], top_Vertex_ids[s_next], base_Vertex_ids[s_next]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              } else {
                int[][] newFace_nodes = {
                  {
                    base_Vertex_ids[s], base_Vertex_ids[s_next], top_Vertex_ids[s_next], top_Vertex_ids[s]
                  }
                };  
                allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
              }       
  
              int[][] newFace_options = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);
            }  
  
            { // adding the cap
              int[][] newFace_nodes = {
                top_Vertex_ids
              };  
              allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);         
  
              int[][] newFace_options = { // copying target face properties from curve source
                {
                  allCurves.getMaterial(f), allCurves.getTessellation(f), allCurves.getLayer(f), allCurves.getVisibility(f), allCurves.getWeight(f), allCurves.getClose(f)
                }
              }; 
              allFaces.options =  (int[][]) concat(allFaces.options, newFace_options);  
  
              int[] lastFace = {
                allFaces.nodes.length - 1
              };
  
              new_selection_Face_ids = (int[]) concat(new_selection_Face_ids, lastFace);
            }
  
            allGroups.Faces[allGroups.num - 1][1] = allFaces.nodes.length - 1;
          }
        }
      }
  
  
      userSelections.Face_ids = new_selection_Face_ids;
      
      current_ObjectCategory = ObjectCategory.FACE;
      UI_BAR_b.update = true;
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  void offsetVertices_Selection (int _type, float _amount) {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.FACE) { 
  
        this.convert_Faces_to_Vertices();
      }
  
      if (current_ObjectCategory == ObjectCategory.CURVE) { 
  
        this.convert_Curves_to_Vertices();
      }
  
      float[][] Vertex_offsetValues = new float [userSelections.Vertex_ids.length][3];
      int[] Vertex_offsetNum = new int [userSelections.Vertex_ids.length];
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) { 
        Vertex_offsetValues[o][0] = 0;
        Vertex_offsetValues[o][1] = 0;
        Vertex_offsetValues[o][2] = 0;
  
        Vertex_offsetNum[o] = 0;
      }
  
      userSelections.Vertex_ids = sort(userSelections.Vertex_ids);
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = userSelections.Vertex_ids[o];
  
        for (int f = 0; f < allFaces.nodes.length; f++) {
          for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
            if (allFaces.nodes[f][j] == vNo) { 
  
              float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
  
              for (int s = 0; s < allFaces.nodes[f].length; s++) {
  
                base_Vertices[s][0] = allPoints.getX(allFaces.nodes[f][s]);
                base_Vertices[s][1] = allPoints.getY(allFaces.nodes[f][s]);
                base_Vertices[s][2] = allPoints.getZ(allFaces.nodes[f][s]);
              }
  
              for (int s = 0; s < base_Vertices.length; s++) {
  
                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
                PVector UV = new PVector(0, 0, 0);
  
                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);
  
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);
  
                Vertex_offsetValues[o][0] += W[0] * _amount;
                Vertex_offsetValues[o][1] += W[1] * _amount;
                Vertex_offsetValues[o][2] += W[2] * _amount;
  
                Vertex_offsetNum[o] += 1;
              }
            }
          }
        }
        
        for (int f = 0; f < allCurves.nodes.length; f++) {
          for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
            if (allCurves.nodes[f][j] == vNo) { 
  
              float[][] base_Vertices = new float [allCurves.nodes[f].length][3];
  
              for (int s = 0; s < allCurves.nodes[f].length; s++) {
  
                base_Vertices[s][0] = allPoints.getX(allCurves.nodes[f][s]);
                base_Vertices[s][1] = allPoints.getY(allCurves.nodes[f][s]);
                base_Vertices[s][2] = allPoints.getZ(allCurves.nodes[f][s]);
              }
  
              for (int s = 0; s < base_Vertices.length; s++) {
  
                int s_next = (s + 1) % base_Vertices.length;
                int s_prev = (s + base_Vertices.length - 1) % base_Vertices.length;
  
                PVector U = new PVector(base_Vertices[s_next][0] - base_Vertices[s][0], base_Vertices[s_next][1] - base_Vertices[s][1], base_Vertices[s_next][2] - base_Vertices[s][2]); 
                PVector V = new PVector(base_Vertices[s_prev][0] - base_Vertices[s][0], base_Vertices[s_prev][1] - base_Vertices[s][1], base_Vertices[s_prev][2] - base_Vertices[s][2]); 
                PVector UV = new PVector(0, 0, 0);
  
                if (_type == 0) UV = U.cross(V);
                if (_type == 1) UV = PVector.add(U, V);
  
                float[] W = {
                  UV.x, UV.y, UV.z
                };
                W = funcs.vec3_unit(W);
  
                Vertex_offsetValues[o][0] += W[0] * _amount;
                Vertex_offsetValues[o][1] += W[1] * _amount;
                Vertex_offsetValues[o][2] += W[2] * _amount;
  
                Vertex_offsetNum[o] += 1;
              }
            }
          }
        }        
  
  
        if (Vertex_offsetNum[o] != 0) {
          Vertex_offsetValues[o][0] /= float(Vertex_offsetNum[o]);
          Vertex_offsetValues[o][1] /= float(Vertex_offsetNum[o]);
          Vertex_offsetValues[o][2] /= float(Vertex_offsetNum[o]);
        }
      } 
  
  
      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) {
  
        int vNo = userSelections.Vertex_ids[o];
  
        allPoints.addX(vNo, Vertex_offsetValues[o][0]);
        allPoints.addY(vNo, Vertex_offsetValues[o][1]);
        allPoints.addZ(vNo, Vertex_offsetValues[o][2]);
      } 
  
      userSelections.calculate_selection_BoundingBox();
  
    }
  }
  
  
  
  
  
  void changeVisibilityFaces_Selection (int new_vsb) {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Faces();
      }
  
      if (current_ObjectCategory == ObjectCategory.VERTEX) { 
  
        this.convert_Vertices_to_Faces();
      }
  
      for (int o = userSelections.Face_ids.length - 1; o >= 0; o--) {
  
        int f = userSelections.Face_ids[o];
  
        allFaces.setVisibility(f, new_vsb);
  
      }
    }
  }
  
  
  void changeVisibilityFaces_Scene (int new_vsb) {
  
    for (int f = allFaces.nodes.length - 1; f >= 0; f--) { 
      allFaces.setVisibility(f, new_vsb);
    }
  }
  
  
  void reverseVisibilityFaces_Scene () {
  
    for (int f = allFaces.nodes.length - 1; f >= 0; f--) { 
  
      int vsb = allFaces.getVisibility(f);
      int new_vsb = vsb;
  
      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;
  
      allFaces.setVisibility(f, new_vsb);
    }
  }
  
  
  void changeVisibilityCurves_Selection (int new_vsb) {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      if (current_ObjectCategory == ObjectCategory.GROUP) { 
  
        this.convert_allGroups_to_Curves();
      }
  
      if (current_ObjectCategory == ObjectCategory.VERTEX) { 
  
        this.convert_Vertices_to_Curves();
      }
  
      for (int o = userSelections.Curve_ids.length - 1; o >= 0; o--) {
  
        int f = userSelections.Curve_ids[o];
  
        allCurves.setVisibility(f, new_vsb);
  
      }
    }
  }
  
  
  void changeVisibilityCurves_Scene (int new_vsb) {
  
    for (int f = allCurves.nodes.length - 1; f >= 0; f--) { 
      allCurves.setVisibility(f, new_vsb);
    }
  }
  
  
  void reverseVisibilityCurves_Scene () {
  
    for (int f = allCurves.nodes.length - 1; f >= 0; f--) { 
  
      int vsb = allCurves.getVisibility(f);
      int new_vsb = vsb;
  
      if (vsb == 0) new_vsb = 1;
      else if (vsb == 1) new_vsb = 0;
  
      allCurves.setVisibility(f, new_vsb);
    }
  }
  
  
  
  void isolate_Selection () {
  
    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX)) { 
  
      this.changeVisibilityFaces_Scene(0);
      this.changeVisibilityFaces_Selection(1);
      
      this.changeVisibilityCurves_Scene(0);
      this.changeVisibilityCurves_Selection(1);    
    }
  }
  
  
  void select_Last () {
    
    if (current_ObjectCategory == ObjectCategory.SECTION) {
      userSelections.Section_ids = new int [0];
      
      if (allSections.num > 0) {
        int[] new_Item = {allSections.num - 1};
        userSelections.Section_ids = concat(userSelections.Section_ids, new_Item);
      }
    }   
    
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      userSelections.Camera_ids = new int [0];
      
      if (allCameras.num > 0) {
        int[] new_Item = {allCameras.num - 1};
        userSelections.Camera_ids = concat(userSelections.Camera_ids, new_Item);
      }
    }   
    
    if (current_ObjectCategory == ObjectCategory.SOLID) {
      userSelections.Solid_ids = new int [0];
      
      if (allSolids.DEF.length > 0) {
        int[] new_Item = {allSolids.DEF.length - 1};
        userSelections.Solid_ids = concat(userSelections.Solid_ids, new_Item);
      }
    } 
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      userSelections.Model1D_ids = new int [0];
      
      if (allModel1Ds.num > 0) {
        int[] new_Item = {allModel1Ds.num - 1};
        userSelections.Model1D_ids = concat(userSelections.Model1D_ids, new_Item);
      }
    } 
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      userSelections.Model2D_ids = new int [0];
      
      if (allModel2Ds.num > 0) {
        int[] new_Item = {allModel2Ds.num - 1};
        userSelections.Model2D_ids = concat(userSelections.Model2D_ids, new_Item);
      }
    } 
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      userSelections.Group_ids = new int [0];
  
      if (allGroups.num > 0) {
        int[] new_Item = {allGroups.num - 1};
        userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
      }
    } 
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
      userSelections.Face_ids = new int [0];
      
      if (allFaces.nodes.length > 0) {
        int[] new_Item = {allFaces.nodes.length - 1};
        userSelections.Face_ids = concat(userSelections.Face_ids, new_Item);
      }
    } 
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      userSelections.Vertex_ids = new int [0];
      
      if (allPoints.getLength() > 0) {
        int[] new_Item = {allPoints.getLength() - 1};
        userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
      }
    } 
  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
      userSelections.Curve_ids = new int [0];
      
      if (allCurves.nodes.length > 0) {
        int[] new_Item = {allCurves.nodes.length - 1};
        userSelections.Curve_ids = concat(userSelections.Curve_ids, new_Item);
      }
    } 
  
    userSelections.calculate_selection_BoundingBox();  
  }
  
  
  
  void deselect_All () {
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      userSelections.LandPoint_ids = new int [0];
    }  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {  
      userSelections.Section_ids = new int [0];
    }  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {  
      userSelections.Camera_ids = new int [0];
    }  
  
  
  
    if ((current_ObjectCategory == ObjectCategory.MODEL1D) || (current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.MODEL2D) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE) || (current_ObjectCategory == ObjectCategory.VERTEX) || (current_ObjectCategory == ObjectCategory.SOFTVERTEX) || (current_ObjectCategory == ObjectCategory.SOLID)) {  
  
      userSelections.Model1D_ids = new int [0];
  
      userSelections.Group_ids = new int [0];
  
      userSelections.Model2D_ids = new int [0];
  
      userSelections.Face_ids = new int [0];
  
      userSelections.Vertex_ids = new int [0];
    
      userSelections.Curve_ids = new int [0];
  
      userSelections.Solid_ids = new int [0];
    }  
  
    userSelections.calculate_selection_BoundingBox();
  }
  
  void select_All () {
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      userSelections.LandPoint_ids = new int [Land3D.num_rows * Land3D.num_columns];
      for (int i = 0; i < userSelections.LandPoint_ids.length; i++) { 
        userSelections.LandPoint_ids[i] = i;
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      userSelections.Model1D_ids = new int [allModel1Ds.num];
      for (int i = 0; i < userSelections.Model1D_ids.length; i++) { 
        userSelections.Model1D_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      userSelections.Model2D_ids = new int [allModel2Ds.num];
      for (int i = 0; i < userSelections.Model2D_ids.length; i++) { 
        userSelections.Model2D_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      userSelections.Group_ids = new int [allGroups.num];
      for (int i = 0; i < userSelections.Group_ids.length; i++) { 
        userSelections.Group_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
      userSelections.Face_ids = new int [allFaces.nodes.length];
      for (int i = 0; i < userSelections.Face_ids.length; i++) { 
        userSelections.Face_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      userSelections.Vertex_ids = new int [allPoints.getLength()];
      for (int i = 0; i < userSelections.Vertex_ids.length; i++) { 
        userSelections.Vertex_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
      userSelections.Curve_ids = new int [allCurves.nodes.length];
      for (int i = 0; i < userSelections.Curve_ids.length; i++) { 
        userSelections.Curve_ids[i] = i;
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
      userSelections.Solid_ids = new int [allSolids.DEF.length];
      for (int i = 0; i < userSelections.Solid_ids.length; i++) { 
        userSelections.Solid_ids[i] = i;
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
      userSelections.Section_ids = new int [allSections.num];
      for (int i = 0; i < userSelections.Section_ids.length; i++) { 
        userSelections.Section_ids[i] = i;
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      userSelections.Camera_ids = new int [allCameras.num];
      for (int i = 0; i < userSelections.Camera_ids.length; i++) { 
        userSelections.Camera_ids[i] = i;
      }
    }  
  
    userSelections.calculate_selection_BoundingBox();
  }
  
  
  void reverse_Selection () {
  
    if (current_ObjectCategory == ObjectCategory.LANDPOINT) {
      int[] pre_Selection_LandPoint_ids = sort(userSelections.LandPoint_ids);
  
      userSelections.LandPoint_ids = new int [0];
  
      for (int i = 0; i < Land3D.num_rows * Land3D.num_columns; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_LandPoint_ids.length; j++) {
  
          if (pre_Selection_LandPoint_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_LandPoint_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.LandPoint_ids = concat(userSelections.LandPoint_ids, new_Item);
        }
      }
    }     
  
    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
      int[] pre_Selection_Model1D_ids = sort(userSelections.Model1D_ids);
  
      userSelections.Model1D_ids = new int [0];
  
      for (int i = 0; i < allModel1Ds.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Model1D_ids.length; j++) {
  
          if (pre_Selection_Model1D_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Model1D_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Model1D_ids = concat(userSelections.Model1D_ids, new_Item);
        }
      }
    }    
  
    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
      int[] pre_Selection_Model2D_ids = sort(userSelections.Model2D_ids);
  
      userSelections.Model2D_ids = new int [0];
  
      for (int i = 0; i < allModel2Ds.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Model2D_ids.length; j++) {
  
          if (pre_Selection_Model2D_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Model2D_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Model2D_ids = concat(userSelections.Model2D_ids, new_Item);
        }
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.GROUP) {
      int[] pre_Selection_Group_ids = sort(userSelections.Group_ids);
  
      userSelections.Group_ids = new int [0];
  
      for (int i = 0; i < allGroups.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Group_ids.length; j++) {
  
          if (pre_Selection_Group_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Group_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
        }
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.FACE) {
      int[] pre_Selection_Face_ids = sort(userSelections.Face_ids);
  
      userSelections.Face_ids = new int [0];
  
      for (int i = 0; i < allFaces.nodes.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Face_ids.length; j++) {
  
          if (pre_Selection_Face_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Face_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Face_ids = concat(userSelections.Face_ids, new_Item);
        }
      }
    }  
  
    if (current_ObjectCategory == ObjectCategory.CURVE) {
      int[] pre_Selection_Curve_ids = sort(userSelections.Curve_ids);
  
      userSelections.Curve_ids = new int [0];
  
      for (int i = 0; i < allCurves.nodes.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Curve_ids.length; j++) {
  
          if (pre_Selection_Curve_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Curve_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Curve_ids = concat(userSelections.Curve_ids, new_Item);
        }
      }
    }  
  
  
    if (current_ObjectCategory == ObjectCategory.VERTEX) {
      int[] pre_Selection_Vertex_ids = sort(userSelections.Vertex_ids);
  
      userSelections.Vertex_ids = new int [0];
  
      for (int i = 0; i < allPoints.getLength(); i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Vertex_ids.length; j++) {
  
          if (pre_Selection_Vertex_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Vertex_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
        }
      }
    }
  
    if (current_ObjectCategory == ObjectCategory.SOLID) {
      int[] pre_Selection_Solid_ids = sort(userSelections.Solid_ids);
  
      userSelections.Solid_ids = new int [0];
  
      for (int i = 0; i < allSolids.DEF.length; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Solid_ids.length; j++) {
  
          if (pre_Selection_Solid_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Solid_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Solid_ids = concat(userSelections.Solid_ids, new_Item);
        }
      }
    }      
  
    if (current_ObjectCategory == ObjectCategory.SECTION) {
      int[] pre_Selection_Section_ids = sort(userSelections.Section_ids);
  
      userSelections.Section_ids = new int [0];
  
      for (int i = 0; i < allSections.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Section_ids.length; j++) {
  
          if (pre_Selection_Section_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Section_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Section_ids = concat(userSelections.Section_ids, new_Item);
        }
      }
    }    
  
    if (current_ObjectCategory == ObjectCategory.CAMERA) {
      int[] pre_Selection_Camera_ids = sort(userSelections.Camera_ids);
  
      userSelections.Camera_ids = new int [0];
  
      for (int i = 0; i < allCameras.num; i++) {
        int found = -1; 
  
        for (int j = 0; j < pre_Selection_Camera_ids.length; j++) {
  
          if (pre_Selection_Camera_ids[j] == i) {
            found = 1;
            break;
          } else if (pre_Selection_Camera_ids[j] > i) {
            break;
          }
        }
  
        if (found == -1) {
          int[] new_Item = {
            i
          };
  
          userSelections.Camera_ids = concat(userSelections.Camera_ids, new_Item);
        }
      }
    }    
  
    userSelections.calculate_selection_BoundingBox();
  }  
  
  
  void convert_allModel1Ds_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Model1D_ids.length; i++) {
  
      int f = userSelections.Model1D_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.Model1Ds[OBJ_NUM][0] <= f) && (f <= allGroups.Model1Ds[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < userSelections.Group_ids.length; q++) {
            if (userSelections.Group_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
          }
        }
      }
    }
  }
  
  
  void convert_allModel2Ds_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Model2D_ids.length; i++) {
  
      int f = userSelections.Model2D_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.Model2Ds[OBJ_NUM][0] <= f) && (f <= allGroups.Model2Ds[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < userSelections.Group_ids.length; q++) {
            if (userSelections.Group_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
          }
        }
      }
    }
  }
  
  
  void convert_allSolids_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Solid_ids.length; i++) {
  
      int f = userSelections.Solid_ids[i];
  
      for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
        if ((allGroups.Solids[OBJ_NUM][0] <= f) && (f <= allGroups.Solids[OBJ_NUM][1])) { 
  
          int previously_added = 0;
          for (int q = 0; q < userSelections.Group_ids.length; q++) {
  
  
            if (userSelections.Group_ids[q] == OBJ_NUM) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              OBJ_NUM
            };
            userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
          }
        }
      }
    }
  }
  
  void convert_Faces_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Face_ids.length; i++) {
  
      int f = userSelections.Face_ids[i];
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
        for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
          if ((allGroups.Faces[OBJ_NUM][0] <= f) && (f <= allGroups.Faces[OBJ_NUM][1])) { 
  
            int previously_added = 0;
            for (int q = 0; q < userSelections.Group_ids.length; q++) {
              if (userSelections.Group_ids[q] == OBJ_NUM) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_NUM
              };
              userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  void convert_Curves_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Curve_ids.length; i++) {
  
      int f = userSelections.Curve_ids[i];
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
        for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
          if ((allGroups.Curves[OBJ_NUM][0] <= f) && (f <= allGroups.Curves[OBJ_NUM][1])) { 
  
            int previously_added = 0;
            for (int q = 0; q < userSelections.Group_ids.length; q++) {
              if (userSelections.Group_ids[q] == OBJ_NUM) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                OBJ_NUM
              };
              userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  
  void convert_Vertices_to_allGroups () {
  
    userSelections.Group_ids = new int [0];
  
    for (int i = 0; i < userSelections.Vertex_ids.length; i++) {
  
      int vNo = userSelections.Vertex_ids[i];
  
      for (int f = 0; f < allFaces.nodes.length; f++) {
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          if (allFaces.nodes[f][j] == vNo) { 
  
            for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
              if ((allGroups.Faces[OBJ_NUM][0] <= f) && (f <= allGroups.Faces[OBJ_NUM][1])) { 
  
                int previously_added = 0;
                for (int q = 0; q < userSelections.Group_ids.length; q++) {
                  if (userSelections.Group_ids[q] == OBJ_NUM) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_NUM
                  };
                  userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
                }
              }
            }
          }
        }
      }
      
      for (int f = 0; f < allCurves.nodes.length; f++) {
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          if (allCurves.nodes[f][j] == vNo) { 
  
            for (int OBJ_NUM = 0; OBJ_NUM < allGroups.num; OBJ_NUM++) {
  
              if ((allGroups.Curves[OBJ_NUM][0] <= f) && (f <= allGroups.Curves[OBJ_NUM][1])) { 
  
                int previously_added = 0;
                for (int q = 0; q < userSelections.Group_ids.length; q++) {
                  if (userSelections.Group_ids[q] == OBJ_NUM) {
                    previously_added = 1;
                    break;
                  }
                }
                if (previously_added == 0) {
                  int[] new_Item = {
                    OBJ_NUM
                  };
                  userSelections.Group_ids = concat(userSelections.Group_ids, new_Item);
                }
              }
            }
          }
        }
      }    
    }
  }
  
  
  void convert_Vertices_to_Faces () {
  
    userSelections.Face_ids = new int [0];
  
    for (int i = 0; i < userSelections.Vertex_ids.length; i++) {
  
      int vNo = userSelections.Vertex_ids[i];
  
      for (int f = 0; f < allFaces.nodes.length; f++) {
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          if (allFaces.nodes[f][j] == vNo) { 
  
            int previously_added = 0;
            for (int q = 0; q < userSelections.Face_ids.length; q++) {
              if (userSelections.Face_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              userSelections.Face_ids = concat(userSelections.Face_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  void convert_Vertices_to_Curves () {
  
    userSelections.Curve_ids = new int [0];
  
    for (int i = 0; i < userSelections.Vertex_ids.length; i++) {
  
      int vNo = userSelections.Vertex_ids[i];
  
      for (int f = 0; f < allCurves.nodes.length; f++) {
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          if (allCurves.nodes[f][j] == vNo) { 
  
            int previously_added = 0;
            for (int q = 0; q < userSelections.Curve_ids.length; q++) {
              if (userSelections.Curve_ids[q] == f) {
                previously_added = 1;
                break;
              }
            }
            if (previously_added == 0) {
              int[] new_Item = {
                f
              };
              userSelections.Curve_ids = concat(userSelections.Curve_ids, new_Item);
            }
          }
        }
      }
    }
  }
  
  
  void convert_allGroups_to_allModel1Ds () {
  
    userSelections.Model1D_ids = new int [0];
    
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Model1Ds[OBJ_NUM][0]; f <= allGroups.Model1Ds[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Model1D_ids.length; q++) {
          if (userSelections.Model1D_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          userSelections.Model1D_ids = concat(userSelections.Model1D_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_allModel2Ds () {
  
    userSelections.Model2D_ids = new int [0];
  
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Model2Ds[OBJ_NUM][0]; f <= allGroups.Model2Ds[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Model2D_ids.length; q++) {
          if (userSelections.Model2D_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          userSelections.Model2D_ids = concat(userSelections.Model2D_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_allSolids () {
  
    userSelections.Solid_ids = new int [0];
  
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Solids[OBJ_NUM][0]; f <= allGroups.Solids[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Solid_ids.length; q++) {
          if (userSelections.Solid_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          userSelections.Solid_ids = concat(userSelections.Solid_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_Faces () {
  
    userSelections.Face_ids = new int [0];
  
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Face_ids.length; q++) {
          if (userSelections.Face_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          userSelections.Face_ids = concat(userSelections.Face_ids, new_Item);
        }
      }
    }
  }
  
  
  void convert_allGroups_to_Curves () {
  
    userSelections.Curve_ids = new int [0];
  
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) { 
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Curve_ids.length; q++) {
          if (userSelections.Curve_ids[q] == f) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            f
          };
          userSelections.Curve_ids = concat(userSelections.Curve_ids, new_Item);
        }
      }
    }
  }
  
  
  
  void convert_allGroups_to_Vertices () {
  
    userSelections.Vertex_ids = new int [0];
  
    for (int i = 0; i < userSelections.Group_ids.length; i++) {
  
      int OBJ_NUM = userSelections.Group_ids[i];
  
      for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) { 
  
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
          int vNo = allFaces.nodes[f][j];
  
          int previously_added = 0;
          for (int q = 0; q < userSelections.Vertex_ids.length; q++) {
            if (userSelections.Vertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
          }
        }
      }
      
      for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) { 
  
        for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
          int vNo = allCurves.nodes[f][j];
  
          int previously_added = 0;
          for (int q = 0; q < userSelections.Vertex_ids.length; q++) {
            if (userSelections.Vertex_ids[q] == vNo) {
              previously_added = 1;
              break;
            }
          }
          if (previously_added == 0) {
            int[] new_Item = {
              vNo
            };
            userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
          }
        }
      }    
    }
  }
  
  
  void convert_Faces_to_Vertices () {
  
    userSelections.Vertex_ids = new int [0];
  
    for (int i = 0; i < userSelections.Face_ids.length; i++) {
  
      int f = userSelections.Face_ids[i];
  
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
  
        int vNo = allFaces.nodes[f][j];
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Vertex_ids.length; q++) {
          if (userSelections.Vertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
        }
      }
    }
  }
  
  
  void convert_Curves_to_Vertices () {
  
    userSelections.Vertex_ids = new int [0];
  
    for (int i = 0; i < userSelections.Curve_ids.length; i++) {
  
      int f = userSelections.Curve_ids[i];
  
      for (int j = 0; j < allCurves.nodes[f].length; j++) {
  
        int vNo = allCurves.nodes[f][j];
  
        int previously_added = 0;
        for (int q = 0; q < userSelections.Vertex_ids.length; q++) {
          if (userSelections.Vertex_ids[q] == vNo) {
            previously_added = 1;
            break;
          }
        }
        if (previously_added == 0) {
          int[] new_Item = {
            vNo
          };
          userSelections.Vertex_ids = concat(userSelections.Vertex_ids, new_Item);
        }
      }
    }
  }
  
  

  
  void convert_Vertex_to_softSelection () { 
  
    int[] keep_selection_Vertex_ids = userSelections.Vertex_ids;
  
    this.convert_Vertices_to_allGroups();
  
    this.convert_allGroups_to_Vertices();
  
    userSelections.Vertex_softSelectionVertices = new int[userSelections.Vertex_ids.length]; 
    userSelections.Vertex_softSelectionValues = new float[userSelections.Vertex_ids.length];
  
    for (int q = 0; q < userSelections.Vertex_ids.length; q++) {
  
      int n = userSelections.Vertex_ids[q];
  
      float d_min = FLOAT_undefined;
  
      for (int p = 0; p < keep_selection_Vertex_ids.length; p++) {
  
        int m = keep_selection_Vertex_ids[p];
  
        float d = dist(allPoints.getX(m), allPoints.getY(m), allPoints.getZ(m), allPoints.getX(n), allPoints.getY(n), allPoints.getZ(n));
  
        if (d_min > d) {
          d_min = d;
        }
      }
  
      userSelections.Vertex_softSelectionValues[q] = userSelections.softVertexSelectionFunction(d_min);
    }
  
    userSelections.Vertex_softSelectionVertices = userSelections.Vertex_ids;
  
    userSelections.Vertex_ids = keep_selection_Vertex_ids;
  }
  
  
  
  void add_Octahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {
    
    if ((rx > 0) && (ry > 0) && (rz > 0)) {    
      
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      float teta = rot * PI / 180.0;
    
      float[] X_ = new float [6];
      float[] Y_ = new float [6];
      float[] Z_ = new float [6];
    
      float q = pow(2, 0.5);
    
      X_[0] = 0;  
      Y_[0] = 0;  
      Z_[0] = q;
      X_[1] = q;  
      Y_[1] = 0;  
      Z_[1] = 0;
      X_[2] = 0;  
      Y_[2] = q;  
      Z_[2] = 0;
      X_[3] = -q;  
      Y_[3] = 0;  
      Z_[3] = 0;
      X_[4] = 0;  
      Y_[4] = -q;  
      Z_[4] = 0;
      X_[5] = 0;  
      Y_[5] = 0;  
      Z_[5] = -q;
    
      for (int i = 0; i < 6; i++) {
        X_[i] *= rx;
        Y_[i] *= ry;
        Z_[i] *= rz;
    
        float X_r = X_[i] * cos(teta) - Y_[i] * sin(teta);
        float Y_r = X_[i] * sin(teta) + Y_[i] * cos(teta);
        float Z_r = Z_[i];
    
        X_[i] = X_r + x;
        Y_[i] = Y_r + y;
        Z_[i] = Z_r + z;
      }
    
      int[] v = new int [6];
    
      for (int i = 0; i < 6; i++) {
        v[i] = this.add_Vertex(X_[i], Y_[i], Z_[i]);
      } 
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
      {
        int[] newFace_nodes = {
          v[1], v[2], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
    
      {
        int[] newFace_nodes = {
          v[2], v[3], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
    
      {
        int[] newFace_nodes = {
          v[3], v[4], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
    
      {
        int[] newFace_nodes = {
          v[4], v[1], v[0]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
    
      {
        int[] newFace_nodes = {
          v[1], v[5], v[2]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
    
      {
        int[] newFace_nodes = {
          v[2], v[5], v[3]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }      
      {
        int[] newFace_nodes = {
          v[3], v[5], v[4]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
    
      {
        int[] newFace_nodes = {
          v[4], v[5], v[1]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      
    }            
  }
  
  
  void add_House1_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {
   
    if ((rx > 0) && (ry > 0) && (rz > 0)) {
      
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      float teta = rot * PI / 180.0;
    
      float x1 = rx;  
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;
    
      float y1 = ry;  
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;
    
      float z0 = -rz; 
      float z1 = rz;
      float z2 = h2;
    
      float[] vx = { 
        1, -1, -1, 1, 1, -1, -1, 1, 1, -1
      };
      float[] vy = { 
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };
    
      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;
    
        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];
    
        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }  
    
      int b1 = this.add_Vertex(vx[0], vy[0], vz[0]);
      int b2 = this.add_Vertex(vx[1], vy[1], vz[1]);
      int b3 = this.add_Vertex(vx[2], vy[2], vz[2]);
      int b4 = this.add_Vertex(vx[3], vy[3], vz[3]);
    
      int t1 = this.add_Vertex(vx[4], vy[4], vz[4]);
      int t2 = this.add_Vertex(vx[5], vy[5], vz[5]);
      int t3 = this.add_Vertex(vx[6], vy[6], vz[6]);
      int t4 = this.add_Vertex(vx[7], vy[7], vz[7]);
    
      int m1 = this.add_Vertex(vx[8], vy[8], vz[8]);
      int m2 = this.add_Vertex(vx[9], vy[9], vz[9]);
    
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
    
      {//West
        int[] newFace_nodes = {
          t3, m2, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//Roof-South
        int[] newFace_nodes = {
          m1, m2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//East
        int[] newFace_nodes = {
          t1, m1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//Roof-North
        int[] newFace_nodes = {
          m2, m1, t1, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  void add_House2_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float h2, float rot) {
  
    if ((rx > 0) && (ry > 0) && (rz > 0)) {
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
  
      if (ry > rx) {
        
        float tmp = rx;
        rx = ry;
        ry = tmp;
        
        rot += 90;
      }      
  
      float teta = rot * PI / 180.0;
    
      float x1 = rx;  
      float x2 = -rx;
      float x3 = -rx;
      float x4 = rx;
    
      float y1 = ry;  
      float y2 = ry;
      float y3 = -ry;
      float y4 = -ry;
    
      float z0 = -rz; 
      float z1 = rz;
      float z2 = h2;
    
      float[] vx = { 
        1, -1, -1, 1, 1, -1, -1, 1, 1-ry/rx, -1+ry/rx
      };
      float[] vy = { 
        1, 1, -1, -1, 1, 1, -1, -1, 0, 0
      };
      float[] vz = {
        0, 0, 0, 0, 1, 1, 1, 1, 1+h2/rz, 1+h2/rz
      };
      
      for (int i = 0; i < 10; i++) {
        vx[i] *= rx;
        vy[i] *= ry;
        vz[i] *= rz;
    
        float vx_rot = x + vx[i] * cos(teta) - vy[i] * sin(teta);
        float vy_rot = y + vx[i] * sin(teta) + vy[i] * cos(teta);
        float vz_rot = z + vz[i];
    
        vx[i] = vx_rot;
        vy[i] = vy_rot;
        vz[i] = vz_rot;
      }  
    
      int b1 = this.add_Vertex(vx[0], vy[0], vz[0]);
      int b2 = this.add_Vertex(vx[1], vy[1], vz[1]);
      int b3 = this.add_Vertex(vx[2], vy[2], vz[2]);
      int b4 = this.add_Vertex(vx[3], vy[3], vz[3]);
    
      int t1 = this.add_Vertex(vx[4], vy[4], vz[4]);
      int t2 = this.add_Vertex(vx[5], vy[5], vz[5]);
      int t3 = this.add_Vertex(vx[6], vy[6], vz[6]);
      int t4 = this.add_Vertex(vx[7], vy[7], vz[7]);
    
      int m1 = this.add_Vertex(vx[8], vy[8], vz[8]);
      int m2 = this.add_Vertex(vx[9], vy[9], vz[9]);
    
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
    
      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//Roof-West
        int[] newFace_nodes = {
          t3, m2, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//Roof-South
        int[] newFace_nodes = {
          m1, m2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//Roof-East
        int[] newFace_nodes = {
          t1, m1, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }  
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//Roof-North
        int[] newFace_nodes = {
          m2, m1, t1, t2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }    
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  
  void add_Box_Core (int m, int tes, int lyr, int vsb, int wgt, int clz, float x, float y, float z, float rx, float ry, float rz, float rot) {
  
    if ((rx > 0) && (ry > 0) && (rz > 0)) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      float teta = rot * PI / 180.0;
    
      int t1 = this.add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z + rz);
      int t2 = this.add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z + rz);
      int t3 = this.add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z + rz);
      int t4 = this.add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z + rz);
    
      int b1 = this.add_Vertex(x + (rx * cos(teta) - ry * sin(teta)), y + (rx * sin(teta) + ry * cos(teta)), z - rz);
      int b2 = this.add_Vertex(x + (-rx * cos(teta) - ry * sin(teta)), y + (-rx * sin(teta) + ry * cos(teta)), z - rz);
      int b3 = this.add_Vertex(x + (-rx * cos(teta) + ry * sin(teta)), y + (-rx * sin(teta) - ry * cos(teta)), z - rz);
      int b4 = this.add_Vertex(x + (rx * cos(teta) + ry * sin(teta)), y + (rx * sin(teta) - ry * cos(teta)), z - rz);
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
    
      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//Roof
        int[] newFace_nodes = {
          t1, t2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  void add_Box_Corners (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2) {
  
    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int t1 = this.add_Vertex(x2, y2, z2);
      int t2 = this.add_Vertex(x1, y2, z2);
      int t3 = this.add_Vertex(x1, y1, z2);
      int t4 = this.add_Vertex(x2, y1, z2);
    
      int b1 = this.add_Vertex(x2, y2, z1);
      int b2 = this.add_Vertex(x1, y2, z1);
      int b3 = this.add_Vertex(x1, y1, z1);
      int b4 = this.add_Vertex(x2, y1, z1);
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
    
      {//West
        int[] newFace_nodes = {
          t3, t2, b2, b3
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//Roof
        int[] newFace_nodes = {
          t1, t2, t3, t4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//East
        int[] newFace_nodes = {
          t1, t4, b4, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//North
        int[] newFace_nodes = {
          t2, t1, b1, b2
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//South
        int[] newFace_nodes = {
          t4, t3, b3, b4
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      {//Bottom
        int[] newFace_nodes = {
          b4, b3, b2, b1
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  void add_H_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float d, float w, float Alpha, float Beta) {
  
    if ((d > 0) && (w > 0)) {
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      float rx = 0.5 * d * funcs.cos_ang(Beta);
      float ry = 0.5 * d * funcs.sin_ang(Beta);
    
      float wx = w * funcs.cos_ang(Beta - 90) * funcs.cos_ang(Alpha);
      float wy = w * funcs.sin_ang(Beta - 90) * funcs.cos_ang(Alpha);
      float wz = w * funcs.sin_ang(Alpha);
    
      float x1 = x0 + rx;
      float y1 = y0 + ry;
      float z1 = z0;
    
      float x2 = x0 - rx;
      float y2 = y0 - ry;
      float z2 = z0;
    
      float x3 = wx + x0 - rx;
      float y3 = wy + y0 - ry;
      float z3 = wz + z0;
    
      float x4 = wx + x0 + rx;
      float y4 = wy + y0 + ry;
      float z4 = wz + z0;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  void add_V_shade (int m, int tes, int lyr, int vsb, int wgt, int clz, float x0, float y0, float z0, float h, float d, float t, float t0) {
  
    if ((d > 0) && (h > 0)) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      float dx = d * funcs.cos_ang(t + t0 - 90);
      float dy = d * funcs.sin_ang(t + t0 - 90);
    
      float x1 = x0;
      float y1 = y0;
      float z1 = z0 - 0.5 * h;
    
      float x2 = x0;
      float y2 = y0;
      float z2 = z0 + 0.5 * h;
    
      float x3 = x0 + dx;
      float y3 = y0 + dy;
      float z3 = z0 + 0.5 * h;
    
      float x4 = x0 + dx;
      float y4 = y0 + dy;
      float z4 = z0 - 0.5 * h;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  
  void add_Mesh2 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x3, float y3, float z3) {
  
    if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {    
      
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt; 
      current_Closed = clz;
    
      float x2 = x3;
      float y2 = y3;
      float z2 = z3;
    
      float x4 = x1;
      float y4 = y1;
      float z4 = z1;
    
      if (z1 == z3) {
        y2 = y1;
        y4 = y3;
      } else if (y1 == y3) {
        x2 = x1;
        x4 = x3;
      } else if (x1 == x3) {
        z2 = z1;
        z4 = z3;
      }  
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  void add_Mesh3 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {
  
    if ((x1 != x2) || (y1 != y2) || (z1 != z2)) {  
      if ((x2 != x3) || (y2 != y3) || (z2 != z3)) {  
        if ((x1 != x3) || (y1 != y3) || (z1 != z3)) {    
    
          current_Material = m;
          current_Tessellation = tes;
          current_Layer = lyr;
          current_Visibility = vsb;
          current_Weight = wgt;
          current_Closed = clz;
        
          int v1 = this.add_Vertex(x1, y1, z1);
          int v2 = this.add_Vertex(x2, y2, z2);
          int v3 = this.add_Vertex(x3, y3, z3);
        
          {
            int[] newFace_nodes = {
              v1, v2, v3
            };
            this.add_Face(newFace_nodes);
          }
    
        }
      }
    }
  }
  
  
  
  void add_Mesh4 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else if ((x1 == x4) && (y1 == y4) && (z1 == z4)) {
      
      this.add_Mesh3 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
    }
    else {
          
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;  
      current_Closed = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4
        };
        this.add_Face(newFace_nodes);
      }
          
    }
  
  }
  
  
  
  void add_Mesh5 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }
    else if ((x1 == x5) && (y1 == y5) && (z1 == z5)) {
      
      this.add_Mesh4 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    }  
    else {  
      
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
      int v5 = this.add_Vertex(x5, y5, z5);
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4, v5
        };
        this.add_Face(newFace_nodes);
      }
      
    }
  }
  
  
  void add_Mesh6 (int m, int tes, int lyr, int vsb, int wgt, int clz, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float x5, float y5, float z5, float x6, float y6, float z6) {
  
    if ((x1 == x2) && (y1 == y2) && (z1 == z2)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }    
    else if ((x2 == x3) && (y2 == y3) && (z2 == z3)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x4, y4, z4, x5, y5, z5, x6, y6, z6);
    }      
    else if ((x3 == x4) && (y3 == y4) && (z3 == z4)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x5, y5, z5, x6, y6, z6);
    }
    else if ((x4 == x5) && (y4 == y5) && (z4 == z5)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x6, y6, z6);
    }
    else if ((x5 == x6) && (y5 == y6) && (z5 == z6)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }    
    else if ((x1 == x6) && (y1 == y6) && (z1 == z6)) {
      
      this.add_Mesh5 (m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
    }  
    else {    
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int v1 = this.add_Vertex(x1, y1, z1);
      int v2 = this.add_Vertex(x2, y2, z2);
      int v3 = this.add_Vertex(x3, y3, z3);
      int v4 = this.add_Vertex(x4, y4, z4);
      int v5 = this.add_Vertex(x5, y5, z5);
      int v6 = this.add_Vertex(x6, y6, z6);
    
      {
        int[] newFace_nodes = {
          v1, v2, v3, v4, v5, v6
        };
        this.add_Face(newFace_nodes);
      }
    }
  }
  
  
  
  
  void add_PolygonHyper (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {
  
    if ((r > 0) && (h > 0) && (n > 2)) {
      
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int[] newFace_nodes = {
        this.add_Vertex(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz - 0.5 * h)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);
        int[] f = {
          this.add_Vertex(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz + (2 * (i % 2) - 1) * 0.5 * h)
        };
        newFace_nodes = concat(newFace_nodes, f);
      } 
    
      this.add_Face(newFace_nodes);
    }
  }
  
  
  
  void add_PolygonMesh (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int n, float rot) {
  
    if ((r > 0) && (n > 2)) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int[] newFace_nodes = {
        this.add_Vertex(cx + r * funcs.cos_ang(0), cy + r * funcs.sin_ang(0), cz)
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n) + rot;
        int[] f = {
          this.add_Vertex(cx + r * funcs.cos_ang(t), cy + r * funcs.sin_ang(t), cz)
        };
        newFace_nodes = concat(newFace_nodes, f);
      } 
    
      this.add_Face(newFace_nodes);
    }
  }
  
  
  
  void add_PolygonExtrude (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float h, int n, float rot) {
  
    if ((r > 0) && (h > 0) && (n > 2)) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int[] vT = new int [n];
      int[] vB = new int [n];
    
      vT[0] = this.add_Vertex(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz + 0.5 * h);
      vB[0] = this.add_Vertex(cx + r * funcs.cos_ang(rot), cy + r * funcs.sin_ang(rot), cz - 0.5 * h);
    
      int[] newFace_nodesT = {
        vT[0]
      };
      int[] newFace_nodesB = {
        vB[0]
      };
      for (int i = 1; i < n; i++) {
        float t = i * 360.0 / float(n);
    
        vT[i] = this.add_Vertex(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz + 0.5 * h);
        vB[i] = this.add_Vertex(cx + r * funcs.cos_ang(t + rot), cy + r * funcs.sin_ang(t + rot), cz - 0.5 * h);
        int[] fT = {
          vT[i]
        };
        int[] fB = {
          vB[i]
        };
    
        newFace_nodesT = concat(newFace_nodesT, fT);
        newFace_nodesB = concat(newFace_nodesB, fB);
      } 
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
      this.add_Face(newFace_nodesT);
    
      if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1)); 
      this.add_Face(newFace_nodesB);
    
      for (int i = 0; i < n; i++) {
        int next_i = (i + 1) % n;
    
        int[] newFace_nodes = {
          vT[i], vB[i], vB[next_i], vT[next_i]
        };
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1)); 
        this.add_Face(newFace_nodes);
      }
    }
  }
  
  
  
  
  
  
  void add_Icosahedron (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, float rot) {
  
    if (r > 0) {  
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int[] vT = new int [6];
      int[] vB = new int [6];
    
      vT[0] = this.add_Vertex(cx, cy, cz + r);
      vB[0] = this.add_Vertex(cx, cy, cz - r);
    
      for (int i = 1; i <= 5; i++) {
        float t = i * 72;
    
        float R_in = r * pow(5.0, 0.5) * 2.0 / 5.0;  
        float H_in = r * pow(5.0, 0.5) * 1.0 / 5.0;
    
        vT[i] = this.add_Vertex(cx + R_in * funcs.cos_ang(t + rot), cy + R_in * funcs.sin_ang(t + rot), cz + H_in);
        vB[i] = this.add_Vertex(cx + R_in * funcs.cos_ang(t + 36 + rot), cy + R_in * funcs.sin_ang(t + 36 + rot), cz - H_in);
      } 
    
    
      if (m == -1) current_Material = 0;
      else current_Material = m;
    
      for (int i = 1; i <= 5; i++) {
    
        int next_i = (i % 5) + 1;
    
        {
          int[] newFace_nodesT = new int [3];
          int[] newFace_nodesB = new int [3];
    
          newFace_nodesT[0] = vT[i];
          newFace_nodesT[1] = vT[next_i];
          newFace_nodesT[2] = vT[0];
    
          newFace_nodesB[0] = vB[i];
          newFace_nodesB[1] = vB[next_i];
          newFace_nodesB[2] = vT[next_i]; 
    
          if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));   
          this.add_Face(newFace_nodesT);
          this.add_Face(newFace_nodesB);
        }
    
        {
          int[] newFace_nodesT = new int [3];
          int[] newFace_nodesB = new int [3];
    
          newFace_nodesT[0] = vT[next_i];
          newFace_nodesT[1] = vT[i];
          newFace_nodesT[2] = vB[i];
    
          newFace_nodesB[0] = vB[next_i];
          newFace_nodesB[1] = vB[i];
          newFace_nodesB[2] = vB[0];    
    
          if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));
          this.add_Face(newFace_nodesT);
          this.add_Face(newFace_nodesB);
        }
      }
    }
  }  
  
  
  void create_Face_afterSphericalTessellation (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int[] f) {
  
    if (r > 0) {
    
      current_Material = m;
      current_Tessellation = tes;
      current_Layer = lyr;
      current_Visibility = vsb;
      current_Weight = wgt;
      current_Closed = clz;
    
      int A = f[0];
      int B = f[1];
      int C = f[2];
      int D = f[3];
    
      int M, N;  // 
      int MM, NN; // MM: mirror of M based on AB; NN: mirror of N baesd on CD
    
      float[] G;
    
      { 
        float[][] the_points = {
          {
            allPoints.getX(D) - cx, allPoints.getY(D) - cy, allPoints.getZ(D) - cz
          }
          , {
            allPoints.getX(A) - cx, allPoints.getY(A) - cy, allPoints.getZ(A) - cz
          }
          , {
            allPoints.getX(B) - cx, allPoints.getY(B) - cy, allPoints.getZ(B) - cz
          }
        };
    
        G = funcs.vec3_unit(funcs.centroid(the_points));
        M = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
        G[0] = (allPoints.getX(C) - cx) + (allPoints.getX(D) - cx) - (allPoints.getX(M) - cx);
        G[1] = (allPoints.getY(C) - cy) + (allPoints.getY(D) - cy) - (allPoints.getY(M) - cy);
        G[2] = (allPoints.getZ(C) - cz) + (allPoints.getZ(D) - cz) - (allPoints.getZ(M) - cz);
        G = funcs.vec3_unit(G);
        MM = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }   
    
    
      { 
        float[][] the_points = {
          {
            allPoints.getX(B) - cx, allPoints.getY(B) - cy, allPoints.getZ(B) - cz
          }
          , {
            allPoints.getX(C) - cx, allPoints.getY(C) - cy, allPoints.getZ(C) - cz
          }
          , {
            allPoints.getX(D) - cx, allPoints.getY(D) - cy, allPoints.getZ(D) - cz
          }
        };
    
        G = funcs.vec3_unit(funcs.centroid(the_points));
        N = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
    
    
        G[0] = (allPoints.getX(A) - cx) + (allPoints.getX(B) - cx) - (allPoints.getX(N) - cx);
        G[1] = (allPoints.getY(A) - cy) + (allPoints.getY(B) - cy) - (allPoints.getY(N) - cy);
        G[2] = (allPoints.getZ(A) - cz) + (allPoints.getZ(B) - cz) - (allPoints.getZ(N) - cz);
        G = funcs.vec3_unit(G);    
        NN = this.add_Vertex(cx + r * G[0], cy + r * G[1], cz + r * G[2]);
      }
    
    
    
    
    
      {
        int[][] newFace_options = {
          {
            current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
          }
        }; 
    
        allFaces.options = (int[][]) concat(allFaces.options, newFace_options);
    
    
        int[][] newFace_nodes = {
          {
            M, B, N, D
          }
        }; 
    
        allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
      }
    
      {
        int[][] newFace_options = {
          {
            current_Material, current_Tessellation, current_Layer, current_Visibility, current_Weight, current_Closed
          }
        }; 
    
        //allFaces.options = (int[][]) concat(allFaces.options, newFace_options);
    
    
        int[][] newFace_nodes = {
          {
            MM, B, M, A
          }
        }; 
    
        //allFaces.nodes = (int[][]) concat(allFaces.nodes, newFace_nodes);
      }
    }
  }
  



  
  
  
  void add_ParametricSurface (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float rx, float ry, float rz, int n, float rot) {
  
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt; 
    current_Closed = clz;
  
    if (m == -1) current_Material = 0;
    else current_Material = m;  
  
    float teta = rot * PI / 180.0;
  
    float stp_u = 0.1; //0.05;
    float stp_v = 0.1; //0.05;
  
    float start_u = -1;
    float start_v = -1;
    float end_u = 1;
    float end_v = 1;
  
    if (n == 1) {
      start_u = 0;
    }
    if (n == 2) {
      start_u = 0;
    }
  
    for (float a = start_u; a < end_u; a += stp_u) {
      for (float b = start_v; b < end_v; b += stp_v) {
  
        int[] newFace_nodes = {
        };
  
        for (int i = 0; i < 4; i++) {
  
          float u = a;
          float v = b;
  
          if ((i == 1) || (i == 2)) u += stp_u;
          if ((i == 2) || (i == 3)) v += stp_v;
  
          float x = 0;
          float y = 0;
          float z = 0;
  
          if (n == 1) { // LOGO:
            float x0 = cos(u * PI); 
            float y0 = sin(v * PI);
            float z0 = -sin(u * PI) * cos(v * PI);
  
            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;  
              y = y0 / d;  
              z = z0 / d;
            }
          } else if (n == 2) { 
            x = cos(u * PI); 
            y = sin(v * PI);
            z = -sin(u * PI) * cos(v * PI);
          } else if (n == 3) {
            x = sin(u * PI); 
            y = sin(v * PI);
            z = cos((u + v) * PI);
          } else if (n == 4) {
            float x0 = sin(u * PI); 
            float y0 = sin(v * PI);
            float z0 = cos((u + v) * PI);
  
            float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
            x = 0;
            y = 0;
            z = 0;
            if (d != 0) {
              x = x0 / d;  
              y = y0 / d;  
              z = z0 / d;
            }
          } else if (n == 5) {
            x = u; 
            y = v; 
            z = cos(0.5 * u * PI) * cos(0.5 * v * PI);
          } else if (n == 6) {
            x = u; 
            y = v; 
            z = sin(u * PI) * sin(v * PI);
          } else if (n == 7) {
            x = u; 
            y = v; 
            z = 0.5 * cos(u * PI) + cos(v * PI);
          }
  
  
          x *= rx;
          y *= ry;
          z *= rz;
  
          float x_rot = cx + x * cos(teta) - y * sin(teta);
          float y_rot = cy + x * sin(teta) + y * cos(teta);
          float z_rot = cz + z;
  
          x = x_rot;
          y = y_rot;
          z = z_rot;
  
          int[] f = {
            this.add_Vertex(x, y, z)
          };
          newFace_nodes = concat(newFace_nodes, f);
        }
  
        if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));      
  
        this.add_Face(newFace_nodes);
      }
    }
  }  
  
  
  void add_CrystalSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float r, int Tessellation, int isSky, float t) {
  
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;
  
    int[] vT = new int [6];
    int[] vB = new int [6];
  
    vT[0] = this.addToTempObjectVertices(0, 0, 1);
    vB[0] = this.addToTempObjectVertices(0, 0, -1);
  
    for (int i = 1; i <= 5; i++) {
      float q = i * 72 + t;
  
      float R_in = pow(5.0, 0.5) * 2.0 / 5.0;  
      float H_in = pow(5.0, 0.5) * 1.0 / 5.0;
  
      vT[i] = this.addToTempObjectVertices(R_in * funcs.cos_ang(q), R_in * funcs.sin_ang(q), H_in);
      vB[i] = this.addToTempObjectVertices(R_in * funcs.cos_ang(q + 36), R_in * funcs.sin_ang(q + 36), -H_in);
    } 
  
  
    int BuildFaces = 0;
  
    for (int Loop_Tessellation = 1; Loop_Tessellation <= Tessellation; Loop_Tessellation++) { // added so that the tree generated from the bottom to the top!
  
      if (Loop_Tessellation == Tessellation) BuildFaces = 1;
      else BuildFaces = 0;
  
      for (int i = 1; i <= 5; i++) {
  
        int next_i = (i % 5) + 1;
        int prev_i = ((i + 5 - 2) % 5) + 1;
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
          Loop_Tessellation, BuildFaces);
        }
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vT[0]][0], TempObjectVertices[vT[0]][1], TempObjectVertices[vT[0]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
          TempObjectVertices[vT[next_i]][0], TempObjectVertices[vT[next_i]][1], TempObjectVertices[vT[next_i]][2], 
          Loop_Tessellation, BuildFaces);
        }      
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vT[prev_i]][0], TempObjectVertices[vT[prev_i]][1], TempObjectVertices[vT[prev_i]][2], 
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          Loop_Tessellation, BuildFaces);
        }     
  
        {
          SOLARCHVISION_createLozenge(
  
          TempObjectVertices[vT[i]][0], TempObjectVertices[vT[i]][1], TempObjectVertices[vT[i]][2], 
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
  
          Loop_Tessellation, BuildFaces);
        }
  
        {
          SOLARCHVISION_createLozenge(
          TempObjectVertices[vB[prev_i]][0], TempObjectVertices[vB[prev_i]][1], TempObjectVertices[vB[prev_i]][2], 
          TempObjectVertices[vB[0]][0], TempObjectVertices[vB[0]][1], TempObjectVertices[vB[0]][2], 
          TempObjectVertices[vB[next_i]][0], TempObjectVertices[vB[next_i]][1], TempObjectVertices[vB[next_i]][2], 
          TempObjectVertices[vB[i]][0], TempObjectVertices[vB[i]][1], TempObjectVertices[vB[i]][2], 
  
          Loop_Tessellation, BuildFaces);
        }
      }
    }
  
  
    //println("Vertices:", POINTER_TempObjectVertices);
    //println("Faces:", POINTER_TempObjectFaces);
  
    if (isSky == 0) {
      this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, r, r, r, t);
    } else if (isSky == 1) {
  
  
      skyVertices = new float [0][3]; 
      skyFaces = new int [0][1];
  
      for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
        float x = TempObjectVertices[i][0];
        float y = TempObjectVertices[i][1];
        float z = TempObjectVertices[i][2];
  
        float[][] newVertex = {
          {
            x, y, z
          }
        }; 
  
        skyVertices = (float[][]) concat(skyVertices, newVertex);
      }
  
      for (int i = 0; i < POINTER_TempObjectFaces; i++) {
  
        int[][] newFace_nodes = {
          {
            TempObjectFaces[i][0], TempObjectFaces[i][1], TempObjectFaces[i][2], TempObjectFaces[i][3]
          }
        }; 
  
        skyFaces = (int[][]) concat(skyFaces, newFace_nodes);
      }
  
  
      POINTER_TempObjectVertices = 0;
      POINTER_TempObjectFaces = 0;
    } else {
      // Nothing. In this case we should add temp object outside this function. See SuperSphere
    }
  }  
  
  
  
  void add_SuperSphere (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float px, float py, float pz, float sx, float sy, float sz, int Tessellation, float t) {
  
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt; 
    current_Closed = clz;
  
    this.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, 1, Tessellation, -1, 90); // passing with isSky:-1
  
    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
    value = 1;
    posX = 0;
    posY = 0; 
    posZ = 0;    
    powX = px;
    powY = py;
    powZ = pz;    
    scaleX = 1;
    scaleY = 1; 
    scaleZ = 1;    
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];
  
      float the_dist = (pow((pow(abs(x - posX) / scaleX, powX) + pow(abs(y - posY) / scaleY, powY) + pow(abs(z - posZ) / scaleZ, powZ)), (3.0 / (powX + powY + powZ))) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
        z /= the_dist;
      }
  
      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }
  
    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);
  }  
  
  
  void add_SuperCylinder (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, int n, float t) {
  
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt; 
    current_Closed = clz;
  
    int[] vT = new int [n];
    int[] vB = new int [n];
  
    vT[0] = this.addToTempObjectVertices(1, 0, 1);
    vB[0] = this.addToTempObjectVertices(1, 0, -1);
  
    int[] newFace_nodesT = {
      vT[0]
    };
    int[] newFace_nodesB = {
      vB[0]
    };
    for (int i = 1; i < n; i++) {
      float rot = i * 360.0 / float(n);
  
      vT[i] = this.addToTempObjectVertices(funcs.cos_ang(rot), funcs.sin_ang(rot), 1);
      vB[i] = this.addToTempObjectVertices(funcs.cos_ang(rot), funcs.sin_ang(rot), -1);
      int[] fT = {
        vT[i]
      };
      int[] fB = {
        vB[i]
      };
  
      newFace_nodesT = concat(newFace_nodesT, fT);
      newFace_nodesB = concat(newFace_nodesB, fB);
    } 
  
    this.addToTempObjectFaces(newFace_nodesT, 0); // 0:check_duplicates
    this.addToTempObjectFaces(newFace_nodesB, 0); // 0:check_duplicates  
  
    for (int i = 0; i < n; i++) {
      int next_i = (i + 1) % n;
  
      int[] newFace_nodes = {
        vT[i], vB[i], vB[next_i], vT[next_i]
      };
  
      this.addToTempObjectFaces(newFace_nodes, 0); // 0:check_duplicates
    }  
  
    float value, posX, posY, posZ, powX, powY, powZ, scaleX, scaleY, scaleZ, rotZ; 
    value = 1;
    posX = 0;
    posY = 0; 
    posZ = 0;    
    scaleX = 1;
    scaleY = 1; 
    scaleZ = 1;    
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float x = TempObjectVertices[i][0];
      float y = TempObjectVertices[i][1];
      float z = TempObjectVertices[i][2];
  
      float the_dist = (pow((pow(abs(x - posX) / scaleX, 2) + pow(abs(y - posY) / scaleY, 2)), 0.5) / value);
      if (the_dist != 0) {
        x /= the_dist;
        y /= the_dist;
      }
  
      TempObjectVertices[i][0] = x;
      TempObjectVertices[i][1] = y;
      TempObjectVertices[i][2] = z;
    }
  
    this.addTempObjectToScene(m, tes, lyr, vsb, wgt, clz, cx, cy, cz, sx, sy, sz, t);
  }
  
  
  int addToTempObjectVertices (float x, float y, float z) {
  
    float[][] newVertex = {
      {
        x, y, z
      }
    }; 
  
    int vertex_existed = 0;
  
    float min_dist = FLOAT_undefined;
  
    for (int i = 0; i < POINTER_TempObjectVertices; i++) {
  
      float the_dist = funcs.vec_dist(newVertex[0], TempObjectVertices[i]);
  
      if (the_dist < 0.1) { // avoid creating duplicate vertices - WELD is necessary for allModel1Ds spheres!
  
        if (min_dist > the_dist) {
          min_dist = the_dist;
          vertex_existed = i;
        }
      }
    }
  
    if (vertex_existed == 0) { 
  
      if (POINTER_TempObjectVertices >= TempObjectVertices.length) {
        TempObjectVertices = (float[][]) concat(TempObjectVertices, newVertex);
      } else {
        //TempObjectVertices[POINTER_TempObjectVertices] = new int [3];
  
        TempObjectVertices[POINTER_TempObjectVertices][0] = x;
        TempObjectVertices[POINTER_TempObjectVertices][1] = y;
        TempObjectVertices[POINTER_TempObjectVertices][2] = z;
      }
  
      vertex_existed = POINTER_TempObjectVertices;
  
      POINTER_TempObjectVertices += 1;
    }
  
    return(vertex_existed);
  }
  
  int addToTempObjectFaces (int[] f, int check_duplicates) {
  
    int face_existed = 0;
  
    if (check_duplicates == 1) {
  
      for (int i = 0; i < POINTER_TempObjectFaces; i++) {
        if (f.length == TempObjectFaces[i].length) {
  
          for (int k = 0; k < f.length; k++) { // "k" introduces different variations that two faces could match
  
            for (int dir = -1; dir <= 1; dir += 2) { // "dir" introduces different diretions that two faces could match
  
              //println("\ndir=", dir);
  
              float total_distances = 0; 
  
              for (int j = 0; j < f.length; j++) {
  
                int q = (j * dir + k + f.length) % f.length;
  
                //print("q=", q, "; k=" );
  
                total_distances += funcs.vec_dist(TempObjectVertices[f[q]], TempObjectVertices[TempObjectFaces[i][j]]);
              }
  
              if (total_distances < 0.0001) { // avoid creating duplicate faces
                //println("A duplicate face detected :", i);
  
                face_existed = i;
                break;
              }
            }
          }
        }
        if (face_existed != 0) break;
      }
    }
  
    if (face_existed == 0) { 
  
      if (POINTER_TempObjectFaces >= TempObjectFaces.length) {
        int[][] newFace_nodes = {
          f
        }; 
        TempObjectFaces = (int[][]) concat(TempObjectFaces, newFace_nodes);
      } else {
        TempObjectFaces[POINTER_TempObjectFaces] = new int [f.length];
  
        for (int i = 0; i < f.length; i++) {
          TempObjectFaces[POINTER_TempObjectFaces][i] = f[i];
        }
      }
  
      face_existed = POINTER_TempObjectFaces;
  
      POINTER_TempObjectFaces += 1;
    }
  
    return(face_existed);
  }
  
  void addTempObjectToScene (int m, int tes, int lyr, int vsb, int wgt, int clz, float cx, float cy, float cz, float sx, float sy, float sz, float t) {
  
    current_Material = m;
    current_Tessellation = tes;
    current_Layer = lyr;
    current_Visibility = vsb;
    current_Weight = wgt;
    current_Closed = clz;
  
    if (m == -1) current_Material = 0;
    else current_Material = m;
  
    for (int i = 0; i < POINTER_TempObjectFaces; i++) {
  
      int[] new_Vertex_ids = new int [TempObjectFaces[i].length];
  
      for (int j = 0; j < TempObjectFaces[i].length; j++) {
  
        float x0 = TempObjectVertices[TempObjectFaces[i][j]][0] * sx;
        float y0 = TempObjectVertices[TempObjectFaces[i][j]][1] * sy;
        float z0 = TempObjectVertices[TempObjectFaces[i][j]][2] * sz;
  
        float x = x0 * funcs.cos_ang(t) - y0 * funcs.sin_ang(t);
        float y = x0 * funcs.sin_ang(t) + y0 * funcs.cos_ang(t);
        float z = z0;
  
        new_Vertex_ids[j] = this.add_Vertex(x + cx, y + cy, z + cz);
      }
  
      if (m == -1) current_Material = 1 + (current_Material % (Materials_Number - 1));  
      this.add_Face(new_Vertex_ids);
    }
  
    TempObjectVertices = new float [0][3];
  
    TempObjectFaces = new int [0][1];
  
    POINTER_TempObjectVertices = 0;
    POINTER_TempObjectFaces = 0;
  }
  
  void SOLARCHVISION_createLozenge (float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, int Tessellation, int BuildFaces) {
  
  
    if (Tessellation > 0) {
  
      if (Tessellation == 1) {
  
        int[] newPoly = new int [4];
  
        newPoly[0] = this.addToTempObjectVertices(x1, y1, z1);    
        newPoly[1] = this.addToTempObjectVertices(x2, y2, z2);
        newPoly[2] = this.addToTempObjectVertices(x3, y3, z3);
        newPoly[3] = this.addToTempObjectVertices(x4, y4, z4);
  
        if (BuildFaces != 0) {
          this.addToTempObjectFaces(newPoly, 1); // 1:check_duplicates
        }
  
        {
          // because the vertices might be welded to a nearest point:  
  
          x1 = TempObjectVertices[newPoly[0]][0];
          y1 = TempObjectVertices[newPoly[0]][1];
          z1 = TempObjectVertices[newPoly[0]][2];
  
          x2 = TempObjectVertices[newPoly[1]][0];
          y2 = TempObjectVertices[newPoly[1]][1];
          z2 = TempObjectVertices[newPoly[1]][2];
  
          x3 = TempObjectVertices[newPoly[2]][0];
          y3 = TempObjectVertices[newPoly[2]][1];
          z3 = TempObjectVertices[newPoly[2]][2];
  
          x4 = TempObjectVertices[newPoly[3]][0];
          y4 = TempObjectVertices[newPoly[3]][1];
          z4 = TempObjectVertices[newPoly[3]][2];
        }
      }
  
  
  
      Tessellation -= 1;
  
      float[] M = {
        (x1 + x2 + x4) / 3.0, (y1 + y2 + y4) / 3.0, (z1 + z2 + z4) / 3.0
      };
      float[] N = {
        (x3 + x2 + x4) / 3.0, (y3 + y2 + y4) / 3.0, (z3 + z2 + z4) / 3.0
      };
  
      M = funcs.vec3_unit(M);
      N = funcs.vec3_unit(N);
  
      SOLARCHVISION_createLozenge(x2, y2, z2, N[0], N[1], N[2], x4, y4, z4, M[0], M[1], M[2], Tessellation, BuildFaces);     
  
  
      if (BuildFaces != 0) 
      {
  
        float[] P = M;
  
        PVector A_vec = new PVector(x1, y1, z1);
        PVector B_vec = new PVector(x2, y2, z2);
  
        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();
  
        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
  
        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };
  
        Q = funcs.vec3_unit(Q);
  
        SOLARCHVISION_createLozenge(x2, y2, z2, P[0], P[1], P[2], x1, y1, z1, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
      }
  
  
      if (BuildFaces != 0) 
      {
  
        float[] P = N;
  
        PVector A_vec = new PVector(x3, y3, z3);
        PVector B_vec = new PVector(x4, y4, z4);
  
        PVector AxB_vec = A_vec.cross(B_vec);
        AxB_vec.normalize();
  
        float distP_OAB = P[0] * AxB_vec.x + P[1] * AxB_vec.y + P[2] * AxB_vec.z;
  
        float[] Q = {
          P[0] - 2 * distP_OAB * AxB_vec.x, P[1] - 2 * distP_OAB * AxB_vec.y, P[2] - 2 * distP_OAB * AxB_vec.z
        };
  
        Q = funcs.vec3_unit(Q);
  
        SOLARCHVISION_createLozenge(x4, y4, z4, P[0], P[1], P[2], x3, y3, z3, Q[0], Q[1], Q[2], Tessellation, BuildFaces);
      }
    }
  }  
  
  
  void delete_Faces () {
  
    allFaces.nodes = new int [0][3];
  
    allFaces.options = new int [0][6];
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Faces[q][0] = 0;
      allGroups.Faces[q][1] = -1;
    }  
  
    this.deselect_All();
  }
  
  void delete_Curves () {
  
    allCurves.nodes = new int [0][3];
  
    allCurves.options = new int [0][6];
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Curves[q][0] = 0;
      allGroups.Curves[q][1] = -1;
    }  
  
    this.deselect_All();
  }
  
  void delete_Vertices () {
  
    allVertices = new float [0][3];
  
    this.deselect_All();
  }
  
  void delete_allGroups () {
    
    allGroups.Model1Ds = new int [0][2];
  
    allGroups.Model2Ds = new int [0][2];
  
    allGroups.Faces = new int [0][2];
  
    allGroups.Curves = new int [0][2];
  
    allGroups.Solids = new int [0][2];
  
    allGroups.PivotMatrix = new float [0][9];
  
    allGroups.PivotType = new int [0][1];
  
    allGroups.num = 0;
    
    this.deselect_All();
   
  }    
  
  
  void delete_allSolids () {
    allSolids.DEF = new float [0][13]; 
  
    for (int q = 0; q < allGroups.num; q++) {
      allGroups.Solids[q][0] = 0;
      allGroups.Solids[q][1] = -1;
    }
  
    this.deselect_All();
  }    

  
  void delete_allCameras () {
  
    allCameras.options = new float [0][8]; 
  
    allCameras.Type = new int [0];
  
    this.add_veryFirstCamera();
  
    this.deselect_All();
  }
  
  void add_veryFirstCamera () {
    
    allCameras.options = new float [1][8]; 
    allCameras.options[0][0] = WIN3D.position_X;
    allCameras.options[0][1] = WIN3D.position_Y;
    allCameras.options[0][2] = WIN3D.position_Z;
    allCameras.options[0][3] = WIN3D.position_T;
    allCameras.options[0][4] = WIN3D.rotation_X;
    allCameras.options[0][5] = WIN3D.rotation_Y;
    allCameras.options[0][6] = WIN3D.rotation_Z;
    allCameras.options[0][7] = WIN3D.rotation_T;
    allCameras.options[0][8] = WIN3D.Zoom;
  
    allCameras.Type = new int [1];
    allCameras.Type[0] = WIN3D.ViewType;  
    
    allCameras.num = 1;
  }  
  

  
  void delete_allSections () {
    allSections.UVERAB = new float [0][6]; 
  
    allSections.Type = new int [0];
  
    allSections.RES1 = new int [0];
  
    allSections.RES2 = new int [0];
  
    allSections.SolidImpact = new PImage [0];
  
    allSections.SolarImpact = new PImage [0][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
  
    allSections.num = 0;
  
    this.deselect_All();
  }

  

  
  

  
  

  
  
  

  
  
  
  void add_DefaultModel (int n) {
  
    if (Land3D.loadMesh) {
  
      allModel2Ds.add_onLand(1); // 1 = people
  
      allModel2Ds.add_onLand(2); // 2 = 2D trees
    } else {
      //allModel2Ds.add_polar(1, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // people
      //allModel2Ds.add_polar(2, 50, 0,0,0, 0,50); // (t, n, x, y, z, r1, r2) // trees
    }  
  
  
  
    //if (n != 0) {
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    this.add_Mesh2(8, 0, 0, 1, 0, 0, -25, -25, 0, 25, 25, 0);
    //}
  
    if (n == 1) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 90);
    }
  
    if (n == 2) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0);
    }  
  
    if (n == 3) {
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_PolygonHyper(0, 0, 0, 1, 0, 0, 0, 0, 5, 10, 10, 4, 0);
  
      this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
      this.add_House1_Core(7, 0, 0, 1, 0, 0, 25, 25, 0, 6, 6, 6, 6, 0);
    }   
  
    if (n == 4) {
      for (int i = 0; i < int (10 + random (10)); i++) {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        this.add_House1_Core(7, 0, 0, 1, 0, 0, random(-80, 80), random(-80, 80), 0, random(5, 10), random(5, 10), random(5, 10), random(2.5, 7.5), random(360));
      }
    }    
  
  
    if (n == 5) {
      //SOLARCHVISION Complex:
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 3);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 2, 1, 1, 3, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 0, 2, 1, 3, 3);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 0, 0, 6, 4, 0.5);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7, 0, 0, 9, 2, 2);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7, 3, 0, 9, 4, 4);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 0, 0, 13, 4, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 0, 0, 13, 1, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 1, 0, 10.5, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12.5, 1, 0, 13, 3, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 3, 0, 13, 4, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 4, 0, 1, 8, 2);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5, 0, 4, 8, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5, 0, 4, 5.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 5.5, 0, 2.5, 7.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 3.5, 5.5, 0, 4, 7.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 7.5, 0, 4, 8, 2);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 5, 0, 8, 8, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 9, 5, 0, 11, 9, 1);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 5, 0, 13, 7, 4);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 8, 0, 13, 9, 8);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 9, 0, 4, 11, 1);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 9, 0, 8, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5, 9, 0, 5.5, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5.5, 9, 0, 7.5, 9.5, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 5.5, 10.5, 0, 7.5, 11, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 7.5, 9, 0, 8, 11, 2);
  
      //this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 0, 3, 13, 3);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 0, 3, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 1, 1, 13, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 2, 12, 1, 3, 13, 2);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 0, 12, 2, 3, 13, 3);
  
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 4, 12, 0, 8, 13, 2);
  
      //this.add_Box_Corners(-1, 0 , 0 , 1 ,0, 0, 9, 10, 0, 13, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 9, 10, 0, 10, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 10, 0, 12, 10.5, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 10, 12.5, 0, 12, 13, 1);
      this.add_Box_Corners(-1, 0, 0, 1, 0, 0, 12, 10, 0, 13, 13, 1);
  
      float model_scale = 12; // to make grid scale equal to 12m. <<<<
  
      for (int i = 1; i < allPoints.getLength(); i++) {
        allPoints.setX(i, allPoints.getX(i) - 6.5);
        allPoints.setY(i, allPoints.getY(i) - 6.5); 
  
        allPoints.setX(i, allPoints.getX(i) * model_scale);
        allPoints.setY(i, allPoints.getY(i) * model_scale); 
        allPoints.setZ(i, allPoints.getZ(i) * model_scale);
      }
    }      
  
    if (n == 6) {
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 0;
        float z = 0;
        float r = 10;
        this.add_CrystalSphere(1, 0, 0, 1, 0, 0, x, y, z, r, 5, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
  
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 30;
        float y = 0;
        float z = 0;
        float r = 8;
        this.add_CrystalSphere(2, 0, 0, 1, 0, 0, x, y, z, r, 4, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
  
      {
        this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
        float x = 0;
        float y = 20;
        float z = 0;
        float r = 8;
        this.add_CrystalSphere(3, 0, 0, 1, 0, 0, x, y, z, r, 3, 0, 90);
        this.add_Solid(x, y, z, 2, 2, 2, r, r, r, 0, 0, 0, 1);
      }
    }
  
    if (n == 7) {
      this.add_Model_Main();
    }
  }  
  
  int maximum_default_models = 7;
  
  
  void add_Model_2DsFromFile () {
  
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
  
    String[] FileALL = loadStrings(BaseFolder + "/Import/Hamedan_PEOPLE.txt");
  
    String lineSTR;  
  
    for (int f = 1; f < FileALL.length; f++) { // skip the first line.
  
      lineSTR = FileALL[f];
      //println(lineSTR);
  
      String[] parts = split(lineSTR, ',');
  
      float x = float(parts[0]);
      float y = float(parts[1]);
      float z = float(parts[2]);
  
      allModel2Ds.add_single("PEOPLE", 0, x, y, z, 2.5);
    }
  }
  
  
  
  void add_Model_Main () { 
  
    this.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
  
    addToLastGroup = false;
  }
  
}  

solarchvision_Model3Ds allModel3Ds = new solarchvision_Model3Ds();




class solarchvision_Cameras {

  private final static String CLASS_STAMP = "Cameras";
  
  boolean displayAll = false;
  
  float[][] options = {
    {
      WIN3D.position_X, WIN3D.position_Y, WIN3D.position_Z, WIN3D.position_T, WIN3D.rotation_X, WIN3D.rotation_Y, WIN3D.rotation_Z, WIN3D.rotation_T, WIN3D.Zoom
    }
  };
  int[] Type = {
    WIN3D.ViewType
  };
  int num = 1;


  
  
  private float[][] Vertices;
  private int[][] Faces;
  
  void draw () {
  
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
    if (this.displayAll) {
  
      for (int f = 0; f < this.num; f++) {
  
        float Camera_pX = this.options[f][0];
        float Camera_pY = this.options[f][1];
        float Camera_pZ = this.options[f][2];
        float Camera_pT = this.options[f][3];
        float Camera_rX = this.options[f][4];
        float Camera_rY = this.options[f][5];
        float Camera_rZ = this.options[f][6];
        float Camera_rT = this.options[f][7];
        float Camera_ZOOM = this.options[f][8];
  
        int Camera_type = this.Type[f];
  
        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        WIN3D.graphics.noFill();  
  
        WIN3D.graphics.beginShape();
  
        float[][] ImageVertex = getCorners(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_ZOOM);
  
        for (int q = 1; q <= 4; q++) {
  
          float x = ImageVertex[q][0];
          float y = ImageVertex[q][1];
          float z = ImageVertex[q][2];
  
          WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
  
          this.Vertices[f * 4 + q - 1][0] = x;
          this.Vertices[f * 4 + q - 1][1] = y;
          this.Vertices[f * 4 + q - 1][2] = z;
        }        
  
        this.Faces[f][0] = f * 4 + 0;
        this.Faces[f][1] = f * 4 + 1;
        this.Faces[f][2] = f * 4 + 2;
        this.Faces[f][3] = f * 4 + 3;  
  
        WIN3D.graphics.endShape(CLOSE);
  
        WIN3D.graphics.strokeWeight(1);
        WIN3D.graphics.stroke(0);
        //WIN3D.graphics.fill(127,255,127,127);
        WIN3D.graphics.noFill();
  
        WIN3D.graphics.beginShape();
  
        for (int q = 1; q <= 4; q++) {
  
          {
            float x = ImageVertex[q][0];
            float y = ImageVertex[q][1];
            float z = ImageVertex[q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
  
          {
            int next_q = 1 + (q % 4); 
  
            float x = ImageVertex[next_q][0];
            float y = ImageVertex[next_q][1];
            float z = ImageVertex[next_q][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
  
          {
            int o = 0; 
  
            float x = ImageVertex[o][0];
            float y = ImageVertex[o][1];
            float z = ImageVertex[o][2];
  
            WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale);
          }
        }        
  
        WIN3D.graphics.endShape(CLOSE);
      }
  
      WIN3D.graphics.strokeWeight(0);
    }
  }
  
  
  float[][] getCorners (int Camera_type, float Camera_pX, float Camera_pY, float Camera_pZ, float Camera_pT, float Camera_rX, float Camera_rY, float Camera_rZ, float Camera_rT, float Camera_ZOOM) {
  
    float[][] ImageVertex = new float [5][3];
  
    float r = Camera_pT * 5; // <<<<<<
  
    float rx = r * funcs.sin_ang(0.5 * Camera_ZOOM) /  WIN3D.view_R;
    float ry = r * funcs.sin_ang(0.5 * Camera_ZOOM);  
    float rz = r * funcs.cos_ang(0.5 * Camera_ZOOM);  
  
    for (int q = 0; q < 5; q++) {  
  
      float qx = 0, qy = 0, qz = 0;
  
      if (q == 0) {
        qx = 0; 
        qy = 0; 
        qz = 0;
      } else if (q == 1) {
        qx = -1; 
        qy = -1; 
        qz = -1;
      } else if (q == 2) {
        qx = -1; 
        qy = 1; 
        qz = -1;
      } else if (q == 3) {
        qx = 1; 
        qy = 1; 
        qz = -1;
      } else if (q == 4) {
        qx = 1; 
        qy = -1; 
        qz = -1;
      }
  
      float x = 0, y = 0, z = 0;
  
      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
      float keep_WIN3D_position_X = WIN3D.position_X; 
      float keep_WIN3D_position_Y = WIN3D.position_Y;
      float keep_WIN3D_position_Z = WIN3D.position_Z;
      float keep_WIN3D_position_T = WIN3D.position_T;
      float keep_WIN3D_rotation_X = WIN3D.rotation_X; 
      float keep_WIN3D_rotation_Y = WIN3D.rotation_Y;
      float keep_WIN3D_rotation_Z = WIN3D.rotation_Z;
      float keep_WIN3D_rotation_T = WIN3D.rotation_T;
      float keep_WIN3D_Zoom = WIN3D.Zoom;
  
      {
  
        WIN3D.position_X = Camera_pX;
        WIN3D.position_Y = Camera_pY;
        WIN3D.position_Z = Camera_pZ;
        WIN3D.position_T = Camera_pT;
        WIN3D.rotation_X = Camera_rX; 
        WIN3D.rotation_Y = Camera_rY;
        WIN3D.rotation_Z = Camera_rZ;
        WIN3D.rotation_T = Camera_rT;
        WIN3D.Zoom = Camera_ZOOM;
  
        WIN3D.transform_3DViewport();
  
        float x1 = rx * qx;
        float y1 = ry * qy;
        float z1 = rz * qz;
  
        float x2 = x1;
        float y2 = y1 * funcs.cos_ang(Camera_rX) - z1 * funcs.sin_ang(Camera_rX);
        float z2 = y1 * funcs.sin_ang(Camera_rX) + z1 * funcs.cos_ang(Camera_rX);
  
        float x3 = x2 * funcs.cos_ang(Camera_rZ) - y2 * funcs.sin_ang(Camera_rZ);
        float y3 = x2 * funcs.sin_ang(Camera_rZ) + y2 * funcs.cos_ang(Camera_rZ);
        float z3 = z2;
  
        x = WIN3D.CAM_x + x3;
        y = WIN3D.CAM_y + y3;
        z = WIN3D.CAM_z + z3;
      }
  
      WIN3D.CAM_x = keep_WIN3D_CAM_x;
      WIN3D.CAM_y = keep_WIN3D_CAM_y;
      WIN3D.CAM_z = keep_WIN3D_CAM_z;
      WIN3D.position_X = keep_WIN3D_position_X; 
      WIN3D.position_Y = keep_WIN3D_position_Y;
      WIN3D.position_Z = keep_WIN3D_position_Z;
      WIN3D.position_T = keep_WIN3D_position_T;
      WIN3D.rotation_X = keep_WIN3D_rotation_X; 
      WIN3D.rotation_Y = keep_WIN3D_rotation_Y;
      WIN3D.rotation_Z = keep_WIN3D_rotation_Z;
      WIN3D.rotation_T = keep_WIN3D_rotation_T;
      WIN3D.Zoom = keep_WIN3D_Zoom;
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
    }
  
    return ImageVertex;
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);
      
      float[] face_norm = funcs.vec3_cross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }  
  
  

  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
    
    int ni = this.num;
    parent.setInt("ni", ni);
    for (int i = 0; i < ni; i++) {
      XML child = parent.addChild("item");
      child.setInt("id", i);
      String lineSTR = "";
      //for (int j = 0; j < this.options[i].length; j++) {
      for (int j = 0; j < 9; j++) { // x, y, z, s, rx, ry, rz, zoom
        lineSTR += nf(this.options[i][j], 0, 4).replace(",", "."); // <<<<
        lineSTR += ",";
      }
      lineSTR += nf(this.Type[i], 0);

      child.setContent(lineSTR);
    }
    
    parent.setString("displayAll", Boolean.toString(this.displayAll));
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
    
    XML parent = xml.getChild(this.CLASS_STAMP);

    int ni = parent.getInt("ni");

    this.options = new float [ni][9];
    this.Type = new int [ni];

    this.num = ni;

    XML[] children = parent.getChildren("item");         
    for (int i = 0; i < ni; i++) {

      String lineSTR = children[i].getContent();
      String[] parts = split(lineSTR, ',');
      for (int j = 0; j < 9; j++) {
        this.options[i][j] = float(parts[j]);
      }

      this.Type[i] = int(parts[9]);
    }
    
    this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
  }    

}

solarchvision_Cameras allCameras = new solarchvision_Cameras();



class solarchvision_Sections {

  private final static String CLASS_STAMP = "Sections";
  
  boolean displayAll = true;

  float[][] UVERAB = new float[0][6];
  int[] Type = new int[0];
  
  int[] RES1 = new int[0];
  int[] RES2 = new int[0];
  int num = 0;


  private float[][] Vertices;
  private int[][] Faces;
  
  PImage[] SolidImpact = new PImage[0];
  PImage[][][] SolarImpact = new PImage [0][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];

  void resize_solarImpact_array () { // called when STUDY.j_End changes
  
    allSections.SolarImpact = new PImage [allSections.num][(1 + STUDY.j_End - STUDY.j_Start)][numberOfImpactVariations];
    {
      for (int i = 0; i < allSections.num; i++) {
        for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) { 
          for (int q = 0; q < numberOfImpactVariations; q++) {
            allSections.SolarImpact[i][j][q] = createImage(2, 2, RGB); // empty and small
          }
        }
      }
    }
  
  }  
  
  
  void draw (int target_window) {
    
    this.Faces = new int [this.num][4];
  
    this.Vertices = new float [4 * this.num][3];
  
  
    boolean proceed = true;
  
    if (this.displayAll == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
    
    if (proceed) {
  
      for (int f = 0; f < this.num; f++) {
  
        float Section_U_offset = this.UVERAB[f][0];
        float Section_V_offset = this.UVERAB[f][1];
        float Section_elevation = this.UVERAB[f][2];
        float Section_rotation = this.UVERAB[f][3];
        float Section_U_scale = this.UVERAB[f][4];
        float Section_V_scale = this.UVERAB[f][5];
  
        int Section_Type = this.Type[f];
        int Section_RES1 = this.RES1[f];
        int Section_RES2 = this.RES2[f];
  
        if (Section_Type != 0) {
          
          String the_filename = "Impact_" + nf(f, 0) + ".bmp";
          
          if (User3D.export_MaterialLibrary) {
  
            String TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
  
            if ((target_window == TypeWindow.HTML) || (target_window == TypeWindow.OBJ)) {
  
              if (allSolarImpacts.displayImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolarImpact[f][IMPACTS_displayDay][Impact_TYPE].save(TEXTURE_path);
              } else if (allSolidImpacts.displayImage) {
                println("Saving texture:", TEXTURE_path);
                this.SolidImpact[f].save(TEXTURE_path);
              }
  
              if (target_window == TypeWindow.HTML) {
                htmlOutput.println("\t\t\t\t<Appearance DEF='" + the_filename + "'>");
                htmlOutput.println("\t\t\t\t\t<ImageTexture url='"+ Subfolder_exportMaps + the_filename + "'><ImageTexture/>");
                htmlOutput.println("\t\t\t\t</Appearance>");
              }
    
              if (target_window == TypeWindow.OBJ) {
    
                mtlOutput.println("newmtl " + the_filename.replace('.', '_'));
                mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
                mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
                mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
                mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
                mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
                mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
      
                mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
                mtlOutput.println("\tTr 1.000"); //  0-1 transparency
                mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
      
                //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
                mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
              }
            }
          }
  
  
          if (target_window == TypeWindow.OBJ) {
  
            if (User3D.export_PolyToPoly == 1) {
              obj_lastGroupNumber += 1;  
              objOutput.println("g Impact_" + nf(f, 0));
            }
    
            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl " + the_filename.replace('.', '_'));
            }
          }
  
  
          float[][] subFace = getCorners(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
    
  
          num_vertices_added = 0;
        
          int end_turn = 1;
          if (target_window == TypeWindow.OBJ) end_turn = 3;
          for (int _turn = 1; _turn <= end_turn; _turn++) {
  
            boolean display_image = false;
            
            if (target_window == TypeWindow.WIN3D) {
      
              WIN3D.graphics.beginShape();
  
              WIN3D.graphics.noStroke();
              WIN3D.graphics.noFill();
    
              if (allSolarImpacts.displayImage) { 
                
                WIN3D.graphics.texture(this.SolarImpact[f][IMPACTS_displayDay][Impact_TYPE]);
  
              } else if (allSolidImpacts.displayImage) {
                
                WIN3D.graphics.texture(this.SolidImpact[f]);
              }  
              
            }
    
  
            for (int q = 1; q <= 4; q++) {
    
              float x = subFace[q][0];
              float y = subFace[q][1];
              float z = subFace[q][2];
              float u = subFace[q][3];
              float v = subFace[q][4];
    
              if (target_window == TypeWindow.WIN3D) {
    
                WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * Section_RES1, v * Section_RES2);
              }
              
              
              if (target_window == TypeWindow.OBJ) {
                
                v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
  
                if (_turn == 1) {
                  SOLARCHVISION_OBJprintVertex(x, y, z);
                }
  
                if (_turn == 2) {
                  SOLARCHVISION_OBJprintVtexture(u, v, 0);
                }
  
                if (_turn == 3) {
                  obj_lastVertexNumber += 1;
                  obj_lastVtextureNumber += 1;
                }           
              } 
    
              this.Vertices[f * 4 + q - 1][0] = x;
              this.Vertices[f * 4 + q - 1][1] = y;
              this.Vertices[f * 4 + q - 1][2] = z;
            }       
           
            if (target_window == TypeWindow.WIN3D) {
              WIN3D.graphics.endShape(CLOSE);
            }
    
            this.Faces[f][0] = f * 4 + 0;
            this.Faces[f][1] = f * 4 + 1;
            this.Faces[f][2] = f * 4 + 2;
            this.Faces[f][3] = f * 4 + 3;  
          }
          
          if (target_window == TypeWindow.OBJ) {
  
            String n1_txt = nf(obj_lastVertexNumber - 3, 0); 
            String n2_txt = nf(obj_lastVertexNumber - 2, 0);
            String n3_txt = nf(obj_lastVertexNumber - 1, 0);
            String n4_txt = nf(obj_lastVertexNumber - 0, 0);
  
            String m1_txt = nf(obj_lastVtextureNumber - 3, 0); 
            String m2_txt = nf(obj_lastVtextureNumber - 2, 0);
            String m3_txt = nf(obj_lastVtextureNumber - 1, 0);
            String m4_txt = nf(obj_lastVtextureNumber - 0, 0);      
  
            obj_lastFaceNumber += 1;            
            objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
            if (User3D.export_BackSides) {
              obj_lastFaceNumber += 1;
              objOutput.println("f " + n1_txt + "/" + m1_txt + " " + n4_txt + "/" + m4_txt + " " + n3_txt + "/" + m3_txt + " " + n2_txt + "/" + m2_txt);
            }
  
          }
          
          
          if (target_window == TypeWindow.HTML) {
            
            htmlOutput.println("\t\t\t\t<shape>");
  
            htmlOutput.println("\t\t\t\t\t<Appearance USE='" + the_filename + "'></Appearance>");
  
            
            htmlOutput.println("\t\t\t\t\t<IndexedFaceSet solid='false' coordIndex='0 1 2 3 -1'>"); // force two-sided
           
            htmlOutput.print  ("\t\t\t\t\t\t<Coordinate point='");
            for (int s = 1; s < subFace.length; s++) {
              if (s > 1) {
                htmlOutput.print(",");
              }                  
              
              htmlOutput.print(nf(subFace[s][0], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][1], 0, User3D.export_PrecisionVertex) + " " + nf(subFace[s][2], 0, User3D.export_PrecisionVertex));
            }                
            htmlOutput.println("'></Coordinate>");          
            
            
            for (int s = 1; s < subFace.length; s++) {
              
              float u = subFace[s][3];
              float v = subFace[s][4];
              
              if (s == 1) {
                htmlOutput.print  ("\t\t\t\t\t\t<TextureCoordinate point='");
              }
              if (s > 1) {
                htmlOutput.print(",");
              }                  
    
              v = 1 - v; // mirroring the image <<<<<<<<<<<<<<<<<<
              SOLARCHVISION_HTMLprintVtexture(u, v);
              
              if (s == subFace.length - 1) {
                htmlOutput.println("'></TextureCoordinate>");
              }     
            }  
  
          
    
            htmlOutput.println("\t\t\t\t\t</IndexedFaceSet>");
           
            htmlOutput.println("\t\t\t\t</shape>");          
          }
      
        }
      }
  
    }
  
  }
  
  
  float[][] getCorners (int Section_Type, float Section_U_offset, float Section_V_offset, float Section_elevation, float Section_rotation, float Section_U_scale, float Section_V_scale, int Section_RES1, int Section_RES2) {
  
    float[][] ImageVertex = new float [5][5];
  
    for (int q = 0; q < 5; q++) {
  
      float qx = 0, qy = 0, u = 0, v = 0;
  
      if (q == 0) {
        qx = 0; 
        qy = 0; 
        u = 0.5; 
        v = 0.5;
      } // center    
      else if (q == 1) {
        qx = -1; 
        qy = -1; 
        u = 0; 
        v = 1;
      } else if (q == 2) {
        qx = 1; 
        qy = -1; 
        u = 1; 
        v = 1;
      } else if (q == 3) {
        qx = 1; 
        qy = 1; 
        u = 1; 
        v = 0;
      } else if (q == 4) {
        qx = -1; 
        qy = 1; 
        u = 0; 
        v = 0;
      }    
  
      float a = qx * 0.5 * Section_U_scale + Section_U_offset;
      float b = qy * 0.5 * Section_V_scale + Section_V_offset;
      float c = Section_elevation;  
  
      float x = 0, y = 0, z = 0;
  
      if (Section_Type == 1) {
        x = a * funcs.cos_ang(Section_rotation) - b * funcs.sin_ang(Section_rotation);
        y = a * funcs.sin_ang(Section_rotation) + b * funcs.cos_ang(Section_rotation);
        z = c;
      } else if (Section_Type == 2) {
        x = a * funcs.cos_ang(Section_rotation) - c * funcs.sin_ang(Section_rotation);
        y = -(a * funcs.sin_ang(Section_rotation) + c * funcs.cos_ang(Section_rotation));
        z = b;
      } else if (Section_Type == 3) {
        x = a * funcs.cos_ang(90 - Section_rotation) - c * funcs.sin_ang(90 - Section_rotation); // ????????????
        y = -(a * funcs.sin_ang(90 - Section_rotation) + c * funcs.cos_ang(90 - Section_rotation)); // ????????????
        z = b;
      }      
  
      ImageVertex[q][0] = x;
      ImageVertex[q][1] = y;
      ImageVertex[q][2] = z;
      ImageVertex[q][3] = u;
      ImageVertex[q][4] = v;
    }
  
    return ImageVertex;
  }
  
  float[] intersect (float[] ray_pnt, float[] ray_dir) {
  
    float[] ray_normal = funcs.vec3_unit(ray_dir);   
  
    float[][] hitPoint = new float [this.Faces.length][4];
  
    for (int f = 0; f < this.Faces.length; f++) {
      hitPoint[f][0] = FLOAT_undefined;
      hitPoint[f][1] = FLOAT_undefined;
      hitPoint[f][2] = FLOAT_undefined;
      hitPoint[f][3] = FLOAT_undefined;
    }
    
    for (int f = 0; f < this.Faces.length; f++) {
  
      int n = this.Faces[f].length;
      
      float X_intersect = FLOAT_undefined;         
      float Y_intersect = FLOAT_undefined;
      float Z_intersect = FLOAT_undefined;
      float dist2intersect = FLOAT_undefined;
  
      boolean InPoly = false;
  
      float[] A = this.Vertices[this.Faces[f][0]];
      float[] B = this.Vertices[this.Faces[f][1]];
      float[] C = this.Vertices[this.Faces[f][n - 2]];
      float[] D = this.Vertices[this.Faces[f][n - 1]];
      
      float[] AC = funcs.vec3_diff(A, C);
      float[] BD = funcs.vec3_diff(B, D);
      
      float[] face_norm = funcs.vec3_cross(AC, BD);
      
      float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
  
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
          
          float[] P = {X_intersect, Y_intersect, Z_intersect};
          
          InPoly = funcs.isInside_Rectangle(P, A, B, C);
        }
      }
            
      if (InPoly) {
        hitPoint[f][0] = X_intersect;
        hitPoint[f][1] = Y_intersect;
        hitPoint[f][2] = Z_intersect;
        hitPoint[f][3] = dist2intersect;
      }  
  
    }  
  
    float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};
  
    float pre_dist = FLOAT_undefined;
  
    for (int f = 0; f < this.Faces.length; f++) {
  
      if (pre_dist > hitPoint[f][3]) {
  
        pre_dist = hitPoint[f][3];
  
        return_point[0] = f;
        return_point[1] = hitPoint[f][0];
        return_point[2] = hitPoint[f][1];
        return_point[3] = hitPoint[f][2];
        return_point[4] = hitPoint[f][3];
      }
  
    }
  
    return return_point;
  }
  
  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);

    {
      XML parent = xml.addChild(this.CLASS_STAMP);
      
      int ni = this.num;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
        XML child = parent.addChild("item");
        child.setInt("id", i);
        String lineSTR = "";
        //for (int j = 0; j < this.UVERAB[i].length; j++) {
        for (int j = 0; j < 6; j++) { // u, v, e, r, a, b
          lineSTR += nf(this.UVERAB[i][j], 0, 4).replace(",", "."); // <<<<
          lineSTR += ",";
        }
        lineSTR += nf(this.Type[i], 0);
        lineSTR += ",";
        lineSTR += nf(this.RES1[i], 0);
        lineSTR += ",";
        lineSTR += nf(this.RES2[i], 0);
  
        child.setContent(lineSTR);
      }
      
      parent.setString("displayAll", Boolean.toString(this.displayAll));
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".SolidImpact");
      int ni = this.SolidImpact.length;
      parent.setInt("ni", ni);
      for (int i = 0; i < ni; i++) {
  
        String the_filename = "SolidImpact_" + nf(i, 0) + ".bmp";
  
        String TEXTURE_path = Folder_Project + "/Textures/" + the_filename;
  
        println("Saving texture:", TEXTURE_path);
        this.SolidImpact[i].save(TEXTURE_path);
  
        XML child = parent.addChild("item");
        child.setInt("id", i); 
        child.setContent(TEXTURE_path);
      }
    }

    {
      XML parent = xml.addChild(this.CLASS_STAMP + ".SolarImpacts");
      int ni = 0, nj = 0, nk = 0;
      
      ni = this.SolarImpact.length;
      if (ni > 0) {
        nj = this.SolarImpact[0].length;
        if (nj > 0) {
          nk = this.SolarImpact[0][0].length;
        }
      }
      
      parent.setInt("ni", ni);
      parent.setInt("nj", nj);
      parent.setInt("nk", nk);
  
      for (int i = 0; i < ni; i++) {
        for (int j = 0; j < nj; j++) {
          for (int k = 0; k < nk; k++) {
  
            String the_filename = "allSolarImpacts." + nf((i * nj + j) * nk + k, 0) + ".bmp";
    
            String TEXTURE_path = Folder_Project + "/Textures/" + the_filename;
    
            println("Saving texture:", TEXTURE_path);
            this.SolarImpact[i][j][k].save(TEXTURE_path);
    
            XML child = parent.addChild("item");
            child.setInt("id", (i * nj + j) * nk + k); 
            child.setContent(TEXTURE_path);
          }
        }
      }
    }    
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);

    {
      XML parent = xml.getChild(this.CLASS_STAMP);
      
      int ni = parent.getInt("ni");
  
      this.UVERAB = new float [ni][6];
      this.Type = new int [ni];
      this.RES1 = new int [ni];
      this.RES2 = new int [ni];
      this.num = ni;
  
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {
  
        String lineSTR = children[i].getContent();
        String[] parts = split(lineSTR, ',');
        for (int j = 0; j < 6; j++) {
          this.UVERAB[i][j] = float(parts[j]);
        }
  
        this.Type[i] = int(parts[6]);
        this.RES1[i] = int(parts[7]);
        this.RES2[i] = int(parts[8]);
      }
      
      this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));      
    }
    
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".SolidImpact");
    
      int ni = parent.getInt("ni");
  
      this.SolidImpact = new PImage [ni];
  
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {      
  
        String TEXTURE_path = children[i].getContent();
  
        this.SolidImpact[i] = createImage(2, 2, RGB); // empty and small
  
        println("Loading texture(" + i + "):", TEXTURE_path);
        this.SolidImpact[i] = loadImage(TEXTURE_path);
        println("loaded!");
      }
    }
  
    {
      XML parent = xml.getChild(this.CLASS_STAMP + ".SolarImpacts");
    
      int ni = parent.getInt("ni");
      int nj = parent.getInt("nj");
      int nk = parent.getInt("nk");
  
      this.SolarImpact = new PImage [ni][nj][nk]; 
  
      XML[] children = parent.getChildren("item");         
      for (int i = 0; i < ni; i++) {      
        for (int j = 0; j < nj; j++) {
          for (int k = 0; k < nk; k++) {
  
            String TEXTURE_path = children[(i * nj + j) * nk + k].getContent();
  
            this.SolarImpact[i][j][k] = createImage(2, 2, RGB); // empty and small
  
            println("Loading texture(" + i + "," + j + "," + k + "):", TEXTURE_path);
            this.SolarImpact[i][j][k] = loadImage(TEXTURE_path);
            println("loaded!");
          }
        }
      }
    }    
  }  
  
}  

solarchvision_Sections allSections = new solarchvision_Sections();



class solarchvision_WindRose {
  
  private final static String CLASS_STAMP = "WindRose";
  
  boolean rebuild_Image_array = true;   
  
  PImage[] Image;
  
  boolean displayImage = false; 
  
  int renderedRES = 1;
  int RES = 400;
  
  float scale = 400;
  
  
  void resize_Image_array () {
  
    this.Image = new PImage [(1 + STUDY.j_End - STUDY.j_Start)];
  
    for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 
  
      this.Image[j + 1] = createImage(2, 2, RGB); // empty and small
    }  
  
    this.rebuild_Image_array = false;
  }
  

  void draw () 
{
  
    if (this.displayImage) {
  
      if (this.rebuild_Image_array) {
        this.resize_Image_array();
      }    
  
      WIN3D.graphics.stroke(0);
      WIN3D.graphics.fill(127, 127, 127);    
  
      WIN3D.graphics.beginShape();
  
      float elevation = 0.0 + allSolidImpacts.elevation[1];
      float U_scale = this.scale; 
      float V_scale = this.scale;
  
      float minU = 0;
      float maxU = this.renderedRES;
      float minV = 0;
      float maxV = this.renderedRES;
  
      //float c = HeightAboveGround * OBJECTS_scale; // <<< or zero i.e. height of the plane in 3D  // ?????????
      float c = elevation * OBJECTS_scale; 
  
      c += 1; // put this.Image it at level 1m. // <<<<<<<<<<<
  
      WIN3D.graphics.beginShape();
  
      WIN3D.graphics.texture(this.Image[IMPACTS_displayDay]);  
      WIN3D.graphics.stroke(255, 255, 255, 0);
      WIN3D.graphics.fill(255, 255, 255, 0);  
  
      for (int q = 0; q < 4; q++) {
  
        float qx = 0, qy = 0, u = 0, v = 0;
  
        if (q == 0) {
          qx = -1; 
          qy = -1; 
          u = minU; 
          v = maxV;
        } else if (q == 1) {
          qx = 1; 
          qy = -1; 
          u = maxU; 
          v = maxV;
        } else if (q == 2) {
          qx = 1; 
          qy = 1; 
          u = maxU; 
          v = minV;
        } else if (q == 3) {
          qx = -1; 
          qy = 1; 
          u = minU; 
          v = minV;
        }    
  
        float a = qx * 0.5;
        float b = qy * 0.5;    
  
        float x = 0, y = 0, z = 0;
  
        x = a;
        y = b;
        z = c;         
  
        WIN3D.graphics.vertex(x * OBJECTS_scale * WIN3D.scale, -y * OBJECTS_scale * WIN3D.scale, z * OBJECTS_scale * WIN3D.scale, u * U_scale, v * V_scale);
      }   
  
      WIN3D.graphics.endShape(CLOSE);
    }
  }



  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);
      
    parent.setString("displayImage", Boolean.toString(this.displayImage));
    parent.setInt("RES", this.RES);
    parent.setInt("renderedRES", this.renderedRES);
    parent.setFloat("scale", this.scale);    
  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displayImage = Boolean.parseBoolean(parent.getString("displayImage"));
    this.RES = parent.getInt("RES");
    this.renderedRES = parent.getInt("renderedRES");
    this.scale = parent.getFloat("scale");      
  }   
}

solarchvision_WindRose allWindRoses = new solarchvision_WindRose();




class solarchvision_WindFlow {
  
  private final static String CLASS_STAMP = "WindFlow";
  
  boolean displayAll = false;
  
  int pallet_CLR = 18; 
  int pallet_DIR = -1;  
  float pallet_MLT = 1;



  void draw (int target_window) {
  
    boolean proceed = true;
  
    if (this.displayAll == false) {
      proceed = false;
    }
  
    if ((target_window == TypeWindow.STUDY) || (target_window == TypeWindow.WORLD)) {  
      proceed = false;
    }
  
    if (proceed) {
  
      int PAL_type = allWindFlows.pallet_CLR; 
      int PAL_direction = allWindFlows.pallet_DIR; 
      float PAL_multiplier = allWindFlows.pallet_MLT;
        
        
        
      if (target_window == TypeWindow.OBJ) {  
    
        String the_filename = "";
    
        if (User3D.export_MaterialLibrary) {
    
          the_filename = "WindFlowPallet.bmp";
    
          String TEXTURE_path = Folder_Model3Ds + "/" + Subfolder_exportMaps + the_filename;
    
          println("Saving texture:", TEXTURE_path);
    
          int RES1 = User3D.export_PalletResolution; 
          int RES2 = User3D.export_PalletResolution / 16;       
    
          PImage pallet_Texture = createImage(RES1, RES2, ARGB);       
    
    
          pallet_Texture.loadPixels();
    
          for (int np = 0; np < (RES1 * RES2); np++) {
            int Image_X = np % RES1;
            int Image_Y = np / RES1;
    
            float _val = (Image_X / (0.5 * RES1)) - 1; 
    
            float _u = 0.5 + 0.5 * _val;
    
            float[] COL = PAINT.getColorStyle(PAL_type, _u);  
    
            pallet_Texture.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
          }
    
          pallet_Texture.updatePixels();   
    
          pallet_Texture.save(TEXTURE_path);      
    
    
          mtlOutput.println("newmtl " + "WindFlow");
          mtlOutput.println("\tilum 2"); // 0:Color on and Ambient off, 1:Color on and Ambient on, 2:Highlight on, etc.
          mtlOutput.println("\tKa 1.000 1.000 1.000"); // ambient
          mtlOutput.println("\tKd 1.000 1.000 1.000"); // diffuse
          mtlOutput.println("\tKs 0.000 0.000 0.000"); // specular
          mtlOutput.println("\tNs 10.00"); // 0-1000 specular exponent
          mtlOutput.println("\tNi 1.500"); // 0.001-10 (glass:1.5) optical_density (index of refraction)
    
          mtlOutput.println("\td 1.000"); //  0-1 transparency  d = Tr, or maybe d = 1 - Tr
          mtlOutput.println("\tTr 1.000"); //  0-1 transparency
          mtlOutput.println("\tTf 1.000 1.000 1.000"); //  transmission filter
    
          //mtlOutput.println("\tmap_Ka " + Subfolder_exportMaps + the_filename); // ambient map
          mtlOutput.println("\tmap_Kd " + Subfolder_exportMaps + the_filename); // diffuse map
        }    
    
        num_vertices_added = 0;
    
        for (int _turn = 1; _turn < 4; _turn++) {    
    
          if (_turn == 3) {
            obj_lastGroupNumber += 1;
            objOutput.println("g WindFlow");
    
            if (User3D.export_MaterialLibrary) {
              objOutput.println("usemtl WindFlow");
            }
          }        
    
          for (int q = 0; q < allSolidImpacts.Wind_Lines.length; q++) {
    
            int n1 = allSolidImpacts.Wind_Lines[q][0];
            int n2 = allSolidImpacts.Wind_Lines[q][1];
    
            float x1 = allSolidImpacts.Wind_Vertices[n1][0];
            float y1 = allSolidImpacts.Wind_Vertices[n1][1];
            float z1 = allSolidImpacts.Wind_Vertices[n1][2];
    
            float x2 = allSolidImpacts.Wind_Vertices[n2][0];
            float y2 = allSolidImpacts.Wind_Vertices[n2][1];
            float z2 = allSolidImpacts.Wind_Vertices[n2][2];
    
    
            float _val = allWindFlows.pallet_MLT * allSolidImpacts.Wind_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<
    
            float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
            if (PAL_direction == -1) _u = 1 - _u;
            if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
            if (PAL_direction == 2) _u =  0.5 * _u;
    
            float the_dist = dist(x1, y1, z1, x2, y2, z2);
    
            float[] W = {
              x2 - x1, y2 - y1, z2 - z1
            };
            W = funcs.vec3_unit(W);
    
            float Alpha = funcs.asin_ang(W[2]);
            float Beta = funcs.atan2_ang(W[1], W[0]) + 90;   
    
    
            if (_turn == 1) {
    
              SOLARCHVISION_OBJprintVertex(x1, y1, z1);
              SOLARCHVISION_OBJprintVertex(x2, y2, z2);
    
              for (int i = 0; i < 4; i++) {
    
                float px = 0.1 * the_dist * cos(i * HALF_PI);
                float py = 0;
                float pz = 0.1 * the_dist * sin(i * HALF_PI); 
    
                float pz_rot = pz;
                float px_rot = px * funcs.cos_ang(Beta) - py * funcs.sin_ang(Beta);
                float py_rot = px * funcs.sin_ang(Beta) + py * funcs.cos_ang(Beta);  
    
                px = px_rot;
                py = py_rot;
                pz = pz_rot;
    
                px_rot = px;
                py_rot = py * funcs.cos_ang(Alpha) - pz * funcs.sin_ang(Alpha);
                pz_rot = py * funcs.sin_ang(Alpha) + pz * funcs.cos_ang(Alpha);
    
                px = px_rot;
                py = py_rot;
                pz = pz_rot;    
    
                SOLARCHVISION_OBJprintVertex(x1 + px, y1 + py, z1 + pz);
              }
            }
    
    
            if (_turn == 2) {
              for (int i = 0; i < 6; i++) {
    
                float u1 = 0.5 * (_u + 0.5);
    
                if (u1 > 0.999) u1 = 0.999;
                if (u1 < 0.001) u1 = 0.001;
    
                SOLARCHVISION_OBJprintVtexture(u1, 0.5, 0);
              }
            }
    
            if (_turn == 3) {
              num_vertices_added += 6;
    
              String n1_txt = nf(obj_lastVertexNumber + num_vertices_added - 5, 0); 
              String n2_txt = nf(obj_lastVertexNumber + num_vertices_added - 4, 0);
              String n3_txt = nf(obj_lastVertexNumber + num_vertices_added - 3, 0);
              String n4_txt = nf(obj_lastVertexNumber + num_vertices_added - 2, 0);
              String n5_txt = nf(obj_lastVertexNumber + num_vertices_added - 1, 0);
              String n6_txt = nf(obj_lastVertexNumber + num_vertices_added - 0, 0);
    
              String m1_txt = nf(obj_lastVtextureNumber + num_vertices_added - 5, 0); 
              String m2_txt = nf(obj_lastVtextureNumber + num_vertices_added - 4, 0);
              String m3_txt = nf(obj_lastVtextureNumber + num_vertices_added - 3, 0);
              String m4_txt = nf(obj_lastVtextureNumber + num_vertices_added - 2, 0);          
              String m5_txt = nf(obj_lastVtextureNumber + num_vertices_added - 1, 0);          
              String m6_txt = nf(obj_lastVtextureNumber + num_vertices_added - 0, 0);          
    
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n3_txt + "/" + m3_txt + " " + n4_txt + "/" + m4_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n4_txt + "/" + m4_txt + " " + n5_txt + "/" + m5_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n5_txt + "/" + m5_txt + " " + n6_txt + "/" + m6_txt);
              objOutput.println("f " + n2_txt + "/" + m2_txt + " " + n6_txt + "/" + m6_txt + " " + n3_txt + "/" + m3_txt);
    
              obj_lastFaceNumber += 4;
            }
          }
        }
    
        obj_lastVertexNumber += num_vertices_added;
        obj_lastVtextureNumber += num_vertices_added;
      }      
      
      
      

      if (target_window == TypeWindow.WIN3D) {
  
  
        for (int q = 0; q < allSolidImpacts.Wind_Lines.length; q++) {
    
          int n1 = allSolidImpacts.Wind_Lines[q][0];
          int n2 = allSolidImpacts.Wind_Lines[q][1];
    
          float x1 = allSolidImpacts.Wind_Vertices[n1][0];
          float y1 = allSolidImpacts.Wind_Vertices[n1][1];
          float z1 = allSolidImpacts.Wind_Vertices[n1][2];
    
          float x2 = allSolidImpacts.Wind_Vertices[n2][0];
          float y2 = allSolidImpacts.Wind_Vertices[n2][1];
          float z2 = allSolidImpacts.Wind_Vertices[n2][2];
    
    
          float _val = this.pallet_MLT * allSolidImpacts.Wind_Vertices[n1][3]; // startpoint value = endpoint value <<<<<<<<<<
    
          float _u = 0.5 + 0.5 * (PAL_multiplier * _val);
          if (PAL_direction == -1) _u = 1 - _u;
          if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
          if (PAL_direction == 2) _u =  0.5 * _u;
    
          float[] COL = PAINT.getColorStyle(PAL_type, _u);      
    
          /*    
           WIN3D.graphics.stroke(COL[1], COL[2], COL[3], COL[0]);
           WIN3D.graphics.fill(COL[1], COL[2], COL[3], COL[0]);
           
           WIN3D.graphics.strokeWeight(1);
           WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);
           
           WIN3D.graphics.strokeWeight(4);      
           WIN3D.graphics.line(x1 * OBJECTS_scale * WIN3D.scale, -y1 * OBJECTS_scale * WIN3D.scale, z1 * OBJECTS_scale * WIN3D.scale, 0.5 * (x2 + x1) * OBJECTS_scale * WIN3D.scale, -0.5 * (y2 + y1) * OBJECTS_scale * WIN3D.scale, 0.5 * (z2 + z1) * OBJECTS_scale * WIN3D.scale);
           */
    
    
          float the_dist = dist(x1, y1, z1, x2, y2, z2);
    
          float[] W = {
            x2 - x1, y2 - y1, z2 - z1
          };
          W = funcs.vec3_unit(W);
    
          float Alpha = funcs.asin_ang(W[2]);
          float Beta = funcs.atan2_ang(W[1], W[0]) + 90;   
    
          WIN3D.graphics.fill(COL[1], COL[2], COL[3], 127);
          WIN3D.graphics.noStroke();
    
          for (int i = 0; i < 4; i++) {
    
            WIN3D.graphics.beginShape();
    
            WIN3D.graphics.vertex(x2 * OBJECTS_scale * WIN3D.scale, -y2 * OBJECTS_scale * WIN3D.scale, z2 * OBJECTS_scale * WIN3D.scale);  
    
            for (int j = 0; j < 2; j++) {
    
              float px = 0.1 * the_dist * cos((i + j) * HALF_PI);
              float py = 0;
              float pz = 0.1 * the_dist * sin((i + j) * HALF_PI); 
    
              float pz_rot = pz;
              float px_rot = px * funcs.cos_ang(Beta) - py * funcs.sin_ang(Beta);
              float py_rot = px * funcs.sin_ang(Beta) + py * funcs.cos_ang(Beta);  
    
              px = px_rot;
              py = py_rot;
              pz = pz_rot;
    
              px_rot = px;
              py_rot = py * funcs.cos_ang(Alpha) - pz * funcs.sin_ang(Alpha);
              pz_rot = py * funcs.sin_ang(Alpha) + pz * funcs.cos_ang(Alpha);
    
              px = px_rot;
              py = py_rot;
              pz = pz_rot;          
    
              WIN3D.graphics.vertex((x1 + px) * OBJECTS_scale * WIN3D.scale, -(y1 + py) * OBJECTS_scale * WIN3D.scale, (z1 + pz) * OBJECTS_scale * WIN3D.scale);
            }
    
            WIN3D.graphics.endShape(CLOSE);
          }
        }
    
    
        WIN3D.graphics.strokeWeight(0);
      }
      
      
    }
  }

  
  public void to_XML (XML xml) {
    
    println("Saving:" + this.CLASS_STAMP);
    
    XML parent = xml.addChild(this.CLASS_STAMP);

    parent.setString("displayAll", Boolean.toString(this.displayAll));
    
    parent.setInt("pallet_CLR", this.pallet_CLR);
    parent.setInt("pallet_DIR", this.pallet_DIR);
    parent.setFloat("pallet_MLT", this.pallet_MLT);

  }
  
  
  public void from_XML (XML xml) {
    
    println("Loading:" + this.CLASS_STAMP);
  
    XML parent = xml.getChild(this.CLASS_STAMP);
    
    this.displayAll = Boolean.parseBoolean(parent.getString("displayAll"));
    
    this.pallet_CLR = parent.getInt("pallet_CLR");
    this.pallet_DIR = parent.getInt("pallet_DIR");
    this.pallet_MLT = parent.getFloat("pallet_MLT");
   
  }   
}

solarchvision_WindFlow allWindFlows = new solarchvision_WindFlow();














void VertexSolar_resize_array () { // called when STUDY.j_End changes

  VertexSolar_XYZ     = new float [0][3];
  VertexSolar_amounts = new float [2][1 + STUDY.j_End - STUDY.j_Start][0];

  VertexSolar_rebuild_array = false;
}


void SOLARCHVISION_calculate_VertexSolar_array () {
  
  cursor(WAIT);

  VertexSolar_resize_array();

  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;

  Impact_TYPE = Impact_ACTIVE; 
  if (STUDY.PlotImpacts % 2 == 1) Impact_TYPE = Impact_PASSIVE;

  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int[][] PROCESSED_DAILY_SCENARIOS = {
    {
    }
  };  
  
  float Progress = 0;

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if (1 + Progress < 100 * f / float(allFaces.nodes.length)) { 
      Progress = 100 * f / float(allFaces.nodes.length);
      println("Progress:", int(Progress), "%");
    }

    int vsb = allFaces.getVisibility(f);

    if (vsb > 0) {

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allFaces.displayTessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }     

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);

        for (int s = 0; s < subFace.length; s++) {
          
          int q = SHADE.findID_SolarImpact_atXYZ(subFace[s][0], subFace[s][1], subFace[s][2]);
          
          if (q < 0) { // this will compute and add new points to the list only if there are not computed before.
  
            int s_next = (s + 1) % subFace.length;
            int s_prev = (s + subFace.length - 1) % subFace.length;
  
            PVector U = new PVector(subFace[s_next][0] - subFace[s][0], subFace[s_next][1] - subFace[s][1], subFace[s_next][2] - subFace[s][2]);
            PVector V = new PVector(subFace[s_prev][0] - subFace[s][0], subFace[s_prev][1] - subFace[s][1], subFace[s_prev][2] - subFace[s][2]);
            PVector UV = U.cross(V);
            float[] W = {
              UV.x, UV.y, UV.z
            };
            W = funcs.vec3_unit(W);
  
            float Alpha = funcs.asin_ang(W[2]);
            float Beta = funcs.atan2_ang(W[1], W[0]) + 90; 
  
            float[] VECT = {
              0, 0, 0
            }; 
  
            if (abs(Alpha) > 89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = 1;
            } else if (Alpha < -89.99) {
              VECT[0] = 0;
              VECT[1] = 0;
              VECT[2] = -1;
            } else {
              VECT[0] = funcs.sin_ang(Beta);
              VECT[1] = -funcs.cos_ang(Beta);
              VECT[2] = funcs.tan_ang(Alpha);
            }  
  
            VECT = funcs.vec3_unit(VECT);
            
            
            float SkyMask = 0;
            
            for (int i = 0; i < DiffuseVectors.length; i++) {
              float[] SkyV = {
                DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
              };
  
              float tmp = funcs.vec_dot(funcs.vec3_unit(SkyV), funcs.vec3_unit(VECT));
              if (tmp <= 0) tmp = 0; // removes backing faces
           
              SkyMask += tmp / float(DiffuseVectors.length);
            }   
            
            
  
            int l = STUDY.ImpactLayer;
  
            int DATE_step = 1;
      
            int J_START = STUDY.j_Start;
            int J_END = STUDY.j_End;
      
            float TOTALvaluesSUM_RAD = FLOAT_undefined;
            float TOTALvaluesSUM_EFF_P = FLOAT_undefined;
            float TOTALvaluesSUM_EFF_N = FLOAT_undefined;
            int TOTALvaluesNUM = 0;                          
      
            for (int j = J_START; j < J_END; j += DATE_step) {
              
              float valuesSUM_RAD = FLOAT_undefined;
              float valuesSUM_EFF_P = FLOAT_undefined;
              float valuesSUM_EFF_N = FLOAT_undefined;
              int valuesNUM = 0;                     
  
              now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;
  
              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }
  
              float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 
  
              float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
              float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);
  
              int[] Normals_COL_N;
  
  
              if (PROCESSED_DAILY_SCENARIOS.length > STUDY.j_End - STUDY.j_Start) {
                Normals_COL_N = PROCESSED_DAILY_SCENARIOS[STUDY.j_End - STUDY.j_Start];
              } else {
                Normals_COL_N = new int [9];
                Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);
  
                int[][] newNormals = {
                  Normals_COL_N
                };
                PROCESSED_DAILY_SCENARIOS = (int[][]) concat(PROCESSED_DAILY_SCENARIOS, newNormals);
                //println("length of PROCESSED_DAILY_SCENARIOS =", PROCESSED_DAILY_SCENARIOS.length);
              }
  
              int nk = Normals_COL_N[l];
  
              if (nk != -1) {
                int k = int(nk / STUDY.joinDays);
                int j_ADD = nk % STUDY.joinDays; 
  
                for (int i = 0; i < 24; i++) {
  
                  if (STUDY.isInHourlyRange(i)) {
  
                    float HOUR_ANGLE = i; 
                    float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
                    if (SunR[3] > 0) {
  
                      now_k = k + start_k;
                      now_i = i;
                      now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
                      if (now_j >= 365) {
                        now_j = now_j % 365;
                      }
                      if (now_j < 0) {
                        now_j = (now_j + 365) % 365;
                      }
  
                      Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                      Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                      Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                      Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
  
                      if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                        values_R_dir = FLOAT_undefined;
                        values_R_dif = FLOAT_undefined;
                        values_E_dir = FLOAT_undefined;
                        values_E_dif = FLOAT_undefined;
                      } else {
  
                        int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                        
                        if (memberCount == 1) {
                          values_R_dir = 0.001 * Pa; 
                          values_R_dif = 0.001 * Pb;  
                          values_E_dir = 0.001 * Pc;
                          values_E_dif = 0.001 * Pd;
  
                          if (is_undefined_FLOAT(valuesSUM_RAD)) {
                            valuesSUM_RAD = 0;
                            valuesSUM_EFF_P = 0;
                            valuesSUM_EFF_N = 0;
                            valuesNUM = 0;
                          } else {
  
  
  
                            float[] SunV = {
                              SunR[1], SunR[2], SunR[3]
                            };
  
                            float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
                            if (SunMask <= 0) SunMask = 0; // removes backing faces 
  
  
  
                            float[] ray_start = subFace[s];     
                            float[] ray_direction = {
                              SunR[1], SunR[2], SunR[3]
                            }; 
  
                            if (funcs.vec_dot(W, ray_direction) > 0) { // removes backing faces
  
                              if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) { 
                                if (values_E_dir < 0) {
                                  valuesSUM_EFF_P += -(values_E_dir * SunMask); 
                                  valuesSUM_EFF_N += -(values_E_dif * SkyMask); 
                                } else {
                                  valuesSUM_EFF_N += (values_E_dir * SunMask); 
                                  valuesSUM_EFF_P += (values_E_dif * SkyMask); 
                                }
  
                                valuesSUM_RAD += (values_R_dif * SkyMask);
                              } else { 
                                if (values_E_dir < 0) {
                                  valuesSUM_EFF_N += -((values_E_dir * SunMask) + (values_E_dif * SkyMask));
                                } else {
                                  valuesSUM_EFF_P += ((values_E_dir * SunMask) + (values_E_dif * SkyMask));
                                }
  
                                valuesSUM_RAD += ((values_R_dir * SunMask) + (values_R_dif * SkyMask)); // calculates total radiation
                              }
                            }
                            valuesNUM += 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
              
  
              if (valuesNUM != 0) {
                //float valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);  
                //float valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
                float valuesMUL = funcs.roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);
  
                valuesSUM_RAD *= valuesMUL;
                valuesSUM_EFF_P *= valuesMUL;
                valuesSUM_EFF_N *= valuesMUL;
  
                if (TOTALvaluesNUM == 0) {
                  TOTALvaluesSUM_RAD = 0;
                  TOTALvaluesSUM_EFF_P = 0;
                  TOTALvaluesSUM_EFF_N = 0;
                }
  
                TOTALvaluesSUM_RAD += valuesSUM_RAD;
                TOTALvaluesSUM_EFF_P += valuesSUM_EFF_P;
                TOTALvaluesSUM_EFF_N += valuesSUM_EFF_N;
                TOTALvaluesNUM += 1;
              } else {
                valuesSUM_RAD = FLOAT_undefined;
                valuesSUM_EFF_P = FLOAT_undefined;
                valuesSUM_EFF_N = FLOAT_undefined;
              }
              
              float AVERAGE, PERCENTAGE, COMPARISON;
  
              AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
              if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N)); 
              else PERCENTAGE = 0.0;
              COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
              //println("3D-Model >> valuesSUM_RAD:", valuesSUM_RAD, "|COMPARISON:", COMPARISON);
  
              float[] ADDvalues_RAD = {
                valuesSUM_RAD
              };
              VertexSolar_amounts[Impact_ACTIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][j + 1], ADDvalues_RAD);
  
              float[] ADDvalues_EFF = {
                COMPARISON
              };
              VertexSolar_amounts[Impact_PASSIVE][j + 1] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][j + 1], ADDvalues_EFF);
             
            }    
  
  
            if (TOTALvaluesNUM != 0) {
              TOTALvaluesSUM_RAD /= 1.0 * TOTALvaluesNUM;
              TOTALvaluesSUM_EFF_P /= 1.0 * TOTALvaluesNUM;
              TOTALvaluesSUM_EFF_N /= 1.0 * TOTALvaluesNUM;
            } else {
              TOTALvaluesSUM_RAD = FLOAT_undefined;
              TOTALvaluesSUM_EFF_P = FLOAT_undefined;
              TOTALvaluesSUM_EFF_N = FLOAT_undefined;
            }
  
  
            float AVERAGE, PERCENTAGE, COMPARISON;
  
            AVERAGE = (TOTALvaluesSUM_EFF_P - TOTALvaluesSUM_EFF_N);
            if ((TOTALvaluesSUM_EFF_P + TOTALvaluesSUM_EFF_N) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P - TOTALvaluesSUM_EFF_N) / (1.0 * (TOTALvaluesSUM_EFF_P + TOTALvaluesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);
  
  
            float valuesSUM = FLOAT_undefined;
            if (Impact_TYPE == Impact_ACTIVE) valuesSUM = TOTALvaluesSUM_RAD;
            if (Impact_TYPE == Impact_PASSIVE) valuesSUM = COMPARISON; 
  
            //println("3D-Model >> valuesSUM_RAD:", valuesSUM_RAD, "|COMPARISON:", COMPARISON);
  
            float[] ADDvalues_RAD = {
              TOTALvaluesSUM_RAD
            };
            VertexSolar_amounts[Impact_ACTIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_ACTIVE][0], ADDvalues_RAD);
  
            float[] ADDvalues_EFF = {
              COMPARISON
            };
            VertexSolar_amounts[Impact_PASSIVE][0] = (float[]) concat(VertexSolar_amounts[Impact_PASSIVE][0], ADDvalues_EFF);
            
            float[][] ADD_values_XYZ = {
              {
                subFace[s][0], subFace[s][1], subFace[s][2]
              }
            };
            VertexSolar_XYZ = (float[][]) concat(VertexSolar_XYZ, ADD_values_XYZ);          
  
          }
          
        }

      }
    }
  }
  
  cursor(ARROW);
}






float[] SOLARCHVISION_snap_Faces (float[] RxP) {
  
  if (RxP[0] >= 0) {
    
    int f = int(RxP[0]);
    float x = RxP[1];
    float y = RxP[2];
    float z = RxP[3];
  
    if (User3D.create_Snap == 1) { // nearest endpoint
    
      float nearest_D = FLOAT_undefined;
      float nearest_X = FLOAT_undefined;
      float nearest_Y = FLOAT_undefined;
      float nearest_Z = FLOAT_undefined;

      int mt = allFaces.getMaterial(f);

      int Tessellation = allFaces.getTessellation(f);

      int TotalSubNo = 1;  
      if (allFaces.getMaterial(f) == 0) {
        Tessellation += allFaces.displayTessellation;
      }
      if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));

      float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
      for (int j = 0; j < allFaces.nodes[f].length; j++) {
        int vNo = allFaces.nodes[f][j];
        base_Vertices[j][0] = allPoints.getX(vNo);
        base_Vertices[j][1] = allPoints.getY(vNo);
        base_Vertices[j][2] = allPoints.getZ(vNo);
      }

      for (int n = 0; n < TotalSubNo; n++) {

        float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);

        WIN3D.graphics.beginShape();

        for (int s = 0; s < subFace.length; s++) {
      
          float d = dist(x, y, z, subFace[s][0], subFace[s][1], subFace[s][2]);
          
          if (nearest_D > d) {
            nearest_D = d;
            nearest_X = subFace[s][0];
            nearest_Y = subFace[s][1];
            nearest_Z = subFace[s][2];
          }
        }
      }
      
      if (is_undefined_FLOAT(nearest_D) == false) {
        RxP[1] = nearest_X;
        RxP[2] = nearest_Y;
        RxP[3] = nearest_Z;
      }
    }
  }
  
  return RxP;
}


int SOLARCHVISION_isIntersected_Faces (float[] ray_pnt, float[] ray_dir, int firstGuess) {
  
  float[] ray_normal = funcs.vec3_unit(ray_dir);   

  int hit = 0;

  for (int q = 0; q < allFaces.nodes.length; q++) {
    
    int f = (q + firstGuess) % allFaces.nodes.length;
    
    if (f > 0) {
      
      int n = allFaces.nodes[f].length;
      
      if (n > 2) {      
  
        int vsb = allFaces.getVisibility(f);
    
          if (vsb > 0) {    
  
          float X_intersect = FLOAT_undefined;         
          float Y_intersect = FLOAT_undefined;
          float Z_intersect = FLOAT_undefined;
          float dist2intersect = FLOAT_undefined;
          float[] face_norm = {0,0,0};
          
          boolean InPoly = false;
          
          if (n < 5) { // works if n==3 or n==4
      
            float[] A = allPoints.getPosition(allFaces.nodes[f][0]);
            float[] B = allPoints.getPosition(allFaces.nodes[f][1]);
            float[] C = allPoints.getPosition(allFaces.nodes[f][n - 2]);
            float[] D = allPoints.getPosition(allFaces.nodes[f][n - 1]);
            
            float[] AC = funcs.vec3_diff(A, C);
            float[] BD = funcs.vec3_diff(B, D);
            
            face_norm = funcs.vec3_cross(AC, BD);
            
            float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
          
            float R = -funcs.vec3_dot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
                
                if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
                else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case
  
              }
            }
          }
          else {        
  
            int[] tmpFace = new int[n];
            float[] G = {
              0, 0, 0
            }; 
            for (int j = 0; j < n; j++) {
              tmpFace[j] = allFaces.nodes[f][j];
              G[0] += allPoints.getX(tmpFace[j]) / float(n); 
              G[1] += allPoints.getY(tmpFace[j]) / float(n);
              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
            }  
            
            for (int j = 0; j < n; j++) {
      
              int j_next = (j + 1) % n;
      
              float[] A = {
                allPoints.getX(allFaces.nodes[f][j]),
                allPoints.getY(allFaces.nodes[f][j]),
                allPoints.getZ(allFaces.nodes[f][j])
              };            
              
              float[] B = {
                allPoints.getX(allFaces.nodes[f][j_next]),
                allPoints.getY(allFaces.nodes[f][j_next]),
                allPoints.getZ(allFaces.nodes[f][j_next])
              };                
    
              float[] AG = funcs.vec3_diff(A, G);
              float[] BG = funcs.vec3_diff(B, G);
              
              face_norm = funcs.vec3_cross(AG, BG);
                
              float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
              
              float R = -funcs.vec3_dot(ray_dir, face_norm);
        
              if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
                dist2intersect = FLOAT_huge;
              }
              else {
                dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
        
                //if (dist2intersect > 0) {
                if (dist2intersect > FLOAT_tiny) {
      
                  X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                  Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                  Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                  
                  float[] P = {X_intersect, Y_intersect, Z_intersect};
    
                  InPoly = funcs.isInside_Triangle(P, A, B, G); 
                  
                }
              }
              
              if (InPoly) break;
            }
          }
                
          if (InPoly) {
            
            hit = f;
            
            break;         
          }               
  
        }
        
        if (hit != 0) break;
      }
    }
  }

  return hit;
}


float[] SOLARCHVISION_intersect_Faces (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = funcs.vec3_unit(ray_dir);   

  float[][] hitPoint = new float [allFaces.nodes.length][7];

  for (int f = 0; f < allFaces.nodes.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
    hitPoint[f][4] = FLOAT_undefined;
    hitPoint[f][5] = FLOAT_undefined;
    hitPoint[f][6] = FLOAT_undefined;
  }
  
  for (int f = 0; f < allFaces.nodes.length; f++) {
    
    int n = allFaces.nodes[f].length;
    
    if (n > 2) {
  
      int vsb = allFaces.getVisibility(f);
  
      if (vsb > 0) {    

        float X_intersect = FLOAT_undefined;         
        float Y_intersect = FLOAT_undefined;
        float Z_intersect = FLOAT_undefined;
        float dist2intersect = FLOAT_undefined;
        float[] face_norm = {0,0,0};
        
        boolean InPoly = false;
        
        if (n < 5) { // works if n==3 or n==4
    
          float[] A = allPoints.getPosition(allFaces.nodes[f][0]);
          float[] B = allPoints.getPosition(allFaces.nodes[f][1]);
          float[] C = allPoints.getPosition(allFaces.nodes[f][n - 2]);
          float[] D = allPoints.getPosition(allFaces.nodes[f][n - 1]);
          
          float[] AC = funcs.vec3_diff(A, C);
          float[] BD = funcs.vec3_diff(B, D);
          
          face_norm = funcs.vec3_cross(AC, BD);
          
          float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
        
          float R = -funcs.vec3_dot(ray_dir, face_norm);
    
          if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
            dist2intersect = FLOAT_huge;
          }
          else {
            dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
    
            //if (dist2intersect > 0) {
            if (dist2intersect > FLOAT_tiny) {
  
              X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
              Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
              Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
              
              float[] P = {X_intersect, Y_intersect, Z_intersect};
              
              if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
              else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

            }
          }
        }
        else {        

          int[] tmpFace = new int[n];
          float[] G = {
            0, 0, 0
          }; 
          for (int j = 0; j < n; j++) {
            tmpFace[j] = allFaces.nodes[f][j];
            G[0] += allPoints.getX(tmpFace[j]) / float(n); 
            G[1] += allPoints.getY(tmpFace[j]) / float(n);
            G[2] += allPoints.getZ(tmpFace[j]) / float(n);
          }  
          
          for (int j = 0; j < n; j++) {
    
            int j_next = (j + 1) % n;
    
            float[] A = {
              allPoints.getX(allFaces.nodes[f][j]),
              allPoints.getY(allFaces.nodes[f][j]),
              allPoints.getZ(allFaces.nodes[f][j])
            };            
            
            float[] B = {
              allPoints.getX(allFaces.nodes[f][j_next]),
              allPoints.getY(allFaces.nodes[f][j_next]),
              allPoints.getZ(allFaces.nodes[f][j_next])
            };                
  
            float[] AG = funcs.vec3_diff(A, G);
            float[] BG = funcs.vec3_diff(B, G);
            
            face_norm = funcs.vec3_cross(AG, BG);
              
            float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
            
            float R = -funcs.vec3_dot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
  
                InPoly = funcs.isInside_Triangle(P, A, B, G); 
                
              }
            }
            
            if (InPoly) break;
          }
        }
              
        if (InPoly) {
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
          hitPoint[f][4] = face_norm[0];
          hitPoint[f][5] = face_norm[1];
          hitPoint[f][6] = face_norm[2];             
        }               

      }
    }  
  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < allFaces.nodes.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
      return_point[5] = hitPoint[f][4];
      return_point[6] = hitPoint[f][5];
      return_point[7] = hitPoint[f][6];

    }

  }

  return return_point;
}







float[] SOLARCHVISION_intersect_Curves (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = funcs.vec3_unit(ray_dir);   

  float[][] hitPoint = new float [allCurves.nodes.length][7];

  for (int f = 0; f < allCurves.nodes.length; f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
    hitPoint[f][4] = FLOAT_undefined;
    hitPoint[f][5] = FLOAT_undefined;
    hitPoint[f][6] = FLOAT_undefined;
  }
  
  for (int f = 0; f < allCurves.nodes.length; f++) {
    
    int n = allCurves.nodes[f].length;
    
    if (n > 2) {
  
      int vsb = allCurves.getVisibility(f);
  
      if (vsb > 0) {    

        float X_intersect = FLOAT_undefined;         
        float Y_intersect = FLOAT_undefined;
        float Z_intersect = FLOAT_undefined;
        float dist2intersect = FLOAT_undefined;
        float[] face_norm = {0,0,0};
        
        boolean InPoly = false;
        
        if (n < 5) { // works if n==3 or n==4
    
          float[] A = allPoints.getPosition(allCurves.nodes[f][0]);
          float[] B = allPoints.getPosition(allCurves.nodes[f][1]);
          float[] C = allPoints.getPosition(allCurves.nodes[f][n - 2]);
          float[] D = allPoints.getPosition(allCurves.nodes[f][n - 1]);
          
          float[] AC = funcs.vec3_diff(A, C);
          float[] BD = funcs.vec3_diff(B, D);
          
          face_norm = funcs.vec3_cross(AC, BD);
          
          float face_offset = 0.25 * ((A[0] + B[0] + C[0] + D[0]) * face_norm[0] + (A[1] + B[1] + C[1] + D[1]) * face_norm[1] + (A[2] + B[2] + C[2] + D[2]) * face_norm[2]);  
        
          float R = -funcs.vec3_dot(ray_dir, face_norm);
    
          if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
            dist2intersect = FLOAT_huge;
          }
          else {
            dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
    
            //if (dist2intersect > 0) {
            if (dist2intersect > FLOAT_tiny) {
  
              X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
              Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
              Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
              
              float[] P = {X_intersect, Y_intersect, Z_intersect};
              
              if (n == 4) InPoly = funcs.isInside_Quadrangle(P, A, B, C, D);
              else InPoly = funcs.isInside_Triangle(P, A, B, D); // note D is the last vertex while C=B in this case

            }
          }
        }
        else {        

          int[] tmpCurve = new int[n];
          float[] G = {
            0, 0, 0
          }; 
          for (int j = 0; j < n; j++) {
            tmpCurve[j] = allCurves.nodes[f][j];
            G[0] += allPoints.getX(tmpCurve[j]) / float(n); 
            G[1] += allPoints.getY(tmpCurve[j]) / float(n);
            G[2] += allPoints.getZ(tmpCurve[j]) / float(n);
          }  
          
          for (int j = 0; j < n; j++) {
    
            int j_next = (j + 1) % n;
    
            float[] A = {
              allPoints.getX(allCurves.nodes[f][j]),
              allPoints.getY(allCurves.nodes[f][j]),
              allPoints.getZ(allCurves.nodes[f][j])
            };            
            
            float[] B = {
              allPoints.getX(allCurves.nodes[f][j_next]),
              allPoints.getY(allCurves.nodes[f][j_next]),
              allPoints.getZ(allCurves.nodes[f][j_next])
            };                
  
            float[] AG = funcs.vec3_diff(A, G);
            float[] BG = funcs.vec3_diff(B, G);
            
            face_norm = funcs.vec3_cross(AG, BG);
              
            float face_offset = (1.0 / 3.0) * ((A[0] + B[0] + G[0]) * face_norm[0] + (A[1] + B[1] + G[1]) * face_norm[1] + (A[2] + B[2] + G[2]) * face_norm[2]);  
            
            float R = -funcs.vec3_dot(ray_dir, face_norm);
      
            if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
              dist2intersect = FLOAT_huge;
            }
            else {
              dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
      
              //if (dist2intersect > 0) {
              if (dist2intersect > FLOAT_tiny) {
    
                X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
                Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
                Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];
                
                float[] P = {X_intersect, Y_intersect, Z_intersect};
  
                InPoly = funcs.isInside_Triangle(P, A, B, G); 
                
              }
            }
            
            if (InPoly) break;
          }
        }
              
        if (InPoly) {
          hitPoint[f][0] = X_intersect;
          hitPoint[f][1] = Y_intersect;
          hitPoint[f][2] = Z_intersect;
          hitPoint[f][3] = dist2intersect;
          hitPoint[f][4] = face_norm[0];
          hitPoint[f][5] = face_norm[1];
          hitPoint[f][6] = face_norm[2];             
        }               

      }
    }  
  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < allCurves.nodes.length; f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
      return_point[5] = hitPoint[f][4];
      return_point[6] = hitPoint[f][5];
      return_point[7] = hitPoint[f][6];

    }

  }

  return return_point;
}






























float[] SOLARCHVISION_intersect_LandPoints (float[] ray_pnt, float[] ray_dir) {

  float[] ray_normal = funcs.vec3_unit(ray_dir);   

  float[][] hitPoint = new float [(Land3D.num_rows - 1) * (Land3D.num_columns - 1)][4];

  for (int f = 0; f < (Land3D.num_rows - 1) * (Land3D.num_columns - 1); f++) {
    hitPoint[f][0] = FLOAT_undefined;
    hitPoint[f][1] = FLOAT_undefined;
    hitPoint[f][2] = FLOAT_undefined;
    hitPoint[f][3] = FLOAT_undefined;
  }

  for (int f = 0; f < (Land3D.num_rows - 1) * (Land3D.num_columns - 1); f++) {

    float X_intersect = FLOAT_undefined;         
    float Y_intersect = FLOAT_undefined;
    float Z_intersect = FLOAT_undefined;
    float dist2intersect = FLOAT_undefined;
    
    boolean InPoly = false;

    int LAND_i = f / (Land3D.num_columns - 1);
    int LAND_j = f % (Land3D.num_columns - 1);
    
    float[] A = Land3D.Mesh[LAND_i][LAND_j];
    float[] B = Land3D.Mesh[LAND_i][LAND_j + 1];
    float[] C = Land3D.Mesh[LAND_i + 1][LAND_j + 1];
    float[] D = Land3D.Mesh[LAND_i + 1][LAND_j];
    float[] G = {0.25 * (A[0] + B[0] + C[0] + D[0]), 0.25 * (A[1] + B[1] + C[1] + D[1]), 0.25 * (A[2] + B[2] + C[2] + D[2])}; 
    
    for (int i = 0; i < 4; i++) {
      
      float[] M = {0,0,0};
      float[] N = {0,0,0};

      if (i == 0) {
        M = A;
        N = B;
      } else if (i == 1) {
        M = B;
        N = C;
      } else if (i == 2) {
        M = C;
        N = D;
      } else if (i == 3) {
        M = D;
        N = A;
      }       
    
      float[] NG = funcs.vec3_diff(N, G);
      float[] GM = funcs.vec3_diff(G, M);
      
      float[] face_norm = funcs.vec3_cross(NG, GM);
      
      float face_offset = ((G[0] + M[0] + N[0]) * face_norm[0] + (G[1] + M[1] + N[1]) * face_norm[1] + (G[2] + M[2] + N[2]) * face_norm[2]) / 3.0;  
    
      float R = -funcs.vec3_dot(ray_dir, face_norm);
  
      if ((R < FLOAT_tiny) && (R > -FLOAT_tiny)) { // the ray is parallel to the plane
        dist2intersect = FLOAT_huge;
      }
      else {
        dist2intersect = (funcs.vec3_dot(ray_pnt, face_norm) - face_offset) / R;
  
        //if (dist2intersect > 0) {
        if (dist2intersect > FLOAT_tiny) {
        
          X_intersect = dist2intersect * ray_dir[0] + ray_pnt[0];
          Y_intersect = dist2intersect * ray_dir[1] + ray_pnt[1];
          Z_intersect = dist2intersect * ray_dir[2] + ray_pnt[2];

          float[] P = {X_intersect, Y_intersect, Z_intersect};

          InPoly = funcs.isInside_Triangle(P, M, N, G); 
          
        }
      }
      
      if (InPoly) break;
    }
    
    if (InPoly) {
      hitPoint[f][0] = X_intersect;
      hitPoint[f][1] = Y_intersect;
      hitPoint[f][2] = Z_intersect;
      hitPoint[f][3] = dist2intersect;
    }   

  }

  float[] return_point = {-1, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined, FLOAT_undefined};

  float pre_dist = FLOAT_undefined;

  for (int f = 0; f < (Land3D.num_rows - 1) * (Land3D.num_columns - 1); f++) {

    if (pre_dist > hitPoint[f][3]) {

      pre_dist = hitPoint[f][3];

      return_point[0] = f;
      return_point[1] = hitPoint[f][0];
      return_point[2] = hitPoint[f][1];
      return_point[3] = hitPoint[f][2];
      return_point[4] = hitPoint[f][3];
    }

  }

  return return_point;
}









// ---------------------------------------------------------





double[] getLandGrid (int i, int j) {

  double stp_lat = 1.0 / 2224.5968; // equals to 50m 

  double stp_lon = stp_lat / funcs.cos_ang(STATION.getLatitude());   
  
  //float q = 2;
  float q = pow(2, 0.5);
  //float q = 1.25;
  //float q = 1.125;  
  
  float t = j * 360.0 / (Land3D.num_columns - 1);
  
  float r = 0;
  if (i > 0) r = pow(q, i - 1);

  double _lon = STATION.getLongitude() + stp_lon * r * funcs.cos_ang(t);
  double _lat = STATION.getLatitude() + stp_lat * r * funcs.sin_ang(t);
  
  double[] LON_LAT = {_lon, _lat};
  
  return LON_LAT;
  
}














float[][] skyVertices = new float [0][3];
int[][] skyFaces = new int [0][1];

int POINTER_TempObjectVertices = 0;
int POINTER_TempObjectFaces = 0;

float[][] TempObjectVertices = new float [0][3];
int[][] TempObjectFaces = new int [0][1];

float SOLARCHVISION_SolarAtSurface (float SunR1, float SunR2, float SunR3, float SunR4, float SunR5, float Alpha, float Beta, float THE_ALBEDO) {

  float return_value = FLOAT_undefined;

  if ((is_undefined_FLOAT(SunR1) == false) && (is_undefined_FLOAT(SunR2) == false) && (is_undefined_FLOAT(SunR3) == false) && (is_undefined_FLOAT(SunR4) == false) && (is_undefined_FLOAT(SunR5) == false)) { 

    float[] VECT = {
      0, 0, 0
    }; 

    if (abs(Alpha) > 89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = 1;
    } else if (Alpha < -89.99) {
      VECT[0] = 0;
      VECT[1] = 0;
      VECT[2] = -1;
    } else {
      VECT[0] = funcs.sin_ang(Beta);
      VECT[1] = -funcs.cos_ang(Beta);
      VECT[2] = funcs.tan_ang(Alpha);
    }   

    VECT = funcs.vec3_unit(VECT);


    float[] SunV = {
      SunR1, SunR2, SunR3
    };

    float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
    if (SunMask <= 0) SunMask = 0; // removes backing faces 

    float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));

    return_value = (SunR4 * SunMask) + (SunR5 * SkyMask);    


    /*
    float[] REF_SunV = {SunR1, SunR2, -SunR3};
     
     float REF_SunMask = funcs.vec_dot(funcs.vec3_unit(REF_SunV), funcs.vec3_unit(VECT));
     if (REF_SunMask <= 0) REF_SunMask = 0; // removes backing faces 
     
     float REF_SkyMask = 1 - (0.5 * (1.0 + (Alpha / 90.0)));      
     
     return_value +=  (0.01 * THE_ALBEDO) * ((SunR4 * REF_SunMask) + (SunR5 * REF_SkyMask));
     */
  }

  return (return_value);
}












void GlobalSolar_resize_array () {

  Sky3D.stp_slp = Sky3D.calculatedResolution;
  Sky3D.stp_dir = Sky3D.calculatedResolution;
  Sky3D.num_slp = int(funcs.roundTo(180.0 / (1.0 * Sky3D.stp_slp), 1)) + 1;  
  Sky3D.num_dir = int(funcs.roundTo(360.0 / (1.0 * Sky3D.stp_dir), 1));

  GlobalSolar = new float [2][(1 + STUDY.j_End - STUDY.j_Start)][Sky3D.num_slp][Sky3D.num_dir];

  for (int i = 0; i < GlobalSolar.length; i++) {
    for (int j = 0; j < GlobalSolar[i].length; j++) {
  
      for (int a = 0; a < Sky3D.num_slp; a++) {
        for (int b = 0; b < Sky3D.num_dir; b++) {  
          GlobalSolar[i][j][a][b] = FLOAT_undefined;
        }
      }
    }
  }

  GlobalSolar_rebuild_array = false;
}


void SOLARCHVISION_calculate_GlobalSolar_array () {

  cursor(WAIT);

  if (GlobalSolar_rebuild_array) {
    GlobalSolar_resize_array();
  }

  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int[] startK_endK = get_startK_endK();
  int start_k = startK_endK[0]; 
  int end_k = startK_endK[1];
  int count_k = 1 + end_k - start_k; 
  if (count_k < 0) count_k = 0;



  if (STUDY.PlotImpacts % 2 == 0) Impact_TYPE = Impact_ACTIVE; 
  else Impact_TYPE = Impact_PASSIVE;



  float Pa = FLOAT_undefined;
  float Pb = FLOAT_undefined;
  float Pc = FLOAT_undefined;
  float Pd = FLOAT_undefined;

  float values_R_dir;
  float values_R_dif;
  float values_E_dir;
  float values_E_dif;

  int now_k = 0;
  int now_i = 0;
  int now_j = 0;

  int l = STUDY.ImpactLayer;

  float[][] TOTALvaluesSUM_RAD = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  float[][] TOTALvaluesSUM_EFF_P = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  float[][] TOTALvaluesSUM_EFF_N = new float [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];
  int[][] TOTALvaluesNUM = new int [1 + int(180 / Sky3D.stp_slp)][1 + int(360 / Sky3D.stp_dir)];

  for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) { 
    for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
      TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
      TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
      TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
      TOTALvaluesNUM[a][b] = 0;
    }
  }

  for (int j = STUDY.j_Start; j < STUDY.j_End; j++) {

    now_j = (j * int(STUDY.perDays) + TIME.beginDay + 365) % 365;

    if (now_j >= 365) {
      now_j = now_j % 365;
    }
    if (now_j < 0) {
      now_j = (now_j + 365) % 365;
    }

    float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0); 

    float sunrise = SOLARCHVISION_Sunrise(STATION.getLatitude(), DATE_ANGLE); 
    float sunset = SOLARCHVISION_Sunset(STATION.getLatitude(), DATE_ANGLE);

    int[] Normals_COL_N;
    Normals_COL_N = new int [9];
    Normals_COL_N = SOLARCHVISION_PROCESS_DAILY_SCENARIOS(start_k, end_k, j, DATE_ANGLE);

    for (int nk = Normals_COL_N[l]; nk <= Normals_COL_N[l]; nk++) {
      if (nk != -1) {
        int k = int(nk / STUDY.joinDays);
        int j_ADD = nk % STUDY.joinDays; 

        for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) { 
          float Alpha = a * Sky3D.stp_slp - 90;
          for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
            float Beta = b * Sky3D.stp_dir;

            float valuesSUM_RAD = 0;
            float valuesSUM_EFF_P = 0;
            float valuesSUM_EFF_N = 0;
            int valuesNUM = 0; 

            for (int i = 0; i < 24; i++) {
              if (STUDY.isInHourlyRange(i)) {

                float HOUR_ANGLE = i; 
                float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

                if (SunR[3] > 0) {

                  now_k = k + start_k;
                  now_i = i;
                  now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;

                  if (now_j >= 365) {
                    now_j = now_j % 365;
                  }
                  if (now_j < 0) {
                    now_j = (now_j + 365) % 365;
                  }

                  Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
                  Pb = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
                  Pc = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_direffect.id);
                  Pd = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difeffect.id);
        
                  if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb)) || (is_undefined_FLOAT(Pc)) || (is_undefined_FLOAT(Pd))) {
                    values_R_dir = FLOAT_undefined;
                    values_R_dif = FLOAT_undefined;
                    values_E_dir = FLOAT_undefined;
                    values_E_dif = FLOAT_undefined;
                  } else {

                    int memberCount = SOLARCHVISION_filter(CurrentDataSource, LAYER_cloudcover.id, STUDY.filter, STUDY.skyScenario, now_i, now_j, now_k);
                    
                    if (memberCount == 1) {
                      values_R_dir = 0.001 * Pa;
                      values_R_dif = 0.001 * Pb;
                      values_E_dir = 0.001 * Pc;
                      values_E_dif = 0.001 * Pd;

                      if (is_undefined_FLOAT(valuesSUM_RAD)) {
                        valuesSUM_RAD = 0;
                        valuesSUM_EFF_P = 0;
                        valuesSUM_EFF_N = 0;
                        valuesNUM = 0;
                      } else {

                        if (values_E_dir < 0) {
                          valuesSUM_EFF_N += -SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                        } else {
                          valuesSUM_EFF_P += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_E_dir, values_E_dif, Alpha, Beta, GlobalAlbedo);
                        }

                        valuesSUM_RAD += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], values_R_dir, values_R_dif, Alpha, Beta, GlobalAlbedo); 

                        valuesNUM += 1;
                      }
                    }
                  }
                }
              }
            }


            if (valuesNUM != 0) {
              //float valuesMUL = SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE) / (1.0 * valuesNUM);  
              //float valuesMUL = int(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE)) / (1.0 * valuesNUM);
              float valuesMUL = funcs.roundTo(SOLARCHVISION_DayTime(STATION.getLatitude(), DATE_ANGLE), 1) / (1.0 * valuesNUM);

              valuesSUM_RAD *= valuesMUL;
              valuesSUM_EFF_P *= valuesMUL;
              valuesSUM_EFF_N *= valuesMUL;

              if (TOTALvaluesNUM[a][b] == 0) {
                TOTALvaluesSUM_RAD[a][b] = 0;
                TOTALvaluesSUM_EFF_P[a][b] = 0;
                TOTALvaluesSUM_EFF_N[a][b] = 0;
              }

              TOTALvaluesSUM_RAD[a][b] += valuesSUM_RAD;
              TOTALvaluesSUM_EFF_P[a][b] += valuesSUM_EFF_P;
              TOTALvaluesSUM_EFF_N[a][b] += valuesSUM_EFF_N;
              TOTALvaluesNUM[a][b] += 1;
            } else {
              valuesSUM_RAD = FLOAT_undefined;
              valuesSUM_EFF_P = FLOAT_undefined;
              valuesSUM_EFF_N = FLOAT_undefined;
            }


            float AVERAGE, PERCENTAGE, COMPARISON;

            AVERAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N);
            if ((valuesSUM_EFF_P + valuesSUM_EFF_N) > 0.00001) PERCENTAGE = (valuesSUM_EFF_P - valuesSUM_EFF_N) / (1.0 * (valuesSUM_EFF_P + valuesSUM_EFF_N)); 
            else PERCENTAGE = 0.0;
            COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

            if (is_undefined_FLOAT(valuesSUM_RAD) == false) {
              GlobalSolar[Impact_ACTIVE][j + 1][a][b] = valuesSUM_RAD;
            }
            if (is_undefined_FLOAT(COMPARISON) == false) {
              GlobalSolar[Impact_PASSIVE][j + 1][a][b] = COMPARISON;
            }
          }
        }
      }
    }
  }



  for (int a = 0; a <= int (180 / Sky3D.stp_slp); a++) { 
    float Alpha = a * Sky3D.stp_slp - 90;
    for (int b = 0; b < int (360 / Sky3D.stp_dir); b++) {
      float Beta = b * Sky3D.stp_dir;

      if (TOTALvaluesNUM[a][b] != 0) {
        TOTALvaluesSUM_RAD[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
        TOTALvaluesSUM_EFF_P[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
        TOTALvaluesSUM_EFF_N[a][b] /= 1.0 * TOTALvaluesNUM[a][b];
      } else {
        TOTALvaluesSUM_RAD[a][b] = FLOAT_undefined;
        TOTALvaluesSUM_EFF_P[a][b] = FLOAT_undefined;
        TOTALvaluesSUM_EFF_N[a][b] = FLOAT_undefined;
      }

      float AVERAGE, PERCENTAGE, COMPARISON;

      AVERAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]);
      if ((TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b]) > 0.00001) PERCENTAGE = (TOTALvaluesSUM_EFF_P[a][b] - TOTALvaluesSUM_EFF_N[a][b]) / (1.0 * (TOTALvaluesSUM_EFF_P[a][b] + TOTALvaluesSUM_EFF_N[a][b])); 
      else PERCENTAGE = 0.0;
      COMPARISON = ((abs(PERCENTAGE)) * AVERAGE);

      if (is_undefined_FLOAT(TOTALvaluesSUM_RAD[a][b]) == false) {
        GlobalSolar[Impact_ACTIVE][0][a][b] = TOTALvaluesSUM_RAD[a][b];
      }
      if (is_undefined_FLOAT(COMPARISON) == false) {
        GlobalSolar[Impact_PASSIVE][0][a][b] = COMPARISON;
      }

    }
  }


  keep_STUDY_perDays = STUDY.perDays;
  STUDY.joinDays = keep_STUDY_joinDays;

  cursor(ARROW);
}


void SOLARCHVISION_draw_logo (float cx, float cy, float cz, float cr, int the_view) {

  float stp_u = 1.0 / 12.0;
  float stp_v = 1.0 / 12.0;

  int n_a = 1;

  for (float a = -1; a < 1; a += stp_u) {

    n_a *= -1;

    int n_b = n_a;

    for (float b = -1; b < 1; b += stp_v) {

      n_b *= -1;

      float[][] newQuad = {
        {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
        , {
          0, 0, 0
        }
      };

      for (int i = 0; i < 4; i++) {

        float u = a;
        float v = b;

        if ((i == 1) || (i == 2)) u += stp_u;
        if ((i == 2) || (i == 3)) v += stp_v;

        //---------------------------------------
        float x0 = cos(u * PI); 
        float y0 = sin(u * PI) * cos(v * PI);
        float z0 = sin(v * PI);

        float d = pow(x0*x0 + y0*y0 + z0*z0, 0.5);
        x0 /= d;  
        y0 /= d;  
        z0 /= d;  

        float x = x0;
        float y = y0;
        float z = z0;

        if (the_view == 0) { // corner view: logo
          float t = 0.25 * PI;
          newQuad[i][0] = x0 * cos(t) - z0 * sin(t);
          newQuad[i][1] = y0;   
          newQuad[i][2] = x0 * sin(t) + z0 * cos(t);
        } else if (the_view == 1) { // front view
          newQuad[i][0] = x0;
          newQuad[i][1] = y0;   
          newQuad[i][2] = z0;
        } else if (the_view == -1) { // top view
          newQuad[i][0] = x0;
          newQuad[i][1] = z0;   
          newQuad[i][2] = y0;
        }
      }

      float x1 = cr * newQuad[0][0] + cx;
      float y1 = cr * newQuad[0][1] + cy;
      float z1 = cr * newQuad[0][2] + cz;

      float x2 = cr * newQuad[1][0] + cx;
      float y2 = cr * newQuad[1][1] + cy;
      float z2 = cr * newQuad[1][2] + cz;

      float x3 = cr * newQuad[2][0] + cx;
      float y3 = cr * newQuad[2][1] + cy;
      float z3 = cr * newQuad[2][2] + cz;

      float x4 = cr * newQuad[3][0] + cx;
      float y4 = cr * newQuad[3][1] + cy;
      float z4 = cr * newQuad[3][2] + cz;

      if (n_a * n_b == 1) {
        triangle(x1, y1, x2, y2, x3, y3);
        triangle(x3, y3, x4, y4, x1, y1);
      } else {
        triangle(x4, y4, x1, y1, x2, y2);
        triangle(x2, y2, x3, y3, x4, y4);
      }
    }
  }
}













int mouseWheelConsume = 0;

void mouseWheel (MouseEvent event) {

  if (frameCount > Last_initializationStep) {

    if (UI_BAR_a.selected_parent == -1) {

      mouseWheelConsume += 1;
      if (mouseWheelConsume % 2 == 0) {
        mouseWheelConsume = 0;

        float Wheel_Value = event.getCount(); 

        if (SOLARCHVISION_automated == 0) {
          SOLARCHVISION_X_clicked = mouseX;
          SOLARCHVISION_Y_clicked = mouseY;

          {
            float displayBarHeight = MessageSize;
            float displayBarWidth = 2 * SOLARCHVISION_pixel_W; 

            STUDY.X_control = 0.5 * displayBarWidth;
            STUDY.Y_control = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + 0.5 * UI_BAR_d.tab;

            for (int i = 0; i < UI_BAR_d.Items.length; i++) {

              float x1 = STUDY.X_control - 0.366 * displayBarWidth;
              float x2 = STUDY.X_control + 0.5 * displayBarWidth;
              float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
              float y2 = STUDY.Y_control + 0.45 * displayBarHeight;

              if (UI_BAR_d.Items[i][0].equals("Day")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_i_Start = STUDY.i_Start;
                  int keep_STUDY_i_End = STUDY.i_End;

                  if (Wheel_Value > 0) {
                    STUDY.i_Start += 1; 
                    STUDY.i_End += 1;
                  } 
                  if (Wheel_Value < 0) {
                    STUDY.i_Start -= 1; 
                    STUDY.i_End -= 1;
                  } 

                  if (STUDY.i_Start < 0) STUDY.i_Start = 23;
                  if (STUDY.i_Start > 23) STUDY.i_Start = 0;
                  if (STUDY.i_End < 0) STUDY.i_End = 23;
                  if (STUDY.i_End > 23) STUDY.i_End = 0;

                  if ((keep_STUDY_i_Start != STUDY.i_Start) || (keep_STUDY_i_End != STUDY.i_End)) {

                    ROLLOUT.update = true;
                    STUDY.update = true;
                    WIN3D.update = true;
                    WORLD.update = true;
                    UI_BAR_d.update = true;

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_BAR_d.Items[i][0].equals("Year")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  int keep_STUDY_joinDays = STUDY.joinDays;

                  if (Wheel_Value > 0) STUDY.joinDays += 2;
                  if (Wheel_Value < 0) STUDY.joinDays -= 2;

                  if (STUDY.joinDays > 365 / STUDY.j_End) STUDY.joinDays = 365 / STUDY.j_End;
                  if (STUDY.joinDays < 1) STUDY.joinDays = 1;

                  if (keep_STUDY_joinDays != STUDY.joinDays) {

                    ROLLOUT.update = true;
                    STUDY.update = true;
                    WIN3D.update = true;
                    UI_BAR_d.update = true;

                    SOLARCHVISION_find_which_bakings_to_regenerate();
                  }
                }
              }

              if (UI_BAR_d.Items[i][0].equals("Scenario")) {

                if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CWEEDS_start) SampleYear_Start = CLIMATE_CWEEDS_start;
                    if (SampleYear_Start > CLIMATE_CWEEDS_end) SampleYear_Start = CLIMATE_CWEEDS_end;
                    if (SampleYear_End < CLIMATE_CWEEDS_start) SampleYear_End = CLIMATE_CWEEDS_start;
                    if (SampleYear_End > CLIMATE_CWEEDS_end) SampleYear_End = CLIMATE_CWEEDS_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d.update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }
                  
                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                    int keep_SampleYear_Start = SampleYear_Start;
                    int keep_SampleYear_End = SampleYear_End;

                    if (Wheel_Value > 0) {
                      SampleYear_Start += 1; 
                      SampleYear_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleYear_Start -= 1; 
                      SampleYear_End -= 1;
                    }

                    if (SampleYear_End < SampleYear_Start) SampleYear_End = SampleYear_Start;
                    if (SampleYear_Start > SampleYear_End) SampleYear_Start = SampleYear_End;

                    if (SampleYear_Start < CLIMATE_CLMREC_start) SampleYear_Start = CLIMATE_CLMREC_start;
                    if (SampleYear_Start > CLIMATE_CLMREC_end) SampleYear_Start = CLIMATE_CLMREC_end;
                    if (SampleYear_End < CLIMATE_CLMREC_start) SampleYear_End = CLIMATE_CLMREC_start;
                    if (SampleYear_End > CLIMATE_CLMREC_end) SampleYear_End = CLIMATE_CLMREC_end;

                    if ((keep_SampleYear_Start != SampleYear_Start) || (keep_SampleYear_End != SampleYear_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d.update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }                  

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    int keep_SampleMember_Start = SampleMember_Start;
                    int keep_SampleMember_End = SampleMember_End;

                    if (Wheel_Value > 0) {
                      SampleMember_Start += 1; 
                      SampleMember_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleMember_Start -= 1; 
                      SampleMember_End -= 1;
                    }

                    if (SampleMember_End < SampleMember_Start) SampleMember_End = SampleMember_Start;
                    if (SampleMember_Start > SampleMember_End) SampleMember_Start = SampleMember_End; 

                    if (SampleMember_Start < ENSEMBLE_FORECAST_start) SampleMember_Start = ENSEMBLE_FORECAST_start;
                    if (SampleMember_Start > ENSEMBLE_FORECAST_end) SampleMember_Start = ENSEMBLE_FORECAST_end;
                    if (SampleMember_End < ENSEMBLE_FORECAST_start) SampleMember_End = ENSEMBLE_FORECAST_start;
                    if (SampleMember_End > ENSEMBLE_FORECAST_end) SampleMember_End = ENSEMBLE_FORECAST_end;

                    if ((keep_SampleMember_Start != SampleMember_Start) || (keep_SampleMember_End != SampleMember_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d.update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }   

                  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                    int keep_SampleStation_Start = SampleStation_Start;
                    int keep_SampleStation_End = SampleStation_End;

                    if (Wheel_Value > 0) {
                      SampleStation_Start += 1; 
                      SampleStation_End += 1;
                    }
                    if (Wheel_Value < 0) {
                      SampleStation_Start -= 1; 
                      SampleStation_End -= 1;
                    }

                    if (SampleStation_End < SampleStation_Start) SampleStation_End = SampleStation_Start;
                    if (SampleStation_Start > SampleStation_End) SampleStation_Start = SampleStation_End; 

                    if (SampleStation_Start < ENSEMBLE_OBSERVED_start) SampleStation_Start = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_Start > ENSEMBLE_OBSERVED_end) SampleStation_Start = ENSEMBLE_OBSERVED_end;
                    if (SampleStation_End < ENSEMBLE_OBSERVED_start) SampleStation_End = ENSEMBLE_OBSERVED_start;
                    if (SampleStation_End > ENSEMBLE_OBSERVED_end) SampleStation_End = ENSEMBLE_OBSERVED_end;

                    if ((keep_SampleStation_Start != SampleStation_Start) || (keep_SampleStation_End != SampleStation_End)) {

                      ROLLOUT.update = true;
                      STUDY.update = true;
                      WIN3D.update = true;
                      UI_BAR_d.update = true;

                      SOLARCHVISION_find_which_bakings_to_regenerate();
                    }
                  }
                }
              }            


              STUDY.Y_control += UI_BAR_d.tab;
            }
          }


          if (WORLD.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY) == 1) {

              int keep_WORLD_Zoom = WORLD.Zoom;

              if (Wheel_Value < 0) WORLD.Zoom -= 1;
              if (Wheel_Value > 0) WORLD.Zoom += 1;

              if (WORLD.Zoom < 1) WORLD.Zoom = 1;
              if (WORLD.Zoom > 6) WORLD.Zoom = 6;

              if (keep_WORLD_Zoom != WORLD.Zoom) {
                WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);

                WORLD.update = true;
              }
            }
          }    

          if (WIN3D.include) {
            if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

              float[] P = userSelections.getPivot();

              float x0 = P[0];
              float y0 = P[1];
              float z0 = P[2];


              if (WIN3D.UI_CurrentTask == UITASK.Rotate) { // rotate

                float r = 5 * Wheel_Value;

                int the_Vector = userSelections.rotVector;

                userSelections.rotate_Selection(x0, y0, z0, r, the_Vector);

                WIN3D.update = true;
              }   

              if (WIN3D.UI_CurrentTask == UITASK.Scale) { // scale

                float s = pow(pow(2.0, 0.25), Wheel_Value);

                float sx = s;
                float sy = s;
                float sz = s;

                int the_Vector = userSelections.scaleVector;

                if (the_Vector == 0) {
                  sy = 1; 
                  sz = 1;
                }  
                if (the_Vector == 1) {
                  sz = 1; 
                  sx = 1;
                }  
                if (the_Vector == 2) {
                  sx = 1; 
                  sy = 1;
                }                    

                userSelections.scale_Selection(x0, y0, z0, sx, sy, sz);

                WIN3D.update = true;
              }       


              if (WIN3D.UI_CurrentTask == UITASK.Move) { // move

                float d = Wheel_Value;

                float dx = d;
                float dy = d;
                float dz = d;

                int the_Vector = userSelections.posVector;

                if (the_Vector == 0) {
                  dy = 0; 
                  dz = 0;
                }  
                if (the_Vector == 1) {
                  dz = 0; 
                  dx = 0;
                }  
                if (the_Vector == 2) {
                  dx = 0; 
                  dy = 0;
                }  

                userSelections.move_Selection(dx, dy, dz);

                WIN3D.update = true;
              }   



              if (WIN3D.UI_TaskModifyParameter == 0) {
                if (WIN3D.UI_CurrentTask >= UITASK.Seed_Material) { // other properties

                  int p = int(Wheel_Value);

                  userSelections.changeProperties_Selection(p);

                  WIN3D.update = true;
                }
              }
              
              



              if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) || (WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll)) { // viewport:zoom

                if (WIN3D.ViewType == 1) {
                  WIN3D.position_Z += Wheel_Value * WIN3D.position_T * OBJECTS_scale;
                } else {
                  WIN3D.Zoom /= pow(2.0, Wheel_Value);
                }

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) { // viewport:elevation

                if (Wheel_Value > 0) WIN3D.Zoom = 2 * funcs.atan_ang((1.0 / 1.1) * funcs.tan_ang(0.5 * WIN3D.Zoom)); 
                if (Wheel_Value < 0) WIN3D.Zoom = 2 * funcs.atan_ang((1.1 / 1.0) * funcs.tan_ang(0.5 * WIN3D.Zoom));

                WIN3D.update = true;
              }  

              if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport:3DModelSize

                if (Wheel_Value > 0) OBJECTS_scale *= pow(2.0, 0.25);
                if (Wheel_Value < 0) OBJECTS_scale /= pow(2.0, 0.25);

                WIN3D.update = true;
              }          

              if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.position_X += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                    WIN3D.update = true;
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.position_Y += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                    WIN3D.update = true;
                  }
                }


                if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                  if (WIN3D.UI_OptionXorY == 0) {

                    WIN3D.rotation_X += Wheel_Value * WIN3D.rotation_T;

                    WIN3D.update = true;
                  }

                  if (WIN3D.UI_OptionXorY == 1) {

                    WIN3D.rotation_Z += Wheel_Value * WIN3D.rotation_T;

                    WIN3D.update = true;
                  }
                }


                WIN3D.update = true;
              }  


              if (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // SkydomeSize

                  if (Wheel_Value > 0) Sky3D.scale *= pow(2.0, 0.25);              
                  if (Wheel_Value < 0) Sky3D.scale /= pow(2.0, 0.25);

                  WIN3D.update = true;
                }
              }

              if (WIN3D.UI_CurrentTask == UITASK.AllModelSize) { // viewport:different functions with wheel

                if (WIN3D.UI_TaskModifyParameter == 0) { // AllModelSize

                  if (Wheel_Value > 0) {
                    OBJECTS_scale *= pow(2.0, 0.25);
                    Sky3D.scale *= pow(2.0, 0.25);
                  }              

                  if (Wheel_Value < 0) {
                    OBJECTS_scale /= pow(2.0, 0.25);
                    Sky3D.scale /= pow(2.0, 0.25);
                  }      

                  WIN3D.update = true;
                }
              }    

              if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport:TargetRollXY/TargetRoolZ

                if (WIN3D.UI_OptionXorY == 0) {   
                  WIN3D.rotation_X += Wheel_Value * WIN3D.rotation_T;

                  WIN3D.reverseTransform_3DViewport();
                }

                if (WIN3D.UI_OptionXorY == 1) {   
                  WIN3D.rotation_Z += Wheel_Value * WIN3D.rotation_T;

                  WIN3D.reverseTransform_3DViewport();
                }              

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport:CameraRollXY/CameraRoolZ

                if (WIN3D.UI_OptionXorY == 0) {   

                  WIN3D.rotateZ_3DViewport_around_Selection(Wheel_Value * WIN3D.rotation_T);
                }

                if (WIN3D.UI_OptionXorY == 1) {   

                  WIN3D.rotateXY_3DViewport_around_Selection(Wheel_Value * WIN3D.rotation_T);
                }    

                WIN3D.update = true;
              }            

              if (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ) { // viewport:CameraDistance

                WIN3D.move_3DViewport_towards_Selection(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }              

              if (WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) { // viewport:PanX

                WIN3D.position_X += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                WIN3D.update = true;
              }         

              if (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ) { // viewport:PanY

                WIN3D.position_Y += Wheel_Value * WIN3D.position_T * OBJECTS_scale;

                WIN3D.update = true;
              }      

              if ((WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport:DistMouseXY

                WIN3D.move_3DViewport_towards_Mouse(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }

              if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport:LandOrbit

                WIN3D.move_3DViewport_towards_Mouse(pow(2, -0.5 * Wheel_Value));

                WIN3D.update = true;
              }      


              
            }
          }
        }
      }
    }
  }
}


int dragging_started = 0;

void mouseReleased () {

  if (frameCount > Last_initializationStep) {  

    if (SOLARCHVISION_automated == 0) {

      if (dragging_started != 0) {

        SOLARCHVISION_X_click2 = mouseX;
        SOLARCHVISION_Y_click2 = mouseY;

        int swap_tmp = 0;

        if (SOLARCHVISION_X_click2 < SOLARCHVISION_X_click1) {
          swap_tmp = SOLARCHVISION_X_click2;
          SOLARCHVISION_X_click2 = SOLARCHVISION_X_click1;
          SOLARCHVISION_X_click1 = swap_tmp;
        }

        if (SOLARCHVISION_Y_click2 < SOLARCHVISION_Y_click1) {
          swap_tmp = SOLARCHVISION_Y_click2;
          SOLARCHVISION_Y_click2 = SOLARCHVISION_Y_click1;
          SOLARCHVISION_Y_click1 = swap_tmp;
        }        

        if (FRAME_drag_IMG) {

          SOLARCHVISION_RecordFrame();

          strokeWeight(2);
          if (mouseButton == RIGHT) {
            noStroke();
            fill(127, 127);
          } else {
            stroke(255, 0, 0);
            noFill();
          }          

          rect(SOLARCHVISION_X_click1, SOLARCHVISION_Y_click1, SOLARCHVISION_X_click2 - SOLARCHVISION_X_click1, SOLARCHVISION_Y_click2 - SOLARCHVISION_Y_click1);
          strokeWeight(0);

          SOLARCHVISION_RecordFrame();

          WORLD.update = true;
          WIN3D.update = true;  
          STUDY.update = true;
          ROLLOUT.update = true;
          UI_BAR_a.update = true;
          UI_BAR_b.update = true;
          UI_BAR_d.update = true;          

          FRAME_drag_IMG = false;

          dragging_started = 0;
        } else {        

          if (WIN3D.include) {
            if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

              if ((WIN3D.UI_CurrentTask == UITASK.RectSelect) || (WIN3D.UI_CurrentTask > UITASK.Move)) { // RectSelect also if scale, rotate, modify, etc. where selected          

                float corner1x = SOLARCHVISION_X_click1 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner1y = SOLARCHVISION_Y_click1 - 0.5 * WIN3D.dY - WIN3D.cY;

                float corner2x = SOLARCHVISION_X_click2 - 0.5 * WIN3D.dX - WIN3D.cX;
                float corner2y = SOLARCHVISION_Y_click2 - 0.5 * WIN3D.dY - WIN3D.cY;

                pushMatrix();

                translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

                noFill();

                stroke(127); 
                strokeWeight(2);

                rect(corner1x, corner1y, corner2x - corner1x, corner2y - corner1y);

                popMatrix();            

                userSelections.selectRect(corner1x, corner1y, corner2x, corner2y);

                userSelections.calculate_selection_BoundingBox();

                userSelections.reset_selectedRefValues();  

                WIN3D.update = true;
              }


              if (WIN3D.UI_CurrentTask == UITASK.GetLength) {      

                float x1 = 0;
                float y1 = 0;
                float z1 = 0;

                float x2 = 0;
                float y2 = 0;
                float z2 = 0;

                for (int q = 0; q < 2; q++) {

                  float Image_X = 0;
                  float Image_Y = 0;

                  if (q == 0) {
                    Image_X = SOLARCHVISION_X_click1 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click1 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }
                  if (q == 1) {
                    Image_X = SOLARCHVISION_X_click2 - (WIN3D.cX + 0.5 * WIN3D.dX);
                    Image_Y = SOLARCHVISION_Y_click2 - (WIN3D.cY + 0.5 * WIN3D.dY);
                  }

                  float[] ray_direction = new float [3];

                  float[] ray_start = {
                    WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
                  };

                  float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

                  ray_start[0] /= OBJECTS_scale;
                  ray_start[1] /= OBJECTS_scale;
                  ray_start[2] /= OBJECTS_scale;          

                  ray_end[0] /= OBJECTS_scale;
                  ray_end[1] /= OBJECTS_scale;
                  ray_end[2] /= OBJECTS_scale;

                  if (WIN3D.ViewType == 0) {
                    float[] ray_center = WIN3D.calculate_Click3D(0, 0);

                    ray_center[0] /= OBJECTS_scale;
                    ray_center[1] /= OBJECTS_scale;
                    ray_center[2] /= OBJECTS_scale;

                    ray_start[0] += ray_end[0] - ray_center[0];
                    ray_start[1] += ray_end[1] - ray_center[1];
                    ray_start[2] += ray_end[2] - ray_center[2];
                  }

                  ray_direction[0] = ray_end[0] - ray_start[0];
                  ray_direction[1] = ray_end[1] - ray_start[1];
                  ray_direction[2] = ray_end[2] - ray_start[2];

                  float[] RxP = new float [8]; 

                  if (mouseButton == RIGHT) {
                    RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
                  } else if (mouseButton == LEFT) {
                    RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));
                  }

                  if (RxP[0] >= 0) {
                    if (q == 0) {
                      x1 = RxP[1];
                      y1 = RxP[2];
                      z1 = RxP[3];
                    }
                    if (q == 1) {
                      x2 = RxP[1];
                      y2 = RxP[2];
                      z2 = RxP[3];
                    }
                  }
                }

                float dx = x2 - x1;
                float dy = y2 - y1;
                float dz = z2 - z1;

                float dx_rot = dx * funcs.cos_ang(-WIN3D.rotation_Z) - dy * funcs.sin_ang(-WIN3D.rotation_Z);
                float dy_rot = dx * funcs.sin_ang(-WIN3D.rotation_Z) + dy * funcs.cos_ang(-WIN3D.rotation_Z);
                float dz_rot = dz;

                if (WIN3D.UI_TaskModifyParameter == 0) {
                  User3D.create_Length = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 1) {
                  User3D.create_Width = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 2) {
                  User3D.create_Height = dist(x1, y1, z1, x2, y2, z2);
                }
                if (WIN3D.UI_TaskModifyParameter == 3) {
                  User3D.create_Length = abs(dx_rot);
                  User3D.create_Width = abs(dy_rot);
                  User3D.create_Height = abs(dz_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 4) {
                  User3D.create_Length = abs(dx_rot);
                  User3D.create_Width = abs(dy_rot);
                }
                if (WIN3D.UI_TaskModifyParameter == 5) {
                  User3D.create_Orientation = funcs.atan2_ang(y2 - y1, x2 - x1) + 90;
                }

                ROLLOUT.update = true;
              }
            }
          }

          dragging_started = 0;
        }
      }
    }
  }
}

void mouseDragged () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_drag_IMG) {
        if (dragging_started == 0) {
          SOLARCHVISION_X_click1 = pmouseX;
          SOLARCHVISION_Y_click1 = pmouseY;

          dragging_started = 1;
        }
      } else if (WIN3D.include) {
        if (isInside(pmouseX, pmouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {
          if (isInside(mouseX, mouseY, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

            if (dragging_started == 0) {

              SOLARCHVISION_X_click1 = pmouseX;
              SOLARCHVISION_Y_click1 = pmouseY;

              dragging_started = 1;
            }

            float dx = (mouseX - pmouseX) / float(WIN3D.dX);
            float dy = (mouseY - pmouseY) / float(WIN3D.dY);

            if (WIN3D.UI_CurrentTask == UITASK.LandOrbit_Pan_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraLandOrbit

                WIN3D.rotateXY_3DViewport_around_LandIntersection(10 * dx * WIN3D.rotation_T);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }
            } 

            if ((WIN3D.UI_CurrentTask == UITASK.PanX_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PanY_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                WIN3D.update = true;
              }
            } 

            if ((WIN3D.UI_CurrentTask == UITASK.Pan_TargetRoll) || (WIN3D.UI_CurrentTask == UITASK.DistMouseXY_TargetRollXY_TargetRollZ) || (WIN3D.UI_CurrentTask == UITASK.PickSelect)) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }      

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T; 
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }            

            if ((WIN3D.UI_CurrentTask == UITASK.CameraRoll_Pan) || (WIN3D.UI_CurrentTask == UITASK.CameraDistance_TargetRollXY_TargetRollZ)) { // viewport

              if (mouseButton == LEFT) { // CameraRoll

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.CameraRollXY_CameraRollZ) { // viewport

              if (mouseButton == LEFT) { // CameraRollXY

                WIN3D.rotateXY_3DViewport_around_Selection(10 * dx * WIN3D.rotation_T);

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // CameraRollZ

                WIN3D.rotateZ_3DViewport_around_Selection(10 * dy * WIN3D.rotation_T);

                WIN3D.update = true;
              }
            }            

            if (WIN3D.UI_CurrentTask == UITASK.TargetRoll_Pan) { // viewport

              if (mouseButton == LEFT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T; 
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.TargetRollXY_TargetRollZ) { // viewport

              if (mouseButton == LEFT) { // TargetRollXY

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T; 

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // TargetRollZ

                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }            

            if ((WIN3D.UI_CurrentTask == UITASK.Zoom_Orbit_Pan) || (WIN3D.UI_CurrentTask == UITASK.SkydomeSize) || (WIN3D.UI_CurrentTask == UITASK.AllModelSize)) { // viewport

              if (mouseButton == LEFT) { // orbit

                WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T; 
                WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;

                WIN3D.update = true;
              }

              if (mouseButton == RIGHT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }
            }  

            if (WIN3D.UI_CurrentTask == UITASK.Pan_Height) { 

              if (mouseButton == LEFT) { // move Y

                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale;  

                WIN3D.update = true;
              }              

              if (mouseButton == RIGHT) { // move X

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  

                WIN3D.update = true;
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.ModelSize_Pan_TargetRoll) { // viewport

              if (mouseButton == LEFT) { // Pan

                WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 

                WIN3D.update = true;
              }   

              if (mouseButton == RIGHT) { // TargetRoll

                WIN3D.rotation_Z += 10 * dx * WIN3D.rotation_T; 
                WIN3D.rotation_X += 10 * dy * WIN3D.rotation_T;

                WIN3D.reverseTransform_3DViewport(); 

                WIN3D.update = true;
              }
            }

            if (WIN3D.UI_CurrentTask == UITASK.Truck_Orbit) { // viewport:different functions

              if (WIN3D.UI_TaskModifyParameter == 0) { // Truck

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                  if (mouseButton == RIGHT) WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 
                  WIN3D.update = true;
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.position_X += 100 * dx * WIN3D.position_T * OBJECTS_scale;  
                  if (mouseButton == LEFT) WIN3D.position_Y += 100 * dy * WIN3D.position_T * OBJECTS_scale; 
                  WIN3D.update = true;
                }
              }


              if (WIN3D.UI_TaskModifyParameter == 1) {  // Orbit

                if (WIN3D.UI_OptionXorY == 0) {
                  if (mouseButton == LEFT) WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;
                  if (mouseButton == RIGHT) WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T;
                  WIN3D.update = true;
                }

                if (WIN3D.UI_OptionXorY == 1) {
                  if (mouseButton == RIGHT) WIN3D.rotation_X -= 10 * dy * WIN3D.rotation_T;
                  if (mouseButton == LEFT) WIN3D.rotation_Z -= 10 * dx * WIN3D.rotation_T;
                  WIN3D.update = true;
                }
              }


              WIN3D.update = true;
            }
          }
        }
      }
    }
  }
}


void SOLARCHVISION_update_project_info (File selectedFile) {

  ProjectName = selectedFile.getName().replace(".xml", "").replace(".XML", ""); // should work most of the times!
  Folder_Project =  selectedFile.getAbsolutePath().replace(char(92), '/').replace("/" + selectedFile.getName(), "");

  println("New ProjectName:", ProjectName);
  println("New Folder_Project:", Folder_Project);
}

void SOLARCHVISION_fileSelected_New (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("New project:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
}

void SOLARCHVISION_fileSelected_Open (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Loading:", Filename);

    SOLARCHVISION_load_project(Filename);

    SOLARCHVISION_update_project_info(selectedFile);
  }
} 


void SOLARCHVISION_fileSelected_SaveAs (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Saving to:", Filename);

    SOLARCHVISION_update_project_info(selectedFile);

    SOLARCHVISION_save_project(Filename);
  }
}     



void SOLARCHVISION_SelectFile_Import_3DModel (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');


    if (allGroups.num == 0) {
      allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);
    }


    println("Importing:", Filename);

    int number_of_allGroups_before = allGroups.num;

    //SOLARCHVISION_import_objects_OBJ(Filename, -1,0,0,1,0,0, 0,0,0, 1,1,1); // different objects: different materials
    SOLARCHVISION_import_objects_OBJ(Filename, User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, 0, 0, 0, 1, 1, 1); // apply default material

    int number_of_allGroups_after = allGroups.num;

    userSelections.Group_ids = new int [1 + number_of_allGroups_after - number_of_allGroups_before];
    for (int i = 0; i < userSelections.Group_ids.length - 1; i++) { 
      userSelections.Group_ids[i] = i + number_of_allGroups_before;
      //println(userSelections.Group_ids[i]);
    }

    current_ObjectCategory = ObjectCategory.GROUP;

    userSelections.calculate_selection_BoundingBox();

    WIN3D.update = true;
    
  }
}     


void SOLARCHVISION_SelectFile_Execute_CommandFile (File selectedFile) {

  String Filename = "";

  if (selectedFile == null) {
  } else {
    Filename = selectedFile.getAbsolutePath().replace(char(92), '/');

    println("Executing:", Filename);

    SOLARCHVISION_execute_commands_TXT(Filename);

    WIN3D.update = true;
  }
} 


void mouseClicked () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (FRAME_click_IMG) {

        SOLARCHVISION_RecordFrame();

        UI_BAR_b.drawMouse(1, mouseX, mouseY, 2 * MessageSize);        

        SOLARCHVISION_RecordFrame();
        /*        
         WORLD.update = true;
         WIN3D.update = true;  
         STUDY.update = true;
         ROLLOUT.update = true;
         UI_BAR_a.update = true;
         UI_BAR_b.update = true;
         UI_BAR_d.update = true;          
         
         FRAME_click_IMG = 0;
         */
      }    


      if ((UI_BAR_a.selected_parent != -1) && (isInside(mouseX, mouseY, 0, 0, width, SOLARCHVISION_pixel_A) == 0)) {
        
        String menu_option = UI_BAR_a.Items[UI_BAR_a.selected_parent][UI_BAR_a.selected_child];

        if (mouseButton == LEFT) {
          if (UI_BAR_a.selected_child != 0) {

            // should call the functions here!

            if (menu_option.equals("Mojtaba Samimi")) { 
              link("http://solarchvision.com/?page_id=102");
            }     

            if (menu_option.equals("www.solarchvision.com")) { 
              link("http://solarchvision.com/");
            }     

            if (menu_option.equals("New")) { 
              
              /////////////////////////////
              SOLARCHVISION_hold_project();
              /////////////////////////////
              
              selectInput("Specify project name:", "SOLARCHVISION_fileSelected_New");

              SOLARCHVISION_delete_All();

              //SOLARCHVISION_update_station(0);
            }  

            if (menu_option.equals("Save")) { 
              SOLARCHVISION_save_project(Folder_Project + "/" + ProjectName + ".xml");
            }

            if (menu_option.equals("Hold")) {
              
              SOLARCHVISION_hold_project();
            }            

            if (menu_option.equals("Fetch")) {
              
              SOLARCHVISION_fetch_project();
            } 

            if (menu_option.equals("Undo")) {
            }             

            if (menu_option.equals("Open...")) { 
              selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
            }          

            if (menu_option.equals("Save As...")) { 
              selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
            }

            if (menu_option.equals("Import 3D-Model...")) { 
              selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
            }   

            if (menu_option.equals("Execute CommandFile...")) { 
              selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
            } 

            if (menu_option.equals("Export 3D-Model > OBJ (time-series)")) {
              SOLARCHVISION_export_objects_OBJ_timeSeries();
            } 
                        

            if (menu_option.equals("Export 3D-Model > OBJ (date-series)")) {
              SOLARCHVISION_export_objects_OBJ_dateSeries();
            } 
            
            if (menu_option.equals("Export 3D-Model > OBJ")) {
              SOLARCHVISION_export_objects_OBJ("");
            }    
            
            if (menu_option.equals("Export 3D-Model > HTML")) {
              SOLARCHVISION_export_objects_HTML();
            }              
            
            if (menu_option.equals("Export 3D-Model > RAD")) {
              SOLARCHVISION_export_objects_RAD();
            }
        
            if (menu_option.equals("Export 3D-Model > SCR")) {
              SOLARCHVISION_export_objects_SCR();
            }                

            if (menu_option.equals("Quit")) { 
              exit();
            }      



            if (menu_option.equals("Wind pattern (active)")) {
              STUDY.PlotImpacts = -2;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = true;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Wind pattern (passive)")) {
              STUDY.PlotImpacts = -1;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = true;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Urban solar potential (active)")) {
              STUDY.PlotImpacts = 0;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Urban solar potential (passive)")) {
              STUDY.PlotImpacts = 1;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Orientation potential (active)")) {
              STUDY.PlotImpacts = 2;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Orientation potential (passive)")) {
              STUDY.PlotImpacts = 3;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Hourly sun position (active)")) {
              STUDY.PlotImpacts = 4;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Hourly sun position (passive)")) {
              STUDY.PlotImpacts = 5;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("View from sun & sky (active)")) {
              STUDY.PlotImpacts = 6;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("View from sun & sky (passive)")) {
              STUDY.PlotImpacts = 7;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Annual cycle sun path (active)")) {
              STUDY.PlotImpacts = 8;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Annual cycle sun path (passive)")) {
              STUDY.PlotImpacts = 9;
              STUDY.plotSetup = 14; // <<<<<<<<
              STUDY.update = true;
              allWindRoses.displayImage = false;
              ROLLOUT.update = true;
            }  

            if (menu_option.equals("Pre-bake Selected Sections")) {
              allSolarImpacts.render_Shadows_selectedSections();              
              WIN3D.update = true;
            }         

            if (menu_option.equals("Process Active Impact")) {
              STUDY.PlotImpacts = 0;         
              allSolarImpacts.calculate_Impact_selectedSections();              
              WIN3D.update = true;
            }   

            if (menu_option.equals("Process Passive Impact")) {
              STUDY.PlotImpacts = 1;         
              allSolarImpacts.calculate_Impact_selectedSections();              
              WIN3D.update = true;
            }               

            if (menu_option.equals("Process Solid Impact")) {
              allSolidImpacts.calculate_Impact_selectedSections();              
              WIN3D.update = true;
            }  

            if (menu_option.equals("Run wind 3D-model")) {
              allSolidImpacts.calculate_WindFlow();              
              WIN3D.update = true;
            }  

            for (int n = -2; n <= 14; n++) { 
              if (menu_option.equals("Layout " + nf(n, 0))) {

                STUDY.plotSetup = n;
                STUDY.update = true;

                if (STUDY.plotSetup == 14) {
                } else {  

                  if (FrameVariation != 2) {
                    FrameVariation = 2;
                    SOLARCHVISION_update_frame_layout();
                  }
                }
              }
            }




            if (menu_option.equals("Stop REC.")) { 
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;   

              ROLLOUT.update = true;
            }

            if (menu_option.equals("REC. Time Graph")) { 
              STUDY.record_AUTO = true;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;   

              ROLLOUT.update = true;
            } 

            if (menu_option.equals("REC. Location Graph")) { 
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = true;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;   

              ROLLOUT.update = true;
            } 

            if (menu_option.equals("REC. Solid Graph")) { 
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = true;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = false;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;   

              ROLLOUT.update = true;
            } 

            if (menu_option.equals("REC. Screenshot")) { 
              STUDY.record_AUTO = false;
              STUDY.record_IMG = false;
              STUDY.record_PDF = false;
              WORLD.record_AUTO = false;
              WORLD.record_IMG = false;
              WORLD.record_PDF = false;
              WIN3D.record_AUTO = false;
              WIN3D.record_IMG = false;
              FRAME_record_AUTO = true;
              FRAME_record_IMG = false;
              FRAME_click_IMG = false;
              FRAME_drag_IMG = false;   

              ROLLOUT.update = true;
            }             

            if (menu_option.equals("PDF Time Graph")) { 
              STUDY.record_PDF = true;
              STUDY.update = true;
            }   

            if (menu_option.equals("JPG Time Graph")) { 
              STUDY.record_IMG = true;
              STUDY.update = true;
            }   

            if (menu_option.equals("JPG Location Graph")) { 
              WORLD.record_IMG = true;
              WORLD.update = true;
            } 

            if (menu_option.equals("PDF Location Graph")) { 
              WORLD.record_PDF = true;
              WORLD.update = true;
            }   

            if (menu_option.equals("JPG 3D Graph")) { 
              WIN3D.record_IMG = true;
              WIN3D.update = true;
            } 
            
            if (menu_option.equals("JPG 3D Full-Period")) { 
              WIN3D.fullPeriod_IMG = true;
              WIN3D.record_IMG = true;
              WIN3D.update = true;
            }             

            if (menu_option.equals("Screenshot")) { 
              FRAME_record_IMG = true;
            }             

            if (menu_option.equals("Screenshot+Click")) { 
              FRAME_click_IMG = true;
            }           

            if (menu_option.equals("Screenshot+Drag")) { 
              FRAME_drag_IMG = true;
            }                

            if (menu_option.equals("update Station")) { 
              SOLARCHVISION_update_station(0);
            }
            
            if (menu_option.equals("Load Land Mesh")) { 
              Land3D.update_textures();
            }

            if (menu_option.equals("Load Land Texture")) { 
              Land3D.update_textures();
            }

            if (menu_option.equals("Download Land Mesh")) { 
              Land3D.download_mesh();
            }

            if (menu_option.equals("Download Land Texture")) { 
              Land3D.download_textures();
            }   
            
            if (menu_option.equals("Download Toroposphere")) {
              Tropo3D.download_images();
            }

            if (menu_option.equals("Download Aerial")) {
              SOLARCHVISION_download_AERIAL(TIME.year, TIME.month, TIME.day, TIME.hour);
            }
            if (menu_option.equals("Download NAEFS")) {
              download_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
            }     
            if (menu_option.equals("Download CLMREC")) {
              download_CLIMATE_CLMREC();
            }                      
            if (menu_option.equals("Download SWOB")) {
              download_ENSEMBLE_OBSERVED();
            }            
            
            
            


            if (menu_option.equals("update TMYEPW")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;
              
              CLIMATE_TMYEPW_load = true;
              update_CLIMATE_TMYEPW();
            }      
            if (menu_option.equals("update CWEEDS")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;
              
              CLIMATE_CWEEDS_load = true;
              update_CLIMATE_CWEEDS();
            }    
            if (menu_option.equals("update CLMREC")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;
              
              CLIMATE_CLMREC_load = true;
              update_CLIMATE_CLMREC();
            }   
            if (menu_option.equals("update SWOB")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;
              
              ENSEMBLE_OBSERVED_load = true;
              SOLARCHVISION_update_ENSEMBLE_OBSERVED();
            } 
            if (menu_option.equals("update NAEFS")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              
              ENSEMBLE_FORECAST_load = true;
              update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
            }    
            if (menu_option.equals("update Aerial")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              
              ENSEMBLE_FORECAST_load = true;
              SOLARCHVISION_load_AERIAL(TIME.year, TIME.month, TIME.day, TIME.hour);
            }      
   
        
            
            
            
            
            if (menu_option.equals("Typical Year (TMY)")) {
              CurrentDataSource = dataID_CLIMATE_TMYEPW;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d.update = true;    

              WORLD.displayAll_TMYEPW = 1;
              WORLD.displayNear_TMYEPW = true;  
            } 
            if (menu_option.equals("Long-term (CWEEDS)")) {
              CurrentDataSource = dataID_CLIMATE_CWEEDS;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d.update = true;    

              WORLD.displayAll_CWEEDS = 1;
              WORLD.displayNear_CWEEDS = true;                
            }
            if (menu_option.equals("Long-term (CLMREC)")) {
              CurrentDataSource = dataID_CLIMATE_CLMREC;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d.update = true; 

              WORLD.displayAll_CLMREC = 1;
              WORLD.displayNear_CLMREC = true;   
            }            
            if (menu_option.equals("Real-time Observed (SWOB)")) {
              CurrentDataSource = dataID_ENSEMBLE_OBSERVED;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d.update = true;      
  
              WORLD.displayAll_SWOB = 1;
              WORLD.displayNear_SWOB = true;             
            }                  
            if (menu_option.equals("Weather Forecast (NAEFS)")) {
              CurrentDataSource = dataID_ENSEMBLE_FORECAST;
              WORLD.update = true;
              WIN3D.update = true;  
              STUDY.update = true;
              ROLLOUT.update = true;
              UI_BAR_d.update = true;     
 
              WORLD.displayAll_NAEFS = 1;
              WORLD.displayNear_NAEFS = true;                 
            } 
     
            


            if (UI_BAR_a.Items[UI_BAR_a.selected_parent][0].equals("Layers")) {
              if (UI_BAR_a.selected_child > 0) {
                if (CurrentLayer_id != UI_BAR_a.selected_child - 1) {

                  if (UI_BAR_a.selected_child < numberOfLayers) {

                    changeCurrentLayerTo(UI_BAR_a.selected_child - 1);

                    DevelopLayer_id = CurrentLayer_id;

                    STUDY.update = true;
                  } else {

                    if ((Develop_Option == DEV_OP_06) || (Develop_Option == DEV_OP_07) || (Develop_Option == DEV_OP_08)) {

                      if (CurrentLayer_id == DevelopLayer_id) {

                        changeCurrentLayerTo(LAYER_developed.id);
                      }

                      Develop_Option = UI_BAR_a.selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);   

                      STUDY.update = true;
                    } else {

                      DevelopLayer_id = CurrentLayer_id;

                      changeCurrentLayerTo(LAYER_developed.id); 

                      Develop_Option = UI_BAR_a.selected_child - numberOfLayers;

                      SOLARCHVISION_postProcess_developDATA(CurrentDataSource);   

                      STUDY.update = true;
                    }
                  }
                }
              }
            }            



            if (menu_option.equals("Shade Surface Wire")) {
              WIN3D.FacesShade = SHADE.Surface_Wire;
              allFaces.displayEdges = true; //<<<<<<<<<<<<<<<

              WIN3D.update = true;  
            }       
            if (menu_option.equals("Shade Surface Base")) {
              WIN3D.FacesShade = SHADE.Surface_Base;
              WIN3D.update = true;  
            }           
            if (menu_option.equals("Shade Surface White")) {
              WIN3D.FacesShade = SHADE.Surface_White;
              WIN3D.update = true;  
            } 
            if (menu_option.equals("Shade Surface Materials")) {
              WIN3D.FacesShade = SHADE.Surface_Materials;
              WIN3D.update = true;  
            } 
            if (menu_option.equals("Shade Global Solar")) {
              WIN3D.FacesShade = SHADE.Global_Solar;
              WIN3D.update = true;  
            } 
            if (menu_option.equals("Shade Vertex Solar")) {
              WIN3D.FacesShade = SHADE.Vertex_Solar;
              WIN3D.update = true;  
            }           
            if (menu_option.equals("Shade Vertex Solid")) {
              WIN3D.FacesShade = SHADE.Vertex_Solid;
              WIN3D.update = true;  
            }           
            if (menu_option.equals("Shade Vertex Elevation")) {
              WIN3D.FacesShade = SHADE.Vertex_Elevation;
              WIN3D.update = true;  
            }      
            if (menu_option.equals("Render Viewport")) {
              
              SOLARCHVISION_RenderViewport();            
            }     
            if (menu_option.equals("PreBake Viewport")) {
              
              SOLARCHVISION_preBakeViewport();            
            }           
            

            if (menu_option.equals("Display/Hide Land Mesh")) {
              Land3D.displaySurface = !Land3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (menu_option.equals("Display/Hide Land Texture")) {
              Land3D.displayTexture = !Land3D.displayTexture;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }       
            if (menu_option.equals("Display/Hide Land Points")) {
              Land3D.displayPoints = !Land3D.displayPoints;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                 
            if (menu_option.equals("Display/Hide Land Depth")) {
              Land3D.displayDepth = !Land3D.displayDepth;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Vertices")) {
              allPoints.displayAll = !allPoints.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (menu_option.equals("Display/Hide Edges")) {
              allFaces.displayEdges = !allFaces.displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Normals")) {
              allFaces.displayNormals = !allFaces.displayNormals;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }             
            if (menu_option.equals("Display/Hide Leaves")) {
              allModel1Ds.displayLeaves = !allModel1Ds.displayLeaves;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Model1Ds")) {
              allModel1Ds.displayAll = !allModel1Ds.displayAll;
              allModel1Ds.displayLeaves = allModel1Ds.displayAll; // <<<<<<

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Model2Ds")) {
              allModel2Ds.displayAll = !allModel2Ds.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Curves")) {
              allCurves.displayAll = !allCurves.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }          
            if (menu_option.equals("Display/Hide Faces")) {
              allFaces.displayAll = !allFaces.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }       
            if (menu_option.equals("Display/Hide Solids")) {
              allSolids.displayAll = !allSolids.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (menu_option.equals("Display/Hide Sections")) {
              allSections.displayAll = !allSections.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (menu_option.equals("Display/Hide Cameras")) {
              allCameras.displayAll = !allCameras.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (menu_option.equals("Display/Hide Sky")) {
              Sky3D.displaySurface = !Sky3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide Sun Grid")) {
              Sun3D.displayGrid = !Sun3D.displayGrid;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (menu_option.equals("Display/Hide Sun Path")) {
              Sun3D.displayPath = !Sun3D.displayPath;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (menu_option.equals("Display/Hide Sun Pattern")) {
              Sun3D.displayPattern = !Sun3D.displayPattern;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (menu_option.equals("Display/Hide Sun Surface")) {
              Sun3D.displaySurface = !Sun3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide Moon Surface")) {
              Moon3D.displaySurface = !Moon3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide Earth Surface")) {
              Earth3D.displaySurface = !Earth3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (menu_option.equals("Display/Hide Troposphere")) {
              Tropo3D.displaySurface = !Tropo3D.displaySurface;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }              
            if (menu_option.equals("Display/Hide Solar Section")) {
              allSolarImpacts.displayImage = !allSolarImpacts.displayImage;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Display/Hide Solid Section")) {
              allSolidImpacts.displayImage = !allSolidImpacts.displayImage;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            } 
            if (menu_option.equals("Display/Hide Selected Solids")) {
              userSelections.Solid_displayEdges = !userSelections.Solid_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }            
            if (menu_option.equals("Display/Hide Selected Sections")) {
              userSelections.Section_displayEdges = !userSelections.Section_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide Selected Cameras")) {
              userSelections.Camera_displayEdges = !userSelections.Camera_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }     
            if (menu_option.equals("Display/Hide Selected LandPoints")) {
              userSelections.LandPoint_displayPoints = !userSelections.LandPoint_displayPoints;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                  
            if (menu_option.equals("Display/Hide Wind Flow")) {
              allWindFlows.displayAll = !allWindFlows.displayAll;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide Selected Faces")) {
              userSelections.Face_displayEdges = !userSelections.Face_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (menu_option.equals("Display/Hide Selected Faces Vertex Count")) {
              userSelections.Face_displayVertexCount = !userSelections.Face_displayVertexCount;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }            
            if (menu_option.equals("Display/Hide Selected Curves Vertex Count")) {
              userSelections.Curve_displayVertexCount = !userSelections.Curve_displayVertexCount;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }                   
            if (menu_option.equals("Display/Hide Selected Vertices")) {
              userSelections.Vertex_displayVertices = !userSelections.Vertex_displayVertices;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }   
            if (menu_option.equals("Display/Hide Selected Curves")) {
              userSelections.Curve_displayVertices = !userSelections.Curve_displayVertices;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }               
            if (menu_option.equals("Display/Hide Selected REF Pivot")) {
              userSelections.displayReferencePivot = !userSelections.displayReferencePivot;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }        
            if (menu_option.equals("Display/Hide Selected Group Pivot")) {
              userSelections.Group_displayPivot = !userSelections.Group_displayPivot;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }  
            if (menu_option.equals("Display/Hide Selected Group Edges")) {
              userSelections.Group_displayEdges = !userSelections.Group_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (menu_option.equals("Display/Hide Selected Group Box")) {
              userSelections.Group_displayBox = !userSelections.Group_displayBox;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (menu_option.equals("Display/Hide Selected 2D Edges")) {
              userSelections.Model2D_displayEdges = !userSelections.Model2D_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }    
            if (menu_option.equals("Display/Hide Selected 1D Edges")) {
              userSelections.Model1D_displayEdges = !userSelections.Model1D_displayEdges;

              WIN3D.update = true;  
              ROLLOUT.update = true;
            }              

            if (menu_option.equals("Display/Hide SWOB points")) {
              WORLD.displayAll_SWOB = (WORLD.displayAll_SWOB + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide SWOB nearest")) {
              WORLD.displayNear_SWOB = !WORLD.displayNear_SWOB;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide NAEFS points")) {
              WORLD.displayAll_NAEFS = (WORLD.displayAll_NAEFS + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide NAEFS nearest")) {
              WORLD.displayNear_NAEFS = !WORLD.displayNear_NAEFS;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide CWEEDS points")) {
              WORLD.displayAll_CWEEDS = (WORLD.displayAll_CWEEDS + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide CWEEDS nearest")) {
              WORLD.displayNear_CWEEDS = !WORLD.displayNear_CWEEDS;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide CLMREC points")) {
              WORLD.displayAll_CLMREC = (WORLD.displayAll_CLMREC + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide CLMREC nearest")) {
              WORLD.displayNear_CLMREC = !WORLD.displayNear_CLMREC;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }            
            if (menu_option.equals("Display/Hide TMYEPW points")) {
              WORLD.displayAll_TMYEPW = (WORLD.displayAll_TMYEPW + 1) % 2;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }
            if (menu_option.equals("Display/Hide TMYEPW nearest")) {
              WORLD.displayNear_TMYEPW = !WORLD.displayNear_TMYEPW;

              WORLD.update = true;  
              ROLLOUT.update = true;
            }

            if (menu_option.equals("3D-Tree")) {
              UI_set_to_Create_allModel1Ds();
              UI_BAR_b.hghlight("3D-Tree");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("2D-Tree")) {
              UI_set_to_Create_Tree();
              UI_BAR_b.hghlight("2D-Tree");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Person")) {
              UI_set_to_Create_Person();
              UI_BAR_b.hghlight("Person");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Point")) {
              UI_set_to_Create_Vertex();
              UI_BAR_b.hghlight("Point");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Spline")) {
              UI_set_to_Create_Curve();
              UI_BAR_b.hghlight("Spline");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Surface")) {
              UI_set_to_Create_Face();
              UI_BAR_b.hghlight("Surface");
              UI_BAR_b.update = true;
            }

            
            if (menu_option.equals("Parametric 1")) {
              UI_set_to_Create_Parametric(1);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Parametric 2")) {
              UI_set_to_Create_Parametric(2);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Parametric 3")) {
              UI_set_to_Create_Parametric(3);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Parametric 4")) {
              UI_set_to_Create_Parametric(4);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Parametric 5")) {
              UI_set_to_Create_Parametric(5);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Parametric 6")) {
              UI_set_to_Create_Parametric(6);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Parametric 7")) {
              UI_set_to_Create_Parametric(7);
              UI_BAR_b.hghlight("Parametric");      
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Tri")) {
              UI_set_to_Create_Tri();
              UI_BAR_b.hghlight("Tri");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Plane")) {
              UI_set_to_Create_Plane();
              UI_BAR_b.hghlight("Plane");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Poly")) {
              UI_set_to_Create_Poly();
              UI_BAR_b.hghlight("Poly");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Extrude")) {
              UI_set_to_Create_Extrude();
              UI_BAR_b.hghlight("Extrude");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Hyper")) {
              UI_set_to_Create_Hyper();
              UI_BAR_b.hghlight("Hyper");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("House1")) {
              UI_set_to_Create_House1();
              UI_BAR_b.hghlight("House1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("House2")) {
              UI_set_to_Create_House2();
              UI_BAR_b.hghlight("House2");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Box")) {
              UI_set_to_Create_Box();
              UI_BAR_b.hghlight("Box");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Icosahedron")) {
              UI_set_to_Create_Icosahedron();
              UI_BAR_b.hghlight("Icosahedron");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Octahedron")) {
              UI_set_to_Create_Octahedron();
              UI_BAR_b.hghlight("Octahedron");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Sphere")) {
              UI_set_to_Create_Sphere();
              UI_BAR_b.hghlight("Sphere");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Cylinder")) {
              UI_set_to_Create_Cylinder();
              UI_BAR_b.hghlight("Cylinder");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Cushion")) {
              UI_set_to_Create_Cushion();
              UI_BAR_b.hghlight("Cushion");
              UI_BAR_b.update = true;
            }



            if (menu_option.equals("Drop on LandSurface")) {
              UI_set_to_Modify_Drop(0);
              UI_BAR_b.hghlight("DrL±");
              UI_BAR_b.update = true;  

              userSelections.drop_Selection();
              WIN3D.update = true;
            }
            if (menu_option.equals("Drop on ModelSurface (Down)")) {
              UI_set_to_Modify_Drop(1);
              UI_BAR_b.hghlight("DrM-");
              UI_BAR_b.update = true;  

              userSelections.drop_Selection(); 
              WIN3D.update = true;
            }                      
            if (menu_option.equals("Drop on ModelSurface (Up)")) {
              UI_set_to_Modify_Drop(2);
              UI_BAR_b.hghlight("DrM+");
              UI_BAR_b.update = true;  

              userSelections.drop_Selection();
              WIN3D.update = true;
            }



            if (menu_option.equals("Get dX")) {
              UI_set_to_Modify_GetLength(0);
              UI_BAR_b.hghlight("GLx");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Get dY")) {
              UI_set_to_Modify_GetLength(1);
              UI_BAR_b.hghlight("GLy");
              UI_BAR_b.update = true;
            }              
            if (menu_option.equals("Get dZ")) {
              UI_set_to_Modify_GetLength(2);
              UI_BAR_b.hghlight("GLz");
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Get dXYZ")) {
              UI_set_to_Modify_GetLength(3);
              UI_BAR_b.hghlight("GL³");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Get dXY")) {
              UI_set_to_Modify_GetLength(4);
              UI_BAR_b.hghlight("GL²");
              UI_BAR_b.update = true;
            }      
            if (menu_option.equals("Get Angle")) {
              UI_set_to_Modify_GetLength(5);
              UI_BAR_b.hghlight("GLa");
              UI_BAR_b.update = true;
            }               


            if (menu_option.equals("MoveX")) {
              UI_set_to_Modify_Move(0);
              UI_BAR_b.hghlight("MVx");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("MoveY")) {
              UI_set_to_Modify_Move(1);
              UI_BAR_b.hghlight("MVy");
              UI_BAR_b.update = true;
            }              
            if (menu_option.equals("MoveZ")) {
              UI_set_to_Modify_Move(2);
              UI_BAR_b.hghlight("MVz");
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Move")) {
              UI_set_to_Modify_Move(3);
              UI_BAR_b.hghlight("MV³");
              UI_BAR_b.update = true;
            }


            if (menu_option.equals("ScaleX")) {
              UI_set_to_Modify_Scale(0);
              UI_BAR_b.hghlight("SCx");
              UI_BAR_b.update = true;
            }          
            if (menu_option.equals("ScaleY")) {
              UI_set_to_Modify_Scale(1);
              UI_BAR_b.hghlight("SCy");
              UI_BAR_b.update = true;
            }      
            if (menu_option.equals("ScaleZ")) {
              UI_set_to_Modify_Scale(2);
              UI_BAR_b.hghlight("SCz");
              UI_BAR_b.update = true;
            }    
            if (menu_option.equals("Scale")) {
              UI_set_to_Modify_Scale(3);
              UI_BAR_b.hghlight("SC³");
              UI_BAR_b.update = true;
            }


            if (menu_option.equals("PowerX")) {
              UI_set_to_Modify_Power(0);
              UI_BAR_b.hghlight("PWx");
              UI_BAR_b.update = true;
            }          
            if (menu_option.equals("PowerY")) {
              UI_set_to_Modify_Power(1);
              UI_BAR_b.hghlight("PWy");
              UI_BAR_b.update = true;
            }      
            if (menu_option.equals("PowerZ")) {
              UI_set_to_Modify_Power(2);
              UI_BAR_b.hghlight("PWz");
              UI_BAR_b.update = true;
            }    
            if (menu_option.equals("Power")) {
              UI_set_to_Modify_Power(3);
              UI_BAR_b.hghlight("PW³");
              UI_BAR_b.update = true;
            }


            if (menu_option.equals("RotateX")) {
              UI_set_to_Modify_Rotate(0);
              UI_BAR_b.hghlight("RTx");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("RotateY")) {
              UI_set_to_Modify_Rotate(1);
              UI_BAR_b.hghlight("RTy");
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("RotateZ")) {
              UI_set_to_Modify_Rotate(2);
              UI_BAR_b.hghlight("RTz");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Rotate")) {
              UI_set_to_Modify_Rotate(2);
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Pivot")) {
              UI_set_to_Modify_Pivot(0);
              UI_BAR_b.hghlight("SPvt0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick Pivot")) {
              UI_set_to_Modify_Pivot(1);
              UI_BAR_b.hghlight("SPvt1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign Pivot")) {
              UI_set_to_Modify_Pivot(2);
              UI_BAR_b.hghlight("SPvt2");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Save Current ReferenceBox")) {
              userSelections.save_current_BoundingBox();
              UI_BAR_b.hghlight("<pvt>");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Reset Saved ReferenceBox")) {
              userSelections.apply_saved_BoundingBox();
              UI_BAR_b.hghlight(">pvt<");
              UI_BAR_b.update = true;  
              WIN3D.update = true;
            }
            if (menu_option.equals("Use Selection ReferenceBox")) {
              userSelections.calculate_selection_BoundingBox();
              UI_BAR_b.hghlight("|pvt|");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Use Origin ReferenceBox")) {
              userSelections.apply_origin_ReferenceBox();
              UI_BAR_b.hghlight(".pvt.");
              UI_BAR_b.update = true;  
              WIN3D.update = true;
            }



            if (menu_option.equals("Begin New Group at Origin")) {
              
              allModel3Ds.beginNewGroup(0, 0, 0, 1, 1, 1, 0, 0, 0);

              userSelections.Group_ids = new int [1];
              userSelections.Group_ids[0] = allGroups.num - 1;

              WIN3D.update = true;
            }    

            if (menu_option.equals("Begin New Group at Pivot")) {

              allModel3Ds.beginNewGroup(userSelections.BoundingBox[1 + userSelections.alignX][0], userSelections.BoundingBox[1 + userSelections.alignX][1], userSelections.BoundingBox[1 + userSelections.alignX][2], userSelections.BoundingBox[1 + userSelections.alignX][3], userSelections.BoundingBox[1 + userSelections.alignX][4], userSelections.BoundingBox[1 + userSelections.alignX][5], userSelections.BoundingBox[1 + userSelections.alignX][6], userSelections.BoundingBox[1 + userSelections.alignX][7], userSelections.BoundingBox[1 + userSelections.alignX][8]);

              userSelections.Group_ids = new int [1];
              userSelections.Group_ids[0] = allGroups.num - 1;       

              WIN3D.update = true;
            }              

            if (menu_option.equals("Solid")) {
              UI_set_to_Create_Solid();
              UI_BAR_b.hghlight("SLD");
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Section")) {
              UI_set_to_Create_Section();
              UI_BAR_b.hghlight("SEC");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Camera")) {
              UI_set_to_Create_Camera();
              UI_BAR_b.hghlight("CAM");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Viewport >> Camera")) {

              float Camera_pX = WIN3D.position_X;
              float Camera_pY = WIN3D.position_Y;
              float Camera_pZ = WIN3D.position_Z;
              float Camera_pT = WIN3D.position_T;
              float Camera_rX = WIN3D.rotation_X;
              float Camera_rY = WIN3D.rotation_Y;
              float Camera_rZ = WIN3D.rotation_Z;
              float Camera_rT = WIN3D.rotation_T;
              float Camera_ZOOM = WIN3D.Zoom;

              int Camera_type = WIN3D.ViewType;

              allModel3Ds.add_Camera(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_ZOOM);

              WIN3D.currentCamera = allCameras.num - 1;
              WIN3D.apply_currentCamera();
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D.update = true;   
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Camera >> Viewport")) {

              allCameras.options[0][0] = allCameras.options[WIN3D.currentCamera][0];
              allCameras.options[0][1] = allCameras.options[WIN3D.currentCamera][1];
              allCameras.options[0][2] = allCameras.options[WIN3D.currentCamera][2];
              allCameras.options[0][3] = allCameras.options[WIN3D.currentCamera][3];
              allCameras.options[0][4] = allCameras.options[WIN3D.currentCamera][4];
              allCameras.options[0][5] = allCameras.options[WIN3D.currentCamera][5];
              allCameras.options[0][6] = allCameras.options[WIN3D.currentCamera][6];
              allCameras.options[0][7] = allCameras.options[WIN3D.currentCamera][7];
              allCameras.options[0][8] = allCameras.options[WIN3D.currentCamera][8];

              allCameras.Type[0] = allCameras.Type[WIN3D.currentCamera];

              WIN3D.currentCamera = 0;
              SOLARCHVISION_modify_Viewport_Title();

              WIN3D.update = true;   
              UI_BAR_b.update = true;
            }  

            if (menu_option.equals("GoTo Selected Camera")) {
              if (userSelections.Camera_ids.length > 0) {
                WIN3D.currentCamera = userSelections.Camera_ids[userSelections.Camera_ids.length - 1];
                WIN3D.apply_currentCamera();
                SOLARCHVISION_modify_Viewport_Title();
  
                WIN3D.update = true;   
                UI_BAR_b.update = true;
              }
            }
            
            if (menu_option.equals("LandMesh >> Group")) {
              Land3D.draw(TypeWindow.LandMesh);
              
              WIN3D.update = true;   
            }          
          
            if (menu_option.equals("LandGap >> Group")) {
              Land3D.draw(TypeWindow.LandGap);

              WIN3D.update = true;   
            }                



            if (menu_option.equals("Change Seed/Material")) {
              UI_set_to_Modify_Seed(0);
              UI_BAR_b.hghlight("Mat0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick Seed/Material")) {
              UI_set_to_Modify_Seed(1);
              UI_BAR_b.hghlight("Mat1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign Seed/Material")) {
              UI_set_to_Modify_Seed(2);
              UI_BAR_b.hghlight("Mat2");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Change Tessellation")) {
              UI_set_to_Modify_Tessellation(0);
              UI_BAR_b.hghlight("Tes0");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Pick Tessellation")) {
              UI_set_to_Modify_Tessellation(1);
              UI_BAR_b.hghlight("Tes1");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Assign Tessellation")) {
              UI_set_to_Modify_Tessellation(2);
              UI_BAR_b.hghlight("Tes2");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Change Layer")) {
              UI_set_to_Modify_Layer(0);
              UI_BAR_b.hghlight("Lyr0");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Pick Layer")) {
              UI_set_to_Modify_Layer(1);
              UI_BAR_b.hghlight("Lyr1");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Assign Layer")) {
              UI_set_to_Modify_Layer(2);
              UI_BAR_b.hghlight("Lyr2");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Change Visibility")) {
              UI_set_to_Modify_Visibility(0);
              UI_BAR_b.hghlight("Vsb0");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Pick Visibility")) {
              UI_set_to_Modify_Visibility(1);
              UI_BAR_b.hghlight("Vsb1");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Assign Visibility")) {
              UI_set_to_Modify_Visibility(2);
              UI_BAR_b.hghlight("Vsb2");
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Change Weight")) {
              UI_set_to_Modify_Weight(0);
              UI_BAR_b.hghlight("Wgt0");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Pick Weight")) {
              UI_set_to_Modify_Weight(1);
              UI_BAR_b.hghlight("Wgt1");
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Assign Weight")) {
              UI_set_to_Modify_Weight(2);
              UI_BAR_b.hghlight("Wgt2");
              UI_BAR_b.update = true;
            } 

            if (menu_option.equals("Flip Normal")) {
              UI_set_to_Modify_Normal(1);
              UI_BAR_b.hghlight("Norm1");
              UI_BAR_b.update = true;
            }                

            if (menu_option.equals("Set-Out Normal")) {
              UI_set_to_Modify_Normal(2);
              UI_BAR_b.hghlight("Norm2");
              UI_BAR_b.update = true;
            }   

            if (menu_option.equals("Set-In Normal")) {
              UI_set_to_Modify_Normal(3);
              UI_BAR_b.hghlight("Norm3");
              UI_BAR_b.update = true;
            }   

            if (menu_option.equals("Get FirstVertex")) {
              UI_set_to_Modify_FirstVertex(1);
              UI_BAR_b.hghlight("1stV");
              UI_BAR_b.update = true;
            }     
            


            if (menu_option.equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
              UI_BAR_b.hghlight("dgMax0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick DegreeMax")) {
              UI_set_to_Modify_DegreeMax(1);
              UI_BAR_b.hghlight("dgMax1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign DegreeMax")) {
              UI_set_to_Modify_DegreeMax(2);
              UI_BAR_b.hghlight("dgMax2");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Change DegreeDif")) {
              UI_set_to_Modify_DegreeDif(0);
              UI_BAR_b.hghlight("dgDif0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick DegreeDif")) {
              UI_set_to_Modify_DegreeDif(1);
              UI_BAR_b.hghlight("dgDif1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign DegreeDif")) {
              UI_set_to_Modify_DegreeDif(2);
              UI_BAR_b.hghlight("dgDif2");
              UI_BAR_b.update = true;
            }                 

            if (menu_option.equals("Change DegreeMin")) {
              UI_set_to_Modify_DegreeMin(0);
              UI_BAR_b.hghlight("dgMin0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick DegreeMin")) {
              UI_set_to_Modify_DegreeMin(1);
              UI_BAR_b.hghlight("dgMin1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign DegreeMin")) {
              UI_set_to_Modify_DegreeMin(2);
              UI_BAR_b.hghlight("dgMin2");
              UI_BAR_b.update = true;
            }     

            if (menu_option.equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
              UI_BAR_b.hghlight("trSz0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick TrunkSize")) {
              UI_set_to_Modify_TrunkSize(1);
              UI_BAR_b.hghlight("trSz1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign TrunkSize")) {
              UI_set_to_Modify_TrunkSize(2);
              UI_BAR_b.hghlight("trSz2");
              UI_BAR_b.update = true;
            }     

            if (menu_option.equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
              UI_BAR_b.hghlight("lfSz0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick LeafSize")) {
              UI_set_to_Modify_LeafSize(1);
              UI_BAR_b.hghlight("lfSz1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign LeafSize")) {
              UI_set_to_Modify_LeafSize(2);
              UI_BAR_b.hghlight("lfSz2");
              UI_BAR_b.update = true;
            }     

            if (menu_option.equals("Model1DsProps")) {
              UI_set_to_Modify_All_Model1DsProps(0);
              UI_BAR_b.hghlight("allFP0");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Pick Model1DsProps")) {
              UI_set_to_Modify_All_Model1DsProps(1);
              UI_BAR_b.hghlight("allFP1");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Assign Model1DsProps")) {
              UI_set_to_Modify_All_Model1DsProps(2);
              UI_BAR_b.hghlight("allFP2");
              UI_BAR_b.update = true;
            }                 

            if (menu_option.equals("Change DegreeMax")) {
              UI_set_to_Modify_DegreeMax(0);
            }    
            if (menu_option.equals("Change DegreeDif")) {
              UI_set_to_Modify_DegreeDif(0);
            }    
            if (menu_option.equals("Change DegreeMin")) {
              UI_set_to_Modify_DegreeMin(0);
            }     
            if (menu_option.equals("Change TrunkSize")) {
              UI_set_to_Modify_TrunkSize(0);
            }
            if (menu_option.equals("Change LeafSize")) {
              UI_set_to_Modify_LeafSize(0);
            }           


            if (menu_option.equals("Orthographic")) {
              UI_set_to_View_ProjectionType(0);
              UI_BAR_b.hghlight("P<>");
              UI_BAR_b.update = true;
            }           
            if (menu_option.equals("Perspective")) {
              UI_set_to_View_ProjectionType(1);
              UI_BAR_b.hghlight("P><");
              UI_BAR_b.update = true;
            }   

            if (menu_option.equals("Reverse Selection")) {
              allModel3Ds.reverse_Selection();
              WIN3D.update = true;
            }             
            if (menu_option.equals("Deselect All")) {
              allModel3Ds.deselect_All();
              WIN3D.update = true;
            } 
            if (menu_option.equals("Select All")) {
              allModel3Ds.select_All();
              WIN3D.update = true;
            }           
            if (menu_option.equals("Select Solid")) {
              current_ObjectCategory = ObjectCategory.SOLID;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }                 
            if (menu_option.equals("Select Section")) {
              current_ObjectCategory = ObjectCategory.SECTION;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }       
            if (menu_option.equals("Select Camera")) {
              current_ObjectCategory = ObjectCategory.CAMERA;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }  
            if (menu_option.equals("Select LandPoint")) {
              current_ObjectCategory = ObjectCategory.LANDPOINT;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }              
            if (menu_option.equals("Select Model1Ds")) {
              current_ObjectCategory = ObjectCategory.MODEL1D;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }  
            if (menu_option.equals("Select Model2Ds")) {
              current_ObjectCategory = ObjectCategory.MODEL2D;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Select Group")) {
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Select Face")) {
              current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Select Curve")) {
              current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Select Vertex")) {
              current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Soft Selection")) {
              allModel3Ds.convert_Vertex_to_softSelection();

              current_ObjectCategory = ObjectCategory.SOFTVERTEX;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }                 
            if (menu_option.equals("Vertex >> Group")) {
              allModel3Ds.convert_Vertices_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Face >> Group")) {
              allModel3Ds.convert_Faces_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Group >> Face")) {
              allModel3Ds.convert_allGroups_to_Faces();
              current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }    
            if (menu_option.equals("Curve >> Group")) {
              allModel3Ds.convert_Curves_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Group >> Curve")) {
              allModel3Ds.convert_allGroups_to_Curves();
              current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }            
            if (menu_option.equals("Curve >> Vertex")) {
              allModel3Ds.convert_Curves_to_Vertices();
              current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Vertex >> Curve")) {
              allModel3Ds.convert_Vertices_to_Curves();
              current_ObjectCategory = ObjectCategory.CURVE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }               
            if (menu_option.equals("Group >> Vertex")) {
              allModel3Ds.convert_allGroups_to_Vertices();
              current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }  
            if (menu_option.equals("Face >> Vertex")) {
              allModel3Ds.convert_Faces_to_Vertices();
              current_ObjectCategory = ObjectCategory.VERTEX;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Vertex >> Face")) {
              allModel3Ds.convert_Vertices_to_Faces();
              current_ObjectCategory = ObjectCategory.FACE;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }    
            if (menu_option.equals("Solid >> Group")) {
              allModel3Ds.convert_allSolids_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Group >> Solid")) {
              allModel3Ds.convert_allGroups_to_allSolids();
              current_ObjectCategory = ObjectCategory.SOLID;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }                
            if (menu_option.equals("Model2Ds >> Group")) {
              allModel3Ds.convert_allModel2Ds_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Group >> Model2Ds")) {
              allModel3Ds.convert_allGroups_to_allModel2Ds();
              current_ObjectCategory = ObjectCategory.MODEL2D;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Model1Ds >> Group")) {
              allModel3Ds.convert_allModel1Ds_to_allGroups();
              current_ObjectCategory = ObjectCategory.GROUP;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Group >> Model1Ds")) {
              allModel3Ds.convert_allGroups_to_allModel1Ds();
              current_ObjectCategory = ObjectCategory.MODEL1D;
              WIN3D.update = true;
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Click Select")) {
              UI_set_to_View_ClickSelect(0);
              UI_BAR_b.hghlight("±CS");
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Click Select+")) {
              UI_set_to_View_ClickSelect(1);
              UI_BAR_b.hghlight("+CS");
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Click Select-")) {
              UI_set_to_View_ClickSelect(2);
              UI_BAR_b.hghlight("-CS");
              UI_BAR_b.update = true;
            }            

            if (menu_option.equals("Window Select")) {
              UI_set_to_View_WindowSelect(0);
              UI_BAR_b.hghlight("±WS");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Window Select+")) {
              UI_set_to_View_WindowSelect(1);
              UI_BAR_b.hghlight("+WS");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Window Select-")) {
              UI_set_to_View_WindowSelect(2);
              UI_BAR_b.hghlight("-WS");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Select Near Selected Vertices")) {
              allModel3Ds.selectNearVertices_Selection();
              WIN3D.update = true;
            }

            if (menu_option.equals("Weld Objects Selected Vertices")) {
              allModel3Ds.weldObjectsVertices_Selection(User3D.modify_WeldTreshold);
              WIN3D.update = true;
            }            
            if (menu_option.equals("Weld Scene Selected Vertices")) {
              allModel3Ds.weldSceneVertices_Selection(User3D.modify_WeldTreshold);
              WIN3D.update = true;
            }
            if (menu_option.equals("Reposition Selected Vertices")) {
              allModel3Ds.repositionVertices_Selection();
              WIN3D.update = true;
            }          
            if (menu_option.equals("Separate Selected Vertices")) {
              allModel3Ds.separateVertices_Selection();
              WIN3D.update = true;
            }          
            if (menu_option.equals("Select All Isolated Vertices")) {
              allModel3Ds.selectIsolatedVertices_Scene();
              WIN3D.update = true;
            }             
            if (menu_option.equals("Delete All Isolated Vertices")) {
              allModel3Ds.deleteIsolatedVertices_Scene();
              WIN3D.update = true;
            }   
            if (menu_option.equals("Delete Isolated Selected Vertices")) {
              allModel3Ds.deleteIsolatedVertices_Selection();
              WIN3D.update = true;
            }              
            if (menu_option.equals("Delete All Empty Groups")) {
              allModel3Ds.deleteEmptyallGroups_Scene();
              WIN3D.update = true;
            }               
            if (menu_option.equals("Delete Selection")) {
              allModel3Ds.delete_Selection();
              WIN3D.update = true;
            }      
            if (menu_option.equals("Dettach from All Groups")) {
              allModel3Ds.dettachFromallGroups_Selection();
              WIN3D.update = true;
            }                
            if (menu_option.equals("Ungroup Selection")) {
              allModel3Ds.ungroup_Selection();
              WIN3D.update = true;
            }      
            if (menu_option.equals("Group Selection")) {
              allModel3Ds.group_Selection(1);
              WIN3D.update = true;
            }      
            if (menu_option.equals("Attach to Last Group")) {
              allModel3Ds.group_Selection(0);
              WIN3D.update = true;
            }                 
            if (menu_option.equals("Duplicate Selection (Identical)")) {
              allModel3Ds.duplicate_Selection(0);
              WIN3D.update = true;
            }      
            if (menu_option.equals("Duplicate Selection (Variation)")) {
              allModel3Ds.duplicate_Selection(1);
              WIN3D.update = true;
            } 
            if (menu_option.equals("Auto-Normal Selected Faces")) {
              allModel3Ds.autoNormalFaces_Selection();
              WIN3D.update = true;
            }
            if (menu_option.equals("Force Triangulate Selected Faces")) {
              allModel3Ds.forceTriangulateFaces_Selection();
              WIN3D.update = true;
            }            
            
            if (menu_option.equals("Insert Corner Opennings")) {
              allModel3Ds.insertCornerOpennings_Selection();
              WIN3D.update = true;
            }
            if (menu_option.equals("Insert Parallel Opennings")) {
              allModel3Ds.insertParallelOpennings_Selection();              
              WIN3D.update = true;
            }     
            if (menu_option.equals("Insert Rotated Opennings")) {
              allModel3Ds.insertRotatedOpennings_Selection();
              WIN3D.update = true;
            }       
            if (menu_option.equals("Insert Edge Opennings")) {
              allModel3Ds.insertEdgeOpennings_Selection();
              WIN3D.update = true;
            } 
            
            if (menu_option.equals("Optimize Faces")) {
              allModel3Ds.optimizeFaceSelection();
              WIN3D.update = true;
            }            
            
            if (menu_option.equals("Triangulate Faces")) {
              allModel3Ds.triangulateFaceSelection();
              WIN3D.update = true;
            }                      

            if (menu_option.equals("Tessellate Rows & Columns")) {
              allModel3Ds.tessellateRowsColumnsFaceSelection();
              WIN3D.update = true;
            }
            if (menu_option.equals("Tessellate Rectangular")) {
              allModel3Ds.tessellateRectangularFaceSelection();
              WIN3D.update = true;
            }
            if (menu_option.equals("Tessellation Triangular")) {
              allModel3Ds.tessellateTriangularFaceSelection();
              WIN3D.update = true;
            }            
            if (menu_option.equals("Extrude Face Edges")) {
              allModel3Ds.extrudeFaceEdges_Selection();
              WIN3D.update = true;
            }    
            if (menu_option.equals("Extrude Curve Edges")) {
              allModel3Ds.extrudeCurveEdges_Selection();
              WIN3D.update = true;
            }                
            if (menu_option.equals("Offset(above) Vertices")) {
              allModel3Ds.offsetVertices_Selection(0, abs(User3D.modify_OffsetAmount));
              WIN3D.update = true;
            }  
            if (menu_option.equals("Offset(below) Vertices")) {
              allModel3Ds.offsetVertices_Selection(0, -abs(User3D.modify_OffsetAmount));
              WIN3D.update = true;
            }             
            if (menu_option.equals("Offset(expand) Vertices")) {
              allModel3Ds.offsetVertices_Selection(1, -abs(User3D.modify_OffsetAmount));
              WIN3D.update = true;
            }   
            if (menu_option.equals("Offset(shrink) Vertices")) {
              allModel3Ds.offsetVertices_Selection(1, abs(User3D.modify_OffsetAmount));
              WIN3D.update = true;
            }               

            if (menu_option.equals("Reverse Visibility of All Faces")) {
              allModel3Ds.reverseVisibilityFaces_Scene();
              WIN3D.update = true;
            } 
            if (menu_option.equals("Hide All Faces")) {
              allModel3Ds.changeVisibilityFaces_Scene(0);
              WIN3D.update = true;
            }  
            if (menu_option.equals("Unhide All Faces")) {
              allModel3Ds.changeVisibilityFaces_Scene(1);
              WIN3D.update = true;
            }  
            if (menu_option.equals("Hide Selected Faces")) {
              allModel3Ds.changeVisibilityFaces_Selection(0);
              WIN3D.update = true;
            }  
            if (menu_option.equals("Unhide Selected Faces")) {
              allModel3Ds.changeVisibilityFaces_Selection(1);
              WIN3D.update = true;
            }     
            if (menu_option.equals("Isolate Selection")) {
              allModel3Ds.isolate_Selection();
              WIN3D.update = true;
            }         

            if (menu_option.equals("Flatten Selected LandPoints")) {

              userSelections.flatten_selectedLandPoints();
              WIN3D.update = true;
            }

            if (menu_option.equals("Erase All Model1Ds")) {
              allModel1Ds.delete();
              WIN3D.update = true;
            }      
    
            if (menu_option.equals("Erase All Model2Ds")) {
              allModel2Ds.delete();
              WIN3D.update = true;
            }        
    
            if (menu_option.equals("Erase All Groups")) {
              allModel3Ds.delete_allGroups();
              WIN3D.update = true;
            }
    
            if (menu_option.equals("Erase All Solids")) {
              allModel3Ds.delete_allSolids();
              WIN3D.update = true;
            }          
    
            if (menu_option.equals("Erase All Sections")) {
              allModel3Ds.delete_allSections();
              WIN3D.update = true;
            }       
    
            if (menu_option.equals("Erase All Cameras")) {
              allModel3Ds.delete_allCameras();
              WIN3D.update = true;
            }    
    
            if (menu_option.equals("Erase Faces")) {
              allModel3Ds.delete_Faces();
              WIN3D.update = true;
            }             
    
            if (menu_option.equals("Erase Curves")) {
              allModel3Ds.delete_Curves();
              WIN3D.update = true;
            }  
    
            if (menu_option.equals("Erase All ")) {
              SOLARCHVISION_delete_All();
              WIN3D.update = true;
            }  
            
        
            if (menu_option.equals("TargetRoll")) {
              UI_set_to_View_TargetRoll(0);
              UI_BAR_b.hghlight("TRL");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("TargetRollZ")) {
              UI_set_to_View_TargetRoll(1);
              UI_BAR_b.hghlight("TRLz");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("TargetRollXY")) {
              UI_set_to_View_TargetRoll(2);
              UI_BAR_b.hghlight("TRLxy");
              UI_BAR_b.update = true;
            }          
            if (menu_option.equals("CameraRoll")) {
              UI_set_to_View_CameraRoll(0);
              UI_BAR_b.hghlight("CRL");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("CameraRollZ")) {
              UI_set_to_View_CameraRoll(1);
              UI_BAR_b.hghlight("CRLz");
              UI_BAR_b.update = true;
            }                
            if (menu_option.equals("CameraRollXY")) {
              UI_set_to_View_CameraRoll(2);
              UI_BAR_b.hghlight("CRLxy");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("Orbit")) {
              UI_set_to_View_Orbit(0);
              UI_BAR_b.hghlight("OR");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("OrbitZ")) {
              UI_set_to_View_Orbit(1);
              UI_BAR_b.hghlight("ORz");
              UI_BAR_b.update = true;
            }           
            if (menu_option.equals("OrbitXY")) {
              UI_set_to_View_Orbit(2);
              UI_BAR_b.hghlight("ORxy");
              UI_BAR_b.update = true;
            }   

            if (menu_option.equals("LandOrbit")) {
              UI_set_to_View_LandOrbit(0);
              UI_BAR_b.hghlight("LNOR");
              UI_BAR_b.update = true;
            }   

            if (menu_option.equals("Pan")) {
              UI_set_to_View_Pan(0);
              UI_BAR_b.hghlight("Pan");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PanX")) {
              UI_set_to_View_Pan(1);
              UI_BAR_b.hghlight("PanX");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PanY")) {
              UI_set_to_View_Pan(2);
              UI_BAR_b.hghlight("PanY");
              UI_BAR_b.update = true;
            }          

            if (menu_option.equals("Zoom")) {
              UI_set_to_View_ZOOM(0);
              UI_BAR_b.hghlight("±ZM");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Zoom as default")) {
              UI_set_to_View_ZOOM(1);
              UI_BAR_b.hghlight("0ZM");
              UI_BAR_b.update = true;
            }


            if (menu_option.equals("TruckX")) {
              UI_set_to_View_Truck(1);
              UI_BAR_b.hghlight("DIx");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("TruckY")) {
              UI_set_to_View_Truck(2);
              UI_BAR_b.hghlight("DIy");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("TruckZ")) {
              UI_set_to_View_Truck(0);
              UI_BAR_b.hghlight("DIz");
              UI_BAR_b.update = true;
            }          
            if (menu_option.equals("DistZ")) {
              UI_set_to_View_Truck(0);
              UI_BAR_b.hghlight("±CDZ");
              UI_BAR_b.update = true;
            }     
            if (menu_option.equals("CameraDistance")) {
              UI_set_to_View_CameraDistance(0);
              UI_BAR_b.hghlight("±CDS");
              UI_BAR_b.update = true;
            }   
            if (menu_option.equals("DistMouseXY")) {
              UI_set_to_View_DistMouseXY(0);
              UI_BAR_b.hghlight("±CDM");
              UI_BAR_b.update = true;
            }  

            if (menu_option.equals("Look at origin")) {
              UI_set_to_View_LookAtOrigin(0);
              UI_BAR_b.hghlight("LAO");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Look at direction")) {
              UI_set_to_View_LookAtDirection(0);
              UI_BAR_b.hghlight("LAD");
              UI_BAR_b.update = true;
            }             
            if (menu_option.equals("Look at selection")) {
              UI_set_to_View_LookAtSelection(0);
              UI_BAR_b.hghlight("LAS");
              UI_BAR_b.update = true;
            }          
 
            
            if (menu_option.equals("3DModelSize")) {
              UI_set_to_View_3DModelSize();
              UI_BAR_b.hghlight("±SZ");
              UI_BAR_b.update = true;
            }          

            if (menu_option.equals("SkydomeSize")) {
              UI_set_to_View_SkydomeSize();
              UI_BAR_b.hghlight("±SK");
              UI_BAR_b.update = true;
            }       

            if (menu_option.equals("AllModelSize")) {
              UI_set_to_View_AllModelSize();
              UI_BAR_b.hghlight("±SA");
              UI_BAR_b.update = true;
            }     

            if (menu_option.equals("Display All Viewports")) {
              UI_set_to_Viewport(0);
              UI_BAR_b.hghlight("AllViewports");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Enlarge 3D Viewport")) {
              UI_set_to_Viewport(1);
              UI_BAR_b.hghlight("Expand3DView");
              UI_BAR_b.update = true;
            } 
            if (menu_option.equals("Enlarge Time Viewport")) {
              UI_set_to_Viewport(2);
              UI_BAR_b.hghlight("ExpandTimeView");
              UI_BAR_b.update = true;
            }              
            if (menu_option.equals("Enlarge Map Viewport")) {
              UI_set_to_Viewport(3);
              UI_BAR_b.hghlight("ExpandMapView");
              UI_BAR_b.update = true;
            }             

            if (menu_option.equals("Top")) {
              UI_set_to_View_3DViewPoint(0);
              UI_BAR_b.hghlight("Top");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Front")) {
              UI_set_to_View_3DViewPoint(1);
              UI_BAR_b.hghlight("Front");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Left")) {
              UI_set_to_View_3DViewPoint(2);
              UI_BAR_b.hghlight("Left");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Back")) {
              UI_set_to_View_3DViewPoint(3);
              UI_BAR_b.hghlight("Back");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Right")) {
              UI_set_to_View_3DViewPoint(4);
              UI_BAR_b.hghlight("Right");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("Bottom")) {
              UI_set_to_View_3DViewPoint(5);
              UI_BAR_b.hghlight("Bottom");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("S.W.")) {
              UI_set_to_View_3DViewPoint(6);
              UI_BAR_b.hghlight("S.W.");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("S.E.")) {
              UI_set_to_View_3DViewPoint(7);
              UI_BAR_b.hghlight("S.E.");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("N.E.")) {
              UI_set_to_View_3DViewPoint(8);
              UI_BAR_b.hghlight("N.E.");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("N.W.")) {
              UI_set_to_View_3DViewPoint(9);
              UI_BAR_b.hghlight("N.W.");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("PivotX:Minimum")) {
              UI_set_to_View_PivotX(-1);
              UI_BAR_b.hghlight("X<");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotX:Center")) {
              UI_set_to_View_PivotX(0);
              UI_BAR_b.hghlight("X|");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotX:Maximum")) {
              UI_set_to_View_PivotX(1);
              UI_BAR_b.hghlight("X>");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("PivotY:Minimum")) {
              UI_set_to_View_PivotY(-1);
              UI_BAR_b.hghlight("Y<");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotY:Center")) {
              UI_set_to_View_PivotY(0);
              UI_BAR_b.hghlight("Y|");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotY:Maximum")) {
              UI_set_to_View_PivotY(1);
              UI_BAR_b.hghlight("Y>");
              UI_BAR_b.update = true;
            }

            if (menu_option.equals("PivotZ:Minimum")) {
              UI_set_to_View_PivotZ(-1);
              UI_BAR_b.hghlight("Z<");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotZ:Center")) {
              UI_set_to_View_PivotZ(0);
              UI_BAR_b.hghlight("Z|");
              UI_BAR_b.update = true;
            }
            if (menu_option.equals("PivotZ:Maximum")) {
              UI_set_to_View_PivotZ(1);
              UI_BAR_b.hghlight("Z>");
              UI_BAR_b.update = true;
            }
          }
        }

        UI_BAR_a.selected_parent = -1;
        UI_BAR_a.selected_child = 0;

        image(pre_screen, 0, SOLARCHVISION_pixel_A);

        SOLARCHVISION_X_clicked = -1;
        SOLARCHVISION_Y_clicked = -1;
      } else {    

        SOLARCHVISION_X_clicked = mouseX;
        SOLARCHVISION_Y_clicked = mouseY;

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, 0, width, SOLARCHVISION_pixel_A) == 1) {
          UI_BAR_a.update = true;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B) == 1) {
          UI_BAR_b.update = true;
        }

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C) == 1) {
          UI_BAR_c.update = true;
          typeUserCommand = 1;
        }  

        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, 0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C, width, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + SOLARCHVISION_pixel_D) == 1) {
          UI_BAR_d.update = true;
        }  

        if (WORLD.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WORLD.cX, WORLD.cY, WORLD.cX + WORLD.dX, WORLD.cY + WORLD.dY) == 1) {

            float mouse_lon = 360.0 * ((mouseX - WORLD.cX) * WORLD.sX / WORLD.dX - 0.5) + WORLD.oX;
            float mouse_lat = -180.0 * ((mouseY - WORLD.cY) * WORLD.sY / WORLD.dY - 0.5) + WORLD.oY;
            //float mouse_lon = STATION.getLongitude();
            //float mouse_lat = STATION.getLatitude();


            pre_LocationLAT = LocationLAT;
            pre_LocationLON = LocationLON;

            STATION.setLatitude(mouse_lat);
            STATION.setLongitude(mouse_lon);

            if (mouseButton == LEFT) {
              WORLD.Zoom = 6;
            }

            if ((pre_LocationLAT != LocationLAT) || (pre_LocationLON != LocationLON)) {
              WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
            } 



            {
              int nearest_WORLD_NAEFS = -1;
              float nearest_WORLD_NAEFS_dist = FLOAT_undefined;

              for (int f = 0; f < NAEFposition_Ts.length; f++) {

                float _lat = NAEFposition_Ts[f].getLatitude();
                float _lon = NAEFposition_Ts[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_NAEFS_dist > d) {
                  nearest_WORLD_NAEFS_dist = d;
                  nearest_WORLD_NAEFS = f;
                }
              }

              {
                int f = nearest_WORLD_NAEFS;

                if (STATION.getFilename_NAEFS().equals(NAEFposition_Ts[f].getFilename_NAEFS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_NAEFS(NAEFposition_Ts[f].getFilename_NAEFS()); // naefs filename

                  println("nearest naefs filename:", NAEFposition_Ts[f].getFilename_NAEFS());    

                  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                    STATION.setCity(NAEFposition_Ts[f].getCity());
                    STATION.setProvince(NAEFposition_Ts[f].getProvince());
                    STATION.setCountry(NAEFposition_Ts[f].getCountry());

                    //STATION.setLatitude(NAEFposition_Ts[f].getLatitude());
                    //STATION.setLongitude(NAEFposition_Ts[f].getLongitude());
                    STATION.setElevation(NAEFposition_Ts[f].getElevation()); 
                    STATION.setTimelong(NAEFposition_Ts[f].getTimelong());                     

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;


                    SOLARCHVISION_update_station(1);
                    update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
                  }
                }
              }
            }        


            {
              int nearest_WORLD_CWEEDS = -1;
              float nearest_WORLD_CWEEDS_dist = FLOAT_undefined;

              for (int f = 0; f < CWEEDS_coordinates.length; f++) {

                float _lat = CWEEDS_coordinates[f].getLatitude();
                float _lon = CWEEDS_coordinates[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_CWEEDS_dist > d) {
                  nearest_WORLD_CWEEDS_dist = d;
                  nearest_WORLD_CWEEDS = f;
                }
              }

              {
                int f = nearest_WORLD_CWEEDS;

                if (STATION.getFilename_CWEEDS().equals(CWEEDS_coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon); 

                  STATION.setFilename_CWEEDS(CWEEDS_coordinates[f].getFilename_CWEEDS()); // CWEEDS filename

                  println("nearest CWEEDS filename:", CWEEDS_coordinates[f].getFilename_CWEEDS());       

                  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) { 

                    STATION.setCity(CWEEDS_coordinates[f].getCity());
                    STATION.setProvince(CWEEDS_coordinates[f].getProvince());
                    STATION.setCountry(CWEEDS_coordinates[f].getCountry()); 

                    //STATION.setLatitude(CWEEDS_coordinates[f].getLatitude());
                    //STATION.setLongitude(CWEEDS_coordinates[f].getLongitude());
                    STATION.setElevation(CWEEDS_coordinates[f].getElevation());
                    STATION.setTimelong(funcs.roundTo(STATION.getLongitude(), 15));   

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CWEEDS();
                  }
                }
              }
            }          

            {
              int nearest_WORLD_CLMREC = -1;
              float nearest_WORLD_CLMREC_dist = FLOAT_undefined;

              for (int f = 0; f < CLMREC_Coordinates.length; f++) {
                
                //if (int(CLMREC_Coordinates[f].getEndyear()) == 2016) 
                { // only use stations with this condition

                  float _lat = CLMREC_Coordinates[f].getLatitude();
                  float _lon = CLMREC_Coordinates[f].getLongitude(); 
                  if (_lon > 180) _lon -= 360; // << important!
  
                  float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());
  
                  if (nearest_WORLD_CLMREC_dist > d) {
                    nearest_WORLD_CLMREC_dist = d;
                    nearest_WORLD_CLMREC = f;
                  }
                }
              }

              {
                int f = nearest_WORLD_CLMREC;

                if (STATION.getFilename_CWEEDS().equals(CLMREC_Coordinates[f].getFilename_CWEEDS())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);                   

                  STATION.setFilename_CWEEDS(CLMREC_Coordinates[f].getFilename_CWEEDS()); // CLMREC filename

                  println("nearest CLMREC filename:", CLMREC_Coordinates[f].getFilename_CWEEDS());       

                  if (CurrentDataSource == dataID_CLIMATE_CLMREC) { 

                    STATION.setCity(CLMREC_Coordinates[f].getCity());
                    STATION.setProvince(CLMREC_Coordinates[f].getProvince());
                    STATION.setCountry(CLMREC_Coordinates[f].getCountry()); 

                    //STATION.setLatitude(CLMREC_Coordinates[f].getLatitude());
                    //STATION.setLongitude(CLMREC_Coordinates[f].getLongitude());
                    STATION.setElevation(CLMREC_Coordinates[f].getElevation());
                    STATION.setTimelong(CLMREC_Coordinates[f].getTimelong());   

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_CLMREC();
                  }
                }
              }
            }          


            {
              int nearest_WORLD_TMYEPW = -1;
              float nearest_WORLD_TMYEPW_dist = FLOAT_undefined;

              for (int f = 0; f < TMYEPW_Coordinates.length; f++) {

                float _lat = TMYEPW_Coordinates[f].getLatitude();
                float _lon = TMYEPW_Coordinates[f].getLongitude(); 
                if (_lon > 180) _lon -= 360; // << important!

                float d = funcs.lon_lat_dist(_lon, _lat, STATION.getLongitude(), STATION.getLatitude());

                if (nearest_WORLD_TMYEPW_dist > d) {
                  nearest_WORLD_TMYEPW_dist = d;
                  nearest_WORLD_TMYEPW = f;
                }
              }

              {
                int f = nearest_WORLD_TMYEPW;

                if (STATION.getFilename_TMYEPW().equals(TMYEPW_Coordinates[f].getFilename_TMYEPW())) {
                } else {

                  STATION.setLatitude(mouse_lat);                
                  STATION.setLongitude(mouse_lon);

                  STATION.setFilename_TMYEPW(TMYEPW_Coordinates[f].getFilename_TMYEPW()); // epw filename

                  println("nearest epw filename:", TMYEPW_Coordinates[f].getFilename_TMYEPW());       

                  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {     
                    STATION.setCity(TMYEPW_Coordinates[f].getCity());
                    STATION.setProvince(TMYEPW_Coordinates[f].getProvince());
                    STATION.setCountry(TMYEPW_Coordinates[f].getCountry()); 

                    //STATION.setLatitude(TMYEPW_Coordinates[f].getLatitude());
                    //STATION.setLongitude(TMYEPW_Coordinates[f].getLongitude());
                    STATION.setElevation(TMYEPW_Coordinates[f].getElevation());
                    STATION.setTimelong(TMYEPW_Coordinates[f].getTimelong());    

                    ROLLOUT.parent = 0;
                    ROLLOUT.child = 1;
                    ROLLOUT.update = true;

                    SOLARCHVISION_update_station(1);
                    update_CLIMATE_TMYEPW();
                  }
                }
              }
            }          




            WORLD.update = true;
          }
        }

        if (WIN3D.include) {
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, WIN3D.cX, WIN3D.cY, WIN3D.cX + WIN3D.dX, WIN3D.cY + WIN3D.dY) == 1) {

            float Image_X = 0;
            float Image_Y = 0;

            Image_X = SOLARCHVISION_X_clicked - (WIN3D.cX + 0.5 * WIN3D.dX);
            Image_Y = SOLARCHVISION_Y_clicked - (WIN3D.cY + 0.5 * WIN3D.dY);
            
            if (WIN3D.UI_CurrentTask == UITASK.LookAtDirection) { // viewport:LookAtDirection

              WIN3D.look_3DViewport_towards_Direction(Image_X, Image_Y);

              WIN3D.update = true;
            }
            else {
  
              float[] ray_direction = new float [3];
  
              float[] ray_start = {
                WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
              };
  
              float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);
  
              ray_start[0] /= OBJECTS_scale;
              ray_start[1] /= OBJECTS_scale;
              ray_start[2] /= OBJECTS_scale;          
  
              ray_end[0] /= OBJECTS_scale;
              ray_end[1] /= OBJECTS_scale;
              ray_end[2] /= OBJECTS_scale;
  
              if (WIN3D.ViewType == 0) {
                float[] ray_center = WIN3D.calculate_Click3D(0, 0);
  
                ray_center[0] /= OBJECTS_scale;
                ray_center[1] /= OBJECTS_scale;
                ray_center[2] /= OBJECTS_scale;
  
                ray_start[0] += ray_end[0] - ray_center[0];
                ray_start[1] += ray_end[1] - ray_center[1];
                ray_start[2] += ray_end[2] - ray_center[2];
              }
  
              ray_direction[0] = ray_end[0] - ray_start[0];
              ray_direction[1] = ray_end[1] - ray_start[1];
              ray_direction[2] = ray_end[2] - ray_start[2];
  
              float[] RxP = new float [8];
  
              if (mouseButton == RIGHT) {
                RxP = SOLARCHVISION_intersect_LandPoints(ray_start, ray_direction);
              } else if (mouseButton == LEFT) {

                if ((WIN3D.UI_CurrentTask == UITASK.Create) || (WIN3D.UI_CurrentTask == UITASK.Move)) {
                   RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));

                } else {
 
                  if (current_ObjectCategory == ObjectCategory.CURVE) {
                    RxP = SOLARCHVISION_intersect_Curves(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.CAMERA) {
                    RxP = allCameras.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.SECTION) {
                    RxP = allSections.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.SOLID) {
                    RxP = allSolids.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.MODEL1D) {
                    RxP = allModel1Ds.intersect(ray_start, ray_direction);
                  } else if (current_ObjectCategory == ObjectCategory.MODEL2D) {
                    RxP = allModel2Ds.intersect(ray_start, ray_direction);
                  } else {
                    RxP = SOLARCHVISION_snap_Faces(SOLARCHVISION_intersect_Faces(ray_start, ray_direction));
                  }
                }
                
                

              }
  
  
              //println(ray_start[0], ray_start[1], ray_start[2], ">>", ray_end[0], ray_end[1], ray_end[2], ">>", RxP[1], RxP[2], RxP[3], RxP[4], RxP[0]);
  
              if (RxP[0] >= 0) {
  
                if (WIN3D.UI_CurrentTask == UITASK.Move) { // move
  
                  float x1 = FLOAT_undefined;
                  float y1 = FLOAT_undefined;
                  float z1 = FLOAT_undefined;
  
                  if (current_ObjectCategory == ObjectCategory.GROUP) {
  
                    float[] P = userSelections.getPivot();
  
                    x1 = P[0];
                    y1 = P[1];
                    z1 = P[2];
                  }
  
                  if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
                    x1 = allModel2Ds.getX(userSelections.Model2D_ids[userSelections.Model2D_ids.length - 1]); 
                    y1 = allModel2Ds.getY(userSelections.Model2D_ids[userSelections.Model2D_ids.length - 1]); 
                    z1 = allModel2Ds.getZ(userSelections.Model2D_ids[userSelections.Model2D_ids.length - 1]);
                  }
  
                  if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
                    x1 = allModel1Ds.getX(userSelections.Model1D_ids[userSelections.Model1D_ids.length - 1]); 
                    y1 = allModel1Ds.getY(userSelections.Model1D_ids[userSelections.Model1D_ids.length - 1]); 
                    z1 = allModel1Ds.getZ(userSelections.Model1D_ids[userSelections.Model1D_ids.length - 1]);
                  }            
  
                  if (current_ObjectCategory == ObjectCategory.SOLID) {
  
                    x1 = allSolids.get_posX(userSelections.Solid_ids[userSelections.Solid_ids.length - 1]); 
                    y1 = allSolids.get_posY(userSelections.Solid_ids[userSelections.Solid_ids.length - 1]); 
                    z1 = allSolids.get_posZ(userSelections.Solid_ids[userSelections.Solid_ids.length - 1]);
                  }                 
  
                  if (current_ObjectCategory == ObjectCategory.VERTEX) {
  
                    x1 = allPoints.getX(userSelections.Vertex_ids[userSelections.Vertex_ids.length - 1]); 
                    y1 = allPoints.getY(userSelections.Vertex_ids[userSelections.Vertex_ids.length - 1]); 
                    z1 = allPoints.getZ(userSelections.Vertex_ids[userSelections.Vertex_ids.length - 1]);
                  }             
  
                  if ((x1 != FLOAT_undefined) && (y1 != FLOAT_undefined) && (z1 != FLOAT_undefined)) {       
  
                    float x2 = RxP[1];
                    float y2 = RxP[2];
                    float z2 = RxP[3];
  
                    float[] p = userSelections.translateOutside_ReferencePivot(x2, y2, z2);
  
                    float dx = p[0] - x1; 
                    float dy = p[1] - y1;
                    float dz = p[2] - z1;
  
                    int the_Vector = userSelections.posVector;
  
                    if (the_Vector == 0) {
                      dy = 0; 
                      dz = 0;
                    }  
                    if (the_Vector == 1) {
                      dz = 0; 
                      dx = 0;
                    }  
                    if (the_Vector == 2) {
                      dx = 0; 
                      dy = 0;
                    } 
  
                    userSelections.move_Selection(dx, dy, dz);
  
                    userSelections.calculate_selection_BoundingBox();
                    WIN3D.update = true;
                  }
                }   
  
  
  
  
                if (mouseButton == LEFT) { // modify should work only with left click because the right click returns the land info, not objects info
  
                  if ((WIN3D.UI_TaskModifyParameter != 0) && (WIN3D.UI_CurrentTask >= UITASK.Seed_Material)) { // Pick/Assign properties 
  
                    if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.FACE) || (current_ObjectCategory == ObjectCategory.CURVE)) {
  
                      int f = int(RxP[0]);
  
                      if ((WIN3D.UI_CurrentTask == UITASK.Seed_Material) || (WIN3D.UI_CurrentTask == UITASK.Tessellation) || (WIN3D.UI_CurrentTask == UITASK.Layer) || (WIN3D.UI_CurrentTask == UITASK.Visibility) || (WIN3D.UI_CurrentTask == UITASK.Weight)) {
  
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) User3D.default_Material     = allFaces.getMaterial(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  User3D.default_Tessellation = allFaces.getTessellation(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         User3D.default_Layer        = allFaces.getLayer(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    User3D.default_Visibility   = allFaces.getVisibility(f);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        User3D.default_Weight       = allFaces.getWeight(f);
                        } 
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign(sub) 
                          if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (f, User3D.default_Material);
                          if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(f, User3D.default_Tessellation);
                          if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (f, User3D.default_Layer);
                          if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (f, User3D.default_Visibility);
                          if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setWeight      (f, User3D.default_Weight);
                        }
                        if (WIN3D.UI_TaskModifyParameter == 3) { // Assign(all) 
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }

                          for (int q = allGroups.Faces[OBJ_NUM][0]; q <= allGroups.Faces[OBJ_NUM][1]; q++) {                    
                            if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) allFaces.setMaterial    (q, User3D.default_Material);
                            if (WIN3D.UI_CurrentTask == UITASK.Tessellation)  allFaces.setTessellation(q, User3D.default_Tessellation);
                            if (WIN3D.UI_CurrentTask == UITASK.Layer)         allFaces.setLayer       (q, User3D.default_Layer);
                            if (WIN3D.UI_CurrentTask == UITASK.Visibility)    allFaces.setVisibility  (q, User3D.default_Visibility);
                            if (WIN3D.UI_CurrentTask == UITASK.Weight)        allFaces.setClose       (q, User3D.default_Weight);
                          }
                        }
                      }
  
                      if (WIN3D.UI_CurrentTask == UITASK.Pivot) {
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          //?????????????????????????????????????????????????
                        }     
                        if (WIN3D.UI_TaskModifyParameter == 2) { // Assign
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }


                          float[] P = userSelections.getPivot();

                          allGroups.PivotMatrix[OBJ_NUM][0] = P[0];
                          allGroups.PivotMatrix[OBJ_NUM][1] = P[1];
                          allGroups.PivotMatrix[OBJ_NUM][2] = P[2];

                          //zzzzzzzzzzzzzzzzzzz should add other components?

                        }
                      }
  
                      if (WIN3D.UI_CurrentTask == UITASK.Normal) { //Normal
  
                        if (current_ObjectCategory == ObjectCategory.FACE) {
  
                          userSelections.Face_ids = new int [1];
                          userSelections.Face_ids[0] = f;       
  
                          userSelections.Face_displayVertexCount = true;                 
  
                          int n = allFaces.nodes[f].length;
  
                          if (n > 2) {
                            int[] tmpFace = new int[n];
                            float[] G = {
                              0, 0, 0
                            }; 
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                              G[0] += allPoints.getX(tmpFace[j]) / float(n); 
                              G[1] += allPoints.getY(tmpFace[j]) / float(n);
                              G[2] += allPoints.getZ(tmpFace[j]) / float(n);
                            }  
  
                            int flip_face = 0;
                            if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                            else {
                              PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);                       
                              PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);
  
                              PVector GAxGB = AG.cross(BG);
  
                              float[] P = userSelections.getPivot();
  
                              float x0 = P[0];
                              float y0 = P[1];
                              float z0 = P[2];                            
  
                              PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);
  
                              float V = PG.dot(GAxGB); 
  
                              if (WIN3D.UI_TaskModifyParameter == 2) {
                                if (V > 0) flip_face = 1;
                              }
                              if (WIN3D.UI_TaskModifyParameter == 3) {
                                if (V < 0) flip_face = 1;
                              }
                            }
  
                            if (flip_face == 1) {
                              for (int j = 0; j < n; j++) {
                                allFaces.nodes[f][j] = tmpFace[n - j - 1];
                              }
                            }
                          }
                        }
  
                        if (current_ObjectCategory == ObjectCategory.GROUP) {
                          int OBJ_NUM = 0;
                          for (int i = 0; i < allGroups.num; i++) {
                            if ((allGroups.Faces[i][0] <= f) && (f <= allGroups.Faces[i][1])) {
                              OBJ_NUM = i;
                              break;
                            }
                          }
     
                          for (int q = allGroups.Faces[OBJ_NUM][0]; q <= allGroups.Faces[OBJ_NUM][1]; q++) {                    
                            int n = allFaces.nodes[q].length;

                            if (n > 2) {
                              int[] tmpFace = new int[n];
                              float[] G = {
                                0, 0, 0
                              }; 
                              for (int j = 0; j < n; j++) {
                                tmpFace[j] = allFaces.nodes[q][j];
                                G[0] += allPoints.getX(tmpFace[j]) / float(n); 
                                G[1] += allPoints.getY(tmpFace[j]) / float(n);
                                G[2] += allPoints.getZ(tmpFace[j]) / float(n);
                              }  

                              int flip_face = 0;
                              if (WIN3D.UI_TaskModifyParameter == 1) flip_face = 1;
                              else {
                                PVector AG = new PVector(allPoints.getX(tmpFace[0]) - G[0], allPoints.getY(tmpFace[0]) - G[1], allPoints.getZ(tmpFace[0]) - G[2]);                       
                                PVector BG = new PVector(allPoints.getX(tmpFace[1]) - G[0], allPoints.getY(tmpFace[1]) - G[1], allPoints.getZ(tmpFace[1]) - G[2]);

                                PVector GAxGB = AG.cross(BG);

                                float[] P = userSelections.getPivot();

                                float x0 = P[0];
                                float y0 = P[1];
                                float z0 = P[2];                                

                                PVector PG = new PVector(x0 - G[0], y0 - G[1], z0 - G[2]);

                                float V = PG.dot(GAxGB); 

                                if (WIN3D.UI_TaskModifyParameter == 2) {
                                  if (V > 0) flip_face = 1;
                                }
                                if (WIN3D.UI_TaskModifyParameter == 3) {
                                  if (V < 0) flip_face = 1;
                                }
                              }

                              if (flip_face == 1) {
                                for (int j = 0; j < n; j++) {
                                  allFaces.nodes[q][j] = tmpFace[n - j - 1];
                                }
                              }
                            }
                          }

                        }
                      }   
  
  
                      if (WIN3D.UI_CurrentTask == UITASK.FirstVertex) { //FirstVertex
  
                        if (current_ObjectCategory == ObjectCategory.FACE) {
  
                          userSelections.Face_ids = new int [1];
                          userSelections.Face_ids[0] = f;
  
                          userSelections.Face_displayVertexCount = true;
  
                          int n = allFaces.nodes[f].length;
  
                          if (n > 2) {
  
                            int min_num = 0;
                            float min_dist = FLOAT_undefined;
  
                            for (int j = 0; j < n; j++) {
                              int vNo = allFaces.nodes[f][j];
  
                              float d = dist(RxP[1], RxP[2], RxP[3], allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }
  
                            int[] tmpFace = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpFace[j] = allFaces.nodes[f][j];
                            }  
  
                            for (int j = 0; j < n; j++) {
                              allFaces.nodes[f][j] = tmpFace[(j + min_num + n) % n];
                            }
                          }
                        }
                        
                        
                        if (current_ObjectCategory == ObjectCategory.CURVE) {
  
                          userSelections.Curve_ids = new int [1];
                          userSelections.Curve_ids[0] = f;
  
                          userSelections.Curve_displayVertexCount = true;
  
                          int n = allCurves.nodes[f].length;
  
                          if (n > 2) {
  
                            int min_num = 0;
                            float min_dist = FLOAT_undefined;
  
                            for (int j = 0; j < n; j++) {
                              int vNo = allCurves.nodes[f][j];
  
                              float d = dist(RxP[1], RxP[2], RxP[3], allPoints.getX(vNo), allPoints.getY(vNo), allPoints.getZ(vNo));
  
                              if (min_dist > d) {
                                min_dist = d;
                                min_num = j;
                              }
                            }
  
                            int[] tmpCurve = new int[n];
                            for (int j = 0; j < n; j++) {
                              tmpCurve[j] = allCurves.nodes[f][j];
                            }  
  
                            for (int j = 0; j < n; j++) {
                              allCurves.nodes[f][j] = tmpCurve[(j + min_num + n) % n];
                            }
                          }
                        }                      
                        
                      }
                    } 
  
  
  
  
  
  
  
  
  
  
                    if (current_ObjectCategory == ObjectCategory.MODEL2D) {
  
                      int OBJ_NUM = int(RxP[0]);
  
                      int n = allModel2Ds.MAP[OBJ_NUM];
                      int sign_n = 1;
                      if (n < 0) sign_n = -1;
                      n = abs(n);
                      int n1 = allModel2Ds.num_files_PEOPLE;
                      int n2 = allModel2Ds.num_files_PEOPLE + allModel2Ds.num_files_TREES;
  
                      if (WIN3D.UI_CurrentTask == UITASK.Seed_Material) {
  
                        if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                          if (n <= n1) { // case: people 
                            User3D.create_Person_Type = n;
                          } else { // case: trees
                            User3D.create_Plant_Type = n - n1;
                          }
                        } 
                        if ((WIN3D.UI_TaskModifyParameter == 2) || (WIN3D.UI_TaskModifyParameter == 3)) { // Assign
                          if (n <= n1) { // case: people 
                            allModel2Ds.MAP[OBJ_NUM] = sign_n * User3D.create_Person_Type;
                          } else { // case: trees
                            allModel2Ds.MAP[OBJ_NUM] = sign_n * (User3D.create_Plant_Type + n1);
                          }
                        }
                      }
                    }      
  
  
                    if (current_ObjectCategory == ObjectCategory.MODEL1D) {
  
                      int OBJ_NUM = int(RxP[0]);
  
                      if (WIN3D.UI_TaskModifyParameter == 1) { // Pick 
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) User3D.create_Model1D_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
                          User3D.create_Model1D_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM); 
                          User3D.create_Model1D_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                        }
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) User3D.create_Model1D_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) User3D.create_Model1D_TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) User3D.create_Model1D_LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
                        if (WIN3D.UI_CurrentTask == UITASK.All_Model1DsProps) { // all properties
                          User3D.create_Model1D_DegreeMax = allModel1Ds.getDegreeMax(OBJ_NUM);
                          User3D.create_Model1D_DegreeMin = allModel1Ds.getDegreeMin(OBJ_NUM);
                          User3D.create_Model1D_TrunkSize = allModel1Ds.getTrunkSize(OBJ_NUM);
                          User3D.create_Model1D_LeafSize = allModel1Ds.getLeafSize(OBJ_NUM);
                        }
                      } 
                      if (WIN3D.UI_TaskModifyParameter == 2) { //Assign
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMax) allModel1Ds.setDegreeMax(OBJ_NUM, User3D.create_Model1D_DegreeMax);                    
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeDif) {
                          allModel1Ds.setDegreeMax(OBJ_NUM, User3D.create_Model1D_DegreeMax); 
                          allModel1Ds.setDegreeMin(OBJ_NUM, User3D.create_Model1D_DegreeMin);
                        }                 
                        if (WIN3D.UI_CurrentTask == UITASK.DegreeMin) allModel1Ds.setDegreeMin(OBJ_NUM, User3D.create_Model1D_DegreeMin);                    
                        if (WIN3D.UI_CurrentTask == UITASK.TrunkSize) allModel1Ds.setTrunkSize(OBJ_NUM, User3D.create_Model1D_TrunkSize);                    
                        if (WIN3D.UI_CurrentTask == UITASK.LeafSize) allModel1Ds.setLeafSize(OBJ_NUM, User3D.create_Model1D_LeafSize);
                        if (WIN3D.UI_CurrentTask == UITASK.All_Model1DsProps) { // all properties
                          allModel1Ds.setDegreeMax(OBJ_NUM, User3D.create_Model1D_DegreeMax);
                          allModel1Ds.setDegreeMin(OBJ_NUM, User3D.create_Model1D_DegreeMin);                    
                          allModel1Ds.setTrunkSize(OBJ_NUM, User3D.create_Model1D_TrunkSize);                    
                          allModel1Ds.setLeafSize(OBJ_NUM, User3D.create_Model1D_LeafSize);
                        }
                      }
                    }                        
  
                    WIN3D.update = true;                 
                    ROLLOUT.update = true;
                  } else if ((WIN3D.UI_CurrentTask != UITASK.Create) && (WIN3D.UI_CurrentTask != UITASK.Move)) { // PickSelect also if scale, rotate, modify, etc. where selected
  
                    userSelections.selectPick(RxP);
                  }
                }
  
                if (WIN3D.UI_CurrentTask == UITASK.Create) { // create
                  
                  int keep_number_of_allGroups = allGroups.num;
                  int keep_number_of_allModel2Ds = allModel2Ds.num;
                  int keep_number_of_allModel1Ds = allModel1Ds.num;
                  int keep_number_of_allSolids = allSolids.DEF.length;
                  int keep_number_of_allSections = allSections.num;
                  int keep_number_of_allCameras = allCameras.num;
  
                  float x = RxP[1]; 
                  float y = RxP[2]; 
                  float z = RxP[3];         
              
                  float rot = User3D.create_Orientation;
                  if (rot == 360) rot = WIN3D.rotation_Z;
  
  
  
                  float rx = 0.5 * User3D.create_Length;
                  if (rx < 0) rx = random(0.25 * abs(rx), abs(rx));
  
                  float ry = 0.5 * User3D.create_Width;
                  if (ry < 0) ry = random(0.25 * abs(ry), abs(ry));
  
                  float rz = 0.5 * User3D.create_Height;
                  if (rz < 0) rz = random(0.25 * abs(rz), abs(rz));
  
  
  
                  float px = User3D.create_powX; 
                  float py = User3D.create_powY;
                  float pz = User3D.create_powZ;
  
                  if (User3D.create_powRnd == 1) {
                    px = pow(2, int(random(5)) - 1);
                    py = px;
                    pz = px;
                  }
  
                  if (User3D.create_Volume != 0) {
  
                    if ((rx != 0) && (ry != 0)) {
                      rz = User3D.create_Volume / (8 * rx * ry);
                    }
  
                    //---------------------------------------------------
                    float A = 1; 
                    // cube volume: 8*r^3, sphere volume: 4*r^3, so maybe:
                    if (pz >= 8) A = 1;
                    else if (pz == 4) A = 0.75;
                    else if (pz == 2) A = 0.5;
                    else if (pz == 1) A = 0.25;
                    else if (pz == 0.5) A = 0.125;
                    else if (pz == 0.25) A = 0.0625;
  
                    rx /= pow(A, (1.0 / 3.0));
                    ry /= pow(A, (1.0 / 3.0));
                    rz /= pow(A, (1.0 / 3.0));
                    //---------------------------------------------------
                  }
  
  
                  if ((current_ObjectCategory != ObjectCategory.MODEL1D) && (current_ObjectCategory != ObjectCategory.MODEL2D) && (current_ObjectCategory != ObjectCategory.LANDPOINT) && (current_ObjectCategory != ObjectCategory.CAMERA) && (current_ObjectCategory != ObjectCategory.SECTION)) {
  
                    x -= rx * userSelections.alignX;
                    y -= ry * userSelections.alignY;
                    z -= rz * userSelections.alignZ;
                  }
  
  
  
                  //if ((current_ObjectCategory == ObjectCategory.GROUP) || (current_ObjectCategory == ObjectCategory.SOLID) || (current_ObjectCategory == ObjectCategory.MODEL1D) || (current_ObjectCategory == ObjectCategory.MODEL2D)) {
                  if (current_ObjectCategory == ObjectCategory.GROUP) {
  
                    if (addToLastGroup == false) {
  
                      allModel3Ds.beginNewGroup(x, y, z, 1, 1, 1, 0, 0, rot);
                    }
                  }
  
  
                  if (current_ObjectCategory == ObjectCategory.GROUP) { // working with meshes
    
                    if (CreateObject == CREATE.SuperOBJ) {
    
                      if ((px == CubePower) && (py == CubePower) && (pz == 2)) {
    
                        allModel3Ds.add_ParametricSurface(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, 2, rot);
                      } else if ((px == 2) && (py == 2) && (pz == CubePower)) {
    
                        allModel3Ds.add_SuperCylinder(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, User3D.create_CylinderDegree, rot);
                      } else if ((px == CubePower) && (py == CubePower) && (pz == CubePower)) {
    
                        allModel3Ds.add_Box_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, rot);
                      } else if ((px == 1) && (py == 1) && (pz == 1)) {
    
                        allModel3Ds.add_Octahedron(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, rot);
                      } else {
    
                        allModel3Ds.add_SuperSphere(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, pz, py, pz, rx, ry, rz, User3D.create_SphereDegree, rot);
                      }
    
    
    
    
                      if (User3D.create_MeshOrSolid != 0) {
    
                        allModel3Ds.add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                      }
                    }
    
  
    
                    if (CreateObject == CREATE.Tri) {
    
                      allModel3Ds.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y-ry, z-rz, x+rx, y-ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x+rx, y-ry, z-rz, x+rx, y+ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x+rx, y+ry, z-rz, x-rx, y+ry, z-rz, x, y, z+rz);
                      allModel3Ds.add_Mesh3(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y+ry, z-rz, x-rx, y-ry, z-rz, x, y, z+rz);
                    }
    

                    if (CreateObject == CREATE.Plane) {
    
                      allModel3Ds.add_Mesh4(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x-rx, y-ry, z, x+rx, y-ry, z, x+rx, y+ry, z, x-rx, y+ry, z);
                    }
                    
                    if (CreateObject == CREATE.Poly) {
    
                      allModel3Ds.add_PolygonMesh(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, User3D.create_PolyDegree, rot);
                    }                    
                    
                    if (CreateObject == CREATE.Hyper) {
    
                      allModel3Ds.add_PolygonHyper(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, 2 * rz, User3D.create_PolyDegree, rot);
                    }
                      
    
                    if (CreateObject == CREATE.Extrude) {       
    
                      allModel3Ds.add_PolygonExtrude(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, 2 * rz, User3D.create_PolyDegree, rot);
                    }
    
                    if (CreateObject == CREATE.House1) {   
                      
                      float h = ry;  

                      allModel3Ds.add_House1_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, h, rot);
                    }

                    if (CreateObject == CREATE.House2) {   
       
                      float h = ry;   
          
                      if (ry > rx) h = rx;            
    
                      allModel3Ds.add_House2_Core(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, h, rot);
                    }
    
                    if (CreateObject == CREATE.Parametric) {
    
                      allModel3Ds.add_ParametricSurface(User3D.default_Material, User3D.default_Tessellation, User3D.default_Layer, User3D.default_Visibility, User3D.default_Weight, User3D.default_Closed, x, y, z, rx, ry, rz, User3D.create_Parametric_Type, rot);
                    }
                    
                  }
  
                  if (current_ObjectCategory == ObjectCategory.MODEL2D) { // working with object2Ds
                    if (CreateObject == CREATE.Person) {
    
                      randomSeed(millis());
                      allModel2Ds.add_single("PEOPLE", User3D.create_Person_Type, x, y, z, 2.5);
                    }
    
                    if (CreateObject == CREATE.Plant) {
                      int n = 0;
                      if (User3D.create_Plant_Type > 0) n = User3D.create_Plant_Type + allModel2Ds.num_files_PEOPLE;
    
                      randomSeed(millis());
                      allModel2Ds.add_single("TREES", n, x, y, z, 2 * rz);
                    }
                  }    
                  
                  if (current_ObjectCategory == ObjectCategory.MODEL1D) { // working with allModel1Ds
                    if (CreateObject == CREATE.allModel1Ds) {
  
                      randomSeed(millis());
                      allModel1Ds.add_single(User3D.create_Model1D_Type, x, y, z, 2 * rz, rot, User3D.create_Model1D_DegreeMin, User3D.create_Model1D_DegreeMax, User3D.create_Model1D_Seed, User3D.create_Model1D_TrunkSize, User3D.create_Model1D_LeafSize);
                    }        
                  }

                  if (current_ObjectCategory == ObjectCategory.VERTEX) { // working with vertices
                    if (CreateObject == CREATE.Vertex) {
                      allModel3Ds.add_Vertex(x, y, z);
                      
                    }
                  }    


                  if (current_ObjectCategory == ObjectCategory.FACE) { // working with faces
                    if (CreateObject == CREATE.Face) {
                      allModel3Ds.add_VertexToLastFace(x, y, z); 

                      userSelections.Face_ids = new int [1];
                      userSelections.Face_ids[0] = allFaces.nodes.length - 1;
    
                      userSelections.calculate_selection_BoundingBox();
                    }
                  }      
          
                  if (current_ObjectCategory == ObjectCategory.CURVE) { // working with curves
                    if (CreateObject == CREATE.Curve) {
                      allModel3Ds.add_VertexToLastCurve(x, y, z);                   

                      userSelections.Curve_ids = new int [1];
                      userSelections.Curve_ids[0] = allCurves.nodes.length - 1;
    
                      userSelections.calculate_selection_BoundingBox();
                    }
                  }        
                      

  
                  if (current_ObjectCategory == ObjectCategory.SOLID) { // working with solids
                    if (CreateObject == CREATE.Solid) {
                      allModel3Ds.add_Solid(x, y, z, px, py, pz, rx, ry, rz, 0, 0, rot, 1);
                    }
                  }        
  
  
                  if (current_ObjectCategory == ObjectCategory.CAMERA) { // working with cameras
                    if (CreateObject == CREATE.Camera) {              
    
                      int f = int(RxP[0]);
    
                      float keep_WIN3D_CAM_x = WIN3D.CAM_x;
                      float keep_WIN3D_CAM_y = WIN3D.CAM_y;
                      float keep_WIN3D_CAM_z = WIN3D.CAM_z;
                      float keep_WIN3D_position_X = WIN3D.position_X; 
                      float keep_WIN3D_position_Y = WIN3D.position_Y;
                      float keep_WIN3D_position_Z = WIN3D.position_Z;
                      float keep_WIN3D_position_T = WIN3D.position_T;
                      float keep_WIN3D_rotation_X = WIN3D.rotation_X; 
                      float keep_WIN3D_rotation_Y = WIN3D.rotation_Y;
                      float keep_WIN3D_rotation_Z = WIN3D.rotation_Z;
                      float keep_WIN3D_rotation_T = WIN3D.rotation_T;
                      float keep_WIN3D_Zoom = WIN3D.Zoom;
    
                      {
    
                        WIN3D.CAM_x = RxP[1];
                        WIN3D.CAM_y = RxP[2];
                        WIN3D.CAM_z = RxP[3] + EyeLevel;       
    
                        WIN3D.reverseTransform_3DViewport();
    
                        float Camera_pX = WIN3D.position_X;
                        float Camera_pY = WIN3D.position_Y;
                        float Camera_pZ = WIN3D.position_Z;
                        float Camera_pT = WIN3D.position_T;
                        float Camera_rX = WIN3D.rotation_X;
                        float Camera_rY = WIN3D.rotation_Y;
                        float Camera_rZ = WIN3D.rotation_Z;
                        float Camera_rT = WIN3D.rotation_T;
                        float Camera_ZOOM = WIN3D.Zoom;
    
                        int Camera_type = WIN3D.ViewType;
    
                        allModel3Ds.add_Camera(Camera_type, Camera_pX, Camera_pY, Camera_pZ, Camera_pT, Camera_rX, Camera_rY, Camera_rZ, Camera_rT, Camera_ZOOM);
    
                        WIN3D.update = true;
                      }  
    
                      WIN3D.CAM_x = keep_WIN3D_CAM_x;
                      WIN3D.CAM_y = keep_WIN3D_CAM_y;
                      WIN3D.CAM_z = keep_WIN3D_CAM_z;
                      WIN3D.position_X = keep_WIN3D_position_X; 
                      WIN3D.position_Y = keep_WIN3D_position_Y;
                      WIN3D.position_Z = keep_WIN3D_position_Z;
                      WIN3D.position_T = keep_WIN3D_position_T;
                      WIN3D.rotation_X = keep_WIN3D_rotation_X; 
                      WIN3D.rotation_Y = keep_WIN3D_rotation_Y;
                      WIN3D.rotation_Z = keep_WIN3D_rotation_Z;
                      WIN3D.rotation_T = keep_WIN3D_rotation_T;
                      WIN3D.Zoom = keep_WIN3D_Zoom;
                    }
                  }
                  
                  
                  if (current_ObjectCategory == ObjectCategory.SECTION) { // working with sections
                    if (CreateObject == CREATE.Section) {
    
                      int createNewSection = 0;
    
                      float Section_U_offset = allSolidImpacts.U_offset[allSolidImpacts.sectionType];
                      float Section_V_offset = allSolidImpacts.V_offset[allSolidImpacts.sectionType];
                      float Section_elevation = allSolidImpacts.elevation[allSolidImpacts.sectionType];
                      float Section_rotation = allSolidImpacts.rotation[allSolidImpacts.sectionType];
                      float Section_U_scale = allSolidImpacts.U_scale[allSolidImpacts.sectionType];
                      float Section_V_scale = allSolidImpacts.V_scale[allSolidImpacts.sectionType];
    
                      int Section_Type = allSolidImpacts.sectionType;
                      int Section_RES1 = allSolidImpacts.RES1;
                      int Section_RES2 = allSolidImpacts.RES2;  
      
                      if (mouseButton == LEFT) {   
                        
                        int f = int(RxP[0]);
                        
                        int n = allFaces.nodes[f].length;
      
                        if (n > 2) {
      
                          //float min_Alpha = 90;
                          float min_Beta = 360;
      
                          for (int j = 0; j < n; j++) {
      
                            int j_next = (j + 1) % n;
      
                            float x1 = allPoints.getX(allFaces.nodes[f][j]);
                            float y1 = allPoints.getY(allFaces.nodes[f][j]);
                            float z1 = allPoints.getZ(allFaces.nodes[f][j]);                        
      
                            float x2 = allPoints.getX(allFaces.nodes[f][j_next]);
                            float y2 = allPoints.getY(allFaces.nodes[f][j_next]);
                            float z2 = allPoints.getZ(allFaces.nodes[f][j_next]);                        
      
      
                            //float Alpha = funcs.asin_ang(z2 - z1);
                            float Beta = funcs.atan2_ang(y2 - y1, x2 - x1) + 90;
      
                            //if (min_Alpha > Alpha) min_Alpha = Alpha;                      
                            if (min_Beta > Beta) min_Beta = Beta;
                          }
      
                          //println("min_Alpha", min_Alpha);
      
                          float[][] tmpVertices = new float[n][3];
      
      
                          for (int j = 0; j < n; j++) {
      
                            float x1 = allPoints.getX(allFaces.nodes[f][j]);
                            float y1 = allPoints.getY(allFaces.nodes[f][j]);
                            float z1 = allPoints.getZ(allFaces.nodes[f][j]);
      
                            float x2 = x1 * funcs.cos_ang(-min_Beta) - y1 * funcs.sin_ang(-min_Beta);
                            float y2 = x1 * funcs.sin_ang(-min_Beta) + y1 * funcs.cos_ang(-min_Beta);
                            float z2 = z1;
      
                            tmpVertices[j][0] = x2;
                            tmpVertices[j][1] = y2;
                            tmpVertices[j][2] = z2;
                          }    
      
                          float min_x = FLOAT_undefined;
                          float max_x = -FLOAT_undefined;
                          float min_y = FLOAT_undefined;
                          float max_y = -FLOAT_undefined;
                          float min_z = FLOAT_undefined;
                          float max_z = -FLOAT_undefined;
      
                          float[] G = {
                            0, 0, 0
                          }; 
                          for (int j = 0; j < n; j++) {
                            float the_x = tmpVertices[j][0];
                            float the_y = tmpVertices[j][1];
                            float the_z = tmpVertices[j][2];
      
                            G[0] += the_x / float(n); 
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);
      
                            if (min_x > the_x) min_x = the_x; 
                            if (max_x < the_x) max_x = the_x; 
                            if (min_y > the_y) min_y = the_y; 
                            if (max_y < the_y) max_y = the_y; 
                            if (min_z > the_z) min_z = the_z; 
                            if (max_z < the_z) max_z = the_z;
                          }
      
    
    
                          if ((max_z - min_z < max_x - min_x) && (max_z - min_z < max_y - min_y)) {
                            Section_Type = 1;
      
                            Section_U_scale = max_x - min_x; 
                            Section_V_scale = max_y - min_y;
      
                            Section_U_offset = G[0];
                            Section_V_offset = G[1];
      
                            Section_elevation = G[2];
      
                            Section_rotation = min_Beta;
                          } else {
                            Section_Type = 2;
      
                            Section_U_scale = max_y - min_y;
                            Section_V_scale = max_z - min_z; 
      
                            Section_U_offset = -G[1];
                            Section_V_offset = G[2];        
      
                            Section_elevation = -G[0];
      
                            Section_rotation = 90 - min_Beta;
                          }       
      
      
                          // recalculating G...  
                          G[0] = 0;             
                          G[1] = 0;
                          G[2] = 0;
                          for (int j = 0; j < n; j++) {
                            float the_x = allPoints.getX(allFaces.nodes[f][j]);
                            float the_y = allPoints.getY(allFaces.nodes[f][j]);
                            float the_z = allPoints.getZ(allFaces.nodes[f][j]);
      
                            G[0] += the_x / float(n); 
                            G[1] += the_y / float(n);
                            G[2] += the_z / float(n);
                          }
      
                          PVector AG = new PVector(allPoints.getX(allFaces.nodes[f][0]) - G[0], allPoints.getY(allFaces.nodes[f][0]) - G[1], allPoints.getZ(allFaces.nodes[f][0]) - G[2]);                       
                          PVector BG = new PVector(allPoints.getX(allFaces.nodes[f][1]) - G[0], allPoints.getY(allFaces.nodes[f][1]) - G[1], allPoints.getZ(allFaces.nodes[f][1]) - G[2]);
      
                          PVector GAxGB = AG.cross(BG);
      
                          float[][] ImageVertex = allSections.getCorners(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
      
                          float[] SectionCorner_A = ImageVertex[1];
                          float[] SectionCorner_B = ImageVertex[2];
                          float[] SectionCorner_C = ImageVertex[3];
                          float[] SectionCorner_D = ImageVertex[4]; 
      
                          float[] ImageCenter = {
                            0, 0, 0
                          };
                          for (int j = 0; j < 3; j++) {
                            ImageCenter[j] = 0.25 * (SectionCorner_A[j] + SectionCorner_B[j] + SectionCorner_C[j] + SectionCorner_D[j]);
                          }  
      
                          PVector AG_other = new PVector(SectionCorner_A[0] - ImageCenter[0], SectionCorner_A[1] - ImageCenter[1], SectionCorner_A[2] - ImageCenter[2]);                       
                          PVector BG_other = new PVector(SectionCorner_B[0] - ImageCenter[0], SectionCorner_B[1] - ImageCenter[1], SectionCorner_B[2] - ImageCenter[2]);
      
                          PVector GAxGB_other = AG_other.cross(BG_other);
      
                          //println("GAxGB", GAxGB);
                          //println("GAxGB_other", GAxGB_other);
      
                          float V = GAxGB_other.dot(GAxGB);
      
                          //println("V", nf(V, 0, 6));                        
      
                          if (V < 0) {
                            println("flip face!");
      
                            Section_rotation = 180 + Section_rotation;
                            Section_elevation *= -1;
                            Section_U_offset *= -1;
                          } else {
                            println("face OK!");
                          }
                          
                          createNewSection = 1;
      
                        }
                      }
                      
                      if (mouseButton == RIGHT) {   
    
                        Section_Type = 1;
    
                        Section_U_offset = RxP[1];
                        Section_V_offset = RxP[2];
                        Section_elevation = RxP[3];
    
    
                        createNewSection = 1;
                      }
                      
                      if (createNewSection != 0) {
      
                        allModel3Ds.add_Section(Section_Type, Section_U_offset, Section_V_offset, Section_elevation, Section_rotation, Section_U_scale, Section_V_scale, Section_RES1, Section_RES2);
    
                        if (keep_number_of_allSections != allSections.num) { // if any Section created during the process
    
                          userSelections.Section_ids = new int [0];
    
                          for (int o = keep_number_of_allSections; o < allSections.num; o++) {
    
                            int[] newlyAddedSection = {o};
    
                            userSelections.Section_ids = concat(userSelections.Section_ids, newlyAddedSection);
                          }  
    
                          userSelections.calculate_selection_BoundingBox();
                        }      
    
                        allSolidImpacts.U_offset[allSolidImpacts.sectionType] = Section_U_offset;
                        allSolidImpacts.V_offset[allSolidImpacts.sectionType] = Section_V_offset;
                        allSolidImpacts.elevation[allSolidImpacts.sectionType] = Section_elevation;
                        allSolidImpacts.rotation[allSolidImpacts.sectionType] = Section_rotation;
                        allSolidImpacts.U_scale[allSolidImpacts.sectionType] = Section_U_scale;
                        allSolidImpacts.V_scale[allSolidImpacts.sectionType] = Section_V_scale;
    
                        allSolidImpacts.sectionType = Section_Type;
                        allSolidImpacts.RES1 = Section_RES1;
                        allSolidImpacts.RES2 = Section_RES2;    
    
                        allSolidImpacts.calculate_Impact_selectedSections();
    
                        allSolarImpacts.sectionType = Section_Type;          
    
                        WIN3D.update = true; 
                        ROLLOUT.update = true;
    
                      }                  
                    }
                  }
  
  

  
                  if (keep_number_of_allSolids != allSolids.DEF.length) { // if any Solid created during the process
  
                    userSelections.Solid_ids = new int [0];
  
                    for (int o = keep_number_of_allSolids; o < allSolids.DEF.length; o++) {
  
                      int[] newlyAddedSolid = {o};
  
                      userSelections.Solid_ids = concat(userSelections.Solid_ids, newlyAddedSolid);
                    }  
  
                    userSelections.calculate_selection_BoundingBox();
                  }   
  
  
  
                  if (keep_number_of_allCameras != allCameras.num) { // if any Camera created during the process
  
                    userSelections.Camera_ids = new int [0];
  
                    for (int o = keep_number_of_allCameras; o < allCameras.num; o++) {
  
                      int[] newlyAddedCamera = {o};
  
                      userSelections.Camera_ids = concat(userSelections.Camera_ids, newlyAddedCamera);
                    }  
  
                    userSelections.calculate_selection_BoundingBox();
                  }                   
  
  
                  if (keep_number_of_allGroups != allGroups.num) { // if any Group created during the process
  
                    userSelections.Group_ids = new int [0];
  
                    for (int o = keep_number_of_allGroups; o < allGroups.num; o++) {
  
                      int[] newlyAddedGroup = {o};
  
                      userSelections.Group_ids = concat(userSelections.Group_ids, newlyAddedGroup);
                    }  
  
                    userSelections.calculate_selection_BoundingBox();
                  }   
  
                  if (keep_number_of_allModel2Ds != allModel2Ds.num) { // if any allModel2Ds created during the process
  
                    userSelections.Model2D_ids = new int [0];
  
                    for (int o = keep_number_of_allModel2Ds; o < allModel2Ds.num; o++) {
  
                      int[] newlyAddedallModel2Ds = {o};
  
                      userSelections.Model2D_ids = concat(userSelections.Model2D_ids, newlyAddedallModel2Ds);
                    }  
  
                    userSelections.calculate_selection_BoundingBox();
                  }   
  
  
                  if (keep_number_of_allModel1Ds != allModel1Ds.num) { // if any allModel1Ds created during the process
  
                    userSelections.Model1D_ids = new int [0];
  
                    for (int o = keep_number_of_allModel1Ds; o < allModel1Ds.num; o++) {
  
                      int[] newlyAddedallModel1Ds = {o};
  
                      userSelections.Model1D_ids = concat(userSelections.Model1D_ids, newlyAddedallModel1Ds);
                    }  
  
                    userSelections.calculate_selection_BoundingBox();
                  }
                  
          
                  
                  
                }
              }          
  
              WIN3D.update = true;
            }
          }
        }

        ROLLOUT.update = true;

        redraw();
      }
    }
  }
}

int isInside (float x, float y, float x1, float y1, float x2, float y2) {
  if ((x1 < x) && (x < x2) && (y1 < y) && (y < y2)) return 1;
  else return 0;
} 















//---------------------------------------------------------------------


void SOLARCHVISION_download_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {

  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR;

/*
  String the_directory = getGrib2Folder(GRIB2_DomainSelection);
  {  
    String[] tmpMessage = {
      nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
    };
    saveStrings(the_directory + "/TempEmpty.txt", tmpMessage);
  }


  for (int h = 0; h < GRIB2_TGL_number; h++) {

    if (GRIB2_TGL_Selected[h] != 0) {

      for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
        GRIB2_Layer = l;

        for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
          GRIB2_Hour = k;

          boolean new_files_downloaded = false;

          String the_link = "";

          String the_filename = getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);

          String the_target = the_directory + "/" + the_filename;
          
          File dir = new File(the_target);
          if (!dir.isFile()) {

            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDWPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("HRDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("RDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }          
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GDPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("REPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }
            if (GRIB2_Domains[GRIB2_DomainSelection][0].equals("GEPS")) {
              the_link = "http://dd.weatheroffice.ec.gc.ca/" + GRIB2_Domains[GRIB2_DomainSelection][1] + "/" + nf(GRIB2_ModelRun, 2) + "/" + nf(GRIB2_Hour, 3) + "/" + the_filename;
            }


            println("Try downloading: " + the_link);
        
            try {
              saveBytes(the_target, loadBytes(the_link));
            } 
            catch (Exception e) {
              println("LINK NOT AVAILABLE:", the_link);
            }

          }

        }
      }
    }
  }
*/
}




void SOLARCHVISION_load_AERIAL (int begin_YEAR, int begin_MONTH, int begin_DAY, int begin_HOUR) {


  GRIB2_Year = begin_YEAR;
  GRIB2_Month = begin_MONTH;
  GRIB2_Day = begin_DAY;
  GRIB2_ModelRun = begin_HOUR; 

/*


  AERIAL_Data = new float [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Flags = new int [49][numberOfLayers][AERIAL_num][GRIB2_maxScenarios];
  AERIAL_Locations = new float [AERIAL_num][3]; // lon, lat, tgl
  AERIAL_Center_Longitude = STATION.getLongitude();
  AERIAL_Center_Latitude = STATION.getLatitude();

  for (int h = 0; h < GRIB2_TGL_number; h++) {
    GRIB2_TGL_Selected[h] = 0; // deselect all layers first.
  }

  for (int n = 0; n < AERIAL_num; n++) {
    for (int k = 0; k <= 48; k++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int o = 0; o < GRIB2_maxScenarios; o++) {   
          AERIAL_Data[k][l][n][o] = FLOAT_undefined;
          AERIAL_Flags[k][l][n][o] = -1;
        }
      }
    }  


    float stp_lat = 20.0 / 2224.5968; // equals to 1km <<<<<<<<
    float stp_lon = stp_lat / funcs.cos_ang(AERIAL_Center_Latitude); 


    float r1 = float(GRIB2_Domains[GRIB2_DomainSelection][5]);
    float r = 0; 
    float t = 0; 

    int p = n / (1 + 6 + 12);
    int q = n % (1 + 6 + 12);

    if ((q > 0) && (q <= 6)) {
      r = 1 * r1;
      t = 360 * q / 6.0;
    }  

    if ((q > 6) && (q <= 18)) {
      r = 2 * r1;
      t = 360 * (q - 6) / 12.0;
    }  

    if ((q > 18) && (q <= 36)) {
      r = 3 * r1;
      t = 360 * (q - 18) / 18.0;
    }  

    float _tgl = 40 * p;

    if (_tgl == 0) _tgl = 10; // <<<<<<  

    AERIAL_Locations[n][0] = AERIAL_Center_Longitude + stp_lon * r * funcs.cos_ang(t);
    AERIAL_Locations[n][1] = AERIAL_Center_Latitude + stp_lat * r * funcs.sin_ang(t);
    AERIAL_Locations[n][2] = _tgl;

    GRIB2_TGL_Selected[p] = 1;
  }  
    
    
  
  
  if (ENSEMBLE_FORECAST_load) {
  
    String the_directory = getGrib2Folder(GRIB2_DomainSelection);
    {  
      String[] tmpMessage = {
        nf(GRIB2_Year, 4), nf(GRIB2_Month, 2), nf(GRIB2_Day, 2), nf(GRIB2_ModelRun, 2)
      };
      saveStrings(Folder_Wgrib2Temp + "/TempEmpty.txt", tmpMessage);
    }
  
  
    for (int h = 0; h < GRIB2_TGL_number; h++) {
  
      if (GRIB2_TGL_Selected[h] != 0) {
  
        for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
          GRIB2_Layer = l;
  
          for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
            GRIB2_Hour = k;
  
            boolean new_files_downloaded = false;
  
            String the_link = "";
  
            String the_target = the_directory + "/" + getGrib2Filename(GRIB2_Hour, GRIB2_Layer, h);
            
            File dir = new File(the_target);
            if (dir.isFile()) {
  
              float[][] Points = {
                {
                  0, 0, 0
                }
              };
  
              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(funcs.roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
  
                if (p == h) {
  
                  float[][] newPoint = {
                    {
                      AERIAL_Locations[n][0], AERIAL_Locations[n][1], AERIAL_Locations[n][2]
                    }
                  };
                  Points = (float[][]) concat(Points, newPoint);
  
                }
              }
  
  
              float[][] GRIB2_values = getGrib2Value_MultiplePoints(GRIB2_Hour, GRIB2_Layer, h, Points, the_link);
  
              int nPoint = 0;
  
              for (int n = 0; n < AERIAL_num; n++) {
                int p = int(funcs.roundTo(AERIAL_Locations[n][2] / 40.0, 1)); 
  
                if (p == h) {
  
                  nPoint += 1;
  
                  for (int o = 0; o < GRIB2_maxScenarios; o++) {
                    AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o] = GRIB2_values[nPoint][o];
                  }
                }
              }
            }
          }
        }
      }
    }
  
  

  
  
  
  
    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;
  
      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;
  
        for (int n = 0; n < AERIAL_num; n++) {
          for (int o = 0; o < GRIB2_maxScenarios; o++) {
            if (is_undefined_FLOAT(AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]) == false) {
              AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = 1;
            } else AERIAL_Flags[GRIB2_Hour][GRIB2_Layer][n][o] = -1;
          }
        }
      }
    }

    for (int l = GRIB2_Layer_Start; l <= GRIB2_Layer_End; l += GRIB2_Layer_Step) {
      GRIB2_Layer = l;
  
      for (int k = GRIB2_Hour_Start; k <= GRIB2_Hour_End; k += GRIB2_Hour_Step) {
        GRIB2_Hour = k;
  
        for (int n = 0; n < 1; n++) { // <<<<<<<<<<<<<<<< For now: only the first point (i.e. the center)
          for (int o = 0; o < GRIB2_maxScenarios; o++) {  
  
            int THE_YEAR = GRIB2_Year;
            int THE_MONTH = GRIB2_Month;
            int THE_DAY = GRIB2_Day;
            int THE_HOUR = GRIB2_ModelRun;
  
            int now_i = int(THE_HOUR);
            int now_j = TIME.convert2Date(THE_MONTH, THE_DAY);
  
            now_i -= int(-STATION.getTimelong() / 15);
            if (now_i < 0) {
              now_i += 24;
              now_j -= 1;
              if (now_j < 0) {
                now_j += 365;
              }
            }          
  
            int next_i = now_i + k;
            int next_j = now_j;
            if (next_i >= 24) {
  
              next_j += int(next_i / 24);
              if (next_j >= 365) {
                next_j = next_j % 365;
              }
  
              next_i = next_i % 24;
            }
  
  
            ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o] = AERIAL_Data[GRIB2_Hour][GRIB2_Layer][n][o]; // <<<<<<<<<<< writing after member 43
  
            println(GRIB2_Domains[GRIB2_DomainSelection][0] + "[" + nf(o, 0) + "]:", ENSEMBLE_FORECAST_values[next_i][next_j][l][43 + o]);          
            println("GDPS:", ENSEMBLE_FORECAST_values[next_i][next_j][l][21]);
          }
        }
      }
    }


    SOLARCHVISION_setDataFlags(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_fillGaps(dataID_ENSEMBLE_FORECAST);
    if (CLIMATIC_SolarForecast == 1) {
      SOLARCHVISION_postProcess_climaticSolarForecast();
    }
    else {
      SOLARCHVISION_postProcess_solarsUsingCloud(dataID_ENSEMBLE_FORECAST);
    }
    SOLARCHVISION_postProcess_solarEffects(dataID_ENSEMBLE_FORECAST);
    SOLARCHVISION_postProcess_developDATA(dataID_ENSEMBLE_FORECAST);
    
    WORLD.displayAll_NAEFS = 1;
    WORLD.displayNear_NAEFS = true;     
  }
  
  WORLD.update = true;
  WIN3D.update = true;  
  STUDY.update = true;
  ROLLOUT.update = true;
  UI_BAR_d.update = true;    
  
  SampleMember_Start = 44; //ENSEMBLE_FORECAST_start;
  SampleMember_End = ENSEMBLE_FORECAST_end;
  
  */
}















void SOLARCHVISION_draw_Perspective_Internally () {

  if (current_ObjectCategory == ObjectCategory.LANDPOINT) {    

    if (userSelections.LandPoint_displayPoints) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = userSelections.LandPoint_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = userSelections.LandPoint_ids[o];


        int i = OBJ_NUM / Land3D.num_columns;
        int j = OBJ_NUM % Land3D.num_columns;

        float x = Land3D.Mesh[i][j][0] * OBJECTS_scale;
        float y = Land3D.Mesh[i][j][1] * OBJECTS_scale;
        float z = -Land3D.Mesh[i][j][2] * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }

      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (current_ObjectCategory == ObjectCategory.CAMERA) {

    if (userSelections.Camera_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = userSelections.Camera_ids.length - 1; o >= 0; o--) {

          int f = userSelections.Camera_ids[o];

          beginShape();

          for (int j = 0; j < allCameras.Faces[f].length; j++) {

            int vNo = allCameras.Faces[f][j];

            float x = allCameras.Vertices[vNo][0] * OBJECTS_scale;
            float y = allCameras.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allCameras.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    

  if (current_ObjectCategory == ObjectCategory.SECTION) {

    if (userSelections.Section_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = userSelections.Section_ids.length - 1; o >= 0; o--) {

          int f = userSelections.Section_ids[o];

          beginShape();

          for (int j = 0; j < allSections.Faces[f].length; j++) {

            int vNo = allSections.Faces[f][j];

            float x = allSections.Vertices[vNo][0] * OBJECTS_scale;
            float y = allSections.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allSections.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  

  if (current_ObjectCategory == ObjectCategory.SOLID) {

    if (userSelections.Solid_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = userSelections.Solid_ids.length - 1; o >= 0; o--) {

          int OBJ_NUM = userSelections.Solid_ids[o];

          for (int plane_type = 0; plane_type < allSolids.num_visualFaces; plane_type++) {          

            int f = OBJ_NUM * allSolids.num_visualFaces + plane_type; 

            beginShape();

            for (int j = 0; j < allSolids.Faces[f].length; j++) {

              int vNo = allSolids.Faces[f][j];

              float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
              float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

      }


      strokeWeight(0);   

      popMatrix();
    }
  }  
  
  if (current_ObjectCategory == ObjectCategory.MODEL2D) {

    if (userSelections.Model2D_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = userSelections.Model2D_ids.length - 1; o >= 0; o--) {

          int OBJ_NUM = userSelections.Model2D_ids[o];

          for (int plane_type = 0; plane_type < allModel2Ds.num_visualFaces; plane_type++) {          

            int f = OBJ_NUM * allModel2Ds.num_visualFaces + plane_type; 

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }    

  if (current_ObjectCategory == ObjectCategory.MODEL1D) {

    if (userSelections.Model1D_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0); 
      strokeWeight(2);

      {
        for (int o = userSelections.Model1D_ids.length - 1; o >= 0; o--) {

          int f = userSelections.Model1D_ids[o];

          beginShape();

          for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

            int vNo = allModel1Ds.Faces[f][j];

            float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
            float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
            float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);

        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }

  if (current_ObjectCategory == ObjectCategory.FACE) {    

    if (userSelections.Face_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(127, 0, 255); 
      strokeWeight(2);

      for (int o = userSelections.Face_ids.length - 1; o >= 0; o--) {

        int f = userSelections.Face_ids[o];

        int Tessellation = allFaces.getTessellation(f);

        int TotalSubNo = 1;  
        if (allFaces.getMaterial(f) == 0) {
          Tessellation += allFaces.displayTessellation;
        }
        if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));

        float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];
          base_Vertices[j][0] = allPoints.getX(vNo);
          base_Vertices[j][1] = allPoints.getY(vNo);
          base_Vertices[j][2] = allPoints.getZ(vNo);
        }

        for (int n = 0; n < TotalSubNo; n++) {

          float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);

          beginShape();

          for (int s = 0; s < subFace.length; s++) {

            float x = subFace[s][0] * OBJECTS_scale;
            float y = subFace[s][1] * OBJECTS_scale;            
            float z = -subFace[s][2] * OBJECTS_scale;

            float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

            if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
              if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
            }
          }

          endShape(CLOSE);
        }

      }

      strokeWeight(0);   

      popMatrix();
    }


    if (userSelections.Face_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      fill(0);

      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = userSelections.Face_ids.length - 1; o >= 0; o--) {

        int f = userSelections.Face_ids[o];

        for (int j = 0; j < allFaces.nodes[f].length; j++) {
          int vNo = allFaces.nodes[f][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;            
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }
  
  
  if (current_ObjectCategory == ObjectCategory.CURVE) {    

    if (userSelections.Curve_displayVertexCount) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      fill(0);

      stroke(0); 
      strokeWeight(0);

      textSize(1.5 * MessageSize);
      textAlign(CENTER, BOTTOM);

      for (int o = userSelections.Curve_ids.length - 1; o >= 0; o--) {

        int f = userSelections.Curve_ids[o];

        for (int j = 0; j < allCurves.nodes[f].length; j++) {
          int vNo = allCurves.nodes[f][j];

          float x = allPoints.getX(vNo) * OBJECTS_scale;
          float y = allPoints.getY(vNo) * OBJECTS_scale;            
          float z = -allPoints.getZ(vNo) * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              text(nf(j + 1, 0), Image_XYZ[0], Image_XYZ[1]);
            }
          }
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }


  if (current_ObjectCategory == ObjectCategory.VERTEX) {    

    if (userSelections.Vertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 0, 255, 127);

      strokeWeight(2);

      ellipseMode(CENTER);

      float R = 10;

      for (int o = userSelections.Vertex_ids.length - 1; o >= 0; o--) {

        int vNo = userSelections.Vertex_ids[o];

        float x = allPoints.getX(vNo) * OBJECTS_scale;
        float y = allPoints.getY(vNo) * OBJECTS_scale;
        float z = -allPoints.getZ(vNo) * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
        }
      }

      strokeWeight(0);   

      popMatrix();
    }
  }  



  if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {    

    if (userSelections.Vertex_displayVertices) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      strokeWeight(0);

      ellipseMode(CENTER);

      float R = 5;

      for (int q = 0; q < userSelections.Vertex_softSelectionVertices.length; q++) {

        int vNo = userSelections.Vertex_softSelectionVertices[q];

        float _u = userSelections.Vertex_softSelectionValues[q];    

        float x = allPoints.getX(vNo) * OBJECTS_scale;
        float y = allPoints.getY(vNo) * OBJECTS_scale;
        float z = -allPoints.getZ(vNo) * OBJECTS_scale;

        float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

        if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
          if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX + R, -0.5 * WIN3D.dY + R, 0.5 * WIN3D.dX - R, 0.5 * WIN3D.dY - R) == 1) {

            float[] COL = PAINT.getColorStyle(14, _u); // <<<<<<<<<<<<<<<<<
            fill(COL[1], COL[2], COL[3], COL[0]);
            stroke(COL[1], COL[2], COL[3], COL[0]); 

            ellipse(Image_XYZ[0], Image_XYZ[1], R, R);
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }
  }    



  if (current_ObjectCategory == ObjectCategory.GROUP) {    

    if (userSelections.Group_displayEdges) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(127); 
      strokeWeight(2);

      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = userSelections.Group_ids[o];


        for (int f = allGroups.Faces[OBJ_NUM][0]; f <= allGroups.Faces[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allFaces.nodes.length)) { 

            int Tessellation = allFaces.getTessellation(f);

            int TotalSubNo = 1;  
            if (allFaces.getMaterial(f) == 0) {
              Tessellation += allFaces.displayTessellation;
            }
            if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));

            float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
            for (int j = 0; j < allFaces.nodes[f].length; j++) {
              int vNo = allFaces.nodes[f][j];
              base_Vertices[j][0] = allPoints.getX(vNo);
              base_Vertices[j][1] = allPoints.getY(vNo);
              base_Vertices[j][2] = allPoints.getZ(vNo);
            }

            for (int n = 0; n < TotalSubNo; n++) {

              float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);

              beginShape();

              for (int s = 0; s < subFace.length; s++) {

                float x = subFace[s][0] * OBJECTS_scale;
                float y = subFace[s][1] * OBJECTS_scale;            
                float z = -subFace[s][2] * OBJECTS_scale;

                float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

                if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                  if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                }
              }

              endShape(CLOSE);
            }
          }
        }


        for (int f = allGroups.Curves[OBJ_NUM][0]; f <= allGroups.Curves[OBJ_NUM][1]; f++) {
          if ((0 <= f) && (f < allCurves.nodes.length)) { 

            beginShape();

            for (int vNo = 0; vNo < allCurves.nodes[f].length; vNo++) {

              float x = allPoints.getX(vNo) * OBJECTS_scale;
              float y = allPoints.getY(vNo) * OBJECTS_scale;            
              float z = -allPoints.getZ(vNo) * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }
        

        for (int f = allGroups.Model1Ds[OBJ_NUM][0]; f <= allGroups.Model1Ds[OBJ_NUM][1]; f++) {

          if ((0 <= f) && (f < allModel1Ds.Faces.length)) { 

            beginShape();

            for (int j = 0; j < allModel1Ds.Faces[f].length; j++) {

              int vNo = allModel1Ds.Faces[f][j];

              float x = allModel1Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel1Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel1Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }


        for (int f = allGroups.Model2Ds[OBJ_NUM][0]; f <= allGroups.Model2Ds[OBJ_NUM][1]; f++) {

          if ((0 <= f) && (f < allModel2Ds.Faces.length)) { 

            beginShape();

            for (int j = 0; j < allModel2Ds.Faces[f].length; j++) {

              int vNo = allModel2Ds.Faces[f][j];

              float x = allModel2Ds.Vertices[vNo][0] * OBJECTS_scale;
              float y = allModel2Ds.Vertices[vNo][1] * OBJECTS_scale;
              float z = -allModel2Ds.Vertices[vNo][2] * OBJECTS_scale;

              float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

              if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
              }
            }

            endShape(CLOSE);
          }
        }

        for (int q = allGroups.Solids[OBJ_NUM][0]; q <= allGroups.Solids[OBJ_NUM][1]; q++) {

          if ((0 < q) && (q < allSolids.Faces.length)) {

            for (int plane_type = 0; plane_type < allSolids.num_visualFaces; plane_type++) {          

              int f = (q - 1) * allSolids.num_visualFaces + plane_type + 1; 

              if ((0 <= f) && (f < allSolids.Faces.length)) {               

                beginShape();

                for (int j = 0; j < allSolids.Faces[f].length; j++) {

                  int vNo = allSolids.Faces[f][j];

                  float x = allSolids.Vertices[vNo][0] * OBJECTS_scale;
                  float y = allSolids.Vertices[vNo][1] * OBJECTS_scale;
                  float z = -allSolids.Vertices[vNo][2] * OBJECTS_scale;

                  float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

                  if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
                    if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
                  }
                }

                endShape(CLOSE);
              }
            }
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }


    if (userSelections.Group_displayBox) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(0, 127, 0, 127);
      strokeWeight(2);

      int keep_selection_alignX = userSelections.alignX;
      int keep_selection_alignY = userSelections.alignY;
      int keep_selection_alignZ = userSelections.alignZ;

      userSelections.alignX = 0; // apply the centre
      userSelections.alignY = 0; // apply the centre
      userSelections.alignZ = 0; // apply the centre

      float[] P = userSelections.getPivot();

      float posX = P[0];
      float posY = P[1];
      float posZ = P[2];

      float posX_min = userSelections.BoundingBox[0][0];
      float posY_min = userSelections.BoundingBox[0][1];
      float posZ_min = userSelections.BoundingBox[0][2];

      float posX_max = userSelections.BoundingBox[2][0];
      float posY_max = userSelections.BoundingBox[2][1];
      float posZ_max = userSelections.BoundingBox[2][2];

      float[][] BoundingBox_Vertices = {
        {
          posX_min, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_min, posZ_min
        }
        , 
        {
          posX_max, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_max, posZ_min
        }
        , 
        {
          posX_min, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_min, posZ_max
        }
        , 
        {
          posX_max, posY_max, posZ_max
        }
        , 
        {
          posX_min, posY_max, posZ_max
        }
      }; 


      for (int i = 0; i < BoundingBox_Vertices.length; i++) {

        float x = BoundingBox_Vertices[i][0] - posX;
        float y = BoundingBox_Vertices[i][1] - posY;
        float z = BoundingBox_Vertices[i][2] - posZ;

        float[] A = userSelections.translateInside_ReferencePivot(x, y, z);

        x = A[0];
        y = A[1];
        z = A[2]; 

        BoundingBox_Vertices[i][0] = x;
        BoundingBox_Vertices[i][1] = y;
        BoundingBox_Vertices[i][2] = z;
      }                                     

      int[][] BoundingBox_Faces = {
        {
          3, 2, 1, 0
        }
        , {
          0, 1, 5, 4
        }
        , {
          1, 2, 6, 5
        }
        , {
          2, 3, 7, 6
        }
        , {
          3, 0, 4, 7
        }
        , {
          4, 5, 6, 7
        }
      };

      for (int f = 0; f < BoundingBox_Faces.length; f++) {

        beginShape();

        for (int g = 0; g < BoundingBox_Faces[f].length; g++) {

          int vNo = BoundingBox_Faces[f][g];

          float x = BoundingBox_Vertices[vNo][0] * OBJECTS_scale;
          float y = BoundingBox_Vertices[vNo][1] * OBJECTS_scale;            
          float z = -BoundingBox_Vertices[vNo][2] * OBJECTS_scale;

          float[] Image_XYZ = WIN3D.calculate_Perspective_Internally(x, y, z);            

          if (Image_XYZ[2] > 0) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZ[0], Image_XYZ[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) vertex(Image_XYZ[0], Image_XYZ[1]);
          }
        }
        endShape(CLOSE);
      }

      strokeWeight(0);   

      popMatrix();


      userSelections.alignX = keep_selection_alignX;
      userSelections.alignY = keep_selection_alignY;
      userSelections.alignZ = keep_selection_alignZ;
    }  




    if (userSelections.Group_displayPivot) {

      pushMatrix();

      translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

      noFill();

      stroke(255, 127, 0, 127); 

      strokeWeight(5);

      for (int o = userSelections.Group_ids.length - 1; o >= 0; o--) {

        int OBJ_NUM = userSelections.Group_ids[o];

        float[][] Pivot_Vertices = {
          {
            0, 0, 0
          }
          , 
          {
            1, 0, 0
          }
          , 
          {
            0, 1, 0
          }
          , 
          {
            0, 0, 1
          }
        }; 


        float x0 = allGroups.PivotMatrix[OBJ_NUM][0];
        float y0 = allGroups.PivotMatrix[OBJ_NUM][1];
        float z0 = allGroups.PivotMatrix[OBJ_NUM][2];

        for (int i = 0; i < Pivot_Vertices.length; i++) {

          float x = Pivot_Vertices[i][0];
          float y = Pivot_Vertices[i][1];
          float z = Pivot_Vertices[i][2];

          float r = 10; // <<<<<<<<< display size

          x *= r;
          y *= r;
          z *= r;

          float[] O = userSelections.translateInside_ReferencePivot(0, 0, 0);
          float[] A = userSelections.translateInside_ReferencePivot(x, y, z);

          float dx = A[0] - O[0];
          float dy = A[1] - O[1];
          float dz = A[2] - O[2];

          Pivot_Vertices[i][0] = x0 + dx;
          Pivot_Vertices[i][1] = y0 + dy;
          Pivot_Vertices[i][2] = z0 + dz;
        }


        int[][] Pivot_Lines = {
          {
            0, 1
          }
          , {
            0, 2
          }
          , {
            0, 3
          }
        };

        int f_start = 0;
        int f_end = Pivot_Lines.length - 1;

        if (allGroups.PivotType[OBJ_NUM][0] == 1) {
          f_start = 0; 
          f_end = f_start;
        }
        if (allGroups.PivotType[OBJ_NUM][0] == 2) {
          f_start = 1; 
          f_end = f_start;
        }
        if (allGroups.PivotType[OBJ_NUM][0] == 3) {
          f_start = 2; 
          f_end = f_start;
        }

        for (int f = f_start; f <= f_end; f++) {

          int a = Pivot_Lines[f][0];
          int b = Pivot_Lines[f][1];

          float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
          float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
          float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

          float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
          float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
          float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

          float[] Image_XYZa = WIN3D.calculate_Perspective_Internally(x1, y1, z1);            
          float[] Image_XYZb = WIN3D.calculate_Perspective_Internally(x2, y2, z2);

          if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
            if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
              if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
                line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
              }
            }
          }
        }
      }


      strokeWeight(0);   

      popMatrix();
    }
  }



  if (userSelections.displayReferencePivot) {

    pushMatrix();

    translate(WIN3D.cX + 0.5 * WIN3D.dX, WIN3D.cY + 0.5 * WIN3D.dY);  

    noFill();

    strokeWeight(2);

    float[][] Pivot_Vertices = {
      {
        0, 0, 0
      }
      , 
      {
        1, 0, 0
      }
      , 
      {
        0, 1, 0
      }
      , 
      {
        0, 0, 1
      }
    }; 

    float[] P = userSelections.getPivot();

    float x0 = P[0];
    float y0 = P[1];
    float z0 = P[2];

    for (int i = 0; i < Pivot_Vertices.length; i++) {

      float x = Pivot_Vertices[i][0];
      float y = Pivot_Vertices[i][1];
      float z = Pivot_Vertices[i][2];

      float r = 5; // <<<<<<<<< display size

      x *= r;
      y *= r;
      z *= r;

      float[] O = userSelections.translateInside_ReferencePivot(0, 0, 0);
      float[] A = userSelections.translateInside_ReferencePivot(x, y, z);

      float dx = A[0] - O[0];
      float dy = A[1] - O[1];
      float dz = A[2] - O[2];

      Pivot_Vertices[i][0] = x0 + dx;
      Pivot_Vertices[i][1] = y0 + dy;
      Pivot_Vertices[i][2] = z0 + dz;
    }

    int[][] Pivot_Lines = {
      {
        0, 1
      }
      , {
        0, 2
      }
      , {
        0, 3
      }
    };


    for (int f = 0; f < Pivot_Lines.length; f++) {

      if (f == 0) stroke(255, 0, 0);
      if (f == 1) stroke(0, 0, 255);
      if (f == 2) stroke(127, 127, 0);

      int a = Pivot_Lines[f][0];
      int b = Pivot_Lines[f][1];

      float x1 = Pivot_Vertices[a][0] * OBJECTS_scale;
      float y1 = Pivot_Vertices[a][1] * OBJECTS_scale;            
      float z1 = -Pivot_Vertices[a][2] * OBJECTS_scale;

      float x2 = Pivot_Vertices[b][0] * OBJECTS_scale;
      float y2 = Pivot_Vertices[b][1] * OBJECTS_scale;            
      float z2 = -Pivot_Vertices[b][2] * OBJECTS_scale;

      float[] Image_XYZa = WIN3D.calculate_Perspective_Internally(x1, y1, z1);            
      float[] Image_XYZb = WIN3D.calculate_Perspective_Internally(x2, y2, z2);

      if ((Image_XYZa[2] > 0) && (Image_XYZb[2] > 0)) { // it also illuminates undefined Z values whereas negative value passed in the Calculate function.
        if (isInside(Image_XYZa[0], Image_XYZa[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
          if (isInside(Image_XYZb[0], Image_XYZb[1], -0.5 * WIN3D.dX, -0.5 * WIN3D.dY, 0.5 * WIN3D.dX, 0.5 * WIN3D.dY) == 1) {
            line(Image_XYZa[0], Image_XYZa[1], Image_XYZb[0], Image_XYZb[1]);
          }
        }
      }
    }

    strokeWeight(0);   

    popMatrix();
  }
}













String NearLatitude_Stamp () {

  int Round_Latitude = int(funcs.roundTo(STATION.getLatitude(), 5));
  if (Round_Latitude > 70) Round_Latitude = 70; // <<<<<<<<<<<<<<<
  if (Round_Latitude < -45) Round_Latitude = -45; // <<<<<<<<<<<<<<<

  String a = nf(abs(Round_Latitude), 2);

  if (Round_Latitude < 0) a += "S";
  else a += "N";

  return a;
}



String Section_Stamp () {

  String s = "";

  s += "t" + nf(allSolidImpacts.sectionType, 0);
  s += "u" + nf(allSolarImpacts.U_offset, 0, 3);
  s += "v" + nf(allSolarImpacts.V_offset, 0, 3);
  s += "w" + nf(allSolarImpacts.elevation, 0, 3);
  s += "r" + nf(allSolarImpacts.rotation, 0, 3);  

  s = s.replace('.', 'p');
  s = s.replace('-', 'n');

  return s;
}


String Viewport_Stamp () {

  String s = "";
  
  /*

  s += "x" + nf(WIN3D.position_X, 0, 3);
  s += "y" + nf(WIN3D.position_Y, 0, 3);
  s += "z" + nf(WIN3D.position_Z, 0, 3);

  s += "rx" + nf(WIN3D.rotation_X, 0, 3);
  s += "ry" + nf(WIN3D.rotation_Y, 0, 3);
  s += "rz" + nf(WIN3D.rotation_Z, 0, 3);
  
  s = s.replace('.', 'p');
  s = s.replace('-', 'n');
  
  */

  return s;
}


PGraphics SHADOW_graphics; // to be accessible to allModel1Ds plants



void SOLARCHVISION_render_Shadows_CurrentSection () {

  cursor(WAIT);  

  SceneName = "Section_" + Section_Stamp();


  int RES1 = allSolarImpacts.RES1;
  int RES2 = allSolarImpacts.RES2;

  float Shades_scaleX = RES1 / allSolarImpacts.U_scale;
  float Shades_scaleY = RES2 / allSolarImpacts.V_scale;

  float Shades_offsetX = allSolarImpacts.U_offset;
  float Shades_offsetY = allSolarImpacts.V_offset; 


  SHADOW_graphics = createGraphics(RES1, RES2, P2D); 

  PGraphics TREES_graphics = createGraphics(RES1, RES2, P2D);

  int keep_allSolarImpacts_sectionType = allSolarImpacts.sectionType;
  float keep_allSolarImpacts_rotation = allSolarImpacts.rotation;

  if (allSolarImpacts.sectionType == 3) {
    allSolarImpacts.sectionType = 2;
    allSolarImpacts.rotation = 90 - allSolarImpacts.rotation;
  }

  {  
    int RAD_TYPE = 0;

    for (int DATE_ANGLE = 0; DATE_ANGLE < 360; DATE_ANGLE += 15) {

      //for (int i = 0; i < 24; i++) {
      for (int i = 4; i <= 20; i++) { // to make it faster. Also the images are not needed out of this period.

        float HOUR_ANGLE = i; 
        float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (allSolarImpacts.sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);

          SunR_Rotated_check = 2;
        } else if (allSolarImpacts.sectionType == 3) {
        }

        for (int SHD = 0; SHD <= 1; SHD++) {

          String[] STR_SHD = {
            "F", "T"
          };
          String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

          File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);

          File_Name += "_Camera00";

          TREES_graphics.beginDraw();

          TREES_graphics.blendMode(REPLACE);

          TREES_graphics.fill(255); 
          TREES_graphics.stroke(255);
          TREES_graphics.strokeWeight(0);
          TREES_graphics.rectMode(CORNER);
          TREES_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            TREES_graphics.pushMatrix();
            TREES_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);            

            TREES_graphics.stroke(0); 
            TREES_graphics.fill(0);     

            TREES_graphics.blendMode(BLEND);        

            if (allModel2Ds.displayAll) {

              for (int f = 0; f < allModel2Ds.num; f++) {

                int n = abs(allModel2Ds.MAP[f]);

                int w = allModel2Ds.Images[n].width; 
                int h = allModel2Ds.Images[n].height;

                float r = allModel2Ds.getS(f) * 0.5;

                float t = atan2(SunR[2], SunR[1]) + 0.5 * PI; 

                if (allModel2Ds.MAP[f] < 0) t += PI;         

                if (r > 2.5) { // to select only trees!               

                  float x = 0, y = 0, z = 0;

                  { // Vertical mask
                    TREES_graphics.beginShape();

                    TREES_graphics.texture(allModel2Ds.Images[n]); 

                    x = allModel2Ds.getX(f);
                    y = allModel2Ds.getY(f);
                    z = allModel2Ds.getZ(f);

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z; 
                    TX[2] = x + r * cos(t); 
                    TY[2] = y + r * sin(t); 
                    TZ[2] = z + 2 * r; 
                    TX[3] = x - r * cos(t); 
                    TY[3] = y - r * sin(t); 
                    TZ[3] = z + 2 * r;            

                    TU[0] = 0; 
                    TV[0] = h;
                    TU[1] = w; 
                    TV[1] = h;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (allSolarImpacts.sectionType == 2) {
                      {
                        for (int q = 0; q < 4; q++) {
                          float a = TX[q];
                          float b = -TY[q];
                          float c = TZ[q];

                          TX[q] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
                          TY[q] = c;
                          TZ[q] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                        }
                      } 
                      { // now that we rotated 2D we could rotate x,y,z
                        float a = x;
                        float b = -y;
                        float c = z;

                        x = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
                        y = c;
                        z = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                      }
                    } else if (allSolarImpacts.sectionType == 3) {
                    }

                    if ((TZ[0] < allSolarImpacts.elevation) && (allSolarImpacts.elevation < TZ[2])) {

                      float ratio = (allSolarImpacts.elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                      TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                      TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                      if (allSolarImpacts.sectionType == 1) {

                        TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                        TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                      } else if (allSolarImpacts.sectionType == 2) {

                        TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                        TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                      } else if (allSolarImpacts.sectionType == 3) {
                      }
                    }

                    if (TZ[2] > allSolarImpacts.elevation) {

                      for (int q = 0; q < 4; q++) {

                        TZ[q] = TZ[q] - allSolarImpacts.elevation;
                        TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                        TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                        if (allSolarImpacts.sectionType == 1) {
                          float px = TX[q];
                          float py = TY[q];

                          TX[q] = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                          TY[q] = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                        }                          

                        TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                      }
                    }

                    TREES_graphics.endShape(CLOSE);
                  }

                  { // Horizontal mask
                    float ratio = 0.5; // put the mask at half of the height of the tree 

                    for (int back_front = -1; back_front <= 1; back_front += 2) {

                      float rot = back_front * PI / 2 + t;

                      TREES_graphics.beginShape();

                      TREES_graphics.texture(allModel2Ds.Images[n]); 

                      x = allModel2Ds.getX(f);
                      y = allModel2Ds.getY(f);
                      z = allModel2Ds.getZ(f);                      

                      float[] TX = {
                        0, 0, 0, 0
                      };
                      float[] TY = {
                        0, 0, 0, 0
                      };
                      float[] TZ = {
                        0, 0, 0, 0
                      };
                      float[] TU = {
                        0, 0, 0, 0
                      };
                      float[] TV = {
                        0, 0, 0, 0
                      };

                      TX[0] = x - r * cos(t); 
                      TY[0] = y - r * sin(t); 
                      TZ[0] = z + 2 * r * ratio; 
                      TX[1] = x + r * cos(t); 
                      TY[1] = y + r * sin(t); 
                      TZ[1] = z + 2 * r * ratio; 
                      TX[2] = x + r * cos(t) + r * cos(rot); 
                      TY[2] = y + r * sin(t) + r * sin(rot); 
                      TZ[2] = z + 2 * r * ratio; 
                      TX[3] = x - r * cos(t) + r * cos(rot); 
                      TY[3] = y - r * sin(t) + r * sin(rot); 
                      TZ[3] = z + 2 * r * ratio;    

                      TU[0] = 0; 
                      TV[0] = h * ratio;
                      TU[1] = w; 
                      TV[1] = h * ratio;
                      TU[2] = w; 
                      TV[2] = 0;
                      TU[3] = 0; 
                      TV[3] = 0;   

                      if (allSolarImpacts.sectionType == 1) {

                        if (z + 2 * r * ratio > allSolarImpacts.elevation) {

                          for (int q = 0; q < 4; q++) {

                            TZ[q] = TZ[q] - allSolarImpacts.elevation;
                            TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                            TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);  

                            if (allSolarImpacts.sectionType == 1) {
                              float px = TX[q];
                              float py = TY[q];

                              TX[q] = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                              TY[q] = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                            }                            

                            TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                          }
                        }
                      }

                      TREES_graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }

            TREES_graphics.popMatrix();
          }


          TREES_graphics.endDraw();     

          TREES_graphics.save(File_Name + "_2D.jpg");



          SHADOW_graphics.beginDraw();

          SHADOW_graphics.blendMode(REPLACE);

          float _val = 0;
          if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
          SHADOW_graphics.fill(255 * _val); 
          SHADOW_graphics.stroke(255 * _val);
          SHADOW_graphics.strokeWeight(0);
          SHADOW_graphics.rectMode(CORNER);
          SHADOW_graphics.rect(0, 0, RES1, RES2);

          if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

            SHADOW_graphics.pushMatrix();
            SHADOW_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);            

            SHADOW_graphics.stroke(0); 
            SHADOW_graphics.fill(0);              

            if (allFaces.displayAll) {

              for (int f = 0; f < allFaces.nodes.length; f++) {
  
                int vsb = allFaces.getVisibility(f);
  
                if (vsb > 0) {
  
                  int  mt = allFaces.getMaterial(f);
                  if (Materials_Color[mt][0] > 127) {
  
                    int Tessellation = allFaces.getTessellation(f);
  
                    int TotalSubNo = 1;  
                    if (allFaces.getMaterial(f) == 0) {
                      Tessellation += allFaces.displayTessellation;
                    }
                    if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
  
                    float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                    for (int g = 0; g < allFaces.nodes[f].length; g++) {
                      int vNo = allFaces.nodes[f][g];
                      base_Vertices[g][0] = allPoints.getX(vNo);
                      base_Vertices[g][1] = allPoints.getY(vNo);
                      base_Vertices[g][2] = allPoints.getZ(vNo);
                    }
  
                    for (int n = 0; n < TotalSubNo; n++) {
  
                      float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
                      float[][] subFace_Rotated = subFace;
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
                        if (allSolarImpacts.sectionType == 2) {
                          float a = subFace_Rotated[s][0];
                          float b = -subFace_Rotated[s][1];
                          float c = subFace_Rotated[s][2];
  
                          subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
                          subFace_Rotated[s][1] = c;    
                          subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                        } else if (allSolarImpacts.sectionType == 3) {
                        }
                      }  
  
                      SHADOW_graphics.beginShape();
  
                      for (int s = 0; s < subFace_Rotated.length; s++) {
  
                        float z = subFace_Rotated[s][2] - allSolarImpacts.elevation;
                        float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                        float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
  
  
                        if (z >= 0) {
  
                          if (allSolarImpacts.sectionType == 1) {                    
                            float px = x;
                            float py = y;
  
                            x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          } 
  
                          SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                        } else {
                          int s_next = (s + 1) % subFace_Rotated.length;
                          int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                          float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.elevation;
                          float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_prev > 0) { 
                            float ratio = z_prev / (z_prev - z);
  
                            float x_trim = x_prev * (1 - ratio) + x * ratio;
                            float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                            if (allSolarImpacts.sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                              y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                            } 
  
                            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
  
                          float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.elevation;
                          float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                          float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                          if (z_next > 0) { 
                            float ratio = z_next / (z_next - z);
  
                            float x_trim = x_next * (1 - ratio) + x * ratio;
                            float y_trim = y_next * (1 - ratio) + y * ratio;
  
                            if (allSolarImpacts.sectionType == 1) {
                              float px = x_trim;
                              float py = y_trim;
  
                              x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                              y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                            } 
  
                            SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                          }
                        }
                      }
  
                      SHADOW_graphics.endShape(CLOSE);
                    }
                  }
                }
              }
            }
            

            if (Land3D.displaySurface) {
              
              int Tessellation = Land3D.displayTessellation;
              if (WIN3D.FacesShade == SHADE.Surface_Base) {
                Tessellation = 0;
              }
        
              int TotalSubNo = 1;  
              if (Tessellation > 0) TotalSubNo = 4 * int(funcs.roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
        
        
              for (int Li = Land3D.Surface_SkipStart; Li < Land3D.num_rows - 1 - Land3D.Surface_SkipEnd; Li++) {
                for (int Lj = 0; Lj < Land3D.num_columns - 1; Lj++) {
        
                  float[][] base_Vertices = new float [4][3];
        
                  base_Vertices[0][0] = Land3D.Mesh[Li][Lj][0];
                  base_Vertices[0][1] = Land3D.Mesh[Li][Lj][1];
                  base_Vertices[0][2] = Land3D.Mesh[Li][Lj][2];
        
                  base_Vertices[1][0] = Land3D.Mesh[Li+1][Lj][0];
                  base_Vertices[1][1] = Land3D.Mesh[Li+1][Lj][1];
                  base_Vertices[1][2] = Land3D.Mesh[Li+1][Lj][2];
        
                  base_Vertices[2][0] = Land3D.Mesh[Li+1][Lj+1][0];
                  base_Vertices[2][1] = Land3D.Mesh[Li+1][Lj+1][1];
                  base_Vertices[2][2] = Land3D.Mesh[Li+1][Lj+1][2];
        
                  base_Vertices[3][0] = Land3D.Mesh[Li][Lj+1][0];
                  base_Vertices[3][1] = Land3D.Mesh[Li][Lj+1][1];
                  base_Vertices[3][2] = Land3D.Mesh[Li][Lj+1][2];        
        
                  for (int n = 0; n < TotalSubNo; n++) {

                    float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;

                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (allSolarImpacts.sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];

                        subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
                        subFace_Rotated[s][1] = c;    
                        subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                      } else if (allSolarImpacts.sectionType == 3) {
                      }
                    }  

                    SHADOW_graphics.beginShape();

                    for (int s = 0; s < subFace_Rotated.length; s++) {

                      float z = subFace_Rotated[s][2] - allSolarImpacts.elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                      if (z >= 0) {

                        if (allSolarImpacts.sectionType == 1) {                    
                          float px = x;
                          float py = y;

                          x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                          y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                        } 

                        SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                        float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);

                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;

                          if (allSolarImpacts.sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          } 

                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }

                        float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);

                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;

                          if (allSolarImpacts.sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;

                            x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          } 

                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }

                    SHADOW_graphics.endShape(CLOSE);
                  }
                }
              }
            }
            
            

            //now calculating allModel1Ds plants
            if (allModel1Ds.displayAll) {

              for (int f = 0; f < allModel1Ds.num; f++) {

                float x = allModel1Ds.getX(f);
                float y = allModel1Ds.getY(f);
                float z = allModel1Ds.getZ(f);

                float r = allModel1Ds.getS(f) * 0.5;
                float rot = allModel1Ds.getR(f);      

                int n = allModel1Ds.getType(f);

                int dMin = allModel1Ds.getDegreeMin(f);

                int dMax = allModel1Ds.getDegreeMax(f);

                int s = allModel1Ds.getSeed(f);

                float TrunkSize = allModel1Ds.getTrunkSize(f);

                float LeafSize = allModel1Ds.getLeafSize(f);

                randomSeed(s);

                if (n == 0) {

                  float Alpha = 0;
                  float Beta = rot; 

                  allModel1Ds.branch_shadow(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
                }
              }
            }            

            SHADOW_graphics.popMatrix();
          }


          SHADOW_graphics.save(File_Name + "3D_.jpg"); //just to test   

          if (allModel2Ds.displayAll) {

            PImage img = loadImage(File_Name + "_2D.jpg");

            img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

            SHADOW_graphics.blendMode(DARKEST); 

            SHADOW_graphics.tint(255, 255);

            SHADOW_graphics.image(img, 0, 0, RES1, RES2);

            SHADOW_graphics.noTint();
          }  

          SHADOW_graphics.endDraw();        


          SHADOW_graphics.save(File_Name + ".png");
        }
      }
    }
  }


  {
    int RAD_TYPE = 1;

    for (int SHD = 0; SHD <= 1; SHD++) {

      String[] STR_SHD = {
        "F", "T"
      };
      String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

      File_Name += "DIF_" + STR_SHD[SHD];

      for (int i = 0; i < DiffuseVectors.length; i++) {

        float[] SunR= {
          0, DiffuseVectors[i][0], DiffuseVectors[i][1], DiffuseVectors[i][2]
        };

        float[] SunR_Rotated = SunR; 
        int SunR_Rotated_check = 3;

        if (allSolarImpacts.sectionType == 2) {
          float a = SunR_Rotated[1];
          float b = -SunR_Rotated[2];
          float c = SunR_Rotated[3];

          SunR_Rotated[1] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
          SunR_Rotated[2] = c;
          SunR_Rotated[3] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);

          SunR_Rotated_check = 2;
        } else if (allSolarImpacts.sectionType == 3) {
        }


        //------------------------------------ start of copy & paste from the direct version!
        TREES_graphics.beginDraw();

        TREES_graphics.blendMode(REPLACE);

        TREES_graphics.fill(255); 
        TREES_graphics.stroke(255);
        TREES_graphics.strokeWeight(0);
        TREES_graphics.rectMode(CORNER);
        TREES_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          TREES_graphics.pushMatrix();
          TREES_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);            

          TREES_graphics.stroke(0); 
          TREES_graphics.fill(0);     

          TREES_graphics.blendMode(BLEND);        

          if (allModel2Ds.displayAll) {

            for (int f = 0; f < allModel2Ds.num; f++) {

              int n = abs(allModel2Ds.MAP[f]);

              int w = allModel2Ds.Images[n].width; 
              int h = allModel2Ds.Images[n].height;

              float r = allModel2Ds.getS(f) * 0.5;

              float t = atan2(SunR[2], SunR[1]) + 0.5 * PI;

              if (allModel2Ds.MAP[f] < 0) t += PI;         

              if (r > 2.5) { // to select only trees!               

                float x = allModel2Ds.getX(f);
                float y = allModel2Ds.getY(f);
                float z = allModel2Ds.getZ(f);

                { // Vertical mask
                  TREES_graphics.beginShape();

                  TREES_graphics.texture(allModel2Ds.Images[n]); 

                  x = allModel2Ds.getX(f);
                  y = allModel2Ds.getY(f);
                  z = allModel2Ds.getZ(f);

                  float[] TX = {
                    0, 0, 0, 0
                  };
                  float[] TY = {
                    0, 0, 0, 0
                  };
                  float[] TZ = {
                    0, 0, 0, 0
                  };
                  float[] TU = {
                    0, 0, 0, 0
                  };
                  float[] TV = {
                    0, 0, 0, 0
                  };

                  TX[0] = x - r * cos(t); 
                  TY[0] = y - r * sin(t); 
                  TZ[0] = z; 
                  TX[1] = x + r * cos(t); 
                  TY[1] = y + r * sin(t); 
                  TZ[1] = z; 
                  TX[2] = x + r * cos(t); 
                  TY[2] = y + r * sin(t); 
                  TZ[2] = z + 2 * r; 
                  TX[3] = x - r * cos(t); 
                  TY[3] = y - r * sin(t); 
                  TZ[3] = z + 2 * r;            

                  TU[0] = 0; 
                  TV[0] = h;
                  TU[1] = w; 
                  TV[1] = h;
                  TU[2] = w; 
                  TV[2] = 0;
                  TU[3] = 0; 
                  TV[3] = 0;   

                  if (allSolarImpacts.sectionType == 2) {
                    {
                      for (int q = 0; q < 4; q++) {
                        float a = TX[q];
                        float b = -TY[q];
                        float c = TZ[q];

                        TX[q] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
                        TY[q] = c;
                        TZ[q] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                      }
                    } 
                    { // now that we rotated 2D we could rotate x,y,z
                      float a = x;
                      float b = -y;
                      float c = z;

                      x = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);
                      y = c;
                      z = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                    }
                  } else if (allSolarImpacts.sectionType == 3) {
                  }

                  if ((TZ[0] < allSolarImpacts.elevation) && (allSolarImpacts.elevation < TZ[2])) {

                    float ratio = (allSolarImpacts.elevation - TZ[0]) / (TZ[2] - TZ[0]);                      

                    TZ[0] = (TZ[0] * (1 - ratio) + TZ[2] * ratio);
                    TZ[1] = (TZ[1] * (1 - ratio) + TZ[3] * ratio);    

                    if (allSolarImpacts.sectionType == 1) {

                      TV[0] = (TV[0] * (1 - ratio) + TV[2] * ratio);
                      TV[1] = (TV[1] * (1 - ratio) + TV[3] * ratio);
                    } else if (allSolarImpacts.sectionType == 2) {

                      TU[1] = (TU[1] * (1 - ratio) + TU[3] * ratio);
                      TU[2] = (TU[2] * (1 - ratio) + TU[0] * ratio);
                    } else if (allSolarImpacts.sectionType == 3) {
                    }
                  }

                  if (TZ[2] > allSolarImpacts.elevation) {

                    for (int q = 0; q < 4; q++) {

                      TZ[q] = TZ[q] - allSolarImpacts.elevation;
                      TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                      TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);   

                      if (allSolarImpacts.sectionType == 1) {
                        float px = TX[q];
                        float py = TY[q];

                        TX[q] = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                        TY[q] = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                      }                          

                      TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                    }
                  }

                  TREES_graphics.endShape(CLOSE);
                }

                { // Horizontal mask
                  float ratio = 0.5; // put the mask at half of the height of the tree 

                  for (int back_front = -1; back_front <= 1; back_front += 2) {

                    float rot = back_front * PI / 2 + t;

                    TREES_graphics.beginShape();

                    TREES_graphics.texture(allModel2Ds.Images[n]); 

                    float[] TX = {
                      0, 0, 0, 0
                    };
                    float[] TY = {
                      0, 0, 0, 0
                    };
                    float[] TZ = {
                      0, 0, 0, 0
                    };
                    float[] TU = {
                      0, 0, 0, 0
                    };
                    float[] TV = {
                      0, 0, 0, 0
                    };

                    TX[0] = x - r * cos(t); 
                    TY[0] = y - r * sin(t); 
                    TZ[0] = z + 2 * r * ratio; 
                    TX[1] = x + r * cos(t); 
                    TY[1] = y + r * sin(t); 
                    TZ[1] = z + 2 * r * ratio; 
                    TX[2] = x + r * cos(t) + r * cos(rot); 
                    TY[2] = y + r * sin(t) + r * sin(rot); 
                    TZ[2] = z + 2 * r * ratio; 
                    TX[3] = x - r * cos(t) + r * cos(rot); 
                    TY[3] = y - r * sin(t) + r * sin(rot); 
                    TZ[3] = z + 2 * r * ratio;    

                    TU[0] = 0; 
                    TV[0] = h * ratio;
                    TU[1] = w; 
                    TV[1] = h * ratio;
                    TU[2] = w; 
                    TV[2] = 0;
                    TU[3] = 0; 
                    TV[3] = 0;   

                    if (allSolarImpacts.sectionType == 1) {
                      if (z + 2 * r * ratio > allSolarImpacts.elevation) {

                        for (int q = 0; q < 4; q++) {

                          TZ[q] = TZ[q] - allSolarImpacts.elevation;
                          TX[q] = (TX[q] - TZ[q] * SunR_Rotated[1] / SunR_Rotated[3]);
                          TY[q] = (TY[q] - TZ[q] * SunR_Rotated[2] / SunR_Rotated[3]);                  

                          if (allSolarImpacts.sectionType == 1) {
                            float px = TX[q];
                            float py = TY[q];

                            TX[q] = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            TY[q] = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          }      

                          TREES_graphics.vertex((TX[q] - Shades_offsetX) * Shades_scaleX, -(TY[q] - Shades_offsetY) * Shades_scaleY, TU[q], TV[q]);
                        }
                      }
                    }

                    TREES_graphics.endShape(CLOSE);
                  }
                }
              }
            }
          }

          TREES_graphics.popMatrix();
        }


        TREES_graphics.endDraw();
        //------------------------------------ end of copy & paste from the direct version!

        TREES_graphics.save(File_Name + nf(i, 3) + "_2D.jpg");



        SHADOW_graphics.beginDraw();

        SHADOW_graphics.blendMode(REPLACE);

        float _val = 0;
        if (SunR_Rotated[3] > 0) _val = SunR_Rotated[3];
        SHADOW_graphics.fill(255 * _val); 
        SHADOW_graphics.stroke(255 * _val);
        SHADOW_graphics.strokeWeight(0);
        SHADOW_graphics.rectMode(CORNER);
        SHADOW_graphics.rect(0, 0, RES1, RES2);

        if ((SHD == 1) && (SunR[3] > 0) && (SunR_Rotated[SunR_Rotated_check] > 0)) { // i.e. one-sided plane

          SHADOW_graphics.pushMatrix();
          SHADOW_graphics.translate(allSolarImpacts.RES1 / 2, allSolarImpacts.RES2 / 2);            

          SHADOW_graphics.stroke(0); 
          SHADOW_graphics.fill(0);
          
          if (allFaces.displayAll) {

            for (int f = 0; f < allFaces.nodes.length; f++) {
  
              int vsb = allFaces.getVisibility(f);
  
              if (vsb > 0) {
  
                int  mt = allFaces.getMaterial(f);            
                if (Materials_Color[mt][0] > 127) {
  
                  int Tessellation = allFaces.getTessellation(f);
  
                  int TotalSubNo = 1;  
                  if (allFaces.getMaterial(f) == 0) {
                    Tessellation += allFaces.displayTessellation;
                  }
                  if (Tessellation > 0) TotalSubNo = allFaces.nodes[f].length * int(funcs.roundTo(pow(4, Tessellation - 1), 1));
  
                  float[][] base_Vertices = new float [allFaces.nodes[f].length][3];
                  for (int g = 0; g < allFaces.nodes[f].length; g++) {
                    int vNo = allFaces.nodes[f][g];
                    base_Vertices[g][0] = allPoints.getX(vNo);
                    base_Vertices[g][1] = allPoints.getY(vNo);
                    base_Vertices[g][2] = allPoints.getZ(vNo);
                  }
  
                  for (int n = 0; n < TotalSubNo; n++) {
  
                    float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
                    float[][] subFace_Rotated = subFace;
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
                      if (allSolarImpacts.sectionType == 2) {
                        float a = subFace_Rotated[s][0];
                        float b = -subFace_Rotated[s][1];
                        float c = subFace_Rotated[s][2];
  
                        subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
                        subFace_Rotated[s][1] = c;      
                        subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                      } else if (allSolarImpacts.sectionType == 3) {
                      }
                    }                
  
                    SHADOW_graphics.beginShape();
  
                    for (int s = 0; s < subFace_Rotated.length; s++) {
  
                      float z = subFace_Rotated[s][2] - allSolarImpacts.elevation;
                      float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                      float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];
  
                      if (z >= 0) {
  
                        if (allSolarImpacts.sectionType == 1) {
                          float px = x;
                          float py = y;
  
                          x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                          y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                        }                   
  
                        SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                      } else {
                        int s_next = (s + 1) % subFace_Rotated.length;
                        int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         
  
                        float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.elevation;
                        float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];       
  
                        if (z_prev > 0) { 
                          float ratio = z_prev / (z_prev - z);
  
                          float x_trim = x_prev * (1 - ratio) + x * ratio;
                          float y_trim = y_prev * (1 - ratio) + y * ratio;
  
                          if (allSolarImpacts.sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          }                     
  
                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
  
                        float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.elevation;
                        float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                        float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];
  
                        if (z_next > 0) { 
                          float ratio = z_next / (z_next - z);
  
                          float x_trim = x_next * (1 - ratio) + x * ratio;
                          float y_trim = y_next * (1 - ratio) + y * ratio;
  
                          if (allSolarImpacts.sectionType == 1) {
                            float px = x_trim;
                            float py = y_trim;
  
                            x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                            y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                          }                     
  
                          SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                        }
                      }
                    }
  
                    SHADOW_graphics.endShape(CLOSE);
                  }
                }
              }
            }
          }
          
          
          if (Land3D.displaySurface) {
            
            int Tessellation = Land3D.displayTessellation;
            if (WIN3D.FacesShade == SHADE.Surface_Base) {
              Tessellation = 0;
            }
      
            int TotalSubNo = 1;  
            if (Tessellation > 0) TotalSubNo = 4 * int(funcs.roundTo(pow(4, Tessellation - 1), 1)); // = 4 * ... because in LAND grid the cell has 4 points.
      
      
            for (int Li = Land3D.Surface_SkipStart; Li < Land3D.num_rows - 1 - Land3D.Surface_SkipEnd; Li++) {
              for (int Lj = 0; Lj < Land3D.num_columns - 1; Lj++) {
      
                float[][] base_Vertices = new float [4][3];
      
                base_Vertices[0][0] = Land3D.Mesh[Li][Lj][0];
                base_Vertices[0][1] = Land3D.Mesh[Li][Lj][1];
                base_Vertices[0][2] = Land3D.Mesh[Li][Lj][2];
      
                base_Vertices[1][0] = Land3D.Mesh[Li+1][Lj][0];
                base_Vertices[1][1] = Land3D.Mesh[Li+1][Lj][1];
                base_Vertices[1][2] = Land3D.Mesh[Li+1][Lj][2];
      
                base_Vertices[2][0] = Land3D.Mesh[Li+1][Lj+1][0];
                base_Vertices[2][1] = Land3D.Mesh[Li+1][Lj+1][1];
                base_Vertices[2][2] = Land3D.Mesh[Li+1][Lj+1][2];
      
                base_Vertices[3][0] = Land3D.Mesh[Li][Lj+1][0];
                base_Vertices[3][1] = Land3D.Mesh[Li][Lj+1][1];
                base_Vertices[3][2] = Land3D.Mesh[Li][Lj+1][2];        
      
                for (int n = 0; n < TotalSubNo; n++) {

                  float[][] subFace = funcs.getSubFace(base_Vertices, Tessellation, n);
                  float[][] subFace_Rotated = subFace;

                  for (int s = 0; s < subFace_Rotated.length; s++) {
                    if (allSolarImpacts.sectionType == 2) {
                      float a = subFace_Rotated[s][0];
                      float b = -subFace_Rotated[s][1];
                      float c = subFace_Rotated[s][2];

                      subFace_Rotated[s][0] = a * funcs.cos_ang(-allSolarImpacts.rotation) - b * funcs.sin_ang(-allSolarImpacts.rotation);     
                      subFace_Rotated[s][1] = c;    
                      subFace_Rotated[s][2] = a * funcs.sin_ang(-allSolarImpacts.rotation) + b * funcs.cos_ang(-allSolarImpacts.rotation);
                    } else if (allSolarImpacts.sectionType == 3) {
                    }
                  }  

                  SHADOW_graphics.beginShape();

                  for (int s = 0; s < subFace_Rotated.length; s++) {

                    float z = subFace_Rotated[s][2] - allSolarImpacts.elevation;
                    float x = subFace_Rotated[s][0] - z * SunR_Rotated[1] / SunR_Rotated[3];
                    float y = subFace_Rotated[s][1] - z * SunR_Rotated[2] / SunR_Rotated[3];



                    if (z >= 0) {

                      if (allSolarImpacts.sectionType == 1) {                    
                        float px = x;
                        float py = y;

                        x = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                        y = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                      } 

                      SHADOW_graphics.vertex((x - Shades_offsetX) * Shades_scaleX, -((y - Shades_offsetY) * Shades_scaleY));
                    } else {
                      int s_next = (s + 1) % subFace_Rotated.length;
                      int s_prev = (s + subFace_Rotated.length - 1) % subFace_Rotated.length;         

                      float z_prev = subFace_Rotated[s_prev][2] - allSolarImpacts.elevation;
                      float x_prev = subFace_Rotated[s_prev][0] - z_prev * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_prev = subFace_Rotated[s_prev][1] - z_prev * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_prev > 0) { 
                        float ratio = z_prev / (z_prev - z);

                        float x_trim = x_prev * (1 - ratio) + x * ratio;
                        float y_trim = y_prev * (1 - ratio) + y * ratio;

                        if (allSolarImpacts.sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                          y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                        } 

                        SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }

                      float z_next = subFace_Rotated[s_next][2] - allSolarImpacts.elevation;
                      float x_next = subFace_Rotated[s_next][0] - z_next * SunR_Rotated[1] / SunR_Rotated[3];
                      float y_next = subFace_Rotated[s_next][1] - z_next * SunR_Rotated[2] / SunR_Rotated[3];

                      if (z_next > 0) { 
                        float ratio = z_next / (z_next - z);

                        float x_trim = x_next * (1 - ratio) + x * ratio;
                        float y_trim = y_next * (1 - ratio) + y * ratio;

                        if (allSolarImpacts.sectionType == 1) {
                          float px = x_trim;
                          float py = y_trim;

                          x_trim = px * funcs.cos_ang(-allSolarImpacts.rotation) - py * funcs.sin_ang(-allSolarImpacts.rotation); 
                          y_trim = px * funcs.sin_ang(-allSolarImpacts.rotation) + py * funcs.cos_ang(-allSolarImpacts.rotation);
                        } 

                        SHADOW_graphics.vertex((x_trim - Shades_offsetX) * Shades_scaleX, -((y_trim - Shades_offsetY) * Shades_scaleY));
                      }
                    }
                  }

                  SHADOW_graphics.endShape(CLOSE);
                }
              }
            }
          }          

          //now calculating allModel1Ds plants
          if (allModel1Ds.displayAll) {

            for (int f = 0; f < allModel1Ds.num; f++) {

              float x = allModel1Ds.getX(f);
              float y = allModel1Ds.getY(f);
              float z = allModel1Ds.getZ(f);

              float r = allModel1Ds.getS(f) * 0.5;
              float rot = allModel1Ds.getR(f);      

              int n = allModel1Ds.getType(f);

              int dMin = allModel1Ds.getDegreeMin(f);

              int dMax = allModel1Ds.getDegreeMax(f);

              int s = allModel1Ds.getSeed(f);

              float TrunkSize = allModel1Ds.getTrunkSize(f);

              float LeafSize = allModel1Ds.getLeafSize(f);

              randomSeed(s);

              if (n == 0) {

                float Alpha = 0;
                float Beta = rot; 

                allModel1Ds.branch_shadow(x, y, z, Alpha, Beta, r, dMin, dMin, dMax, TrunkSize, LeafSize, SunR_Rotated, Shades_scaleX, Shades_scaleY, Shades_offsetX, Shades_offsetY);
              }
            }
          }          

          SHADOW_graphics.popMatrix();
        }

        SHADOW_graphics.save(File_Name + "3D_.jpg"); //just to test   

        if (allModel2Ds.displayAll) {

          PImage img = loadImage(File_Name + nf(i, 3) + "_2D.jpg");

          img.filter(THRESHOLD, 0.75); // Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter.

          SHADOW_graphics.blendMode(DARKEST); 

          SHADOW_graphics.tint(255, 255);

          SHADOW_graphics.image(img, 0, 0, RES1, RES2);

          SHADOW_graphics.noTint();
        }  

        SHADOW_graphics.endDraw();    

        SHADOW_graphics.save(File_Name + nf(i, 3) + ".jpg");
      }



      PGraphics DIFFUSE_graphics = createGraphics(RES1, RES2, P2D);    

      DIFFUSE_graphics.beginDraw();

      DIFFUSE_graphics.blendMode(REPLACE);

      DIFFUSE_graphics.fill(0); 
      DIFFUSE_graphics.stroke(0);
      DIFFUSE_graphics.strokeWeight(0);
      DIFFUSE_graphics.rectMode(CORNER);
      DIFFUSE_graphics.rect(0, 0, RES1, RES2);

      for (int i = 0; i < skyFaces.length; i++) {

        PImage img = loadImage(File_Name + nf(i, 3) + ".jpg");

        DIFFUSE_graphics.blendMode(ADD); 

        DIFFUSE_graphics.tint(255, 255 / (0.5 * float(skyFaces.length)));

        DIFFUSE_graphics.image(img, 0, 0, RES1, RES2);

        DIFFUSE_graphics.noTint();
      }

      DIFFUSE_graphics.endDraw();

      File_Name += "_Camera00.png"; 

      DIFFUSE_graphics.save(File_Name);
      println(File_Name);
    }
  }

  allSolarImpacts.sectionType = keep_allSolarImpacts_sectionType;
  allSolarImpacts.rotation = keep_allSolarImpacts_rotation;  

  cursor(ARROW);
}




































































int UI_X_moved = -1;
int UI_Y_moved = -1;


void mouseMoved () {

  if (frameCount > Last_initializationStep) {

    if (SOLARCHVISION_automated == 0) {

      if (UI_BAR_a.selected_parent != -1) {

        if ((UI_X_moved != mouseX) || (UI_Y_moved != mouseY)) {

          UI_X_moved = mouseX;
          UI_Y_moved = mouseY;      

          UI_BAR_a.update = true;     

          redraw();
        }
      }
    }
  }
}



PImage pre_screen;




void SOLARCHVISION_modify_Viewport_Title () {

  String s = "Cam" + nf(WIN3D.currentCamera, 2);

  UI_BAR_b.Items[0][11] = s; // <<<<< Note: 3DViewPoint is the first index on BAR_b 
  UI_BAR_b.hghlight(s);

  UI_BAR_b.update = true;
}  






void UI_set_to_Create_Nothing () {

  CreateObject = CREATE.Nothing;

  WIN3D.UI_CurrentTask = UITASK.Create;

  ROLLOUT.update = true;
}


void UI_set_to_Create_allModel1Ds () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.allModel1Ds;
  current_ObjectCategory = ObjectCategory.MODEL1D;
}  


void UI_set_to_Create_Tree () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plant;
  current_ObjectCategory = ObjectCategory.MODEL2D;
}

void UI_set_to_Create_Person () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Person;
  current_ObjectCategory = ObjectCategory.MODEL2D;
}

void UI_set_to_Create_Vertex () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Vertex;
  current_ObjectCategory = ObjectCategory.VERTEX;
}

void UI_set_to_Create_Face () {
  UI_set_to_Create_Nothing();

  current_Material = User3D.default_Material;
  current_Tessellation = User3D.default_Tessellation;
  current_Layer = User3D.default_Layer;
  current_Visibility = User3D.default_Visibility;
  current_Weight = User3D.default_Weight;  
  current_Closed = User3D.default_Closed;   
  
  allModel3Ds.beginNewFace();

  CreateObject = CREATE.Face;
  current_ObjectCategory = ObjectCategory.FACE;
}

void UI_set_to_Create_Curve () {
  UI_set_to_Create_Nothing();

  current_Material = User3D.default_Material;
  current_Tessellation = User3D.default_Tessellation;
  current_Layer = User3D.default_Layer;
  current_Visibility = User3D.default_Visibility;
  current_Weight = User3D.default_Weight;  
  current_Closed = User3D.default_Closed;   
  
  allModel3Ds.beginNewCurve();

  CreateObject = CREATE.Curve;
  current_ObjectCategory = ObjectCategory.CURVE;
}

void UI_set_to_Create_Solid () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Solid;
  current_ObjectCategory = ObjectCategory.SOLID;
}

void UI_set_to_Create_Section () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Section;
  current_ObjectCategory = ObjectCategory.SECTION;
}


void UI_set_to_Create_Camera () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Camera;
  current_ObjectCategory = ObjectCategory.CAMERA;
}






void UI_set_to_Create_Parametric (int n) {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Parametric;
  User3D.create_Parametric_Type = n;

  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Tri () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Tri;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Plane () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Plane;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Poly () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Poly;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Extrude () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Extrude;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Hyper () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.Hyper;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_House1 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House1;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_House2 () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.House2;
  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Box () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = CubePower;   
  User3D.create_powY = CubePower; 
  User3D.create_powZ = CubePower;             

  current_ObjectCategory = ObjectCategory.GROUP;
}


void UI_set_to_Create_Icosahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 1;  
  User3D.create_powY = 1; 
  User3D.create_powZ = 1;            

  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Octahedron () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 1;  
  User3D.create_powY = 1; 
  User3D.create_powZ = 1;            

  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Sphere () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 2;  
  User3D.create_powY = 2; 
  User3D.create_powZ = 2;            

  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Cylinder () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = 2;  
  User3D.create_powY = 2; 
  User3D.create_powZ = CubePower;             

  current_ObjectCategory = ObjectCategory.GROUP;
}

void UI_set_to_Create_Cushion () {
  UI_set_to_Create_Nothing();

  CreateObject = CREATE.SuperOBJ;

  User3D.create_powX = CubePower;   
  User3D.create_powY = CubePower;  
  User3D.create_powZ = 2;            

  current_ObjectCategory = ObjectCategory.GROUP;
}




void UI_set_to_Modify_Move (int n) {
  WIN3D.UI_CurrentTask = UITASK.Move;

  userSelections.posVector = n;

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Scale (int n) {
  WIN3D.UI_CurrentTask = UITASK.Scale;

  userSelections.scaleVector = n;

  ROLLOUT.update = true;
}


void UI_set_to_Modify_Rotate (int n) {
  WIN3D.UI_CurrentTask = UITASK.Rotate;

  userSelections.rotVector = n;

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Seed (int n) {
  WIN3D.UI_CurrentTask = UITASK.Seed_Material;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Tessellation (int n) {
  WIN3D.UI_CurrentTask = UITASK.Tessellation;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Layer (int n) {
  WIN3D.UI_CurrentTask = UITASK.Layer;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Visibility (int n) {
  WIN3D.UI_CurrentTask = UITASK.Visibility;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Weight (int n) {
  WIN3D.UI_CurrentTask = UITASK.Weight;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

// the same messages of WIN3D.UI_CurrentTask=6/7 for both Layer/Visibility of group3Ds and DegreeMax/DegreeDif is not good!

void UI_set_to_Modify_DegreeMax (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeMax;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_DegreeDif (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeDif;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_DegreeMin (int n) {
  WIN3D.UI_CurrentTask = UITASK.DegreeMin;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_TrunkSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.TrunkSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_LeafSize (int n) {
  WIN3D.UI_CurrentTask = UITASK.LeafSize;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_All_Model1DsProps (int n) {
  WIN3D.UI_CurrentTask = UITASK.All_Model1DsProps;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Pivot (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pivot;
  WIN3D.UI_TaskModifyParameter = n; // 0:change selection 1:pick from 2:assign to

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Normal (int n) {
  WIN3D.UI_CurrentTask = UITASK.Normal;
  WIN3D.UI_TaskModifyParameter = n; // 1:flip normal, 2:set out from pivot, 3:set in from pivot    

  ROLLOUT.update = true;
}

void UI_set_to_Modify_FirstVertex (int n) {
  WIN3D.UI_CurrentTask = UITASK.FirstVertex;
  WIN3D.UI_TaskModifyParameter = n; // 1:default

  ROLLOUT.update = true;
}




void UI_set_to_Modify_Drop (int n) {
  WIN3D.UI_CurrentTask = UITASK.Drop;

  WIN3D.UI_TaskModifyParameter = n; // 0:LandSurface± 1:ModelSurface- 2:ModelSurface+

  ROLLOUT.update = true;
}


void UI_set_to_Modify_GetLength (int n) {
  WIN3D.UI_CurrentTask = UITASK.GetLength;

  WIN3D.UI_TaskModifyParameter = n; // 0:x 1:y 2:z 3:xyz 4:xy 5:angle(on XY plane) 

  ROLLOUT.update = true;
}

void UI_set_to_Modify_Power (int n) {

  if (n == 0) WIN3D.UI_CurrentTask = UITASK.PowerX; // x 
  if (n == 1) WIN3D.UI_CurrentTask = UITASK.PowerY; // y 
  if (n == 2) WIN3D.UI_CurrentTask = UITASK.PowerZ; // z 
  if (n == 3) WIN3D.UI_CurrentTask = UITASK.PowerAll; // xyz

  WIN3D.UI_TaskModifyParameter = 0; // 0:change

  ROLLOUT.update = true;
}










void UI_set_to_View_ProjectionType (int n) {
  WIN3D.ViewType = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_ClickSelect (int n) {

  WIN3D.UI_CurrentTask = UITASK.PickSelect;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.update = true;
}

void UI_set_to_View_WindowSelect (int n) {
  WIN3D.UI_CurrentTask = UITASK.RectSelect;

  if (n == 1) {
    addNewSelectionToPreviousSelection = 1;
  }

  if (n == 2) {
    addNewSelectionToPreviousSelection = -1;
  }

  ROLLOUT.update = true;
}    

void UI_set_to_View_PivotX (int n) {

  userSelections.alignX = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_PivotY (int n) {

  userSelections.alignY = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}

void UI_set_to_View_PivotZ (int n) {

  userSelections.alignZ = n;

  WIN3D.update = true; 
  ROLLOUT.update = true;
}      


void UI_set_to_View_Truck (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  


void UI_set_to_View_DistMouseXY (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.DistMouseXY_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.update = true;
}  



void UI_set_to_View_CameraDistance (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraDistance_TargetRollXY_TargetRollZ;
  }

  ROLLOUT.update = true;
}  



void UI_set_to_View_CameraRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.CameraRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.CameraRollXY_CameraRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  



void UI_set_to_View_TargetRoll (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.TargetRoll_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.TargetRollXY_TargetRollZ;
    WIN3D.UI_TaskModifyParameter = 0;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  


void UI_set_to_View_Orbit (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Zoom_Orbit_Pan;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;            
    WIN3D.UI_OptionXorY = 0;
  } 

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.Truck_Orbit;
    WIN3D.UI_TaskModifyParameter = 1;            
    WIN3D.UI_OptionXorY = 1;
  }           

  ROLLOUT.update = true;
}  



void UI_set_to_View_LandOrbit (int n) {

  WIN3D.UI_CurrentTask = UITASK.LandOrbit_Pan_TargetRollZ;

  ROLLOUT.update = true;
}  



void UI_set_to_View_LookAtSelection (int n) {

  WIN3D.look_3DViewport_towards_Selection();

  { // automatically set another choice of ineterest
    UI_set_to_View_CameraDistance(0);
    UI_BAR_b.hghlight("±CDS");
    UI_BAR_b.update = true;
  }

  WIN3D.update = true;

  ROLLOUT.update = true;
}  


void UI_set_to_View_LookAtDirection (int n) {

  WIN3D.UI_CurrentTask = UITASK.LookAtDirection;

  ROLLOUT.update = true;
}  


void UI_set_to_View_LookAtOrigin (int n) {

  WIN3D.position_X = 0;
  WIN3D.position_Y = 0;
  WIN3D.position_Z = 0; 

  {
    // automatically set another choice of ineterest

    UI_set_to_View_Truck(0);
    UI_BAR_b.hghlight("±CDZ");
    UI_BAR_b.update = true;
  }

  WIN3D.update = true;

  ROLLOUT.update = true;
}  


void UI_set_to_View_Pan (int n) {

  if (n == 0) {
    WIN3D.UI_CurrentTask = UITASK.Pan_TargetRoll;
  }

  if (n == 1) {
    WIN3D.UI_CurrentTask = UITASK.PanX_TargetRollXY_TargetRollZ;
  }

  if (n == 2) {
    WIN3D.UI_CurrentTask = UITASK.PanY_TargetRollXY_TargetRollZ;
  }


  ROLLOUT.update = true;
}  

void UI_set_to_View_ZOOM (int n) {
  WIN3D.UI_CurrentTask = UITASK.Pan_Height;

  if (n == 1) {
    WIN3D.Zoom = 60;
    WIN3D.update = true;
  }

  ROLLOUT.update = true;
}      

void UI_set_to_View_3DModelSize () {

  WIN3D.UI_CurrentTask = UITASK.ModelSize_Pan_TargetRoll;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}      

void UI_set_to_View_SkydomeSize () {

  WIN3D.UI_CurrentTask = UITASK.SkydomeSize;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}   

void UI_set_to_View_AllModelSize () {

  WIN3D.UI_CurrentTask = UITASK.AllModelSize;

  WIN3D.update = true;  

  ROLLOUT.update = true;
}   


void UI_set_to_Viewport (int n) {

  FrameVariation = n;
  SOLARCHVISION_update_frame_layout();

  ROLLOUT.update = true;
}

void UI_set_to_View_3DViewPoint (int n) {

  WIN3D.currentCamera = 0;

  WIN3D.apply_currentCamera();

  if (n == 0) {
    WIN3D.rotateZ_3DViewport_around_Selection(0 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }

  if (n == 1) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }          

  if (n == 2) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(-90 - WIN3D.rotation_Z);
  }    

  if (n == 3) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(180 - WIN3D.rotation_Z);
  }   

  if (n == 4) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(90 - WIN3D.rotation_Z);
  }  

  if (n == 5) {
    WIN3D.rotateZ_3DViewport_around_Selection(180 - WIN3D.rotation_X);
    WIN3D.rotateXY_3DViewport_around_Selection(0 - WIN3D.rotation_Z);
  }             

  if (n == 6) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(-45 - WIN3D.rotation_Z);
  }             

  if (n == 7) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(45 - WIN3D.rotation_Z);
  }     

  if (n == 8) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(135 - WIN3D.rotation_Z);
  }

  if (n == 9) {
    WIN3D.rotateZ_3DViewport_around_Selection(90 - WIN3D.rotation_X); 
    WIN3D.rotateXY_3DViewport_around_Selection(-135 - WIN3D.rotation_Z);
  }


  UI_BAR_b.update = true;

  WIN3D.update = true;   

  ROLLOUT.update = true;
} 























int[] get_startK_endK () {
  int[] a = new int [2];

  int start_k = -1;
  int end_k = -1; 

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End; 

    if (start_k < CLIMATE_CWEEDS_start) start_k = CLIMATE_CWEEDS_start;
    if (end_k > CLIMATE_CWEEDS_end) end_k = CLIMATE_CWEEDS_end;

    start_k -= CLIMATE_CWEEDS_start;
    end_k -= CLIMATE_CWEEDS_start;
  }
  if (CurrentDataSource == dataID_CLIMATE_CLMREC) {

    start_k = SampleYear_Start;
    end_k = SampleYear_End;

    if (start_k < CLIMATE_CLMREC_start) start_k = CLIMATE_CLMREC_start;
    if (end_k > CLIMATE_CLMREC_end) end_k = CLIMATE_CLMREC_end;

    start_k -= CLIMATE_CLMREC_start;
    end_k -= CLIMATE_CLMREC_start;
  }  
  if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {

    start_k = 0;
    end_k = 0;   
  }     
  if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {

    start_k = SampleMember_Start;
    end_k = SampleMember_End;

    start_k -= ENSEMBLE_FORECAST_start;
    end_k -= ENSEMBLE_FORECAST_start;    
  }    
  if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {

    start_k =  SampleStation_Start;
    end_k =  SampleStation_End;
    
    start_k -= ENSEMBLE_OBSERVED_start;
    end_k -= ENSEMBLE_OBSERVED_start;     
  }   


  //println("start_k=", start_k);
  //println("end_k=", end_k);

  a[0] = start_k;
  a[1] = end_k;
  
  return  a;
}



void SOLARCHVISION_explore_output (String outputFile) {

  if ((displayOutput_inExplorer)  && (STUDY.record_AUTO == false) && (WORLD.record_AUTO == false) && (WIN3D.record_AUTO == false) && (FRAME_record_AUTO == false)) {
    launch("explorer /select," + outputFile.replace('/', char(92)));
  }
}





              
String save_folder = "";

void SOLARCHVISION_save_project (String myFile) {

  myFile = myFile.replace(char(92), '/');
  
  save_folder = myFile.substring(0, myFile.lastIndexOf("/")); 

  XML xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  xml.setName("SOLARCHVISION_" + SOLARCHVISION_version + "_project");

  {
    XML parent = xml.addChild("SOLARCHVISION_variables");
  
    parent.setString("displayOutput_inExplorer", Boolean.toString(displayOutput_inExplorer));

    parent.setInt("current_ObjectCategory", current_ObjectCategory);
  
    parent.setFloat("GlobalAlbedo", GlobalAlbedo);
    parent.setFloat("Interpolation_Weight", Interpolation_Weight);
    
    parent.setInt("CLIMATIC_SolarForecast", CLIMATIC_SolarForecast);
    parent.setInt("CLIMATIC_WeatherForecast", CLIMATIC_WeatherForecast);
    parent.setInt("SOLARCHVISION_automated", SOLARCHVISION_automated);

    parent.setInt("CLIMATE_TMYEPW_start", CLIMATE_TMYEPW_start);
    parent.setInt("CLIMATE_TMYEPW_end", CLIMATE_TMYEPW_end);
    parent.setInt("CLIMATE_CWEEDS_start", CLIMATE_CWEEDS_start);
    parent.setInt("CLIMATE_CWEEDS_end", CLIMATE_CWEEDS_end);
    parent.setInt("CLIMATE_CLMREC_start", CLIMATE_CLMREC_start);
    parent.setInt("CLIMATE_CLMREC_end", CLIMATE_CLMREC_end);
    parent.setInt("ENSEMBLE_FORECAST_start", ENSEMBLE_FORECAST_start);
    parent.setInt("ENSEMBLE_FORECAST_end", ENSEMBLE_FORECAST_end);
    parent.setInt("ENSEMBLE_FORECAST_maxDays", ENSEMBLE_FORECAST_maxDays);
    parent.setInt("ENSEMBLE_OBSERVED_maxDays", ENSEMBLE_OBSERVED_maxDays);
    parent.setInt("ENSEMBLE_OBSERVED_numNearest", ENSEMBLE_OBSERVED_numNearest);
    parent.setInt("ENSEMBLE_OBSERVED_start", ENSEMBLE_OBSERVED_start);
    parent.setInt("ENSEMBLE_OBSERVED_end", ENSEMBLE_OBSERVED_end);
    parent.setInt("SampleYear_Start", SampleYear_Start);
    parent.setInt("SampleYear_End", SampleYear_End);
    parent.setInt("SampleMember_Start", SampleMember_Start);
    parent.setInt("SampleMember_End", SampleMember_End);
    parent.setInt("SampleStation_Start", SampleStation_Start);
    parent.setInt("SampleStation_End", SampleStation_End);
    parent.setString("CLIMATE_TMYEPW_load", Boolean.toString(CLIMATE_TMYEPW_load));
    parent.setString("CLIMATE_CWEEDS_load", Boolean.toString(CLIMATE_CWEEDS_load));
    parent.setString("CLIMATE_CLMREC_load", Boolean.toString(CLIMATE_CLMREC_load));  
    parent.setString("ENSEMBLE_FORECAST_load", Boolean.toString(ENSEMBLE_FORECAST_load));
    parent.setString("ENSEMBLE_OBSERVED_load", Boolean.toString(ENSEMBLE_OBSERVED_load));
    parent.setInt("GRIB2_Month", GRIB2_Month);
    parent.setInt("GRIB2_Day", GRIB2_Day);
    parent.setInt("GRIB2_ModelRun", GRIB2_ModelRun);
    parent.setInt("AERIAL_num", AERIAL_num);
    parent.setFloat("AERIAL_Center_Longitude", AERIAL_Center_Longitude);
    parent.setFloat("AERIAL_Center_Latitude", AERIAL_Center_Latitude);
    parent.setInt("GRIB2_Hour_Start", GRIB2_Hour_Start);
    parent.setInt("GRIB2_Hour_End", GRIB2_Hour_End);
    parent.setInt("GRIB2_Hour_Step", GRIB2_Hour_Step);
    parent.setInt("GRIB2_Layer_Start", GRIB2_Layer_Start);
    parent.setInt("GRIB2_Layer_End", GRIB2_Layer_End);
    parent.setInt("GRIB2_Layer_Step", GRIB2_Layer_Step);
    parent.setInt("GRIB2_Hour", GRIB2_Hour);
    parent.setInt("GRIB2_Layer", GRIB2_Layer);
    parent.setInt("GRIB2_DomainSelection", GRIB2_DomainSelection);
    parent.setInt("GRIB2_TGL_number", GRIB2_TGL_number);
    parent.setInt("AERIAL_graphOption", AERIAL_graphOption);
    parent.setInt("Develop_Option", Develop_Option);
    parent.setInt("Develop_DayHour", Develop_DayHour);
    parent.setString("DevelopData_update", Boolean.toString(DevelopData_update));
    parent.setInt("numberOfLayers", numberOfLayers);

    parent.setFloat("Develop_AngleInclination", Develop_AngleInclination);
    parent.setFloat("Develop_AngleOrientation", Develop_AngleOrientation);
    parent.setInt("DevelopLayer_id", DevelopLayer_id);
    parent.setInt("CurrentLayer_id", CurrentLayer_id);


    parent.setInt("Impact_TYPE", Impact_TYPE);

    parent.setInt("COLOR_STYLE_Current", COLOR_STYLE_Current);
    parent.setInt("COLOR_STYLE_Number", COLOR_STYLE_Number);
    
    parent.setInt("CurrentDataSource", CurrentDataSource);
    parent.setInt("DrawnFrame", DrawnFrame);


  
    parent.setFloat("Planetary_Magnification", Planetary_Magnification);

    
    //parent.setInt("Camera_Variation", Camera_Variation);

    parent.setInt("Materials_Selection", Materials_Selection);
    parent.setFloat("OBJECTS_scale", OBJECTS_scale);

    parent.setInt("FrameVariation", FrameVariation);
    parent.setInt("Language_Active", Language_Active);
  
    parent.setInt("IMPACTS_displayDay", IMPACTS_displayDay);

    parent.setFloat("BIOSPHERE_drawResolution", BIOSPHERE_drawResolution);

    parent.setString("Default_Font", Default_Font);
  }


  STATION.to_XML(xml);
  
  allPoints.to_XML(xml);

  allCurves.to_XML(xml);

  allFaces.to_XML(xml);

  allGroups.to_XML(xml);
  
  allCameras.to_XML(xml);
  
  allSolids.to_XML(xml);

  allSections.to_XML(xml);
  
  allModel1Ds.to_XML(xml);
  
  allModel2Ds.to_XML(xml);
  
  userSelections.to_XML(xml);  
  
  User3D.to_XML(xml);
  
  Land3D.to_XML(xml);  
  
  Earth3D.to_XML(xml);
  
  Sky3D.to_XML(xml);
  
  Tropo3D.to_XML(xml);
  
  Moon3D.to_XML(xml);
  
  Sun3D.to_XML(xml);

  WIN3D.to_XML(xml);
  
  WORLD.to_XML(xml);
  
  STUDY.to_XML(xml);
  
  allWindRoses.to_XML(xml);
  
  allWindFlows.to_XML(xml);
  
  allSolidImpacts.to_XML(xml);
  
  allSolarImpacts.to_XML(xml);  

  LAYER_windspd200hPa.to_XML(xml);
  LAYER_thicknesses_1000_500.to_XML(xml);
  LAYER_heightp500hPa.to_XML(xml);
  LAYER_ceilingsky.to_XML(xml);
  LAYER_cloudcover.to_XML(xml);
  LAYER_winddir.to_XML(xml);
  LAYER_windspd.to_XML(xml);
  LAYER_pressure.to_XML(xml);
  LAYER_drybulb.to_XML(xml);
  LAYER_relhum.to_XML(xml);
  LAYER_dirnorrad.to_XML(xml);
  LAYER_difhorrad.to_XML(xml);
  LAYER_glohorrad.to_XML(xml);
  LAYER_direffect.to_XML(xml);
  LAYER_difeffect.to_XML(xml);
  LAYER_precipitation.to_XML(xml);
  LAYER_developed.to_XML(xml);  

  saveXML(xml, myFile);    

  println("End of saving XML.");

}


void SOLARCHVISION_load_project (String myFile) {

  myFile = myFile.replace(char(92), '/');


  int continue_process = 1;

  XML xml = parseXML("<?xml version='1.0' encoding='UTF-8'?>" + char(13) + "<empty>" + char(13) + "</empty>");

  try {
    xml = loadXML(myFile);
  }
  catch (Exception e) {
    println("Can't read:", myFile);
    continue_process = 0;
  }

  if (continue_process == 1) { 

    {
      XML parent = xml.getChild("SOLARCHVISION_variables");
      
      displayOutput_inExplorer = Boolean.parseBoolean(parent.getString("displayOutput_inExplorer"));

      current_ObjectCategory = parent.getInt("current_ObjectCategory");

      GlobalAlbedo = parent.getFloat("GlobalAlbedo");
      Interpolation_Weight = parent.getFloat("Interpolation_Weight");
      
      CLIMATIC_SolarForecast = parent.getInt("CLIMATIC_SolarForecast");
      CLIMATIC_WeatherForecast = parent.getInt("CLIMATIC_WeatherForecast");
      SOLARCHVISION_automated = parent.getInt("SOLARCHVISION_automated");

      CLIMATE_TMYEPW_start = parent.getInt("CLIMATE_TMYEPW_start");
      CLIMATE_TMYEPW_end = parent.getInt("CLIMATE_TMYEPW_end");
      CLIMATE_CWEEDS_start = parent.getInt("CLIMATE_CWEEDS_start");
      CLIMATE_CWEEDS_end = parent.getInt("CLIMATE_CWEEDS_end");
      CLIMATE_CLMREC_start = parent.getInt("CLIMATE_CLMREC_start");
      CLIMATE_CLMREC_end = parent.getInt("CLIMATE_CLMREC_end");
      ENSEMBLE_FORECAST_start = parent.getInt("ENSEMBLE_FORECAST_start");
      ENSEMBLE_FORECAST_end = parent.getInt("ENSEMBLE_FORECAST_end");
      ENSEMBLE_FORECAST_maxDays = parent.getInt("ENSEMBLE_FORECAST_maxDays");
      ENSEMBLE_OBSERVED_maxDays = parent.getInt("ENSEMBLE_OBSERVED_maxDays");      
      ENSEMBLE_OBSERVED_numNearest = parent.getInt("ENSEMBLE_OBSERVED_numNearest");
      ENSEMBLE_OBSERVED_start = parent.getInt("ENSEMBLE_OBSERVED_start");
      ENSEMBLE_OBSERVED_end = parent.getInt("ENSEMBLE_OBSERVED_end");
      SampleYear_Start = parent.getInt("SampleYear_Start");
      SampleYear_End = parent.getInt("SampleYear_End");
      SampleMember_Start = parent.getInt("SampleMember_Start");
      SampleMember_End = parent.getInt("SampleMember_End");
      SampleStation_Start = parent.getInt("SampleStation_Start");
      SampleStation_End = parent.getInt("SampleStation_End");
      CLIMATE_TMYEPW_load = Boolean.parseBoolean(parent.getString("CLIMATE_TMYEPW_load"));
      CLIMATE_CWEEDS_load = Boolean.parseBoolean(parent.getString("CLIMATE_CWEEDS_load"));
      CLIMATE_CLMREC_load = Boolean.parseBoolean(parent.getString("CLIMATE_CLMREC_load"));
      ENSEMBLE_FORECAST_load = Boolean.parseBoolean(parent.getString("ENSEMBLE_FORECAST_load"));
      ENSEMBLE_OBSERVED_load = Boolean.parseBoolean(parent.getString("ENSEMBLE_OBSERVED_load"));
      GRIB2_Month = parent.getInt("GRIB2_Month");
      GRIB2_Day = parent.getInt("GRIB2_Day");
      GRIB2_ModelRun = parent.getInt("GRIB2_ModelRun");
      AERIAL_num = parent.getInt("AERIAL_num");
      AERIAL_Center_Longitude = parent.getFloat("AERIAL_Center_Longitude");
      AERIAL_Center_Latitude = parent.getFloat("AERIAL_Center_Latitude");
      GRIB2_Hour_Start = parent.getInt("GRIB2_Hour_Start");
      GRIB2_Hour_End = parent.getInt("GRIB2_Hour_End");
      GRIB2_Hour_Step = parent.getInt("GRIB2_Hour_Step");
      GRIB2_Layer_Start = parent.getInt("GRIB2_Layer_Start");
      GRIB2_Layer_End = parent.getInt("GRIB2_Layer_End");
      GRIB2_Layer_Step = parent.getInt("GRIB2_Layer_Step");
      GRIB2_Hour = parent.getInt("GRIB2_Hour");
      GRIB2_Layer = parent.getInt("GRIB2_Layer");
      GRIB2_DomainSelection = parent.getInt("GRIB2_DomainSelection");
      GRIB2_TGL_number = parent.getInt("GRIB2_TGL_number");
      AERIAL_graphOption = parent.getInt("AERIAL_graphOption");
      Develop_Option = parent.getInt("Develop_Option");
      Develop_DayHour = parent.getInt("Develop_DayHour");
      //DevelopData_update = Boolean.parseBoolean(parent.getString("DevelopData_update"));
      numberOfLayers = parent.getInt("numberOfLayers");
      Develop_AngleInclination = parent.getFloat("Develop_AngleInclination");
      Develop_AngleOrientation = parent.getFloat("Develop_AngleOrientation");
      DevelopLayer_id = parent.getInt("DevelopLayer_id");
      
      changeCurrentLayerTo(parent.getInt("CurrentLayer_id"));

      Impact_TYPE = parent.getInt("Impact_TYPE");

      COLOR_STYLE_Current = parent.getInt("COLOR_STYLE_Current");
      COLOR_STYLE_Number = parent.getInt("COLOR_STYLE_Number");
      
      CurrentDataSource = parent.getInt("CurrentDataSource");
      DrawnFrame = parent.getInt("DrawnFrame");


  
      Planetary_Magnification = parent.getFloat("Planetary_Magnification");

      
      Camera_Variation = parent.getInt("Camera_Variation");

      Materials_Selection = parent.getInt("Materials_Selection");
      OBJECTS_scale = parent.getFloat("OBJECTS_scale");
      
      FrameVariation = parent.getInt("FrameVariation");
      Language_Active = parent.getInt("Language_Active");
  
      IMPACTS_displayDay = parent.getInt("IMPACTS_displayDay");
      

  
  
      BIOSPHERE_drawResolution = parent.getFloat("BIOSPHERE_drawResolution");
  

    
  
      {
        String new_Default_Font = parent.getString("Default_Font");
        if (Default_Font.equals(new_Default_Font)) {
        } else {
          Default_Font = new_Default_Font;        
          SOLARCHVISION_loadDefaultFontStyle();
        }
      } 
    }
  

    STATION.from_XML(xml);
    
    allPoints.from_XML(xml);
    
    allCurves.from_XML(xml);
  
    allFaces.from_XML(xml);
  
    allGroups.from_XML(xml);
    
    allCameras.from_XML(xml);
    
    allSolids.from_XML(xml);
    
    allSections.from_XML(xml);
    
    allModel1Ds.from_XML(xml);
    
    allModel2Ds.from_XML(xml);    
    
    userSelections.from_XML(xml);
    
    User3D.from_XML(xml);
    
    Land3D.from_XML(xml);  
    
    Earth3D.from_XML(xml);
    
    Sky3D.from_XML(xml);
    
    Tropo3D.from_XML(xml);
    
    Moon3D.from_XML(xml);
    
    Sun3D.from_XML(xml);

    WIN3D.from_XML(xml);    
    
    WORLD.from_XML(xml);
    
    STUDY.from_XML(xml);
    
    allWindRoses.from_XML(xml);
    
    allWindFlows.from_XML(xml);
    
    allSolidImpacts.from_XML(xml);
    
    allSolarImpacts.from_XML(xml);
    
    LAYER_windspd200hPa.from_XML(xml);
    LAYER_thicknesses_1000_500.from_XML(xml);
    LAYER_heightp500hPa.from_XML(xml);
    LAYER_ceilingsky.from_XML(xml);
    LAYER_cloudcover.from_XML(xml);
    LAYER_winddir.from_XML(xml);
    LAYER_windspd.from_XML(xml);
    LAYER_pressure.from_XML(xml);
    LAYER_drybulb.from_XML(xml);
    LAYER_relhum.from_XML(xml);
    LAYER_dirnorrad.from_XML(xml);
    LAYER_difhorrad.from_XML(xml);
    LAYER_glohorrad.from_XML(xml);
    LAYER_direffect.from_XML(xml);
    LAYER_difeffect.from_XML(xml);
    LAYER_precipitation.from_XML(xml);
    LAYER_developed.from_XML(xml);
  
    println("End of loading XML.");
  
  
    // loading only weather data // 
    SOLARCHVISION_update_station(2); 
    SOLARCHVISION_update_station(3);
    SOLARCHVISION_update_station(4);
    SOLARCHVISION_update_station(5);
    ///////////////////////////////
  
    addNewSelectionToPreviousSelection = 0;
    
    addToLastGroup = false;
  
    UI_set_to_Create_Nothing();
  
    WORLD.autoView = true;
  
    WORLD.VIEW_id = WORLD.FindGoodViewport(LocationLON, LocationLAT);
  
    SOLARCHVISION_update_frame_layout();
  
    ROLLOUT.update = true;
    WORLD.update = true;
    WIN3D.update = true; 
    STUDY.update = true;     
    UI_BAR_a.update = true; 
    UI_BAR_b.update = true;
    UI_BAR_d.update = true;
  
  
  
    allSolarImpacts.rebuild_Image_array = true;
    allWindRoses.rebuild_Image_array = true; 
  
    VertexSolar_rebuild_array = true;
    GlobalSolar_rebuild_array = true;
  
    VertexSolar_resize_array(); 
    GlobalSolar_resize_array();
  
  
    SOLARCHVISION_modify_Viewport_Title();
  }
}


void SOLARCHVISION_hold_project () {

  HoldStamp = nf(millis(), 0);

  SOLARCHVISION_save_project(Folder_Project + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml");  
}

void SOLARCHVISION_fetch_project () {
  try {
    SOLARCHVISION_load_project(Folder_Project + "/Temp/" + ProjectName + "_tmp" + HoldStamp + ".xml");
  }
  catch (Exception e) {
    println("Cannot find hold file!");
  }
}

























void SOLARCHVISION_preBakeViewport () {

  cursor(WAIT);  
  
  println("PreBaking Direct and Diffuse Models. Please wait...");  

  Camera_Variation = 0;
  
  allSolarImpacts.sectionType = 1; // <<<<< so that it analyzed later!

  int start_DATE_ANGLE = 0;
  int step_DATE_ANGLE = 15;
  int end_DATE_ANGLE = 360 - step_DATE_ANGLE;
  
  int start_HOUR = 4; // to make it faster. Also the images are not needed out of this period.
  int step_HOUR = 1;
  int end_HOUR = 20; // to make it faster. Also the images are not needed out of this period.

  SceneName = "Viewport_" + Viewport_Stamp();

  int pre_WIN3D_dX = WIN3D.dX; 
  int pre_WIN3D_dY = WIN3D.dY;
 
  WIN3D.dX = allSolarImpacts.RES1;
  WIN3D.dY = allSolarImpacts.RES2;
  WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);

  WIN3D.transform_3DViewport();
  
  //WIN3D.put_3DViewport();  //????????????

  float ScaleToFit = float(pre_WIN3D_dY) / float(WIN3D.dY); 


  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;    

  float[][] Diffuse_Matrix = new float [2][(RES1 * RES2)]; 
  
  for (int SHD = 0; SHD <= 1; SHD++) {
    for (int np = 0; np < (RES1 * RES2); np++) {
      Diffuse_Matrix[SHD][np] = 0; 
    }
  }

  int n_Map = 0; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1;
    }
  } 
  
  PImage[][] Direct_RGBA = new PImage [n_Map][2];


  int[] lastHitDirect = new int [n_Map];
  
  for (int i = 0; i < lastHitDirect.length; i++) {
    lastHitDirect[i] = 0;
  }  

  int[] lastHitDiffuse = new int [DiffuseVectors.length];
  
  for (int i = 0; i < lastHitDiffuse.length; i++) {
    lastHitDiffuse[i] = 0;
  }  


  n_Map = -1; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1; 
      
      for (int SHD = 0; SHD <= 1; SHD++) {

        Direct_RGBA[n_Map][SHD] = createImage(RES1, RES2, ARGB);
        
        Direct_RGBA[n_Map][SHD].loadPixels();
      }
    }
  }
  
  float Progress = 0;

  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    if (1 + Progress < 100 * np / float(RES1 * RES2)) { 
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }
    
    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;
  

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = WIN3D.calculate_Click3D(Image_X * ScaleToFit, Image_Y * ScaleToFit);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];


    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);

    if (RxP[0] >= 0) {        
        
      int f = int(RxP[0]);

      float[] COL = {
        0, 0, 0, 0
      };
      
      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = funcs.vec3_unit(face_norm);
      
      if (funcs.vec_dot(face_norm, ray_direction) > 0) { // to render backing faces 
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }
      
      float Alpha = 90 - funcs.acos_ang(face_norm[2]);
      float Beta = 180 - funcs.atan2_ang(face_norm[0], face_norm[1]);

      float[] VECT = {
        0, 0, 0
      }; 

      if (abs(Alpha) > 89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = 1;
      } else if (Alpha < -89.99) {
        VECT[0] = 0;
        VECT[1] = 0;
        VECT[2] = -1;
      } else {
        VECT[0] = funcs.sin_ang(Beta);
        VECT[1] = -funcs.cos_ang(Beta);
        VECT[2] = funcs.tan_ang(Alpha);
      }   
      
      VECT = funcs.vec3_unit(VECT);
      
      {
        
        for (int n_Ray = 0; n_Ray < DiffuseVectors.length; n_Ray++) { 
  
          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];
          
          ray_direction[0] = DiffuseVectors[n_Ray][0];
          ray_direction[1] = DiffuseVectors[n_Ray][1];
          ray_direction[2] = DiffuseVectors[n_Ray][2];
    
          float SkyMask = funcs.vec_dot(funcs.vec3_unit(DiffuseVectors[n_Ray]), funcs.vec3_unit(VECT));
          //if (SkyMask <= 0) SkyMask = 0; // removes backing faces
         
          // when SHD = 0;
          Diffuse_Matrix[0][np] += SkyMask / float(DiffuseVectors.length);
         
          lastHitDiffuse[n_Ray] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDiffuse[n_Ray]);
            
          // when SHD = 1;            
          if (lastHitDiffuse[n_Ray] == 0) {
            Diffuse_Matrix[1][np] += SkyMask / float(DiffuseVectors.length);
          }
          else Diffuse_Matrix[1][np] += 0;   
        }
      }      

      
      n_Map = -1; 
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
        
        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
          n_Map += 1; 
          
          float HOUR_ANGLE = i;
    
          float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);

          float[] DirectVector = {
            SunR[1], SunR[2], SunR[3]
          };

          // new trace
          ray_start[0] = RxP[1];
          ray_start[1] = RxP[2];
          ray_start[2] = RxP[3];
          
          ray_direction[0] = DirectVector[0];
          ray_direction[1] = DirectVector[1];
          ray_direction[2] = DirectVector[2];

          float SunMask = funcs.vec_dot(funcs.vec3_unit(DirectVector), funcs.vec3_unit(VECT));
          //if (SunMask <= 0) SunMask = 0; // removes backing faces 

          // when SHD = 0;
          Direct_RGBA[n_Map][0].pixels[np] = color(255 * SunMask, 255);
            
          // when SHD = 1;            
          
          lastHitDirect[n_Map] = SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, lastHitDirect[n_Map]);
          
          if (lastHitDirect[n_Map] == 0) { 
            Direct_RGBA[n_Map][1].pixels[np] = color(255 * SunMask, 255);
          }
          else Direct_RGBA[n_Map][1].pixels[np] = color(0, 255);
        }
      }
    }
    else {
      
      n_Map = -1; 
      for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
        
        for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
          n_Map += 1; 
          
          for (int SHD = 0; SHD <= 1; SHD++) {
    
            Direct_RGBA[n_Map][SHD].pixels[np] = color(0,0,0,0);
          
          }
        }
      }     

      for (int SHD = 0; SHD <= 1; SHD++) {

        Diffuse_Matrix[SHD][np] = FLOAT_undefined;
      
      }     
      
    }
    
  }
  
  println("Progress: 100 %");
  
  n_Map = -1; 
  for (int DATE_ANGLE = start_DATE_ANGLE; DATE_ANGLE <= end_DATE_ANGLE; DATE_ANGLE += step_DATE_ANGLE) {
    
    for (int i = start_HOUR; i <= end_HOUR; i += step_HOUR) { 
      n_Map += 1; 

      float HOUR_ANGLE = i;

      for (int SHD = 0; SHD <= 1; SHD++) {

        String[] STR_SHD = {
          "F", "T"
        };
        String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;
  
        File_Name += nf(DATE_ANGLE, 3) + "_" + STR_SHD[SHD] + "_" + nf(int(funcs.roundTo(HOUR_ANGLE * 100, 1.0)), 4);
  
        File_Name += "_Camera" + nf(Camera_Variation, 2);
  
        Direct_RGBA[n_Map][SHD].updatePixels();
        
        Direct_RGBA[n_Map][SHD].save(File_Name + ".png");
        
        println(File_Name + ".png");
      }
    }
  }  

  PImage[] Diffuse_RGBA = new PImage [2];

  for (int SHD = 0; SHD <= 1; SHD++) {
    
    String[] STR_SHD = {
      "F", "T"
    };
    String File_Name = Folder_Shadings + "/" + NearLatitude_Stamp() + "/" + SceneName;

    File_Name += "DIF_" + STR_SHD[SHD];
    
    File_Name += "_Camera" + nf(Camera_Variation, 2);
    
    Diffuse_RGBA[SHD] = createImage(RES1, RES2, ARGB); 
    
    Diffuse_RGBA[SHD].loadPixels();

    for (int np = 0; np < (RES1 * RES2); np++) {
      
      if (is_undefined_FLOAT(Diffuse_Matrix[SHD][np]) == false) {
      
        Diffuse_RGBA[SHD].pixels[np] = color(255 * Diffuse_Matrix[SHD][np], 255);
      }
      else {
        
        Diffuse_RGBA[SHD].pixels[np] = color(0,0,0,0);
      }
    }    

    Diffuse_RGBA[SHD].updatePixels();
    
    
    Diffuse_RGBA[SHD].save(File_Name + ".png");
    
    println(File_Name + ".png");    
  }       



  cursor(ARROW);
  
  WIN3D.dX = pre_WIN3D_dX;
  WIN3D.dY = pre_WIN3D_dY;
  WIN3D.view_R = float(WIN3D.dY) / float(WIN3D.dX);
}






void SOLARCHVISION_RenderViewport () {

  println("Render started!");
  
  int PAL_type = 0; 
  int PAL_direction = 1;
  float PAL_multiplier = 1;   

  if (Impact_TYPE == Impact_ACTIVE) {
    PAL_type = allFaces.ACTIVE_pallet_CLR; 
    PAL_direction = allFaces.ACTIVE_pallet_DIR; 
    PAL_multiplier = 1.0 * allFaces.ACTIVE_pallet_MLT;
  }
  if (Impact_TYPE == Impact_PASSIVE) {  
    PAL_type = allFaces.PASSIVE_pallet_CLR; 
    PAL_direction = allFaces.PASSIVE_pallet_DIR;
    PAL_multiplier = 0.05 * allFaces.PASSIVE_pallet_MLT;
  }     

  
  int RES1 = WIN3D.dX;
  int RES2 = WIN3D.dY;
  
  PImage Image_RGBA = createImage(RES1, RES2, ARGB);

  Image_RGBA.loadPixels();

  float Progress = 0;

   


  for (int np = 0; np < (RES1 * RES2); np++) {
    int Image_X = np % RES1;
    int Image_Y = np / RES1;
    
    Image_X -= 0.5 * WIN3D.dX;
    Image_Y -= 0.5 * WIN3D.dY;

    if (1 + Progress < 100 * np / float(RES1 * RES2)) { 
      Progress = 100 * np / float(RES1 * RES2);
      println("Progress:", int(Progress), "%");
    }

    float[] ray_direction = new float [3];

    float[] ray_start = {
      WIN3D.CAM_x, WIN3D.CAM_y, WIN3D.CAM_z
    };

    float[] ray_end = WIN3D.calculate_Click3D(Image_X, Image_Y);

    ray_start[0] /= OBJECTS_scale;
    ray_start[1] /= OBJECTS_scale;
    ray_start[2] /= OBJECTS_scale;          

    ray_end[0] /= OBJECTS_scale;
    ray_end[1] /= OBJECTS_scale;
    ray_end[2] /= OBJECTS_scale;

    if (WIN3D.ViewType == 0) {
      float[] ray_center = WIN3D.calculate_Click3D(0, 0);

      ray_center[0] /= OBJECTS_scale;
      ray_center[1] /= OBJECTS_scale;
      ray_center[2] /= OBJECTS_scale;

      ray_start[0] += ray_end[0] - ray_center[0];
      ray_start[1] += ray_end[1] - ray_center[1];
      ray_start[2] += ray_end[2] - ray_center[2];
    }

    ray_direction[0] = ray_end[0] - ray_start[0];
    ray_direction[1] = ray_end[1] - ray_start[1];
    ray_direction[2] = ray_end[2] - ray_start[2];



         
  
    float[] RxP = new float [8]; 

    RxP = SOLARCHVISION_intersect_Faces(ray_start, ray_direction);

    if (RxP[0] >= 0) {        
        
      int f = int(RxP[0]);


      float[] COL = {
        0, 0, 0, 0
      };
      
      float[] face_norm = {RxP[5], RxP[6], RxP[7]};
      face_norm = funcs.vec3_unit(face_norm);
      
      if (funcs.vec_dot(face_norm, ray_direction) > 0) { // to render backing faces 
        face_norm[0] *= -1;
        face_norm[1] *= -1;
        face_norm[2] *= -1;
      }

      
      float Alpha = 90 - funcs.acos_ang(face_norm[2]);
      float Beta = 180 - funcs.atan2_ang(face_norm[0], face_norm[1]);

float valuesSUM_RAD = 0;
float valuesSUM_EFF_P = 0;
float valuesSUM_EFF_N = 0;
int valuesNUM = 0; 

float values_R_dir = 1;
float values_R_dif = 1;
float values_E_dir = 0.1;
float values_E_dif = 0.1;


//float[] SunR = SOLARCHVISION_SunPositionRadiation( DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);
float[] SunR = SOLARCHVISION_SunPositionRadiation(0, 12, 0);
float[] VECT = {
  0, 0, 0
}; 

if (abs(Alpha) > 89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = 1;
} else if (Alpha < -89.99) {
  VECT[0] = 0;
  VECT[1] = 0;
  VECT[2] = -1;
} else {
  VECT[0] = funcs.sin_ang(Beta);
  VECT[1] = -funcs.cos_ang(Beta);
  VECT[2] = funcs.tan_ang(Alpha);
}   

VECT = funcs.vec3_unit(VECT);


float[] SunV = {
  SunR[1], SunR[2], SunR[3]
};

float SunMask = funcs.vec_dot(funcs.vec3_unit(SunV), funcs.vec3_unit(VECT));
if (SunMask <= 0) SunMask = 0; // removes backing faces 

float SkyMask = (0.5 * (1.0 + (Alpha / 90.0)));


// new trace
ray_start[0] = RxP[1];
ray_start[1] = RxP[2];
ray_start[2] = RxP[3];

ray_direction[0] = SunV[0];
ray_direction[1] = SunV[1];
ray_direction[2] = SunV[2];

//if (funcs.vec_dot(face_norm, ray_direction) > 0) 
{ // removes backing faces

  if (SOLARCHVISION_isIntersected_Faces(ray_start, ray_direction, 0) != 0) { 
    if (values_E_dir < 0) {
      valuesSUM_EFF_P += -(values_E_dir * SunMask); 
      valuesSUM_EFF_N += -(values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    } else {
      valuesSUM_EFF_N += (values_E_dir * SunMask); 
      valuesSUM_EFF_P += (values_E_dif * SkyMask); // adding approximate diffuse radiation effect anyway!
    }

    valuesSUM_RAD += (values_R_dif * SkyMask); // only approximate diffuse radiation!
  } else { 
    if (values_E_dir < 0) {
      valuesSUM_EFF_N += -((values_E_dir * SunMask) + (values_E_dif * SkyMask));
    } else {
      valuesSUM_EFF_P += ((values_E_dir * SunMask) + (values_E_dif * SkyMask));
    }

    valuesSUM_RAD += ((values_R_dir * SunMask) + (values_R_dif * SkyMask)); // calculates total radiation
  }
}
valuesNUM += 1;

//-----------------------------
float valuesSUM = valuesSUM_RAD; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//-----------------------------
      
      float _u = 0;
    
      if (is_undefined_FLOAT(valuesSUM) == false) {
    
        if (Impact_TYPE == Impact_ACTIVE) _u = (0.1 * PAL_multiplier * valuesSUM);
        if (Impact_TYPE == Impact_PASSIVE) _u = 0.5 + 0.5 * (0.1 * PAL_multiplier * valuesSUM);
    
        if (PAL_direction == -1) _u = 1 - _u;
        if (PAL_direction == -2) _u = 0.5 - 0.5 * _u;
        if (PAL_direction == 2) _u =  0.5 * _u;
      }
    
      COL = PAINT.getColorStyle(PAL_type, _u);

      
      Image_RGBA.pixels[np] = color(COL[1], COL[2], COL[3], COL[0]);
    }
    
    else Image_RGBA.pixels[np] = color(0,0,0,0);
  }

  Image_RGBA.updatePixels();
 
  String myFile = Folder_ScreenShots + "/" + createStamp(1, "Render") + ".png";
  Image_RGBA.save(myFile);
  SOLARCHVISION_explore_output(myFile);
  println("File created:" + myFile);
  
}





float[][] DiffuseVectors;  

void SOLARCHVISION_build_SkySphere (int Tessellation) {

  //allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0,0,0, 1, Tessellation, 1, 90); // SKY
  //allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 4, 1, 90); // SKY
  allModel3Ds.add_CrystalSphere(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1, 90); // SKY

  DiffuseVectors = new float[0][3];

  for (int i = 0; i < skyFaces.length; i++) {

    float x = 0;
    float y = 0;
    float z = 0;

    for (int j = 0; j < skyFaces[i].length; j++) {

      x += skyVertices[skyFaces[i][j]][0] / float(skyFaces[i].length);
      y += skyVertices[skyFaces[i][j]][1] / float(skyFaces[i].length);
      z += skyVertices[skyFaces[i][j]][2] / float(skyFaces[i].length);
      
      if (z > 0) {
        float[][] new_Vector = {{x, y, z}};
        DiffuseVectors = (float[][]) concat(DiffuseVectors, new_Vector);
      }      
    }
  }

}






void setFlag_CurrentDataSource (int i, int j, int k, int Parameter_ID, boolean flag) { 
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_flags[i][j][Parameter_ID][k] = flag; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_flags[i][j][Parameter_ID][k] = flag; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_flags[i][j][Parameter_ID][k] = flag; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_flags[i][j][Parameter_ID][k] = flag; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_flags[i][j][Parameter_ID][k] = flag; 
  }   

}  

void setValue_CurrentDataSource (int i, int j, int k, int Parameter_ID, float value) { 
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    CLIMATE_CWEEDS_values[i][j][Parameter_ID][k] = value; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    CLIMATE_CLMREC_values[i][j][Parameter_ID][k] = value; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    CLIMATE_TMYEPW_values[i][j][Parameter_ID][k] = value; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k] = value; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k] = value; 
  }   

}  


float getValue_CurrentDataSource (int i, int j, int k, int Parameter_ID) { 
  
  float return_value = FLOAT_undefined;
  
  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_values[i][j][Parameter_ID][k]; 
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_values[i][j][Parameter_ID][k]; 
  }        
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_values[i][j][Parameter_ID][k]; 
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_values[i][j][Parameter_ID][k]; 
  }            
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_values[i][j][Parameter_ID][k]; 
  }   

  return return_value;
}  


int getStart_CurrentDataSource () {
  
  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_start;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_start;
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_start;
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_start;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_start;
  }
  
  return return_value;
}

int getEnd_CurrentDataSource () {
  
  int return_value = -1;

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = CLIMATE_CWEEDS_end;
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value = CLIMATE_CLMREC_end;
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = CLIMATE_TMYEPW_end;
  }  
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = ENSEMBLE_FORECAST_end;
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = ENSEMBLE_OBSERVED_end;
  }
  
  return return_value;
}

String getReference_CurrentDataSource () {
  
  String return_value = "";

  if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
    return_value = STATION.getFilename_CWEEDS() + ".wy2" + ", Environment and Climate Change Canada: ftp://ftp.tor.ec.gc.ca/Pub/Normals/";
  }
  else if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
    return_value  = "Environment and Climate Change Canada website at http://climate.weather.gc.ca/climate_data";
  }  
  else if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
    return_value = STATION.getFilename_TMYEPW() + ".epw";
  }    
  else if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
    return_value = nf(TIME.year, 4) + nf(TIME.month, 2) + nf(TIME.day, 2) + nf(TIME.hour, 2) + "_GEPS-NAEFS-RAW_" + STATION.getFilename_NAEFS() + "_" + CurrentLayer_name + "_000-384.xml" + ", Environment and Climate Change Canada: http://dd.weatheroffice.ec.gc.ca/ensemble/naefs/";
  }
  else if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
    return_value = "Environment and Climate Change Canada website at http://dd.weatheroffice.ec.gc.ca/observations/swob-ml/";
  }
  
  return return_value;
}  



void SOLARCHVISION_setDataFlags (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();
  // setting the flags
  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int l = 0; l < numberOfLayers; l++) {
        for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
          if (is_undefined_FLOAT(getValue_CurrentDataSource(i, j, k, l)) == false) {
            setFlag_CurrentDataSource(i, j, k, l, true);
          }
        }
      }
    }
  }  
  
  CurrentDataSource = keep_CurrentDataSource;
}

void SOLARCHVISION_postProcess_fillGaps (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  int MAX_SEARCH = 6; // It defines how many hours the program should seek for each point to find next available data.  

  for (int l = 0; l < numberOfLayers; l++) {

    for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
      float pre_v = FLOAT_undefined;
      int pre_num = 0;

      for (int j = 0; j < 365; j++) { 

        for (int i = 0; i < 24; i++) {
          
          if (is_undefined_FLOAT(getValue_CurrentDataSource(i, j, k, l))) {
            if (is_undefined_FLOAT(pre_v) == false) {
              pre_num += 1;

              float next_v = FLOAT_undefined;
              int next_i = i;
              int next_j = j;
              int next_num = 0;
              while ((next_num < MAX_SEARCH) && (is_undefined_FLOAT(next_v))) {
                next_num += 1;
                next_i += 1;
                if (next_i == 24) {
                  next_i -= 24;
                  next_j += 1;
                }
                if (next_j == 365) {
                  next_j = 0;
                }
                if (is_undefined_FLOAT(getValue_CurrentDataSource(next_i, next_j, k, l)) == false) {
                  next_v = getValue_CurrentDataSource(next_i, next_j, k, l);

                  if (l == LAYER_winddir.id) {
                    if ((next_v - pre_v) > 180) next_v -= 360;
                    if ((next_v - pre_v) < -180) next_v += 360;
                  }
                }
              }
              if (next_num < MAX_SEARCH) {
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, ((next_num * pre_v + pre_num * next_v) / (pre_num + next_num) + 360) % 360);
                else setValue_CurrentDataSource(i, j, k, l, (next_num * pre_v + pre_num * next_v) / (pre_num + next_num));

                float interpolation_pow = pow(2.0, Interpolation_Weight);

                setValue_CurrentDataSource(i, j, k, l, (pow(next_num, interpolation_pow) * pre_v + pow(pre_num, interpolation_pow) * next_v) / (pow(next_num, interpolation_pow) + pow(pre_num, interpolation_pow)));
                if (l == LAYER_winddir.id) setValue_CurrentDataSource(i, j, k, l, (getValue_CurrentDataSource(i, j, k, l) + 360) % 360);
              }
            }
          } else {
            pre_v = getValue_CurrentDataSource(i, j, k, l);
            pre_num = 0;
          }

        }
      }

    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}






void SOLARCHVISION_postProcess_solarsUsingCloud (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();

  for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
    for (int j = 0; j < 365; j++) { 
      for (int i = 0; i < 24; i++) {
        
        float CL = getValue_CurrentDataSource(i, j, k, LAYER_cloudcover.id);
        
        if (is_undefined_FLOAT(CL) == false) {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, CL);

          setValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id, SunR[4]);

          setValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id, SunR[5]);

          setValue_CurrentDataSource(i, j, k, LAYER_glohorrad.id, SunR[4] * SunR[3] + SunR[5]);
        }
          
      }
    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_solarEffects (int desired_DataSource) {
  
  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();


  for (int i = 0; i < 24; i++) {
    for (int j = 0; j < 365; j++) {
      for (int k = 0; k < (1 + DATA_end - DATA_start); k++) {
        
        float T     = getValue_CurrentDataSource(i, j, k, LAYER_drybulb.id);
        float R_dir = getValue_CurrentDataSource(i, j, k, LAYER_dirnorrad.id);
        float R_dif = getValue_CurrentDataSource(i, j, k, LAYER_difhorrad.id);

        if ((is_undefined_FLOAT(T) == false) && (is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) {

          setValue_CurrentDataSource(i, j, k, LAYER_direffect.id, (18 - T) * R_dir);
          setValue_CurrentDataSource(i, j, k, LAYER_difeffect.id, (18 - T) * R_dif);

        }
      }
    }
  }
  
  CurrentDataSource = keep_CurrentDataSource;
}


void SOLARCHVISION_postProcess_climaticSolarForecast () {

  int num_count = (1 + CLIMATE_CWEEDS_end - CLIMATE_CWEEDS_start);

  for (int k = 0; k < (1 + ENSEMBLE_FORECAST_end - ENSEMBLE_FORECAST_start); k++) {
    for (int j_for = 0; j_for < ENSEMBLE_FORECAST_maxDays; j_for++) { 
      int j = ((j_for + TIME.beginDay) % 365);
      for (int i = 0; i < 24; i++) {
        if (is_undefined_FLOAT(ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k])) {
        } else {
          float DATE_ANGLE = (360 * ((286 + j) % 365) / 365.0);
          float HOUR_ANGLE = i; 

          float[] SunR = SOLARCHVISION_SunPositionRadiation(DATE_ANGLE, HOUR_ANGLE, ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k]);

          ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = SunR[4];

          ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = SunR[5];

          ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = SunR[4] * SunR[3] + SunR[5];

          //---------------------------------------------------------------------

          float Forecast_CC = ENSEMBLE_FORECAST_values[i][j][LAYER_cloudcover.id][k];
          float Forecast_AP = ENSEMBLE_FORECAST_values[i][j][LAYER_pressure.id][k];

          float CC_epsilon = 1.0; // defines a range for finding near previous results: 1.0 results in e.g. 2 < CC < 4 for CC at 3  
          float AP_epsilon = 50.0;

          float valuesSUM_DIR = 0;
          float valuesSUM_DIF = 0;
          float valuesSUM_GLO = 0;
          float sum_count = 0;

          float process_add_days = 11;

          for (int q = 0; q < num_count; q++) {

            for (int j_ADD = 0; j_ADD < process_add_days; j_ADD++) { 

              int now_i = i;
              int now_j = int(j + (j_ADD - int(0.5 * process_add_days)) + 365) % 365;

              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }


              if ((is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q])) || (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]))) {
              } else {
                float CC_dist = abs(Forecast_CC - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_cloudcover.id][q]);
                float AP_dist = abs(Forecast_AP - CLIMATE_CWEEDS_values[now_i][now_j][LAYER_pressure.id][q]);
                if ((CC_dist < CC_epsilon) && (AP_dist < AP_epsilon)) {

                  float _weight;

                  _weight = 1; 
                  _weight *= pow(abs(1 - pow(CC_dist/CC_epsilon, 2)), 2); // to add more wights to closer cases
                  _weight *= pow(abs(1 - pow(AP_dist/AP_epsilon, 2)), 2);

                  sum_count += _weight;

                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q])) {
                  } else valuesSUM_DIR += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_dirnorrad.id][q]; 
                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q])) {
                  } else valuesSUM_DIF += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_difhorrad.id][q]; 
                  if (is_undefined_FLOAT(CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q])) {
                  } else valuesSUM_GLO += _weight * CLIMATE_CWEEDS_values[now_i][now_j][LAYER_glohorrad.id][q];
                }
              }
            }
          }

          if (sum_count != 0) {
            valuesSUM_DIR /= sum_count;
            valuesSUM_DIF /= sum_count;
            valuesSUM_GLO /= sum_count;

            ENSEMBLE_FORECAST_values[i][j][LAYER_dirnorrad.id][k] = valuesSUM_DIR;
            ENSEMBLE_FORECAST_values[i][j][LAYER_difhorrad.id][k] = valuesSUM_DIF;
            ENSEMBLE_FORECAST_values[i][j][LAYER_glohorrad.id][k] = valuesSUM_GLO;
          } else {
            println("Cannot find simillar conditions in climate file at i:", i, ", j:", j, ", k:", k);
          }

        }
      }
    }
  }
}




void SOLARCHVISION_postProcess_developDATA (int desired_DataSource) {

  int keep_CurrentDataSource = CurrentDataSource;
  
  CurrentDataSource = desired_DataSource;  
  
  float keep_STUDY_perDays = STUDY.perDays;
  int keep_STUDY_joinDays = STUDY.joinDays;
  
  if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
    STUDY.perDays = 1;
    STUDY.joinDays = 1;
  }

  int DATA_start = getStart_CurrentDataSource();
  int DATA_end = getEnd_CurrentDataSource();
  
  int count_k = 1 + DATA_end - DATA_start; 
  if (count_k > 0) {
  
    float Pa = FLOAT_undefined;
    float Pb = FLOAT_undefined;
    float RAIN, T, WS, R_dir, R_dif;
  
    float[] valuesSUM; 
    valuesSUM = new float [count_k];
  
    for (int k = 0; k < count_k; k++) {
      valuesSUM[k] = FLOAT_undefined;
    }
  
    for (int j = STUDY.j_Start; j <= STUDY.j_End; j++) { 
      for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {
        for (int k = 0; k < count_k; k++) {
          for (int i = 0; i < 24; i++) {
  
            int now_k = k;
            int now_i = i;
            int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
            if (now_j >= 365) {
              now_j = now_j % 365;
            }
            if (now_j < 0) {
              now_j = (now_j + 365) % 365;
            }
  
            int next_i = now_i + 12;
            int next_j = now_j;
            int next_k = now_k;
            if (next_i >= 24) {
              next_i = next_i - 24; 
              next_j += 1; 
              if (next_j >= 365) {
                next_j = next_j % 365;
              }
            }
  
  
            int pre_i = now_i - 12;
            int pre_j = now_j;
            int pre_k = now_k;
            if (pre_i < 0) {
              pre_i = pre_i + 24; 
              pre_j -= 1; 
              if (pre_j < 0) {
                pre_j = (pre_j + 365) % 365;
              }
            }       

  
            setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, FLOAT_undefined);
  
            T = FLOAT_undefined;
            R_dir = FLOAT_undefined;
            R_dif = FLOAT_undefined;
  
            if ((i == 0) && (j == STUDY.j_Start)) valuesSUM[now_k] = 0; 
  
  
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_dirnorrad.id);
            
            if (is_undefined_FLOAT(Pa)) {
              R_dir = FLOAT_undefined;
            } else {
              R_dir = Pa;
            }
            
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_difhorrad.id);
            
            if (is_undefined_FLOAT(Pa)) {
              R_dif = FLOAT_undefined;
            } else {
              R_dif = Pa;
            }
            
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_drybulb.id);
            
            if (is_undefined_FLOAT(Pa)) {
              T = FLOAT_undefined;
            } else {
              T = Pa;
            }
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_windspd.id);
            
            if (is_undefined_FLOAT(Pa)) {
              WS = FLOAT_undefined;
            } else {
              WS = Pa;
            }        
  
            Pa = getValue_CurrentDataSource(now_i, now_j, now_k, LAYER_precipitation.id);
            Pb = getValue_CurrentDataSource(next_i, next_j, now_k, LAYER_precipitation.id);
            
            if ((is_undefined_FLOAT(Pa)) || (is_undefined_FLOAT(Pb))) {
              RAIN = FLOAT_undefined;
            } else {
              RAIN = Pb - Pa;
              //RAIN = Pa - Pb;
  
              if (T <= 0) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Lewis
              //if ((T < 5) && (T > -5)) RAIN *= -1;  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Mojtaba
            }    
  
  
            float DATE_ANGLE = (360 * ((286 + now_j) % 365) / 365.0);
            float HOUR_ANGLE = now_i; 
  
            float[] SunR = SOLARCHVISION_SunPosition(STATION.getLatitude(), DATE_ANGLE, HOUR_ANGLE);
  
  
  
  
  
  
            if (Develop_Option == DEV_OP_00) {  
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                if (Materials_DirectArea_Flags[now_i][now_j] == -1) {
                  valuesSUM[now_k] = FLOAT_undefined;
                } else {
                  valuesSUM[now_k] = 0.001 * (R_dir * Materials_DirectArea_Data[Materials_Selection][now_i][now_j] + R_dif * Materials_DiffuseArea_Data[Materials_Selection][now_i][now_j]);
                }
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.5;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "KW";
              LAYER_developed.descriptions[Language_EN] = "Direct radiation on surfaces with material #" + String.valueOf(Materials_Selection);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }         
  
  
            if (Develop_Option == DEV_OP_01) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;
  
  
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_02) {
              float Alpha = Develop_AngleInclination;
              float Beta = Develop_AngleOrientation;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * valuesSUM[now_k]);
              }
  
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on inclination_" + String.valueOf(Alpha) + "_South-Deviation_" + String.valueOf(Beta);
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_03) {
              float Alpha = funcs.asin_ang(SunR[3]);
              float Beta = funcs.atan2_ang(SunR[2], SunR[1]) + 90;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                valuesSUM[now_k] = SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.1;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }         
  
            if (Develop_Option == DEV_OP_04) {
              float Alpha = funcs.asin_ang(SunR[3]);
              float Beta = funcs.atan2_ang(SunR[2], SunR[1]) + 90;
  
              if ((is_undefined_FLOAT(R_dir) == false) && (is_undefined_FLOAT(R_dif) == false)) { 
  
                valuesSUM[now_k] += SOLARCHVISION_SolarAtSurface(SunR[1], SunR[2], SunR[3], R_dir, R_dif, Alpha, Beta, GlobalAlbedo);
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, 0.001 * valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = -40;
              LAYER_developed.V_belowLine = 1;
              LAYER_developed.unit = "kWh/m²";
              LAYER_developed.descriptions[Language_EN] = "Accumulated radiation on solar tracker";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_05) {
  
              if (is_undefined_FLOAT(T) == false) { 
                valuesSUM[now_k] += (T - 18) / 24;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 1.0;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = -1;
              LAYER_developed.unit = "°C";
              LAYER_developed.descriptions[Language_EN] = "Accumulated degree day (based on 18°C)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_06) {
  
              valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = 1; _count <= num_count; _count++) {
  
                int plus_i = - (_count - 1);
  
                int new_k = k;
                int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }
  
                float T_new = FLOAT_undefined;
  
                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                if (is_undefined_FLOAT(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }            
  
                if (is_undefined_FLOAT(T_new) == false) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  valuesSUM[now_k] += _weight * T_new;
                }
              } 
  
              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
  
              valuesSUM[now_k] = 0;
  
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour PASSIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }     
  
  
            if (Develop_Option == DEV_OP_07) {
  
              valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = 1; _count <= ceil ( (num_count + 1) / 2); _count++) {
                for (int dir_count = -1; dir_count <= 1; dir_count += 2) {
  
                  int plus_i = dir_count * (_count - 1);
  
                  int new_k = k;
                  int new_i = ((i + plus_i) + 24 * 365 + 24 * (floor((i + plus_i) / 24.0))) % 24;
                  int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                  if (new_j >= 365) {
                    new_j = new_j % 365;
                  }
                  if (now_j < 0) {
                    new_j = (new_j + 365) % 365;
                  }
  
                  float T_new = FLOAT_undefined;
                  
                  Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                  if (is_undefined_FLOAT(Pa)) {
                    T_new = FLOAT_undefined;
                  } else {
                    T_new = Pa;
                  }            
  
                  if (is_undefined_FLOAT(T_new) == false) {
                    float _weight = (num_count - _count + 1);
                    if (STUDY.TrendJoinType == 1) _weight = 1;
                    sum_count += _weight;
                    valuesSUM[now_k] += _weight * T_new;
                  }
                }
              } 
  
              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
  
              valuesSUM[now_k] = 0;
  
  
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour NORMAL trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            }           
  
            if (Develop_Option == DEV_OP_08) {
  
              valuesSUM[now_k] = 0;
              float sum_count = 0;
  
              int num_count = STUDY.TrendJoinHours;
  
  
              for (int _count = num_count; _count > 0; _count--) {
  
                int plus_i = _count - 1;
  
                int new_k = k;
                int new_i = ((i + plus_i) + 24 * floor((i + plus_i) / 24.0)) % 24;
                int new_j = (j + TIME.beginDay + 365 + floor((i + plus_i) / 24.0)) % 365;
  
                if (new_j >= 365) {
                  new_j = new_j % 365;
                }
                if (now_j < 0) {
                  new_j = (new_j + 365) % 365;
                }
  
                float T_new = FLOAT_undefined;
  
                Pa = getValue_CurrentDataSource(new_i, new_j, new_k, DevelopLayer_id);
  
                if (is_undefined_FLOAT(Pa)) {
                  T_new = FLOAT_undefined;
                } else {
                  T_new = Pa;
                }            
  
                if (is_undefined_FLOAT(T_new) == false) {
                  float _weight = (num_count - _count + 1);
                  if (STUDY.TrendJoinType == 1) _weight = 1;
                  sum_count += _weight;
                  valuesSUM[now_k] += _weight * T_new;
                }
              } 
  
              if (sum_count != 0) {
                valuesSUM[now_k] /= sum_count;
              } else {
                valuesSUM[now_k] = FLOAT_undefined;
              }
              setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
  
              valuesSUM[now_k] = 0;
  
 
              LAYER_developed.descriptions[Language_EN] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_EN];
              LAYER_developed.descriptions[Language_FR] = String.valueOf(STUDY.TrendJoinHours) + "-hour ACTIVE trend of " + CurrentLayer_descriptions[Language_FR]; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_09) {
  
              if (is_undefined_FLOAT(RAIN) == false) { 
                valuesSUM[now_k] = RAIN;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.5;
              LAYER_developed.V_offset = 0; //-20.0 / (1.0 * STUDY.LevelPix); // so that we can have two views on probabilites above and below zero.
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/12hours";
              LAYER_developed.descriptions[Language_EN] = "12-hour Surface Accumulated Precipitation";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
            if (Develop_Option == DEV_OP_10) {
  
              if (is_undefined_FLOAT(RAIN) == false) { 
                valuesSUM[now_k] = RAIN;
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 2.0; //4.0;
              LAYER_developed.V_offset = 0; 
              LAYER_developed.V_belowLine = 0; //1;
              LAYER_developed.unit = "mm/h";
              LAYER_developed.descriptions[Language_EN] = "Hourly Surface Precipitation (interpolated)";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            } 
  
  
            if (Develop_Option == DEV_OP_11) {
  
              if (is_undefined_FLOAT(WS) == false) { 
  
                valuesSUM[now_k] = 0.5 * 1.23 * 1 * pow(WS / 3.6, 3); 
  
                setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
              }
  
              LAYER_developed.V_scale = 0.05;
              LAYER_developed.V_offset = 0;
              LAYER_developed.V_belowLine = 0;
              LAYER_developed.unit = "W/m²";
              LAYER_developed.descriptions[Language_EN] = "Wind power";
              LAYER_developed.descriptions[Language_FR] = "?"; // ??
            }    
  
  
  
  
  
  
            if ((Develop_Option == DEV_OP_02) || (Develop_Option == DEV_OP_04)) {
  
              if ((i == 23) && (Develop_DayHour == 1)) {
                for (int l = i + 1 - 24; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 24;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/day";
  
                valuesSUM[now_k] = 0;
              }
  
              if (((i == 11) || (i == 23)) && (Develop_DayHour == 2)) {
                for (int l = i + 1 - 12; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 12;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/12hours";
  
                valuesSUM[now_k] = 0;
              }   
  
              if (((i == 5) || (i == 11) || (i == 17) || (i == 23)) && (Develop_DayHour == 3)) {
                for (int l = i + 1 - 6; l <= i; l++) {
                  setValue_CurrentDataSource(now_i, now_j, now_k, LAYER_developed.id, valuesSUM[now_k]);
                }
                //STUDY.sumInterval = 6;
                LAYER_developed.V_scale = 10;
                LAYER_developed.V_offset = 0;
                LAYER_developed.V_belowLine = 0;
                LAYER_developed.unit += "/6hours";
  
                valuesSUM[now_k] = 0;
              }
            }
          }
        }
      }
    }
  }
  
  println("developDATA updated!");

  DevelopData_update = false;  

  STUDY.perDays = keep_STUDY_perDays;
  STUDY.joinDays = keep_STUDY_joinDays;
 
  CurrentDataSource = keep_CurrentDataSource; 
}





















class solarchvision_UI_BAR_a {
  
  private final static String CLASS_STAMP = "UI_BAR_a";
  
  boolean update = true;
  
  float width_parent = 4 * SOLARCHVISION_pixel_A;
  float width_child = 3.5 * 4 * SOLARCHVISION_pixel_A;
  
  int selected_parent = -1;
  int selected_child = 0;
  
  String[][] Items = {
    {
      "SOLARCHVISION-" + SOLARCHVISION_version, 
      "Designed & developed by", 
      "Mojtaba Samimi", 
      "www.solarchvision.com"
    }
    , 
    {
      "Project", 
      "New", 
      "Save", 
      "Hold", 
      "Fetch", 
      "Open...", 
      "Save As...", 
      "Export 3D-Model > SCR", 
      "Export 3D-Model > RAD", 
      "Export 3D-Model > HTML", 
      "Export 3D-Model > OBJ", 
      "Export 3D-Model > OBJ (date-series)", 
      "Export 3D-Model > OBJ (time-series)", 
      "Import 3D-Model...", 
      "Execute CommandFile...", 
      "Preferences", 
      "Quit"
    }
    , 
    {
      "Site", 
      "update Station", 
      "Load Land Mesh", 
      "Load Land Texture", 
      "Download Land Mesh", 
      "Download Land Texture", 
      "Download Toroposphere", 
      "Download NAEFS", 
      "Download SWOB", 
      "Download CLMREC", 
      "Download Aerial" 
    }
    , 
    {
      "Data", 
      "Typical Year (TMY)", 
      "Long-term (CWEEDS)", 
      "Long-term (CLMREC)", 
      "Real-time Observed (SWOB)", 
      "Weather Forecast (NAEFS)", 
      "update NAEFS", 
      "update SWOB", 
      "update CLMREC", 
      "update CWEEDS", 
      "update TMYEPW", 
      "update Aerial"
    }
    , 
    {
      "View", 
      "Camera >> Viewport", 
      "GoTo Selected Camera", 
      "Top", 
      "Front", 
      "Left", 
      "Back", 
      "Right", 
      "Bottom", 
      "S.W.", 
      "S.E.", 
      "N.E.", 
      "N.W.", 
      "Display All Viewports", 
      "Enlarge 3D Viewport", 
      "Enlarge Map Viewport", 
      "Enlarge Time Viewport", 
      "Perspective", 
      "Orthographic", 
      "Zoom", 
      "Zoom as default", 
      "Look at origin", 
      "Look at direction", 
      "Look at selection", 
      "Pan", 
      "PanX", 
      "PanY", 
      "LandOrbit", 
      "Orbit", 
      "OrbitXY", 
      "OrbitZ", 
      "CameraRoll", 
      "CameraRollXY", 
      "CameraRollZ", 
      "TargetRoll", 
      "TargetRollXY", 
      "TargetRollZ", 
      "TruckX", 
      "TruckY", 
      "TruckZ", 
      "DistZ", 
      "DistMouseXY", 
      "CameraDistance", 
      "3DModelSize", 
      "SkydomeSize"
    }
    , 
    {    
      "Display2D",
      "Display/Hide SWOB points", 
      "Display/Hide SWOB nearest", 
      "Display/Hide NAEFS points", 
      "Display/Hide NAEFS nearest", 
      "Display/Hide CWEEDS points", 
      "Display/Hide CWEEDS nearest", 
      "Display/Hide CLMREC points", 
      "Display/Hide CLMREC nearest", 
      "Display/Hide TMYEPW points", 
      "Display/Hide TMYEPW nearest"
    }
    , 
    {
      "Display3D", 
      "Display/Hide Land Mesh", 
      "Display/Hide Land Texture", 
      "Display/Hide Land Points", 
      "Display/Hide Land Depth", 
      "Display/Hide Vertices", 
      "Display/Hide Edges", 
      "Display/Hide Normals", 
      "Display/Hide Leaves", 
      "Display/Hide Model1Ds",
      "Display/Hide Model2Ds",
      "Display/Hide Curves", 
      "Display/Hide Faces", 
      "Display/Hide Solids", 
      "Display/Hide Sections", 
      "Display/Hide Cameras", 
      "Display/Hide Sky", 
      "Display/Hide Sun Grid",
      "Display/Hide Sun Path", 
      "Display/Hide Sun Pattern", 
      "Display/Hide Sun Surface", 
      "Display/Hide Moon Surface", 
      "Display/Hide Troposphere", 
      "Display/Hide Earth Surface", 
      "Display/Hide Solar Section", 
      "Display/Hide Solid Section", 
      "Display/Hide Wind Flow", 
      "Display/Hide Selected Solids", 
      "Display/Hide Selected Sections", 
      "Display/Hide Selected Cameras", 
      "Display/Hide Selected LandPoints", 
      "Display/Hide Selected Faces", 
      "Display/Hide Selected Faces Vertex Count", 
      "Display/Hide Selected Curves Vertex Count", 
      "Display/Hide Selected Vertices", 
      "Display/Hide Selected REF Pivot", 
      "Display/Hide Selected Group Pivot", 
      "Display/Hide Selected Group Edges", 
      "Display/Hide Selected Group Box", 
      "Display/Hide Selected 2D Edges", 
      "Display/Hide Selected 1D Edges", 
    }
    , 
    {
      "Shade", 
      "Shade Surface Wire", 
      "Shade Surface Base", 
      "Shade Surface White", 
      "Shade Surface Materials", 
      "Shade Global Solar", 
      "Shade Vertex Solar", 
      "Shade Vertex Solid", 
      "Shade Vertex Elevation"
    }
    , 
    {
      "Study", 
      "Wind pattern (active)", 
      "Wind pattern (passive)", 
      "Urban solar potential (active)", 
      "Urban solar potential (passive)", 
      "Orientation potential (active)", 
      "Orientation potential (passive)", 
      "Hourly sun position (active)", 
      "Hourly sun position (passive)", 
      "View from sun & sky (active)", 
      "View from sun & sky (passive)", 
      "Annual cycle sun path (active)", 
      "Annual cycle sun path (passive)", 
      "Render Viewport", 
      "PreBake Viewport", 
      "Pre-bake Selected Sections", 
      "Process Active Impact", 
      "Process Passive Impact", 
      "Process Solid Impact", 
      "Run wind 3D-model"
    }
    , 
    {
      "Layers"
    }
    , // Parameters 
    {
      "Layout", 
      "Layout -2", 
      "Layout -1", 
      "Layout 0", 
      "Layout 1", 
      "Layout 2", 
      "Layout 3", 
      "Layout 4", 
      "Layout 5", 
      "Layout 6", 
      "Layout 7", 
      "Layout 8", 
      "Layout 9", 
      "Layout 10", 
      "Layout 11", 
      "Layout 12", 
      "Layout 13", 
      "Layout 14"
    }
    , 
    {
      "Create", 
      "Begin New Group at Origin", 
      "Begin New Group at Pivot", 
      "LandMesh >> Group", 
      "LandGap >> Group", 
      "Viewport >> Camera", 
      "Camera", 
      "Section", 
      "Solid", 
      "Point", 
      "Spline", 
      "Surface", 
      "3D-Tree", 
      "2D-Tree", 
      "Person", 
      "House1", 
      "House2", 
      "Box", 
      "Cushion", 
      "Cylinder", 
      "Sphere", 
      "Octahedron", 
      "Icosahedron", 
      "Tri", 
      "Hyper", 
      "Plane", 
      "Poly", 
      "Extrude", 
      "Parametric 1", 
      "Parametric 2", 
      "Parametric 3", 
      "Parametric 4", 
      "Parametric 5", 
      "Parametric 6", 
      "Parametric 7", 
      "Get dX", 
      "Get dY", 
      "Get dZ", 
      "Get dXYZ", 
      "Get dXY", 
      "Get Angle"
    }
    , 
    {
      "Select", 
      "Reverse Selection", 
      "Deselect All", 
      "Select All", 
      "Select Solid", 
      "Select Section", 
      "Select Camera", 
      "Select LandPoint", 
      "Select Model1Ds", 
      "Select Model2Ds", 
      "Select Group", 
      "Select Face", 
      "Select Curve", 
      "Select Vertex", 
      "Soft Selection", 
      "Group >> Vertex", 
      "Group >> Curve", 
      "Group >> Face", 
      "Group >> Solid", 
      "Group >> Model2Ds", 
      "Group >> Model1Ds", 
      "Model1Ds >> Group", 
      "Model2Ds >> Group", 
      "Solid >> Group", 
      "Face >> Group", 
      "Curve >> Group", 
      "Vertex >> Group", 
      "Vertex >> Face", 
      "Face >> Vertex", 
      "Click Select", 
      "Click Select+", 
      "Click Select-", 
      "Window Select", 
      "Window Select+", 
      "Window Select-", 
      "Select Near Selected Vertices", 
      "Select All Isolated Vertices"
    }
    ,
   
    {
      "Edit", 
      "Duplicate Selection (Identical)", 
      "Duplicate Selection (Variation)", 
      "Attach to Last Group", 
      "Dettach from All Groups", 
      "Group Selection", 
      "Ungroup Selection", 
      "Delete All Empty Groups", 
      "Delete Selection", 
      "Delete All Isolated Vertices", 
      "Delete Isolated Selected Vertices", 
      "Separate Selected Vertices", 
      "Reposition Selected Vertices", 
      "Weld Objects Selected Vertices", 
      "Weld Scene Selected Vertices", 
      "Offset(above) Vertices", 
      "Offset(below) Vertices", 
      "Offset(expand) Vertices", 
      "Offset(shrink) Vertices", 
      "Extrude Face Edges", 
      "Extrude Curve Edges", 
      "Optimize Faces",
      //"Triangulate Faces",
      "Tessellation Triangular", 
      "Tessellate Rectangular", 
      "Tessellate Rows & Columns", 
      "Auto-Normal Selected Faces", 
      "Force Triangulate Selected Faces", 
      "Insert Corner Opennings", 
      "Insert Parallel Opennings", 
      "Insert Rotated Opennings", 
      "Insert Edge Opennings", 
      "Reverse Visibility of All Faces", 
      "Hide All Faces", 
      "Hide Selected Faces", 
      "Unhide Selected Faces", 
      "Unhide All Faces", 
      "Isolate Selection", 
      "Reverse Visibility of All Curves", 
      "Hide All Curves", 
      "Hide Selected Curves", 
      "Unhide Selected Curves", 
      "Unhide All Curves", 
      "Flatten Selected LandPoints"
    }
    , 
    {
      "Modify", 
      "Move", 
      "MoveX", 
      "MoveY", 
      "MoveZ", 
      "Rotate", 
      "RotateX", 
      "RotateY", 
      "RotateZ", 
      "Scale", 
      "ScaleX", 
      "ScaleY", 
      "ScaleZ", 
      "Power", 
      "PowerX", 
      "PowerY", 
      "PowerZ", 
      "Flip Normal", 
      "Set-Out Normal", 
      "Set-In Normal", 
      "Get FirstVertex", 
      "Change Seed/Material", 
      "Change Tessellation", 
      "Change Layer", 
      "Change Visibility", 
      "Change Weight", 
      "Change DegreeMax", 
      "Change DegreeDif", 
      "Change DegreeMin", 
      "Change TrunkSize", 
      "Change LeafSize"
    }
    , 
    {
      "Match", 
      "Save Current ReferenceBox", 
      "Reset Saved ReferenceBox", 
      "Use Selection ReferenceBox", 
      "Use Origin ReferenceBox", 
      "PivotX:Minimum", 
      "PivotX:Center", 
      "PivotX:Maximum", 
      "PivotY:Minimum", 
      "PivotY:Center", 
      "PivotY:Maximum", 
      "PivotZ:Minimum", 
      "PivotZ:Center", 
      "PivotZ:Maximum", 
      "Pick Seed/Material", 
      "Pick Tessellation", 
      "Pick Layer", 
      "Pick Visibility", 
      "Pick DegreeMax", 
      "Pick DegreeDif", 
      "Pick DegreeMin", 
      "Pick TrunkSize", 
      "Pick LeafSize", 
      "Pick Model1DsProps", 
      "Assign Seed/Material", 
      "Assign Tessellation", 
      "Assign Layer", 
      "Assign Visibility", 
      "Assign DegreeMax", 
      "Assign DegreeDif", 
      "Assign DegreeMin", 
      "Assign TrunkSize", 
      "Assign LeafSize", 
      "Assign Model1DsProps", 
      "Assign Pivot", 
      "Drop on LandSurface", 
      "Drop on ModelSurface (Up)", 
      "Drop on ModelSurface (Down)"
    }
    , 
    {
      "Action", 
      "Undo", 
      "Redo", 
      "JPG Time Graph", 
      "PDF Time Graph", 
      "JPG Location Graph", 
      "PDF Location Graph", 
      "JPG 3D Graph", 
      "JPG 3D Full-Period",
      "Screenshot", 
      "Screenshot+Click", 
      "Screenshot+Drag", 
      "REC. Time Graph", 
      "REC. Location Graph", 
      "REC. Solid Graph", 
      "REC. Screenshot", 
      "Stop REC.", 
      "Erase All Model1Ds", 
      "Erase All Model2Ds", 
      "Erase All Groups", 
      "Erase All Solids", 
      "Erase All Sections", 
      "Erase All Cameras", 
      "Erase Faces", 
      "Erase Curves", 
      "Erase All "
    }
  };
  
  
  
  
  
  final int LayersID_in_Bar = 8; 

  solarchvision_UI_BAR_a () { // constructor
  
    this.Items[LayersID_in_Bar] = new String [numberOfLayers + 12];
  
    this.Items[LayersID_in_Bar][0] = "Layers";
  
    for (int i = 0; i < numberOfLayers; i++) {
  
      this.Items[LayersID_in_Bar][i + 1] = allLayers[i].descriptions[Language_EN];
    }
  
    this.Items[LayersID_in_Bar][numberOfLayers + 0] = "12h accumulated Precipitation";
    this.Items[LayersID_in_Bar][numberOfLayers + 1] = "Hourly precipitation";
    this.Items[LayersID_in_Bar][numberOfLayers + 2] = "Wind power";  
    this.Items[LayersID_in_Bar][numberOfLayers + 3] = "Accumulated degree day <18°C<";
    this.Items[LayersID_in_Bar][numberOfLayers + 4] = "Accumulated radiation on tracker";
    this.Items[LayersID_in_Bar][numberOfLayers + 5] = "Accumulated radiation on surface";
    this.Items[LayersID_in_Bar][numberOfLayers + 6] = "Radiation on surface inclination";
    this.Items[LayersID_in_Bar][numberOfLayers + 7] = "Radiation on solar tracker";
    this.Items[LayersID_in_Bar][numberOfLayers + 8] = "Radiation on surface material";
    this.Items[LayersID_in_Bar][numberOfLayers + 9] = "Normal trend of parameter";
    this.Items[LayersID_in_Bar][numberOfLayers + 10] = "Passive trend of parameter";
    this.Items[LayersID_in_Bar][numberOfLayers + 11] = "Active trend of parameter";
  }

  
  void draw () {
    
    if (this.update) {
  
      //println("update BAR!");
  
      this.update = false;
  
      fill(127);
      noStroke();
  
      rect(0, 0, width, SOLARCHVISION_pixel_A);
  
      STUDY.X_control = 0; //0.25 * MessageSize;
      STUDY.Y_control = 0.5 * SOLARCHVISION_pixel_A;
  
      for (int i = 0; i < this.Items.length; i++) {
  
        float cx = STUDY.X_control + i * this.width_parent;
        float cy = STUDY.Y_control;
        float cr = 0.5 * SOLARCHVISION_pixel_A; 
  
        if (i > 0) cx += 1.5 * this.width_parent; // to include SOLARCHVISION title     
  
        if (isInside(mouseX, mouseY, cx, cy - cr, cx + this.width_parent, cy + cr) == 1) {
  
          if (this.selected_parent == -1) {
  
            pre_screen = get(0, SOLARCHVISION_pixel_A, width, height - SOLARCHVISION_pixel_A);
  
            //println("Screen GET!");
          }     
  
          this.selected_parent = i;
  
          this.selected_child = 0;
        }     
  
  
        textAlign(LEFT, CENTER);   
  
        if (this.selected_parent == i) {
  
          stroke(0); 
          fill(0);
          textSize(1.25 * MessageSize);
        } else {
          stroke(255); 
          fill(255);
          textSize(1.25 * MessageSize);
        }
  
        text(this.Items[i][0], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize);
  
  
  
        if (this.selected_parent == i) {
  
          image(pre_screen, 0, SOLARCHVISION_pixel_A);
  
          this.selected_child = 0; 
  
          for (int j = 1; j < this.Items[this.selected_parent].length; j++) {
  
            if (isInside(UI_X_moved, UI_Y_moved, cx, cy - cr + j * SOLARCHVISION_pixel_A, cx + this.width_child, cy + cr + j * SOLARCHVISION_pixel_A) == 1) {
  
              this.selected_child = j;
  
              fill(255, 127, 0);
              noStroke();
              rect(cx, cy - cr + j * SOLARCHVISION_pixel_A, this.width_child, SOLARCHVISION_pixel_A);
            } else {
  
              fill(0, 223);
              noStroke();
              rect(cx, cy - cr + j * SOLARCHVISION_pixel_A, this.width_child, SOLARCHVISION_pixel_A);
            }
  
            textAlign(LEFT, CENTER);
  
            if (this.selected_child == j) {
  
              stroke(0); 
              fill(0);
            } else {
              stroke(255); 
              fill(255);
  
              if (this.Items[i][0].equals("Display2D")) {
                if (this.Items[i][j].equals("Display/Hide SWOB points")) {
                  if (WORLD.displayAll_SWOB == 0) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide SWOB nearest")) {
                  if (WORLD.displayNear_SWOB == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide NAEFS points")) {
                  if (WORLD.displayAll_NAEFS == 0) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide NAEFS nearest")) {
                  if (WORLD.displayNear_NAEFS == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CWEEDS points")) {
                  if (WORLD.displayAll_CWEEDS == 0) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CWEEDS nearest")) {
                  if (WORLD.displayNear_CWEEDS == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CLMREC points")) {
                  if (WORLD.displayAll_CLMREC == 0) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide CLMREC nearest")) {
                  if (WORLD.displayNear_CLMREC == false) {
                    stroke(127); 
                    fill(127);
                  }
                }              
                if (this.Items[i][j].equals("Display/Hide TMYEPW points")) {
                  if (WORLD.displayAll_TMYEPW == 0) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide TMYEPW nearest")) {
                  if (WORLD.displayNear_TMYEPW == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
              }
  
              if (this.Items[i][0].equals("Display3D")) {
                if (this.Items[i][j].equals("Display/Hide Land Mesh")) {
                  if (Land3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }       
                if (this.Items[i][j].equals("Display/Hide Land Texture")) {
                  if (Land3D.displayTexture == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Land Points")) {
                  if (Land3D.displayPoints == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Land Depth")) {
                  if (Land3D.displayDepth == false) {
                    stroke(127); 
                    fill(127);
                  }
                }  
                if (this.Items[i][j].equals("Display/Hide Vertices")) {
                  if (allPoints.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }              
                if (this.Items[i][j].equals("Display/Hide Edges")) {
                  if (allFaces.displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                } 
                if (this.Items[i][j].equals("Display/Hide Normals")) {
                  if (allFaces.displayNormals == false) {
                    stroke(127); 
                    fill(127);
                  }
                }               
                if (this.Items[i][j].equals("Display/Hide Leaves")) {
                  if (allModel1Ds.displayLeaves == false) {
                    stroke(127); 
                    fill(127);
                  }
                }  
                if (this.Items[i][j].equals("Display/Hide Model1Ds")) {
                  if (allModel1Ds.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }               
                if (this.Items[i][j].equals("Display/Hide Model2Ds")) {
                  if (allModel2Ds.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                } 
                if (this.Items[i][j].equals("Display/Hide Curves")) {
                  if (allFaces.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }   
                if (this.Items[i][j].equals("Display/Hide Faces")) {
                  if (allFaces.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }      
                if (this.Items[i][j].equals("Display/Hide Solids")) {
                  if (allSolids.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                  
                if (this.Items[i][j].equals("Display/Hide Sections")) {
                  if (allSections.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }          
                if (this.Items[i][j].equals("Display/Hide Cameras")) {
                  if (allCameras.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                
                if (this.Items[i][j].equals("Display/Hide Sky")) {
                  if (Sky3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Grid")) {
                  if (Sun3D.displayGrid == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Path")) {
                  if (Sun3D.displayPath == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Sun Pattern")) {
                  if (Sun3D.displayPattern == false) {
                    stroke(127); 
                    fill(127);
                  }
                }              
                if (this.Items[i][j].equals("Display/Hide Sun Surface")) {
                  if (Sun3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Moon Surface")) {
                  if (Moon3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Earth Surface")) {
                  if (Earth3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Troposphere")) {
                  if (Tropo3D.displaySurface == false) {
                    stroke(127); 
                    fill(127);
                  }
                }  
                if (this.Items[i][j].equals("Display/Hide Solar Section")) {
                  if (allSolarImpacts.displayImage == false) {
                    stroke(127); 
                    fill(127);
                  }
                }  
                if (this.Items[i][j].equals("Display/Hide Solid Section")) {
                  if (allSolidImpacts.displayImage == false) {
                    stroke(127); 
                    fill(127);
                  }
                } 
                if (this.Items[i][j].equals("Display/Hide Wind Flow")) {
                  if (allWindFlows.displayAll == false) {
                    stroke(127); 
                    fill(127);
                  }
                }
                if (this.Items[i][j].equals("Display/Hide Selected Solids")) {
                  if (userSelections.Solid_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                        
                if (this.Items[i][j].equals("Display/Hide Selected Sections")) {
                  if (userSelections.Section_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }          
                if (this.Items[i][j].equals("Display/Hide Selected Cameras")) {
                  if (userSelections.Camera_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }        
                if (this.Items[i][j].equals("Display/Hide Selected LandPoints")) {
                  if (userSelections.LandPoint_displayPoints == false) {
                    stroke(127); 
                    fill(127);
                  }
                }              
                if (this.Items[i][j].equals("Display/Hide Selected Faces")) {
                  if (userSelections.Face_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }      
                if (this.Items[i][j].equals("Display/Hide Selected Curves")) {
                  if (userSelections.Curve_displayVertices == false) {
                    stroke(127); 
                    fill(127);
                  }
                }         
                if (this.Items[i][j].equals("Display/Hide Selected Faces Vertex Count")) {
                  if (userSelections.Face_displayVertexCount == false) {
                    stroke(127); 
                    fill(127);
                  }
                }   
                if (this.Items[i][j].equals("Display/Hide Selected Curves Vertex Count")) {
                  if (userSelections.Curve_displayVertexCount == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                
                if (this.Items[i][j].equals("Display/Hide Selected Vertices")) {
                  if (userSelections.Vertex_displayVertices == false) {
                    stroke(127); 
                    fill(127);
                  }
                }               
                if (this.Items[i][j].equals("Display/Hide Selected REF Pivot")) {
                  if (userSelections.displayReferencePivot == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                 
                if (this.Items[i][j].equals("Display/Hide Selected Group Pivot")) {
                  if (userSelections.displayReferencePivot == false) {
                    stroke(127); 
                    fill(127);
                  }
                }                    
                if (this.Items[i][j].equals("Display/Hide Selected Group Edges")) {
                  if (userSelections.Group_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Selected Group Box")) {
                  if (userSelections.Group_displayBox == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Selected 2D Edges")) {
                  if (userSelections.Model2D_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }    
                if (this.Items[i][j].equals("Display/Hide Selected 1D Edges")) {
                  if (userSelections.Model1D_displayEdges == false) {
                    stroke(127); 
                    fill(127);
                  }
                }              
              }
            }
  
            textSize(1.25 * MessageSize);
            text(this.Items[i][j], cx + 0.5 * MessageSize, cy - 0.2 * MessageSize + j * SOLARCHVISION_pixel_A);
          }
        }
      }
  
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
    
  }
  
}

solarchvision_UI_BAR_a UI_BAR_a = new solarchvision_UI_BAR_a();   



class solarchvision_UI_BAR_b {
  
  private final static String CLASS_STAMP = "UI_BAR_b";

  boolean update = true;
  
  float tab = SOLARCHVISION_pixel_B;
  
  String[][] Items = {
    {
      "11", "Top", "Front", "Left", "Back", "Right", "Bottom", "S.W.", "S.E.", "N.E.", "N.W.", "Cam00", "3DViewPoint", "2.0"
    }
    , 
    {
      "2", "AllViewports", "Expand3DView", "ExpandTimeView", "ExpandMapView", "3DViewSpace", "1"
    }
    , 
  
    {
      "2", "P<>", "P><", "ProjectionType", "1.0"
    }
    , 
    {
      "1", "LAO", "LookAtOrigin", "1.0"
    }
    , 
    {
      "1", "LAD", "LookAtDirection", "1.0"
    }  
    , 
    {
      "1", "LAS", "LookAtSelection", "1.0"
    }
    , 
    {
      "3", "CRL", "CRLz", "CRLxy", "CameraRoll", "1.0"
    }
    , 
    {
      "1", "±CDS", "CameraDistance", "1.0"
    }
    , 
    {
      "1", "±CDM", "DistMouseXY", "1.0"
    }
    , 
    {
      "1", "±CDZ", "DistZ", "1.0"
    }
    , 
    {
      "3", "DIz", "DIx", "DIy", "Truck", "1.0"
    }
    ,
    {
      "1", "LNOR", "LandOrbit", "1.0"
    }
    ,  
    {
      "1", "OR", "ORxy", "ORz", "Orbit", "1.0"
    }
    ,   
    {
      "1", "TRL", "TRLz", "TRLxy", "TargetRoll", "1.0"
    }
    , 
    {
      "1", "Pan", "PanX", "PanY", "Pan", "1.0"
    }
    , 
    {
      "1", "±ZM", "0ZM", "Zoom", "1.0"
    }
    , 
    {
      "1", "±SA", "AllModelSize", "1.0"
    }
    , 
    {
      "1", "±SZ", "3DModelSize", "1.0"
    }
    , 
    {
      "1", "±SK", "SkydomeSize", "1.0"
    }
    , 
  
    {
      "3", "3D-Tree", "2D-Tree", "Person", "Model2DsType", "1.5"
    }
    , 
    {
      "1", "House1", "House2", "Box", "Cushion", "Cylinder", "Sphere", "Octahedron", "Icosahedron", "Tri", "Hyper", "Plane", "Poly", "Extrude", "Parametric", "Point", "Spline", "Surface", "BuildingType", "2.5"
    }
    , 
    {
      "1", "as_Mesh", "as_Solid", "Mesh|Solid", "2.0"
    }
    , 
  
    {
      "4", "Land", "1D", "2D", "Group", "Face", "Vertex", "Soft", "Solid", "Section", "Camera", "Curve", "LayerType", "2.0"
    }
    , 
    {
      "1", "±CS", "+CS", "-CS", "ClickSelect", "1.0"
    }
    , 
    {
      "1", "±WS", "+WS", "-WS", "WindowSelect", "1.0"
    }
    , 
    {
      "2", "X<", "X|", "X>", "PivotX", "1.0"
    }
    , 
    {
      "2", "Y<", "Y|", "Y>", "PivotY", "1.0"
    }
    , 
    {
      "2", "Z<", "Z|", "Z>", "PivotZ", "1.0"
    }
    , 
    //{"1", "DrL±", "DrM+", "DrM-", "Drop", "1.0"},
    {
      "4", "GLx", "GLy", "GLz", "GL³", "GL²", "GLa", "GetLength", "1.0"
    }
    , 
    {
      "3", "MVx", "MVy", "MVz", "MV³", "Move", "1.0"
    }
    , 
    {
      "3", "SCx", "SCy", "SCz", "SC³", "Scale", "1.0"
    }
    , 
    {
      "3", "RTx", "RTy", "RTz", "Rotate", "1.0"
    }
    , 
    //{"3", "PWx", "PWy", "PWz", "PW³", "Power", "1.0"},
    {
      "1", "Mat0", "Mat1", "Mat2", "Mat3", "Change Seed/Material", "1.0"
    }
    , 
    {
      "1", "Tes0", "Tes1", "Tes2", "Tes3", "Change Tessellation", "1.0"
    }
    , 
    {
      "1", "Lyr0", "Lyr1", "Lyr2", "Lyr3", "Change Layer", "1.0"
    }
    , 
    {
      "1", "Vsb0", "Vsb1", "Vsb2", "Vsb3", "Change Visibility", "1.0"
    }
    , 
    {
      "1", "Wgt0", "Wgt1", "Wgt2", "Wgt3", "Change Weight", "1.0"
    }
    ,   
    {
      "1", "Norm1", "Norm2", "Norm3", "Normal", "1.0"
    }
    , 
    {
      "1", "1stV", "FirstVertex", "1.0"
    }
    , 
  
  
    //{"1", "<pvt>", ">pvt<", "|pvt|", ".pvt.", "Get/Set Pivot", "1.0"},
  
    //{"1", "SPvt0", "SPvt1", "SPvt2", "Pivot", "1.0"},
  
    //{"1", "dgMax0", "dgMax1", "dgMax2", "Change DegreeMax", "1.0"},
    //{"1", "dgDif0", "dgDif1", "dgDif2", "Change DegreeDif", "1.0"},
    //{"1", "dgMin0", "dgMin1", "dgMin2", "Change DegreeMin", "1.0"},
    //{"1", "tsSz0", "trSz1", "trSz2", "Change TrunkSize", "1.0"},
    //{"1", "lfSz0", "lfSz1", "lfSz2", "Change LeafSize", "1.0"},
    //{"1", "allFP0", "allFP1", "allFP2", "Model1DsProps", "1.0"},
  
    //{"1", "SEC", "Section", "1.0"},
    //{"1", "SLD", "Solid", "1.0"},
    //{"1", "CAM", "Pick Study Camera", "1.0"},
  };         
  
  
  
  int Selection = -1;                        
  
  
  boolean displayText; 
  
  
  void hghlight (String s) {
  
    int break_loops = 0;
  
    for (int i = 0; i < this.Items.length; i++) {
      for (int j = 1; j < this.Items[i].length - 2; j++) {
        if (this.Items[i][j].equals(s)) {
  
          this.Items[i][0] = nf(j, 0);
  
          break_loops = 1;
        }
  
        if (break_loops == 1) break;
      }
      if (break_loops == 1) break;
    }
  }
  
  
  void draw () {
  
    if (this.update) {
  
      this.update = false;
  
      fill(0);
      noStroke();
      rect(0, SOLARCHVISION_pixel_A, width, SOLARCHVISION_pixel_B);
  
      STUDY.X_control = 0; //0.25 * MessageSize;
      STUDY.Y_control = SOLARCHVISION_pixel_A + 0.5 * SOLARCHVISION_pixel_B;
  
      float cx = STUDY.X_control;
      float cy = STUDY.Y_control;
      float cr = 0.5 * SOLARCHVISION_pixel_B;   
  
      for (int i = 0; i < this.Items.length; i++) {
  
        {
          String Bar_Switch = this.Items[i][this.Items[i].length - 2];
  
          if (Bar_Switch.equals("LayerType")) {
            this.Items[i][0] = nf(current_ObjectCategory + 1, 0);
          }
        }
  
  
  
        int j = int(this.Items[i][0]);
  
        float Item_width = this.tab * float(this.Items[i][this.Items[i].length - 1]);
  
        noFill();
        stroke(255);
        strokeWeight(1);
        rect(cx, cy - cr, Item_width, SOLARCHVISION_pixel_B);
        strokeWeight(0);
  
  
  
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, cx, cy - cr, cx + Item_width, cy + cr) == 1) {
  
          if (mouseButton == RIGHT) {       
  
            if (this.Selection != i) {
              this.Selection = i;
            } else {
  
              int n = int(this.Items[i][0]);
  
              n -= 1;
  
              if (n <= 0) n = this.Items[i].length - 3;
  
              this.Items[i][0] = nf(n, 0);
  
              j = n;
            }
          }
  
          if (mouseButton == LEFT) {
  
            if (this.Selection != i) {
              this.Selection = i;
            } else {
  
              int n = int(this.Items[i][0]);
  
              n += 1;
  
              if (n >= this.Items[i].length - 2) n = 1;
  
              this.Items[i][0] = nf(n, 0);
  
              j = n;
            }
          }               
  
  
          fill(255, 127, 0);
          noStroke();
          rect(cx, cy - cr, Item_width, SOLARCHVISION_pixel_B);     
  
          String Bar_Switch = this.Items[i][this.Items[i].length - 2];
  
  
          if (Bar_Switch.equals("LayerType")) {
            current_ObjectCategory = j - 1;
  
            if (current_ObjectCategory == ObjectCategory.SOFTVERTEX) {
              allModel3Ds.convert_Vertex_to_softSelection();
            }
  
            ROLLOUT.update = true;   
            WIN3D.update = true;
          }
  
          if (Bar_Switch.equals("Mesh|Solid")) {
            User3D.create_MeshOrSolid = j - 1;
  
            ROLLOUT.update = true;
          }        
  
          if ((Bar_Switch.equals("Model2DsType")) || (Bar_Switch.equals("BuildingType"))) {
            if ((this.Items[i][j]).equals("3D-Tree")) UI_set_to_Create_allModel1Ds();
            else if ((this.Items[i][j]).equals("2D-Tree")) UI_set_to_Create_Tree();
            else if ((this.Items[i][j]).equals("Person")) UI_set_to_Create_Person();
            else if ((this.Items[i][j]).equals("Point")) UI_set_to_Create_Vertex();
            else if ((this.Items[i][j]).equals("Spline")) UI_set_to_Create_Curve();
            else if ((this.Items[i][j]).equals("Surface")) UI_set_to_Create_Face();
            else if ((this.Items[i][j]).equals("Tri")) UI_set_to_Create_Tri();
            else if ((this.Items[i][j]).equals("Plane")) UI_set_to_Create_Plane();
            else if ((this.Items[i][j]).equals("Poly")) UI_set_to_Create_Poly();
            else if ((this.Items[i][j]).equals("Extrude")) UI_set_to_Create_Extrude();
            else if ((this.Items[i][j]).equals("Hyper")) UI_set_to_Create_Hyper();
            else if ((this.Items[i][j]).equals("House1")) UI_set_to_Create_House1();
            else if ((this.Items[i][j]).equals("House2")) UI_set_to_Create_House2();
            else if ((this.Items[i][j]).equals("Box")) UI_set_to_Create_Box();
            else if ((this.Items[i][j]).equals("Icosahedron")) UI_set_to_Create_Octahedron();
            else if ((this.Items[i][j]).equals("Octahedron")) UI_set_to_Create_Octahedron();
            else if ((this.Items[i][j]).equals("Sphere")) UI_set_to_Create_Sphere();
            else if ((this.Items[i][j]).equals("Cylinder")) UI_set_to_Create_Cylinder();
            else if ((this.Items[i][j]).equals("Cushion")) UI_set_to_Create_Cushion();
            else if ((this.Items[i][j]).equals("Parametric")) UI_set_to_Create_Parametric(User3D.create_Parametric_Type);
          }
  
          if (Bar_Switch.equals("Change Seed/Material")) {
            if ((this.Items[i][j]).equals("Mat0")) UI_set_to_Modify_Seed(0);
            if ((this.Items[i][j]).equals("Mat1")) UI_set_to_Modify_Seed(1);
            if ((this.Items[i][j]).equals("Mat2")) UI_set_to_Modify_Seed(2);
            if ((this.Items[i][j]).equals("Mat3")) UI_set_to_Modify_Seed(3);
          }
  
          if (Bar_Switch.equals("Change Tessellation")) {
            if ((this.Items[i][j]).equals("Tes0")) UI_set_to_Modify_Tessellation(0);
            if ((this.Items[i][j]).equals("Tes1")) UI_set_to_Modify_Tessellation(1);
            if ((this.Items[i][j]).equals("Tes2")) UI_set_to_Modify_Tessellation(2);
            if ((this.Items[i][j]).equals("Tes3")) UI_set_to_Modify_Tessellation(3);
          }
  
          if (Bar_Switch.equals("Change Layer")) {
            if ((this.Items[i][j]).equals("Lyr0")) UI_set_to_Modify_Layer(0);
            if ((this.Items[i][j]).equals("Lyr1")) UI_set_to_Modify_Layer(1);
            if ((this.Items[i][j]).equals("Lyr2")) UI_set_to_Modify_Layer(2);
            if ((this.Items[i][j]).equals("Lyr3")) UI_set_to_Modify_Layer(3);
          }
  
          if (Bar_Switch.equals("Change Visibility")) {
            if ((this.Items[i][j]).equals("Vsb0")) UI_set_to_Modify_Visibility(0);
            if ((this.Items[i][j]).equals("Vsb1")) UI_set_to_Modify_Visibility(1);
            if ((this.Items[i][j]).equals("Vsb2")) UI_set_to_Modify_Visibility(2);
            if ((this.Items[i][j]).equals("Vsb3")) UI_set_to_Modify_Visibility(3);
          }    
      
          if (Bar_Switch.equals("Change Weight")) {
            if ((this.Items[i][j]).equals("Wgt0")) UI_set_to_Modify_Weight(0);
            if ((this.Items[i][j]).equals("Wgt1")) UI_set_to_Modify_Weight(1);
            if ((this.Items[i][j]).equals("Wgt2")) UI_set_to_Modify_Weight(2);
            if ((this.Items[i][j]).equals("Wgt3")) UI_set_to_Modify_Weight(3);
          }           
  
          if (Bar_Switch.equals("Normal")) {
            if ((this.Items[i][j]).equals("Norm1")) UI_set_to_Modify_Normal(1);
            if ((this.Items[i][j]).equals("Norm2")) UI_set_to_Modify_Normal(2);
            if ((this.Items[i][j]).equals("Norm3")) UI_set_to_Modify_Normal(3);
          }
  
          if (Bar_Switch.equals("FirstVertex")) {
            if ((this.Items[i][j]).equals("1stV")) UI_set_to_Modify_FirstVertex(1);
          }        
  
  
  
          if (Bar_Switch.equals("Rotate")) UI_set_to_Modify_Rotate(j - 1);
          if (Bar_Switch.equals("Power")) UI_set_to_Modify_Power(j - 1);        
          if (Bar_Switch.equals("Scale")) UI_set_to_Modify_Scale(j - 1);
          if (Bar_Switch.equals("Move")) UI_set_to_Modify_Move(j - 1);
          if (Bar_Switch.equals("GetLength")) UI_set_to_Modify_GetLength(j - 1);
          if (Bar_Switch.equals("Drop")) UI_set_to_Modify_Drop(j - 1);
  
          if (Bar_Switch.equals("ProjectionType")) UI_set_to_View_ProjectionType(j - 1);
  
          if (Bar_Switch.equals("ClickSelect")) UI_set_to_View_ClickSelect(j - 1);
          if (Bar_Switch.equals("WindowSelect")) UI_set_to_View_WindowSelect(j - 1);
  
          if (Bar_Switch.equals("PivotX")) UI_set_to_View_PivotX(j - 2);
          if (Bar_Switch.equals("PivotY")) UI_set_to_View_PivotY(j - 2);
          if (Bar_Switch.equals("PivotZ")) UI_set_to_View_PivotZ(j - 2);
  
          if (Bar_Switch.equals("LandOrbit")) UI_set_to_View_LandOrbit(0);
          
          if (Bar_Switch.equals("Orbit")) UI_set_to_View_Orbit(j - 1);
          if (Bar_Switch.equals("CameraRoll")) UI_set_to_View_CameraRoll(j - 1);
          if (Bar_Switch.equals("TargetRoll")) UI_set_to_View_TargetRoll(j - 1);
  
          if (Bar_Switch.equals("LookAtOrigin")) UI_set_to_View_LookAtOrigin(j - 1);
          if (Bar_Switch.equals("LookAtDirection")) UI_set_to_View_LookAtDirection(j - 1);
          if (Bar_Switch.equals("LookAtSelection")) UI_set_to_View_LookAtSelection(j - 1);
  
          if (Bar_Switch.equals("Pan")) {
  
            UI_set_to_View_Pan(j - 1);
          }  
  
          if (Bar_Switch.equals("Zoom")) {
            UI_set_to_View_ZOOM(j - 1);
  
            this.Items[i][0] = "1"; // << set it to default choice next time
          }     
  
          if (Bar_Switch.equals("CameraDistance")) UI_set_to_View_CameraDistance(0);
  
          if (Bar_Switch.equals("DistMouseXY")) UI_set_to_View_DistMouseXY(0);
  
          if (Bar_Switch.equals("DistZ")) UI_set_to_View_Truck(0);
          if (Bar_Switch.equals("Truck")) UI_set_to_View_Truck(j - 1);
  
          if (Bar_Switch.equals("3DModelSize")) UI_set_to_View_3DModelSize();
  
          if (Bar_Switch.equals("SkydomeSize")) UI_set_to_View_SkydomeSize();
  
          if (Bar_Switch.equals("AllModelSize")) UI_set_to_View_AllModelSize();
  
          if (Bar_Switch.equals("3DViewSpace")) UI_set_to_Viewport(j - 1);
  
          if (Bar_Switch.equals("3DViewPoint")) UI_set_to_View_3DViewPoint(j - 1);
        }
  
  
        this.displayText = true;  
  
        { // drawing the icons where available
  
          String Bar_Switch = this.Items[i][this.Items[i].length - 2];
  
          if (Bar_Switch.equals("Drop")) {
            UI_BAR_b.drawDrop(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("GetLength")) {
            UI_BAR_b.drawGetLength(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }        
          if (Bar_Switch.equals("Move")) {
            UI_BAR_b.drawMove(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Scale")) {
            UI_BAR_b.drawScale(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }    
          if (Bar_Switch.equals("Power")) {
            UI_BAR_b.drawPower(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }            
          if (Bar_Switch.equals("Rotate")) {
            UI_BAR_b.drawRotate(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }    
          if (Bar_Switch.equals("Change Seed/Material")) {
            UI_BAR_b.drawSeed(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Tessellation")) {
            UI_BAR_b.drawTessellation(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Layer")) {
            UI_BAR_b.drawLayer(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("Change Visibility")) {
            UI_BAR_b.drawVisibility(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }       
          if (Bar_Switch.equals("Change Weight")) {
            UI_BAR_b.drawWeight(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }          
          if (Bar_Switch.equals("Normal")) {
            UI_BAR_b.drawNormal(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }           
          if (Bar_Switch.equals("FirstVertex")) {
            UI_BAR_b.drawFirstVertex(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }            
  
          if (Bar_Switch.equals("ClickSelect")) {
            UI_BAR_b.drawClickSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }       
          if (Bar_Switch.equals("WindowSelect")) {
            UI_BAR_b.drawWindowSelect(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }   
          if (Bar_Switch.equals("ProjectionType")) {
            UI_BAR_b.drawProjectionType(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }          
          if (Bar_Switch.equals("Zoom")) {
            UI_BAR_b.drawZOOM(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("LandOrbit")) {
            UI_BAR_b.drawLandOrbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }             
          if (Bar_Switch.equals("Orbit")) {
            UI_BAR_b.drawOrbit(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }     
          if (Bar_Switch.equals("CameraRoll")) {
            UI_BAR_b.drawCameraRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }             
          if (Bar_Switch.equals("TargetRoll")) {
            UI_BAR_b.drawTargetRoll(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }      
          if (Bar_Switch.equals("CameraDistance")) {
            UI_BAR_b.drawCameraDistance(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }           
          if (Bar_Switch.equals("LookAtOrigin")) {
            UI_BAR_b.drawLookAtOrigin(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }  
          if (Bar_Switch.equals("LookAtDirection")) {
            UI_BAR_b.drawLookAtDirection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }              
          if (Bar_Switch.equals("LookAtSelection")) {
            UI_BAR_b.drawLookAtSelection(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }                
          if (Bar_Switch.equals("Pan")) {
            UI_BAR_b.drawPan(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("DistMouseXY")) {
            UI_BAR_b.drawDistMouseXY(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }          
          if (Bar_Switch.equals("DistZ")) {
            UI_BAR_b.drawDistZ(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }        
          if (Bar_Switch.equals("Truck")) {
            UI_BAR_b.drawTruck(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("3DModelSize")) {
            UI_BAR_b.draw3DModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }      
          if (Bar_Switch.equals("SkydomeSize")) {
            UI_BAR_b.drawSkydomeSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
          if (Bar_Switch.equals("AllModelSize")) {
            UI_BAR_b.drawAllModelSize(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }  
  
          if (Bar_Switch.equals("3DViewSpace")) {
            UI_BAR_b.draw3DViewSpace(j, cx + 0.5 * Item_width, cy, 0.5 * SOLARCHVISION_pixel_B);
          }
        }
  
        if (this.displayText) { // writing titles where the icon is not available
  
          textAlign(CENTER, CENTER);   
          stroke(255); 
          fill(255);
          textSize(0.45 * SOLARCHVISION_pixel_B);
  
          text(this.Items[i][j], cx + 0.5 * Item_width, cy - 0.2 * MessageSize);
        }
  
  
        cx += Item_width;
      }
  
  
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }   
  
  void drawMouse (int _type, float x, float y, float r) {
  
    float d = 0.4 * r;
  
    for (int i = 0; i < 3; i++) { 
  
      float dx = 0;
      float dy = 0;
  
      if (i == 0) {
        dx = 0.5 * d;
        dy = 0.5 * d;
        strokeWeight(1);
        stroke(63); 
        fill(63);
      } else if (i == 1) {
        strokeWeight(3);
        stroke(0); 
        fill(0);
      } else {
        strokeWeight(1);
        stroke(1);
        stroke(255); 
        fill(255);
      }          
  
      pushMatrix();
      translate(x + d + dx, y + d + dy);
  
      triangle(-d, -d, -d, d, d, -d); 
  
      if (i == 1) {
        strokeWeight(2 + d);
      } else { 
        strokeWeight(d);
      }
  
      line(0, 0, d, d);
  
      popMatrix();
    }
  
    strokeWeight(0);
  }
  
  void drawClickSelect (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    fill(255);  
  
    float d = 0.3 * r;
    triangle(-d, -d, -d, d, d, -d); 
  
    strokeWeight(5);
    line(0, 0, d, d);
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawWindowSelect (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    fill(63);  
    rect(-0.5 * r, -0.5 * r, 1.25 * r, 1.25 * r);
  
    strokeWeight(1);
    stroke(255); 
    fill(255);  
  
    float d = 0.3 * r;
    triangle(-d, -d, -d, d, d, -d); 
  
    strokeWeight(5);
    line(0, 0, d, d);
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawDrop (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    fill(0);
  
    float d = 0.8 * r;
  
    if (_type == 1) {
      ellipse(0, 0, 2 * d, d);
    } 
    if ((_type == 2) || (_type == 3)) {
      beginShape();
      vertex(0, 0.5 * d);
      vertex(funcs.cos_ang(30) * d, 0);
      vertex(0, -0.5 * d);
      vertex(-funcs.cos_ang(30) * d, 0);
      endShape(CLOSE);
    } 
  
  
  
  
    strokeWeight(2);
    stroke(255); 
    fill(0);
  
    if (_type == 1) {
      line(0, 0, 0, -d);  
      line(0, 0, 0 - 0.25 * d, 0.25 * -d);
      line(0, 0, 0 + 0.25 * d, 0.25 * -d);
  
      line(0, 0, 0, d);  
      line(0, 0, 0 - 0.25 * d, 0.25 * d);
      line(0, 0, 0 + 0.25 * d, 0.25 * d);
    }
  
    if (_type == 2) {
      line(0, 0.25 * d, 0, -d);  
      line(0, 0.25 * d, 0 - 0.25 * d, 0);
      line(0, 0.25 * d, 0 + 0.25 * d, 0);
    }
  
    if (_type == 3) {
      line(0, 0.25 * -d, 0, d);  
      line(0, 0.25 * -d, 0 - 0.25 * d, 0);
      line(0, 0.25 * -d, 0 + 0.25 * d, 0);
    }  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawGetLength (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();
  
  
    float d = 0.8 * r;
  
    beginShape();
    vertex(0, 0);
    vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, -d);
    vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
    endShape(CLOSE);
  
    beginShape();
    vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    vertex(0, 0);
    vertex(0, d);
    vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
    endShape(CLOSE);
  
  
    strokeWeight(2);
    stroke(0, 127, 255); 
    fill(0);
  
    if (_type == 1) {
      line(0, 0, funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }
    if (_type == 2) {
      line(0, 0, funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }    
    if (_type == 3) {
      line(0, 0, -funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
    }      
    if (_type == 4) {
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);  
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }     
    if (_type == 5) {
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
    }    
    if (_type == 6) {
      line(0, 0, 0, -d);
    }      
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawMove (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(0, 0, 0.8 * r, 0); 
    line(0, 0, 0, -0.8 * r); 
    line(0, 0, -0.4 * r, 0.4 * r); 
  
    strokeWeight(3);
    stroke(255); 
    noFill();  
  
    if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
    if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);  
    if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
    if (_type == 4) line(-0.4 * r, -0.4 * r, 0.4 * r, 0.4 * r);
  
    noStroke();
    fill(255, 0, 0);
    float d = 5;
    if (_type == 1) {
      ellipse(-0.8 * r, 0, d, d); 
      ellipse(0.8 * r, 0, d, d);
    }
    if (_type == 2) {
      ellipse(0.4 * r, -0.4 * r, d, d); 
      ellipse(-0.4 * r, 0.4 * r, d, d);
    }    
    if (_type == 3) {
      ellipse(0, 0.8 * r, d, d); 
      ellipse(0, -0.8 * r, d, d);
    }
    if (_type == 4) {
      ellipse(-0.4 * r, -0.4 * r, d, d); 
      ellipse(0.4 * r, 0.4 * r, d, d);
    }  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  void drawScale (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(0, 0, 0.8 * r, 0); 
    line(0, 0, 0, -0.8 * r); 
    line(0, 0, -0.4 * r, 0.4 * r); 
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  
    strokeWeight(5);
    stroke(0, 255, 0); 
    noFill();  
  
    if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
    if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
    if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
    if (_type == 4) {
      line(-0.4 * r, 0, 0.4 * r, 0);
      line(0, 0.4 * r, 0, -0.4 * r);
      line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    }  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawPower (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(0, 0, 0.8 * r, 0); 
    line(0, 0, 0, -0.8 * r); 
    line(0, 0, -0.4 * r, 0.4 * r); 
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  
    strokeWeight(3);
    stroke(0, 127, 255); 
    noFill();  
  
    if (_type == 1) line(-0.4 * r, 0, 0.4 * r, 0);
    if (_type == 2) line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);  
    if (_type == 3) line(0, 0.4 * r, 0, -0.4 * r);
    if (_type == 4) {
      line(-0.4 * r, 0, 0.4 * r, 0);
      line(0, 0.4 * r, 0, -0.4 * r);
      line(0.2 * r, -0.2 * r, -0.2 * r, 0.2 * r);
    }  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawRotate (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(0, 0, 0.8 * r, 0); 
    line(0, 0, 0, -0.8 * r); 
    line(0, 0, -0.4 * r, 0.4 * r); 
  
    strokeWeight(3);
    stroke(255); 
    noFill();  
  
    if (_type == 1) line(-0.8 * r, 0, 0.8 * r, 0);
    if (_type == 2) line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
    if (_type == 3) line(0, 0.8 * r, 0, -0.8 * r);
  
    strokeWeight(2);
    stroke(0, 127, 255);
    noFill();
    float d = 0.85 * r;
    if (_type == 1) {
      arc(0, 0, d, d, 0.25 * PI, 1.75 * PI);
    }
    if (_type == 2) {
      arc(0, 0, d, d, (0.25 + 0.75) * PI, (1.75 + 0.75) * PI);
    }
    if (_type == 3) {
      arc(0, 0, d, d, (0.25 - 0.5) * PI, (1.75 - 0.5) * PI);
    }
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  
  
  void drawSeed (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(0, 0, 0.8 * r, 0); 
    line(0, 0, 0, -0.8 * r); 
    line(0, 0, -0.4 * r, 0.4 * r); 
  
    strokeWeight(1);
    stroke(255); 
    noFill();  
  
    line(-0.8 * r, 0, 0.8 * r, 0);
    line(0, 0.8 * r, 0, -0.8 * r);
    line(0.4 * r, -0.4 * r, -0.4 * r, 0.4 * r);
  
    strokeWeight(1);
    stroke(255, 255, 0); 
    noFill();  
  
    for (int i = 0; i < 360; i += 30) {
      float d = random(0.25, 0.75);
  
      line(0, 0, 0.8 * r * d * cos(i), 0.8 * r * d * sin(i));
    }  
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void drawTessellation (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 1.25 * r;
  
    strokeWeight(2);
    stroke(255); 
    fill(63);  
    rect(-0.5 * d, -0.5 * d, d, d);
  
    strokeWeight(1);
    stroke(191); 
    fill(191);  
  
    for (int i = 1; i < 4; i++) {
      float w = (0.25 * i - 0.5) * d;
      line(-0.5 * d, w, 0.5 * d, w);  
      line(w, -0.5 * d, w, 0.5 * d);
    }
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawLayer (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 0.8 * r;
  
    strokeWeight(1);
    stroke(255); 
    fill(0);
  
    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE); 
  
    strokeWeight(2);
    stroke(255); 
    fill(0, 127, 255);
  
    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawVisibility (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 0.8 * r;
  
    strokeWeight(1);
    stroke(255); 
    fill(0);
  
    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE); 
  
    strokeWeight(0);
    stroke(255); 
    fill(127, 127);
  
    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawWeight (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
  
    strokeWeight(1);
    stroke(255); 
    fill(63);  
    //rect(-0.5 * r, -0.5 * r, r, r);
    
    float d = r * pow(2, 0.5);
    
    strokeWeight(1);
    noFill();  
    ellipse(0, 0, d, d);
  
    strokeWeight(1);
    noFill();  
    arc(0, -r, d, d, 0.25 * PI, 0.75 * PI);
    arc(r, 0, d, d, 0.75 * PI, 1.25 * PI);
    arc(0, r, d, d, 1.25 * PI, 1.75 * PI);
    arc(-r, 0, d, d, 1.75 * PI, 2.25 * PI);
  
  
    stroke(0, 127, 255);
    strokeWeight(3);
    if (_type == 2) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r);
    }
    if (_type == 3) {
      line(-0.75 * r, -0.5 * r, -0.25 * r, -0.5 * r); 
      line(-0.5 * r, -0.75 * r, -0.5 * r, -0.25 * r);
    } 
    if (_type == 4) {
      line(-0.7 * r, -0.7 * r, -0.3 * r, -0.3 * r); 
      line(-0.7 * r, -0.3 * r, -0.3 * r, -0.7 * r);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawNormal (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 0.8 * r;
  
    strokeWeight(2);
    stroke(255); 
    fill(0);
  
    beginShape();
    vertex(0, 0.5 * d);
    vertex(funcs.cos_ang(30) * d, 0);
    vertex(0, -0.5 * d);
    vertex(-funcs.cos_ang(30) * d, 0);
    endShape(CLOSE);
  
    if (_type == 1) {
      line(0, 0, 0, -d);  
      line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
      line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
  
      line(0, 0.5 * d, 0, d);  
      line(0 - 0.25 * d, d - 0.25 * d, 0, d);
      line(0 + 0.25 * d, d - 0.25 * d, 0, d);
    }
  
    if (_type == 2) {
      line(0, 0, 0, -d);  
      line(0 - 0.25 * d, -d + 0.25 * d, 0, -d);
      line(0 + 0.25 * d, -d + 0.25 * d, 0, -d);
    }
  
  
    if (_type == 3) {
      line(0, 0, 0, d);  
      line(0 - 0.25 * d, d - 0.25 * d, 0, d);
      line(0 + 0.25 * d, d - 0.25 * d, 0, d);
    }  
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawFirstVertex (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 0.8 * r;
  
    strokeWeight(2);
    stroke(255); 
    fill(0);
  
    beginShape();
    vertex(0, d);
    vertex(funcs.cos_ang(30) * d, 0.5 * d);
    vertex(0, 0);
    vertex(-funcs.cos_ang(30) * d, 0.5 * d);
    endShape(CLOSE);
  
    stroke(255, 0, 0);
    ellipse(0, 0, 0.25 * d, 0.25 * d);
  
    fill(255);
    textSize(d);
    textAlign(CENTER, BOTTOM);
    text("1st", 0, 0);
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void draw3DViewSpace (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(2);
    stroke(255); 
    noFill();
  
    strokeWeight(1);
    stroke(255); 
    if (_type == 1) fill(63);  
    if (_type == 2) fill(191);
    rect(-0.75 * r, -0.75 * r, 1.5 * r, 1.5 * r);
  
    if (_type == 1) fill(191);  
    if (_type == 2) fill(63);
    rect(-0.75 * r, -0.75 * r, 0.75 * r, 0.75 * r);
  
    strokeWeight(2);
    line(0, 0, 0.75 * r, 0.75 * r);
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  void drawProjectionType (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(2);
    stroke(255); 
    fill(0);
  
  
    float d = 0.8 * r;
  
    if (_type == 1) {
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }  
  
    if (_type == 2) {
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0.75 * funcs.sin_ang(0) * d, 0.75 * -funcs.cos_ang(0) * d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(0.75 * funcs.sin_ang(120) * d, 0.75 * -funcs.cos_ang(120) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(0.75 * funcs.sin_ang(240) * d, 0.75 * -funcs.cos_ang(240) * d);
      endShape(CLOSE);
    }
  
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawTruck (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
  
    stroke(255); 
    fill(0);
  
    float d = 0.625 * r;
  
    float a = 0;
    float b = 0;
    if (_type == 1) {
      a = funcs.cos_ang(30) * d; 
      b = -funcs.sin_ang(30) * d;
    }
    if (_type == 2) {
      a = -funcs.cos_ang(30) * d; 
      b = -funcs.sin_ang(30) * d;
    }
    if (_type == 3) {
      a = 0; 
      b = d;
    }
  
    strokeWeight(1);
    {
      pushMatrix();
      translate(0.5 * a, 0.5 * b);
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      popMatrix();
    }
  
  
  
  
    strokeWeight(2);
    {
      pushMatrix();
      translate(-0.5 * a, -0.5 * b);
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      popMatrix();
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  
  void drawZOOM (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    {
      pushMatrix();
      translate(0.25 * r, 0.25 * r);
  
      stroke(255); 
  
      fill(0);
      strokeWeight(1);
      ellipse(-0.4 * r, -0.4 * r, 0.8 * r, 0.8 * r); 
  
      noFill();  
      strokeWeight(4);
      line(-0.1 * r, -0.1 * r, 0.3 * r, 0.3 * r);
  
      strokeWeight(2);
      stroke(255, 255, 0);
      if (_type == 1) {
        line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r); 
        line(-0.4 * r, -0.6 * r, -0.4 * r, -0.2 * r);
      } 
      if (_type == 2) {
        line(-0.6 * r, -0.4 * r, -0.2 * r, -0.4 * r);
      }
  
      popMatrix();
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void draw3DModelSize (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    stroke(255); 
    fill(0);
    strokeWeight(2);
    ellipse(0, 0, r, r);
    noFill();
    strokeWeight(1);
    ellipse(0, 0, 1.5 * r, 1.5 * r); 
  
    strokeWeight(1);
    line(-0.75 * r, 0, -0.5 * r, 0);
    line(0, -0.75 * r, 0, -0.5 * r);
    line(0.75 * r, 0, 0.5 * r, 0);
    line(0, 0.75 * r, 0, 0.5 * r);
  
  
    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r); 
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  
  
  void drawAllModelSize (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 0.75 * r;
  
    stroke(255); 
    fill(0); 
    strokeWeight(1);
    ellipse(0, 0, d, d);
    noFill();
    strokeWeight(1);
    ellipse(0, 0, 2 * d, 2 * d); 
  
    strokeWeight(1);
    line(-1 * d, 0, -0.5 * d, 0);
    line(0, -1 * d, 0, -0.5 * d);
    line(1 * d, 0, 0.5 * d, 0);
    line(0, 1 * d, 0, 0.5 * d);
  
  
    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r); 
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawSkydomeSize (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    {
      pushMatrix();
      translate(0, 0.125 * r);
  
      float d = 1.0 * r;
  
      strokeWeight(1);
      stroke(255); 
      fill(0);
      arc(0, 0, d, d, PI, 2 * PI); 
      arc(0, 0, d, 0.333 * d, 0, PI);
  
      d = 1.5 * r;
  
      strokeWeight(2);
      stroke(255); 
      noFill();  
      arc(0, 0, d, d, PI, 2 * PI);
      arc(0, 0, d, 0.333 * d, 0, PI);
  
      popMatrix();
    }
  
    strokeWeight(2);
    stroke(255, 255, 0);
    line(-0.2 * r, 0, 0.2 * r, 0);
    line(0, -0.2 * r, 0, 0.2 * r); 
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawLandOrbit (int _type, float x, float y, float r) {
  
    {
      pushMatrix();
      translate(x, y);
      translate(-0.333 * r, -0.333 * r); // <<<<<<
    
      float d = 1.0 * r;
    
      strokeWeight(1);
      stroke(255); 
      fill(0); 
      ellipse(0, 0, d, d); 
    
      strokeWeight(2);
      stroke(255); 
      noFill();  
    
      if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
      if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
        arc(0, 0, d, 0.333 * d, 0, PI);
      }
    
      strokeWeight(0);
    
      popMatrix();
    }
    
    {  
      pushMatrix();
      translate(x, y);
      translate(0.333 * r, 0.333 * r); // <<<<<<
    
      float d = 0.75 * r;
    
      strokeWeight(1);
      stroke(255); 
      noFill();  
      arc(0, 0, d, d, 0, PI); 
    
      stroke(255); 
      noFill();  
    
      for (float i = -1.5; i <= 1.5; i++) { 
        line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);
    
        if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
      }
      
      strokeWeight(0);
  
      popMatrix();      
    }
  
    this.displayText = false;
  }
  
  void drawOrbit (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    float d = 1.5 * r;
  
    strokeWeight(1);
    stroke(255); 
    fill(0); 
    ellipse(0, 0, d, d); 
  
    strokeWeight(2);
    stroke(255); 
    noFill();  
  
    if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
    if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
    if (_type == 1) {
      arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      arc(0, 0, d, 0.333 * d, 0, PI);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawLookAtOrigin (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0); 
  
    {
      float d = 0.8 * r;
  
      line(0, 0, funcs.cos_ang(90) * d, -funcs.sin_ang(90) * d);
      line(0, 0, funcs.cos_ang(210) * d, -funcs.sin_ang(210) * d);
      line(0, 0, funcs.cos_ang(330) * d, -funcs.sin_ang(330) * d);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawLookAtDirection (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0); 
  
    {
      float d = 0.8 * r;
  
      line(-d,d/2,d,d/2);
      line(d/2,-d,d/2,d);
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawLookAtSelection (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(2);
    stroke(255);
    fill(127, 63, 0); 
  
    {
      float d = 0.8 * r;
  
      line(0, 0, funcs.cos_ang(90) * d, -funcs.sin_ang(90) * d);
      line(0, 0, funcs.cos_ang(210) * d, -funcs.sin_ang(210) * d);
      line(0, 0, funcs.cos_ang(330) * d, -funcs.sin_ang(330) * d);
    }
  
    {
      //float d = 0.625 * r;
      float d = 0.5 * r;
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }    
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawCameraRoll (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    {
      float d = 1.5 * r;
  
      strokeWeight(1);
      stroke(255); 
      fill(0);
      ellipse(0, 0, d, d);
    }
  
  
    strokeWeight(1);
    stroke(255);
    fill(127, 63, 0); 
    {
      //float d = 0.625 * r;
      float d = 0.5 * r;
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }  
  
  
  
    {
      float d = 1.5 * r;
  
      strokeWeight(2);
      stroke(255); 
      noFill();  
  
      if (_type == 3) arc(0, 0, d, 0.333 * d, 0, PI); 
      if (_type == 2) arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, 0.5 * PI, 1.5 * PI); 
        arc(0, 0, d, 0.333 * d, 0, PI);
      }
    }  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void drawTargetRoll (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    {  
  
      float d = 1.5 * r;
  
      strokeWeight(1);
      stroke(255); 
      fill(0);  
      rect(-d/2, -d/2, d, d);   
  
      strokeWeight(2);
      stroke(255); 
      noFill();  
  
      if (_type == 3) arc(0, 0, d, 0.333 * d, PI, 2 * PI); 
      if (_type == 2) arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
      if (_type == 1) {
        arc(0, 0, 0.333 * d, d, -0.5 * PI, 0.5 * PI); 
        arc(0, 0, d, 0.333 * d, PI, 2 * PI);
      }
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  void drawPan (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    {
      float d = 1.0 * r;
  
      strokeWeight(1);
      stroke(255); 
      noFill();  
      arc(0, 0, d, d, 0, PI); 
  
      stroke(255); 
      noFill();  
  
      for (float i = -1.5; i <= 1.5; i++) { 
        line(i * 0.25 * d - 0.125 * d, -0.5 * d, i * 0.25 * d + 0.125 * d, 0);
  
        if (i < 1.5) arc(i * 0.25 * d, -0.5 * d, 0.25 * d, 0.25 * d, PI, 2*PI);
      }
    }
  
    strokeWeight(2);
    stroke(255); 
    noFill();  
    {
      float d = 0.75 * r;
  
      if (_type == 2) {
        line(-1 * d, 0, -0.5 * d, 0);
        line(1 * d, 0, 0.5 * d, 0);
      }
      if (_type == 3) {
        line(0, -1 * d, 0, -0.5 * d);
        line(0, 1 * d, 0, 0.5 * d);
      }
    }
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void drawDistMouseXY (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    line(-r, -0.5 * r, r, -0.5 * r);
    strokeWeight(2);
    line(-0.5 * r, -0.5 * r, r, 0);
    line(-0.5 * r, -0.5 * r, -r, 0);
    strokeWeight(2);
    line(-0.5 * r, -0.5 * r, 0, r);
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void drawCameraDistance (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    line(-r, 0, r, 0);
    strokeWeight(2);
    line(0, 0, r, 0.5 * r);
    line(0, 0, -r, 0.5 * r);
    strokeWeight(2);
    line(0, 0, 0, r);
  
    strokeWeight(1);
    stroke(255);
    fill(127, 63, 0); 
    {
      //float d = 0.625 * r;
      float d = 0.5 * r;
  
      beginShape();
      vertex(0, 0);
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, -d);
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
  
      beginShape();
      vertex(-funcs.cos_ang(30) * d, -funcs.sin_ang(30) * d);
      vertex(0, 0);
      vertex(0, d);
      vertex(-funcs.cos_ang(30) * d, (1 - funcs.sin_ang(30)) * d);
      endShape(CLOSE);
    }  
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }
  
  
  
  void drawDistZ (int _type, float x, float y, float r) {
  
    pushMatrix();
    translate(x, y);
  
    strokeWeight(1);
    stroke(255); 
    line(-r, 0, r, 0);
    strokeWeight(2);
    line(0, 0, r, 0.5 * r);
    line(0, 0, -r, 0.5 * r);
    strokeWeight(2);
    line(0, 0, 0, r);
  
  
    strokeWeight(0);
  
    popMatrix();
  
    this.displayText = false;
  }


}

solarchvision_UI_BAR_b UI_BAR_b = new solarchvision_UI_BAR_b(); 






class solarchvision_UI_BAR_c {
  
  private final static String CLASS_STAMP = "UI_BAR_c";

  boolean update = true;
  
  void draw () {
    if (this.update) {
      
      this.update = false;
      
      int maxDisplayLines = 2;
  
      if (typeUserCommand == 1) {
        fill(0);
      }
      else {
        fill(63);
      }
      noStroke();
      rect(0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H, width, SOLARCHVISION_pixel_C);
  
      noStroke();
      
      textSize(1.5 * MessageSize);
      
  
      pushMatrix();
      translate(0, 0.333 * MessageSize + SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H);
  
      for (int q = 0; q < maxDisplayLines; q++) {
        
        int n = allCommands.length + q - maxDisplayLines;
        
        if ((0 <= n) && (n < allCommands.length)) {
          
          textAlign(RIGHT, CENTER);
          fill(255,127,0);
          text(allMessages[n], width - 0.5 * MessageSize, q * 1.5 * MessageSize);
          
          textAlign(LEFT, CENTER);
          fill(255);
          text(allCommands[n], 0.5 * MessageSize, q * 1.5 * MessageSize);
  
        }
      }
      
      popMatrix();
  
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }  
  }

}

solarchvision_UI_BAR_c UI_BAR_c = new solarchvision_UI_BAR_c(); 





class solarchvision_UI_BAR_d {
  
  private final static String CLASS_STAMP = "UI_BAR_d";

  boolean update = true;
  
  float tab;
  
  String[][] Items = {
  
    {
      "Day"
    }
    , 
    {
      "Year"
    }
    , 
    {
      "Scenario"
    }
  };         
  
  
  
  void draw () {
  
    if (this.update) {
  
      this.update = false;
  
      this.tab = SOLARCHVISION_pixel_D / float(this.Items.length);
  
      fill(191);
      noStroke();
      rect(0, SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C, width, SOLARCHVISION_pixel_D);
  
  
  
      float displayBarHeight = MessageSize;
      float displayBarWidth = 2 * SOLARCHVISION_pixel_W; 
  
      STUDY.X_control = 0.5 * displayBarWidth;
      STUDY.Y_control = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + 0.5 * this.tab;
  
      for (int i = 0; i < this.Items.length; i++) {
  
        float x1 = STUDY.X_control - 0.3666 * displayBarWidth;
        float x2 = STUDY.X_control + 0.4875 * displayBarWidth;
        float y1 = STUDY.Y_control - 0.45 * displayBarHeight;
        float y2 = STUDY.Y_control + 0.45 * displayBarHeight;
  
        fill(127);
        noStroke();      
        rect(x1, y1, x2 - x1, y2 - y1);      
  
        textAlign(RIGHT, CENTER);   
        stroke(0); 
        fill(0);
        textSize(1.25 * MessageSize);
  
        text(this.Items[i][0] + ": ", x1, STUDY.Y_control - 0.2 * MessageSize);
  
        if (this.Items[i][0].equals("Day")) {
  
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {
  
            if (mouseButton == LEFT) {
              STUDY.i_Start = int(funcs.roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));
  
              ROLLOUT.update = true;
              STUDY.update = true;
              WIN3D.update = true;
              WORLD.update = true;
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
  
            if (mouseButton == RIGHT) {
              STUDY.i_End = int(funcs.roundTo(24.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));
  
              ROLLOUT.update = true;
              STUDY.update = true;
              WIN3D.update = true;
              WORLD.update = true;
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }        
  
          float x_start = x1 + (x2 - x1) * (STUDY.i_Start) / 24.0;  
          float x_end = x1 + (x2 - x1) * (STUDY.i_End + 1) / 24.0;
  
          fill(0, 191, 0, 191);
          noStroke();
  
          if (STUDY.i_Start <= STUDY.i_End) { 
            rect(x_start, y1, x_end - x_start, y2 - y1);
          } else {
            rect(x1, y1, x_end - x1, y2 - y1);
            rect(x_start, y1, x2 - x_start, y2 - y1);
          }
  
          textAlign(CENTER, CENTER);   
          stroke(0); 
          fill(0);
          textSize(1.25 * MessageSize);
  
          for (int j = 0; j < 24; j++) {
            text(nf(j, 0), x1 + (x2 - x1) * (j + 0.5) / 24.0, STUDY.Y_control - 0.2 * MessageSize);
          }
        }
  
        if (this.Items[i][0].equals("Year")) {
  
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {
  
            if (mouseButton == LEFT) {
              float keep_TIME_Date = TIME.date;
              TIME.date = (int(funcs.roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
              TIME.updateDate(); 
              TIME.beginDay = int(TIME.beginDay + (TIME.date - keep_TIME_Date) + 365) % 365;
              update_ENSEMBLE_FORECAST(TIME.year, TIME.month, TIME.day, TIME.hour);
              
              STUDY.update = true; 
              ROLLOUT.update = true;
              WIN3D.update = true;            
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
  
            if (mouseButton == RIGHT) {
  
              float _DATE2 = (int(funcs.roundTo(365.0 * (SOLARCHVISION_X_clicked - x1) / (x2 - x1), 1)) + 286) % 365;
  
              if (TIME.date > _DATE2) _DATE2 += 365;
  
              STUDY.perDays = int(funcs.roundTo((_DATE2 - TIME.date) / float(STUDY.j_End - STUDY.j_Start), 1));
  
              if (STUDY.perDays < 0) STUDY.perDays = 1;
  
              STUDY.update = true; 
              ROLLOUT.update = true;
              WIN3D.update = true;
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }        
  
          float keep_STUDY_perDays = STUDY.perDays;
          int keep_STUDY_joinDays = STUDY.joinDays;
          if ((CurrentDataSource == dataID_ENSEMBLE_FORECAST) || (CurrentDataSource == dataID_ENSEMBLE_OBSERVED)) {
            STUDY.perDays = 1;
            STUDY.joinDays = 1;
          }
  
          for (int j = STUDY.j_Start; j < STUDY.j_End; j++) { 
  
            for (int j_ADD = 0; j_ADD < STUDY.joinDays; j_ADD++) {    
  
              int now_j = int(j * STUDY.perDays + (j_ADD - int(funcs.roundTo(0.5 * STUDY.joinDays, 1))) + TIME.beginDay + 365) % 365;
  
              if (now_j >= 365) {
                now_j = now_j % 365;
              }
              if (now_j < 0) {
                now_j = (now_j + 365) % 365;
              }
  
              float x_start = x1 + (x2 - x1) * ((now_j) % 365) / 365.0;  
              float x_end = x1 + (x2 - x1) * ((now_j + 1) % 365) / 365.0;
  
              fill(191, 0, 0, 127);
              noStroke();
  
              if (x_start <= x_end) { 
                rect(x_start, y1, x_end - x_start, y2 - y1);
              } else {
                rect(x1, y1, x_end - x1, y2 - y1);
                rect(x_start, y1, x2 - x_start, y2 - y1);
              }
            }
          }
  
          {
            textAlign(CENTER, CENTER);   
            stroke(0); 
            fill(0);
            textSize(1.25 * MessageSize);
  
            for (int j = 0; j < 12; j++) {
              text(TIME.namesOfMonths[j][Language_Active], x1 + (x2 - x1) * (j + 0.5) / 12.0, STUDY.Y_control - 0.2 * MessageSize);
            }
          }        
  
          STUDY.perDays = keep_STUDY_perDays;
          STUDY.joinDays = keep_STUDY_joinDays;
        }
  
  
        if (this.Items[i][0].equals("Scenario")) {
  
          int n1 = 0;
          int n2 = 1;
  
          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
            n1 = 1950;
            n2 = 2050;
          }
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
            n1 = 1950;
            n2 = 2050;
          }        
          if (CurrentDataSource == dataID_CLIMATE_TMYEPW) {
            n1 = 1950;
            n2 = 2050;
          }        
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
            n1 = ENSEMBLE_FORECAST_start;
            n2 = ENSEMBLE_FORECAST_end;
          }        
          if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
            n1 = ENSEMBLE_OBSERVED_start;
            n2 = ENSEMBLE_OBSERVED_end;
          }  
  
          if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {
  
            if (mouseButton == LEFT) {
  
              int V_selection = n1 + int(funcs.roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));
  
              if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                SampleYear_Start = V_selection;
  
                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }
  
              }
              
              if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                SampleYear_Start = V_selection;
  
                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }
  
              }            
  
              if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                SampleMember_Start = V_selection;
  
                if (SampleMember_Start > SampleMember_End) {
                  int swap_tmp = SampleMember_Start;
                  SampleMember_Start = SampleMember_End;
                  SampleMember_End = swap_tmp;
                }
  
              }            
  
              if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                SampleStation_Start = V_selection;
  
                if (SampleStation_Start > SampleStation_End) {
                  int swap_tmp = SampleStation_Start;
                  SampleStation_Start = SampleStation_End;
                  SampleStation_End = swap_tmp;
                }
  
              }       
  
              ROLLOUT.update = true;
              STUDY.update = true;
              WIN3D.update = true;
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
  
            if (mouseButton == RIGHT) {
  
              int V_selection = n1 + int(funcs.roundTo((n2 - n1 + 1) * (SOLARCHVISION_X_clicked - x1) / (x2 - x1) - 0.5, 1));
  
              if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
                SampleYear_End = V_selection;
  
                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }
  
              }
  
              if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
                SampleYear_End = V_selection;
  
                if (SampleYear_Start > SampleYear_End) {
                  int swap_tmp = SampleYear_Start;
                  SampleYear_Start = SampleYear_End;
                  SampleYear_End = swap_tmp;
                }
  
              }
  
              if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
                SampleMember_End = V_selection;
  
                if (SampleMember_Start > SampleMember_End) {
                  int swap_tmp = SampleMember_Start;
                  SampleMember_Start = SampleMember_End;
                  SampleMember_End = swap_tmp;
                }
  
              }
  
              if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
                SampleStation_End = V_selection;
  
                if (SampleStation_Start > SampleStation_End) {
                  int swap_tmp = SampleStation_Start;
                  SampleStation_Start = SampleStation_End;
                  SampleStation_End = swap_tmp;
                }
  
              }                
  
              ROLLOUT.update = true;
              STUDY.update = true;
              WIN3D.update = true;
  
              SOLARCHVISION_find_which_bakings_to_regenerate();
            }
          }        
  
          float V_start = 0;  
          float V_end = 0;        
  
          if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
            V_start = SampleYear_Start;
            V_end = SampleYear_End;
          }
          if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
            V_start = SampleYear_Start;
            V_end = SampleYear_End;
          }        
          if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
            V_start = SampleMember_Start;
            V_end = SampleMember_End;
          }
          if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
            V_start = SampleStation_Start;
            V_end = SampleStation_End;
          }        
  
          float x_start = x1 + (x2 - x1) * (V_start - n1) / float(n2 - n1 + 1);  
          float x_end = x1 + (x2 - x1) * (V_end - n1 + 1) / float(n2 - n1 + 1);
  
          fill(0, 0, 191, 191);
          noStroke();
  
          if (x_start <= x_end) { 
            rect(x_start, y1, x_end - x_start, y2 - y1);
          }
  
          textAlign(CENTER, CENTER);   
          stroke(0); 
          fill(0);
          textSize(1.25 * MessageSize);
  
          for (int j = 0; j < n2 - n1 + 1; j++) {
  
            String txt = ".";
  
            if (j % 5 == 0) {
              txt = "|";
            }          
  
            if (CurrentDataSource == dataID_CLIMATE_CWEEDS) {
              if ((j % 10 == 5)) {
                txt = nf(j - 5 + n1, 0) + "s";
              }
            }
            if (CurrentDataSource == dataID_CLIMATE_CLMREC) {
              if ((j % 10 == 5)) {
                txt = nf(j - 5 + n1, 0) + "s";
              }
            }          
            if (CurrentDataSource == dataID_ENSEMBLE_FORECAST) {
              //if ((j % 1 == 0)) {
              txt = nf(j + n1, 0);
              //}
            }
            if (CurrentDataSource == dataID_ENSEMBLE_OBSERVED) {
              //if ((j % 1 == 0)) {
              txt = SWOB_Coordinates[nearest_Station_ENSEMBLE_OBSERVED_id[j]].getCode();
              //}
            }                 
  
            text(txt, x1 + (x2 - x1) * (j + 0.5) / float(n2 - n1 + 1), STUDY.Y_control - 0.2 * MessageSize);
          }
        }        
  
  
  
  
        STUDY.Y_control += this.tab;
      }
  
  
      displayBarWidth = ROLLOUT.dX; // <<<<<<<<<
      displayBarHeight = 4.5 * MessageSize;
  
      float temp_offsetX = ROLLOUT.cX + 0.5 * displayBarWidth;
      float temp_offsetY = SOLARCHVISION_pixel_A + SOLARCHVISION_pixel_B + 2 * SOLARCHVISION_pixel_H + SOLARCHVISION_pixel_C + 0.5 * displayBarHeight;
  
      for (int n = 0; n < 9; n++) {
  
        int i = 2 - n / 3;
        int j = 2 - n % 3;
  
        float rx = (i + 0.5) / 3.0 - 0.5;
        float ry = (j + 0.5) / 3.0 - 0.5;
  
        float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
        float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
        float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
        float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;
  
        if (isInside(SOLARCHVISION_X_clicked, SOLARCHVISION_Y_clicked, x1, y1, x2, y2) == 1) {
  
          STUDY.ImpactLayer = n;
  
          STUDY.update = true; 
          ROLLOUT.update = true;
          WIN3D.update = true;
  
          SOLARCHVISION_find_which_bakings_to_regenerate();
        }
      }
  
      for (int n = 0; n < 9; n++) {
  
        int i = 2 - n / 3;
        int j = 2 - n % 3;
  
        float rx = (i + 0.5) / 3.0 - 0.5;
        float ry = (j + 0.5) / 3.0 - 0.5;
  
        float x1 = temp_offsetX + (rx - 0.16) * displayBarWidth;
        float x2 = temp_offsetX + (rx + 0.16) * displayBarWidth;
        float y1 = temp_offsetY + (ry - 0.15) * displayBarHeight;
        float y2 = temp_offsetY + (ry + 0.15) * displayBarHeight;
  
        if (n == STUDY.ImpactLayer) { 
          fill(255, 127, 0);
          noStroke();
        } else if (n / 3 == STUDY.ImpactLayer / 3) {
          fill(127, 63, 0);
          noStroke();
        } else {
          fill(127);
          noStroke();
        }  
        rect(x1, y1, x2 - x1, y2 - y1);      
  
        textAlign(CENTER, CENTER);   
        if (n == STUDY.ImpactLayer) { 
          stroke(0); 
          fill(0);
        } else if (n / 3 == STUDY.ImpactLayer / 3) {
          stroke(191); 
          fill(191);
        } else {
          stroke(255); 
          fill(255);
        }        
  
        if (n == STUDY.ImpactLayer) { 
          textSize(1.25 * MessageSize);
        } else {
          textSize(1.125 * MessageSize);
        }
  
        text(STAT_N_Title[n], 0.5 * (x1 + x2), 0.5 * (y1 + y2) - 0.2 * MessageSize);
      }    
  
      SOLARCHVISION_X_clicked = -1;
      SOLARCHVISION_Y_clicked = -1;
    }
  }   
  
}

solarchvision_UI_BAR_d UI_BAR_d = new solarchvision_UI_BAR_d();   
  
  




String[] allCommands = {"SOLARCHVISION Command Input:", ""};
String[] allMessages = {"SOLARCHVISION Command Output:", ""};


int typeUserCommand = 0;

void COMIN_keyPressed (KeyEvent e) {



  if (e.isAltDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {
      }
    }
  } else if (e.isControlDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    } else {
      switch(key) {
      }
    }
  } else if (e.isShiftDown()) {
    if (key == CODED) { 
      switch(keyCode) {
      }
    }
  }


  if ((e.isAltDown() != true) && (e.isControlDown() != true) && (e.isShiftDown() != true)) {

    if (key == CODED) { 
      switch(keyCode) {
      }
    }
  }

  if ((e.isAltDown() != true) && (e.isControlDown() != true)) {

    if (key != CODED) { 
      switch(key) {

       case ENTER:
         String[] newCommand = {""};
         String[] newMessage = {""};
         
         allMessages[allMessages.length - 1] = SOLARCHVISION_executeCommand(allCommands[allCommands.length - 1]);         
         
         allCommands = concat(allCommands, newCommand);  
         allMessages = concat(allMessages, newMessage);
         break;
        
       case BACKSPACE: 
          if (allCommands[allCommands.length - 1].length() > 0) {
            allCommands[allCommands.length - 1] = allCommands[allCommands.length - 1].substring(0, allCommands[allCommands.length - 1].length() - 1);
          }
          break;

        default:
          if ((31 < key) && (key < 127)) { 
            allCommands[allCommands.length - 1] += key;
          }
          break;
      }
      
      
    }
  }
}

void SOLARCHVISION_execute_commands_TXT (String FileName) {

  String[] FileALL = loadStrings(FileName);

  for (int f = 0; f < FileALL.length; f++) {

    String lineSTR = FileALL[f];
  
    SOLARCHVISION_executeCommand(lineSTR);
  } 
  
}

String SOLARCHVISION_executeCommand (String lineSTR) {

  String return_message = "";
  
  lineSTR = lineSTR.replace("\"", ""); 
  
  String[] parts = split(lineSTR, ' ');
  
  String Command_CAPITAL = parts[0].toUpperCase();
  
  if (Command_CAPITAL.equals("CLS")) {
    allCommands = new String[1];
    allMessages = new String[1];

    allCommands[0] = "";
    allMessages[0] = "";
  }
  
  else if (Command_CAPITAL.equals("OPEN")) {
    selectInput("Select a file to open:", "SOLARCHVISION_fileSelected_Open");
  }          

  else if (Command_CAPITAL.equals("SAVE.AS")) {
    selectOutput("Select a file to write to:", "SOLARCHVISION_fileSelected_SaveAs");
  }

  else if (Command_CAPITAL.equals("SAVE")) {
    SOLARCHVISION_save_project(Folder_Project + "/" + ProjectName + ".xml");
  }    

  else if (Command_CAPITAL.equals("HOLD")) {
    SOLARCHVISION_hold_project();
  }  

  else if (Command_CAPITAL.equals("FETCH")) {
    SOLARCHVISION_fetch_project();
  }    

  else if (Command_CAPITAL.equals("IMPORT")) {
    selectInput("Select OBJ file to import:", "SOLARCHVISION_SelectFile_Import_3DModel");
  }   

  else if (Command_CAPITAL.equals("EXECUTE")) {
    selectInput("Select TXT file to execute:", "SOLARCHVISION_SelectFile_Execute_CommandFile");
  }
  
  else if (Command_CAPITAL.equals("EXPORT.OBJ.TIMESERIES")) {
    SOLARCHVISION_export_objects_OBJ_timeSeries();
  }    

  else if (Command_CAPITAL.equals("EXPORT.OBJ.DATESERIES")) {
    SOLARCHVISION_export_objects_OBJ_dateSeries();
  }      

  else if (Command_CAPITAL.equals("EXPORT.OBJ")) {
    SOLARCHVISION_export_objects_OBJ("");
  }    
  
  else if (Command_CAPITAL.equals("EXPORT.RAD")) {
    SOLARCHVISION_export_objects_RAD();
  }

  else if (Command_CAPITAL.equals("EXPORT.SCR")) {
    SOLARCHVISION_export_objects_SCR();
  }                

  else if (Command_CAPITAL.equals("QUIT")) {
    exit();
  }      





  else if (Command_CAPITAL.equals("MOVE")) {
    if (parts.length > 1) {
      float dx = 0;
      float dy = 0;
      float dz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
        }
        else {
               if (q == 1) dx = float(parameters[0]);
          else if (q == 2) dy = float(parameters[0]);
          else if (q == 3) dz = float(parameters[0]);
        }
      }
      userSelections.move_Selection(dx, dy, dz);
      WIN3D.update = true;
    }
    else {
      return_message = "Move dx=? dy=? dz=?";
      
      UI_BAR_b.hghlight("MV³");
      UI_BAR_b.update = true;
    }
  }  
  
  else if ((Command_CAPITAL.equals("ROTATE")) || (Command_CAPITAL.equals("ROTATEX")) || (Command_CAPITAL.equals("ROTATEY")) || (Command_CAPITAL.equals("ROTATEZ"))) {
    if (parts.length > 1) {
      int v = 2;
      if (Command_CAPITAL.equals("ROTATEX")) v = 0;
      if (Command_CAPITAL.equals("ROTATEY")) v = 1;
      if (Command_CAPITAL.equals("ROTATEZ")) v = 2;
      
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) r = float(parameters[0]);
        }      
      }
      userSelections.rotate_Selection(x, y, z, r, v);
      WIN3D.update = true;
    }
    else {
      return_message = "Rotate[X|Y|Z] r=? x=? y=? z=?";
  
      UI_set_to_Modify_Rotate(2);
      UI_BAR_b.update = true;
    }    
  }    
  
  else if (Command_CAPITAL.equals("SCALE")) {
    if (parts.length > 1) {
      float sx = 1;
      float sy = 1;
      float sz = 1;
      
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("s")) {sx = float(parameters[1]); sy = sx; sz = sx;}
          else if (low_case.equals("sxy")) {sx = float(parameters[1]); sy = sx;}             
          else if (low_case.equals("syz")) {sy = float(parameters[1]); sz = sy;}
          else if (low_case.equals("szx")) {sz = float(parameters[1]); sx = sz;}
          else if (low_case.equals("sx")) sx = float(parameters[1]);
          else if (low_case.equals("sy")) sy = float(parameters[1]);
          else if (low_case.equals("sz")) sz = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
        else {
          if (q == 1) {sx = float(parameters[0]); sy = sx; sz = sx;}
        }           
      }
      userSelections.scale_Selection(x, y, z, sx, sy, sz);
      WIN3D.update = true;
    }
    else {
      return_message = "Scale s=? sx=? sy=? sz=? x=? y=? z=?";
      
      UI_BAR_b.hghlight("SC³");
      UI_BAR_b.update = true;      
    }        
  }    
  
  else if (Command_CAPITAL.equals("DELETE")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("all")) {SOLARCHVISION_delete_All(); WIN3D.update = true;}
        else if (low_case.equals("selection")) {allModel3Ds.delete_Selection(); WIN3D.update = true;}
        else if (low_case.equals("group3ds")) {allModel3Ds.delete_allGroups(); WIN3D.update = true;}
        else if (low_case.equals("object2ds")) {allModel2Ds.delete(); WIN3D.update = true;}
        else if (low_case.equals("model1ds")) {allModel1Ds.delete(); WIN3D.update = true;}
        else if (low_case.equals("vertices")) {allModel3Ds.deleteIsolatedVertices_Selection(); WIN3D.update = true;}
        else if (low_case.equals("faces")) {allModel3Ds.delete_Faces(); WIN3D.update = true;}
        else if (low_case.equals("lines")) {allModel3Ds.delete_Curves(); WIN3D.update = true;}
        else if (low_case.equals("solids")) {allModel3Ds.delete_allSolids(); WIN3D.update = true;}
        else if (low_case.equals("sections")) {allModel3Ds.delete_allSections(); WIN3D.update = true;}
        else if (low_case.equals("cameras")) {allModel3Ds.delete_allCameras(); WIN3D.update = true;}
      }
    }
    else {
      return_message = "Delete all/selection/group3Ds/object2Ds/allModel1Ds/vertices/faces/solids/sections/cameras";
    }
  }   
  
  else if (Command_CAPITAL.equals("COPY")) {
    if (parts.length > 1) {
      int n = 1;
      float dx = 0;
      float dy = 0;
      float dz = 0;
      float rx = 0;
      float ry = 0;
      float rz = 0;      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("n")) n = int(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);          
        }
      }
      
      for (int q = 0; q < n; q++) {
        allModel3Ds.duplicate_Selection(0); 
        if ((dx != 0) || (dy != 0) || (dz != 0)) userSelections.move_Selection(dx, dy, dz);
        if (rx != 0) userSelections.rotate_Selection(0, 0, 0, rx, 0);
        if (ry != 0) userSelections.rotate_Selection(0, 0, 0, ry, 1);
        if (rz != 0) userSelections.rotate_Selection(0, 0, 0, rz, 2);
      }
      WIN3D.update = true;
    }
    else {
      return_message = "Copy n=? dx=? dy=? dz=? rx=? ry=? rz=?";
    }
  }   
  
  else if (Command_CAPITAL.equals("SELECT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("group3ds")) {current_ObjectCategory = ObjectCategory.GROUP; UI_BAR_b.update = true;}
        else if (low_case.equals("object2ds")) {current_ObjectCategory = ObjectCategory.MODEL2D; UI_BAR_b.update = true;}
        else if (low_case.equals("model1ds")) {current_ObjectCategory = ObjectCategory.MODEL1D; UI_BAR_b.update = true;}
        else if (low_case.equals("vertices")) {current_ObjectCategory = ObjectCategory.VERTEX; UI_BAR_b.update = true;}
        else if (low_case.equals("faces")) {current_ObjectCategory = ObjectCategory.FACE; UI_BAR_b.update = true;}
        else if (low_case.equals("lines")) {current_ObjectCategory = ObjectCategory.CURVE; UI_BAR_b.update = true;}
        else if (low_case.equals("solids")) {current_ObjectCategory = ObjectCategory.SOLID; UI_BAR_b.update = true;}
        else if (low_case.equals("sections")) {current_ObjectCategory = ObjectCategory.SECTION; UI_BAR_b.update = true;}
        else if (low_case.equals("cameras")) {current_ObjectCategory = ObjectCategory.CAMERA; UI_BAR_b.update = true;}
        else if (low_case.equals("landpoints")) {current_ObjectCategory = ObjectCategory.LANDPOINT; UI_BAR_b.update = true;}
      }
      
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("all")) {allModel3Ds.select_All(); WIN3D.update = true;}
        else if (low_case.equals("reverse")) {allModel3Ds.reverse_Selection(); WIN3D.update = true;}
        else if (low_case.equals("nothing")) {allModel3Ds.deselect_All(); WIN3D.update = true;}
        else if (low_case.equals("last")) {allModel3Ds.select_Last(); WIN3D.update = true;}
      }
    }
    else {
      return_message = "Select all/last/nothing/reverse group3Ds/object2Ds/allModel1Ds/vertices/faces/solids/sections/cameras/landpoint";
    }
  }





  
  else if (Command_CAPITAL.equals("2DMAN")) {
    if (parts.length > 1) {
      String t = "PEOPLE";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
        }
      }
      allModel2Ds.add_single(t, m, x, y, z, 2.5);
      WIN3D.update = true;  
      current_ObjectCategory = ObjectCategory.MODEL2D; 
      UI_BAR_b.update = true;
      //allModel3Ds.select_Last();
    }
    else {
      return_message = "2Dman m=? x=? y=? z=?";

      UI_set_to_Create_Person();
      UI_BAR_b.hghlight("Person");
      UI_BAR_b.update = true;      
    }  
  }
     
  else if (Command_CAPITAL.equals("2DTREE")) {
    if (parts.length > 1) {
      String t = "TREES";
      int m = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel2Ds.add_single(t, m, x, y, z, h);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.MODEL2D; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "2Dtree m=? x=? y=? z=? h=?";
      
      UI_set_to_Create_Tree();
      UI_BAR_b.hghlight("2D-Tree");
      UI_BAR_b.update = true;      
    }  
  }    
 
  else if (Command_CAPITAL.equals("3DTREE")) {
    if (parts.length > 1) {
      int m = 0;
      int Sd = 0; //PlantSeed
      int Min = 2; //PlantDegreeMin
      int Max = 5; //PlantDegreeMax
      float x = 0;
      float y = 0;
      float z = 0;
      float h = 5.0;
      float r = 0;
      float Tk = 1.0; //TrunkSize
      float Lf = 1.0; //LeafSize
       
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("sd")) Sd = int(parameters[1]);
          else if (low_case.equals("min")) Min = int(parameters[1]);
          else if (low_case.equals("max")) Max = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]) * PI / 180.0;
          else if (low_case.equals("tk")) Tk = float(parameters[1]);
          else if (low_case.equals("lf")) Lf = float(parameters[1]);
        }
      }
      if (h != 0) {
        allModel1Ds.add_single(m, x, y, z, h, r, Min, Max, Sd, Tk, Lf);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.MODEL1D; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "3Dtree m=? Sd=? Min=? Max=? x=? y=? z=? h=? r=? Tk=? Lf=?";
      
      UI_set_to_Create_allModel1Ds();
      UI_BAR_b.hghlight("3D-Tree");
      UI_BAR_b.update = true;      
    }  
  }     

  else if (Command_CAPITAL.equals("BOX2P")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x2 - x1 != 0) && (y2 - y1 != 0) && (z2 - z1 != 0)) {   
        allModel3Ds.add_Box_Corners(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Box2P m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";

      UI_set_to_Create_Box();
      UI_BAR_b.hghlight("Box");
      UI_BAR_b.update = true;            
    }  
  }  
  
  else if (Command_CAPITAL.equals("BOX")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_Box_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Box m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";

      UI_set_to_Create_Box();
      UI_BAR_b.hghlight("Box");
      UI_BAR_b.update = true;      
    }  
  }     

  else if (Command_CAPITAL.equals("HOUSE1")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_House1_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "House1 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House1();
      UI_BAR_b.hghlight("House1");
      UI_BAR_b.update = true;      
    }  
  }     
  
  else if (Command_CAPITAL.equals("HOUSE2")) {
    if (parts.length > 1) {
      int m = -1;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float h = 3;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_House2_Core(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, h, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "House2 m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? dh=? r=?";

      UI_set_to_Create_House1();
      UI_BAR_b.hghlight("House2");
      UI_BAR_b.update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("CYLINDER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 16;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_SuperCylinder(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, 0.5 * d, 0.5 * h, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Cylinder m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";
      
      UI_set_to_Create_Cylinder();
      UI_BAR_b.hghlight("Cylinder");
      UI_BAR_b.update = true;            
    }  
  }   

  else if (Command_CAPITAL.equals("SPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_CrystalSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, 0, 90 + r); // passing with isSky:0
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Sphere m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";
      
      UI_set_to_Create_Sphere();
      UI_BAR_b.hghlight("Sphere");
      UI_BAR_b.update = true;      
    }  
  }   


  else if (Command_CAPITAL.equals("SUPERSPHERE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float px = 2;
      float py = 2;
      float pz = 2;      
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0) && (px > 0) && (py > 0) && (pz > 0)) {   
        allModel3Ds.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, px, py, pz, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "SuperSphere m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? px=? py=? pz=? deg=? r=?";
      
      UI_set_to_Create_Sphere();
      UI_BAR_b.hghlight("Sphere");
      UI_BAR_b.update = true;      
    }  
  }   

  else if (Command_CAPITAL.equals("CUSHION")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 3;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_SuperSphere(m, tes, lyr, vsb, wgt, clz, x, y, z, CubePower, CubePower, 2, 0.5 * dx, 0.5 * dy, 0.5 * dz, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Cushion m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? deg=? r=?";
      
      UI_set_to_Create_Cushion();
      UI_BAR_b.hghlight("Cushion");
      UI_BAR_b.update = true;      
    }  
  }   
          

  else if (Command_CAPITAL.equals("OCTAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float dx = 6;
      float dy = 6;
      float dz = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("dx")) dx = float(parameters[1]);
          else if (low_case.equals("dy")) dy = float(parameters[1]);
          else if (low_case.equals("dz")) dz = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((dx != 0) && (dy != 0) && (dz != 0)) {   
        allModel3Ds.add_Octahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * dx, 0.5 * dy, 0.5 * dz, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Octahedron m=? tes=? lyr=? x=? y=? z=? dx=? dy=? dz=? r=?";
      
      UI_set_to_Create_Octahedron();
      UI_BAR_b.hghlight("Octahedron");
      UI_BAR_b.update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("ICOSAHEDRON")) {
    if (parts.length > 1) {
      int m = 7;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_Icosahedron(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Icosahedron m=? tes=? lyr=? x=? y=? z=? d=? r=?";
      
      UI_set_to_Create_Icosahedron();
      UI_BAR_b.hghlight("Icosahedron");
      UI_BAR_b.update = true;            
    }  
  } 
  
  else if (Command_CAPITAL.equals("POLYGONEXTRUDE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_PolygonExtrude(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.GROUP; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonExtrude m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";
      
      UI_set_to_Create_Extrude();
      UI_BAR_b.hghlight("Extrude");
      UI_BAR_b.update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("POLYGONHYPER")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float h = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_PolygonHyper(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, h, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonHyper m=? tes=? lyr=? x=? y=? z=? d=? h=? deg=? r=?";
      
      UI_set_to_Create_Hyper();
      UI_BAR_b.hghlight("Hyper");
      UI_BAR_b.update = true;      
    }  
  }       

  else if (Command_CAPITAL.equals("POLYGONMESH")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 6;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if (d != 0) {   
        allModel3Ds.add_PolygonMesh(m, tes, lyr, vsb, wgt, clz, x, y, z, 0.5 * d, deg, r);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "PolygonMesh m=? tes=? lyr=? x=? y=? z=? d=? deg=? r=?";
      
      UI_set_to_Create_Plane();
      UI_BAR_b.hghlight("Poly");
      UI_BAR_b.update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("MESH2")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
        }
      }
      if ((x1 == x2) || (y1 == y2) || (z1 == z2)) {   
        allModel3Ds.add_Mesh2(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh2 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=?";
    }  
  } 
 
  else if (Command_CAPITAL.equals("MESH3")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
        }
      }
      {   
        allModel3Ds.add_Mesh3(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh3 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=?";
    }  
  }    

  else if (Command_CAPITAL.equals("MESH4")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);          
        }
      }
      {   
        allModel3Ds.add_Mesh4(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh4 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=?";
    }  
  }  

  else if (Command_CAPITAL.equals("MESH5")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;    
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;          
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);
          else if (low_case.equals("x5")) x5 = float(parameters[1]);
          else if (low_case.equals("y5")) y5 = float(parameters[1]);
          else if (low_case.equals("z5")) z5 = float(parameters[1]);            
        }
      }
      {   
        allModel3Ds.add_Mesh5(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh5 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=?";
    }  
  }  
  
  else if (Command_CAPITAL.equals("MESH6")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x1 = 0;
      float y1 = 0;
      float z1 = 0;
      float x2 = 0;
      float y2 = 0;
      float z2 = 0;
      float x3 = 0;
      float y3 = 0;
      float z3 = 0;
      float x4 = 0;
      float y4 = 0;
      float z4 = 0;    
      float x5 = 0;
      float y5 = 0;
      float z5 = 0;
      float x6 = 0;
      float y6 = 0;
      float z6 = 0;         
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x1")) x1 = float(parameters[1]);
          else if (low_case.equals("y1")) y1 = float(parameters[1]);
          else if (low_case.equals("z1")) z1 = float(parameters[1]);
          else if (low_case.equals("x2")) x2 = float(parameters[1]);
          else if (low_case.equals("y2")) y2 = float(parameters[1]);
          else if (low_case.equals("z2")) z2 = float(parameters[1]);
          else if (low_case.equals("x3")) x3 = float(parameters[1]);
          else if (low_case.equals("y3")) y3 = float(parameters[1]);
          else if (low_case.equals("z3")) z3 = float(parameters[1]);
          else if (low_case.equals("x4")) x4 = float(parameters[1]);
          else if (low_case.equals("y4")) y4 = float(parameters[1]);
          else if (low_case.equals("z4")) z4 = float(parameters[1]);
          else if (low_case.equals("x5")) x5 = float(parameters[1]);
          else if (low_case.equals("y5")) y5 = float(parameters[1]);
          else if (low_case.equals("z5")) z5 = float(parameters[1]);            
          else if (low_case.equals("x6")) x6 = float(parameters[1]);
          else if (low_case.equals("y6")) y6 = float(parameters[1]);
          else if (low_case.equals("z6")) z6 = float(parameters[1]);         
        }
      }
      {   
        allModel3Ds.add_Mesh6(m, tes, lyr, vsb, wgt, clz, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, x5, y5, z5, x6, y6, z6);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Mesh6 m=? tes=? lyr=? x1=? y1=? z1=? x2=? y2=? z2=? x3=? y3=? z3=? x4=? y4=? z4=? x5=? y5=? z5=? x6=? y6=? z6=?";
    }  
  }    

  else if (Command_CAPITAL.equals("H_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float w = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("w")) w = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
          else if (low_case.equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (w != 0)) {
        allModel3Ds.add_H_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, d, w, a, b);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "H_Shade m=? tes=? lyr=? x=? y=? z=? d=? w=? a=? b=?";
    }  
  }
  
  else if (Command_CAPITAL.equals("V_SHADE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float x = 0;
      float y = 0;
      float z = 0;
      float d = 0;
      float h = 0;
      float a = 0;
      float b = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);

          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("d")) d = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
          else if (low_case.equals("b")) b = float(parameters[1]);
        }
      }
      if ((d != 0) && (h != 0)) {   
        allModel3Ds.add_V_shade(m, tes, lyr, vsb, wgt, clz, x, y, z, h, d, a, b);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.FACE; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "V_Shade m=? tes=? lyr=? x=? y=? z=? d=? h=? a=? b=?";
    }  
  }  

  else if (Command_CAPITAL.equals("SOLID")) {
    if (parts.length > 1) {
      float v = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float px = 2;
      float py = 2;
      float pz = 2;
      float sx = 1;
      float sy = 1;
      float sz = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("v")) v = float(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("sx")) sx = float(parameters[1]);
          else if (low_case.equals("sy")) sy = float(parameters[1]);
          else if (low_case.equals("sz")) sz = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);
        }
      }
      if ((px != 0) && (py != 0) && (pz != 0) && (sx != 0) && (sy != 0) && (sz != 0) && (v != 0)) {   
        allModel3Ds.add_Solid(x, y, z, px, py, pz, sx, sy, sz, rx, ry, rz, v);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.SOLID; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Solid x=? y=? z=? px=? py=? pz=? sx=? sy=? sz=? rx=? ry=? rz=? v=?";
      
      UI_set_to_Create_Solid();
      UI_BAR_b.hghlight("SLD");
      UI_BAR_b.update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("SECTION")) {
    if (parts.length > 1) {
      int t = 1;
      int i = 200;
      int j = 200;
      float w = 20;
      float h = 20;      
      float u = 0;
      float v = 0;
      float e = 0;
      float r = 0;
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("t")) t = int(parameters[1]);
          else if (low_case.equals("i")) i = int(parameters[1]);
          else if (low_case.equals("j")) j = int(parameters[1]);  
          else if (low_case.equals("w")) w = float(parameters[1]);
          else if (low_case.equals("h")) h = float(parameters[1]);          
          else if (low_case.equals("u")) u = float(parameters[1]);
          else if (low_case.equals("v")) v = float(parameters[1]);
          else if (low_case.equals("e")) e = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
        }
      }
      if ((t > 0) && (i > 0) && (j > 0) && (w > 0) && (h > 0)) {   
        allModel3Ds.add_Section(t, u, v, e, r, w, h, i, j);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.SECTION; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Section t=? i=? j=? w=? h=? u=? v=? e=? r=?";
      
      UI_set_to_Create_Section();
      UI_BAR_b.hghlight("SEC");
      UI_BAR_b.update = true;      
    }  
  }

  else if (Command_CAPITAL.equals("CAMERA")) {
    if (parts.length > 1) {
      int t = 1;
      float px = 0;
      float py = 0;
      float pz = 0;
      float pt = 1;
      float rx = 0;
      float ry = 0;
      float rz = 0;
      float rt = 5;
      float a = 60;
      
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("t")) t = int(parameters[1]);
          else if (low_case.equals("px")) px = float(parameters[1]);
          else if (low_case.equals("py")) py = float(parameters[1]);
          else if (low_case.equals("pz")) pz = float(parameters[1]);
          else if (low_case.equals("pt")) pt = float(parameters[1]);
          else if (low_case.equals("rx")) rx = float(parameters[1]);
          else if (low_case.equals("ry")) ry = float(parameters[1]);
          else if (low_case.equals("rz")) rz = float(parameters[1]);
          else if (low_case.equals("rt")) rt = float(parameters[1]);
          else if (low_case.equals("a")) a = float(parameters[1]);
        }
      }
      if (a != 0) {   
        allModel3Ds.add_Camera(t, px, py, pz, pt, rx, ry, rz, rt, a);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.CAMERA; 
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Camera t=? px=? py=? pz=? pt=? rx=? ry=? rz=? rt=? a=?";
      
      UI_set_to_Create_Camera();
      UI_BAR_b.hghlight("CAM");
      UI_BAR_b.update = true;      
    }  
  }  

  else if (Command_CAPITAL.equals("SPLINE")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 0;
      float[][] points = new float [0][3];
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);
          else if (low_case.equals("wgt")) wgt = int(parameters[1]);
          else if (low_case.equals("clz")) clz = int(parameters[1]);
        }
        else {
          String[] xyz = split(parts[q], ',');
          if (xyz.length > 2) {
            float[][] newPoint = {{float(xyz[0]), float(xyz[1]), float(xyz[2])}}; 
            points = (float[][]) concat(points, newPoint);
          }
        }        
      }
      if (points.length > 1) {   
        allModel3Ds.add_Spline(m, tes, lyr, vsb, wgt, clz, points);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.CURVE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Spline m=? tes=? lyr=? xtr=? wgt=? clz=? x1,y1,z1 x2,y2,z2 etc.";
      
      UI_set_to_Create_Curve();
      UI_BAR_b.hghlight("Curve");
      UI_BAR_b.update = true;                
    }  
  }  
  
  else if (Command_CAPITAL.equals("ARC")) {
    if (parts.length > 1) {
      int m = 7;
      int deg = 6;
      int tes = 0;
      int lyr = 0;
      int vsb = 1;
      int wgt = 0;
      int clz = 1;
      float x = 0;
      float y = 0;
      float z = 0;
      float r = 0;
      float rot = 0;
      float ang = 360; // complete circle
      for (int q = 1; q < parts.length; q++) {
        String[] parameters = split(parts[q], '=');
        if (parameters.length > 1) {
          String low_case = parameters[0].toLowerCase();
               if (low_case.equals("m")) m = int(parameters[1]);
          else if (low_case.equals("tes")) tes = int(parameters[1]);
          else if (low_case.equals("lyr")) lyr = int(parameters[1]);
          else if (low_case.equals("wgt")) wgt = int(parameters[1]);
          else if (low_case.equals("clz")) clz = int(parameters[1]);
          else if (low_case.equals("x")) x = float(parameters[1]);
          else if (low_case.equals("y")) y = float(parameters[1]);
          else if (low_case.equals("z")) z = float(parameters[1]);
          else if (low_case.equals("r")) r = float(parameters[1]);
          else if (low_case.equals("rot")) rot = float(parameters[1]);
          else if (low_case.equals("ang")) ang = float(parameters[1]);
          else if (low_case.equals("deg")) deg = int(parameters[1]);
        }
      }
      if ((r != 0) && (deg > 2)) {   
        allModel3Ds.add_Arc(m, tes, lyr, vsb, wgt, clz, x, y, z, r, deg, rot, ang);
        WIN3D.update = true;  
        current_ObjectCategory = ObjectCategory.CURVE;
        UI_BAR_b.update = true;
        //allModel3Ds.select_Last();
      }
    }
    else {
      return_message = "Arc m=? tes=? lyr=? xtr=? wgt=? clz=? x=? y=? z=? r=? deg=? rot=? ang=?";

      UI_set_to_Create_Curve();
      UI_BAR_b.hghlight("Curve");
      UI_BAR_b.update = true;                      
    }  
  } 
  
  else if (Command_CAPITAL.equals("PIVOT")) {
    if (parts.length > 1) {
      for (int q = 1; q < parts.length; q++) {
        String low_case = parts[q].toLowerCase();
             if (low_case.equals("minx")) UI_set_to_View_PivotX(-1);
        else if (low_case.equals("midx")) UI_set_to_View_PivotX(0);
        else if (low_case.equals("maxx")) UI_set_to_View_PivotX(1);
        else if (low_case.equals("miny")) UI_set_to_View_PivotY(-1);
        else if (low_case.equals("midy")) UI_set_to_View_PivotY(0);
        else if (low_case.equals("maxy")) UI_set_to_View_PivotY(1);
        else if (low_case.equals("minz")) UI_set_to_View_PivotZ(-1);
        else if (low_case.equals("midz")) UI_set_to_View_PivotZ(0);
        else if (low_case.equals("maxz")) UI_set_to_View_PivotZ(1);
      }
    }
    else {
      return_message = "PIVOT minX midY maxZ or other variations";
    }    
  }
  
  else if (Command_CAPITAL.equals("VERTEX>GROUP")) {
    allModel3Ds.convert_Vertices_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("FACE>GROUP")) {
    allModel3Ds.convert_Faces_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>FACE")) {
    allModel3Ds.convert_allGroups_to_Faces();
    current_ObjectCategory = ObjectCategory.FACE;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }    
  else if (Command_CAPITAL.equals("CURVE>GROUP")) {
    allModel3Ds.convert_Curves_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>CURVE")) {
    allModel3Ds.convert_allGroups_to_Curves();
    current_ObjectCategory = ObjectCategory.CURVE;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }            
  else if (Command_CAPITAL.equals("CURVE>VERTEX")) {
    allModel3Ds.convert_Curves_to_Vertices();
    current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  } 
  else if (Command_CAPITAL.equals("VERTEX>CURVE")) {
    allModel3Ds.convert_Vertices_to_Curves();
    current_ObjectCategory = ObjectCategory.CURVE;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }               
  else if (Command_CAPITAL.equals("GROUP>VERTEX")) {
    allModel3Ds.convert_allGroups_to_Vertices();
    current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }  
  else if (Command_CAPITAL.equals("FACE>VERTEX")) {
    allModel3Ds.convert_Faces_to_Vertices();
    current_ObjectCategory = ObjectCategory.VERTEX;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  } 
  else if (Command_CAPITAL.equals("VERTEX>FACE")) {
    allModel3Ds.convert_Vertices_to_Faces();
    current_ObjectCategory = ObjectCategory.FACE;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }    
  else if (Command_CAPITAL.equals("SOLID>GROUP")) {
    allModel3Ds.convert_allSolids_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>SOLID")) {
    allModel3Ds.convert_allGroups_to_allSolids();
    current_ObjectCategory = ObjectCategory.SOLID;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }                
  else if (Command_CAPITAL.equals("2D>GROUP")) {
    allModel3Ds.convert_allModel2Ds_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>2D")) {
    allModel3Ds.convert_allGroups_to_allModel2Ds();
    current_ObjectCategory = ObjectCategory.MODEL2D;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("1D>GROUP")) {
    allModel3Ds.convert_allModel1Ds_to_allGroups();
    current_ObjectCategory = ObjectCategory.GROUP;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }             
  else if (Command_CAPITAL.equals("GROUP>1D")) {
    allModel3Ds.convert_allGroups_to_allModel1Ds();
    current_ObjectCategory = ObjectCategory.MODEL1D;
    WIN3D.update = true;
    UI_BAR_b.update = true;
  }              

  else if (Command_CAPITAL.equals("DISTZ")) {
    UI_set_to_View_Truck(0);
    UI_BAR_b.hghlight("±CDZ");
    UI_BAR_b.update = true;    
  } 
  else if (Command_CAPITAL.equals("DISTC")) {
    UI_set_to_View_CameraDistance(0);
    UI_BAR_b.hghlight("±CDS");
    UI_BAR_b.update = true;    
  } 
  else if (Command_CAPITAL.equals("DISTP")) {
    UI_set_to_View_DistMouseXY(0);
    UI_BAR_b.hghlight("±CDM");
    UI_BAR_b.update = true;    
  } 


  else if (Command_CAPITAL.equals("SIZEALL")) {
    UI_set_to_View_AllModelSize();
    UI_BAR_b.hghlight("±SA");
    UI_BAR_b.update = true;    
  } 
  else if (Command_CAPITAL.equals("SIZESKY")) {
    UI_set_to_View_SkydomeSize();
    UI_BAR_b.hghlight("±SK");
    UI_BAR_b.update = true;    
  } 
  else if (Command_CAPITAL.equals("SIZE3D")) {
    UI_set_to_View_3DModelSize();
    UI_BAR_b.hghlight("±SZ");
    UI_BAR_b.update = true;    
  } 

  else if (Command_CAPITAL.equals("ALLVIEWPORTS")) {
    UI_set_to_Viewport(0);
    UI_BAR_b.hghlight("AllViewports");
    UI_BAR_b.update = true;    
  }   
  else if (Command_CAPITAL.equals("ENLARGE3D")) {
    UI_set_to_Viewport(1);
    UI_BAR_b.hghlight("Expand3DView");
    UI_BAR_b.update = true;    
  } 
  
  else if (Command_CAPITAL.equals("LOOKORG")) {
    UI_set_to_View_LookAtOrigin(0);
    UI_BAR_b.hghlight("LAO");
    UI_BAR_b.update = true;    
  }   
  else if (Command_CAPITAL.equals("LOOKDIR")) {
    UI_set_to_View_LookAtDirection(0);
    UI_BAR_b.hghlight("LAD");
    UI_BAR_b.update = true;    
  }   
  else if (Command_CAPITAL.equals("LOOKSEL")) {
    UI_set_to_View_LookAtSelection(0);
    UI_BAR_b.hghlight("LAS");
    UI_BAR_b.update = true;    
  }   
  
  else if (Command_CAPITAL.equals("TRUCKZ")) {
    UI_set_to_View_Truck(0);
    UI_BAR_b.hghlight("DIz");
    UI_BAR_b.update = true;
  }   
  else if (Command_CAPITAL.equals("TRUCKX")) {
    UI_set_to_View_Truck(1);
    UI_BAR_b.hghlight("DIx");
    UI_BAR_b.update = true;
  }   
  else if (Command_CAPITAL.equals("TRUCKY")) {
    UI_set_to_View_Truck(2);
    UI_BAR_b.hghlight("DIy");
    UI_BAR_b.update = true;
  }   

  else if (Command_CAPITAL.equals("TROLL")) {
    UI_set_to_View_TargetRoll(0);
    UI_BAR_b.hghlight("TRL");
    UI_BAR_b.update = true;
  }   
  else if (Command_CAPITAL.equals("TROLLZ")) {
    UI_set_to_View_TargetRoll(1);
    UI_BAR_b.hghlight("TRLz");
    UI_BAR_b.update = true;    
  }   
  else if (Command_CAPITAL.equals("TROLLXY")) {
    UI_set_to_View_TargetRoll(2);
    UI_BAR_b.hghlight("TRLxy");
    UI_BAR_b.update = true;    
  }     
  
  else if (Command_CAPITAL.equals("CROLL")) {
    UI_set_to_View_CameraRoll(0);
    UI_BAR_b.hghlight("CRL");
    UI_BAR_b.update = true;   
  }   
  else if (Command_CAPITAL.equals("CROLLZ")) {
    UI_set_to_View_CameraRoll(1);
    UI_BAR_b.hghlight("CRLz");
    UI_BAR_b.update = true;   
  }   
  else if (Command_CAPITAL.equals("CROLLXY")) {
    UI_set_to_View_CameraRoll(2);
    UI_BAR_b.hghlight("CRLxy");
    UI_BAR_b.update = true;   
  }   
  
  
  else if (Command_CAPITAL.equals("ORBIT")) {
    UI_set_to_View_Orbit(0);
    UI_BAR_b.hghlight("OR");
    UI_BAR_b.update = true;   
  }   
  else if (Command_CAPITAL.equals("ORBITZ")) {
    UI_set_to_View_Orbit(1);
    UI_BAR_b.hghlight("ORz");
    UI_BAR_b.update = true;   
  }   
  else if (Command_CAPITAL.equals("ORBITXY")) {
    UI_set_to_View_Orbit(2);
    UI_BAR_b.hghlight("ORxy");
    UI_BAR_b.update = true;   
  }
  
  else if (Command_CAPITAL.equals("LANDORBIT")) {
    UI_set_to_View_LandOrbit(0);
    UI_BAR_b.hghlight("LNOR");
    UI_BAR_b.update = true;   
  }    
  
  else if (Command_CAPITAL.equals("PAN")) {
    UI_set_to_View_Pan(0);
    UI_BAR_b.hghlight("Pan");
    UI_BAR_b.update = true;   
  }  
  else if (Command_CAPITAL.equals("PANX")) {
    UI_set_to_View_Pan(1);
    UI_BAR_b.hghlight("PanX");
    UI_BAR_b.update = true;   
  }  
  else if (Command_CAPITAL.equals("PANY")) {
    UI_set_to_View_Pan(2);
    UI_BAR_b.hghlight("PanY");
    UI_BAR_b.update = true;    
  }  

  else if (Command_CAPITAL.equals("ZOOM")) {
    UI_set_to_View_ZOOM(0);
    UI_BAR_b.hghlight("±ZM");
    UI_BAR_b.update = true;    
  }    
  else if (Command_CAPITAL.equals("NORMALZOOM")) {
    UI_set_to_View_ZOOM(1);
    UI_BAR_b.hghlight("0ZM");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("ORTHOGRAPHIC")) {
    UI_set_to_View_ProjectionType(0);
    UI_BAR_b.hghlight("P<>");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("PERSPECTIVE")) {
    UI_set_to_View_ProjectionType(1);
    UI_BAR_b.hghlight("P><");
    UI_BAR_b.update = true;    
  }    
  else if (Command_CAPITAL.equals("TOP")) {
    UI_set_to_View_3DViewPoint(0);
    UI_BAR_b.hghlight("Top");
    UI_BAR_b.update = true;    
  }    
  else if (Command_CAPITAL.equals("FRONT")) {
    UI_set_to_View_3DViewPoint(1);
    UI_BAR_b.hghlight("Front");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("LEFT")) {
    UI_set_to_View_3DViewPoint(2);
    UI_BAR_b.hghlight("Left");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("BACK")) {
    UI_set_to_View_3DViewPoint(3);
    UI_BAR_b.hghlight("Back");
    UI_BAR_b.update = true;    
  }    
  else if (Command_CAPITAL.equals("RIGHT")) {
    UI_set_to_View_3DViewPoint(4);
    UI_BAR_b.hghlight("Right");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("BOTTOM")) {
    UI_set_to_View_3DViewPoint(5);
    UI_BAR_b.hghlight("Bottom");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("S.W.")) {
    UI_set_to_View_3DViewPoint(6);
    UI_BAR_b.hghlight("S.W.");
    UI_BAR_b.update = true;    
  }    
  else if (Command_CAPITAL.equals("S.E.")) {
    UI_set_to_View_3DViewPoint(7);
    UI_BAR_b.hghlight("S.E.");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("N.E.")) {
    UI_set_to_View_3DViewPoint(8);
    UI_BAR_b.hghlight("N.E.");
    UI_BAR_b.update = true;    
  }  
  else if (Command_CAPITAL.equals("N.W.")) {
    UI_set_to_View_3DViewPoint(9);
    UI_BAR_b.hghlight("N.W.");
    UI_BAR_b.update = true;    
  }    
  

  else if (Command_CAPITAL.equals("SHADE.WIRE")) {
    WIN3D.FacesShade = SHADE.Surface_Wire;
    allFaces.displayEdges = true; //<<<<<<<<<<<<<<<
    WIN3D.update = true;  
  }       
  else if (Command_CAPITAL.equals("SHADE.BASE")) {
    WIN3D.FacesShade = SHADE.Surface_Base;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.WHITE")) {
    WIN3D.FacesShade = SHADE.Surface_White;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.MATERIALS")) {
    WIN3D.FacesShade = SHADE.Surface_Materials;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.GLOBAL")) {
    WIN3D.FacesShade = SHADE.Global_Solar;
    WIN3D.update = true;  
  } 
  else if (Command_CAPITAL.equals("SHADE.REAL")) {
    WIN3D.FacesShade = SHADE.Vertex_Solar;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.SOLID")) {
    WIN3D.FacesShade = SHADE.Vertex_Solid;
    WIN3D.update = true;  
  }           
  else if (Command_CAPITAL.equals("SHADE.ELEVATION")) {
    WIN3D.FacesShade = SHADE.Vertex_Elevation;
    WIN3D.update = true;  
  }      
  else if (Command_CAPITAL.equals("RENDER.VIEWPORT")) {
    SOLARCHVISION_RenderViewport();            
  }     
  else if (Command_CAPITAL.equals("PREBAKE.VIEWPORT")) {
    SOLARCHVISION_preBakeViewport();            
  }             


  else if (Command_CAPITAL.equals("LONLAT")) {
    if (parts.length > 2) {
      
      STATION.setLatitude(float(parts[2]));
      STATION.setLongitude(float(parts[1]));
      
      SOLARCHVISION_update_station(1);
    }
    else {
      return_message = "LonLat ? ?";
    }        
  }      

  
  return return_message;
}

